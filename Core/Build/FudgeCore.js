"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var FudgeCore;
(function (FudgeCore) {
    /**
     * Base class for the different DebugTargets, mainly for technical purpose of inheritance
     */
    class DebugTarget {
        static mergeArguments(_message, ..._args) {
            let out = _message.toString(); //JSON.stringify(_message);
            for (let arg of _args)
                if (arg instanceof Number)
                    out += ", " + arg.toPrecision(2).toString(); //JSON.stringify(arg, null, 2);
                else
                    out += ", " + arg.toString(); //JSON.stringify(arg, null, 2);
            return out;
        }
    }
    FudgeCore.DebugTarget = DebugTarget;
})(FudgeCore || (FudgeCore = {}));
// <reference path="DebugAlert.ts"/>
var FudgeCore;
// <reference path="DebugAlert.ts"/>
(function (FudgeCore) {
    /**
     * The filters corresponding to debug activities, more to come
     */
    let DEBUG_FILTER;
    (function (DEBUG_FILTER) {
        DEBUG_FILTER[DEBUG_FILTER["NONE"] = 0] = "NONE";
        DEBUG_FILTER[DEBUG_FILTER["INFO"] = 1] = "INFO";
        DEBUG_FILTER[DEBUG_FILTER["LOG"] = 2] = "LOG";
        DEBUG_FILTER[DEBUG_FILTER["WARN"] = 4] = "WARN";
        DEBUG_FILTER[DEBUG_FILTER["ERROR"] = 8] = "ERROR";
        DEBUG_FILTER[DEBUG_FILTER["FUDGE"] = 16] = "FUDGE";
        DEBUG_FILTER[DEBUG_FILTER["CLEAR"] = 256] = "CLEAR";
        DEBUG_FILTER[DEBUG_FILTER["GROUP"] = 257] = "GROUP";
        DEBUG_FILTER[DEBUG_FILTER["GROUPCOLLAPSED"] = 258] = "GROUPCOLLAPSED";
        DEBUG_FILTER[DEBUG_FILTER["GROUPEND"] = 260] = "GROUPEND";
        DEBUG_FILTER[DEBUG_FILTER["MESSAGES"] = 31] = "MESSAGES";
        DEBUG_FILTER[DEBUG_FILTER["FORMAT"] = 263] = "FORMAT";
        DEBUG_FILTER[DEBUG_FILTER["ALL"] = 287] = "ALL";
    })(DEBUG_FILTER = FudgeCore.DEBUG_FILTER || (FudgeCore.DEBUG_FILTER = {}));
    FudgeCore.DEBUG_SYMBOL = {
        [DEBUG_FILTER.INFO]: "‚úì",
        [DEBUG_FILTER.LOG]: "‚úé",
        [DEBUG_FILTER.WARN]: "‚ö†",
        [DEBUG_FILTER.ERROR]: "‚ùå",
        [DEBUG_FILTER.FUDGE]: "üé≤"
    };
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
(function (FudgeCore) {
    /**
     * Routing to the standard-console
     */
    let DebugConsole = /** @class */ (() => {
        class DebugConsole extends FudgeCore.DebugTarget {
            /**
             * Displays critical information about failures, which is emphasized e.g. by color
             */
            static fudge(_message, ..._args) {
                console.debug("üé≤", _message, ..._args);
                // let trace: string[] = new Error("Test").stack.split("\n");
                // console.log(trace[4]);
                // console.trace("Test");
            }
        }
        DebugConsole.delegates = {
            [FudgeCore.DEBUG_FILTER.INFO]: console.info,
            [FudgeCore.DEBUG_FILTER.LOG]: console.log,
            [FudgeCore.DEBUG_FILTER.WARN]: console.warn,
            [FudgeCore.DEBUG_FILTER.ERROR]: console.error,
            [FudgeCore.DEBUG_FILTER.FUDGE]: DebugConsole.fudge,
            [FudgeCore.DEBUG_FILTER.CLEAR]: console.clear,
            [FudgeCore.DEBUG_FILTER.GROUP]: console.group,
            [FudgeCore.DEBUG_FILTER.GROUPCOLLAPSED]: console.groupCollapsed,
            [FudgeCore.DEBUG_FILTER.GROUPEND]: console.groupEnd
        };
        return DebugConsole;
    })();
    FudgeCore.DebugConsole = DebugConsole;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
/// <reference path="DebugInterfaces.ts"/>
/// <reference path="DebugConsole.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
/// <reference path="DebugInterfaces.ts"/>
/// <reference path="DebugConsole.ts"/>
(function (FudgeCore) {
    /**
     * The Debug-Class offers functions known from the console-object and additions,
     * routing the information to various [[DebugTargets]] that can be easily defined by the developers and registerd by users
     * Override functions in subclasses of [[DebugTarget]] and register them as their delegates
     */
    let Debug = /** @class */ (() => {
        class Debug {
            // TODO: create filter DEBUG_FILTER.FUDGE solely for messages from FUDGE
            /**
             * De- / Activate a filter for the given DebugTarget.
             */
            static setFilter(_target, _filter) {
                for (let filter in Debug.delegates)
                    Debug.delegates[filter].delete(_target);
                for (let filter in FudgeCore.DEBUG_FILTER) {
                    let parsed = parseInt(filter);
                    if (isNaN(parsed))
                        break;
                    if ([FudgeCore.DEBUG_FILTER.MESSAGES, FudgeCore.DEBUG_FILTER.FORMAT, FudgeCore.DEBUG_FILTER.ALL].indexOf(parsed) != -1)
                        // dont delegate combos... 
                        continue;
                    if (_filter & parsed)
                        Debug.delegates[parsed].set(_target, _target.delegates[parsed]);
                }
            }
            /**
             * Info(...) displays additional information with low priority
             */
            static info(_message, ..._args) {
                Debug.delegate(FudgeCore.DEBUG_FILTER.INFO, _message, _args);
            }
            /**
             * Displays information with medium priority
             */
            static log(_message, ..._args) {
                Debug.delegate(FudgeCore.DEBUG_FILTER.LOG, _message, _args);
            }
            /**
             * Displays information about non-conformities in usage, which is emphasized e.g. by color
             */
            static warn(_message, ..._args) {
                Debug.delegate(FudgeCore.DEBUG_FILTER.WARN, _message, _args);
            }
            /**
             * Displays critical information about failures, which is emphasized e.g. by color
             */
            static error(_message, ..._args) {
                Debug.delegate(FudgeCore.DEBUG_FILTER.ERROR, _message, _args);
            }
            /**
             * Displays messages from FUDGE
             */
            static fudge(_message, ..._args) {
                Debug.delegate(FudgeCore.DEBUG_FILTER.FUDGE, _message, _args);
            }
            /**
             * Clears the output and removes previous messages if possible
             */
            static clear() {
                Debug.delegate(FudgeCore.DEBUG_FILTER.CLEAR, null, null);
            }
            /**
             * Opens a new group for messages
             */
            static group(_name) {
                Debug.delegate(FudgeCore.DEBUG_FILTER.GROUP, _name, null);
            }
            /**
             * Opens a new group for messages that is collapsed at first
             */
            static groupCollapsed(_name) {
                Debug.delegate(FudgeCore.DEBUG_FILTER.GROUPCOLLAPSED, _name, null);
            }
            /**
             * Closes the youngest group
             */
            static groupEnd() {
                Debug.delegate(FudgeCore.DEBUG_FILTER.GROUPEND, null, null);
            }
            /**
             * Lookup all delegates registered to the filter and call them using the given arguments
             */
            static delegate(_filter, _message, _args) {
                let delegates = Debug.delegates[_filter];
                for (let delegate of delegates.values())
                    if (delegate)
                        if (_args && _args.length > 0)
                            delegate(_message, ..._args);
                        else
                            delegate(_message);
            }
            /**
             * setup routing to standard console
             */
            static setupConsole() {
                let result = {};
                let filters = [
                    FudgeCore.DEBUG_FILTER.INFO, FudgeCore.DEBUG_FILTER.LOG, FudgeCore.DEBUG_FILTER.WARN, FudgeCore.DEBUG_FILTER.ERROR, FudgeCore.DEBUG_FILTER.FUDGE,
                    FudgeCore.DEBUG_FILTER.CLEAR, FudgeCore.DEBUG_FILTER.GROUP, FudgeCore.DEBUG_FILTER.GROUPCOLLAPSED, FudgeCore.DEBUG_FILTER.GROUPEND
                ];
                for (let filter of filters)
                    result[filter] = new Map([[FudgeCore.DebugConsole, FudgeCore.DebugConsole.delegates[filter]]]);
                return result;
            }
        }
        /**
         * For each set filter, this associative array keeps references to the registered delegate functions of the chosen [[DebugTargets]]
         */
        Debug.delegates = Debug.setupConsole();
        return Debug;
    })();
    FudgeCore.Debug = Debug;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class EventTarget∆í extends EventTarget {
        addEventListener(_type, _handler, _options) {
            super.addEventListener(_type, _handler, _options);
        }
        removeEventListener(_type, _handler, _options) {
            super.removeEventListener(_type, _handler, _options);
        }
        dispatchEvent(_event) {
            return super.dispatchEvent(_event);
        }
    }
    FudgeCore.EventTarget∆í = EventTarget∆í;
    /**
     * Base class for EventTarget singletons, which are fixed entities in the structure of Fudge, such as the core loop
     */
    let EventTargetStatic = /** @class */ (() => {
        class EventTargetStatic extends EventTarget∆í {
            constructor() {
                super();
            }
            static addEventListener(_type, _handler) {
                EventTargetStatic.targetStatic.addEventListener(_type, _handler);
            }
            static removeEventListener(_type, _handler) {
                EventTargetStatic.targetStatic.removeEventListener(_type, _handler);
            }
            static dispatchEvent(_event) {
                EventTargetStatic.targetStatic.dispatchEvent(_event);
                return true;
            }
        }
        EventTargetStatic.targetStatic = new EventTargetStatic();
        return EventTargetStatic;
    })();
    FudgeCore.EventTargetStatic = EventTargetStatic;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="../Event/Event.ts"/>
var FudgeCore;
// / <reference path="../Event/Event.ts"/>
(function (FudgeCore) {
    // export interface MutatorForComponent extends Mutator { readonly forUserComponent: null; }
    /**
     * Collect applicable attributes of the instance and copies of their values in a Mutator-object
     */
    function getMutatorOfArbitrary(_object) {
        let mutator = {};
        let attributes = Reflect.ownKeys(Reflect.getPrototypeOf(_object));
        for (let attribute of attributes) {
            let value = Reflect.get(_object, attribute);
            if (value instanceof Function)
                continue;
            // if (value instanceof Object && !(value instanceof Mutable))
            //   continue;
            mutator[attribute.toString()] = value;
        }
        return mutator;
    }
    FudgeCore.getMutatorOfArbitrary = getMutatorOfArbitrary;
    /**
     * Base class for all types being mutable using [[Mutator]]-objects, thus providing and using interfaces created at runtime.
     * Mutables provide a [[Mutator]] that is build by collecting all object-properties that are either of a primitive type or again Mutable.
     * Subclasses can either reduce the standard [[Mutator]] built by this base class by deleting properties or implement an individual getMutator-method.
     * The provided properties of the [[Mutator]] must match public properties or getters/setters of the object.
     * Otherwise, they will be ignored if not handled by an override of the mutate-method in the subclass and throw errors in an automatically generated user-interface for the object.
     */
    class Mutable extends FudgeCore.EventTarget∆í {
        /**
         * Retrieves the type of this mutable subclass as the name of the runtime class
         * @returns The type of the mutable
         */
        get type() {
            return this.constructor.name;
        }
        /**
         * Collect applicable attributes of the instance and copies of their values in a Mutator-object
         */
        getMutator() {
            let mutator = {};
            // collect primitive and mutable attributes
            for (let attribute in this) {
                let value = this[attribute];
                if (value instanceof Function)
                    continue;
                if (value instanceof Object && !(value instanceof Mutable) && !(value.hasOwnProperty("idResource")))
                    continue;
                mutator[attribute] = this[attribute];
            }
            // mutator can be reduced but not extended!
            Object.preventExtensions(mutator);
            // delete unwanted attributes
            this.reduceMutator(mutator);
            // replace references to mutable objects with references to copies
            for (let attribute in mutator) {
                let value = mutator[attribute];
                if (value instanceof Mutable)
                    mutator[attribute] = value.getMutator();
            }
            return mutator;
        }
        /**
         * Collect the attributes of the instance and their values applicable for animation.
         * Basic functionality is identical to [[getMutator]], returned mutator should then be reduced by the subclassed instance
         */
        getMutatorForAnimation() {
            return this.getMutator();
        }
        /**
         * Collect the attributes of the instance and their values applicable for the user interface.
         * Basic functionality is identical to [[getMutator]], returned mutator should then be reduced by the subclassed instance
         */
        getMutatorForUserInterface() {
            return this.getMutator();
        }
        /**
         * Collect the attributes of the instance and their values applicable for indiviualization by the component.
         * Basic functionality is identical to [[getMutator]], returned mutator should then be reduced by the subclassed instance
         */
        // public getMutatorForComponent(): MutatorForComponent {
        //     return <MutatorForComponent>this.getMutator();
        // }
        /**
         * Returns an associative array with the same attributes as the given mutator, but with the corresponding types as string-values
         * Does not recurse into objects!
         * @param _mutator
         */
        getMutatorAttributeTypes(_mutator) {
            let types = {};
            for (let attribute in _mutator) {
                let type = null;
                let value = _mutator[attribute];
                if (_mutator[attribute] != undefined)
                    if (typeof (value) == "object")
                        type = this[attribute].constructor.name;
                    else if (typeof (value) == "function")
                        type = value["name"];
                    else
                        type = _mutator[attribute].constructor.name;
                types[attribute] = type;
            }
            return types;
        }
        /**
         * Updates the values of the given mutator according to the current state of the instance
         * @param _mutator
         */
        updateMutator(_mutator) {
            for (let attribute in _mutator) {
                let value = _mutator[attribute];
                if (value instanceof Mutable)
                    value = value.getMutator();
                else
                    _mutator[attribute] = this[attribute];
            }
        }
        /**
         * Updates the attribute values of the instance according to the state of the mutator. Must be protected...!
         * @param _mutator
         */
        mutate(_mutator) {
            // TODO: don't assign unknown properties
            for (let attribute in _mutator) {
                let value = _mutator[attribute];
                let mutant = this[attribute];
                if (mutant instanceof Mutable)
                    mutant.mutate(value);
                else
                    this[attribute] = value;
            }
            this.dispatchEvent(new Event("mutate" /* MUTATE */));
        }
    }
    FudgeCore.Mutable = Mutable;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Handles the external serialization and deserialization of [[Serializable]] objects. The internal process is handled by the objects themselves.
     * A [[Serialization]] object can be created from a [[Serializable]] object and a JSON-String may be created from that.
     * Vice versa, a JSON-String can be parsed to a [[Serialization]] which can be deserialized to a [[Serializable]] object.
     * ```plaintext
     *  [Serializable] ‚Üí (serialize) ‚Üí [Serialization] ‚Üí (stringify)
     *                                                        ‚Üì
     *                                                    [String]
     *                                                        ‚Üì
     *  [Serializable] ‚Üê (deserialize) ‚Üê [Serialization] ‚Üê (parse)
     * ```
     * While the internal serialize/deserialize methods of the objects care of the selection of information needed to recreate the object and its structure,
     * the [[Serializer]] keeps track of the namespaces and classes in order to recreate [[Serializable]] objects. The general structure of a [[Serialization]] is as follows
     * ```plaintext
     * {
     *      namespaceName.className: {
     *          propertyName: propertyValue,
     *          ...,
     *          propertyNameOfReference: SerializationOfTheReferencedObject,
     *          ...,
     *          constructorNameOfSuperclass: SerializationOfSuperClass
     *      }
     * }
     * ```
     * Since the instance of the superclass is created automatically when an object is created,
     * the SerializationOfSuperClass omits the the namespaceName.className key and consists only of its value.
     * The constructorNameOfSuperclass is given instead as a property name in the serialization of the subclass.
     */
    let Serializer = /** @class */ (() => {
        class Serializer {
            /**
             * Registers a namespace to the [[Serializer]], to enable automatic instantiation of classes defined within
             * @param _namespace
             */
            static registerNamespace(_namespace) {
                for (let name in Serializer.namespaces)
                    if (Serializer.namespaces[name] == _namespace)
                        return;
                let name = Serializer.findNamespaceIn(_namespace, window);
                if (!name)
                    for (let parentName in Serializer.namespaces) {
                        name = Serializer.findNamespaceIn(_namespace, Serializer.namespaces[parentName]);
                        if (name) {
                            name = parentName + "." + name;
                            break;
                        }
                    }
                if (!name)
                    throw new Error("Namespace not found. Maybe parent namespace hasn't been registered before?");
                Serializer.namespaces[name] = _namespace;
            }
            /**
             * Returns a javascript object representing the serializable FUDGE-object given,
             * including attached components, children, superclass-objects all information needed for reconstruction
             * @param _object An object to serialize, implementing the [[Serializable]] interface
             */
            static serialize(_object) {
                let serialization = {};
                // TODO: save the namespace with the constructors name
                // serialization[_object.constructor.name] = _object.serialize();
                let path = this.getFullPath(_object);
                if (!path)
                    throw new Error(`Namespace of serializable object of type ${_object.constructor.name} not found. Maybe the namespace hasn't been registered or the class not exported?`);
                serialization[path] = _object.serialize();
                return serialization;
                // return _object.serialize();
            }
            /**
             * Returns a FUDGE-object reconstructed from the information in the [[Serialization]] given,
             * including attached components, children, superclass-objects
             * @param _serialization
             */
            static deserialize(_serialization) {
                let reconstruct;
                try {
                    // loop constructed solely to access type-property. Only one expected!
                    for (let path in _serialization) {
                        // reconstruct = new (<General>Fudge)[typeName];
                        reconstruct = Serializer.reconstruct(path);
                        reconstruct = reconstruct.deserialize(_serialization[path]);
                        return reconstruct;
                    }
                }
                catch (_error) {
                    throw new Error("Deserialization failed: " + _error);
                }
                return null;
            }
            //TODO: implement prettifier to make JSON-Stringification of serializations more readable, e.g. placing x, y and z in one line
            static prettify(_json) { return _json; }
            /**
             * Returns a formatted, human readable JSON-String, representing the given [[Serializaion]] that may have been created by [[Serializer]].serialize
             * @param _serialization
             */
            static stringify(_serialization) {
                // adjustments to serialization can be made here before stringification, if desired
                let json = JSON.stringify(_serialization, null, 2);
                let pretty = Serializer.prettify(json);
                return pretty;
            }
            /**
             * Returns a [[Serialization]] created from the given JSON-String. Result may be passed to [[Serializer]].deserialize
             * @param _json
             */
            static parse(_json) {
                return JSON.parse(_json);
            }
            /**
             * Creates an object of the class defined with the full path including the namespaceName(s) and the className seperated by dots(.)
             * @param _path
             */
            static reconstruct(_path) {
                let typeName = _path.substr(_path.lastIndexOf(".") + 1);
                let namespace = Serializer.getNamespace(_path);
                if (!namespace)
                    throw new Error(`Namespace of serializable object of type ${typeName} not found. Maybe the namespace hasn't been registered?`);
                let reconstruction = new namespace[typeName];
                return reconstruction;
            }
            /**
             * Returns the full path to the class of the object, if found in the registered namespaces
             * @param _object
             */
            static getFullPath(_object) {
                let typeName = _object.constructor.name;
                // Debug.log("Searching namespace of: " + typeName);
                for (let namespaceName in Serializer.namespaces) {
                    let found = Serializer.namespaces[namespaceName][typeName];
                    if (found && _object instanceof found)
                        return namespaceName + "." + typeName;
                }
                return null;
            }
            /**
             * Returns the namespace-object defined within the full path, if registered
             * @param _path
             */
            static getNamespace(_path) {
                let namespaceName = _path.substr(0, _path.lastIndexOf("."));
                return Serializer.namespaces[namespaceName];
            }
            /**
             * Finds the namespace-object in properties of the parent-object (e.g. window), if present
             * @param _namespace
             * @param _parent
             */
            static findNamespaceIn(_namespace, _parent) {
                for (let prop in _parent)
                    if (_parent[prop] == _namespace)
                        return prop;
                return null;
            }
        }
        /** In order for the Serializer to create class instances, it needs access to the appropriate namespaces */
        Serializer.namespaces = { "∆í": FudgeCore };
        return Serializer;
    })();
    FudgeCore.Serializer = Serializer;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class RenderInjector {
        static inject(_constructor, _injector) {
            let injection = Reflect.get(_injector, "inject" + _constructor.name);
            if (!injection) {
                console.error("No injection decorator defined for " + _constructor.name);
            }
            Object.defineProperty(_constructor.prototype, "useRenderData", {
                value: injection
            });
        }
    }
    FudgeCore.RenderInjector = RenderInjector;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class RenderInjectorShader {
        static decorate(_constructor) {
            Object.defineProperty(_constructor, "useProgram", {
                value: RenderInjectorShader.useProgram
            });
            Object.defineProperty(_constructor, "deleteProgram", {
                value: RenderInjectorShader.deleteProgram
            });
            Object.defineProperty(_constructor, "createProgram", {
                value: RenderInjectorShader.createProgram
            });
        }
        static useProgram() {
            if (!this.program)
                this.createProgram();
            let crc3 = FudgeCore.RenderOperator.getRenderingContext();
            crc3.useProgram(this.program);
            crc3.enableVertexAttribArray(this.attributes["a_position"]);
        }
        static deleteProgram() {
            let crc3 = FudgeCore.RenderOperator.getRenderingContext();
            if (this.program) {
                crc3.deleteProgram(this.program);
                delete this.attributes;
                delete this.uniforms;
            }
        }
        static createProgram() {
            FudgeCore.Debug.fudge("Create shader program", this.name);
            let crc3 = FudgeCore.RenderOperator.getRenderingContext();
            let program = crc3.createProgram();
            try {
                crc3.attachShader(program, FudgeCore.RenderOperator.assert(compileShader(this.getVertexShaderSource(), WebGL2RenderingContext.VERTEX_SHADER)));
                crc3.attachShader(program, FudgeCore.RenderOperator.assert(compileShader(this.getFragmentShaderSource(), WebGL2RenderingContext.FRAGMENT_SHADER)));
                crc3.linkProgram(program);
                let error = FudgeCore.RenderOperator.assert(crc3.getProgramInfoLog(program));
                if (error !== "") {
                    throw new Error("Error linking Shader: " + error);
                }
                this.program = program;
                this.attributes = detectAttributes();
                this.uniforms = detectUniforms();
            }
            catch (_error) {
                FudgeCore.Debug.error(_error);
                debugger;
            }
            function compileShader(_shaderCode, _shaderType) {
                let webGLShader = crc3.createShader(_shaderType);
                crc3.shaderSource(webGLShader, _shaderCode);
                crc3.compileShader(webGLShader);
                let error = FudgeCore.RenderOperator.assert(crc3.getShaderInfoLog(webGLShader));
                if (error !== "") {
                    throw new Error("Error compiling shader: " + error);
                }
                // Check for any compilation errors.
                if (!crc3.getShaderParameter(webGLShader, WebGL2RenderingContext.COMPILE_STATUS)) {
                    alert(crc3.getShaderInfoLog(webGLShader));
                    return null;
                }
                return webGLShader;
            }
            function detectAttributes() {
                let detectedAttributes = {};
                let attributeCount = crc3.getProgramParameter(program, WebGL2RenderingContext.ACTIVE_ATTRIBUTES);
                for (let i = 0; i < attributeCount; i++) {
                    let attributeInfo = FudgeCore.RenderOperator.assert(crc3.getActiveAttrib(program, i));
                    if (!attributeInfo) {
                        break;
                    }
                    detectedAttributes[attributeInfo.name] = crc3.getAttribLocation(program, attributeInfo.name);
                }
                return detectedAttributes;
            }
            function detectUniforms() {
                let detectedUniforms = {};
                let uniformCount = crc3.getProgramParameter(program, WebGL2RenderingContext.ACTIVE_UNIFORMS);
                for (let i = 0; i < uniformCount; i++) {
                    let info = FudgeCore.RenderOperator.assert(crc3.getActiveUniform(program, i));
                    if (!info) {
                        break;
                    }
                    detectedUniforms[info.name] = FudgeCore.RenderOperator.assert(crc3.getUniformLocation(program, info.name));
                }
                return detectedUniforms;
            }
        }
    }
    FudgeCore.RenderInjectorShader = RenderInjectorShader;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class RenderInjectorCoat extends FudgeCore.RenderInjector {
        static decorate(_constructor) {
            FudgeCore.RenderInjector.inject(_constructor, RenderInjectorCoat);
        }
        static injectCoatColored(_shader, _cmpMaterial) {
            let colorUniformLocation = _shader.uniforms["u_color"];
            let color = FudgeCore.Color.MULTIPLY(this.color, _cmpMaterial.clrPrimary);
            FudgeCore.RenderOperator.getRenderingContext().uniform4fv(colorUniformLocation, color.getArray());
        }
        static injectCoatTextured(_shader, _cmpMaterial) {
            let crc3 = FudgeCore.RenderOperator.getRenderingContext();
            if (this.renderData) {
                // buffers exist
                let colorUniformLocation = _shader.uniforms["u_color"];
                let color = FudgeCore.Color.MULTIPLY(this.color, _cmpMaterial.clrPrimary);
                FudgeCore.RenderOperator.getRenderingContext().uniform4fv(colorUniformLocation, color.getArray());
                crc3.activeTexture(WebGL2RenderingContext.TEXTURE0);
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, this.renderData["texture0"]);
                crc3.uniform1i(_shader.uniforms["u_texture"], 0);
                crc3.uniformMatrix3fv(_shader.uniforms["u_pivot"], false, _cmpMaterial.pivot.get());
            }
            else {
                this.renderData = {};
                // TODO: check if all WebGL-Creations are asserted
                const texture = FudgeCore.RenderManager.assert(crc3.createTexture());
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, texture);
                try {
                    crc3.texImage2D(crc3.TEXTURE_2D, 0, crc3.RGBA, crc3.RGBA, crc3.UNSIGNED_BYTE, this.texture.image);
                    crc3.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.UNSIGNED_BYTE, this.texture.image);
                }
                catch (_error) {
                    FudgeCore.Debug.error(_error);
                }
                crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, WebGL2RenderingContext.NEAREST);
                crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.NEAREST);
                crc3.generateMipmap(crc3.TEXTURE_2D);
                this.renderData["texture0"] = texture;
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
                this.useRenderData(_shader, _cmpMaterial);
            }
        }
        static injectCoatMatCap(_shader, _cmpMaterial) {
            let crc3 = FudgeCore.RenderOperator.getRenderingContext();
            let colorUniformLocation = _shader.uniforms["u_tint_color"];
            let { r, g, b, a } = this.color;
            let tintColorArray = new Float32Array([r, g, b, a]);
            crc3.uniform4fv(colorUniformLocation, tintColorArray);
            let floatUniformLocation = _shader.uniforms["shade_smooth"];
            let shadeSmooth = this.shadeSmooth;
            crc3.uniform1i(floatUniformLocation, shadeSmooth);
            if (this.renderData) {
                // buffers exist
                crc3.activeTexture(WebGL2RenderingContext.TEXTURE0);
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, this.renderData["texture0"]);
                crc3.uniform1i(_shader.uniforms["u_texture"], 0);
            }
            else {
                this.renderData = {};
                // TODO: check if all WebGL-Creations are asserted
                const texture = FudgeCore.RenderManager.assert(crc3.createTexture());
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, texture);
                try {
                    crc3.texImage2D(crc3.TEXTURE_2D, 0, crc3.RGBA, crc3.RGBA, crc3.UNSIGNED_BYTE, this.texture.image);
                    crc3.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.UNSIGNED_BYTE, this.texture.image);
                }
                catch (_error) {
                    FudgeCore.Debug.error(_error);
                }
                crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, WebGL2RenderingContext.NEAREST);
                crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.NEAREST);
                crc3.generateMipmap(crc3.TEXTURE_2D);
                this.renderData["texture0"] = texture;
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
                this.useRenderData(_shader, _cmpMaterial);
            }
        }
    }
    FudgeCore.RenderInjectorCoat = RenderInjectorCoat;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class RenderInjectorMesh {
        static decorate(_constructor) {
            Object.defineProperty(_constructor.prototype, "useRenderBuffers", {
                value: RenderInjectorMesh.useRenderBuffers
            });
            Object.defineProperty(_constructor.prototype, "createRenderBuffers", {
                value: RenderInjectorMesh.createRenderBuffers
            });
            Object.defineProperty(_constructor.prototype, "deleteRenderBuffers", {
                value: RenderInjectorMesh.deleteRenderBuffers
            });
        }
        static createRenderBuffers() {
            // console.log("createRenderBuffers", this);
            // return;
            let crc3 = FudgeCore.RenderOperator.getRenderingContext();
            let vertices = FudgeCore.RenderOperator.assert(crc3.createBuffer());
            crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, vertices);
            crc3.bufferData(WebGL2RenderingContext.ARRAY_BUFFER, this.vertices, WebGL2RenderingContext.STATIC_DRAW);
            let indices = FudgeCore.RenderOperator.assert(crc3.createBuffer());
            crc3.bindBuffer(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, indices);
            crc3.bufferData(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, this.indices, WebGL2RenderingContext.STATIC_DRAW);
            let textureUVs = crc3.createBuffer();
            crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, textureUVs);
            crc3.bufferData(WebGL2RenderingContext.ARRAY_BUFFER, this.textureUVs, WebGL2RenderingContext.STATIC_DRAW);
            let normalsFace = FudgeCore.RenderOperator.assert(crc3.createBuffer());
            crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, normalsFace);
            crc3.bufferData(WebGL2RenderingContext.ARRAY_BUFFER, this.normalsFace, WebGL2RenderingContext.STATIC_DRAW);
            let renderBuffers = {
                vertices: vertices,
                indices: indices,
                nIndices: this.getIndexCount(),
                textureUVs: textureUVs,
                normalsFace: normalsFace
            };
            this.renderBuffers = renderBuffers;
        }
        static useRenderBuffers(_shader, _world, _projection, _id) {
            // console.log("useRenderBuffers", this);
            // return;
            let crc3 = FudgeCore.RenderOperator.getRenderingContext();
            let aPosition = _shader.attributes["a_position"];
            crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.renderBuffers.vertices);
            crc3.enableVertexAttribArray(aPosition);
            FudgeCore.RenderOperator.setAttributeStructure(aPosition, FudgeCore.Mesh.getBufferSpecification());
            crc3.bindBuffer(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, this.renderBuffers.indices);
            let uProjection = _shader.uniforms["u_projection"];
            crc3.uniformMatrix4fv(uProjection, false, _projection.get());
            // feed in face normals if shader accepts u_world. 
            let uWorld = _shader.uniforms["u_world"];
            if (uWorld) {
                crc3.uniformMatrix4fv(uWorld, false, _world.get());
            }
            let aNormal = _shader.attributes["a_normal"];
            if (aNormal) {
                crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.renderBuffers.normalsFace);
                crc3.enableVertexAttribArray(aNormal);
                FudgeCore.RenderOperator.setAttributeStructure(aNormal, FudgeCore.Mesh.getBufferSpecification());
            }
            // feed in texture coordinates if shader accepts a_textureUVs
            let aTextureUVs = _shader.attributes["a_textureUVs"];
            if (aTextureUVs) {
                crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.renderBuffers.textureUVs);
                crc3.enableVertexAttribArray(aTextureUVs); // enable the buffer
                crc3.vertexAttribPointer(aTextureUVs, 2, WebGL2RenderingContext.FLOAT, false, 0, 0);
            }
            // feed in an id of the node if shader accepts u_id. Used for picking
            let uId = _shader.uniforms["u_id"];
            if (uId)
                FudgeCore.RenderOperator.getRenderingContext().uniform1i(uId, _id);
        }
        static deleteRenderBuffers(_renderBuffers) {
            // console.log("deleteRenderBuffers", this);
            // return;
            let crc3 = FudgeCore.RenderOperator.getRenderingContext();
            if (_renderBuffers) {
                crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, null);
                crc3.deleteBuffer(_renderBuffers.vertices);
                crc3.deleteBuffer(_renderBuffers.textureUVs);
                crc3.bindBuffer(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, null);
                crc3.deleteBuffer(_renderBuffers.indices);
            }
        }
    }
    FudgeCore.RenderInjectorMesh = RenderInjectorMesh;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Keeps a depot of objects that have been marked for reuse, sorted by type.
     * Using [[Recycler]] reduces load on the carbage collector and thus supports smooth performance
     */
    let Recycler = /** @class */ (() => {
        class Recycler {
            /**
             * Fetches an object of the requested type from the depot, or returns a new one, if the depot was empty
             * @param _T The class identifier of the desired object
             */
            static get(_T) {
                let key = _T.name;
                let instances = Recycler.depot[key];
                if (instances && instances.length > 0)
                    return instances.pop();
                else
                    return new _T();
            }
            /**
             * Returns a reference to an object of the requested type in the depot, but does not remove it there.
             * If no object of the requested type was in the depot, one is created, stored and borrowed.
             * For short term usage of objects in a local scope, when there will be no other call to Recycler.get or .borrow!
             * @param _T The class identifier of the desired object
             */
            static borrow(_T) {
                let t;
                let key = _T.name;
                let instances = Recycler.depot[key];
                if (!instances || instances.length == 0) {
                    t = new _T();
                    Recycler.store(t);
                    return t;
                }
                return instances[0];
            }
            /**
             * Stores the object in the depot for later recycling. Users are responsible for throwing in objects that are about to loose scope and are not referenced by any other
             * @param _instance
             */
            static store(_instance) {
                let key = _instance.constructor.name;
                //Debug.log(key);
                let instances = Recycler.depot[key] || [];
                instances.push(_instance);
                Recycler.depot[key] = instances;
                // Debug.log(`ObjectManager.depot[${key}]: ${ObjectManager.depot[key].length}`);
                //Debug.log(this.depot);
            }
            /**
             * Emptys the depot of a given type, leaving the objects for the garbage collector. May result in a short stall when many objects were in
             * @param _T
             */
            static dump(_T) {
                let key = _T.name;
                Recycler.depot[key] = [];
            }
            /**
             * Emptys all depots, leaving all objects to the garbage collector. May result in a short stall when many objects were in
             */
            static dumpAll() {
                Recycler.depot = {};
            }
        }
        Recycler.depot = {};
        return Recycler;
    })();
    FudgeCore.Recycler = Recycler;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Stores and manipulates a twodimensional vector comprised of the components x and y
     * ```plaintext
     *            +y
     *             |__ +x
     * ```
     * @authors Lukas Scheuerle, Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Vector2 extends FudgeCore.Mutable {
        constructor(_x = 0, _y = 0) {
            super();
            this.data = new Float32Array([_x, _y]);
        }
        get x() {
            return this.data[0];
        }
        get y() {
            return this.data[1];
        }
        set x(_x) {
            this.data[0] = _x;
        }
        set y(_y) {
            this.data[1] = _y;
        }
        /**
         * Returns the length of the vector
         */
        get magnitude() {
            return Math.hypot(...this.data);
        }
        /**
         * Returns the square of the magnitude of the vector without calculating a square root. Faster for simple proximity evaluation.
         */
        get magnitudeSquared() {
            return Vector2.DOT(this, this);
        }
        /**
         * A shorthand for writing `new Vector2(0, 0)`.
         * @returns A new vector with the values (0, 0)
         */
        static ZERO() {
            let vector = new Vector2();
            return vector;
        }
        /**
         * A shorthand for writing `new Vector2(_scale, _scale)`.
         * @param _scale the scale of the vector. Default: 1
         */
        static ONE(_scale = 1) {
            let vector = new Vector2(_scale, _scale);
            return vector;
        }
        /**
         * A shorthand for writing `new Vector2(0, y)`.
         * @param _scale The number to write in the y coordinate. Default: 1
         * @returns A new vector with the values (0, _scale)
         */
        static Y(_scale = 1) {
            let vector = new Vector2(0, _scale);
            return vector;
        }
        /**
         * A shorthand for writing `new Vector2(x, 0)`.
         * @param _scale The number to write in the x coordinate. Default: 1
         * @returns A new vector with the values (_scale, 0)
         */
        static X(_scale = 1) {
            let vector = new Vector2(_scale, 0);
            return vector;
        }
        static TRANSFORMATION(_vector, _matrix, _includeTranslation = true) {
            let result = new Vector2();
            let m = _matrix.get();
            let [x, y] = _vector.get();
            result.x = m[0] * x + m[3] * y;
            result.y = m[1] * x + m[4] * y;
            if (_includeTranslation) {
                result.add(_matrix.translation);
            }
            return result;
        }
        /**
         * Normalizes a given vector to the given length without editing the original vector.
         * @param _vector the vector to normalize
         * @param _length the length of the resulting vector. defaults to 1
         * @returns a new vector representing the normalised vector scaled by the given length
         */
        static NORMALIZATION(_vector, _length = 1) {
            let vector = Vector2.ZERO();
            try {
                let [x, y] = _vector.data;
                let factor = _length / Math.hypot(x, y);
                vector.data = new Float32Array([_vector.x * factor, _vector.y * factor]);
            }
            catch (_error) {
                FudgeCore.Debug.fudge(_error);
            }
            return vector;
        }
        /**
         * Scales a given vector by a given scale without changing the original vector
         * @param _vector The vector to scale.
         * @param _scale The scale to scale with.
         * @returns A new vector representing the scaled version of the given vector
         */
        static SCALE(_vector, _scale) {
            let vector = new Vector2(_vector.x * _scale, _vector.y * _scale);
            return vector;
        }
        /**
         * Sums up multiple vectors.
         * @param _vectors A series of vectors to sum up
         * @returns A new vector representing the sum of the given vectors
         */
        static SUM(..._vectors) {
            let result = new Vector2();
            for (let vector of _vectors)
                result.data = new Float32Array([result.x + vector.x, result.y + vector.y]);
            return result;
        }
        /**
         * Subtracts two vectors.
         * @param _a The vector to subtract from.
         * @param _b The vector to subtract.
         * @returns A new vector representing the difference of the given vectors
         */
        static DIFFERENCE(_a, _b) {
            let vector = new Vector2;
            vector.data = new Float32Array([_a.x - _b.x, _a.y - _b.y]);
            return vector;
        }
        /**
         * Computes the dotproduct of 2 vectors.
         * @param _a The vector to multiply.
         * @param _b The vector to multiply by.
         * @returns A new vector representing the dotproduct of the given vectors
         */
        static DOT(_a, _b) {
            let scalarProduct = _a.x * _b.x + _a.y * _b.y;
            return scalarProduct;
        }
        /**
         * Calculates the cross product of two Vectors. Due to them being only 2 Dimensional, the result is a single number,
         * which implicitly is on the Z axis. It is also the signed magnitude of the result.
         * @param _a Vector to compute the cross product on
         * @param _b Vector to compute the cross product with
         * @returns A number representing result of the cross product.
         */
        static CROSSPRODUCT(_a, _b) {
            let crossProduct = _a.x * _b.y - _a.y * _b.x;
            return crossProduct;
        }
        /**
         * Calculates the orthogonal vector to the given vector. Rotates counterclockwise by default.
         * ```plaintext
         * ‚Üë => ‚Üê => ‚Üì => ‚Üí => ‚Üë
         * ```
         * @param _vector Vector to get the orthogonal equivalent of
         * @param _clockwise Should the rotation be clockwise instead of the default counterclockwise? default: false
         * @returns A Vector that is orthogonal to and has the same magnitude as the given Vector.
         */
        static ORTHOGONAL(_vector, _clockwise = false) {
            if (_clockwise)
                return new Vector2(_vector.y, -_vector.x);
            else
                return new Vector2(-_vector.y, _vector.x);
        }
        /**
         * Returns true if the coordinates of this and the given vector are to be considered identical within the given tolerance
         * TODO: examine, if tolerance as criterium for the difference is appropriate with very large coordinate values or if _tolerance should be multiplied by coordinate value
         */
        equals(_compare, _tolerance = Number.EPSILON) {
            if (Math.abs(this.x - _compare.x) > _tolerance)
                return false;
            if (Math.abs(this.y - _compare.y) > _tolerance)
                return false;
            return true;
        }
        /**
         * Adds the given vector to the executing vector, changing the executor.
         * @param _addend The vector to add.
         */
        add(_addend) {
            this.data = new Vector2(_addend.x + this.x, _addend.y + this.y).data;
        }
        /**
         * Subtracts the given vector from the executing vector, changing the executor.
         * @param _subtrahend The vector to subtract.
         */
        subtract(_subtrahend) {
            this.data = new Vector2(this.x - _subtrahend.x, this.y - _subtrahend.y).data;
        }
        /**
         * Scales the Vector by the _scale.
         * @param _scale The scale to multiply the vector with.
         */
        scale(_scale) {
            this.data = new Vector2(_scale * this.x, _scale * this.y).data;
        }
        /**
         * Normalizes the vector.
         * @param _length A modificator to get a different length of normalized vector.
         */
        normalize(_length = 1) {
            this.data = Vector2.NORMALIZATION(this, _length).data;
        }
        /**
         * Sets the Vector to the given parameters. Ommitted parameters default to 0.
         * @param _x new x to set
         * @param _y new y to set
         */
        set(_x = 0, _y = 0) {
            this.data = new Float32Array([_x, _y]);
        }
        /**
         * @returns An array of the data of the vector
         */
        get() {
            return new Float32Array(this.data);
        }
        /**
         * @returns A deep copy of the vector.
         */
        get copy() {
            return new Vector2(this.x, this.y);
        }
        transform(_matrix, _includeTranslation = true) {
            this.data = Vector2.TRANSFORMATION(this, _matrix, _includeTranslation).data;
        }
        /**
         * Adds a z-component of the given magnitude (default=0) to the vector and returns a new Vector3
         */
        toVector3(_z = 0) {
            return new FudgeCore.Vector3(this.x, this.y, z);
        }
        toString() {
            let result = `(${this.x.toPrecision(5)}, ${this.y.toPrecision(5)})`;
            return result;
        }
        getMutator() {
            let mutator = {
                x: this.data[0], y: this.data[1]
            };
            return mutator;
        }
        reduceMutator(_mutator) { }
    }
    FudgeCore.Vector2 = Vector2;
})(FudgeCore || (FudgeCore = {}));
///<reference path="../Engine/Recycler.ts"/>
///<reference path="Vector2.ts"/>
var FudgeCore;
///<reference path="../Engine/Recycler.ts"/>
///<reference path="Vector2.ts"/>
(function (FudgeCore) {
    /**
     * Defines the origin of a rectangle
     */
    let ORIGIN2D;
    (function (ORIGIN2D) {
        ORIGIN2D[ORIGIN2D["TOPLEFT"] = 0] = "TOPLEFT";
        ORIGIN2D[ORIGIN2D["TOPCENTER"] = 1] = "TOPCENTER";
        ORIGIN2D[ORIGIN2D["TOPRIGHT"] = 2] = "TOPRIGHT";
        ORIGIN2D[ORIGIN2D["CENTERLEFT"] = 16] = "CENTERLEFT";
        ORIGIN2D[ORIGIN2D["CENTER"] = 17] = "CENTER";
        ORIGIN2D[ORIGIN2D["CENTERRIGHT"] = 18] = "CENTERRIGHT";
        ORIGIN2D[ORIGIN2D["BOTTOMLEFT"] = 32] = "BOTTOMLEFT";
        ORIGIN2D[ORIGIN2D["BOTTOMCENTER"] = 33] = "BOTTOMCENTER";
        ORIGIN2D[ORIGIN2D["BOTTOMRIGHT"] = 34] = "BOTTOMRIGHT";
    })(ORIGIN2D = FudgeCore.ORIGIN2D || (FudgeCore.ORIGIN2D = {}));
    /**
     * Defines a rectangle with position and size and add comfortable methods to it
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Rectangle extends FudgeCore.Mutable {
        constructor(_x = 0, _y = 0, _width = 1, _height = 1, _origin = ORIGIN2D.TOPLEFT) {
            super();
            this.position = FudgeCore.Recycler.get(FudgeCore.Vector2);
            this.size = FudgeCore.Recycler.get(FudgeCore.Vector2);
            this.setPositionAndSize(_x, _y, _width, _height, _origin);
        }
        /**
         * Returns a new rectangle created with the given parameters
         */
        static GET(_x = 0, _y = 0, _width = 1, _height = 1, _origin = ORIGIN2D.TOPLEFT) {
            let rect = FudgeCore.Recycler.get(Rectangle);
            rect.setPositionAndSize(_x, _y, _width, _height);
            return rect;
        }
        /**
         * Sets the position and size of the rectangle according to the given parameters
         */
        setPositionAndSize(_x = 0, _y = 0, _width = 1, _height = 1, _origin = ORIGIN2D.TOPLEFT) {
            this.size.set(_width, _height);
            switch (_origin & 0x03) {
                case 0x00:
                    this.position.x = _x;
                    break;
                case 0x01:
                    this.position.x = _x - _width / 2;
                    break;
                case 0x02:
                    this.position.x = _x - _width;
                    break;
            }
            switch (_origin & 0x30) {
                case 0x00:
                    this.position.y = _y;
                    break;
                case 0x10:
                    this.position.y = _y - _height / 2;
                    break;
                case 0x20:
                    this.position.y = _y - _height;
                    break;
            }
        }
        pointToRect(_point, _target) {
            let result = _point.copy;
            result.subtract(this.position);
            result.x *= _target.width / this.width;
            result.y *= _target.height / this.height;
            result.add(_target.position);
            return result;
        }
        get x() {
            return this.position.x;
        }
        get y() {
            return this.position.y;
        }
        get width() {
            return this.size.x;
        }
        get height() {
            return this.size.y;
        }
        /**
         * Return the leftmost expansion, respecting also negative values of width
         */
        get left() {
            if (this.size.x > 0)
                return this.position.x;
            return (this.position.x + this.size.x);
        }
        /**
         * Return the topmost expansion, respecting also negative values of height
         */
        get top() {
            if (this.size.y > 0)
                return this.position.y;
            return (this.position.y + this.size.y);
        }
        /**
         * Return the rightmost expansion, respecting also negative values of width
         */
        get right() {
            if (this.size.x > 0)
                return (this.position.x + this.size.x);
            return this.position.x;
        }
        /**
         * Return the lowest expansion, respecting also negative values of height
         */
        get bottom() {
            if (this.size.y > 0)
                return (this.position.y + this.size.y);
            return this.position.y;
        }
        set x(_x) {
            this.position.x = _x;
        }
        set y(_y) {
            this.position.y = _y;
        }
        set width(_width) {
            this.position.x = _width;
        }
        set height(_height) {
            this.position.y = _height;
        }
        set left(_value) {
            this.size.x = this.right - _value;
            this.position.x = _value;
        }
        set top(_value) {
            this.size.y = this.bottom - _value;
            this.position.y = _value;
        }
        set right(_value) {
            this.size.x = this.position.x + _value;
        }
        set bottom(_value) {
            this.size.y = this.position.y + _value;
        }
        get copy() {
            return Rectangle.GET(this.x, this.y, this.width, this.height);
        }
        /**
         * Returns true if the given point is inside of this rectangle or on the border
         * @param _point
         */
        isInside(_point) {
            return (_point.x >= this.left && _point.x <= this.right && _point.y >= this.top && _point.y <= this.bottom);
        }
        collides(_rect) {
            if (this.left > _rect.right)
                return false;
            if (this.right < _rect.left)
                return false;
            if (this.top > _rect.bottom)
                return false;
            if (this.bottom < _rect.top)
                return false;
            return true;
        }
        toString() {
            let result = `∆í.Rectangle(position:${this.position.toString()}, size:${this.size.toString()}`;
            result += `, left:${this.left.toPrecision(5)}, top:${this.top.toPrecision(5)}, right:${this.right.toPrecision(5)}, bottom:${this.bottom.toPrecision(5)}`;
            return result;
        }
        reduceMutator(_mutator) { }
    }
    FudgeCore.Rectangle = Rectangle;
})(FudgeCore || (FudgeCore = {}));
///<reference path="RenderInjector.ts"/>
///<reference path="RenderInjectorShader.ts"/>
///<reference path="RenderInjectorCoat.ts"/>
///<reference path="RenderInjectorMesh.ts"/>
///<reference path="../Math/Rectangle.ts"/>
var FudgeCore;
///<reference path="RenderInjector.ts"/>
///<reference path="RenderInjectorShader.ts"/>
///<reference path="RenderInjectorCoat.ts"/>
///<reference path="RenderInjectorMesh.ts"/>
///<reference path="../Math/Rectangle.ts"/>
(function (FudgeCore) {
    let BLEND;
    (function (BLEND) {
        BLEND[BLEND["OPAQUE"] = 0] = "OPAQUE";
        BLEND[BLEND["TRANSPARENT"] = 1] = "TRANSPARENT";
        BLEND[BLEND["PARTICLE"] = 2] = "PARTICLE";
    })(BLEND = FudgeCore.BLEND || (FudgeCore.BLEND = {}));
    /**
     * Base class for RenderManager, handling the connection to the rendering system, in this case WebGL.
     * Methods and attributes of this class should not be called directly, only through [[RenderManager]]
     */
    let RenderOperator = /** @class */ (() => {
        class RenderOperator {
            /**
             * Wrapper function to utilize the bufferSpecification interface when passing data to the shader via a buffer.
             * @param _attributeLocation  The location of the attribute on the shader, to which they data will be passed.
             * @param _bufferSpecification  Interface passing datapullspecifications to the buffer.
             */
            static setAttributeStructure(_attributeLocation, _bufferSpecification) {
                RenderOperator.crc3.vertexAttribPointer(_attributeLocation, _bufferSpecification.size, _bufferSpecification.dataType, _bufferSpecification.normalize, _bufferSpecification.stride, _bufferSpecification.offset);
            }
            /**
            * Checks the first parameter and throws an exception with the WebGL-errorcode if the value is null
            * @param _value  value to check against null
            * @param _message  optional, additional message for the exception
            */
            static assert(_value, _message = "") {
                if (_value === null)
                    throw new Error(`Assertion failed. ${_message}, WebGL-Error: ${RenderOperator.crc3 ? RenderOperator.crc3.getError() : ""}`);
                return _value;
            }
            /**
             * Initializes offscreen-canvas, renderingcontext and hardware viewport. Call once before creating any resources like meshes or shaders
             */
            static initialize(_antialias, _alpha) {
                FudgeCore.fudgeConfig = FudgeCore.fudgeConfig || {};
                let contextAttributes = {
                    alpha: (_alpha != undefined) ? _alpha : FudgeCore.fudgeConfig.alpha || false,
                    antialias: (_antialias != undefined) ? _antialias : FudgeCore.fudgeConfig.antialias || false,
                    premultipliedAlpha: false
                };
                FudgeCore.Debug.fudge("Initialize RenderManager", contextAttributes);
                let canvas = document.createElement("canvas");
                let crc3;
                crc3 = RenderOperator.assert(canvas.getContext("webgl2", contextAttributes), "WebGL-context couldn't be created");
                RenderOperator.crc3 = crc3;
                // Enable backface- and zBuffer-culling.
                crc3.enable(WebGL2RenderingContext.CULL_FACE);
                crc3.enable(WebGL2RenderingContext.DEPTH_TEST);
                crc3.enable(WebGL2RenderingContext.BLEND);
                crc3.blendEquation(WebGL2RenderingContext.FUNC_ADD);
                RenderOperator.setBlendMode(BLEND.TRANSPARENT);
                // RenderOperator.crc3.pixelStorei(WebGL2RenderingContext.UNPACK_FLIP_Y_WEBGL, true);
                RenderOperator.rectViewport = RenderOperator.getCanvasRect();
                return crc3;
            }
            /**
             * Return a reference to the offscreen-canvas
             */
            static getCanvas() {
                return RenderOperator.crc3.canvas; // TODO: enable OffscreenCanvas
            }
            /**
             * Return a reference to the rendering context
             */
            static getRenderingContext() {
                return RenderOperator.crc3;
            }
            /**
             * Return a rectangle describing the size of the offscreen-canvas. x,y are 0 at all times.
             */
            static getCanvasRect() {
                let canvas = RenderOperator.crc3.canvas;
                return FudgeCore.Rectangle.GET(0, 0, canvas.width, canvas.height);
            }
            /**
             * Set the size of the offscreen-canvas.
             */
            static setCanvasSize(_width, _height) {
                RenderOperator.crc3.canvas.width = _width;
                RenderOperator.crc3.canvas.height = _height;
            }
            /**
             * Set the area on the offscreen-canvas to render the camera image to.
             * @param _rect
             */
            static setViewportRectangle(_rect) {
                Object.assign(RenderOperator.rectViewport, _rect);
                RenderOperator.crc3.viewport(_rect.x, _rect.y, _rect.width, _rect.height);
            }
            /**
             * Retrieve the area on the offscreen-canvas the camera image gets rendered to.
             */
            static getViewportRectangle() {
                return RenderOperator.rectViewport;
            }
            static setDepthTest(_test) {
                if (_test)
                    RenderOperator.crc3.enable(WebGL2RenderingContext.DEPTH_TEST);
                else
                    RenderOperator.crc3.disable(WebGL2RenderingContext.DEPTH_TEST);
            }
            static setBlendMode(_mode) {
                switch (_mode) {
                    case BLEND.OPAQUE:
                        RenderOperator.crc3.blendFunc(WebGL2RenderingContext.ONE, WebGL2RenderingContext.ZERO);
                        break;
                    case BLEND.TRANSPARENT:
                        RenderOperator.crc3.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
                        break;
                    case BLEND.PARTICLE:
                        RenderOperator.crc3.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.DST_ALPHA);
                        break;
                    default:
                        break;
                }
            }
            /**
             * Draw a mesh buffer using the given infos and the complete projection matrix
             */
            static draw(_mesh, cmpMaterial, _final, _projection) {
                let shader = cmpMaterial.material.getShader();
                let coat = cmpMaterial.material.getCoat();
                shader.useProgram();
                _mesh.useRenderBuffers(shader, _final, _projection);
                coat.useRenderData(shader, cmpMaterial);
                RenderOperator.crc3.drawElements(WebGL2RenderingContext.TRIANGLES, _mesh.renderBuffers.nIndices, WebGL2RenderingContext.UNSIGNED_SHORT, 0);
            }
        }
        RenderOperator.crc3 = RenderOperator.initialize();
        RenderOperator.rectViewport = RenderOperator.getCanvasRect();
        return RenderOperator;
    })();
    FudgeCore.RenderOperator = RenderOperator;
})(FudgeCore || (FudgeCore = {}));
/// <reference path="Debug/DebugTarget.ts"/>
/// <reference path="Debug/Debug.ts"/>
/// <reference path="Event/Event.ts"/>
/// <reference path="Transfer/Mutable.ts"/>  
/// <reference path="Transfer/Serializer.ts"/> 
/// <reference path="Render/RenderOperator.ts"/>
// / <reference path="../Transfer/Mutable.ts"/>
var FudgeCore;
// / <reference path="../Transfer/Mutable.ts"/>
(function (FudgeCore) {
    /**
     * Internally used to differentiate between the various generated structures and events.
     * @author Lukas Scheuerle, HFU, 2019
     */
    let ANIMATION_STRUCTURE_TYPE;
    (function (ANIMATION_STRUCTURE_TYPE) {
        /**Default: forward, continous */
        ANIMATION_STRUCTURE_TYPE[ANIMATION_STRUCTURE_TYPE["NORMAL"] = 0] = "NORMAL";
        /**backward, continous */
        ANIMATION_STRUCTURE_TYPE[ANIMATION_STRUCTURE_TYPE["REVERSE"] = 1] = "REVERSE";
        /**forward, rastered */
        ANIMATION_STRUCTURE_TYPE[ANIMATION_STRUCTURE_TYPE["RASTERED"] = 2] = "RASTERED";
        /**backward, rastered */
        ANIMATION_STRUCTURE_TYPE[ANIMATION_STRUCTURE_TYPE["RASTEREDREVERSE"] = 3] = "RASTEREDREVERSE";
    })(ANIMATION_STRUCTURE_TYPE || (ANIMATION_STRUCTURE_TYPE = {}));
    /**
     * Animation Class to hold all required Objects that are part of an Animation.
     * Also holds functions to play said Animation.
     * Can be added to a Node and played through [[ComponentAnimator]].
     * @author Lukas Scheuerle, HFU, 2019
     */
    class Animation extends FudgeCore.Mutable {
        constructor(_name, _animStructure = {}, _fps = 60) {
            super();
            this.totalTime = 0;
            this.labels = {};
            this.stepsPerSecond = 10;
            this.events = {};
            this.framesPerSecond = 60;
            // processed eventlist and animation strucutres for playback.
            this.eventsProcessed = new Map();
            this.animationStructuresProcessed = new Map();
            this.name = _name;
            this.animationStructure = _animStructure;
            this.animationStructuresProcessed.set(ANIMATION_STRUCTURE_TYPE.NORMAL, _animStructure);
            this.framesPerSecond = _fps;
            this.calculateTotalTime();
        }
        /**
         * Generates a new "Mutator" with the information to apply to the [[Node]] the [[ComponentAnimator]] is attached to with [[Node.applyAnimation()]].
         * @param _time The time at which the animation currently is at
         * @param _direction The direction in which the animation is supposed to be playing back. >0 == forward, 0 == stop, <0 == backwards
         * @param _playback The playbackmode the animation is supposed to be calculated with.
         * @returns a "Mutator" to apply.
         */
        getMutated(_time, _direction, _playback) {
            let m = {};
            if (_playback == FudgeCore.ANIMATION_PLAYBACK.TIMEBASED_CONTINOUS) {
                if (_direction >= 0) {
                    m = this.traverseStructureForMutator(this.getProcessedAnimationStructure(ANIMATION_STRUCTURE_TYPE.NORMAL), _time);
                }
                else {
                    m = this.traverseStructureForMutator(this.getProcessedAnimationStructure(ANIMATION_STRUCTURE_TYPE.REVERSE), _time);
                }
            }
            else {
                if (_direction >= 0) {
                    m = this.traverseStructureForMutator(this.getProcessedAnimationStructure(ANIMATION_STRUCTURE_TYPE.RASTERED), _time);
                }
                else {
                    m = this.traverseStructureForMutator(this.getProcessedAnimationStructure(ANIMATION_STRUCTURE_TYPE.RASTEREDREVERSE), _time);
                }
            }
            return m;
        }
        /**
         * Returns a list of the names of the events the [[ComponentAnimator]] needs to fire between _min and _max.
         * @param _min The minimum time (inclusive) to check between
         * @param _max The maximum time (exclusive) to check between
         * @param _playback The playback mode to check in. Has an effect on when the Events are fired.
         * @param _direction The direction the animation is supposed to run in. >0 == forward, 0 == stop, <0 == backwards
         * @returns a list of strings with the names of the custom events to fire.
         */
        getEventsToFire(_min, _max, _playback, _direction) {
            let eventList = [];
            let minSection = Math.floor(_min / this.totalTime);
            let maxSection = Math.floor(_max / this.totalTime);
            _min = _min % this.totalTime;
            _max = _max % this.totalTime;
            while (minSection <= maxSection) {
                let eventTriggers = this.getCorrectEventList(_direction, _playback);
                if (minSection == maxSection) {
                    eventList = eventList.concat(this.checkEventsBetween(eventTriggers, _min, _max));
                }
                else {
                    eventList = eventList.concat(this.checkEventsBetween(eventTriggers, _min, this.totalTime));
                    _min = 0;
                }
                minSection++;
            }
            return eventList;
        }
        /**
         * Adds an Event to the List of events.
         * @param _name The name of the event (needs to be unique per Animation).
         * @param _time The timestamp of the event (in milliseconds).
         */
        setEvent(_name, _time) {
            this.events[_name] = _time;
            this.eventsProcessed.clear();
        }
        /**
         * Removes the event with the given name from the list of events.
         * @param _name name of the event to remove.
         */
        removeEvent(_name) {
            delete this.events[_name];
            this.eventsProcessed.clear();
        }
        get getLabels() {
            //TODO: this actually needs testing
            let en = new Enumerator(this.labels);
            return en;
        }
        get fps() {
            return this.framesPerSecond;
        }
        set fps(_fps) {
            this.framesPerSecond = _fps;
            this.eventsProcessed.clear();
            this.animationStructuresProcessed.clear();
        }
        /**
         * (Re-)Calculate the total time of the Animation. Calculation-heavy, use only if actually needed.
         */
        calculateTotalTime() {
            this.totalTime = 0;
            this.traverseStructureForTime(this.animationStructure);
        }
        //#region transfer
        serialize() {
            let s = {
                idResource: this.idResource,
                name: this.name,
                labels: {},
                events: {},
                fps: this.framesPerSecond,
                sps: this.stepsPerSecond
            };
            for (let name in this.labels) {
                s.labels[name] = this.labels[name];
            }
            for (let name in this.events) {
                s.events[name] = this.events[name];
            }
            s.animationStructure = this.traverseStructureForSerialisation(this.animationStructure);
            return s;
        }
        deserialize(_serialization) {
            this.idResource = _serialization.idResource;
            this.name = _serialization.name;
            this.framesPerSecond = _serialization.fps;
            this.stepsPerSecond = _serialization.sps;
            this.labels = {};
            for (let name in _serialization.labels) {
                this.labels[name] = _serialization.labels[name];
            }
            this.events = {};
            for (let name in _serialization.events) {
                this.events[name] = _serialization.events[name];
            }
            this.eventsProcessed = new Map();
            this.animationStructure = this.traverseStructureForDeserialisation(_serialization.animationStructure);
            this.animationStructuresProcessed = new Map();
            this.calculateTotalTime();
            return this;
        }
        getMutator() {
            return this.serialize();
        }
        reduceMutator(_mutator) {
            delete _mutator.totalTime;
        }
        /**
         * Traverses an AnimationStructure and returns the Serialization of said Structure.
         * @param _structure The Animation Structure at the current level to transform into the Serialization.
         * @returns the filled Serialization.
         */
        traverseStructureForSerialisation(_structure) {
            let newSerialization = {};
            for (let n in _structure) {
                if (_structure[n] instanceof FudgeCore.AnimationSequence) {
                    newSerialization[n] = _structure[n].serialize();
                }
                else {
                    newSerialization[n] = this.traverseStructureForSerialisation(_structure[n]);
                }
            }
            return newSerialization;
        }
        /**
         * Traverses a Serialization to create a new AnimationStructure.
         * @param _serialization The serialization to transfer into an AnimationStructure
         * @returns the newly created AnimationStructure.
         */
        traverseStructureForDeserialisation(_serialization) {
            let newStructure = {};
            for (let n in _serialization) {
                if (_serialization[n].animationSequence) {
                    let animSeq = new FudgeCore.AnimationSequence();
                    newStructure[n] = animSeq.deserialize(_serialization[n]);
                }
                else {
                    newStructure[n] = this.traverseStructureForDeserialisation(_serialization[n]);
                }
            }
            return newStructure;
        }
        //#endregion
        /**
         * Finds the list of events to be used with these settings.
         * @param _direction The direction the animation is playing in.
         * @param _playback The playbackmode the animation is playing in.
         * @returns The correct AnimationEventTrigger Object to use
         */
        getCorrectEventList(_direction, _playback) {
            if (_playback != FudgeCore.ANIMATION_PLAYBACK.FRAMEBASED) {
                if (_direction >= 0) {
                    return this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.NORMAL);
                }
                else {
                    return this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.REVERSE);
                }
            }
            else {
                if (_direction >= 0) {
                    return this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.RASTERED);
                }
                else {
                    return this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.RASTEREDREVERSE);
                }
            }
        }
        /**
         * Traverses an AnimationStructure to turn it into the "Mutator" to return to the Component.
         * @param _structure The strcuture to traverse
         * @param _time the point in time to write the animation numbers into.
         * @returns The "Mutator" filled with the correct values at the given time.
         */
        traverseStructureForMutator(_structure, _time) {
            let newMutator = {};
            for (let n in _structure) {
                if (_structure[n] instanceof FudgeCore.AnimationSequence) {
                    newMutator[n] = _structure[n].evaluate(_time);
                }
                else {
                    newMutator[n] = this.traverseStructureForMutator(_structure[n], _time);
                }
            }
            return newMutator;
        }
        /**
         * Traverses the current AnimationStrcuture to find the totalTime of this animation.
         * @param _structure The structure to traverse
         */
        traverseStructureForTime(_structure) {
            for (let n in _structure) {
                if (_structure[n] instanceof FudgeCore.AnimationSequence) {
                    let sequence = _structure[n];
                    if (sequence.length > 0) {
                        let sequenceTime = sequence.getKey(sequence.length - 1).Time;
                        this.totalTime = sequenceTime > this.totalTime ? sequenceTime : this.totalTime;
                    }
                }
                else {
                    this.traverseStructureForTime(_structure[n]);
                }
            }
        }
        /**
         * Ensures the existance of the requested [[AnimationStrcuture]] and returns it.
         * @param _type the type of the structure to get
         * @returns the requested [[AnimationStructure]]
         */
        getProcessedAnimationStructure(_type) {
            if (!this.animationStructuresProcessed.has(_type)) {
                this.calculateTotalTime();
                let ae = {};
                switch (_type) {
                    case ANIMATION_STRUCTURE_TYPE.NORMAL:
                        ae = this.animationStructure;
                        break;
                    case ANIMATION_STRUCTURE_TYPE.REVERSE:
                        ae = this.traverseStructureForNewStructure(this.animationStructure, this.calculateReverseSequence.bind(this));
                        break;
                    case ANIMATION_STRUCTURE_TYPE.RASTERED:
                        ae = this.traverseStructureForNewStructure(this.animationStructure, this.calculateRasteredSequence.bind(this));
                        break;
                    case ANIMATION_STRUCTURE_TYPE.RASTEREDREVERSE:
                        ae = this.traverseStructureForNewStructure(this.getProcessedAnimationStructure(ANIMATION_STRUCTURE_TYPE.REVERSE), this.calculateRasteredSequence.bind(this));
                        break;
                    default:
                        return {};
                }
                this.animationStructuresProcessed.set(_type, ae);
            }
            return this.animationStructuresProcessed.get(_type);
        }
        /**
         * Ensures the existance of the requested [[AnimationEventTrigger]] and returns it.
         * @param _type The type of AnimationEventTrigger to get
         * @returns the requested [[AnimationEventTrigger]]
         */
        getProcessedEventTrigger(_type) {
            if (!this.eventsProcessed.has(_type)) {
                this.calculateTotalTime();
                let ev = {};
                switch (_type) {
                    case ANIMATION_STRUCTURE_TYPE.NORMAL:
                        ev = this.events;
                        break;
                    case ANIMATION_STRUCTURE_TYPE.REVERSE:
                        ev = this.calculateReverseEventTriggers(this.events);
                        break;
                    case ANIMATION_STRUCTURE_TYPE.RASTERED:
                        ev = this.calculateRasteredEventTriggers(this.events);
                        break;
                    case ANIMATION_STRUCTURE_TYPE.RASTEREDREVERSE:
                        ev = this.calculateRasteredEventTriggers(this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.REVERSE));
                        break;
                    default:
                        return {};
                }
                this.eventsProcessed.set(_type, ev);
            }
            return this.eventsProcessed.get(_type);
        }
        /**
         * Traverses an existing structure to apply a recalculation function to the AnimationStructure to store in a new Structure.
         * @param _oldStructure The old structure to traverse
         * @param _functionToUse The function to use to recalculated the structure.
         * @returns A new Animation Structure with the recalulated Animation Sequences.
         */
        traverseStructureForNewStructure(_oldStructure, _functionToUse) {
            let newStructure = {};
            for (let n in _oldStructure) {
                if (_oldStructure[n] instanceof FudgeCore.AnimationSequence) {
                    newStructure[n] = _functionToUse(_oldStructure[n]);
                }
                else {
                    newStructure[n] = this.traverseStructureForNewStructure(_oldStructure[n], _functionToUse);
                }
            }
            return newStructure;
        }
        /**
         * Creates a reversed Animation Sequence out of a given Sequence.
         * @param _sequence The sequence to calculate the new sequence out of
         * @returns The reversed Sequence
         */
        calculateReverseSequence(_sequence) {
            let seq = new FudgeCore.AnimationSequence();
            for (let i = 0; i < _sequence.length; i++) {
                let oldKey = _sequence.getKey(i);
                let key = new FudgeCore.AnimationKey(this.totalTime - oldKey.Time, oldKey.Value, oldKey.SlopeOut, oldKey.SlopeIn, oldKey.Constant);
                seq.addKey(key);
            }
            return seq;
        }
        /**
         * Creates a rastered [[AnimationSequence]] out of a given sequence.
         * @param _sequence The sequence to calculate the new sequence out of
         * @returns the rastered sequence.
         */
        calculateRasteredSequence(_sequence) {
            let seq = new FudgeCore.AnimationSequence();
            let frameTime = 1000 / this.framesPerSecond;
            for (let i = 0; i < this.totalTime; i += frameTime) {
                let key = new FudgeCore.AnimationKey(i, _sequence.evaluate(i), 0, 0, true);
                seq.addKey(key);
            }
            return seq;
        }
        /**
         * Creates a new reversed [[AnimationEventTrigger]] object based on the given one.
         * @param _events the event object to calculate the new one out of
         * @returns the reversed event object
         */
        calculateReverseEventTriggers(_events) {
            let ae = {};
            for (let name in _events) {
                ae[name] = this.totalTime - _events[name];
            }
            return ae;
        }
        /**
         * Creates a rastered [[AnimationEventTrigger]] object based on the given one.
         * @param _events the event object to calculate the new one out of
         * @returns the rastered event object
         */
        calculateRasteredEventTriggers(_events) {
            let ae = {};
            let frameTime = 1000 / this.framesPerSecond;
            for (let name in _events) {
                ae[name] = _events[name] - (_events[name] % frameTime);
            }
            return ae;
        }
        /**
         * Checks which events lay between two given times and returns the names of the ones that do.
         * @param _eventTriggers The event object to check the events inside of
         * @param _min the minimum of the range to check between (inclusive)
         * @param _max the maximum of the range to check between (exclusive)
         * @returns an array of the names of the events in the given range.
         */
        checkEventsBetween(_eventTriggers, _min, _max) {
            let eventsToTrigger = [];
            for (let name in _eventTriggers) {
                if (_min <= _eventTriggers[name] && _eventTriggers[name] < _max) {
                    eventsToTrigger.push(name);
                }
            }
            return eventsToTrigger;
        }
    }
    FudgeCore.Animation = Animation;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="../Transfer/Serializer.ts"/>
// / <reference path="../Transfer/Mutable.ts"/>
var FudgeCore;
// / <reference path="../Transfer/Serializer.ts"/>
// / <reference path="../Transfer/Mutable.ts"/>
(function (FudgeCore) {
    /**
     * Calculates the values between [[AnimationKey]]s.
     * Represented internally by a cubic function (`f(x) = ax¬≥ + bx¬≤ + cx + d`).
     * Only needs to be recalculated when the keys change, so at runtime it should only be calculated once.
     * @author Lukas Scheuerle, HFU, 2019
     */
    class AnimationFunction {
        constructor(_keyIn, _keyOut = null) {
            this.a = 0;
            this.b = 0;
            this.c = 0;
            this.d = 0;
            this.keyIn = _keyIn;
            this.keyOut = _keyOut;
            this.calculate();
        }
        /**
         * Calculates the value of the function at the given time.
         * @param _time the point in time at which to evaluate the function in milliseconds. Will be corrected for offset internally.
         * @returns the value at the given time
         */
        evaluate(_time) {
            _time -= this.keyIn.Time;
            let time2 = _time * _time;
            let time3 = time2 * _time;
            return this.a * time3 + this.b * time2 + this.c * _time + this.d;
        }
        set setKeyIn(_keyIn) {
            this.keyIn = _keyIn;
            this.calculate();
        }
        set setKeyOut(_keyOut) {
            this.keyOut = _keyOut;
            this.calculate();
        }
        /**
         * (Re-)Calculates the parameters of the cubic function.
         * See https://math.stackexchange.com/questions/3173469/calculate-cubic-equation-from-two-points-and-two-slopes-variably
         * and https://jirkadelloro.github.io/FUDGE/Documentation/Logs/190410_Notizen_LS
         */
        calculate() {
            if (!this.keyIn) {
                this.d = this.c = this.b = this.a = 0;
                return;
            }
            if (!this.keyOut || this.keyIn.Constant) {
                this.d = this.keyIn.Value;
                this.c = this.b = this.a = 0;
                return;
            }
            let x1 = this.keyOut.Time - this.keyIn.Time;
            this.d = this.keyIn.Value;
            this.c = this.keyIn.SlopeOut;
            this.a = (-x1 * (this.keyIn.SlopeOut + this.keyOut.SlopeIn) - 2 * this.keyIn.Value + 2 * this.keyOut.Value) / -Math.pow(x1, 3);
            this.b = (this.keyOut.SlopeIn - this.keyIn.SlopeOut - 3 * this.a * Math.pow(x1, 2)) / (2 * x1);
        }
    }
    FudgeCore.AnimationFunction = AnimationFunction;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="../Transfer/Serializer.ts"/>
// / <reference path="../Transfer/Mutable.ts"/>
var FudgeCore;
// / <reference path="../Transfer/Serializer.ts"/>
// / <reference path="../Transfer/Mutable.ts"/>
(function (FudgeCore) {
    /**
     * Holds information about set points in time, their accompanying values as well as their slopes.
     * Also holds a reference to the [[AnimationFunction]]s that come in and out of the sides. The [[AnimationFunction]]s are handled by the [[AnimationSequence]]s.
     * Saved inside an [[AnimationSequence]].
     * @author Lukas Scheuerle, HFU, 2019
     */
    class AnimationKey extends FudgeCore.Mutable {
        constructor(_time = 0, _value = 0, _slopeIn = 0, _slopeOut = 0, _constant = false) {
            super();
            this.constant = false;
            this.slopeIn = 0;
            this.slopeOut = 0;
            this.time = _time;
            this.value = _value;
            this.slopeIn = _slopeIn;
            this.slopeOut = _slopeOut;
            this.constant = _constant;
            this.broken = this.slopeIn != -this.slopeOut;
            this.functionOut = new FudgeCore.AnimationFunction(this, null);
        }
        get Time() {
            return this.time;
        }
        set Time(_time) {
            this.time = _time;
            this.functionIn.calculate();
            this.functionOut.calculate();
        }
        get Value() {
            return this.value;
        }
        set Value(_value) {
            this.value = _value;
            this.functionIn.calculate();
            this.functionOut.calculate();
        }
        get Constant() {
            return this.constant;
        }
        set Constant(_constant) {
            this.constant = _constant;
            this.functionIn.calculate();
            this.functionOut.calculate();
        }
        get SlopeIn() {
            return this.slopeIn;
        }
        set SlopeIn(_slope) {
            this.slopeIn = _slope;
            this.functionIn.calculate();
        }
        get SlopeOut() {
            return this.slopeOut;
        }
        set SlopeOut(_slope) {
            this.slopeOut = _slope;
            this.functionOut.calculate();
        }
        /**
         * Static comparation function to use in an array sort function to sort the keys by their time.
         * @param _a the animation key to check
         * @param _b the animation key to check against
         * @returns >0 if a>b, 0 if a=b, <0 if a<b
         */
        static compare(_a, _b) {
            return _a.time - _b.time;
        }
        //#region transfer
        serialize() {
            let s = {};
            s.time = this.time;
            s.value = this.value;
            s.slopeIn = this.slopeIn;
            s.slopeOut = this.slopeOut;
            s.constant = this.constant;
            return s;
        }
        deserialize(_serialization) {
            this.time = _serialization.time;
            this.value = _serialization.value;
            this.slopeIn = _serialization.slopeIn;
            this.slopeOut = _serialization.slopeOut;
            this.constant = _serialization.constant;
            this.broken = this.slopeIn != -this.slopeOut;
            return this;
        }
        getMutator() {
            return this.serialize();
        }
        reduceMutator(_mutator) {
            //
        }
    }
    FudgeCore.AnimationKey = AnimationKey;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A sequence of [[AnimationKey]]s that is mapped to an attribute of a [[Node]] or its [[Component]]s inside the [[Animation]].
     * Provides functions to modify said keys
     * @author Lukas Scheuerle, HFU, 2019
     */
    class AnimationSequence extends FudgeCore.Mutable {
        constructor() {
            super(...arguments);
            this.keys = [];
        }
        /**
         * Evaluates the sequence at the given point in time.
         * @param _time the point in time at which to evaluate the sequence in milliseconds.
         * @returns the value of the sequence at the given time. 0 if there are no keys.
         */
        evaluate(_time) {
            if (this.keys.length == 0)
                return 0; //TODO: shouldn't return 0 but something indicating no change, like null. probably needs to be changed in Node as well to ignore non-numeric values in the applyAnimation function
            if (this.keys.length == 1 || this.keys[0].Time >= _time)
                return this.keys[0].Value;
            for (let i = 0; i < this.keys.length - 1; i++) {
                if (this.keys[i].Time <= _time && this.keys[i + 1].Time > _time) {
                    return this.keys[i].functionOut.evaluate(_time);
                }
            }
            return this.keys[this.keys.length - 1].Value;
        }
        /**
         * Adds a new key to the sequence.
         * @param _key the key to add
         */
        addKey(_key) {
            this.keys.push(_key);
            this.keys.sort(FudgeCore.AnimationKey.compare);
            this.regenerateFunctions();
        }
        /**
         * Removes a given key from the sequence.
         * @param _key the key to remove
         */
        removeKey(_key) {
            for (let i = 0; i < this.keys.length; i++) {
                if (this.keys[i] == _key) {
                    this.keys.splice(i, 1);
                    this.regenerateFunctions();
                    return;
                }
            }
        }
        /**
         * Removes the Animation Key at the given index from the keys.
         * @param _index the zero-based index at which to remove the key
         * @returns the removed AnimationKey if successful, null otherwise.
         */
        removeKeyAtIndex(_index) {
            if (_index < 0 || _index >= this.keys.length) {
                return null;
            }
            let ak = this.keys[_index];
            this.keys.splice(_index, 1);
            this.regenerateFunctions();
            return ak;
        }
        /**
         * Gets a key from the sequence at the desired index.
         * @param _index the zero-based index at which to get the key
         * @returns the AnimationKey at the index if it exists, null otherwise.
         */
        getKey(_index) {
            if (_index < 0 || _index >= this.keys.length)
                return null;
            return this.keys[_index];
        }
        get length() {
            return this.keys.length;
        }
        //#region transfer
        serialize() {
            let s = {
                keys: [],
                animationSequence: true
            };
            for (let i = 0; i < this.keys.length; i++) {
                s.keys[i] = this.keys[i].serialize();
            }
            return s;
        }
        deserialize(_serialization) {
            for (let i = 0; i < _serialization.keys.length; i++) {
                // this.keys.push(<AnimationKey>Serializer.deserialize(_serialization.keys[i]));
                let k = new FudgeCore.AnimationKey();
                k.deserialize(_serialization.keys[i]);
                this.keys[i] = k;
            }
            this.regenerateFunctions();
            return this;
        }
        reduceMutator(_mutator) {
            //
        }
        //#endregion
        /**
         * Utility function that (re-)generates all functions in the sequence.
         */
        regenerateFunctions() {
            for (let i = 0; i < this.keys.length; i++) {
                let f = new FudgeCore.AnimationFunction(this.keys[i]);
                this.keys[i].functionOut = f;
                if (i == this.keys.length - 1) {
                    //TODO: check if this is even useful. Maybe update the runcondition to length - 1 instead. Might be redundant if functionIn is removed, see TODO in AnimationKey.
                    f.setKeyOut = this.keys[0];
                    this.keys[0].functionIn = f;
                    break;
                }
                f.setKeyOut = this.keys[i + 1];
                this.keys[i + 1].functionIn = f;
            }
        }
    }
    FudgeCore.AnimationSequence = AnimationSequence;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Extension of AudioBuffer with a load method that creates a buffer in the [[AudioManager]].default to be used with [[ComponentAudio]]
     * @authors Thomas Dorner, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2020
     */
    class Audio extends AudioBuffer {
        /**
         * Asynchronously loads the audio (mp3) from the given url
         */
        static async load(_url) {
            const response = await window.fetch(_url);
            const arrayBuffer = await response.arrayBuffer();
            return (await FudgeCore.AudioManager.default.decodeAudioData(arrayBuffer));
        }
    }
    FudgeCore.Audio = Audio;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Extends the standard AudioContext for integration with FUDGE-graphs.
     * Creates a default object at startup to be addressed as AudioManager default.
     * Other objects of this class may be create for special purposes.
     */
    let AudioManager = /** @class */ (() => {
        class AudioManager extends AudioContext {
            constructor(contextOptions) {
                super(contextOptions);
                this.graph = null;
                this.cmpListener = null;
                /**
                 * Determines FUDGE-graph to listen to. Each [[ComponentAudio]] in the graph will connect to this contexts master gain, all others disconnect.
                 */
                this.listenTo = (_graph) => {
                    if (this.graph)
                        this.graph.broadcastEvent(new Event("childRemoveFromAudioGraph" /* CHILD_REMOVE */));
                    if (!_graph)
                        return;
                    this.graph = _graph;
                    this.graph.broadcastEvent(new Event("childAppendToAudioGraph" /* CHILD_APPEND */));
                };
                /**
                 * Retrieve the FUDGE-graph currently listening to
                 */
                this.getGraphListeningTo = () => {
                    return this.graph;
                };
                /**
                 * Set the [[ComponentAudioListener]] that serves the spatial location and orientation for this contexts listener
                 */
                this.listen = (_cmpListener) => {
                    this.cmpListener = _cmpListener;
                };
                /**
                 * Updates the spatial settings of the AudioNodes effected in the current FUDGE-graph
                 */
                this.update = () => {
                    this.graph.broadcastEvent(new Event("updateAudioGraph" /* UPDATE */));
                    if (this.cmpListener)
                        this.cmpListener.update(this.listener);
                };
                this.gain = this.createGain();
                this.gain.connect(this.destination);
            }
            /**
             * Set the master volume
             */
            set volume(_value) {
                this.gain.gain.value = _value;
            }
            /**
             * Get the master volume
             */
            get volume() {
                return this.gain.gain.value;
            }
        }
        /** The default context that may be used throughout the project without the need to create others */
        AudioManager.default = new AudioManager({ latencyHint: "interactive", sampleRate: 44100 });
        return AudioManager;
    })();
    FudgeCore.AudioManager = AudioManager;
})(FudgeCore || (FudgeCore = {}));
// namespace FudgeCore {
//     /**
//      * Enumerator for all possible Oscillator Types
//      */
//     type OSCILLATOR_TYPE = "sine" | "square" | "sawtooth" | "triangle" | "custom";
//     /**
//      * Interface to create Custom Oscillator Types.
//      * Start-/Endpoint of a custum curve e.g. sine curve.
//      * Both parameters need to be inbetween -1 and 1.
//      * @param startpoint startpoint of a curve 
//      * @param endpoint Endpoint of a curve 
//      */
//     interface OscillatorWave {
//         startpoint: number;
//         endpoint: number;
//     }
//     /**
//      * Add an [[AudioFilter]] to an [[Audio]]
//      * @authors Thomas Dorner, HFU, 2019
//      */
//     export class AudioOscillator {
//         public audioOscillator: OscillatorNode; 
//         private frequency: number;
//         private oscillatorType: OSCILLATOR_TYPE;
//         private oscillatorWave: PeriodicWave;
//         private localGain: GainNode;
//         private localGainValue: number;
//         constructor(_audioSettings: AudioSettings, _oscillatorType?: OSCILLATOR_TYPE) {
//             this.audioOscillator = _audioSettings.getAudioContext().createOscillator();
//             this.localGain = _audioSettings.getAudioContext().createGain();
//             this.oscillatorType = _oscillatorType;
//             if (this.oscillatorType != "custom") {
//                 this.audioOscillator.type = this.oscillatorType;
//             }
//             else {
//                 if (!this.oscillatorWave) {
//                     this.audioOscillator.setPeriodicWave(this.oscillatorWave);
//                 }
//                 else {
//                     console.log("Create a Custom Periodic Wave first to use Custom Type");
//                 }
//             }
//         }
//         public setOscillatorType(_oscillatorType: OSCILLATOR_TYPE): void {
//             if (this.oscillatorType != "custom") {
//                 this.audioOscillator.type = this.oscillatorType;
//             }
//             else {
//                 if (!this.oscillatorWave) {
//                     this.audioOscillator.setPeriodicWave(this.oscillatorWave);
//                 }
//             }
//         }
//         public getOscillatorType(): OSCILLATOR_TYPE {
//             return this.oscillatorType;
//         }
//         public createPeriodicWave(_audioSettings: AudioSettings, _real: OscillatorWave, _imag: OscillatorWave): void {
//             let waveReal: Float32Array = new Float32Array(2);
//             waveReal[0] = _real.startpoint;
//             waveReal[1] = _real.endpoint;
//             let waveImag: Float32Array = new Float32Array(2);
//             waveImag[0] = _imag.startpoint;
//             waveImag[1] = _imag.endpoint;
//             this.oscillatorWave = _audioSettings.getAudioContext().createPeriodicWave(waveReal, waveImag);
//         }
//         public setLocalGain(_localGain: GainNode): void {
//             this.localGain = _localGain;
//         }
//         public getLocalGain(): GainNode {
//             return this.localGain;
//         }
//         public setLocalGainValue(_localGainValue: number): void {
//             this.localGainValue = _localGainValue;
//             this.localGain.gain.value = this.localGainValue;
//         }
//         public getLocalGainValue(): number {
//             return this.localGainValue;
//         }
//         public setFrequency(_audioSettings: AudioSettings, _frequency: number): void {
//             this.frequency = _frequency;
//             this.audioOscillator.frequency.setValueAtTime(this.frequency, _audioSettings.getAudioContext().currentTime);
//         }
//         public getFrequency(): number {
//             return this.frequency;
//         }
//         public createSnare(_audioSettings: AudioSettings): void {
//             this.setOscillatorType("triangle");
//             this.setFrequency(_audioSettings, 100);
//             this.setLocalGainValue(0);
//             this.localGain.gain.setValueAtTime(0, _audioSettings.getAudioContext().currentTime);
//             this.localGain.gain.exponentialRampToValueAtTime(0.01, _audioSettings.getAudioContext().currentTime + .1);
//             this.audioOscillator.connect(this.localGain);
//         }
//     }
// }
var FudgeCore;
(function (FudgeCore) {
    /**
     * Holds data to feed into a [[Shader]] to describe the surface of [[Mesh]].
     * [[Material]]s reference [[Coat]] and [[Shader]].
     * The method useRenderData will be injected by [[RenderInjector]] at runtime, extending the functionality of this class to deal with the renderer.
     */
    class Coat extends FudgeCore.Mutable {
        constructor() {
            super(...arguments);
            this.name = "Coat";
            //#endregion
        }
        mutate(_mutator) {
            super.mutate(_mutator);
        }
        useRenderData(_shader, _cmpMaterial) { }
        //#region Transfer
        serialize() {
            let serialization = this.getMutator();
            return serialization;
        }
        deserialize(_serialization) {
            this.mutate(_serialization);
            return this;
        }
        reduceMutator() { }
    }
    FudgeCore.Coat = Coat;
    /**
     * The simplest [[Coat]] providing just a color
     */
    let CoatColored = /** @class */ (() => {
        let CoatColored = class CoatColored extends Coat {
            constructor(_color) {
                super();
                this.color = _color || new FudgeCore.Color(0.5, 0.5, 0.5, 1);
            }
        };
        CoatColored = __decorate([
            FudgeCore.RenderInjectorCoat.decorate
        ], CoatColored);
        return CoatColored;
    })();
    FudgeCore.CoatColored = CoatColored;
    /**
     * A [[Coat]] to be used by the MatCap Shader providing a texture, a tint color (0.5 grey is neutral). Set shadeSmooth to 1 for smooth shading.
     */
    let CoatMatCap = /** @class */ (() => {
        let CoatMatCap = class CoatMatCap extends Coat {
            constructor(_texture, _color, _shadeSmooth) {
                super();
                this.texture = null;
                this.color = new FudgeCore.Color(0.5, 0.5, 0.5, 1);
                this.texture = _texture || new FudgeCore.TextureImage();
                this.color = _color || new FudgeCore.Color(0.5, 0.5, 0.5, 1);
                this.shadeSmooth = _shadeSmooth || 0;
            }
        };
        CoatMatCap = __decorate([
            FudgeCore.RenderInjectorCoat.decorate
        ], CoatMatCap);
        return CoatMatCap;
    })();
    FudgeCore.CoatMatCap = CoatMatCap;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A [[Coat]] providing a texture and additional data for texturing
     */
    let CoatTextured = /** @class */ (() => {
        let CoatTextured = class CoatTextured extends FudgeCore.Coat {
            constructor() {
                super(...arguments);
                // TODO: see if color should be generalized
                this.color = new FudgeCore.Color(1, 1, 1, 1);
                this.texture = null;
                // constructor(_texture: TextureImage, _color?: Color) {
                //   super();
                //   this.texture = _texture;
                //   this.color = _color || new Color(1, 1, 1, 1);
                // }
                // public getMutatorForComponent(): MutatorForComponent {
                //   let mutatorPivot: MutatorForComponent = <MutatorForComponent><unknown>this.pivot.getMutator();
                //   return mutatorPivot;
                // }
                // public mutate(_mutator: MutatorForComponent): void {
                //   this.pivot.mutate(_mutator);
                // }
            }
        };
        CoatTextured = __decorate([
            FudgeCore.RenderInjectorCoat.decorate
        ], CoatTextured);
        return CoatTextured;
    })();
    FudgeCore.CoatTextured = CoatTextured;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="../Transfer/Serializer.ts"/>
// / <reference path="../Transfer/Mutable.ts"/>
var FudgeCore;
// / <reference path="../Transfer/Serializer.ts"/>
// / <reference path="../Transfer/Mutable.ts"/>
(function (FudgeCore) {
    /**
     * Superclass for all [[Component]]s that can be attached to [[Node]]s.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2020 | Jascha Karag√∂l, HFU, 2019
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Component
     */
    let Component = /** @class */ (() => {
        class Component extends FudgeCore.Mutable {
            constructor() {
                super(...arguments);
                this.singleton = true;
                this.container = null;
                this.active = true;
                //#endregion
            }
            static registerSubclass(_subclass) { return Component.subclasses.push(_subclass) - 1; }
            activate(_on) {
                this.active = _on;
                this.dispatchEvent(new Event(_on ? "componentActivate" /* COMPONENT_ACTIVATE */ : "componentDeactivate" /* COMPONENT_DEACTIVATE */));
            }
            get isActive() {
                return this.active;
            }
            /**
             * Is true, when only one instance of the component class can be attached to a node
             */
            get isSingleton() {
                return this.singleton;
            }
            /**
             * Retrieves the node, this component is currently attached to
             * @returns The container node or null, if the component is not attached to
             */
            getContainer() {
                return this.container;
            }
            /**
             * Tries to add the component to the given node, removing it from the previous container if applicable
             * @param _container The node to attach this component to
             */
            setContainer(_container) {
                if (this.container == _container)
                    return;
                let previousContainer = this.container;
                try {
                    if (previousContainer)
                        previousContainer.removeComponent(this);
                    this.container = _container;
                    if (this.container)
                        this.container.addComponent(this);
                }
                catch (_error) {
                    this.container = previousContainer;
                }
            }
            //#region Transfer
            serialize() {
                let serialization = {
                    active: this.active
                };
                return serialization;
            }
            deserialize(_serialization) {
                this.active = _serialization.active;
                return this;
            }
            reduceMutator(_mutator) {
                delete _mutator.singleton;
                delete _mutator.container;
            }
        }
        /** refers back to this class from any subclass e.g. in order to find compatible other resources*/
        Component.baseClass = Component;
        /** list of all the subclasses derived from this class, if they registered properly*/
        Component.subclasses = [];
        return Component;
    })();
    FudgeCore.Component = Component;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="../Time/Loop.ts"/>
// / <reference path="../Animation/Animation.ts"/>
var FudgeCore;
// / <reference path="../Time/Loop.ts"/>
// / <reference path="../Animation/Animation.ts"/>
(function (FudgeCore) {
    /**
     * Holds different playmodes the animation uses to play back its animation.
     * @author Lukas Scheuerle, HFU, 2019
     */
    let ANIMATION_PLAYMODE;
    (function (ANIMATION_PLAYMODE) {
        /**Plays animation in a loop: it restarts once it hit the end.*/
        ANIMATION_PLAYMODE[ANIMATION_PLAYMODE["LOOP"] = 0] = "LOOP";
        /**Plays animation once and stops at the last key/frame*/
        ANIMATION_PLAYMODE[ANIMATION_PLAYMODE["PLAYONCE"] = 1] = "PLAYONCE";
        /**Plays animation once and stops on the first key/frame */
        ANIMATION_PLAYMODE[ANIMATION_PLAYMODE["PLAYONCESTOPAFTER"] = 2] = "PLAYONCESTOPAFTER";
        /**Plays animation like LOOP, but backwards.*/
        ANIMATION_PLAYMODE[ANIMATION_PLAYMODE["REVERSELOOP"] = 3] = "REVERSELOOP";
        /**Causes the animation not to play at all. Useful for jumping to various positions in the animation without proceeding in the animation.*/
        ANIMATION_PLAYMODE[ANIMATION_PLAYMODE["STOP"] = 4] = "STOP";
        //TODO: add an INHERIT and a PINGPONG mode
    })(ANIMATION_PLAYMODE = FudgeCore.ANIMATION_PLAYMODE || (FudgeCore.ANIMATION_PLAYMODE = {}));
    let ANIMATION_PLAYBACK;
    (function (ANIMATION_PLAYBACK) {
        //TODO: add an in-depth description of what happens to the animation (and events) depending on the Playback. Use Graphs to explain.
        /**Calculates the state of the animation at the exact position of time. Ignores FPS value of animation.*/
        ANIMATION_PLAYBACK[ANIMATION_PLAYBACK["TIMEBASED_CONTINOUS"] = 0] = "TIMEBASED_CONTINOUS";
        /**Limits the calculation of the state of the animation to the FPS value of the animation. Skips frames if needed.*/
        ANIMATION_PLAYBACK[ANIMATION_PLAYBACK["TIMEBASED_RASTERED_TO_FPS"] = 1] = "TIMEBASED_RASTERED_TO_FPS";
        /**Uses the FPS value of the animation to advance once per frame, no matter the speed of the frames. Doesn't skip any frames.*/
        ANIMATION_PLAYBACK[ANIMATION_PLAYBACK["FRAMEBASED"] = 2] = "FRAMEBASED";
    })(ANIMATION_PLAYBACK = FudgeCore.ANIMATION_PLAYBACK || (FudgeCore.ANIMATION_PLAYBACK = {}));
    /**
     * Holds a reference to an [[Animation]] and controls it. Controls playback and playmode as well as speed.
     * @authors Lukas Scheuerle, HFU, 2019
     */
    let ComponentAnimator = /** @class */ (() => {
        class ComponentAnimator extends FudgeCore.Component {
            constructor(_animation = new FudgeCore.Animation(""), _playmode = ANIMATION_PLAYMODE.LOOP, _playback = ANIMATION_PLAYBACK.TIMEBASED_CONTINOUS) {
                super();
                this.speedScalesWithGlobalSpeed = true;
                this.speedScale = 1;
                this.lastTime = 0;
                this.animation = _animation;
                this.playmode = _playmode;
                this.playback = _playback;
                this.localTime = new FudgeCore.Time();
                //TODO: update animation total time when loading a different animation?
                this.animation.calculateTotalTime();
                FudgeCore.Loop.addEventListener("loopFrame" /* LOOP_FRAME */, this.updateAnimationLoop.bind(this));
                FudgeCore.Time.game.addEventListener("timeScaled" /* TIME_SCALED */, this.updateScale.bind(this));
            }
            set speed(_s) {
                this.speedScale = _s;
                this.updateScale();
            }
            /**
             * Jumps to a certain time in the animation to play from there.
             * @param _time The time to jump to
             */
            jumpTo(_time) {
                this.localTime.set(_time);
                this.lastTime = _time;
                _time = _time % this.animation.totalTime;
                let mutator = this.animation.getMutated(_time, this.calculateDirection(_time), this.playback);
                this.getContainer().applyAnimation(mutator);
            }
            /**
             * Returns the current time of the animation, modulated for animation length.
             */
            getCurrentTime() {
                return this.localTime.get() % this.animation.totalTime;
            }
            /**
             * Forces an update of the animation from outside. Used in the ViewAnimation. Shouldn't be used during the game.
             * @param _time the (unscaled) time to update the animation with.
             * @returns a Tupel containing the Mutator for Animation and the playmode corrected time.
             */
            updateAnimation(_time) {
                return this.updateAnimationLoop(null, _time);
            }
            //#region transfer
            serialize() {
                let s = super.serialize();
                s["animation"] = this.animation.serialize();
                s["playmode"] = this.playmode;
                s["playback"] = this.playback;
                s["speedScale"] = this.speedScale;
                s["speedScalesWithGlobalSpeed"] = this.speedScalesWithGlobalSpeed;
                s[super.constructor.name] = super.serialize();
                return s;
            }
            deserialize(_s) {
                this.animation = new FudgeCore.Animation("");
                this.animation.deserialize(_s.animation);
                this.playback = _s.playback;
                this.playmode = _s.playmode;
                this.speedScale = _s.speedScale;
                this.speedScalesWithGlobalSpeed = _s.speedScalesWithGlobalSpeed;
                super.deserialize(_s[super.constructor.name]);
                return this;
            }
            //#endregion
            //#region updateAnimation
            /**
             * Updates the Animation.
             * Gets called every time the Loop fires the LOOP_FRAME Event.
             * Uses the built-in time unless a different time is specified.
             * May also be called from updateAnimation().
             */
            updateAnimationLoop(_e, _time) {
                if (this.animation.totalTime == 0)
                    return [null, 0];
                let time = _time || this.localTime.get();
                if (this.playback == ANIMATION_PLAYBACK.FRAMEBASED) {
                    time = this.lastTime + (1000 / this.animation.fps);
                }
                let direction = this.calculateDirection(time);
                time = this.applyPlaymodes(time);
                this.executeEvents(this.animation.getEventsToFire(this.lastTime, time, this.playback, direction));
                if (this.lastTime != time) {
                    this.lastTime = time;
                    time = time % this.animation.totalTime;
                    let mutator = this.animation.getMutated(time, direction, this.playback);
                    if (this.getContainer()) {
                        this.getContainer().applyAnimation(mutator);
                    }
                    return [mutator, time];
                }
                return [null, time];
            }
            /**
             * Fires all custom events the Animation should have fired between the last frame and the current frame.
             * @param events a list of names of custom events to fire
             */
            executeEvents(events) {
                for (let i = 0; i < events.length; i++) {
                    this.dispatchEvent(new Event(events[i]));
                }
            }
            /**
             * Calculates the actual time to use, using the current playmodes.
             * @param _time the time to apply the playmodes to
             * @returns the recalculated time
             */
            applyPlaymodes(_time) {
                switch (this.playmode) {
                    case ANIMATION_PLAYMODE.STOP:
                        return this.localTime.getOffset();
                    case ANIMATION_PLAYMODE.PLAYONCE:
                        if (_time >= this.animation.totalTime)
                            return this.animation.totalTime - 0.01; //TODO: this might cause some issues
                        else
                            return _time;
                    case ANIMATION_PLAYMODE.PLAYONCESTOPAFTER:
                        if (_time >= this.animation.totalTime)
                            return this.animation.totalTime + 0.01; //TODO: this might cause some issues
                        else
                            return _time;
                    default:
                        return _time;
                }
            }
            /**
             * Calculates and returns the direction the animation should currently be playing in.
             * @param _time the time at which to calculate the direction
             * @returns 1 if forward, 0 if stop, -1 if backwards
             */
            calculateDirection(_time) {
                switch (this.playmode) {
                    case ANIMATION_PLAYMODE.STOP:
                        return 0;
                    // case ANIMATION_PLAYMODE.PINGPONG:
                    //   if (Math.floor(_time / this.animation.totalTime) % 2 == 0)
                    //     return 1;
                    //   else
                    //     return -1;
                    case ANIMATION_PLAYMODE.REVERSELOOP:
                        return -1;
                    case ANIMATION_PLAYMODE.PLAYONCE:
                    case ANIMATION_PLAYMODE.PLAYONCESTOPAFTER:
                        if (_time >= this.animation.totalTime) {
                            return 0;
                        }
                    default:
                        return 1;
                }
            }
            /**
             * Updates the scale of the animation if the user changes it or if the global game timer changed its scale.
             */
            updateScale() {
                let newScale = this.speedScale;
                if (this.speedScalesWithGlobalSpeed)
                    newScale *= FudgeCore.Time.game.getScale();
                this.localTime.setScale(newScale);
            }
        }
        ComponentAnimator.iSubclass = FudgeCore.Component.registerSubclass(ComponentAnimator);
        return ComponentAnimator;
    })();
    FudgeCore.ComponentAnimator = ComponentAnimator;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let AUDIO_PANNER;
    (function (AUDIO_PANNER) {
        AUDIO_PANNER["CONE_INNER_ANGLE"] = "coneInnerAngle";
        AUDIO_PANNER["CONE_OUTER_ANGLE"] = "coneOuterAngle";
        AUDIO_PANNER["CONE_OUTER_GAIN"] = "coneOuterGain";
        AUDIO_PANNER["DISTANCE_MODEL"] = "distanceModel";
        AUDIO_PANNER["MAX_DISTANCE"] = "maxDistance";
        AUDIO_PANNER["PANNING_MODEL"] = "panningModel";
        AUDIO_PANNER["REF_DISTANCE"] = "refDistance";
        AUDIO_PANNER["ROLLOFF_FACTOR"] = "rolloffFactor";
    })(AUDIO_PANNER = FudgeCore.AUDIO_PANNER || (FudgeCore.AUDIO_PANNER = {}));
    let AUDIO_NODE_TYPE;
    (function (AUDIO_NODE_TYPE) {
        AUDIO_NODE_TYPE[AUDIO_NODE_TYPE["SOURCE"] = 0] = "SOURCE";
        AUDIO_NODE_TYPE[AUDIO_NODE_TYPE["PANNER"] = 1] = "PANNER";
        AUDIO_NODE_TYPE[AUDIO_NODE_TYPE["GAIN"] = 2] = "GAIN";
    })(AUDIO_NODE_TYPE = FudgeCore.AUDIO_NODE_TYPE || (FudgeCore.AUDIO_NODE_TYPE = {}));
    /**
     * Builds a minimal audio graph (by default in [[AudioManager]].default) and synchronizes it with the containing [[Node]]
     * ```plaintext
     * ‚îå AudioManager(.default) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     * ‚îÇ ‚îå ComponentAudio ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îÇ
     * ‚îÇ ‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
     * ‚îÇ ‚îÇ    ‚îÇsource‚îÇ ‚Üí ‚îÇpanner‚îÇ ‚Üí ‚îÇ gain ‚îÇ ‚Üí ‚îÇ gain ‚îÇ ‚îÇ
     * ‚îÇ ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
     * ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ
     * ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     * ```
     * @authors Thomas Dorner, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    let ComponentAudio = /** @class */ (() => {
        class ComponentAudio extends FudgeCore.Component {
            constructor(_audio = null, _loop = false, _start = false, _audioManager = FudgeCore.AudioManager.default) {
                super();
                /** places and directs the panner relative to the world transform of the [[Node]]  */
                this.pivot = FudgeCore.Matrix4x4.IDENTITY();
                this.singleton = false;
                this.playing = false;
                this.listened = false;
                /**
                 * Automatically connects/disconnects AudioNodes when adding/removing this component to/from a node.
                 * Therefore unused AudioNodes may be garbage collected when an unused component is collected
                 */
                this.handleAttach = (_event) => {
                    // Debug.log(_event);
                    if (_event.type == "componentAdd" /* COMPONENT_ADD */) {
                        this.getContainer().addEventListener("childAppendToAudioGraph" /* CHILD_APPEND */, this.handleGraph, true);
                        this.getContainer().addEventListener("childRemoveFromAudioGraph" /* CHILD_REMOVE */, this.handleGraph, true);
                        this.getContainer().addEventListener("updateAudioGraph" /* UPDATE */, this.update, true);
                        this.listened = this.getContainer().isDescendantOf(FudgeCore.AudioManager.default.getGraphListeningTo());
                    }
                    else {
                        this.getContainer().removeEventListener("childAppendToAudioGraph" /* CHILD_APPEND */, this.handleGraph, true);
                        this.getContainer().removeEventListener("childRemoveFromAudioGraph" /* CHILD_REMOVE */, this.handleGraph, true);
                        this.getContainer().removeEventListener("updateAudioGraph" /* UPDATE */, this.update, true);
                        this.listened = false;
                    }
                    this.updateConnection();
                };
                /**
                 * Automatically connects/disconnects AudioNodes when appending/removing the FUDGE-graph the component is in.
                 */
                this.handleGraph = (_event) => {
                    // Debug.log(_event);
                    this.listened = (_event.type == "childAppendToAudioGraph" /* CHILD_APPEND */);
                    this.updateConnection();
                };
                /**
                 * Updates the panner node, its position and direction, using the worldmatrix of the container and the pivot of this component.
                 */
                this.update = (_event) => {
                    let mtxResult = this.pivot;
                    if (this.getContainer())
                        mtxResult = FudgeCore.Matrix4x4.MULTIPLICATION(this.getContainer().mtxWorld, this.pivot);
                    // Debug.log(mtxResult.toString());
                    let position = mtxResult.translation;
                    let forward = FudgeCore.Vector3.TRANSFORMATION(FudgeCore.Vector3.Z(1), mtxResult, false);
                    this.panner.positionX.value = position.x;
                    this.panner.positionY.value = position.y;
                    this.panner.positionZ.value = position.z;
                    this.panner.orientationX.value = forward.x;
                    this.panner.orientationY.value = forward.y;
                    this.panner.orientationZ.value = forward.z;
                };
                this.install(_audioManager);
                this.createSource(_audio, _loop);
                this.addEventListener("componentAdd" /* COMPONENT_ADD */, this.handleAttach);
                this.addEventListener("componentRemove" /* COMPONENT_REMOVE */, this.handleAttach);
                if (_start)
                    this.play(_start);
            }
            set audio(_audio) {
                this.source.buffer = _audio;
            }
            get audio() {
                return this.source.buffer;
            }
            set volume(_value) {
                this.gain.gain.value = _value;
            }
            get volume() {
                return this.gain.gain.value;
            }
            /**
             * Set the property of the panner to the given value. Use to manipulate range and rolloff etc.
             */
            setPanner(_property, _value) {
                Object.assign(this.panner, { [_property]: _value });
            }
            // TODO: may be used for serialization of AudioNodes
            getMutatorOfNode(_type) {
                let node = this.getAudioNode(_type);
                let mutator = FudgeCore.getMutatorOfArbitrary(node);
                return mutator;
            }
            /**
             * Returns the specified AudioNode of the standard graph for further manipulation
             */
            getAudioNode(_type) {
                switch (_type) {
                    case AUDIO_NODE_TYPE.SOURCE: return this.source;
                    case AUDIO_NODE_TYPE.PANNER: return this.panner;
                    case AUDIO_NODE_TYPE.GAIN: return this.gain;
                }
            }
            /**
             * Start or stop playing the audio
             */
            play(_on) {
                if (_on) {
                    this.createSource(this.audio, this.source.loop);
                    this.source.start(0, 0);
                }
                else
                    this.source.stop();
                this.playing = _on;
            }
            get isPlaying() {
                return this.playing;
            }
            get isAttached() {
                return this.getContainer() != null;
            }
            get isListened() {
                return this.listened;
            }
            /**
             * Inserts AudioNodes between the panner and the local gain of this [[ComponentAudio]]
             * _input and _output may be the same AudioNode, if there is only one to insert,
             * or may have multiple AudioNode between them to create an effect-graph.\
             * Note that [[ComponentAudio]] does not keep track of inserted AudioNodes!
             * ```plaintext
             * ‚îå AudioManager(.default) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
             * ‚îÇ ‚îå ComponentAudio ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îÇ
             * ‚îÇ ‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
             * ‚îÇ ‚îÇ    ‚îÇsource‚îÇ ‚Üí ‚îÇpanner‚îÇ ‚Üí ‚îÇ_input‚îÇ ‚Üí ...  ‚Üí ‚îÇ_output‚îÇ ‚Üí ‚îÇ gain ‚îÇ ‚Üí ‚îÇ gain ‚îÇ ‚îÇ
             * ‚îÇ ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
             * ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ
             * ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             * ```
             */
            insertAudioNodes(_input, _output) {
                this.panner.disconnect(0);
                if (!_input && !_output) {
                    this.panner.connect(this.gain);
                    return;
                }
                this.panner.connect(_input);
                _output.connect(this.gain);
            }
            /**
             * Activate override. Connects or disconnects AudioNodes
             */
            activate(_on) {
                super.activate(_on);
                this.updateConnection();
            }
            /**
             * Connects this components gain-node to the gain node of the AudioManager this component runs on.
             * Only call this method if the component is not attached to a [[Node]] but needs to be heard.
             */
            connect(_on) {
                if (_on)
                    this.gain.connect(this.audioManager.gain);
                else
                    this.gain.disconnect(this.audioManager.gain);
            }
            install(_audioManager = FudgeCore.AudioManager.default) {
                let active = this.isActive;
                this.activate(false);
                this.audioManager = _audioManager;
                this.panner = _audioManager.createPanner();
                this.gain = _audioManager.createGain();
                this.panner.connect(this.gain);
                this.gain.connect(_audioManager.gain);
                this.activate(active);
            }
            createSource(_audio, _loop) {
                if (this.source) {
                    this.source.disconnect();
                    this.source.buffer = null;
                }
                this.source = this.audioManager.createBufferSource();
                this.source.connect(this.panner);
                if (_audio)
                    this.audio = _audio;
                this.source.loop = _loop;
            }
            updateConnection() {
                try {
                    this.connect(this.isActive && this.isAttached && this.listened);
                }
                catch (_error) {
                    // nop
                }
            }
        }
        ComponentAudio.iSubclass = FudgeCore.Component.registerSubclass(ComponentAudio);
        return ComponentAudio;
    })();
    FudgeCore.ComponentAudio = ComponentAudio;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Serves to set the spatial location and orientation of AudioListeners relative to the
     * world transform of the [[Node]] it is attached to.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    let ComponentAudioListener = /** @class */ (() => {
        class ComponentAudioListener extends FudgeCore.Component {
            constructor() {
                super(...arguments);
                this.pivot = FudgeCore.Matrix4x4.IDENTITY();
            }
            /**
             * Updates the position and orientation of the given AudioListener
             */
            update(_listener) {
                let mtxResult = this.pivot;
                if (this.getContainer())
                    mtxResult = FudgeCore.Matrix4x4.MULTIPLICATION(this.getContainer().mtxWorld, this.pivot);
                // Debug.log(mtxResult.toString());
                let position = mtxResult.translation;
                let forward = FudgeCore.Vector3.TRANSFORMATION(FudgeCore.Vector3.Z(1), mtxResult, false);
                let up = FudgeCore.Vector3.TRANSFORMATION(FudgeCore.Vector3.Y(), mtxResult, false);
                _listener.positionX.value = position.x;
                _listener.positionY.value = position.y;
                _listener.positionZ.value = position.z;
                _listener.forwardX.value = forward.x;
                _listener.forwardY.value = forward.y;
                _listener.forwardZ.value = forward.z;
                _listener.upX.value = up.x;
                _listener.upY.value = up.y;
                _listener.upZ.value = up.z;
                // Debug.log(mtxResult.translation.toString(), forward.toString(), up.toString());
            }
        }
        ComponentAudioListener.iSubclass = FudgeCore.Component.registerSubclass(ComponentAudioListener);
        return ComponentAudioListener;
    })();
    FudgeCore.ComponentAudioListener = ComponentAudioListener;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="Component.ts"/>
var FudgeCore;
// / <reference path="Component.ts"/>
(function (FudgeCore) {
    let FIELD_OF_VIEW;
    (function (FIELD_OF_VIEW) {
        FIELD_OF_VIEW[FIELD_OF_VIEW["HORIZONTAL"] = 0] = "HORIZONTAL";
        FIELD_OF_VIEW[FIELD_OF_VIEW["VERTICAL"] = 1] = "VERTICAL";
        FIELD_OF_VIEW[FIELD_OF_VIEW["DIAGONAL"] = 2] = "DIAGONAL";
    })(FIELD_OF_VIEW = FudgeCore.FIELD_OF_VIEW || (FudgeCore.FIELD_OF_VIEW = {}));
    /**
     * Defines identifiers for the various projections a camera can provide.
     * TODO: change back to number enum if strings not needed
     */
    let PROJECTION;
    (function (PROJECTION) {
        PROJECTION["CENTRAL"] = "central";
        PROJECTION["ORTHOGRAPHIC"] = "orthographic";
        PROJECTION["DIMETRIC"] = "dimetric";
        PROJECTION["STEREO"] = "stereo";
    })(PROJECTION = FudgeCore.PROJECTION || (FudgeCore.PROJECTION = {}));
    /**
     * The camera component holds the projection-matrix and other data needed to render a scene from the perspective of the node it is attached to.
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    let ComponentCamera = /** @class */ (() => {
        class ComponentCamera extends FudgeCore.Component {
            constructor() {
                super(...arguments);
                this.pivot = FudgeCore.Matrix4x4.IDENTITY();
                this.backgroundColor = new FudgeCore.Color(0, 0, 0, 1); // The color of the background the camera will render.
                //private orthographic: boolean = false; // Determines whether the image will be rendered with perspective or orthographic projection.
                this.projection = PROJECTION.CENTRAL;
                this.transform = new FudgeCore.Matrix4x4; // The matrix to multiply each scene objects transformation by, to determine where it will be drawn.
                this.fieldOfView = 45; // The camera's sensorangle.
                this.aspectRatio = 1.0;
                this.direction = FIELD_OF_VIEW.DIAGONAL;
                this.backgroundEnabled = true; // Determines whether or not the background of this camera will be rendered.
                //#endregion
            }
            // TODO: examine, if background should be an attribute of Camera or Viewport
            getProjection() {
                return this.projection;
            }
            getBackgroundEnabled() {
                return this.backgroundEnabled;
            }
            getAspect() {
                return this.aspectRatio;
            }
            getFieldOfView() {
                return this.fieldOfView;
            }
            getDirection() {
                return this.direction;
            }
            /**
             * Returns the multiplikation of the worldtransformation of the camera container with the projection matrix
             * @returns the world-projection-matrix
             */
            get ViewProjectionMatrix() {
                //TODO: optimize, no need to recalculate if neither mtxWorld nor pivot have changed
                let mtxCamera = this.pivot;
                try {
                    mtxCamera = FudgeCore.Matrix4x4.MULTIPLICATION(this.getContainer().mtxWorld, this.pivot);
                }
                catch (_error) {
                    // no container node or no world transformation found -> continue with pivot only
                }
                let mtxWorldProjection = FudgeCore.Matrix4x4.INVERSION(mtxCamera);
                mtxWorldProjection = FudgeCore.Matrix4x4.MULTIPLICATION(this.transform, mtxWorldProjection);
                return mtxWorldProjection;
            }
            /**
             * Set the camera to perspective projection. The world origin is in the center of the canvaselement.
             * @param _aspect The aspect ratio between width and height of projectionspace.(Default = canvas.clientWidth / canvas.ClientHeight)
             * @param _fieldOfView The field of view in Degrees. (Default = 45)
             * @param _direction The plane on which the fieldOfView-Angle is given
             */
            projectCentral(_aspect = this.aspectRatio, _fieldOfView = this.fieldOfView, _direction = this.direction) {
                this.aspectRatio = _aspect;
                this.fieldOfView = _fieldOfView;
                this.direction = _direction;
                this.projection = PROJECTION.CENTRAL;
                this.transform = FudgeCore.Matrix4x4.PROJECTION_CENTRAL(_aspect, this.fieldOfView, 1, 2000, this.direction); // TODO: remove magic numbers
            }
            /**
             * Set the camera to orthographic projection. The origin is in the top left corner of the canvas.
             * @param _left The positionvalue of the projectionspace's left border. (Default = 0)
             * @param _right The positionvalue of the projectionspace's right border. (Default = canvas.clientWidth)
             * @param _bottom The positionvalue of the projectionspace's bottom border.(Default = canvas.clientHeight)
             * @param _top The positionvalue of the projectionspace's top border.(Default = 0)
             */
            projectOrthographic(_left = 0, _right = FudgeCore.RenderManager.getCanvas().clientWidth, _bottom = FudgeCore.RenderManager.getCanvas().clientHeight, _top = 0) {
                this.projection = PROJECTION.ORTHOGRAPHIC;
                this.transform = FudgeCore.Matrix4x4.PROJECTION_ORTHOGRAPHIC(_left, _right, _bottom, _top, 400, -400); // TODO: examine magic numbers!
            }
            /**
             * Return the calculated normed dimension of the projection surface, that is in the hypothetical distance of 1 to the camera
             */
            getProjectionRectangle() {
                let tanFov = Math.tan(Math.PI * this.fieldOfView / 360); // Half of the angle, to calculate dimension from the center -> right angle
                let tanHorizontal = 0;
                let tanVertical = 0;
                if (this.direction == FIELD_OF_VIEW.DIAGONAL) {
                    let aspect = Math.sqrt(this.aspectRatio);
                    tanHorizontal = tanFov * aspect;
                    tanVertical = tanFov / aspect;
                }
                else if (this.direction == FIELD_OF_VIEW.VERTICAL) {
                    tanVertical = tanFov;
                    tanHorizontal = tanVertical * this.aspectRatio;
                }
                else { //FOV_DIRECTION.HORIZONTAL
                    tanHorizontal = tanFov;
                    tanVertical = tanHorizontal / this.aspectRatio;
                }
                return FudgeCore.Rectangle.GET(0, 0, tanHorizontal * 2, tanVertical * 2);
            }
            project(_pointInWorldSpace) {
                let result;
                result = FudgeCore.Vector3.TRANSFORMATION(_pointInWorldSpace, this.ViewProjectionMatrix);
                let m = this.ViewProjectionMatrix.get();
                let w = m[3] * _pointInWorldSpace.x + m[7] * _pointInWorldSpace.y + m[11] * _pointInWorldSpace.z + m[15];
                result.scale(1 / w);
                return result;
            }
            //#region Transfer
            serialize() {
                let serialization = {
                    backgroundColor: this.backgroundColor,
                    backgroundEnabled: this.backgroundEnabled,
                    projection: this.projection,
                    fieldOfView: this.fieldOfView,
                    direction: this.direction,
                    aspect: this.aspectRatio,
                    pivot: this.pivot.serialize(),
                    [super.constructor.name]: super.serialize()
                };
                return serialization;
            }
            deserialize(_serialization) {
                this.backgroundColor = _serialization.backgroundColor;
                this.backgroundEnabled = _serialization.backgroundEnabled;
                this.projection = _serialization.projection;
                this.fieldOfView = _serialization.fieldOfView;
                this.aspectRatio = _serialization.aspect;
                this.direction = _serialization.direction;
                this.pivot.deserialize(_serialization.pivot);
                super.deserialize(_serialization[super.constructor.name]);
                switch (this.projection) {
                    case PROJECTION.ORTHOGRAPHIC:
                        this.projectOrthographic(); // TODO: serialize and deserialize parameters
                        break;
                    case PROJECTION.CENTRAL:
                        this.projectCentral();
                        break;
                }
                return this;
            }
            getMutatorAttributeTypes(_mutator) {
                let types = super.getMutatorAttributeTypes(_mutator);
                if (types.direction)
                    types.direction = FIELD_OF_VIEW;
                if (types.projection)
                    types.projection = PROJECTION;
                return types;
            }
            mutate(_mutator) {
                super.mutate(_mutator);
                switch (this.projection) {
                    case PROJECTION.CENTRAL:
                        this.projectCentral(this.aspectRatio, this.fieldOfView, this.direction);
                        break;
                }
            }
            reduceMutator(_mutator) {
                delete _mutator.transform;
                super.reduceMutator(_mutator);
            }
        }
        ComponentCamera.iSubclass = FudgeCore.Component.registerSubclass(ComponentCamera);
        return ComponentCamera;
    })();
    FudgeCore.ComponentCamera = ComponentCamera;
})(FudgeCore || (FudgeCore = {}));
// /<reference path="../Light/Light.ts"/>
var FudgeCore;
// /<reference path="../Light/Light.ts"/>
(function (FudgeCore) {
    /**
     * Attaches a [[Light]] to the node
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    /**
     * Defines identifiers for the various types of light this component can provide.
     */
    // export enum LIGHT_TYPE {
    //     AMBIENT = "ambient",
    //     DIRECTIONAL = "directional",
    //     POINT = "point",
    //     SPOT = "spot"
    // }
    let ComponentLight = /** @class */ (() => {
        class ComponentLight extends FudgeCore.Component {
            constructor(_light = new FudgeCore.LightAmbient()) {
                super();
                // private static constructors: { [type: string]: General } = { [LIGHT_TYPE.AMBIENT]: LightAmbient, [LIGHT_TYPE.DIRECTIONAL]: LightDirectional, [LIGHT_TYPE.POINT]: LightPoint, [LIGHT_TYPE.SPOT]: LightSpot };
                this.pivot = FudgeCore.Matrix4x4.IDENTITY();
                this.light = null;
                this.singleton = false;
                this.light = _light;
            }
            setType(_class) {
                let mtrOld = {};
                if (this.light)
                    mtrOld = this.light.getMutator();
                this.light = new _class();
                this.light.mutate(mtrOld);
            }
        }
        ComponentLight.iSubclass = FudgeCore.Component.registerSubclass(ComponentLight);
        return ComponentLight;
    })();
    FudgeCore.ComponentLight = ComponentLight;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Attaches a [[Material]] to the node
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    let ComponentMaterial = /** @class */ (() => {
        class ComponentMaterial extends FudgeCore.Component {
            // public mutatorCoat: MutatorForComponent;
            constructor(_material = null) {
                super();
                this.clrPrimary = FudgeCore.Color.CSS("white");
                this.clrSecondary = FudgeCore.Color.CSS("white");
                this.pivot = FudgeCore.Matrix3x3.IDENTITY();
                this.material = _material;
                // this.mutatorCoat = _material.getCoat().getMutatorForComponent();
            }
            //#region Transfer
            serialize() {
                let serialization;
                /* at this point of time, serialization as resource and as inline object is possible. TODO: check if inline becomes obsolete */
                let idMaterial = this.material.idResource;
                if (idMaterial)
                    serialization = { idMaterial: idMaterial };
                else
                    serialization = { material: FudgeCore.Serializer.serialize(this.material) };
                serialization[super.constructor.name] = super.serialize();
                return serialization;
            }
            deserialize(_serialization) {
                let material;
                if (_serialization.idMaterial)
                    material = FudgeCore.ResourceManager.get(_serialization.idMaterial);
                else
                    material = FudgeCore.Serializer.deserialize(_serialization.material);
                this.material = material;
                super.deserialize(_serialization[super.constructor.name]);
                return this;
            }
        }
        ComponentMaterial.iSubclass = FudgeCore.Component.registerSubclass(ComponentMaterial);
        return ComponentMaterial;
    })();
    FudgeCore.ComponentMaterial = ComponentMaterial;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Attaches a [[Mesh]] to the node
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    let ComponentMesh = /** @class */ (() => {
        class ComponentMesh extends FudgeCore.Component {
            constructor(_mesh = null) {
                super();
                this.pivot = FudgeCore.Matrix4x4.IDENTITY();
                this.mesh = null;
                this.mesh = _mesh;
            }
            //#region Transfer
            serialize() {
                let serialization;
                /* at this point of time, serialization as resource and as inline object is possible. TODO: check if inline becomes obsolete */
                let idMesh = this.mesh.idResource;
                if (idMesh)
                    serialization = { idMesh: idMesh };
                else
                    serialization = { mesh: FudgeCore.Serializer.serialize(this.mesh) };
                serialization.pivot = this.pivot.serialize();
                serialization[super.constructor.name] = super.serialize();
                return serialization;
            }
            deserialize(_serialization) {
                let mesh;
                if (_serialization.idMesh)
                    mesh = FudgeCore.ResourceManager.get(_serialization.idMesh);
                else
                    mesh = FudgeCore.Serializer.deserialize(_serialization.mesh);
                this.mesh = mesh;
                this.pivot.deserialize(_serialization.pivot);
                super.deserialize(_serialization[super.constructor.name]);
                return this;
            }
            getMutatorForUserInterface() {
                let mutator = this.getMutator();
                if (!this.mesh)
                    mutator.mesh = FudgeCore.Mesh;
                return mutator;
            }
        }
        ComponentMesh.iSubclass = FudgeCore.Component.registerSubclass(ComponentMesh);
        return ComponentMesh;
    })();
    FudgeCore.ComponentMesh = ComponentMesh;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Base class for scripts the user writes
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Component
     */
    let ComponentScript = /** @class */ (() => {
        class ComponentScript extends FudgeCore.Component {
            constructor() {
                super();
                this.singleton = false;
            }
            serialize() {
                return this.getMutator();
            }
            deserialize(_serialization) {
                this.mutate(_serialization);
                return this;
            }
        }
        // registering this doesn't make sense, only its subclasses. Or this component must refer to scripts to be attached to this component
        // TODO: rethink & refactor
        ComponentScript.iSubclass = FudgeCore.Component.registerSubclass(ComponentScript);
        return ComponentScript;
    })();
    FudgeCore.ComponentScript = ComponentScript;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let BASE;
    (function (BASE) {
        BASE[BASE["SELF"] = 0] = "SELF";
        BASE[BASE["PARENT"] = 1] = "PARENT";
        BASE[BASE["WORLD"] = 2] = "WORLD";
        BASE[BASE["NODE"] = 3] = "NODE";
    })(BASE = FudgeCore.BASE || (FudgeCore.BASE = {}));
    /**
     * Attaches a transform-[[Matrix4x4]] to the node, moving, scaling and rotating it in space relative to its parent.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    let ComponentTransform = /** @class */ (() => {
        class ComponentTransform extends FudgeCore.Component {
            constructor(_matrix = FudgeCore.Matrix4x4.IDENTITY()) {
                super();
                this.local = _matrix;
            }
            //#region Transformations respecting the hierarchy
            /**
             * Adjusts the rotation to point the z-axis directly at the given target point in world space and tilts it to accord with the given up vector,
             * respectively calculating yaw and pitch. If no up vector is given, the previous up-vector is used.
             */
            lookAt(_targetWorld, _up) {
                let container = this.getContainer();
                if (!container && !container.getParent())
                    return this.local.lookAt(_targetWorld, _up);
                // component is attached to a child node -> transform respecting the hierarchy
                let mtxWorld = container.mtxWorld.copy;
                mtxWorld.lookAt(_targetWorld, _up, true);
                let local = FudgeCore.Matrix4x4.RELATIVE(mtxWorld, null, container.getParent().mtxWorldInverse);
                this.local = local;
            }
            /**
             * Adjusts the rotation to match its y-axis with the given up-vector and facing its z-axis toward the given target at minimal angle,
             * respectively calculating yaw only. If no up vector is given, the previous up-vector is used.
             */
            showTo(_targetWorld, _up) {
                let container = this.getContainer();
                if (!container && !container.getParent())
                    return this.local.showTo(_targetWorld, _up);
                // component is attached to a child node -> transform respecting the hierarchy
                let mtxWorld = container.mtxWorld.copy;
                mtxWorld.showTo(_targetWorld, _up, true);
                let local = FudgeCore.Matrix4x4.RELATIVE(mtxWorld, null, container.getParent().mtxWorldInverse);
                this.local = local;
            }
            /**
             * recalculates this local matrix to yield the identical world matrix based on the given node.
             * Use rebase before appending the container of this component to another node while preserving its transformation in the world.
             */
            rebase(_node = null) {
                let mtxResult = this.local;
                let container = this.getContainer();
                if (container)
                    mtxResult = container.mtxWorld;
                if (_node)
                    mtxResult = FudgeCore.Matrix4x4.RELATIVE(mtxResult, null, _node.mtxWorldInverse);
                this.local = mtxResult;
            }
            /**
             * Applies the given transformation relative to the selected base (SELF, PARENT, WORLD) or a particular other node (NODE)
             */
            transform(_transform, _base = BASE.SELF, _node = null) {
                switch (_base) {
                    case BASE.SELF:
                        this.local.multiply(_transform);
                        break;
                    case BASE.PARENT:
                        this.local.multiply(_transform, true);
                        break;
                    case BASE.NODE:
                        if (!_node)
                            throw new Error("BASE.NODE requires a node given as base");
                    case BASE.WORLD:
                        this.rebase(_node);
                        this.local.multiply(_transform, true);
                        let container = this.getContainer();
                        if (container) {
                            if (_base == BASE.NODE)
                                // fix mtxWorld of container for subsequent rebasing 
                                container.mtxWorld.set(FudgeCore.Matrix4x4.MULTIPLICATION(_node.mtxWorld, container.mtxLocal));
                            let parent = container.getParent();
                            if (parent) {
                                // fix mtxLocal for current parent
                                this.rebase(container.getParent());
                                container.mtxWorld.set(FudgeCore.Matrix4x4.MULTIPLICATION(container.getParent().mtxWorld, container.mtxLocal));
                            }
                        }
                        break;
                }
            }
            //#endregion
            //#region Transfer
            serialize() {
                let serialization = {
                    local: this.local.serialize(),
                    [super.constructor.name]: super.serialize()
                };
                return serialization;
            }
            deserialize(_serialization) {
                super.deserialize(_serialization[super.constructor.name]);
                this.local.deserialize(_serialization.local);
                return this;
            }
            // public mutate(_mutator: Mutator): void {
            //     this.local.mutate(_mutator);
            // }
            // public getMutator(): Mutator { 
            //     return this.local.getMutator();
            // }
            // public getMutatorAttributeTypes(_mutator: Mutator): MutatorAttributeTypes {
            //     let types: MutatorAttributeTypes = this.local.getMutatorAttributeTypes(_mutator);
            //     return types;
            // }
            reduceMutator(_mutator) {
                delete _mutator.world;
                super.reduceMutator(_mutator);
            }
        }
        ComponentTransform.iSubclass = FudgeCore.Component.registerSubclass(ComponentTransform);
        return ComponentTransform;
    })();
    FudgeCore.ComponentTransform = ComponentTransform;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Processes input signals of type number and generates an output signal of the same type using
     * proportional, integral or differential mapping, an amplification factor and a linear dampening/delay
     * ```plaintext
     *          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     *          ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      pass through (Proportional)      ‚îÇ
     *  Input ‚Üí ‚îÇ ‚Üí ‚îÇamplify‚îÇ ‚Üí ‚îÇdelay‚îÇ ‚Üí ‚öü sum up over time (Integral) ‚öû ‚Üí ‚îÇ ‚Üí Output
     *          ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      pass change  (Differential)      ‚îÇ
     *          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     * ```
     */
    class Control extends EventTarget {
        constructor(_name, _factor = 1, _type = 0 /* PROPORTIONAL */, _active = true) {
            super();
            this.rateDispatchOutput = 0;
            this.valuePrevious = 0;
            this.outputBase = 0;
            this.outputTarget = 0;
            this.outputPrevious = 0;
            this.outputTargetPrevious = 0;
            this.factor = 0;
            this.time = FudgeCore.Time.game;
            this.timeValueDelay = 0;
            this.timeOutputTargetSet = 0;
            this.idTimer = undefined;
            this.dispatchOutput = (_eventOrValue) => {
                let timer = this.time.getTimer(this.idTimer);
                let output;
                if (typeof (_eventOrValue) == "number")
                    output = _eventOrValue;
                else
                    output = this.calculateOutput();
                let outputChanged = (output != this.outputPrevious);
                if (timer)
                    timer.active = outputChanged;
                if (!outputChanged)
                    return;
                this.outputPrevious = output;
                let event = new CustomEvent("output" /* OUTPUT */, {
                    detail: {
                        output: output
                    }
                });
                this.dispatchEvent(event);
            };
            this.factor = _factor;
            this.type = _type;
            this.active = _active;
            this.name = _name;
        }
        /**
         * Set the time-object to be used when calculating the output in [[CONTROL_TYPE.INTEGRAL]]
         */
        setTimebase(_time) {
            this.time = _time;
            this.calculateOutput();
        }
        /**
         * Feed an input value into this control and fire the events [[EVENT_CONTROL.INPUT]] and [[EVENT_CONTROL.OUTPUT]]
         */
        setInput(_input) {
            this.outputBase = this.calculateOutput();
            this.valuePrevious = this.getValueDelayed();
            this.outputTarget = this.factor * _input;
            this.timeOutputTargetSet = this.time.get();
            if (this.type == 2 /* DIFFERENTIAL */) {
                this.valuePrevious = this.outputTarget - this.outputTargetPrevious;
                this.outputTargetPrevious = this.outputTarget;
                this.outputTarget = 0;
            }
            this.dispatchEvent(new Event("input" /* INPUT */));
            if (this.type == 2 /* DIFFERENTIAL */)
                this.dispatchOutput(this.valuePrevious);
            else
                this.dispatchOutput(null);
        }
        /**
         * Set the time to take for the internal linear dampening until the final ouput value is reached
         */
        setDelay(_time) {
            this.timeValueDelay = Math.max(0, _time);
        }
        /**
         * Set the number of output-events to dispatch per second.
         * At the default of 0, the control output must be polled and will only actively dispatched once each time input occurs and the output changes.
         */
        setRateDispatchOutput(_rateDispatchOutput = 0) {
            this.rateDispatchOutput = _rateDispatchOutput;
            this.time.deleteTimer(this.idTimer);
            this.idTimer = undefined;
            if (this.rateDispatchOutput)
                this.idTimer = this.time.setTimer(1000 / this.rateDispatchOutput, 0, this.dispatchOutput);
        }
        /**
         * Set the factor to multiply the input value given with [[setInput]] with
         */
        setFactor(_factor) {
            this.factor = _factor;
        }
        /**
         * Get the value from the output of this control
         */
        getOutput() {
            return this.calculateOutput();
        }
        /**
         * Calculates the output of this control
         */
        calculateOutput() {
            let output = 0;
            let value = this.getValueDelayed();
            switch (this.type) {
                case 1 /* INTEGRAL */:
                    let timeCurrent = this.time.get();
                    let timeElapsedSinceInput = timeCurrent - this.timeOutputTargetSet;
                    output = this.outputBase;
                    if (this.timeValueDelay > 0) {
                        if (timeElapsedSinceInput < this.timeValueDelay) {
                            output += 0.5 * (this.valuePrevious + value) * timeElapsedSinceInput;
                            break;
                        }
                        else {
                            output += 0.5 * (this.valuePrevious + value) * this.timeValueDelay;
                            timeElapsedSinceInput -= this.timeValueDelay;
                        }
                    }
                    output += value * timeElapsedSinceInput;
                    // value += 0.5 * (this.inputPrevious - input) * this.timeInputDelay + input * timeElapsedSinceInput;
                    break;
                case 2 /* DIFFERENTIAL */:
                case 0 /* PROPORTIONAL */:
                default:
                    output = value;
                    break;
            }
            return output;
        }
        getValueDelayed() {
            if (this.timeValueDelay > 0) {
                let timeElapsedSinceInput = this.time.get() - this.timeOutputTargetSet;
                if (timeElapsedSinceInput < this.timeValueDelay)
                    return this.valuePrevious + (this.outputTarget - this.valuePrevious) * timeElapsedSinceInput / this.timeValueDelay;
            }
            return this.outputTarget;
        }
    }
    FudgeCore.Control = Control;
})(FudgeCore || (FudgeCore = {}));
///<reference path="Control.ts"/>
var FudgeCore;
///<reference path="Control.ts"/>
(function (FudgeCore) {
    /**
     * Handles multiple controls as inputs and creates an output from that.
     * As a subclass of [[Control]], axis calculates the ouput summing up the inputs and processing the result using its own settings.
     * Dispatches [[EVENT_CONTROL.OUTPUT]] and [[EVENT_CONTROL.INPUT]] when one of the controls dispatches them.
     * ```plaintext
     *           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     *           ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                 ‚îÇ
     *   Input ‚Üí ‚îÇ ‚îÇcontrol‚îÇ\                                ‚îÇ
     *           ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò \                               ‚îÇ
     *           ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  \‚îå‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
     *   Input ‚Üí ‚îÇ ‚îÇcontrol‚îÇ---‚îÇsum‚îÇ ‚Üí ‚îÇinternal control ‚îÇ ‚Üí ‚îÇ ‚Üí Output
     *           ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  /‚îî‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
     *           ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê /                               ‚îÇ
     *   Input ‚Üí ‚îÇ ‚îÇcontrol‚îÇ/                                ‚îÇ
     *           ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                 ‚îÇ
     *           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     * ```
     */
    class Axis extends FudgeCore.Control {
        constructor() {
            super(...arguments);
            this.controls = new Map();
            this.sumPrevious = 0;
            this.hndOutputEvent = (_event) => {
                let control = _event.target;
                let event = new CustomEvent("output" /* OUTPUT */, { detail: {
                        control: control,
                        input: _event.detail.output,
                        output: this.getOutput()
                    } });
                this.dispatchEvent(event);
            };
            this.hndInputEvent = (_event) => {
                let event = new Event("input" /* INPUT */, _event);
                this.dispatchEvent(event);
            };
        }
        /**
         * Add the control given to the list of controls feeding into this axis
         */
        addControl(_control) {
            this.controls.set(_control.name, _control);
            _control.addEventListener("input" /* INPUT */, this.hndInputEvent);
            _control.addEventListener("output" /* OUTPUT */, this.hndOutputEvent);
        }
        /**
         * Returns the control with the given name
         */
        getControl(_name) {
            return this.controls.get(_name);
        }
        /**
         * Removes the control with the given name
         */
        removeControl(_name) {
            let control = this.getControl(_name);
            if (control) {
                control.removeEventListener("input" /* INPUT */, this.hndInputEvent);
                control.removeEventListener("output" /* OUTPUT */, this.hndOutputEvent);
                this.controls.delete(_name);
            }
        }
        /**
         * Returns the value of this axis after summing up all inputs and processing the sum according to the axis' settings
         */
        getOutput() {
            let sumInput = 0;
            for (let control of this.controls) {
                if (control[1].active)
                    sumInput += control[1].getOutput();
            }
            if (sumInput != this.sumPrevious)
                super.setInput(sumInput);
            this.sumPrevious = sumInput;
            return super.getOutput();
        }
    }
    FudgeCore.Axis = Axis;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Collects the keys pressed on the keyboard and stores their status.
     */
    let Keyboard = /** @class */ (() => {
        class Keyboard {
            /**
             * Returns true if one of the given keys is is currently being pressed.
             */
            static isPressedOne(_keys) {
                for (let code of _keys) {
                    if (Keyboard.keysPressed[code])
                        return true;
                }
                return false;
            }
            /**
             * Returns true if all of the given keys are currently being pressed
             */
            static isPressedCombo(_keys) {
                for (let code of _keys) {
                    if (!Keyboard.keysPressed[code])
                        return false;
                }
                return true;
            }
            /**
             * Returns the value given as _active if one or, when _combo is true, all of the given keys are pressed.
             * Returns the value given as _inactive if not.
             */
            static mapToValue(_active, _inactive, _keys, _combo = false) {
                if (!_combo && Keyboard.isPressedOne(_keys))
                    return _active;
                if (Keyboard.isPressedCombo(_keys))
                    return _active;
                return _inactive;
            }
            static initialize() {
                let store = {};
                document.addEventListener("keydown", Keyboard.hndKeyInteraction);
                document.addEventListener("keyup", Keyboard.hndKeyInteraction);
                return store;
            }
            static hndKeyInteraction(_event) {
                Keyboard.keysPressed[_event.code] = (_event.type == "keydown");
            }
        }
        Keyboard.keysPressed = Keyboard.initialize();
        return Keyboard;
    })();
    FudgeCore.Keyboard = Keyboard;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
(function (FudgeCore) {
    /**
     * Routing to the alert box
     */
    let DebugAlert = /** @class */ (() => {
        class DebugAlert extends FudgeCore.DebugTarget {
            static createDelegate(_headline) {
                let delegate = function (_message, ..._args) {
                    let args = _args.map(_arg => _arg.toString());
                    let out = _headline + " " + FudgeCore.DebugTarget.mergeArguments(_message, args);
                    alert(out);
                };
                return delegate;
            }
        }
        DebugAlert.delegates = {
            [FudgeCore.DEBUG_FILTER.INFO]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.INFO]),
            [FudgeCore.DEBUG_FILTER.LOG]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.LOG]),
            [FudgeCore.DEBUG_FILTER.WARN]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.WARN]),
            [FudgeCore.DEBUG_FILTER.ERROR]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.ERROR]),
            [FudgeCore.DEBUG_FILTER.FUDGE]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.FUDGE])
        };
        return DebugAlert;
    })();
    FudgeCore.DebugAlert = DebugAlert;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
(function (FudgeCore) {
    /**
     * Routing to a HTMLDialogElement
     */
    class DebugDialog extends FudgeCore.DebugTarget {
    }
    FudgeCore.DebugDialog = DebugDialog;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
(function (FudgeCore) {
    /**
     * Route to an HTMLTextArea, may be obsolete when using HTMLDialogElement
     */
    let DebugTextArea = /** @class */ (() => {
        class DebugTextArea extends FudgeCore.DebugTarget {
            static clear() {
                DebugTextArea.textArea.textContent = "";
                DebugTextArea.groups = [];
            }
            static group(_name) {
                DebugTextArea.print("‚ñº " + _name);
                DebugTextArea.groups.push(_name);
            }
            static groupEnd() {
                DebugTextArea.groups.pop();
            }
            static createDelegate(_headline) {
                let delegate = function (_message, ..._args) {
                    DebugTextArea.print(_headline + " " + FudgeCore.DebugTarget.mergeArguments(_message, _args));
                };
                return delegate;
            }
            static getIndentation(_level) {
                let result = "";
                for (let i = 0; i < _level; i++)
                    result += "| ";
                return result;
            }
            static print(_text) {
                DebugTextArea.textArea.textContent += DebugTextArea.getIndentation(DebugTextArea.groups.length) + _text + "\n";
                if (DebugTextArea.autoScroll)
                    DebugTextArea.textArea.scrollTop = DebugTextArea.textArea.scrollHeight;
            }
        }
        DebugTextArea.textArea = document.createElement("textarea");
        DebugTextArea.autoScroll = true;
        DebugTextArea.delegates = {
            [FudgeCore.DEBUG_FILTER.INFO]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.INFO]),
            [FudgeCore.DEBUG_FILTER.LOG]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.LOG]),
            [FudgeCore.DEBUG_FILTER.WARN]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.WARN]),
            [FudgeCore.DEBUG_FILTER.ERROR]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.ERROR]),
            [FudgeCore.DEBUG_FILTER.FUDGE]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.FUDGE]),
            [FudgeCore.DEBUG_FILTER.CLEAR]: DebugTextArea.clear,
            [FudgeCore.DEBUG_FILTER.GROUP]: DebugTextArea.group,
            [FudgeCore.DEBUG_FILTER.GROUPCOLLAPSED]: DebugTextArea.group,
            [FudgeCore.DEBUG_FILTER.GROUPEND]: DebugTextArea.groupEnd
        };
        DebugTextArea.groups = [];
        return DebugTextArea;
    })();
    FudgeCore.DebugTextArea = DebugTextArea;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Defines a color as values in the range of 0 to 1 for the four channels red, green, blue and alpha (for opacity)
     */
    let Color = /** @class */ (() => {
        class Color extends FudgeCore.Mutable {
            constructor(_r = 1, _g = 1, _b = 1, _a = 1) {
                super();
                this.setNormRGBA(_r, _g, _b, _a);
            }
            static getHexFromCSSKeyword(_keyword) {
                Color.crc2.fillStyle = _keyword;
                return Color.crc2.fillStyle;
            }
            static CSS(_keyword, _alpha = 1) {
                let hex = Color.getHexFromCSSKeyword(_keyword);
                let color = new Color(parseInt(hex.substr(1, 2), 16) / 255, parseInt(hex.substr(3, 2), 16) / 255, parseInt(hex.substr(5, 2), 16) / 255, _alpha);
                return color;
            }
            static MULTIPLY(_color1, _color2) {
                return new Color(_color1.r * _color2.r, _color1.g * _color2.g, _color1.b * _color2.b, _color1.a * _color2.a);
            }
            setNormRGBA(_r, _g, _b, _a) {
                this.r = Math.min(1, Math.max(0, _r));
                this.g = Math.min(1, Math.max(0, _g));
                this.b = Math.min(1, Math.max(0, _b));
                this.a = Math.min(1, Math.max(0, _a));
            }
            setBytesRGBA(_r, _g, _b, _a) {
                this.setNormRGBA(_r / 255, _g / 255, _b / 255, _a / 255);
            }
            getArray() {
                return new Float32Array([this.r, this.g, this.b, this.a]);
            }
            setArrayNormRGBA(_color) {
                this.setNormRGBA(_color[0], _color[1], _color[2], _color[3]);
            }
            setArrayBytesRGBA(_color) {
                this.setBytesRGBA(_color[0], _color[1], _color[2], _color[3]);
            }
            getArrayBytesRGBA() {
                return new Uint8ClampedArray([this.r * 255, this.g * 255, this.b * 255, this.a * 255]);
            }
            add(_color) {
                this.r += _color.r;
                this.g += _color.g;
                this.b += _color.b;
                this.a += _color.a;
            }
            getCSS() {
                let bytes = this.getArrayBytesRGBA();
                return `RGBA(${bytes[0]}, ${bytes[1]}, ${bytes[2]}, ${bytes[3]})`;
            }
            getHex() {
                let bytes = this.getArrayBytesRGBA();
                let hex = "";
                for (let byte of bytes)
                    hex += byte.toString(16).padStart(2, "0");
                return hex;
            }
            setHex(_hex) {
                let bytes = this.getArrayBytesRGBA();
                let channel = 0;
                for (let byte in bytes)
                    bytes[byte] = parseInt(_hex.substr(channel++ * 2, 2), 16);
                this.setArrayBytesRGBA(bytes);
            }
            reduceMutator(_mutator) { }
        }
        // crc2 only used for converting colors from strings predefined by CSS
        Color.crc2 = document.createElement("canvas").getContext("2d");
        return Color;
    })();
    FudgeCore.Color = Color;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Baseclass for materials. Combines a [[Shader]] with a compatible [[Coat]]
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Material extends FudgeCore.Mutable {
        constructor(_name, _shader, _coat) {
            super();
            this.idResource = undefined;
            this.name = _name;
            this.shaderType = _shader;
            if (_shader) {
                if (_coat)
                    this.setCoat(_coat);
                else
                    this.setCoat(this.createCoatMatchingShader());
            }
            FudgeCore.ResourceManager.register(this);
        }
        /**
         * Creates a new [[Coat]] instance that is valid for the [[Shader]] referenced by this material
         */
        createCoatMatchingShader() {
            let coat = new (this.shaderType.getCoat())();
            return coat;
        }
        /**
         * Makes this material reference the given [[Coat]] if it is compatible with the referenced [[Shader]]
         * @param _coat
         */
        setCoat(_coat) {
            if (_coat.constructor != this.shaderType.getCoat())
                if (_coat instanceof this.shaderType.getCoat())
                    FudgeCore.Debug.fudge("Coat is extension of Coat required by shader");
                else
                    throw (new Error("Shader and coat don't match"));
            this.coat = _coat;
        }
        /**
         * Returns the currently referenced [[Coat]] instance
         */
        getCoat() {
            return this.coat;
        }
        /**
         * Changes the materials reference to the given [[Shader]], creates and references a new [[Coat]] instance
         * and mutates the new coat to preserve matching properties.
         * @param _shaderType
         */
        setShader(_shaderType) {
            this.shaderType = _shaderType;
            let coat = this.createCoatMatchingShader();
            coat.mutate(this.coat.getMutator());
            this.setCoat(coat);
        }
        /**
         * Returns the [[Shader]] referenced by this material
         */
        getShader() {
            return this.shaderType;
        }
        //#region Transfer
        // TODO: this type of serialization was implemented for implicit Material create. Check if obsolete when only one material class exists and/or materials are stored separately
        serialize() {
            let serialization = {
                name: this.name,
                idResource: this.idResource,
                shader: this.shaderType.name,
                coat: FudgeCore.Serializer.serialize(this.coat)
            };
            return serialization;
        }
        deserialize(_serialization) {
            this.name = _serialization.name;
            this.idResource = _serialization.idResource;
            // TODO: provide for shaders in the users namespace. See Serializer fullpath etc.
            // tslint:disable-next-line: no-any
            this.shaderType = FudgeCore[_serialization.shader];
            let coat = FudgeCore.Serializer.deserialize(_serialization.coat);
            this.setCoat(coat);
            return this;
        }
        reduceMutator(_mutator) {
            //
        }
    }
    FudgeCore.Material = Material;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Static class handling the resources used with the current FUDGE-instance.
     * Keeps a list of the resources and generates ids to retrieve them.
     * Resources are objects referenced multiple times but supposed to be stored only once
     */
    let ResourceManager = /** @class */ (() => {
        class ResourceManager {
            /**
             * Generates an id for the resources and registers it with the list of resources
             * @param _resource
             */
            static register(_resource) {
                if (!_resource.idResource)
                    _resource.idResource = ResourceManager.generateId(_resource);
                ResourceManager.resources[_resource.idResource] = _resource;
            }
            /**
             * Generate a user readable and unique id using the type of the resource, the date and random numbers
             * @param _resource
             */
            static generateId(_resource) {
                // TODO: build id and integrate info from resource, not just date
                let idResource;
                do
                    idResource = _resource.constructor.name + "|" + new Date().toISOString() + "|" + Math.random().toPrecision(5).substr(2, 5);
                while (ResourceManager.resources[idResource]);
                return idResource;
            }
            /**
             * Tests, if an object is a [[SerializableResource]]
             * @param _object The object to examine
             */
            static isResource(_object) {
                return (Reflect.has(_object, "idResource"));
            }
            /**
             * Retrieves the resource stored with the given id
             * @param _idResource
             */
            static get(_idResource) {
                let resource = ResourceManager.resources[_idResource];
                if (!resource) {
                    let serialization = ResourceManager.serialization[_idResource];
                    if (!serialization) {
                        FudgeCore.Debug.error("Resource not found", _idResource);
                        return null;
                    }
                    resource = ResourceManager.deserializeResource(serialization);
                }
                return resource;
            }
            /**
             * Creates and registers a resource from a [[Node]], copying the complete graph starting with it
             * @param _node A node to create the resource from
             * @param _replaceWithInstance if true (default), the node used as origin is replaced by a [[NodeResourceInstance]] of the [[NodeResource]] created
             */
            static registerNodeAsResource(_node, _replaceWithInstance = true) {
                let serialization = _node.serialize();
                let nodeResource = new FudgeCore.NodeResource("NodeResource");
                nodeResource.deserialize(serialization);
                ResourceManager.register(nodeResource);
                if (_replaceWithInstance && _node.getParent()) {
                    let instance = new FudgeCore.NodeResourceInstance(nodeResource);
                    _node.getParent().replaceChild(_node, instance);
                }
                return nodeResource;
            }
            /**
             * Serialize all resources
             */
            static serialize() {
                let serialization = {};
                for (let idResource in ResourceManager.resources) {
                    let resource = ResourceManager.resources[idResource];
                    if (idResource != resource.idResource)
                        FudgeCore.Debug.error("Resource-id mismatch", resource);
                    serialization[idResource] = FudgeCore.Serializer.serialize(resource);
                }
                return serialization;
            }
            /**
             * Create resources from a serialization, deleting all resources previously registered
             * @param _serialization
             */
            static deserialize(_serialization) {
                ResourceManager.serialization = _serialization;
                ResourceManager.resources = {};
                for (let idResource in _serialization) {
                    let serialization = _serialization[idResource];
                    let resource = ResourceManager.deserializeResource(serialization);
                    if (resource)
                        ResourceManager.resources[idResource] = resource;
                }
                return ResourceManager.resources;
            }
            static deserializeResource(_serialization) {
                return FudgeCore.Serializer.deserialize(_serialization);
            }
        }
        ResourceManager.resources = {};
        ResourceManager.serialization = null;
        return ResourceManager;
    })();
    FudgeCore.ResourceManager = ResourceManager;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Controls the rendering of a graph, using the given [[ComponentCamera]],
     * and the propagation of the rendered image from the offscreen renderbuffer to the target canvas
     * through a series of [[Framing]] objects. The stages involved are in order of rendering
     * [[RenderManager]].viewport -> [[Viewport]].source -> [[Viewport]].destination -> DOM-Canvas -> Client(CSS)
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Viewport extends FudgeCore.EventTarget∆í {
        constructor() {
            super(...arguments);
            this.name = "Viewport"; // The name to call this viewport by.
            this.camera = null; // The camera representing the view parameters to render the graph.
            // TODO: verify if client to canvas should be in Viewport or somewhere else (Window, Container?)
            // Multiple viewports using the same canvas shouldn't differ here...
            // different framing methods can be used, this is the default
            this.frameClientToCanvas = new FudgeCore.FramingScaled();
            this.frameCanvasToDestination = new FudgeCore.FramingComplex();
            this.frameDestinationToSource = new FudgeCore.FramingScaled();
            this.frameSourceToRender = new FudgeCore.FramingScaled();
            this.adjustingFrames = true;
            this.adjustingCamera = true;
            this.graph = null; // The first node in the graph that will be rendered.
            this.crc2 = null;
            this.canvas = null;
            this.pickBuffers = [];
            /**
             * Handle drag-drop events and dispatch to viewport as FUDGE-Event
             */
            this.hndDragDropEvent = (_event) => {
                let _dragevent = _event;
                switch (_dragevent.type) {
                    case "dragover":
                    case "drop":
                        _dragevent.preventDefault();
                        _dragevent.dataTransfer.effectAllowed = "none";
                        break;
                    case "dragstart":
                        // just dummy data,  valid data should be set in handler registered by the user
                        _dragevent.dataTransfer.setData("text", "Hallo");
                        // TODO: check if there is a better solution to hide the ghost image of the draggable object
                        _dragevent.dataTransfer.setDragImage(new Image(), 0, 0);
                        break;
                }
                let event = new FudgeCore.EventDragDrop("∆í" + _event.type, _dragevent);
                this.addCanvasPosition(event);
                this.dispatchEvent(event);
            };
            /**
             * Handle pointer events and dispatch to viewport as FUDGE-Event
             */
            this.hndPointerEvent = (_event) => {
                let event = new FudgeCore.EventPointer("∆í" + _event.type, _event);
                this.addCanvasPosition(event);
                this.dispatchEvent(event);
            };
            /**
             * Handle keyboard events and dispatch to viewport as FUDGE-Event, if the viewport has the focus
             */
            this.hndKeyboardEvent = (_event) => {
                if (!this.hasFocus)
                    return;
                let event = new FudgeCore.EventKeyboard("∆í" + _event.type, _event);
                this.dispatchEvent(event);
            };
            /**
             * Handle wheel event and dispatch to viewport as FUDGE-Event
             */
            this.hndWheelEvent = (_event) => {
                let event = new FudgeCore.EventWheel("∆í" + _event.type, _event);
                this.dispatchEvent(event);
            };
        }
        /**
         * Connects the viewport to the given canvas to render the given graph to using the given camera-component, and names the viewport as given.
         */
        initialize(_name, _graph, _camera, _canvas) {
            this.name = _name;
            this.camera = _camera;
            this.canvas = _canvas;
            this.crc2 = _canvas.getContext("2d");
            this.rectSource = FudgeCore.RenderManager.getCanvasRect();
            this.rectDestination = this.getClientRectangle();
            this.setGraph(_graph);
        }
        /**
         * Retrieve the 2D-context attached to the destination canvas
         */
        getContext() {
            return this.crc2;
        }
        /**
         * Retrieve the size of the destination canvas as a rectangle, x and y are always 0
         */
        getCanvasRectangle() {
            return FudgeCore.Rectangle.GET(0, 0, this.canvas.width, this.canvas.height);
        }
        /**
         * Retrieve the client rectangle the canvas is displayed and fit in, x and y are always 0
         */
        getClientRectangle() {
            // FUDGE doesn't care about where the client rect is, only about the size matters.
            // return Rectangle.GET(this.canvas.offsetLeft, this.canvas.offsetTop, this.canvas.clientWidth, this.canvas.clientHeight);
            return FudgeCore.Rectangle.GET(0, 0, this.canvas.clientWidth, this.canvas.clientHeight);
        }
        /**
         * Set the graph to be drawn in the viewport.
         */
        setGraph(_graph) {
            if (this.graph) {
                this.graph.removeEventListener("componentAdd" /* COMPONENT_ADD */, this.hndComponentEvent);
                this.graph.removeEventListener("componentRemove" /* COMPONENT_REMOVE */, this.hndComponentEvent);
            }
            this.graph = _graph;
            if (this.graph) {
                this.graph.addEventListener("componentAdd" /* COMPONENT_ADD */, this.hndComponentEvent);
                this.graph.addEventListener("componentRemove" /* COMPONENT_REMOVE */, this.hndComponentEvent);
            }
        }
        getGraph() {
            return this.graph;
        }
        /**
         * Logs this viewports scenegraph to the console.
         */
        showSceneGraph() {
            // TODO: move to debug-class
            let output = "SceneGraph for this viewport:";
            output += "\n \n";
            output += this.graph.name;
            FudgeCore.Debug.log(output + "   => ROOTNODE" + this.createSceneGraph(this.graph));
        }
        // #region Drawing
        /**
         * Draw this viewport
         */
        draw() {
            FudgeCore.RenderManager.resetFrameBuffer();
            if (!this.camera.isActive)
                return;
            if (this.adjustingFrames)
                this.adjustFrames();
            if (this.adjustingCamera)
                this.adjustCamera();
            FudgeCore.RenderManager.clear(this.camera.backgroundColor);
            FudgeCore.RenderManager.drawGraph(this.graph, this.camera);
            this.crc2.imageSmoothingEnabled = false;
            this.crc2.drawImage(FudgeCore.RenderManager.getCanvas(), this.rectSource.x, this.rectSource.y, this.rectSource.width, this.rectSource.height, this.rectDestination.x, this.rectDestination.y, this.rectDestination.width, this.rectDestination.height);
        }
        /**
        * Draw this viewport for RayCast
        */
        createPickBuffers() {
            if (this.adjustingFrames)
                this.adjustFrames();
            if (this.adjustingCamera)
                this.adjustCamera();
            this.pickBuffers = FudgeCore.RenderManager.drawGraphForRayCast(this.graph, this.camera);
        }
        pickNodeAt(_pos) {
            // this.createPickBuffers();
            let hits = FudgeCore.RenderManager.pickNodeAt(_pos, this.pickBuffers, this.rectSource);
            hits.sort((a, b) => (b.zBuffer > 0) ? (a.zBuffer > 0) ? a.zBuffer - b.zBuffer : 1 : -1);
            return hits;
        }
        /**
         * Adjust all frames involved in the rendering process from the display area in the client up to the renderer canvas
         */
        adjustFrames() {
            // get the rectangle of the canvas area as displayed (consider css)
            let rectClient = this.getClientRectangle();
            // adjust the canvas size according to the given framing applied to client
            let rectCanvas = this.frameClientToCanvas.getRect(rectClient);
            this.canvas.width = rectCanvas.width;
            this.canvas.height = rectCanvas.height;
            // adjust the destination area on the target-canvas to render to by applying the framing to canvas
            this.rectDestination = this.frameCanvasToDestination.getRect(rectCanvas);
            // adjust the area on the source-canvas to render from by applying the framing to destination area
            this.rectSource = this.frameDestinationToSource.getRect(this.rectDestination);
            // having an offset source does make sense only when multiple viewports display parts of the same rendering. For now: shift it to 0,0
            this.rectSource.x = this.rectSource.y = 0;
            // still, a partial image of the rendering may be retrieved by moving and resizing the render viewport
            let rectRender = this.frameSourceToRender.getRect(this.rectSource);
            FudgeCore.RenderManager.setViewportRectangle(rectRender);
            // no more transformation after this for now, offscreen canvas and render-viewport have the same size
            FudgeCore.RenderManager.setCanvasSize(rectRender.width, rectRender.height);
        }
        /**
         * Adjust the camera parameters to fit the rendering into the render vieport
         */
        adjustCamera() {
            let rect = FudgeCore.RenderManager.getViewportRectangle();
            this.camera.projectCentral(rect.width / rect.height, this.camera.getFieldOfView());
        }
        // #endregion
        //#region Points
        /**
         * Returns a [[Ray]] in world coordinates from this camera through the point given in client space
         */
        getRayFromClient(_point) {
            let posProjection = this.pointClientToProjection(_point);
            let ray = new FudgeCore.Ray(new FudgeCore.Vector3(-posProjection.x, posProjection.y, 1));
            // ray.direction.scale(camera.distance);
            ray.origin.transform(this.camera.pivot);
            ray.direction.transform(this.camera.pivot, false);
            let cameraNode = this.camera.getContainer();
            if (cameraNode) {
                ray.origin.transform(cameraNode.mtxWorld);
                ray.direction.transform(cameraNode.mtxWorld, false);
            }
            return ray;
        }
        pointWorldToClient(_position) {
            let projection = this.camera.project(_position);
            let posClient = this.pointClipToClient(projection.toVector2());
            return posClient;
        }
        /**
         * Returns a point on the source-rectangle matching the given point on the client rectangle
         */
        pointClientToSource(_client) {
            let result = this.frameClientToCanvas.getPoint(_client, this.getClientRectangle());
            result = this.frameCanvasToDestination.getPoint(result, this.getCanvasRectangle());
            result = this.frameDestinationToSource.getPoint(result, this.rectSource);
            //TODO: when Source, Render and RenderViewport deviate, continue transformation 
            return result;
        }
        /**
         * Returns a point on the render-rectangle matching the given point on the source rectangle
         */
        pointSourceToRender(_source) {
            let projectionRectangle = this.camera.getProjectionRectangle();
            let point = this.frameSourceToRender.getPoint(_source, projectionRectangle);
            return point;
        }
        /**
         * Returns a point on the render-rectangle matching the given point on the client rectangle
         */
        pointClientToRender(_client) {
            let point = this.pointClientToSource(_client);
            point = this.pointSourceToRender(point);
            //TODO: when Render and RenderViewport deviate, continue transformation 
            return point;
        }
        /**
         * Returns a point in normed view-rectangle matching the given point on the client rectangle
         * The view-rectangle matches the client size in the hypothetical distance of 1 to the camera, its origin in the center and y-axis pointing up
         * TODO: examine, if this should be a camera-method. Current implementation is for central-projection
         */
        pointClientToProjection(_client) {
            let posRender = this.pointClientToRender(_client);
            let rectRender = this.frameSourceToRender.getRect(this.rectSource);
            let rectProjection = this.camera.getProjectionRectangle();
            let posProjection = new FudgeCore.Vector2(rectProjection.width * posRender.x / rectRender.width, rectProjection.height * posRender.y / rectRender.height);
            posProjection.subtract(new FudgeCore.Vector2(rectProjection.width / 2, rectProjection.height / 2));
            posProjection.y *= -1;
            return posProjection;
        }
        /**
         * Returns a point in the client rectangle matching the given point in normed clipspace rectangle,
         * which stretches from -1 to 1 in both dimensions, y pointing up
         */
        pointClipToClient(_normed) {
            // let rectClient: Rectangle = this.getClientRectangle();
            // let result: Vector2 = Vector2.ONE(0.5);
            // result.x *= (_normed.x + 1) * rectClient.width;
            // result.y *= (1 - _normed.y) * rectClient.height;
            // result.add(rectClient.position);
            //TODO: check if rectDestination can be safely (and more perfomant) be used instead getClientRectangle
            let pointClient = FudgeCore.RenderManager.rectClip.pointToRect(_normed, this.rectDestination);
            return pointClient;
        }
        /**
         * Returns a point in the client rectangle matching the given point in normed clipspace rectangle,
         * which stretches from -1 to 1 in both dimensions, y pointing up
         */
        pointClipToCanvas(_normed) {
            let pointCanvas = FudgeCore.RenderManager.rectClip.pointToRect(_normed, this.getCanvasRectangle());
            return pointCanvas;
        }
        pointClientToScreen(_client) {
            let screen = new FudgeCore.Vector2(this.canvas.offsetLeft + _client.x, this.canvas.offsetTop + _client.y);
            return screen;
        }
        //#endregion
        // #region Events (passing from canvas to viewport and from there into graph)
        /**
         * Returns true if this viewport currently has focus and thus receives keyboard events
         */
        get hasFocus() {
            return (Viewport.focus == this);
        }
        /**
         * Switch the viewports focus on or off. Only one viewport in one FUDGE instance can have the focus, thus receiving keyboard events.
         * So a viewport currently having the focus will lose it, when another one receives it. The viewports fire [[Event]]s accordingly.
         *
         * @param _on
         */
        setFocus(_on) {
            if (_on) {
                if (Viewport.focus == this)
                    return;
                if (Viewport.focus)
                    Viewport.focus.dispatchEvent(new Event("focusout" /* FOCUS_OUT */));
                Viewport.focus = this;
                this.dispatchEvent(new Event("focusin" /* FOCUS_IN */));
            }
            else {
                if (Viewport.focus != this)
                    return;
                this.dispatchEvent(new Event("focusout" /* FOCUS_OUT */));
                Viewport.focus = null;
            }
        }
        /**
         * De- / Activates the given pointer event to be propagated into the viewport as FUDGE-Event
         * @param _type
         * @param _on
         */
        activatePointerEvent(_type, _on) {
            this.activateEvent(this.canvas, _type, this.hndPointerEvent, _on);
        }
        /**
         * De- / Activates the given keyboard event to be propagated into the viewport as FUDGE-Event
         * @param _type
         * @param _on
         */
        activateKeyboardEvent(_type, _on) {
            this.activateEvent(this.canvas.ownerDocument, _type, this.hndKeyboardEvent, _on);
        }
        /**
         * De- / Activates the given drag-drop event to be propagated into the viewport as FUDGE-Event
         * @param _type
         * @param _on
         */
        activateDragDropEvent(_type, _on) {
            if (_type == "\u0192dragstart" /* START */)
                this.canvas.draggable = _on;
            this.activateEvent(this.canvas, _type, this.hndDragDropEvent, _on);
        }
        /**
         * De- / Activates the wheel event to be propagated into the viewport as FUDGE-Event
         * @param _type
         * @param _on
         */
        activateWheelEvent(_type, _on) {
            this.activateEvent(this.canvas, _type, this.hndWheelEvent, _on);
        }
        /**
         * Add position of the pointer mapped to canvas-coordinates as canvasX, canvasY to the event
         * @param event
         */
        addCanvasPosition(event) {
            event.canvasX = this.canvas.width * event.pointerX / event.clientRect.width;
            event.canvasY = this.canvas.height * event.pointerY / event.clientRect.height;
        }
        activateEvent(_target, _type, _handler, _on) {
            _type = _type.slice(1); // chip the ∆ílorentin
            if (_on)
                _target.addEventListener(_type, _handler);
            else
                _target.removeEventListener(_type, _handler);
        }
        hndComponentEvent(_event) {
            FudgeCore.Debug.fudge(_event);
        }
        // #endregion
        /**
         * Creates an outputstring as visual representation of this viewports scenegraph. Called for the passed node and recursive for all its children.
         * @param _fudgeNode The node to create a scenegraphentry for.
         */
        createSceneGraph(_fudgeNode) {
            // TODO: move to debug-class
            let output = "";
            for (let name in _fudgeNode.getChildren()) {
                let child = _fudgeNode.getChildren()[name];
                output += "\n";
                let current = child;
                if (current.getParent() && current.getParent().getParent())
                    output += "|";
                while (current.getParent() && current.getParent().getParent()) {
                    output += "   ";
                    current = current.getParent();
                }
                output += "'--";
                output += child.name;
                output += this.createSceneGraph(child);
            }
            return output;
        }
    }
    FudgeCore.Viewport = Viewport;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class EventDragDrop extends DragEvent {
        constructor(type, _event) {
            super(type, _event);
            let target = _event.target;
            this.clientRect = target.getClientRects()[0];
            this.pointerX = _event.clientX - this.clientRect.left;
            this.pointerY = _event.clientY - this.clientRect.top;
        }
    }
    FudgeCore.EventDragDrop = EventDragDrop;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class EventKeyboard extends KeyboardEvent {
        constructor(type, _event) {
            super(type, _event);
        }
    }
    FudgeCore.EventKeyboard = EventKeyboard;
    /**
     * The codes sent from a standard english keyboard layout
     */
    let KEYBOARD_CODE;
    (function (KEYBOARD_CODE) {
        KEYBOARD_CODE["A"] = "KeyA";
        KEYBOARD_CODE["B"] = "KeyB";
        KEYBOARD_CODE["C"] = "KeyC";
        KEYBOARD_CODE["D"] = "KeyD";
        KEYBOARD_CODE["E"] = "KeyE";
        KEYBOARD_CODE["F"] = "KeyF";
        KEYBOARD_CODE["G"] = "KeyG";
        KEYBOARD_CODE["H"] = "KeyH";
        KEYBOARD_CODE["I"] = "KeyI";
        KEYBOARD_CODE["J"] = "KeyJ";
        KEYBOARD_CODE["K"] = "KeyK";
        KEYBOARD_CODE["L"] = "KeyL";
        KEYBOARD_CODE["M"] = "KeyM";
        KEYBOARD_CODE["N"] = "KeyN";
        KEYBOARD_CODE["O"] = "KeyO";
        KEYBOARD_CODE["P"] = "KeyP";
        KEYBOARD_CODE["Q"] = "KeyQ";
        KEYBOARD_CODE["R"] = "KeyR";
        KEYBOARD_CODE["S"] = "KeyS";
        KEYBOARD_CODE["T"] = "KeyT";
        KEYBOARD_CODE["U"] = "KeyU";
        KEYBOARD_CODE["V"] = "KeyV";
        KEYBOARD_CODE["W"] = "KeyW";
        KEYBOARD_CODE["X"] = "KeyX";
        KEYBOARD_CODE["Y"] = "KeyY";
        KEYBOARD_CODE["Z"] = "KeyZ";
        KEYBOARD_CODE["ESC"] = "Escape";
        KEYBOARD_CODE["ZERO"] = "Digit0";
        KEYBOARD_CODE["ONE"] = "Digit1";
        KEYBOARD_CODE["TWO"] = "Digit2";
        KEYBOARD_CODE["THREE"] = "Digit3";
        KEYBOARD_CODE["FOUR"] = "Digit4";
        KEYBOARD_CODE["FIVE"] = "Digit5";
        KEYBOARD_CODE["SIX"] = "Digit6";
        KEYBOARD_CODE["SEVEN"] = "Digit7";
        KEYBOARD_CODE["EIGHT"] = "Digit8";
        KEYBOARD_CODE["NINE"] = "Digit9";
        KEYBOARD_CODE["MINUS"] = "Minus";
        KEYBOARD_CODE["EQUAL"] = "Equal";
        KEYBOARD_CODE["BACKSPACE"] = "Backspace";
        KEYBOARD_CODE["TABULATOR"] = "Tab";
        KEYBOARD_CODE["BRACKET_LEFT"] = "BracketLeft";
        KEYBOARD_CODE["BRACKET_RIGHT"] = "BracketRight";
        KEYBOARD_CODE["ENTER"] = "Enter";
        KEYBOARD_CODE["CTRL_LEFT"] = "ControlLeft";
        KEYBOARD_CODE["SEMICOLON"] = "Semicolon";
        KEYBOARD_CODE["QUOTE"] = "Quote";
        KEYBOARD_CODE["BACK_QUOTE"] = "Backquote";
        KEYBOARD_CODE["SHIFT_LEFT"] = "ShiftLeft";
        KEYBOARD_CODE["BACKSLASH"] = "Backslash";
        KEYBOARD_CODE["COMMA"] = "Comma";
        KEYBOARD_CODE["PERIOD"] = "Period";
        KEYBOARD_CODE["SLASH"] = "Slash";
        KEYBOARD_CODE["SHIFT_RIGHT"] = "ShiftRight";
        KEYBOARD_CODE["NUMPAD_MULTIPLY"] = "NumpadMultiply";
        KEYBOARD_CODE["ALT_LEFT"] = "AltLeft";
        KEYBOARD_CODE["SPACE"] = "Space";
        KEYBOARD_CODE["CAPS_LOCK"] = "CapsLock";
        KEYBOARD_CODE["F1"] = "F1";
        KEYBOARD_CODE["F2"] = "F2";
        KEYBOARD_CODE["F3"] = "F3";
        KEYBOARD_CODE["F4"] = "F4";
        KEYBOARD_CODE["F5"] = "F5";
        KEYBOARD_CODE["F6"] = "F6";
        KEYBOARD_CODE["F7"] = "F7";
        KEYBOARD_CODE["F8"] = "F8";
        KEYBOARD_CODE["F9"] = "F9";
        KEYBOARD_CODE["F10"] = "F10";
        KEYBOARD_CODE["PAUSE"] = "Pause";
        KEYBOARD_CODE["SCROLL_LOCK"] = "ScrollLock";
        KEYBOARD_CODE["NUMPAD7"] = "Numpad7";
        KEYBOARD_CODE["NUMPAD8"] = "Numpad8";
        KEYBOARD_CODE["NUMPAD9"] = "Numpad9";
        KEYBOARD_CODE["NUMPAD_SUBTRACT"] = "NumpadSubtract";
        KEYBOARD_CODE["NUMPAD4"] = "Numpad4";
        KEYBOARD_CODE["NUMPAD5"] = "Numpad5";
        KEYBOARD_CODE["NUMPAD6"] = "Numpad6";
        KEYBOARD_CODE["NUMPAD_ADD"] = "NumpadAdd";
        KEYBOARD_CODE["NUMPAD1"] = "Numpad1";
        KEYBOARD_CODE["NUMPAD2"] = "Numpad2";
        KEYBOARD_CODE["NUMPAD3"] = "Numpad3";
        KEYBOARD_CODE["NUMPAD0"] = "Numpad0";
        KEYBOARD_CODE["NUMPAD_DECIMAL"] = "NumpadDecimal";
        KEYBOARD_CODE["PRINT_SCREEN"] = "PrintScreen";
        KEYBOARD_CODE["INTL_BACK_SLASH"] = "IntlBackSlash";
        KEYBOARD_CODE["F11"] = "F11";
        KEYBOARD_CODE["F12"] = "F12";
        KEYBOARD_CODE["NUMPAD_EQUAL"] = "NumpadEqual";
        KEYBOARD_CODE["F13"] = "F13";
        KEYBOARD_CODE["F14"] = "F14";
        KEYBOARD_CODE["F15"] = "F15";
        KEYBOARD_CODE["F16"] = "F16";
        KEYBOARD_CODE["F17"] = "F17";
        KEYBOARD_CODE["F18"] = "F18";
        KEYBOARD_CODE["F19"] = "F19";
        KEYBOARD_CODE["F20"] = "F20";
        KEYBOARD_CODE["F21"] = "F21";
        KEYBOARD_CODE["F22"] = "F22";
        KEYBOARD_CODE["F23"] = "F23";
        KEYBOARD_CODE["F24"] = "F24";
        KEYBOARD_CODE["KANA_MODE"] = "KanaMode";
        KEYBOARD_CODE["LANG2"] = "Lang2";
        KEYBOARD_CODE["LANG1"] = "Lang1";
        KEYBOARD_CODE["INTL_RO"] = "IntlRo";
        KEYBOARD_CODE["CONVERT"] = "Convert";
        KEYBOARD_CODE["NON_CONVERT"] = "NonConvert";
        KEYBOARD_CODE["INTL_YEN"] = "IntlYen";
        KEYBOARD_CODE["NUMPAD_COMMA"] = "NumpadComma";
        KEYBOARD_CODE["UNDO"] = "Undo";
        KEYBOARD_CODE["PASTE"] = "Paste";
        KEYBOARD_CODE["MEDIA_TRACK_PREVIOUS"] = "MediaTrackPrevious";
        KEYBOARD_CODE["CUT"] = "Cut";
        KEYBOARD_CODE["COPY"] = "Copy";
        KEYBOARD_CODE["MEDIA_TRACK_NEXT"] = "MediaTrackNext";
        KEYBOARD_CODE["NUMPAD_ENTER"] = "NumpadEnter";
        KEYBOARD_CODE["CTRL_RIGHT"] = "ControlRight";
        KEYBOARD_CODE["AUDIO_VOLUME_MUTE"] = "AudioVolumeMute";
        KEYBOARD_CODE["LAUNCH_APP2"] = "LaunchApp2";
        KEYBOARD_CODE["MEDIA_PLAY_PAUSE"] = "MediaPlayPause";
        KEYBOARD_CODE["MEDIA_STOP"] = "MediaStop";
        KEYBOARD_CODE["EJECT"] = "Eject";
        KEYBOARD_CODE["AUDIO_VOLUME_DOWN"] = "AudioVolumeDown";
        KEYBOARD_CODE["VOLUME_DOWN"] = "VolumeDown";
        KEYBOARD_CODE["AUDIO_VOLUME_UP"] = "AudioVolumeUp";
        KEYBOARD_CODE["VOLUME_UP"] = "VolumeUp";
        KEYBOARD_CODE["BROWSER_HOME"] = "BrowserHome";
        KEYBOARD_CODE["NUMPAD_DIVIDE"] = "NumpadDivide";
        KEYBOARD_CODE["ALT_RIGHT"] = "AltRight";
        KEYBOARD_CODE["HELP"] = "Help";
        KEYBOARD_CODE["NUM_LOCK"] = "NumLock";
        KEYBOARD_CODE["HOME"] = "Home";
        KEYBOARD_CODE["ARROW_UP"] = "ArrowUp";
        KEYBOARD_CODE["ARROW_RIGHT"] = "ArrowRight";
        KEYBOARD_CODE["ARROW_DOWN"] = "ArrowDown";
        KEYBOARD_CODE["ARROW_LEFT"] = "ArrowLeft";
        KEYBOARD_CODE["END"] = "End";
        KEYBOARD_CODE["PAGE_UP"] = "PageUp";
        KEYBOARD_CODE["PAGE_DOWN"] = "PageDown";
        KEYBOARD_CODE["INSERT"] = "Insert";
        KEYBOARD_CODE["DELETE"] = "Delete";
        KEYBOARD_CODE["META_LEFT"] = "Meta_Left";
        KEYBOARD_CODE["OS_LEFT"] = "OSLeft";
        KEYBOARD_CODE["META_RIGHT"] = "MetaRight";
        KEYBOARD_CODE["OS_RIGHT"] = "OSRight";
        KEYBOARD_CODE["CONTEXT_MENU"] = "ContextMenu";
        KEYBOARD_CODE["POWER"] = "Power";
        KEYBOARD_CODE["BROWSER_SEARCH"] = "BrowserSearch";
        KEYBOARD_CODE["BROWSER_FAVORITES"] = "BrowserFavorites";
        KEYBOARD_CODE["BROWSER_REFRESH"] = "BrowserRefresh";
        KEYBOARD_CODE["BROWSER_STOP"] = "BrowserStop";
        KEYBOARD_CODE["BROWSER_FORWARD"] = "BrowserForward";
        KEYBOARD_CODE["BROWSER_BACK"] = "BrowserBack";
        KEYBOARD_CODE["LAUNCH_APP1"] = "LaunchApp1";
        KEYBOARD_CODE["LAUNCH_MAIL"] = "LaunchMail";
        KEYBOARD_CODE["LAUNCH_MEDIA_PLAYER"] = "LaunchMediaPlayer";
        //mac brings this buttton
        KEYBOARD_CODE["FN"] = "Fn";
        //Linux brings these
        KEYBOARD_CODE["AGAIN"] = "Again";
        KEYBOARD_CODE["PROPS"] = "Props";
        KEYBOARD_CODE["SELECT"] = "Select";
        KEYBOARD_CODE["OPEN"] = "Open";
        KEYBOARD_CODE["FIND"] = "Find";
        KEYBOARD_CODE["WAKE_UP"] = "WakeUp";
        KEYBOARD_CODE["NUMPAD_PARENT_LEFT"] = "NumpadParentLeft";
        KEYBOARD_CODE["NUMPAD_PARENT_RIGHT"] = "NumpadParentRight";
        //android
        KEYBOARD_CODE["SLEEP"] = "Sleep";
    })(KEYBOARD_CODE = FudgeCore.KEYBOARD_CODE || (FudgeCore.KEYBOARD_CODE = {}));
    /*
    Firefox can't make use of those buttons and Combinations:
    SINGELE_BUTTONS:
     Druck,
    COMBINATIONS:
     Shift + F10, Shift + Numpad5,
     CTRL + q, CTRL + F4,
     ALT + F1, ALT + F2, ALT + F3, ALT + F7, ALT + F8, ALT + F10
    Opera won't do good with these Buttons and combinations:
    SINGLE_BUTTONS:
     Float32Array, F11, ALT,
    COMBINATIONS:
     CTRL + q, CTRL + t, CTRL + h, CTRL + g, CTRL + n, CTRL + f
     ALT + F1, ALT + F2, ALT + F4, ALT + F5, ALT + F6, ALT + F7, ALT + F8, ALT + F10
     */
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class EventPointer extends PointerEvent {
        constructor(type, _event) {
            super(type, _event);
            let target = _event.target;
            this.clientRect = target.getClientRects()[0];
            this.pointerX = _event.clientX - this.clientRect.left;
            this.pointerY = _event.clientY - this.clientRect.top;
        }
    }
    FudgeCore.EventPointer = EventPointer;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class EventTimer {
        constructor(_timer, ..._arguments) {
            this.type = "\u0192lapse" /* CALL */;
            this.firstCall = true;
            this.lastCall = false;
            this.target = _timer;
            this.arguments = _arguments;
            this.firstCall = true;
        }
    }
    FudgeCore.EventTimer = EventTimer;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class EventWheel extends WheelEvent {
        constructor(type, _event) {
            super(type, _event);
        }
    }
    FudgeCore.EventWheel = EventWheel;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Baseclass for different kinds of lights.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Light extends FudgeCore.Mutable {
        constructor(_color = new FudgeCore.Color(1, 1, 1, 1)) {
            super();
            this.color = _color;
        }
        getType() {
            return this.constructor;
        }
        reduceMutator() { }
    }
    FudgeCore.Light = Light;
    /**
     * Ambient light, coming from all directions, illuminating everything with its color independent of position and orientation (like a foggy day or in the shades)
     * ```plaintext
     * ~ ~ ~
     *  ~ ~ ~
     * ```
     */
    class LightAmbient extends Light {
        constructor(_color = new FudgeCore.Color(1, 1, 1, 1)) {
            super(_color);
        }
    }
    FudgeCore.LightAmbient = LightAmbient;
    /**
     * Directional light, illuminating everything from a specified direction with its color (like standing in bright sunlight)
     * ```plaintext
     * --->
     * --->
     * --->
     * ```
     */
    class LightDirectional extends Light {
        constructor(_color = new FudgeCore.Color(1, 1, 1, 1)) {
            super(_color);
        }
    }
    FudgeCore.LightDirectional = LightDirectional;
    /**
     * Omnidirectional light emitting from its position, illuminating objects depending on their position and distance with its color (like a colored light bulb)
     * ```plaintext
     *         .\|/.
     *        -- o --
     *         ¬¥/|\`
     * ```
     */
    class LightPoint extends Light {
        constructor() {
            super(...arguments);
            this.range = 10;
        }
    }
    FudgeCore.LightPoint = LightPoint;
    /**
     * Spot light emitting within a specified angle from its position, illuminating objects depending on their position and distance with its color
     * ```plaintext
     *          o
     *         /|\
     *        / | \
     * ```
     */
    class LightSpot extends Light {
    }
    FudgeCore.LightSpot = LightSpot;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Framing describes how to map a rectangle into a given frame
     * and how points in the frame correspond to points in the resulting rectangle and vice versa
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Framing
     */
    class Framing extends FudgeCore.Mutable {
        reduceMutator(_mutator) { }
    }
    FudgeCore.Framing = Framing;
    /**
     * The resulting rectangle has a fixed width and height and display should scale to fit the frame
     * Points are scaled in the same ratio
     */
    class FramingFixed extends Framing {
        constructor(_width = 300, _height = 150) {
            super();
            this.width = 300;
            this.height = 150;
            this.setSize(_width, _height);
        }
        setSize(_width, _height) {
            this.width = _width;
            this.height = _height;
        }
        getPoint(_pointInFrame, _rectFrame) {
            let result = new FudgeCore.Vector2(this.width * (_pointInFrame.x - _rectFrame.x) / _rectFrame.width, this.height * (_pointInFrame.y - _rectFrame.y) / _rectFrame.height);
            return result;
        }
        getPointInverse(_point, _rect) {
            let result = new FudgeCore.Vector2(_point.x * _rect.width / this.width + _rect.x, _point.y * _rect.height / this.height + _rect.y);
            return result;
        }
        getRect(_rectFrame) {
            return FudgeCore.Rectangle.GET(0, 0, this.width, this.height);
        }
    }
    FudgeCore.FramingFixed = FramingFixed;
    /**
     * Width and height of the resulting rectangle are fractions of those of the frame, scaled by normed values normWidth and normHeight.
     * Display should scale to fit the frame and points are scaled in the same ratio
     */
    class FramingScaled extends Framing {
        constructor() {
            super(...arguments);
            this.normWidth = 1.0;
            this.normHeight = 1.0;
        }
        setScale(_normWidth, _normHeight) {
            this.normWidth = _normWidth;
            this.normHeight = _normHeight;
        }
        getPoint(_pointInFrame, _rectFrame) {
            let result = new FudgeCore.Vector2(this.normWidth * (_pointInFrame.x - _rectFrame.x), this.normHeight * (_pointInFrame.y - _rectFrame.y));
            return result;
        }
        getPointInverse(_point, _rect) {
            let result = new FudgeCore.Vector2(_point.x / this.normWidth + _rect.x, _point.y / this.normHeight + _rect.y);
            return result;
        }
        getRect(_rectFrame) {
            return FudgeCore.Rectangle.GET(0, 0, this.normWidth * _rectFrame.width, this.normHeight * _rectFrame.height);
        }
    }
    FudgeCore.FramingScaled = FramingScaled;
    /**
     * The resulting rectangle fits into a margin given as fractions of the size of the frame given by normAnchor
     * plus an absolute padding given by pixelBorder. Display should fit into this.
     */
    class FramingComplex extends Framing {
        constructor() {
            super(...arguments);
            this.margin = { left: 0, top: 0, right: 0, bottom: 0 };
            this.padding = { left: 0, top: 0, right: 0, bottom: 0 };
        }
        getPoint(_pointInFrame, _rectFrame) {
            let result = new FudgeCore.Vector2(_pointInFrame.x - this.padding.left - this.margin.left * _rectFrame.width, _pointInFrame.y - this.padding.top - this.margin.top * _rectFrame.height);
            return result;
        }
        getPointInverse(_point, _rect) {
            let result = new FudgeCore.Vector2(_point.x + this.padding.left + this.margin.left * _rect.width, _point.y + this.padding.top + this.margin.top * _rect.height);
            return result;
        }
        getRect(_rectFrame) {
            if (!_rectFrame)
                return null;
            let minX = _rectFrame.x + this.margin.left * _rectFrame.width + this.padding.left;
            let minY = _rectFrame.y + this.margin.top * _rectFrame.height + this.padding.top;
            let maxX = _rectFrame.x + (1 - this.margin.right) * _rectFrame.width - this.padding.right;
            let maxY = _rectFrame.y + (1 - this.margin.bottom) * _rectFrame.height - this.padding.bottom;
            return FudgeCore.Rectangle.GET(minX, minY, maxX - minX, maxY - minY);
        }
        getMutator() {
            return { margin: this.margin, padding: this.padding };
        }
    }
    FudgeCore.FramingComplex = FramingComplex;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Simple class for 3x3 matrix operations
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2020
     */
    class Matrix3x3 extends FudgeCore.Mutable {
        constructor() {
            super();
            this.data = new Float32Array(3); // The data of the matrix.
            this.mutator = null; // prepared for optimization, keep mutator to reduce redundant calculation and for comparison. Set to null when data changes!
            this.data = new Float32Array([
                1, 0, 0,
                0, 1, 0,
                0, 0, 1
            ]);
            this.resetCache();
        }
        /**
         * - get: a copy of the calculated translation vector
         * - set: effect the matrix ignoring its rotation and scaling
         */
        get translation() {
            if (!this.vectors.translation)
                this.vectors.translation = new FudgeCore.Vector2(this.data[6], this.data[7]);
            return this.vectors.translation.copy;
        }
        set translation(_translation) {
            this.data.set(_translation.get(), 12);
            // no full cache reset required
            this.vectors.translation = _translation;
            this.mutator = null;
        }
        /**
         * - get: a copy of the calculated rotation vector
         * - set: effect the matrix
         */
        get rotation() {
            if (!this.vectors.rotation)
                this.vectors.rotation = this.getEulerAngles();
            return this.vectors.rotation;
        }
        set rotation(_rotation) {
            this.mutate({ "rotation": _rotation });
            this.resetCache();
        }
        /**
         * - get: a copy of the calculated scale vector
         * - set: effect the matrix
         */
        get scaling() {
            if (!this.vectors.scaling)
                this.vectors.scaling = new FudgeCore.Vector2(Math.hypot(this.data[0], this.data[1]), Math.hypot(this.data[3], this.data[4]));
            return this.vectors.scaling.copy;
        }
        set scaling(_scaling) {
            this.mutate({ "scaling": _scaling });
            this.resetCache();
        }
        //TODO: figure out what this is used for
        static PROJECTION(_width, _height) {
            let matrix = new Matrix3x3;
            matrix.data.set([
                2 / _width, 0, 0,
                0, -2 / _height, 0,
                -1, 1, 1
            ]);
            return matrix;
        }
        static IDENTITY() {
            const result = FudgeCore.Recycler.get(Matrix3x3);
            result.data.set([
                1, 0, 0,
                0, 1, 0,
                0, 0, 1
            ]);
            return result;
        }
        /**
         * Returns a matrix that translates coordinates along the x-, y- and z-axis according to the given vector.
         */
        static TRANSLATION(_translate) {
            const matrix = FudgeCore.Recycler.get(Matrix3x3);
            matrix.data.set([
                1, 0, 0,
                0, 1, 0,
                _translate.x, _translate.y, 1
            ]);
            return matrix;
        }
        /**
         * Returns a matrix that rotates coordinates on the z-axis when multiplied by.
         * @param _angleInDegrees The value of the rotation.
         */
        static ROTATION(_angleInDegrees) {
            // const matrix: Matrix3x3 = new Matrix3x3;
            const matrix = FudgeCore.Recycler.get(Matrix3x3);
            let angleInRadians = _angleInDegrees * Math.PI / 180;
            let sin = Math.sin(angleInRadians);
            let cos = Math.cos(angleInRadians);
            matrix.data.set([
                cos, sin, 0,
                -sin, cos, 0,
                0, 0, 1
            ]);
            return matrix;
        }
        /**
         * Returns a matrix that scales coordinates along the x-, y- and z-axis according to the given vector
         */
        static SCALING(_scalar) {
            // const matrix: Matrix3x3 = new Matrix3x3;
            const matrix = FudgeCore.Recycler.get(Matrix3x3);
            matrix.data.set([
                _scalar.x, 0, 0,
                0, _scalar.y, 0,
                0, 0, 1
            ]);
            return matrix;
        }
        //#endregion
        static MULTIPLICATION(_a, _b) {
            let a00 = _a.data[0 * 3 + 0];
            let a01 = _a.data[0 * 3 + 1];
            let a02 = _a.data[0 * 3 + 2];
            let a10 = _a.data[1 * 3 + 0];
            let a11 = _a.data[1 * 3 + 1];
            let a12 = _a.data[1 * 3 + 2];
            let a20 = _a.data[2 * 3 + 0];
            let a21 = _a.data[2 * 3 + 1];
            let a22 = _a.data[2 * 3 + 2];
            let b00 = _b.data[0 * 3 + 0];
            let b01 = _b.data[0 * 3 + 1];
            let b02 = _b.data[0 * 3 + 2];
            let b10 = _b.data[1 * 3 + 0];
            let b11 = _b.data[1 * 3 + 1];
            let b12 = _b.data[1 * 3 + 2];
            let b20 = _b.data[2 * 3 + 0];
            let b21 = _b.data[2 * 3 + 1];
            let b22 = _b.data[2 * 3 + 2];
            let matrix = new Matrix3x3;
            matrix.data.set([
                b00 * a00 + b01 * a10 + b02 * a20,
                b00 * a01 + b01 * a11 + b02 * a21,
                b00 * a02 + b01 * a12 + b02 * a22,
                b10 * a00 + b11 * a10 + b12 * a20,
                b10 * a01 + b11 * a11 + b12 * a21,
                b10 * a02 + b11 * a12 + b12 * a22,
                b20 * a00 + b21 * a10 + b22 * a20,
                b20 * a01 + b21 * a11 + b22 * a21,
                b20 * a02 + b21 * a12 + b22 * a22
            ]);
            return matrix;
        }
        //#region Translation
        /**
         * Add a translation by the given vector to this matrix
         */
        translate(_by) {
            const matrix = Matrix3x3.MULTIPLICATION(this, Matrix3x3.TRANSLATION(_by));
            // TODO: possible optimization, translation may alter mutator instead of deleting it.
            this.set(matrix);
            FudgeCore.Recycler.store(matrix);
        }
        /**
         * Add a translation along the x-Axis by the given amount to this matrix
         */
        translateX(_x) {
            this.data[6] += _x;
            this.mutator = null;
            this.vectors.translation = null;
        }
        /**
         * Add a translation along the y-Axis by the given amount to this matrix
         */
        translateY(_y) {
            this.data[7] += _y;
            this.mutator = null;
            this.vectors.translation = null;
        }
        //#endregion
        //#region Scaling
        /**
         * Add a scaling by the given vector to this matrix
         */
        scale(_by) {
            const matrix = Matrix3x3.MULTIPLICATION(this, Matrix3x3.SCALING(_by));
            this.set(matrix);
            FudgeCore.Recycler.store(matrix);
        }
        /**
         * Add a scaling along the x-Axis by the given amount to this matrix
         */
        scaleX(_by) {
            let vector = FudgeCore.Recycler.borrow(FudgeCore.Vector2);
            vector.set(_by, 1);
            this.scale(vector);
        }
        /**
         * Add a scaling along the y-Axis by the given amount to this matrix
         */
        scaleY(_by) {
            let vector = FudgeCore.Recycler.borrow(FudgeCore.Vector2);
            vector.set(1, _by);
            this.scale(vector);
        }
        //#endregion
        //#region Rotation
        /**
         * Adds a rotation around the z-Axis to this matrix
         */
        rotate(_angleInDegrees) {
            const matrix = Matrix3x3.MULTIPLICATION(this, Matrix3x3.ROTATION(_angleInDegrees));
            this.set(matrix);
            FudgeCore.Recycler.store(matrix);
        }
        //#endregion
        //#region Transformation
        /**
         * Multiply this matrix with the given matrix
         */
        multiply(_matrix) {
            this.set(Matrix3x3.MULTIPLICATION(this, _matrix));
            this.mutator = null;
        }
        //#endregion
        //#region Transfer
        /**
         * Calculates and returns the euler-angles representing the current rotation of this matrix
         */
        getEulerAngles() {
            let scaling = this.scaling;
            let s0 = this.data[0] / scaling.x;
            let s1 = this.data[1] / scaling.x;
            let s3 = this.data[3] / scaling.y;
            let s4 = this.data[4] / scaling.y;
            let xSkew = Math.atan2(-s3, s4);
            let ySkew = Math.atan2(s0, s1);
            let sy = Math.hypot(s0, s1); // probably 2. param should be this.data[4] / scaling.y
            let rotation;
            if (!(sy > 1e-6))
                rotation = ySkew;
            else
                rotation = xSkew;
            rotation *= 180 / Math.PI;
            return rotation;
        }
        /**
         * Sets the elements of this matrix to the values of the given matrix
         */
        set(_to) {
            // this.data = _to.get();
            this.data.set(_to.data);
            this.resetCache();
        }
        toString() {
            return `∆í.Matrix3x3(translation: ${this.translation.toString()}, rotation: ${this.rotation.toString()}, scaling: ${this.scaling.toString()}`;
        }
        /**
         * Return the elements of this matrix as a Float32Array
         */
        get() {
            return new Float32Array(this.data);
        }
        /**
         * Return a copy of this
         */
        get copy() {
            let copy = new Matrix3x3();
            copy.set(this);
            return copy;
        }
        serialize() {
            // TODO: save translation, rotation and scale as vectors for readability and manipulation
            let serialization = this.getMutator();
            return serialization;
        }
        deserialize(_serialization) {
            this.mutate(_serialization);
            return this;
        }
        getMutator() {
            if (this.mutator)
                return this.mutator;
            let mutator = {
                translation: this.translation.getMutator(),
                rotation: this.rotation,
                scaling: this.scaling.getMutator()
            };
            // cache mutator
            this.mutator = mutator;
            return mutator;
        }
        mutate(_mutator) {
            let oldTranslation = this.translation;
            let oldRotation = this.rotation;
            let oldScaling = this.scaling;
            let newTranslation = _mutator["translation"];
            let newRotation = _mutator["rotation"];
            let newScaling = _mutator["scaling"];
            let vectors = { translation: oldTranslation, rotation: oldRotation, scaling: oldScaling };
            if (newTranslation) {
                vectors.translation = new FudgeCore.Vector2(newTranslation.x != undefined ? newTranslation.x : oldTranslation.x, newTranslation.y != undefined ? newTranslation.y : oldTranslation.y);
            }
            vectors.rotation = (newRotation == undefined) ? oldRotation : newRotation;
            if (newScaling) {
                vectors.scaling = new FudgeCore.Vector2(newScaling.x != undefined ? newScaling.x : oldScaling.x, newScaling.y != undefined ? newScaling.y : oldScaling.y);
            }
            // TODO: possible performance optimization when only one or two components change, then use old matrix instead of IDENTITY and transform by differences/quotients
            let matrix = Matrix3x3.IDENTITY();
            if (vectors.translation)
                matrix.translate(vectors.translation);
            if (vectors.rotation) {
                matrix.rotate(vectors.rotation);
            }
            if (vectors.scaling)
                matrix.scale(vectors.scaling);
            this.set(matrix);
            this.vectors = vectors;
        }
        getMutatorAttributeTypes(_mutator) {
            let types = {};
            if (_mutator.translation)
                types.translation = "Vector2";
            if (_mutator.rotation)
                types.rotation = "number";
            if (_mutator.scaling)
                types.scaling = "Vector2";
            return types;
        }
        reduceMutator(_mutator) { }
        resetCache() {
            this.vectors = { translation: null, rotation: null, scaling: null };
            this.mutator = null;
        }
    }
    FudgeCore.Matrix3x3 = Matrix3x3;
    //#endregion
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Stores a 4x4 transformation matrix and provides operations for it.
     * ```plaintext
     * [ 0, 1, 2, 3 ] ‚Üê row vector x
     * [ 4, 5, 6, 7 ] ‚Üê row vector y
     * [ 8, 9,10,11 ] ‚Üê row vector z
     * [12,13,14,15 ] ‚Üê translation
     *            ‚Üë  homogeneous column
     * ```
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Matrix4x4 extends FudgeCore.Mutable {
        constructor() {
            super();
            this.data = new Float32Array(16); // The data of the matrix.
            this.mutator = null; // prepared for optimization, keep mutator to reduce redundant calculation and for comparison. Set to null when data changes!
            this.data.set([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]);
            this.resetCache();
        }
        /**
         * - get: a copy of the calculated translation vector
         * - set: effect the matrix ignoring its rotation and scaling
         */
        get translation() {
            if (!this.vectors.translation) {
                this.vectors.translation = FudgeCore.Recycler.get(FudgeCore.Vector3);
                this.vectors.translation.set(this.data[12], this.data[13], this.data[14]);
            }
            return this.vectors.translation.copy;
        }
        set translation(_translation) {
            this.data.set(_translation.get(), 12);
            // no full cache reset required
            this.vectors.translation = _translation.copy;
            this.mutator = null;
        }
        /**
         * - get: a copy of the calculated rotation vector
         * - set: effect the matrix
         */
        get rotation() {
            if (!this.vectors.rotation)
                this.vectors.rotation = this.getEulerAngles();
            return this.vectors.rotation.copy;
        }
        set rotation(_rotation) {
            this.mutate({ "rotation": _rotation });
            this.resetCache();
        }
        /**
         * - get: a copy of the calculated scale vector
         * - set: effect the matrix
         */
        get scaling() {
            if (!this.vectors.scaling) {
                this.vectors.scaling = FudgeCore.Recycler.get(FudgeCore.Vector3);
                this.vectors.scaling.set(Math.hypot(this.data[0], this.data[1], this.data[2]), Math.hypot(this.data[4], this.data[5], this.data[6]), Math.hypot(this.data[8], this.data[9], this.data[10]));
            }
            return this.vectors.scaling.copy;
        }
        set scaling(_scaling) {
            this.mutate({ "scaling": _scaling });
            this.resetCache();
        }
        //#region STATICS
        /**
         * Retrieve a new identity matrix
         */
        static IDENTITY() {
            // const result: Matrix4x4 = new Matrix4x4();
            const result = FudgeCore.Recycler.get(Matrix4x4);
            result.data.set([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]);
            return result;
        }
        /**
         * Computes and returns the product of two passed matrices.
         * @param _a The matrix to multiply.
         * @param _b The matrix to multiply by.
         */
        static MULTIPLICATION(_a, _b) {
            let a = _a.data;
            let b = _b.data;
            // let matrix: Matrix4x4 = new Matrix4x4();
            const matrix = FudgeCore.Recycler.get(Matrix4x4);
            let a00 = a[0 * 4 + 0];
            let a01 = a[0 * 4 + 1];
            let a02 = a[0 * 4 + 2];
            let a03 = a[0 * 4 + 3];
            let a10 = a[1 * 4 + 0];
            let a11 = a[1 * 4 + 1];
            let a12 = a[1 * 4 + 2];
            let a13 = a[1 * 4 + 3];
            let a20 = a[2 * 4 + 0];
            let a21 = a[2 * 4 + 1];
            let a22 = a[2 * 4 + 2];
            let a23 = a[2 * 4 + 3];
            let a30 = a[3 * 4 + 0];
            let a31 = a[3 * 4 + 1];
            let a32 = a[3 * 4 + 2];
            let a33 = a[3 * 4 + 3];
            let b00 = b[0 * 4 + 0];
            let b01 = b[0 * 4 + 1];
            let b02 = b[0 * 4 + 2];
            let b03 = b[0 * 4 + 3];
            let b10 = b[1 * 4 + 0];
            let b11 = b[1 * 4 + 1];
            let b12 = b[1 * 4 + 2];
            let b13 = b[1 * 4 + 3];
            let b20 = b[2 * 4 + 0];
            let b21 = b[2 * 4 + 1];
            let b22 = b[2 * 4 + 2];
            let b23 = b[2 * 4 + 3];
            let b30 = b[3 * 4 + 0];
            let b31 = b[3 * 4 + 1];
            let b32 = b[3 * 4 + 2];
            let b33 = b[3 * 4 + 3];
            matrix.data.set([
                b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30,
                b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31,
                b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32,
                b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33,
                b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30,
                b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31,
                b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32,
                b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33,
                b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30,
                b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31,
                b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32,
                b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33,
                b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30,
                b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31,
                b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32,
                b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33
            ]);
            return matrix;
        }
        /**
         * Computes and returns the inverse of a passed matrix.
         * @param _matrix The matrix to compute the inverse of.
         */
        static INVERSION(_matrix) {
            let m = _matrix.data;
            let m00 = m[0 * 4 + 0];
            let m01 = m[0 * 4 + 1];
            let m02 = m[0 * 4 + 2];
            let m03 = m[0 * 4 + 3];
            let m10 = m[1 * 4 + 0];
            let m11 = m[1 * 4 + 1];
            let m12 = m[1 * 4 + 2];
            let m13 = m[1 * 4 + 3];
            let m20 = m[2 * 4 + 0];
            let m21 = m[2 * 4 + 1];
            let m22 = m[2 * 4 + 2];
            let m23 = m[2 * 4 + 3];
            let m30 = m[3 * 4 + 0];
            let m31 = m[3 * 4 + 1];
            let m32 = m[3 * 4 + 2];
            let m33 = m[3 * 4 + 3];
            let tmp0 = m22 * m33;
            let tmp1 = m32 * m23;
            let tmp2 = m12 * m33;
            let tmp3 = m32 * m13;
            let tmp4 = m12 * m23;
            let tmp5 = m22 * m13;
            let tmp6 = m02 * m33;
            let tmp7 = m32 * m03;
            let tmp8 = m02 * m23;
            let tmp9 = m22 * m03;
            let tmp10 = m02 * m13;
            let tmp11 = m12 * m03;
            let tmp12 = m20 * m31;
            let tmp13 = m30 * m21;
            let tmp14 = m10 * m31;
            let tmp15 = m30 * m11;
            let tmp16 = m10 * m21;
            let tmp17 = m20 * m11;
            let tmp18 = m00 * m31;
            let tmp19 = m30 * m01;
            let tmp20 = m00 * m21;
            let tmp21 = m20 * m01;
            let tmp22 = m00 * m11;
            let tmp23 = m10 * m01;
            let t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) -
                (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);
            let t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) -
                (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);
            let t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) -
                (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);
            let t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) -
                (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);
            let d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);
            // let matrix: Matrix4x4 = new Matrix4x4;
            const matrix = FudgeCore.Recycler.get(Matrix4x4);
            matrix.data.set([
                d * t0,
                d * t1,
                d * t2,
                d * t3,
                d * ((tmp1 * m10 + tmp2 * m20 + tmp5 * m30) - (tmp0 * m10 + tmp3 * m20 + tmp4 * m30)),
                d * ((tmp0 * m00 + tmp7 * m20 + tmp8 * m30) - (tmp1 * m00 + tmp6 * m20 + tmp9 * m30)),
                d * ((tmp3 * m00 + tmp6 * m10 + tmp11 * m30) - (tmp2 * m00 + tmp7 * m10 + tmp10 * m30)),
                d * ((tmp4 * m00 + tmp9 * m10 + tmp10 * m20) - (tmp5 * m00 + tmp8 * m10 + tmp11 * m20)),
                d * ((tmp12 * m13 + tmp15 * m23 + tmp16 * m33) - (tmp13 * m13 + tmp14 * m23 + tmp17 * m33)),
                d * ((tmp13 * m03 + tmp18 * m23 + tmp21 * m33) - (tmp12 * m03 + tmp19 * m23 + tmp20 * m33)),
                d * ((tmp14 * m03 + tmp19 * m13 + tmp22 * m33) - (tmp15 * m03 + tmp18 * m13 + tmp23 * m33)),
                d * ((tmp17 * m03 + tmp20 * m13 + tmp23 * m23) - (tmp16 * m03 + tmp21 * m13 + tmp22 * m23)),
                d * ((tmp14 * m22 + tmp17 * m32 + tmp13 * m12) - (tmp16 * m32 + tmp12 * m12 + tmp15 * m22)),
                d * ((tmp20 * m32 + tmp12 * m02 + tmp19 * m22) - (tmp18 * m22 + tmp21 * m32 + tmp13 * m02)),
                d * ((tmp18 * m12 + tmp23 * m32 + tmp15 * m02) - (tmp22 * m32 + tmp14 * m02 + tmp19 * m12)),
                d * ((tmp22 * m22 + tmp16 * m02 + tmp21 * m12) - (tmp20 * m12 + tmp23 * m22 + tmp17 * m02)) // [15]
            ]);
            return matrix;
        }
        /**
         * Computes and returns a matrix with the given translation, its z-axis pointing directly at the given target,
         * and a minimal angle between its y-axis and the given up-Vector, respetively calculating yaw and pitch.
         */
        static LOOK_AT(_translation, _target, _up = FudgeCore.Vector3.Y()) {
            // const matrix: Matrix4x4 = new Matrix4x4;
            const matrix = FudgeCore.Recycler.get(Matrix4x4);
            let zAxis = FudgeCore.Vector3.DIFFERENCE(_target, _translation);
            zAxis.normalize();
            let xAxis = FudgeCore.Vector3.NORMALIZATION(FudgeCore.Vector3.CROSS(_up, zAxis));
            let yAxis = FudgeCore.Vector3.NORMALIZATION(FudgeCore.Vector3.CROSS(zAxis, xAxis));
            matrix.data.set([
                xAxis.x, xAxis.y, xAxis.z, 0,
                yAxis.x, yAxis.y, yAxis.z, 0,
                zAxis.x, zAxis.y, zAxis.z, 0,
                _translation.x,
                _translation.y,
                _translation.z,
                1
            ]);
            return matrix;
        }
        /**
         * Computes and returns a matrix with the given translation, its y-axis matching the given up-vector
         * and its z-axis facing towards the given target at a minimal angle, respetively calculating yaw only.
         */
        static SHOW_TO(_translation, _target, _up = FudgeCore.Vector3.Y()) {
            // const matrix: Matrix4x4 = new Matrix4x4;
            const matrix = FudgeCore.Recycler.get(Matrix4x4);
            let zAxis = FudgeCore.Vector3.DIFFERENCE(_target, _translation);
            zAxis.normalize();
            let xAxis = FudgeCore.Vector3.NORMALIZATION(FudgeCore.Vector3.CROSS(_up, zAxis));
            // let yAxis: Vector3 = Vector3.NORMALIZATION(Vector3.CROSS(zAxis, xAxis));
            zAxis = FudgeCore.Vector3.NORMALIZATION(FudgeCore.Vector3.CROSS(xAxis, _up));
            matrix.data.set([
                xAxis.x, xAxis.y, xAxis.z, 0,
                _up.x, _up.y, _up.z, 0,
                zAxis.x, zAxis.y, zAxis.z, 0,
                _translation.x,
                _translation.y,
                _translation.z,
                1
            ]);
            return matrix;
        }
        /**
         * Returns a matrix that translates coordinates along the x-, y- and z-axis according to the given vector.
         */
        static TRANSLATION(_translate) {
            // let matrix: Matrix4x4 = new Matrix4x4;
            const matrix = FudgeCore.Recycler.get(Matrix4x4);
            matrix.data.set([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                _translate.x, _translate.y, _translate.z, 1
            ]);
            return matrix;
        }
        /**
         * Returns a matrix that rotates coordinates on the x-axis when multiplied by.
         * @param _angleInDegrees The value of the rotation.
         */
        static ROTATION_X(_angleInDegrees) {
            // const matrix: Matrix4x4 = new Matrix4x4;
            const matrix = FudgeCore.Recycler.get(Matrix4x4);
            let angleInRadians = _angleInDegrees * Math.PI / 180;
            let sin = Math.sin(angleInRadians);
            let cos = Math.cos(angleInRadians);
            matrix.data.set([
                1, 0, 0, 0,
                0, cos, sin, 0,
                0, -sin, cos, 0,
                0, 0, 0, 1
            ]);
            return matrix;
        }
        /**
         * Returns a matrix that rotates coordinates on the y-axis when multiplied by.
         * @param _angleInDegrees The value of the rotation.
         */
        static ROTATION_Y(_angleInDegrees) {
            // const matrix: Matrix4x4 = new Matrix4x4;
            let matrix = FudgeCore.Recycler.get(Matrix4x4);
            let angleInRadians = _angleInDegrees * Math.PI / 180;
            let sin = Math.sin(angleInRadians);
            let cos = Math.cos(angleInRadians);
            matrix.data.set([
                cos, 0, -sin, 0,
                0, 1, 0, 0,
                sin, 0, cos, 0,
                0, 0, 0, 1
            ]);
            return matrix;
        }
        /**
         * Returns a matrix that rotates coordinates on the z-axis when multiplied by.
         * @param _angleInDegrees The value of the rotation.
         */
        static ROTATION_Z(_angleInDegrees) {
            // const matrix: Matrix4x4 = new Matrix4x4;
            const matrix = FudgeCore.Recycler.get(Matrix4x4);
            let angleInRadians = _angleInDegrees * Math.PI / 180;
            let sin = Math.sin(angleInRadians);
            let cos = Math.cos(angleInRadians);
            matrix.data.set([
                cos, sin, 0, 0,
                -sin, cos, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]);
            return matrix;
        }
        /**
         * Returns a matrix that scales coordinates along the x-, y- and z-axis according to the given vector
         */
        static SCALING(_scalar) {
            // const matrix: Matrix4x4 = new Matrix4x4;
            const matrix = FudgeCore.Recycler.get(Matrix4x4);
            matrix.data.set([
                _scalar.x, 0, 0, 0,
                0, _scalar.y, 0, 0,
                0, 0, _scalar.z, 0,
                0, 0, 0, 1
            ]);
            return matrix;
        }
        /**
         * Returns a representation of the given matrix relative to the given base.
         * If known, pass the inverse of the base to avoid unneccesary calculation
         */
        static RELATIVE(_matrix, _base, _inverse) {
            let result = _inverse ? _inverse : Matrix4x4.INVERSION(_base);
            result = Matrix4x4.MULTIPLICATION(result, _matrix);
            return result;
        }
        //#endregion
        //#region PROJECTIONS
        /**
         * Computes and returns a matrix that applies perspective to an object, if its transform is multiplied by it.
         * @param _aspect The aspect ratio between width and height of projectionspace.(Default = canvas.clientWidth / canvas.ClientHeight)
         * @param _fieldOfViewInDegrees The field of view in Degrees. (Default = 45)
         * @param _near The near clipspace border on the z-axis.
         * @param _far The far clipspace border on the z-axis.
         * @param _direction The plane on which the fieldOfView-Angle is given
         */
        static PROJECTION_CENTRAL(_aspect, _fieldOfViewInDegrees, _near, _far, _direction) {
            //TODO: camera looks down negative z-direction, should be positive
            let fieldOfViewInRadians = _fieldOfViewInDegrees * Math.PI / 180;
            let f = Math.tan(0.5 * (Math.PI - fieldOfViewInRadians));
            let rangeInv = 1.0 / (_near - _far);
            // const matrix: Matrix4x4 = new Matrix4x4;
            const matrix = FudgeCore.Recycler.get(Matrix4x4);
            matrix.data.set([
                f, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (_near + _far) * rangeInv, -1,
                0, 0, _near * _far * rangeInv * 2, 0
            ]);
            if (_direction == FudgeCore.FIELD_OF_VIEW.DIAGONAL) {
                _aspect = Math.sqrt(_aspect);
                matrix.data[0] = f / _aspect;
                matrix.data[5] = f * _aspect;
            }
            else if (_direction == FudgeCore.FIELD_OF_VIEW.VERTICAL)
                matrix.data[0] = f / _aspect;
            else //FOV_DIRECTION.HORIZONTAL
                matrix.data[5] = f * _aspect;
            // HACK: matrix should look in positive z-direction, preferably the matrix should be calculated like that right away
            matrix.rotateY(180);
            return matrix;
        }
        /**
         * Computes and returns a matrix that applies orthographic projection to an object, if its transform is multiplied by it.
         * @param _left The positionvalue of the projectionspace's left border.
         * @param _right The positionvalue of the projectionspace's right border.
         * @param _bottom The positionvalue of the projectionspace's bottom border.
         * @param _top The positionvalue of the projectionspace's top border.
         * @param _near The positionvalue of the projectionspace's near border.
         * @param _far The positionvalue of the projectionspace's far border
         */
        static PROJECTION_ORTHOGRAPHIC(_left, _right, _bottom, _top, _near = -400, _far = 400) {
            // const matrix: Matrix4x4 = new Matrix4x4;
            const matrix = FudgeCore.Recycler.get(Matrix4x4);
            matrix.data.set([
                2 / (_right - _left), 0, 0, 0,
                0, 2 / (_top - _bottom), 0, 0,
                0, 0, 2 / (_near - _far), 0,
                (_left + _right) / (_left - _right),
                (_bottom + _top) / (_bottom - _top),
                (_near + _far) / (_near - _far),
                1
            ]);
            return matrix;
        }
        //#endregion
        //#region Rotation
        /**
         * Rotate this matrix by given vector in the order Z, Y, X. Right hand rotation is used, thumb points in axis direction, fingers curling indicate rotation
         * The rotation is appended to already applied transforms, thus multiplied from the right. Set _fromLeft to true to switch and put it in front.
         */
        rotate(_by, _fromLeft = false) {
            this.rotateZ(_by.z, _fromLeft);
            this.rotateY(_by.y, _fromLeft);
            this.rotateX(_by.x, _fromLeft);
        }
        /**
         * Adds a rotation around the x-axis to this matrix
         */
        rotateX(_angleInDegrees, _fromLeft = false) {
            let rotation = Matrix4x4.ROTATION_X(_angleInDegrees);
            this.multiply(rotation, _fromLeft);
            FudgeCore.Recycler.store(rotation);
        }
        /**
         * Adds a rotation around the y-axis to this matrix
         */
        rotateY(_angleInDegrees, _fromLeft = false) {
            let rotation = Matrix4x4.ROTATION_Y(_angleInDegrees);
            this.multiply(rotation, _fromLeft);
            FudgeCore.Recycler.store(rotation);
        }
        /**
         * Adds a rotation around the z-axis to this matrix
         */
        rotateZ(_angleInDegrees, _fromLeft = false) {
            let rotation = Matrix4x4.ROTATION_Z(_angleInDegrees);
            this.multiply(rotation, _fromLeft);
            FudgeCore.Recycler.store(rotation);
        }
        /**
         * Adjusts the rotation of this matrix to point the z-axis directly at the given target and tilts it to accord with the given up vector,
         * respectively calculating yaw and pitch. If no up vector is given, the previous up-vector is used.
         * When _preserveScaling is false, a rotated identity matrix is the result.
         */
        lookAt(_target, _up, _preserveScaling = true) {
            if (!_up)
                _up = this.getY();
            const matrix = Matrix4x4.LOOK_AT(this.translation, _target, _up);
            if (_preserveScaling)
                matrix.scale(this.scaling);
            this.set(matrix);
            FudgeCore.Recycler.store(matrix);
        }
        // TODO: testing lookat that really just rotates the matrix rather than creating a new one
        lookAtRotate(_target, _up, _preserveScaling = true) {
            if (!_up)
                _up = this.getY();
            let scaling = this.scaling;
            let difference = FudgeCore.Vector3.DIFFERENCE(_target, this.translation);
            difference.normalize();
            let cos = FudgeCore.Vector3.DOT(FudgeCore.Vector3.NORMALIZATION(this.getZ()), difference);
            let sin = FudgeCore.Vector3.DOT(FudgeCore.Vector3.NORMALIZATION(this.getX()), difference);
            console.log(sin, cos);
            let mtxRotation = FudgeCore.Recycler.borrow(Matrix4x4);
            mtxRotation.data.set([
                cos, 0, -sin, 0,
                0, 1, 0, 0,
                sin, 0, cos, 0,
                0, 0, 0, 1
            ]);
            this.multiply(mtxRotation, false);
            cos = FudgeCore.Vector3.DOT(FudgeCore.Vector3.NORMALIZATION(this.getZ()), difference);
            sin = -FudgeCore.Vector3.DOT(FudgeCore.Vector3.NORMALIZATION(this.getY()), difference);
            console.log(sin, cos);
            mtxRotation.data.set([
                1, 0, 0, 0,
                0, cos, sin, 0,
                0, -sin, cos, 0,
                0, 0, 0, 1
            ]);
            this.multiply(mtxRotation, false);
            this.scaling = scaling;
        }
        /**
         * Adjusts the rotation of this matrix to match its y-axis with the given up-vector and facing its z-axis toward the given target at minimal angle,
         * respectively calculating yaw only. If no up vector is given, the previous up-vector is used.
         * When _preserveScaling is false, a rotated identity matrix is the result.
         */
        showTo(_target, _up, _preserveScaling = true) {
            if (!_up)
                _up = this.getY();
            const matrix = Matrix4x4.SHOW_TO(this.translation, _target, _up);
            if (_preserveScaling)
                matrix.scale(this.scaling);
            this.set(matrix);
            FudgeCore.Recycler.store(matrix);
        }
        //#endregion
        //#region Translation
        /**
         * Add a translation by the given vector to this matrix.
         * If _local is true, translation occurs according to the current rotation and scaling of this matrix,
         * according to the parent otherwise.
         */
        translate(_by, _local = true) {
            if (_local) {
                let translation = Matrix4x4.TRANSLATION(_by);
                this.multiply(translation);
                FudgeCore.Recycler.store(translation);
            }
            else {
                this.data[12] += _by.x;
                this.data[13] += _by.y;
                this.data[14] += _by.z;
                this.mutator = null;
                if (this.vectors.translation)
                    FudgeCore.Recycler.store(this.vectors.translation);
                this.vectors.translation = null;
            }
            // const matrix: Matrix4x4 = Matrix4x4.MULTIPLICATION(this, Matrix4x4.TRANSLATION(_by));
            // // TODO: possible optimization, translation may alter mutator instead of deleting it.
            // this.set(matrix);
            // Recycler.store(matrix);
        }
        /**
         * Add a translation along the x-axis by the given amount to this matrix
         */
        translateX(_x, _local = true) {
            let translation = FudgeCore.Vector3.X(_x);
            this.translate(translation, _local);
            FudgeCore.Recycler.store(translation);
        }
        /**
         * Add a translation along the y-axis by the given amount to this matrix
         */
        translateY(_y, _local = true) {
            let translation = FudgeCore.Vector3.Y(_y);
            this.translate(translation, _local);
            FudgeCore.Recycler.store(translation);
        }
        /**
         * Add a translation along the z-axis by the given amount to this matrix
         */
        translateZ(_z, _local = true) {
            let translation = FudgeCore.Vector3.Z(_z);
            this.translate(translation, _local);
            FudgeCore.Recycler.store(translation);
        }
        //#endregion
        //#region Scaling
        /**
         * Add a scaling by the given vector to this matrix
         */
        scale(_by) {
            const matrix = Matrix4x4.MULTIPLICATION(this, Matrix4x4.SCALING(_by));
            this.set(matrix);
            FudgeCore.Recycler.store(matrix);
        }
        /**
         * Add a scaling along the x-axis by the given amount to this matrix
         */
        scaleX(_by) {
            let vector = FudgeCore.Recycler.borrow(FudgeCore.Vector3);
            vector.set(_by, 1, 1);
            this.scale(vector);
        }
        /**
         * Add a scaling along the y-axis by the given amount to this matrix
         */
        scaleY(_by) {
            let vector = FudgeCore.Recycler.borrow(FudgeCore.Vector3);
            vector.set(1, _by, 1);
            this.scale(vector);
        }
        /**
         * Add a scaling along the z-axis by the given amount to this matrix
         */
        scaleZ(_by) {
            let vector = FudgeCore.Recycler.borrow(FudgeCore.Vector3);
            vector.set(1, 1, _by);
            this.scale(vector);
        }
        //#endregion
        //#region Transformation
        /**
         * Multiply this matrix with the given matrix
         */
        multiply(_matrix, _fromLeft = false) {
            const matrix = _fromLeft ? Matrix4x4.MULTIPLICATION(_matrix, this) : Matrix4x4.MULTIPLICATION(this, _matrix);
            this.set(matrix);
            FudgeCore.Recycler.store(matrix);
        }
        //#endregion
        //#region Transfer
        /**
         * Calculates and returns the euler-angles representing the current rotation of this matrix
         */
        getEulerAngles() {
            let scaling = this.scaling;
            let s0 = this.data[0] / scaling.x;
            let s1 = this.data[1] / scaling.x;
            let s2 = this.data[2] / scaling.x;
            let s6 = this.data[6] / scaling.y;
            let s10 = this.data[10] / scaling.z;
            let sy = Math.hypot(s0, s1); // probably 2. param should be this.data[4] / scaling.y
            let singular = sy < 1e-6; // If
            let x1, y1, z1;
            let x2, y2, z2;
            if (!singular) {
                x1 = Math.atan2(s6, s10);
                y1 = Math.atan2(-s2, sy);
                z1 = Math.atan2(s1, s0);
                x2 = Math.atan2(-s6, -s10);
                y2 = Math.atan2(-s2, -sy);
                z2 = Math.atan2(-s1, -s0);
                if (Math.abs(x2) + Math.abs(y2) + Math.abs(z2) < Math.abs(x1) + Math.abs(y1) + Math.abs(z1)) {
                    x1 = x2;
                    y1 = y2;
                    z1 = z2;
                }
            }
            else {
                x1 = Math.atan2(-this.data[9] / scaling.z, this.data[5] / scaling.y);
                y1 = Math.atan2(-this.data[2] / scaling.x, sy);
                z1 = 0;
            }
            let rotation = FudgeCore.Recycler.get(FudgeCore.Vector3);
            rotation.set(x1, y1, z1);
            rotation.scale(180 / Math.PI);
            return rotation;
        }
        /**
         * Sets the elements of this matrix to the values of the given matrix
         */
        set(_to) {
            // this.data = _to.get();
            this.data.set(_to.data);
            this.resetCache();
        }
        toString() {
            return `∆í.Matrix4x4(translation: ${this.translation.toString()}, rotation: ${this.rotation.toString()}, scaling: ${this.scaling.toString()}`;
        }
        /**
         * Return the elements of this matrix as a Float32Array
         */
        get() {
            return new Float32Array(this.data);
        }
        /**
         * Return cardinal x-axis
         */
        getX() {
            let result = FudgeCore.Recycler.get(FudgeCore.Vector3);
            result.set(this.data[0], this.data[1], this.data[2]);
            return result;
        }
        /**
         * Return cardinal y-axis
         */
        getY() {
            let result = FudgeCore.Recycler.get(FudgeCore.Vector3);
            result.set(this.data[4], this.data[5], this.data[6]);
            return result;
        }
        /**
         * Return cardinal z-axis
         */
        getZ() {
            let result = FudgeCore.Recycler.get(FudgeCore.Vector3);
            result.set(this.data[8], this.data[9], this.data[10]);
            return result;
        }
        /**
         * Swaps the two cardinal axis and reverses the third, effectively rotating the transform 180 degrees around one and 90 degrees around a second axis
         */
        swapXY() {
            let temp = [this.data[0], this.data[1], this.data[2]]; // store x-axis
            this.data.set([this.data[4], this.data[5], this.data[6]], 0); // overwrite x-axis with y-axis
            this.data.set(temp, 4); // overwrite Y with temp
            this.data.set([-this.data[8], -this.data[9], -this.data[10]], 8); // reverse z-axis
        }
        /**
         * Swaps the two cardinal axis and reverses the third, effectively rotating the transform 180 degrees around one and 90 degrees around a second axis
         */
        swapXZ() {
            let temp = [this.data[0], this.data[1], this.data[2]]; // store x-axis
            this.data.set([this.data[8], this.data[9], this.data[10]], 0); // overwrite x-axis with z-axis
            this.data.set(temp, 8); // overwrite Z with temp
            this.data.set([-this.data[4], -this.data[5], -this.data[6]], 4); // reverse y-axis
        }
        /**
         * Swaps the two cardinal axis and reverses the third, effectively rotating the transform 180 degrees around one and 90 degrees around a second axis
         */
        swapYZ() {
            let temp = [this.data[4], this.data[5], this.data[6]]; // store y-axis
            this.data.set([this.data[8], this.data[9], this.data[10]], 4); // overwrite y-axis with z-axis
            this.data.set(temp, 8); // overwrite Z with temp
            this.data.set([-this.data[0], -this.data[1], -this.data[2]], 0); // reverse x-axis
        }
        /**
         * Return a copy of this
         */
        get copy() {
            let copy = new Matrix4x4();
            copy.set(this);
            return copy;
        }
        getTranslationTo(_target) {
            let difference = FudgeCore.Recycler.get(FudgeCore.Vector3);
            difference.set(_target.data[12] - this.data[12], _target.data[13] - this.data[13], _target.data[14] - this.data[14]);
            return difference;
        }
        serialize() {
            // TODO: save translation, rotation and scale as vectors for readability and manipulation
            let serialization = this.getMutator();
            return serialization;
        }
        deserialize(_serialization) {
            this.mutate(_serialization);
            return this;
        }
        getMutator() {
            if (this.mutator)
                return this.mutator;
            let mutator = {
                translation: this.translation.getMutator(),
                rotation: this.rotation.getMutator(),
                scaling: this.scaling.getMutator()
            };
            // cache mutator
            this.mutator = mutator;
            return mutator;
        }
        mutate(_mutator) {
            let oldTranslation = this.translation;
            let oldRotation = this.rotation;
            let oldScaling = this.scaling;
            let newTranslation = _mutator["translation"];
            let newRotation = _mutator["rotation"];
            let newScaling = _mutator["scaling"];
            let vectors = { translation: oldTranslation, rotation: oldRotation, scaling: oldScaling };
            if (newTranslation) {
                vectors.translation = FudgeCore.Recycler.get(FudgeCore.Vector3);
                vectors.translation.set(newTranslation.x != undefined ? newTranslation.x : oldTranslation.x, newTranslation.y != undefined ? newTranslation.y : oldTranslation.y, newTranslation.z != undefined ? newTranslation.z : oldTranslation.z);
            }
            if (newRotation) {
                vectors.rotation = FudgeCore.Recycler.get(FudgeCore.Vector3);
                vectors.rotation.set(newRotation.x != undefined ? newRotation.x : oldRotation.x, newRotation.y != undefined ? newRotation.y : oldRotation.y, newRotation.z != undefined ? newRotation.z : oldRotation.z);
            }
            if (newScaling) {
                vectors.scaling = FudgeCore.Recycler.get(FudgeCore.Vector3);
                vectors.scaling.set(newScaling.x != undefined ? newScaling.x : oldScaling.x, newScaling.y != undefined ? newScaling.y : oldScaling.y, newScaling.z != undefined ? newScaling.z : oldScaling.z);
            }
            // TODO: possible performance optimization when only one or two components change, then use old matrix instead of IDENTITY and transform by differences/quotients
            let matrix = Matrix4x4.IDENTITY();
            if (vectors.translation)
                matrix.translate(vectors.translation);
            if (vectors.rotation) {
                matrix.rotateZ(vectors.rotation.z);
                matrix.rotateY(vectors.rotation.y);
                matrix.rotateX(vectors.rotation.x);
            }
            if (vectors.scaling)
                matrix.scale(vectors.scaling);
            this.set(matrix);
            this.vectors = vectors;
            FudgeCore.Recycler.store(matrix);
        }
        getMutatorAttributeTypes(_mutator) {
            let types = {};
            if (_mutator.translation)
                types.translation = "Vector3";
            if (_mutator.rotation)
                types.rotation = "Vector3";
            if (_mutator.scaling)
                types.scaling = "Vector3";
            return types;
        }
        reduceMutator(_mutator) { }
        resetCache() {
            this.vectors = { translation: null, rotation: null, scaling: null };
            this.mutator = null;
        }
    }
    FudgeCore.Matrix4x4 = Matrix4x4;
    //#endregion
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Class for creating random values, supporting Javascript's Math.random and a deterministig pseudo-random number generator (PRNG)
     * that can be fed with a seed and then returns a reproducable set of random numbers (if the precision of Javascript allows)
     *
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     */
    let Random = /** @class */ (() => {
        class Random {
            /**
             * Create an instance of [[Random]]. If desired, creates a PRNG with it and feeds the given seed.
             * @param _ownGenerator Default is false
             * @param _seed Default is Math.random()
             */
            constructor(_ownGenerator = false, _seed = Math.random()) {
                this.generate = Math.random;
                if (_ownGenerator)
                    this.generate = Random.createGenerator(_seed);
            }
            /**
             * Creates a dererminstic PRNG with the given seed
             */
            static createGenerator(_seed) {
                // TODO: replace with random number generator to generate predictable sequence
                return Math.random;
            }
            /**
             * Returns a normed random number, thus in the range of [0, 1[
             */
            getNorm() {
                return this.generate();
            }
            /**
             * Returns a random number in the range of given [_min, _max[
             */
            getRange(_min, _max) {
                return _min + this.generate() * (_max - _min);
            }
            /**
             * Returns a random integer number in the range of given floored [_min, _max[
             */
            getRangeFloored(_min, _max) {
                return Math.floor(this.getRange(_min, _max));
            }
            /**
             * Returns true or false randomly
             */
            getBoolean() {
                return this.generate() < 0.5;
            }
            /**
             * Returns -1 or 1 randomly
             */
            getSign() {
                return this.getBoolean() ? 1 : -1;
            }
            /**
             * Returns a randomly selected index into the given array
             */
            getIndex(_array) {
                if (_array.length > 0)
                    return this.getRangeFloored(0, _array.length);
                return -1;
            }
            /**
             * Removes a randomly selected element from the given array and returns it
             */
            splice(_array) {
                return _array.splice(this.getIndex(_array), 1)[0];
            }
            /**
             * Returns a randomly selected key from the given Map-instance
             */
            getKey(_map) {
                let keys = Array.from(_map.keys());
                return keys[this.getIndex(keys)];
            }
            /**
             * Returns a randomly selected property name from the given object
             */
            getPropertyName(_object) {
                let keys = Object.getOwnPropertyNames(_object);
                return keys[this.getIndex(keys)];
            }
            /**
             * Returns a randomly selected symbol from the given object, if symbols are used as keys
             */
            getPropertySymbol(_object) {
                let keys = Object.getOwnPropertySymbols(_object);
                return keys[this.getIndex(keys)];
            }
        }
        Random.default = new Random();
        return Random;
    })();
    FudgeCore.Random = Random;
    /**
     * Standard [[Random]]-instance using Math.random().
     */
    FudgeCore.random = new Random();
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Stores and manipulates a threedimensional vector comprised of the components x, y and z
     * ```plaintext
     *            +y
     *             |__ +x
     *            /
     *          +z
     * ```
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Vector3 extends FudgeCore.Mutable {
        constructor(_x = 0, _y = 0, _z = 0) {
            super();
            this.data = new Float32Array([_x, _y, _z]);
        }
        // TODO: implement equals-functions
        get x() {
            return this.data[0];
        }
        get y() {
            return this.data[1];
        }
        get z() {
            return this.data[2];
        }
        set x(_x) {
            this.data[0] = _x;
        }
        set y(_y) {
            this.data[1] = _y;
        }
        set z(_z) {
            this.data[2] = _z;
        }
        /**
         * Returns the length of the vector
         */
        get magnitude() {
            return Math.hypot(...this.data);
        }
        /**
         * Returns the square of the magnitude of the vector without calculating a square root. Faster for simple proximity evaluation.
         */
        get magnitudeSquared() {
            return Vector3.DOT(this, this);
        }
        /**
         * Creates and returns a vector with the given length pointing in x-direction
         */
        static X(_scale = 1) {
            const vector = FudgeCore.Recycler.get(Vector3);
            vector.data.set([_scale, 0, 0]);
            return vector;
        }
        /**
         * Creates and returns a vector with the given length pointing in y-direction
         */
        static Y(_scale = 1) {
            const vector = FudgeCore.Recycler.get(Vector3);
            vector.data.set([0, _scale, 0]);
            return vector;
        }
        /**
         * Creates and returns a vector with the given length pointing in z-direction
         */
        static Z(_scale = 1) {
            const vector = FudgeCore.Recycler.get(Vector3);
            vector.data.set([0, 0, _scale]);
            return vector;
        }
        /**
         * Creates and returns a vector with the value 0 on each axis
         */
        static ZERO() {
            const vector = FudgeCore.Recycler.get(Vector3);
            vector.data.set([0, 0, 0]);
            return vector;
        }
        /**
         * Creates and returns a vector of the given size on each of the three axis
         */
        static ONE(_scale = 1) {
            const vector = FudgeCore.Recycler.get(Vector3);
            vector.data.set([_scale, _scale, _scale]);
            return vector;
        }
        /**
         * Creates and returns a vector through transformation of the given vector by the given matrix
         */
        static TRANSFORMATION(_vector, _matrix, _includeTranslation = true) {
            let result = FudgeCore.Recycler.get(Vector3);
            let m = _matrix.get();
            let [x, y, z] = _vector.get();
            result.x = m[0] * x + m[4] * y + m[8] * z;
            result.y = m[1] * x + m[5] * y + m[9] * z;
            result.z = m[2] * x + m[6] * y + m[10] * z;
            if (_includeTranslation) {
                result.add(_matrix.translation);
            }
            return result;
        }
        /**
         * Creates and returns a vector which is a copy of the given vector scaled to the given length
         */
        static NORMALIZATION(_vector, _length = 1) {
            let magnitude = _vector.magnitude;
            let vector;
            try {
                if (magnitude == 0)
                    throw (new RangeError("Impossible normalization"));
                vector = Vector3.ZERO();
                let factor = _length / _vector.magnitude;
                vector.data = new Float32Array([_vector.x * factor, _vector.y * factor, _vector.z * factor]);
            }
            catch (_error) {
                FudgeCore.Debug.warn(_error);
            }
            return vector;
        }
        /**
         * Returns the resulting vector attained by addition of all given vectors.
         */
        static SUM(..._vectors) {
            let result = FudgeCore.Recycler.get(Vector3);
            for (let vector of _vectors)
                result.data = new Float32Array([result.x + vector.x, result.y + vector.y, result.z + vector.z]);
            return result;
        }
        /**
         * Returns the result of the subtraction of two vectors.
         */
        static DIFFERENCE(_minuend, _subtrahend) {
            let vector = FudgeCore.Recycler.get(Vector3);
            vector.data = new Float32Array([_minuend.x - _subtrahend.x, _minuend.y - _subtrahend.y, _minuend.z - _subtrahend.z]);
            return vector;
        }
        /**
         * Returns a new vector representing the given vector scaled by the given scaling factor
         */
        static SCALE(_vector, _scaling) {
            let scaled = FudgeCore.Recycler.get(Vector3);
            scaled.data = new Float32Array([_vector.x * _scaling, _vector.y * _scaling, _vector.z * _scaling]);
            return scaled;
        }
        /**
         * Computes the crossproduct of 2 vectors.
         */
        static CROSS(_a, _b) {
            let vector = FudgeCore.Recycler.get(Vector3);
            vector.data = new Float32Array([
                _a.y * _b.z - _a.z * _b.y,
                _a.z * _b.x - _a.x * _b.z,
                _a.x * _b.y - _a.y * _b.x
            ]);
            return vector;
        }
        /**
         * Computes the dotproduct of 2 vectors.
         */
        static DOT(_a, _b) {
            let scalarProduct = _a.x * _b.x + _a.y * _b.y + _a.z * _b.z;
            return scalarProduct;
        }
        /**
         * Calculates and returns the reflection of the incoming vector at the given normal vector. The length of normal should be 1.
         *     __________________
         *           /|\
         * incoming / | \ reflection
         *         /  |  \
         *          normal
         *
         */
        static REFLECTION(_incoming, _normal) {
            let dot = -Vector3.DOT(_incoming, _normal);
            let reflection = Vector3.SUM(_incoming, Vector3.SCALE(_normal, 2 * dot));
            return reflection;
        }
        /**
         * Divides the dividend by the divisor component by component and returns the result
         */
        static RATIO(_dividend, _divisor) {
            let vector = FudgeCore.Recycler.get(Vector3);
            vector.data = new Float32Array([_dividend.x / _divisor.x, _dividend.y / _divisor.y, _dividend.z / _divisor.z]);
            return vector;
        }
        /**
         * Returns true if the coordinates of this and the given vector are to be considered identical within the given tolerance
         * TODO: examine, if tolerance as criterium for the difference is appropriate with very large coordinate values or if _tolerance should be multiplied by coordinate value
         */
        equals(_compare, _tolerance = Number.EPSILON) {
            if (Math.abs(this.x - _compare.x) > _tolerance)
                return false;
            if (Math.abs(this.y - _compare.y) > _tolerance)
                return false;
            if (Math.abs(this.z - _compare.z) > _tolerance)
                return false;
            return true;
        }
        /**
         * Returns true if the position described by this is within a cube with the opposite corners 1 and 2
         */
        isInsideCube(_corner1, _corner2) {
            let diagonal = Vector3.DIFFERENCE(_corner2, _corner1);
            let relative = Vector3.DIFFERENCE(this, _corner1);
            let ratio = Vector3.RATIO(relative, diagonal);
            if (ratio.x > 1 || ratio.x < 0)
                return false;
            if (ratio.y > 1 || ratio.y < 0)
                return false;
            if (ratio.z > 1 || ratio.z < 0)
                return false;
            return true;
        }
        /**
         * Returns true if the position described by this is within a sphere with the given center and radius
         */
        isInsideSphere(_center, _radius) {
            let difference = Vector3.DIFFERENCE(this, _center);
            return difference.magnitudeSquared < (_radius * _radius);
        }
        /**
         * Adds the given vector to this
         */
        add(_addend) {
            this.data.set([_addend.x + this.x, _addend.y + this.y, _addend.z + this.z]);
        }
        /**
         * Subtracts the given vector from this
         */
        subtract(_subtrahend) {
            this.data.set([this.x - _subtrahend.x, this.y - _subtrahend.y, this.z - _subtrahend.z]);
        }
        /**
         * Scales this vector by the given scalar
         */
        scale(_scalar) {
            this.data.set([_scalar * this.x, _scalar * this.y, _scalar * this.z]);
        }
        /**
         * Normalizes this to the given length, 1 by default
         */
        normalize(_length = 1) {
            this.data = Vector3.NORMALIZATION(this, _length).data;
        }
        /**
         * Defines the components of this vector with the given numbers
         */
        set(_x = 0, _y = 0, _z = 0) {
            this.data = new Float32Array([_x, _y, _z]);
        }
        /**
         * Returns this vector as a new Float32Array (copy)
         */
        get() {
            return new Float32Array(this.data);
        }
        /**
         * Returns a copy of this vector
         */
        get copy() {
            let copy = FudgeCore.Recycler.get(Vector3);
            copy.data.set(this.data);
            return copy;
        }
        /**
         * Transforms this vector by the given matrix, including or exluding the translation.
         * Including is the default, excluding will only rotate and scale this vector.
         */
        transform(_matrix, _includeTranslation = true) {
            this.data = Vector3.TRANSFORMATION(this, _matrix, _includeTranslation).data;
        }
        /**
         * Drops the z-component and returns a Vector2 consisting of the x- and y-components
         */
        toVector2() {
            return new FudgeCore.Vector2(this.x, this.y);
        }
        /**
         * Reflects this vector at a given normal. See [[REFLECTION]]
         */
        reflect(_normal) {
            const reflected = Vector3.REFLECTION(this, _normal);
            this.set(reflected.x, reflected.y, reflected.z);
            FudgeCore.Recycler.store(reflected);
        }
        /**
         * Shuffles the components of this vector
         */
        shuffle() {
            let a = Array.from(this.data);
            this.set(FudgeCore.Random.default.splice(a), FudgeCore.Random.default.splice(a), a[0]);
        }
        /**
         * Returns a formatted string representation of this vector
         */
        toString() {
            let result = `(${this.x.toPrecision(5)}, ${this.y.toPrecision(5)}, ${this.z.toPrecision(5)})`;
            return result;
        }
        /**
         * Uses the standard array.map functionality to perform the given function on all components of this vector
         */
        map(_function) {
            let copy = FudgeCore.Recycler.get(Vector3);
            copy.data = this.data.map(_function);
            return copy;
        }
        getMutator() {
            let mutator = {
                x: this.data[0], y: this.data[1], z: this.data[2]
            };
            return mutator;
        }
        reduceMutator(_mutator) { }
    }
    FudgeCore.Vector3 = Vector3;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Abstract base class for all meshes.
     * Meshes provide indexed vertices, the order of indices to create trigons and normals, and texture coordinates
     *
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    let Mesh = /** @class */ (() => {
        var Mesh_1;
        let Mesh = Mesh_1 = class Mesh {
            constructor() {
                this.idResource = undefined;
            }
            static getBufferSpecification() {
                return { size: 3, dataType: WebGL2RenderingContext.FLOAT, normalize: false, stride: 0, offset: 0 };
            }
            static registerSubclass(_subClass) { return Mesh_1.subclasses.push(_subClass) - 1; }
            useRenderBuffers(_shader, _world, _projection, _id) { }
            createRenderBuffers() { }
            deleteRenderBuffers(_shader) { }
            getVertexCount() {
                return this.vertices.length / Mesh_1.getBufferSpecification().size;
            }
            getIndexCount() {
                return this.indices.length;
            }
            create() {
                this.vertices = this.createVertices();
                this.indices = this.createIndices();
                this.textureUVs = this.createTextureUVs();
                this.normalsFace = this.createFaceNormals();
                this.createRenderBuffers();
            }
            // Serialize/Deserialize for all meshes that calculate without parameters
            serialize() {
                let serialization = {
                    idResource: this.idResource
                }; // no data needed ...
                return serialization;
            }
            deserialize(_serialization) {
                this.create(); // TODO: must not be created, if an identical mesh already exists
                this.idResource = _serialization.idResource;
                return this;
            }
            // public abstract create(): void;
            calculateFaceNormals() {
                let normals = [];
                let vertices = [];
                for (let v = 0; v < this.vertices.length; v += 3)
                    vertices.push(new FudgeCore.Vector3(this.vertices[v], this.vertices[v + 1], this.vertices[v + 2]));
                for (let i = 0; i < this.indices.length; i += 3) {
                    let vertex = [this.indices[i], this.indices[i + 1], this.indices[i + 2]];
                    let v0 = FudgeCore.Vector3.DIFFERENCE(vertices[vertex[0]], vertices[vertex[1]]);
                    let v1 = FudgeCore.Vector3.DIFFERENCE(vertices[vertex[0]], vertices[vertex[2]]);
                    let normal = FudgeCore.Vector3.NORMALIZATION(FudgeCore.Vector3.CROSS(v0, v1));
                    let index = vertex[2] * 3;
                    normals[index] = normal.x;
                    normals[index + 1] = normal.y;
                    normals[index + 2] = normal.z;
                }
                return new Float32Array(normals);
            }
        };
        /** refers back to this class from any subclass e.g. in order to find compatible other resources*/
        Mesh.baseClass = Mesh_1;
        /** list of all the subclasses derived from this class, if they registered properly*/
        Mesh.subclasses = [];
        Mesh = Mesh_1 = __decorate([
            FudgeCore.RenderInjectorMesh.decorate
        ], Mesh);
        return Mesh;
    })();
    FudgeCore.Mesh = Mesh;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a simple cube with edges of length 1, each face consisting of two trigons
     * ```plaintext
     *            4____7
     *           0/__3/|
     *            ||5_||6
     *           1|/_2|/
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    let MeshCube = /** @class */ (() => {
        class MeshCube extends FudgeCore.Mesh {
            constructor() {
                super();
                this.create();
            }
            createVertices() {
                let vertices = new Float32Array([
                    // First wrap
                    // front
                    /*0*/ -1, 1, 1, /*1*/ -1, -1, 1, /*2*/ 1, -1, 1, /*3*/ 1, 1, 1,
                    // back
                    /*4*/ -1, 1, -1, /* 5*/ -1, -1, -1, /* 6*/ 1, -1, -1, /* 7*/ 1, 1, -1,
                    // Second wrap
                    // front
                    /*0*/ -1, 1, 1, /*1*/ -1, -1, 1, /*2*/ 1, -1, 1, /*3*/ 1, 1, 1,
                    // back
                    /*4*/ -1, 1, -1, /* 5*/ -1, -1, -1, /* 6*/ 1, -1, -1, /* 7*/ 1, 1, -1
                ]);
                // scale down to a length of 1 for all edges
                vertices = vertices.map(_value => _value / 2);
                return vertices;
            }
            createIndices() {
                let indices = new Uint16Array([
                    // First wrap
                    // front
                    1, 2, 0, 2, 3, 0,
                    // right
                    2, 6, 3, 6, 7, 3,
                    // back
                    6, 5, 7, 5, 4, 7,
                    // Second wrap
                    // left
                    5 + 8, 1 + 8, 4 + 8, 1 + 8, 0 + 8, 4 + 8,
                    // top
                    4 + 8, 0 + 8, 3 + 8, 7 + 8, 4 + 8, 3 + 8,
                    // bottom
                    5 + 8, 6 + 8, 1 + 8, 6 + 8, 2 + 8, 1 + 8
                    /*,
                    // left
                    4, 5, 1, 4, 1, 0,
                    // top
                    4, 0, 3, 4, 3, 7,
                    // bottom
                    1, 5, 6, 1, 6, 2
                    */
                ]);
                return indices;
            }
            createTextureUVs() {
                let textureUVs = new Float32Array([
                    // First wrap
                    // front
                    /*0*/ 0, 0, /*1*/ 0, 1, /*2*/ 1, 1, /*3*/ 1, 0,
                    // back
                    /*4*/ 3, 0, /*5*/ 3, 1, /*6*/ 2, 1, /*7*/ 2, 0,
                    // Second wrap
                    // front
                    /*0*/ 1, 0, /*1*/ 1, 1, /*2*/ 1, 2, /*3*/ 1, -1,
                    // back
                    /*4*/ 0, 0, /*5*/ 0, 1, /*6*/ 0, 2, /*7*/ 0, -1
                ]);
                return textureUVs;
            }
            createFaceNormals() {
                let normals = new Float32Array([
                    // for each triangle, the last vertex of the three defining refers to the normalvector when using flat shading
                    // First wrap
                    // front
                    /*0*/ 0, 0, 1, /*1*/ 0, 0, 0, /*2*/ 0, 0, 0, /*3*/ 1, 0, 0,
                    // back
                    /*4*/ 0, 0, 0, /*5*/ 0, 0, 0, /*6*/ 0, 0, 0, /*7*/ 0, 0, -1,
                    // Second wrap
                    // front
                    /*0*/ 0, 0, 0, /*1*/ 0, -1, 0, /*2*/ 0, 0, 0, /*3*/ 0, 1, 0,
                    // back
                    /*4*/ -1, 0, 0, /*5*/ 0, 0, 0, /*6*/ 0, 0, 0, /*7*/ 0, 0, 0
                ]);
                //normals = this.createVertices();
                return normals;
            }
        }
        MeshCube.iSubclass = FudgeCore.Mesh.registerSubclass(MeshCube);
        return MeshCube;
    })();
    FudgeCore.MeshCube = MeshCube;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generates a planar Grid and applies a Heightmap-Function to it.
     * @authors Jirka Dell'Oro-Friedl, Simon Storl-Schulke, HFU, 2020
     */
    let MeshHeightMap = /** @class */ (() => {
        class MeshHeightMap extends FudgeCore.Mesh {
            constructor(_resolutionX = 16, _resolutionZ = 16, _heightMapFunction) {
                super();
                this.resolutionX = _resolutionX;
                this.resolutionZ = _resolutionZ;
                if (_resolutionZ || _resolutionX <= 0) {
                    FudgeCore.Debug.warn("HeightMap Mesh cannot have resolution values < 1. ");
                    this.resolutionX = Math.max(1, this.resolutionX);
                    this.resolutionZ = Math.max(1, this.resolutionZ);
                }
                if (_heightMapFunction)
                    this.heightMapFunction = _heightMapFunction;
                else
                    this.heightMapFunction = function (_x, _y) { return 0; };
                this.create();
            }
            createVertices() {
                let vertices = new Float32Array((this.resolutionX + 1) * (this.resolutionZ + 1) * 3);
                //Iterate over each cell to generate grid of vertices
                for (let i = 0, z = 0; z <= this.resolutionZ; z++) {
                    for (let x = 0; x <= this.resolutionX; x++) {
                        // X
                        vertices[i] = x / this.resolutionX - 0.5;
                        // Apply heightmap to y coordinate
                        vertices[i + 1] = this.heightMapFunction(x / this.resolutionX, z / this.resolutionZ);
                        // Z
                        vertices[i + 2] = z / this.resolutionZ - 0.5;
                        i += 3;
                    }
                }
                return vertices;
            }
            createIndices() {
                let vert = 0;
                let tris = 0;
                let indices = new Uint16Array(this.resolutionX * this.resolutionZ * 6);
                for (let z = 0; z < this.resolutionZ; z++) {
                    for (let x = 0; x < this.resolutionX; x++) {
                        // First triangle of each grid-cell
                        indices[tris + 0] = vert + 0;
                        indices[tris + 1] = vert + this.resolutionX + 1;
                        indices[tris + 2] = vert + 1;
                        // Second triangle of each grid-cell
                        indices[tris + 3] = vert + 1;
                        indices[tris + 4] = vert + this.resolutionX + 1;
                        indices[tris + 5] = vert + this.resolutionX + 2;
                        vert++;
                        tris += 6;
                    }
                    vert++;
                }
                return indices;
            }
            createTextureUVs() {
                let textureUVs = new Float32Array(this.indices.length * 2);
                for (let i = 0, z = 0; z <= this.resolutionZ; z++) {
                    for (let x = 0; x <= this.resolutionX; x++) {
                        textureUVs[i] = x / this.resolutionX;
                        textureUVs[i + 1] = z / this.resolutionZ;
                        i += 2;
                    }
                }
                return textureUVs;
            }
            createFaceNormals() {
                return this.calculateFaceNormals();
            }
        }
        MeshHeightMap.iSubclass = FudgeCore.Mesh.registerSubclass(MeshHeightMap);
        return MeshHeightMap;
    })();
    FudgeCore.MeshHeightMap = MeshHeightMap;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a simple pyramid with edges at the base of length 1 and a height of 1. The sides consisting of one, the base of two trigons
     * ```plaintext
     *               4
     *              /\`.
     *            3/__\_\ 2
     *           0/____\/1
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    let MeshPyramid = /** @class */ (() => {
        class MeshPyramid extends FudgeCore.Mesh {
            constructor() {
                super();
                this.create();
            }
            createVertices() {
                let vertices = new Float32Array([
                    // floor
                    /*0*/ -1, 0, 1, /*1*/ 1, 0, 1, /*2*/ 1, 0, -1, /*3*/ -1, 0, -1,
                    // tip
                    /*4*/ 0, 2, 0,
                    // floor again for texturing and normals
                    /*5*/ -1, 0, 1, /*6*/ 1, 0, 1, /*7*/ 1, 0, -1, /*8*/ -1, 0, -1
                ]);
                // scale down to a length of 1 for bottom edges and height
                vertices = vertices.map(_value => _value / 2);
                return vertices;
            }
            createIndices() {
                let indices = new Uint16Array([
                    // front
                    4, 0, 1,
                    // right
                    4, 1, 2,
                    // back
                    4, 2, 3,
                    // left
                    4, 3, 0,
                    // bottom
                    5 + 0, 5 + 2, 5 + 1, 5 + 0, 5 + 3, 5 + 2
                ]);
                return indices;
            }
            createTextureUVs() {
                let textureUVs = new Float32Array([
                    // front
                    /*0*/ 0, 1, /*1*/ 0.5, 1, /*2*/ 1, 1, /*3*/ 0.5, 1,
                    // back
                    /*4*/ 0.5, 0,
                    /*5*/ 0, 0, /*6*/ 1, 0, /*7*/ 1, 1, /*8*/ 0, 1
                ]);
                return textureUVs;
            }
            createFaceNormals() {
                return new Float32Array(this.calculateFaceNormals());
            }
        }
        MeshPyramid.iSubclass = FudgeCore.Mesh.registerSubclass(MeshPyramid);
        return MeshPyramid;
    })();
    FudgeCore.MeshPyramid = MeshPyramid;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a simple quad with edges of length 1, the face consisting of two trigons
     * ```plaintext
     *        0 __ 3
     *         |__|
     *        1    2
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    let MeshQuad = /** @class */ (() => {
        class MeshQuad extends FudgeCore.Mesh {
            constructor() {
                super();
                this.create();
            }
            createVertices() {
                let vertices = new Float32Array([
                    /*0*/ -1, 1, 0, /*1*/ -1, -1, 0, /*2*/ 1, -1, 0, /*3*/ 1, 1, 0
                ]);
                vertices = vertices.map(_value => _value / 2);
                return vertices;
            }
            createIndices() {
                let indices = new Uint16Array([
                    1, 2, 0, 2, 3, 0
                ]);
                return indices;
            }
            createTextureUVs() {
                let textureUVs = new Float32Array([
                    // front
                    /*0*/ 0, 0, /*1*/ 0, 1, /*2*/ 1, 1, /*3*/ 1, 0
                ]);
                return textureUVs;
            }
            createFaceNormals() {
                return new Float32Array([
                    /*0*/ 0, 0, 1, /*1*/ 0, 0, 0, /*2*/ 0, 0, 0, /*3*/ 0, 0, 0
                ]);
            }
        }
        MeshQuad.iSubclass = FudgeCore.Mesh.registerSubclass(MeshQuad);
        return MeshQuad;
    })();
    FudgeCore.MeshQuad = MeshQuad;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a UV Sphere with a given number of sectors and stacks (clamped at 128*128)
     * Implementation based on http://www.songho.ca/opengl/gl_sphere.html
     * @authors Simon Storl-Schulke, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2020
     */
    let MeshSphere = /** @class */ (() => {
        class MeshSphere extends FudgeCore.Mesh {
            // Dirty Workaround to have access to the normals from createVertices()
            // private normals: Array<number> = [];
            // private textureUVs: Array<number> = [];
            // public textureUVs: Float32Array;
            constructor(_sectors = 12, _stacks = 8) {
                super();
                //Clamp resolution to prevent performance issues
                this.sectors = Math.min(_sectors, 128);
                this.stacks = Math.min(_stacks, 128);
                if (_sectors < 3 || _stacks < 2) {
                    FudgeCore.Debug.warn("UV Sphere must have at least 3 sectors and 2 stacks to form a 3-dimensional shape.");
                    this.sectors = Math.max(3, _sectors);
                    this.stacks = Math.max(2, _stacks);
                }
                this.create();
            }
            create() {
                let vertices = [];
                let normals = [];
                let textureUVs = [];
                let x;
                let z;
                let xz;
                let y;
                let sectorStep = 2 * Math.PI / this.sectors;
                let stackStep = Math.PI / this.stacks;
                let stackAngle;
                let sectorAngle;
                /* add (sectorCount+1) vertices per stack.
                the first and last vertices have same position and normal,
                but different tex coords */
                for (let i = 0; i <= this.stacks; ++i) {
                    stackAngle = Math.PI / 2 - i * stackStep;
                    xz = Math.cos(stackAngle);
                    y = Math.sin(stackAngle);
                    // add (sectorCount+1) vertices per stack
                    // the first and last vertices have same position and normal, but different tex coords
                    for (let j = 0; j <= this.sectors; ++j) {
                        sectorAngle = j * sectorStep;
                        //vertex position
                        x = xz * Math.cos(sectorAngle);
                        z = xz * Math.sin(sectorAngle);
                        vertices.push(x, y, z);
                        //normals
                        normals.push(x, y, z);
                        //UV Coords
                        textureUVs.push(j / this.sectors * -1);
                        textureUVs.push(i / this.stacks);
                    }
                }
                // scale down
                vertices = vertices.map(_value => _value / 2);
                this.textureUVs = new Float32Array(textureUVs);
                this.normals = new Float32Array(normals);
                this.vertices = new Float32Array(vertices);
                this.normalsFace = this.createFaceNormals();
                this.indices = this.createIndices();
                this.createRenderBuffers();
            }
            createIndices() {
                let inds = [];
                let k1;
                let k2;
                for (let i = 0; i < this.stacks; ++i) {
                    k1 = i * (this.sectors + 1); // beginning of current stack
                    k2 = k1 + this.sectors + 1; // beginning of next stack
                    for (let j = 0; j < this.sectors; ++j, ++k1, ++k2) {
                        // 2 triangles per sector excluding first and last stacks
                        // k1 => k2 => k1+1
                        if (i != 0) {
                            inds.push(k1);
                            inds.push(k1 + 1);
                            inds.push(k2);
                        }
                        if (i != (this.stacks - 1)) {
                            inds.push(k1 + 1);
                            inds.push(k2 + 1);
                            inds.push(k2);
                        }
                    }
                }
                let indices = new Uint16Array(inds);
                return indices;
            }
            createVertices() {
                return this.vertices;
            }
            createTextureUVs() {
                return this.textureUVs;
            }
            //TODO: we also need REAL face normals
            createFaceNormals() {
                return this.normals;
            }
        }
        MeshSphere.iSubclass = FudgeCore.Mesh.registerSubclass(MeshSphere);
        return MeshSphere;
    })();
    FudgeCore.MeshSphere = MeshSphere;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate two quads placed back to back, the one facing in negative Z-direction is textured reversed
     * ```plaintext
     *        0 __ 3
     *         |__|
     *        1    2
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2020
     */
    let MeshSprite = /** @class */ (() => {
        class MeshSprite extends FudgeCore.Mesh {
            constructor() {
                super();
                this.create();
            }
            createVertices() {
                let vertices = new Float32Array([
                    /*0*/ -1, 1, 0, /*1*/ -1, -1, 0, /*2*/ 1, -1, 0, /*3*/ 1, 1, 0
                ]);
                vertices = vertices.map(_value => _value / 2);
                return vertices;
            }
            createIndices() {
                let indices = new Uint16Array([
                    1, 2, 0, 2, 3, 0,
                    0, 3, 1, 3, 2, 1 //back
                ]);
                return indices;
            }
            createTextureUVs() {
                let textureUVs = new Float32Array([
                    // front
                    /*0*/ 0, 0, /*1*/ 0, 1, /*2*/ 1, 1, /*3*/ 1, 0
                ]);
                return textureUVs;
            }
            createFaceNormals() {
                return new Float32Array([
                    /*0: normal of front face*/
                    0, 0, 1,
                    /*1: normal of back face*/
                    0, 0, -1,
                    /*2*/
                    0, 0, 0,
                    /*3*/
                    0, 0, 0
                ]);
            }
        }
        MeshSprite.iSubclass = FudgeCore.Mesh.registerSubclass(MeshSprite);
        return MeshSprite;
    })();
    FudgeCore.MeshSprite = MeshSprite;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Represents a node in the scenetree.
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Graph
     */
    class Node extends FudgeCore.EventTarget∆í {
        /**
         * Creates a new node with a name and initializes all attributes
         * @param _name The name by which the node can be called.
         */
        constructor(_name) {
            super();
            this.mtxWorld = FudgeCore.Matrix4x4.IDENTITY();
            this.timestampUpdate = 0;
            this.parent = null; // The parent of this node.
            this.children = []; // array of child nodes appended to this node.
            this.components = {};
            // private tags: string[] = []; // Names of tags that are attached to this node. (TODO: As of yet no functionality)
            // private layers: string[] = []; // Names of the layers this node is on. (TODO: As of yet no functionality)
            this.listeners = {};
            this.captures = {};
            this.active = true;
            /**
             * Simply calls [[addChild]]. This reference is here solely because appendChild is the equivalent method in DOM.
             * See and preferably use [[addChild]]
             */
            // tslint:disable-next-line: member-ordering
            this.appendChild = this.addChild;
            this.name = _name;
        }
        activate(_on) {
            this.active = _on;
            // TODO: check if COMPONENT_ACTIVATE/DEACTIVATE is the correct event to dispatch. Shouldn't it be something like NODE_ACTIVATE/DEACTIVATE?
            this.dispatchEvent(new Event(_on ? "componentActivate" /* COMPONENT_ACTIVATE */ : "componentDeactivate" /* COMPONENT_DEACTIVATE */));
        }
        get isActive() {
            return this.active;
        }
        /**
         * Shortcut to retrieve this nodes [[ComponentTransform]]
         */
        get cmpTransform() {
            return this.getComponents(FudgeCore.ComponentTransform)[0];
        }
        /**
         * Shortcut to retrieve the local [[Matrix4x4]] attached to this nodes [[ComponentTransform]]
         * Fails if no [[ComponentTransform]] is attached
         */
        get mtxLocal() {
            return this.cmpTransform.local;
        }
        get mtxWorldInverse() {
            if (this.worldInverseUpdated != this.timestampUpdate)
                this.worldInverse = FudgeCore.Matrix4x4.INVERSION(this.mtxWorld);
            this.worldInverseUpdated = this.timestampUpdate;
            return this.worldInverse;
        }
        // #region Scenetree
        /**
         * Returns a reference to this nodes parent node
         */
        getParent() {
            return this.parent;
        }
        /**
         * Traces back the ancestors of this node and returns the first
         */
        getAncestor() {
            let ancestor = this;
            while (ancestor.getParent())
                ancestor = ancestor.getParent();
            return ancestor;
        }
        /**
         * Returns the number of children attached to this
         */
        get nChildren() {
            return this.children.length;
        }
        /**
         * Returns child at the given index in the list of children
         */
        getChild(_index) {
            return this.children[_index];
        }
        /**
         * Returns a clone of the list of children
         */
        getChildren() {
            return this.children.slice(0);
        }
        /**
         * Returns an array of references to childnodes with the supplied name.
         */
        getChildrenByName(_name) {
            let found = [];
            found = this.children.filter((_node) => _node.name == _name);
            return found;
        }
        /**
         * Adds the given reference to a node to the list of children, if not already in
         * @throws Error when trying to add an ancestor of this
         */
        addChild(_child) {
            if (this.children.includes(_child))
                // _node is already a child of this
                return;
            let inAudioGraph = false;
            let graphListened = FudgeCore.AudioManager.default.getGraphListeningTo();
            let ancestor = this;
            while (ancestor) {
                ancestor.timestampUpdate = 0;
                inAudioGraph = inAudioGraph || (ancestor == graphListened);
                if (ancestor == _child)
                    throw (new Error("Cyclic reference prohibited in node hierarchy, ancestors must not be added as children"));
                else
                    ancestor = ancestor.parent;
            }
            let previousParent = _child.parent;
            if (previousParent)
                previousParent.removeChild(_child);
            this.children.push(_child);
            _child.parent = this;
            _child.dispatchEvent(new Event("childAppend" /* CHILD_APPEND */, { bubbles: true }));
            if (inAudioGraph)
                _child.broadcastEvent(new Event("childAppendToAudioGraph" /* CHILD_APPEND */));
        }
        /**
         * Removes the reference to the give node from the list of children
         * @param _child The node to be removed.
         */
        removeChild(_child) {
            let found = this.findChild(_child);
            if (found < 0)
                return;
            _child.dispatchEvent(new Event("childRemove" /* CHILD_REMOVE */, { bubbles: true }));
            if (this.isDescendantOf(FudgeCore.AudioManager.default.getGraphListeningTo()))
                _child.broadcastEvent(new Event("childRemoveFromAudioGraph" /* CHILD_REMOVE */));
            this.children.splice(found, 1);
            _child.parent = null;
        }
        /**
         * Returns the position of the node in the list of children or -1 if not found
         * @param _search The node to be found.
         */
        findChild(_search) {
            return this.children.indexOf(_search);
        }
        /**
         * Replaces a child node with another, preserving the position in the list of children
         * @param _replace The node to be replaced
         * @param _with The node to replace with
         */
        replaceChild(_replace, _with) {
            let found = this.findChild(_replace);
            if (found < 0)
                return false;
            let previousParent = _with.getParent();
            if (previousParent)
                previousParent.removeChild(_with);
            _replace.parent = null;
            this.children[found] = _with;
            _with.parent = this;
            _with.dispatchEvent(new Event("childAppend" /* CHILD_APPEND */, { bubbles: true }));
            if (this.isDescendantOf(FudgeCore.AudioManager.default.getGraphListeningTo()))
                _with.broadcastEvent(new Event("childAppendToAudioGraph" /* CHILD_APPEND */));
            return true;
        }
        /**
         * Generator yielding the node and all decendants in the graph below for iteration
         */
        get graph() {
            return this.getGraphGenerator();
        }
        isUpdated(_timestampUpdate) {
            return (this.timestampUpdate == _timestampUpdate);
        }
        isDescendantOf(_ancestor) {
            let node = this;
            while (node && node != _ancestor)
                node = node.parent;
            return (node != null);
        }
        /**
         * Applies a Mutator from [[Animation]] to all its components and transfers it to its children.
         * @param _mutator The mutator generated from an [[Animation]]
         */
        applyAnimation(_mutator) {
            if (_mutator.components) {
                for (let componentName in _mutator.components) {
                    if (this.components[componentName]) {
                        let mutatorOfComponent = _mutator.components;
                        for (let i in mutatorOfComponent[componentName]) {
                            if (this.components[componentName][+i]) {
                                let componentToMutate = this.components[componentName][+i];
                                let mutatorArray = mutatorOfComponent[componentName];
                                let mutatorWithComponentName = mutatorArray[+i];
                                for (let cname in mutatorWithComponentName) { // trick used to get the only entry in the list
                                    let mutatorToGive = mutatorWithComponentName[cname];
                                    componentToMutate.mutate(mutatorToGive);
                                }
                            }
                        }
                    }
                }
            }
            if (_mutator.children) {
                for (let i = 0; i < _mutator.children.length; i++) {
                    let name = _mutator.children[i]["∆í.Node"].name;
                    let childNodes = this.getChildrenByName(name);
                    for (let childNode of childNodes) {
                        childNode.applyAnimation(_mutator.children[i]["∆í.Node"]);
                    }
                }
            }
        }
        // #endregion
        // #region Components
        /**
         * Returns a list of all components attached to this node, independent of type.
         */
        getAllComponents() {
            let all = [];
            for (let type in this.components) {
                all = all.concat(this.components[type]);
            }
            return all;
        }
        /**
         * Returns a clone of the list of components of the given class attached to this node.
         * @param _class The class of the components to be found.
         */
        getComponents(_class) {
            return (this.components[_class.name] || []).slice(0);
        }
        /**
         * Returns the first compontent found of the given class attached this node or null, if list is empty or doesn't exist
         * @param _class The class of the components to be found.
         */
        getComponent(_class) {
            let list = this.components[_class.name];
            if (list)
                return list[0];
            return null;
        }
        /**
         * Adds the supplied component into the nodes component map.
         * @param _component The component to be pushed into the array.
         */
        addComponent(_component) {
            if (_component.getContainer() == this)
                return;
            let cmpList = this.components[_component.type];
            if (cmpList === undefined)
                this.components[_component.type] = [_component];
            else if (cmpList.length && _component.isSingleton)
                throw new Error("Component is marked singleton and can't be attached, no more than one allowed");
            else
                cmpList.push(_component);
            _component.setContainer(this);
            _component.dispatchEvent(new Event("componentAdd" /* COMPONENT_ADD */));
        }
        /**
         * Removes the given component from the node, if it was attached, and sets its parent to null.
         * @param _component The component to be removed
         * @throws Exception when component is not found
         */
        removeComponent(_component) {
            try {
                let componentsOfType = this.components[_component.type];
                let foundAt = componentsOfType.indexOf(_component);
                if (foundAt < 0)
                    return;
                _component.dispatchEvent(new Event("componentRemove" /* COMPONENT_REMOVE */));
                componentsOfType.splice(foundAt, 1);
                _component.setContainer(null);
            }
            catch (_error) {
                throw new Error(`Unable to remove component '${_component}'in node named '${this.name}'`);
            }
        }
        // #endregion
        // #region Serialization
        serialize() {
            let serialization = {
                name: this.name
            };
            let components = {};
            for (let type in this.components) {
                components[type] = [];
                for (let component of this.components[type]) {
                    // components[type].push(component.serialize());
                    components[type].push(FudgeCore.Serializer.serialize(component));
                }
            }
            serialization["components"] = components;
            let children = [];
            for (let child of this.children) {
                children.push(FudgeCore.Serializer.serialize(child));
            }
            serialization["children"] = children;
            this.dispatchEvent(new Event("nodeSerialized" /* NODE_SERIALIZED */));
            return serialization;
        }
        deserialize(_serialization) {
            this.name = _serialization.name;
            // this.parent = is set when the nodes are added
            // deserialize components first so scripts can react to children being appended
            for (let type in _serialization.components) {
                for (let serializedComponent of _serialization.components[type]) {
                    let deserializedComponent = FudgeCore.Serializer.deserialize(serializedComponent);
                    this.addComponent(deserializedComponent);
                }
            }
            for (let serializedChild of _serialization.children) {
                let deserializedChild = FudgeCore.Serializer.deserialize(serializedChild);
                this.appendChild(deserializedChild);
            }
            this.dispatchEvent(new Event("nodeDeserialized" /* NODE_DESERIALIZED */));
            return this;
        }
        // #endregion
        // #region Events
        /**
         * Adds an event listener to the node. The given handler will be called when a matching event is passed to the node.
         * Deviating from the standard EventTarget, here the _handler must be a function and _capture is the only option.
         * @param _type The type of the event, should be an enumerated value of NODE_EVENT, can be any string
         * @param _handler The function to call when the event reaches this node
         * @param _capture When true, the listener listens in the capture phase, when the event travels deeper into the hierarchy of nodes.
         */
        addEventListener(_type, _handler, _capture = false) {
            let listListeners = _capture ? this.captures : this.listeners;
            if (!listListeners[_type])
                listListeners[_type] = [];
            listListeners[_type].push(_handler);
        }
        /**
         * Removes an event listener from the node. The signatur must match the one used with addEventListener
         * @param _type The type of the event, should be an enumerated value of NODE_EVENT, can be any string
         * @param _handler The function to call when the event reaches this node
         * @param _capture When true, the listener listens in the capture phase, when the event travels deeper into the hierarchy of nodes.
         */
        removeEventListener(_type, _handler, _capture = false) {
            let listenersForType = _capture ? this.captures[_type] : this.listeners[_type];
            if (listenersForType)
                for (let i = listenersForType.length - 1; i >= 0; i--)
                    if (listenersForType[i] == _handler)
                        listenersForType.splice(i, 1);
        }
        /**
         * Dispatches a synthetic event to target. This implementation always returns true (standard: return true only if either event's cancelable attribute value is false or its preventDefault() method was not invoked)
         * The event travels into the hierarchy to this node dispatching the event, invoking matching handlers of the nodes ancestors listening to the capture phase,
         * than the matching handler of the target node in the target phase, and back out of the hierarchy in the bubbling phase, invoking appropriate handlers of the anvestors
         * @param _event The event to dispatch
         */
        dispatchEvent(_event) {
            let ancestors = [];
            let upcoming = this;
            // overwrite event target
            Object.defineProperty(_event, "target", { writable: true, value: this });
            // TODO: consider using Reflect instead of Object throughout. See also Render and Mutable...
            while (upcoming.parent)
                ancestors.push(upcoming = upcoming.parent);
            // capture phase
            Object.defineProperty(_event, "eventPhase", { writable: true, value: Event.CAPTURING_PHASE });
            for (let i = ancestors.length - 1; i >= 0; i--) {
                let ancestor = ancestors[i];
                Object.defineProperty(_event, "currentTarget", { writable: true, value: ancestor });
                let captures = ancestor.captures[_event.type] || [];
                for (let handler of captures)
                    handler(_event);
            }
            if (!_event.bubbles)
                return true;
            // target phase
            Object.defineProperty(_event, "eventPhase", { writable: true, value: Event.AT_TARGET });
            Object.defineProperty(_event, "currentTarget", { writable: true, value: this });
            let listeners = this.listeners[_event.type] || [];
            for (let handler of listeners)
                handler(_event);
            // bubble phase
            Object.defineProperty(_event, "eventPhase", { writable: true, value: Event.BUBBLING_PHASE });
            for (let i = 0; i < ancestors.length; i++) {
                let ancestor = ancestors[i];
                Object.defineProperty(_event, "currentTarget", { writable: true, value: ancestor });
                let listeners = ancestor.listeners[_event.type] || [];
                for (let handler of listeners)
                    handler(_event);
            }
            return true; //TODO: return a meaningful value, see documentation of dispatch event
        }
        /**
         * Broadcasts a synthetic event to this node and from there to all nodes deeper in the hierarchy,
         * invoking matching handlers of the nodes listening to the capture phase. Watch performance when there are many nodes involved
         * @param _event The event to broadcast
         */
        broadcastEvent(_event) {
            // overwrite event target and phase
            Object.defineProperty(_event, "eventPhase", { writable: true, value: Event.CAPTURING_PHASE });
            Object.defineProperty(_event, "target", { writable: true, value: this });
            this.broadcastEventRecursive(_event);
        }
        broadcastEventRecursive(_event) {
            // capture phase only
            Object.defineProperty(_event, "currentTarget", { writable: true, value: this });
            let captures = this.captures[_event.type] || [];
            for (let handler of captures)
                handler(_event);
            // appears to be slower, astonishingly...
            // captures.forEach(function (handler: Function): void {
            //     handler(_event);
            // });
            // same for children
            for (let child of this.children) {
                child.broadcastEventRecursive(_event);
            }
        }
        // #endregion
        *getGraphGenerator() {
            yield this;
            for (let child of this.children)
                yield* child.graph;
        }
    }
    FudgeCore.Node = Node;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A node managed by [[ResourceManager]] that functions as a template for [[NodeResourceInstance]]s
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Resource
     */
    class NodeResource extends FudgeCore.Node {
        constructor() {
            super(...arguments);
            this.idResource = undefined;
        }
    }
    FudgeCore.NodeResource = NodeResource;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * An instance of a [[NodeResource]].
     * This node keeps a reference to its resource an can thus optimize serialization
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Resource
     */
    class NodeResourceInstance extends FudgeCore.Node {
        constructor(_nodeResource) {
            super("NodeResourceInstance");
            /** id of the resource that instance was created from */
            // TODO: examine, if this should be a direct reference to the NodeResource, instead of the id
            this.idSource = undefined;
            if (_nodeResource)
                this.set(_nodeResource);
        }
        /**
         * Recreate this node from the [[NodeResource]] referenced
         */
        reset() {
            let resource = FudgeCore.ResourceManager.get(this.idSource);
            this.set(resource);
        }
        //TODO: optimize using the referenced NodeResource, serialize/deserialize only the differences
        serialize() {
            let serialization = super.serialize();
            serialization.idSource = this.idSource;
            return serialization;
        }
        deserialize(_serialization) {
            super.deserialize(_serialization);
            this.idSource = _serialization.idSource;
            return this;
        }
        /**
         * Set this node to be a recreation of the [[NodeResource]] given
         * @param _nodeResource
         */
        set(_nodeResource) {
            // TODO: examine, if the serialization should be stored in the NodeResource for optimization
            let serialization = FudgeCore.Serializer.serialize(_nodeResource);
            //Serializer.deserialize(serialization);
            for (let path in serialization) {
                this.deserialize(serialization[path]);
                break;
            }
            this.idSource = _nodeResource.idResource;
            this.dispatchEvent(new Event("nodeResourceInstantiated" /* NODERESOURCE_INSTANTIATED */));
        }
    }
    FudgeCore.NodeResourceInstance = NodeResourceInstance;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class Ray {
        constructor(_direction = FudgeCore.Vector3.Z(-1), _origin = FudgeCore.Vector3.ZERO(), _length = 1) {
            this.origin = _origin;
            this.direction = _direction;
            this.length = _length;
        }
        /**
         * Returns the point of intersection of this ray with a plane defined by
         * the given point of origin and the planes normal. All values and calculations
         * must be relative to the same coordinate system, preferably the world
         */
        intersectPlane(_origin, _normal) {
            let difference = FudgeCore.Vector3.DIFFERENCE(_origin, this.origin);
            let factor = FudgeCore.Vector3.DOT(difference, _normal) / FudgeCore.Vector3.DOT(this.direction, _normal);
            let intersect = FudgeCore.Vector3.SUM(this.origin, FudgeCore.Vector3.SCALE(this.direction, factor));
            return intersect;
        }
        getDistance(_target) {
            let originToTarget = FudgeCore.Vector3.DIFFERENCE(_target, this.origin);
            let raySection = FudgeCore.Vector3.NORMALIZATION(this.direction, 1);
            let projectedLength = FudgeCore.Vector3.DOT(originToTarget, raySection);
            raySection.scale(projectedLength);
            raySection.add(this.origin);
            let distance = FudgeCore.Vector3.DIFFERENCE(_target, raySection);
            return distance;
        }
    }
    FudgeCore.Ray = Ray;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class RayHit {
        constructor(_node = null, _face = 0, _zBuffer = 0) {
            this.node = _node;
            this.face = _face;
            this.zBuffer = _zBuffer;
        }
    }
    FudgeCore.RayHit = RayHit;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * The main interface to the render engine, here WebGL, which is used mainly in the superclass [[RenderOperator]]
     */
    let RenderManager = /** @class */ (() => {
        class RenderManager extends FudgeCore.RenderOperator {
            /**
             * Clear the offscreen renderbuffer with the given [[Color]]
             */
            static clear(_color = null) {
                RenderManager.crc3.clearColor(_color.r, _color.g, _color.b, _color.a);
                RenderManager.crc3.clear(WebGL2RenderingContext.COLOR_BUFFER_BIT | WebGL2RenderingContext.DEPTH_BUFFER_BIT);
            }
            /**
             * Reset the offscreen framebuffer to the original RenderingContext
             */
            static resetFrameBuffer(_color = null) {
                RenderManager.crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, null);
            }
            //#region RayCast & Picking
            /**
             * Draws the graph for RayCasting starting with the given [[Node]] using the camera given [[ComponentCamera]].
             */
            static drawGraphForRayCast(_node, _cmpCamera) {
                RenderManager.pickBuffers = [];
                //TODO: examine, why switching blendFunction is necessary 
                FudgeCore.RenderOperator.crc3.blendFunc(1, 0);
                RenderManager.drawGraph(_node, _cmpCamera, RenderManager.drawNodeForRayCast);
                FudgeCore.RenderOperator.crc3.blendFunc(WebGL2RenderingContext.DST_ALPHA, WebGL2RenderingContext.ONE_MINUS_DST_ALPHA);
                RenderManager.resetFrameBuffer();
                return RenderManager.pickBuffers;
            }
            /**
             * Browses through the buffers (previously created with [[drawGraphForRayCast]]) of the size given
             * and returns an unsorted list of the values at the given position, representing node-ids and depth information as [[RayHit]]s
             */
            static pickNodeAt(_pos, _pickBuffers, _rect) {
                let hits = [];
                for (let pickBuffer of _pickBuffers) {
                    RenderManager.crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, pickBuffer.frameBuffer);
                    // TODO: instead of reading all data and afterwards pick the pixel, read only the pixel!
                    let data = new Uint8Array(_rect.width * _rect.height * 4);
                    RenderManager.crc3.readPixels(0, 0, _rect.width, _rect.height, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.UNSIGNED_BYTE, data);
                    let pixel = _pos.x + _rect.width * _pos.y;
                    // let zBuffer: number = data[4 * pixel + 1] + data[4 * pixel + 2] / 256;
                    let zBuffer = data[4 * pixel + 0];
                    let hit = new FudgeCore.RayHit(pickBuffer.node, 0, zBuffer);
                    hits.push(hit);
                }
                return hits;
            }
            //#endregion
            //#region Drawing
            /**
             * The main rendering function to be called from [[Viewport]].
             * Draws the graph starting with the given [[Node]] using the camera given [[ComponentCamera]].
             */
            static drawGraph(_node, _cmpCamera, _drawNode = RenderManager.drawNode) {
                let matrix = FudgeCore.Matrix4x4.IDENTITY();
                if (_node.getParent())
                    matrix = _node.getParent().mtxWorld;
                RenderManager.setupTransformAndLights(_node, matrix);
                RenderManager.drawGraphRecursive(_node, _cmpCamera, _drawNode);
            }
            /**
             * Recursivly iterates over the graph and renders each node and all successors with the given render function
             */
            static drawGraphRecursive(_node, _cmpCamera, _drawNode = RenderManager.drawNode) {
                // TODO: see if third parameter _world?: Matrix4x4 would be usefull
                if (!_node.isActive)
                    return;
                let finalTransform;
                let cmpMesh = _node.getComponent(FudgeCore.ComponentMesh);
                if (cmpMesh) // TODO: careful when using particlesystem, pivot must not change node position
                    finalTransform = FudgeCore.Matrix4x4.MULTIPLICATION(_node.mtxWorld, cmpMesh.pivot);
                else
                    finalTransform = _node.mtxWorld; // caution, RenderManager is a reference...
                // multiply camera matrix
                let projection = FudgeCore.Matrix4x4.MULTIPLICATION(_cmpCamera.ViewProjectionMatrix, finalTransform);
                // TODO: create drawNode method for particle system using _node.mtxWorld instead of finalTransform
                _drawNode(_node, finalTransform, projection);
                // RenderParticles.drawParticles();
                for (let name in _node.getChildren()) {
                    let childNode = _node.getChildren()[name];
                    RenderManager.drawGraphRecursive(childNode, _cmpCamera, _drawNode); //, world);
                }
                FudgeCore.Recycler.store(projection);
                if (finalTransform != _node.mtxWorld)
                    FudgeCore.Recycler.store(finalTransform);
            }
            /**
             * The standard render function for drawing a single node
             */
            static drawNode(_node, _finalTransform, _projection, _lights) {
                try {
                    let cmpMaterial = _node.getComponent(FudgeCore.ComponentMaterial);
                    let mesh = _node.getComponent(FudgeCore.ComponentMesh).mesh;
                    // RenderManager.setLightsInShader(shader, _lights);
                    RenderManager.draw(mesh, cmpMaterial, _finalTransform, _projection); //, _lights);
                }
                catch (_error) {
                    // Debug.error(_error);
                }
            }
            //#endregion
            //#region Picking
            /**
             * The render function for drawing buffers for picking. Renders each node on a dedicated buffer with id and depth values instead of colors
             */
            static drawNodeForRayCast(_node, _finalTransform, _projection, _lights) {
                // TODO: look into SSBOs!
                let target = RenderManager.getRayCastTexture();
                const framebuffer = RenderManager.crc3.createFramebuffer();
                // render to our targetTexture by binding the framebuffer
                RenderManager.crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, framebuffer);
                // attach the texture as the first color attachment
                const attachmentPoint = WebGL2RenderingContext.COLOR_ATTACHMENT0;
                RenderManager.crc3.framebufferTexture2D(WebGL2RenderingContext.FRAMEBUFFER, attachmentPoint, WebGL2RenderingContext.TEXTURE_2D, target, 0);
                try {
                    let mesh = _node.getComponent(FudgeCore.ComponentMesh).mesh;
                    FudgeCore.ShaderRayCast.useProgram();
                    let pickBuffer = { node: _node, texture: target, frameBuffer: framebuffer };
                    RenderManager.pickBuffers.push(pickBuffer);
                    mesh.useRenderBuffers(FudgeCore.ShaderRayCast, _finalTransform, _projection, RenderManager.pickBuffers.length);
                    FudgeCore.RenderOperator.crc3.drawElements(WebGL2RenderingContext.TRIANGLES, mesh.renderBuffers.nIndices, WebGL2RenderingContext.UNSIGNED_SHORT, 0);
                }
                catch (_error) {
                    //
                }
                // make texture available to onscreen-display
            }
            /**
             * Creates a texture buffer to be uses as pick-buffer
             */
            static getRayCastTexture() {
                // create to render to
                const targetTextureWidth = RenderManager.getViewportRectangle().width;
                const targetTextureHeight = RenderManager.getViewportRectangle().height;
                const targetTexture = RenderManager.crc3.createTexture();
                RenderManager.crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, targetTexture);
                {
                    const internalFormat = WebGL2RenderingContext.RGBA8;
                    const format = WebGL2RenderingContext.RGBA;
                    const type = WebGL2RenderingContext.UNSIGNED_BYTE;
                    RenderManager.crc3.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, internalFormat, targetTextureWidth, targetTextureHeight, 0, format, type, null);
                    // set the filtering so we don't need mips
                    RenderManager.crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.LINEAR);
                    RenderManager.crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_S, WebGL2RenderingContext.CLAMP_TO_EDGE);
                    RenderManager.crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_T, WebGL2RenderingContext.CLAMP_TO_EDGE);
                }
                return targetTexture;
            }
            //#endregion
            //#region Transformation & Lights
            /**
             * Recursively iterates over the graph starting with the node given, recalculates all world transforms,
             * collects all lights and feeds all shaders used in the graph with these lights
             */
            static setupTransformAndLights(_node, _world = FudgeCore.Matrix4x4.IDENTITY(), _lights = new Map(), _shadersUsed = null) {
                RenderManager.timestampUpdate = performance.now();
                let firstLevel = (_shadersUsed == null);
                if (firstLevel)
                    _shadersUsed = [];
                let world = _world;
                let cmpTransform = _node.cmpTransform;
                if (cmpTransform)
                    world = FudgeCore.Matrix4x4.MULTIPLICATION(_world, cmpTransform.local);
                _node.mtxWorld.set(world); // overwrite readonly mtxWorld of node
                _node.timestampUpdate = RenderManager.timestampUpdate;
                let cmpLights = _node.getComponents(FudgeCore.ComponentLight);
                for (let cmpLight of cmpLights) {
                    let type = cmpLight.light.getType();
                    let lightsOfType = _lights.get(type);
                    if (!lightsOfType) {
                        lightsOfType = [];
                        _lights.set(type, lightsOfType);
                    }
                    lightsOfType.push(cmpLight);
                }
                let cmpMaterial = _node.getComponent(FudgeCore.ComponentMaterial);
                if (cmpMaterial) {
                    let shader = cmpMaterial.material.getShader();
                    if (_shadersUsed.indexOf(shader) < 0)
                        _shadersUsed.push(shader);
                }
                for (let child of _node.getChildren()) {
                    RenderManager.setupTransformAndLights(child, world, _lights, _shadersUsed);
                }
                if (firstLevel)
                    for (let shader of _shadersUsed)
                        RenderManager.setLightsInShader(shader, _lights);
            }
            /**
             * Set light data in shaders
             */
            static setLightsInShader(_shader, _lights) {
                _shader.useProgram();
                let uni = _shader.uniforms;
                // Ambient
                let ambient = uni["u_ambient.color"];
                if (ambient) {
                    let cmpLights = _lights.get(FudgeCore.LightAmbient);
                    if (cmpLights) {
                        // TODO: add up ambient lights to a single color
                        let result = new FudgeCore.Color(0, 0, 0, 1);
                        for (let cmpLight of cmpLights)
                            result.add(cmpLight.light.color);
                        FudgeCore.RenderOperator.crc3.uniform4fv(ambient, result.getArray());
                    }
                }
                // Directional
                let nDirectional = uni["u_nLightsDirectional"];
                if (nDirectional) {
                    let cmpLights = _lights.get(FudgeCore.LightDirectional);
                    if (cmpLights) {
                        let n = cmpLights.length;
                        FudgeCore.RenderOperator.crc3.uniform1ui(nDirectional, n);
                        for (let i = 0; i < n; i++) {
                            let cmpLight = cmpLights[i];
                            FudgeCore.RenderOperator.crc3.uniform4fv(uni[`u_directional[${i}].color`], cmpLight.light.color.getArray());
                            let direction = FudgeCore.Vector3.Z();
                            direction.transform(cmpLight.pivot, false);
                            direction.transform(cmpLight.getContainer().mtxWorld);
                            FudgeCore.RenderOperator.crc3.uniform3fv(uni[`u_directional[${i}].direction`], direction.get());
                        }
                    }
                }
            }
        }
        RenderManager.rectClip = new FudgeCore.Rectangle(-1, 1, 2, -2);
        return RenderManager;
    })();
    FudgeCore.RenderManager = RenderManager;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class RenderParticles extends FudgeCore.RenderManager {
        static drawParticles() {
            // console.log(RenderParticles.crc3);
        }
    }
    FudgeCore.RenderParticles = RenderParticles;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="../Coat/Coat.ts"/>
var FudgeCore;
// / <reference path="../Coat/Coat.ts"/>
(function (FudgeCore) {
    /**
     * Static superclass for the representation of WebGl shaderprograms.
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    // TODO: define attribute/uniforms as layout and use those consistently in shaders
    let Shader = /** @class */ (() => {
        var Shader_1;
        let Shader = Shader_1 = class Shader {
            /** The type of coat that can be used with this shader to create a material */
            static getCoat() { return null; }
            static getVertexShaderSource() { return null; }
            static getFragmentShaderSource() { return null; }
            static deleteProgram() { }
            static useProgram() { }
            static createProgram() { }
            static registerSubclass(_subclass) { return Shader_1.subclasses.push(_subclass) - 1; }
        };
        /** refers back to this class from any subclass e.g. in order to find compatible other resources*/
        Shader.baseClass = Shader_1;
        /** list of all the subclasses derived from this class, if they registered properly*/
        Shader.subclasses = [];
        Shader = Shader_1 = __decorate([
            FudgeCore.RenderInjectorShader.decorate
        ], Shader);
        return Shader;
    })();
    FudgeCore.Shader = Shader;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Single color shading
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    let ShaderFlat = /** @class */ (() => {
        var ShaderFlat_1;
        let ShaderFlat = ShaderFlat_1 = class ShaderFlat extends FudgeCore.Shader {
            static getCoat() {
                return FudgeCore.CoatColored;
            }
            static getVertexShaderSource() {
                return `#version 300 es

                    struct LightAmbient {
                        vec4 color;
                    };
                    struct LightDirectional {
                        vec4 color;
                        vec3 direction;
                    };

                    const uint MAX_LIGHTS_DIRECTIONAL = 10u;

                    in vec3 a_position;
                    in vec3 a_normal;
                    uniform mat4 u_world;
                    uniform mat4 u_projection;

                    uniform LightAmbient u_ambient;
                    uniform uint u_nLightsDirectional;
                    uniform LightDirectional u_directional[MAX_LIGHTS_DIRECTIONAL];
                    flat out vec4 v_color;
                    
                    void main() {   
                        gl_Position = u_projection * vec4(a_position, 1.0);
                        vec3 normal = normalize(mat3(u_world) * a_normal);

                        v_color = u_ambient.color;
                        for (uint i = 0u; i < u_nLightsDirectional; i++) {
                            float illumination = -dot(normal, u_directional[i].direction);
                            if (illumination > 0.0f)
                                v_color += illumination * u_directional[i].color; // vec4(1,1,1,1); // 
                        }
                        v_color.a = 1.0;
                    }`;
            }
            static getFragmentShaderSource() {
                return `#version 300 es
                    precision mediump float;

                    uniform vec4 u_color;
                    flat in vec4 v_color;
                    out vec4 frag;
                    
                    void main() {
                        frag = u_color * v_color;
                    }`;
            }
        };
        ShaderFlat.iSubclass = FudgeCore.Shader.registerSubclass(ShaderFlat_1);
        ShaderFlat = ShaderFlat_1 = __decorate([
            FudgeCore.RenderInjectorShader.decorate
        ], ShaderFlat);
        return ShaderFlat;
    })();
    FudgeCore.ShaderFlat = ShaderFlat;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Matcap (Material Capture) shading. The texture provided by the coat is used as a matcap material.
     * Implementation based on https://www.clicktorelease.com/blog/creating-spherical-environment-mapping-shader/
     * @authors Simon Storl-Schulke, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    let ShaderMatCap = /** @class */ (() => {
        class ShaderMatCap extends FudgeCore.Shader {
            static getCoat() {
                return FudgeCore.CoatMatCap;
            }
            static getVertexShaderSource() {
                return `#version 300 es

                    in vec3 a_position;
                    in vec3 a_normal;

                    uniform mat4 u_projection;

                    out vec2 texcoords_smooth;
                    flat out vec2 texcoords_flat;

                    void main() {
                        texcoords_smooth = normalize(mat3(u_projection) * a_normal).xy * 0.5 - 0.5;
                        texcoords_flat = texcoords_smooth;
                        gl_Position = u_projection * vec4(a_position, 1.0);
                    }`;
            }
            static getFragmentShaderSource() {
                return `#version 300 es
                    precision mediump float;
                    
                    uniform vec4 u_tint_color;
                    uniform int shade_smooth;
                    uniform sampler2D u_texture;
                    
                    in vec2 texcoords_smooth;
                    flat in vec2 texcoords_flat;

                    out vec4 frag;

                    void main() {

                        if (shade_smooth > 0) {
                          frag = u_tint_color * texture(u_texture, texcoords_smooth) * 2.0;
                        } else {
                          frag = u_tint_color * texture(u_texture, texcoords_flat) * 2.0;
                        }
                    }`;
            }
        }
        ShaderMatCap.iSubclass = FudgeCore.Shader.registerSubclass(ShaderMatCap);
        return ShaderMatCap;
    })();
    FudgeCore.ShaderMatCap = ShaderMatCap;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Renders for Raycasting
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ShaderRayCast extends FudgeCore.Shader {
        static getVertexShaderSource() {
            return `#version 300 es

                    in vec3 a_position;
                    uniform mat4 u_projection;
                    
                    void main() {   
                        gl_Position = u_projection * vec4(a_position, 1.0);
                    }`;
        }
        static getFragmentShaderSource() {
            return `#version 300 es
                    precision mediump float;
                    precision highp int;
                    
                    uniform int u_id;
                    out vec4 frag;
                    
                    void main() {
                       float id = float(u_id)/ 256.0;
                       float upperbyte = trunc(gl_FragCoord.z * 256.0) / 256.0;
                       float lowerbyte = fract(gl_FragCoord.z * 256.0);
                       frag = vec4(gl_FragCoord.z, upperbyte, lowerbyte, 1.0);
                    }`;
        }
    }
    FudgeCore.ShaderRayCast = ShaderRayCast;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Textured shading
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    let ShaderTexture = /** @class */ (() => {
        class ShaderTexture extends FudgeCore.Shader {
            static getCoat() {
                return FudgeCore.CoatTextured;
            }
            static getVertexShaderSource() {
                return `#version 300 es

                in vec3 a_position;
                in vec2 a_textureUVs;
                uniform mat4 u_projection;
                uniform mat3 u_pivot;
                out vec2 v_textureUVs;

                void main() {  
                    gl_Position = u_projection * vec4(a_position, 1.0);
                    // v_textureUVs = a_textureUVs;
                    v_textureUVs = vec2(u_pivot * vec3(a_textureUVs, 1.0)).xy;
                }`;
            }
            static getFragmentShaderSource() {
                return `#version 300 es
                precision mediump float;
                
                in vec2 v_textureUVs;
                uniform vec4 u_color;
                uniform sampler2D u_texture;
                // uniform vec4 u_colorBackground; // maybe a material background color can shine through... but where and with which intensity?
                out vec4 frag;
                
                void main() {
                    vec4 colorTexture = texture(u_texture, v_textureUVs);
                    frag = u_color * colorTexture;
                    //frag = vec4(colorTexture.r * 1.0, colorTexture.g * 0.4, colorTexture.b * 0.1, colorTexture.a * 1.5);//u_color;
                    //frag = colorTexture;
                    if (frag.a < 0.01)
                      discard;
            }`;
            }
        }
        ShaderTexture.iSubclass = FudgeCore.Shader.registerSubclass(ShaderTexture);
        return ShaderTexture;
    })();
    FudgeCore.ShaderTexture = ShaderTexture;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Single color shading
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    let ShaderUniColor = /** @class */ (() => {
        class ShaderUniColor extends FudgeCore.Shader {
            static getCoat() {
                return FudgeCore.CoatColored;
            }
            static getVertexShaderSource() {
                return `#version 300 es

                    in vec3 a_position;
                    uniform mat4 u_projection;
                    
                    void main() {   
                        gl_Position = u_projection * vec4(a_position, 1.0);
                    }`;
            }
            static getFragmentShaderSource() {
                return `#version 300 es
                    precision mediump float;
                    
                    uniform vec4 u_color;
                    out vec4 frag;
                    
                    void main() {
                       frag = u_color;
                    }`;
            }
        }
        ShaderUniColor.iSubclass = FudgeCore.Shader.registerSubclass(ShaderUniColor);
        return ShaderUniColor;
    })();
    FudgeCore.ShaderUniColor = ShaderUniColor;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Baseclass for different kinds of textures.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Texture extends FudgeCore.Mutable {
        reduceMutator() { }
    }
    FudgeCore.Texture = Texture;
    /**
     * Texture created from an existing image
     */
    class TextureImage extends Texture {
        constructor() {
            super(...arguments);
            this.image = null;
        }
    }
    FudgeCore.TextureImage = TextureImage;
    /**
     * Texture created from a canvas
     */
    class TextureCanvas extends Texture {
    }
    FudgeCore.TextureCanvas = TextureCanvas;
    /**
     * Texture created from a FUDGE-Sketch
     */
    class TextureSketch extends TextureCanvas {
    }
    FudgeCore.TextureSketch = TextureSketch;
    /**
     * Texture created from an HTML-page
     */
    class TextureHTML extends TextureCanvas {
    }
    FudgeCore.TextureHTML = TextureHTML;
})(FudgeCore || (FudgeCore = {}));
// /<reference path="../Event/Event.ts"/>
// /<reference path="../Time/Time.ts"/>
var FudgeCore;
// /<reference path="../Event/Event.ts"/>
// /<reference path="../Time/Time.ts"/>
(function (FudgeCore) {
    /**
     * Determines the mode a loop runs in
     */
    let LOOP_MODE;
    (function (LOOP_MODE) {
        /** Loop cycles controlled by window.requestAnimationFrame */
        LOOP_MODE["FRAME_REQUEST"] = "frameRequest";
        /** Loop cycles with the given framerate in [[Time]].game */
        LOOP_MODE["TIME_GAME"] = "timeGame";
        /** Loop cycles with the given framerate in realtime, independent of [[Time]].game */
        LOOP_MODE["TIME_REAL"] = "timeReal";
    })(LOOP_MODE = FudgeCore.LOOP_MODE || (FudgeCore.LOOP_MODE = {}));
    /**
     * Core loop of a Fudge application. Initializes automatically and must be started explicitly.
     * It then fires [[EVENT]].LOOP\_FRAME to all added listeners at each frame
     *
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     */
    let Loop = /** @class */ (() => {
        class Loop extends FudgeCore.EventTargetStatic {
            /**
             * Starts the loop with the given mode and fps
             * @param _mode
             * @param _fps Is only applicable in TIME-modes
             * @param _syncWithAnimationFrame Experimental and only applicable in TIME-modes. Should defer the loop-cycle until the next possible animation frame.
             */
            static start(_mode = LOOP_MODE.FRAME_REQUEST, _fps = 60, _syncWithAnimationFrame = false) {
                Loop.stop();
                Loop.timeStartGame = FudgeCore.Time.game.get();
                Loop.timeStartReal = performance.now();
                Loop.timeLastFrameGame = Loop.timeStartGame;
                Loop.timeLastFrameReal = Loop.timeStartReal;
                Loop.fpsDesired = (_mode == LOOP_MODE.FRAME_REQUEST) ? 60 : _fps;
                Loop.framesToAverage = Loop.fpsDesired;
                Loop.timeLastFrameGameAvg = Loop.timeLastFrameRealAvg = 1000 / Loop.fpsDesired;
                Loop.mode = _mode;
                Loop.syncWithAnimationFrame = _syncWithAnimationFrame;
                let log = `Loop starting in mode ${Loop.mode}`;
                if (Loop.mode != LOOP_MODE.FRAME_REQUEST)
                    log += ` with attempted ${_fps} fps`;
                FudgeCore.Debug.fudge(log);
                switch (_mode) {
                    case LOOP_MODE.FRAME_REQUEST:
                        Loop.loopFrame();
                        break;
                    case LOOP_MODE.TIME_REAL:
                        Loop.idIntervall = window.setInterval(Loop.loopTime, 1000 / Loop.fpsDesired);
                        Loop.loopTime();
                        break;
                    case LOOP_MODE.TIME_GAME:
                        Loop.idIntervall = FudgeCore.Time.game.setTimer(1000 / Loop.fpsDesired, 0, Loop.loopTime);
                        Loop.loopTime();
                        break;
                    default:
                        break;
                }
                Loop.running = true;
            }
            /**
             * Stops the loop
             */
            static stop() {
                if (!Loop.running)
                    return;
                switch (Loop.mode) {
                    case LOOP_MODE.FRAME_REQUEST:
                        window.cancelAnimationFrame(Loop.idRequest);
                        break;
                    case LOOP_MODE.TIME_REAL:
                        window.clearInterval(Loop.idIntervall);
                        window.cancelAnimationFrame(Loop.idRequest);
                        break;
                    case LOOP_MODE.TIME_GAME:
                        FudgeCore.Time.game.deleteTimer(Loop.idIntervall);
                        window.cancelAnimationFrame(Loop.idRequest);
                        break;
                    default:
                        break;
                }
                Loop.running = false;
                FudgeCore.Debug.fudge("Loop stopped!");
            }
            static continue() {
                if (Loop.running)
                    return;
                Loop.start(Loop.mode, Loop.fpsDesired, Loop.syncWithAnimationFrame);
            }
            static getFpsGameAverage() {
                return 1000 / Loop.timeLastFrameGameAvg;
            }
            static getFpsRealAverage() {
                return 1000 / Loop.timeLastFrameRealAvg;
            }
            static loop() {
                let time;
                time = performance.now();
                Loop.timeFrameReal = time - Loop.timeLastFrameReal;
                Loop.timeLastFrameReal = time;
                time = FudgeCore.Time.game.get();
                Loop.timeFrameGame = time - Loop.timeLastFrameGame;
                Loop.timeLastFrameGame = time;
                Loop.timeLastFrameGameAvg = ((Loop.framesToAverage - 1) * Loop.timeLastFrameGameAvg + Loop.timeFrameGame) / Loop.framesToAverage;
                Loop.timeLastFrameRealAvg = ((Loop.framesToAverage - 1) * Loop.timeLastFrameRealAvg + Loop.timeFrameReal) / Loop.framesToAverage;
                // TODO: consider LoopEvent which conveys information such as timeElapsed etc...
                let event = new Event("loopFrame" /* LOOP_FRAME */);
                Loop.targetStatic.dispatchEvent(event);
            }
            static loopFrame() {
                Loop.loop();
                Loop.idRequest = window.requestAnimationFrame(Loop.loopFrame);
            }
            static loopTime() {
                if (Loop.syncWithAnimationFrame)
                    Loop.idRequest = window.requestAnimationFrame(Loop.loop);
                else
                    Loop.loop();
            }
        }
        /** The gametime the loop was started, overwritten at each start */
        Loop.timeStartGame = 0;
        /** The realtime the loop was started, overwritten at each start */
        Loop.timeStartReal = 0;
        /** The gametime elapsed since the last loop cycle */
        Loop.timeFrameGame = 0;
        /** The realtime elapsed since the last loop cycle */
        Loop.timeFrameReal = 0;
        Loop.timeLastFrameGame = 0;
        Loop.timeLastFrameReal = 0;
        Loop.timeLastFrameGameAvg = 0;
        Loop.timeLastFrameRealAvg = 0;
        Loop.running = false;
        Loop.mode = LOOP_MODE.FRAME_REQUEST;
        Loop.idIntervall = 0;
        Loop.idRequest = 0;
        Loop.fpsDesired = 30;
        Loop.framesToAverage = 30;
        Loop.syncWithAnimationFrame = false;
        return Loop;
    })();
    FudgeCore.Loop = Loop;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Instances of this class generate a timestamp that correlates with the time elapsed since the start of the program but allows for resetting and scaling.
     * Supports [[Timer]]s similar to window.setInterval but with respect to the scaled time.
     * All time values are given in milliseconds
     *
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    let Time = /** @class */ (() => {
        class Time extends FudgeCore.EventTarget∆í {
            constructor() {
                super();
                this.timers = {};
                this.idTimerNext = 0;
                this.start = performance.now();
                this.scale = 1.0;
                this.offset = 0.0;
                this.lastCallToElapsed = 0.0;
            }
            /**
             * Returns the game-time-object which starts automatically and serves as base for various internal operations.
             */
            // public static get game(): Time {
            //   return Time.gameTime;
            // }
            static getUnits(_milliseconds) {
                let units = {};
                units.asSeconds = _milliseconds / 1000;
                units.asMinutes = units.asSeconds / 60;
                units.asHours = units.asMinutes / 60;
                units.hours = Math.floor(units.asHours);
                units.minutes = Math.floor(units.asMinutes) % 60;
                units.seconds = Math.floor(units.asSeconds) % 60;
                units.fraction = _milliseconds % 1000;
                units.thousands = _milliseconds % 10;
                units.hundreds = _milliseconds % 100 - units.thousands;
                units.tenths = units.fraction - units.hundreds - units.thousands;
                return units;
            }
            //#region Get/Set time and scaling
            /**
             * Retrieves the current scaled timestamp of this instance in milliseconds
             */
            get() {
                return this.offset + this.scale * (performance.now() - this.start);
            }
            /**
             * Returns the remaining time to the given point of time
             */
            getRemainder(_to) {
                return _to - this.get();
            }
            /**
             * (Re-) Sets the timestamp of this instance
             * @param _time The timestamp to represent the current time (default 0.0)
             */
            set(_time = 0) {
                this.offset = _time;
                this.start = performance.now();
                this.getElapsedSincePreviousCall();
            }
            /**
             * Sets the scaling of this time, allowing for slowmotion (<1) or fastforward (>1)
             * @param _scale The desired scaling (default 1.0)
             */
            setScale(_scale = 1.0) {
                this.set(this.get());
                this.scale = _scale;
                //TODO: catch scale=0
                this.rescaleAllTimers();
                this.getElapsedSincePreviousCall();
                this.dispatchEvent(new Event("timeScaled" /* TIME_SCALED */));
            }
            /**
             * Retrieves the current scaling of this time
             */
            getScale() {
                return this.scale;
            }
            /**
             * Retrieves the offset of this time
             */
            getOffset() {
                return this.offset;
            }
            /**
             * Retrieves the scaled time in milliseconds passed since the last call to this method
             * Automatically reset at every call to set(...) and setScale(...)
             */
            getElapsedSincePreviousCall() {
                let current = this.get();
                let elapsed = current - this.lastCallToElapsed;
                this.lastCallToElapsed = current;
                return elapsed;
            }
            //#endregion
            //#region Timers
            /**
             * Returns a Promise<void> to be resolved after the time given. To be used with async/await
             */
            delay(_lapse) {
                return new Promise(_resolve => this.setTimer(_lapse, 1, () => _resolve()));
            }
            // TODO: examine if web-workers would enhance performance here!
            /**
             * Stops and deletes all [[Timer]]s attached. Should be called before this Time-object leaves scope
             */
            clearAllTimers() {
                for (let id in this.timers) {
                    this.deleteTimer(Number(id));
                }
            }
            /**
             * Deletes [[Timer]] found using the internal id of the connected interval-object
             * @param _id
             */
            deleteTimerByItsInternalId(_id) {
                for (let id in this.timers) {
                    let timer = this.timers[id];
                    if (timer.id == _id) {
                        timer.clear();
                        delete this.timers[id];
                        // TODO: check if an early out is OK here... should be!
                    }
                }
            }
            /**
             * Installs a timer at this time object
             * @param _lapse The object-time to elapse between the calls to _callback
             * @param _count The number of calls desired, 0 = Infinite
             * @param _handler The function to call each the given lapse has elapsed
             * @param _arguments Additional parameters to pass to callback function
             */
            setTimer(_lapse, _count, _handler, ..._arguments) {
                let timer = new FudgeCore.Timer(this, _lapse, _count, _handler, _arguments);
                this.timers[++this.idTimerNext] = timer;
                return this.idTimerNext;
            }
            /**
             * Deletes the timer with the id given by this time object
             */
            deleteTimer(_id) {
                let timer = this.timers[_id];
                if (!timer)
                    return;
                timer.clear();
                delete this.timers[_id];
            }
            /**
             * Returns a reference to the timer with the given id or null if not found.
             */
            getTimer(_id) {
                return this.timers[_id];
            }
            /**
             * Returns a copy of the list of timers currently installed on this time object
             */
            getTimers() {
                let result = {};
                return Object.assign(result, this.timers);
            }
            /**
             * Returns true if there are [[Timers]] installed to this
             */
            hasTimers() {
                return (Object.keys(this.timers).length > 0);
            }
            /**
             * Recreates [[Timer]]s when scaling changes
             */
            rescaleAllTimers() {
                for (let id in this.timers) {
                    let timer = this.timers[id];
                    timer.clear();
                    if (!this.scale)
                        // Time has stopped, no need to replace cleared timers
                        continue;
                    this.timers[id] = timer.installCopy();
                }
            }
        }
        /** Standard game time starting automatically with the application */
        Time.game = new Time();
        return Time;
    })();
    FudgeCore.Time = Time;
    //#endregion
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A [[Timer]]-instance internally uses window.setInterval to call a given handler with a given frequency a given number of times,
     * passing an [[TimerEvent∆í]]-instance with additional information and given arguments.
     * The frequency scales with the [[Time]]-instance the [[Timer]]-instance is attached to.
     *
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Timer {
        /**
         * Creates a [[Timer]] instance.
         * @param _time The [[Time]] instance, the timer attaches to
         * @param _elapse The time in milliseconds to elapse, to the next call of _handler, measured in _time
         * @param _count The desired number of calls to _handler, Timer deinstalls automatically after last call. Passing 0 invokes infinite calls
         * @param _handler The [[TimerHandler]] instance to call
         * @param _arguments Additional arguments to pass to _handler
         */
        constructor(_time, _elapse, _count, _handler, ..._arguments) {
            this.time = _time;
            this.elapse = _elapse;
            this.event = new FudgeCore.EventTimer(this, _arguments);
            this.handler = _handler;
            this.count = _count;
            let scale = Math.abs(_time.getScale());
            if (!scale) {
                // Time is stopped, timer won't be active
                this.active = false;
                return;
            }
            this.timeoutReal = this.elapse / scale;
            let callback = () => {
                if (!this.active)
                    return;
                this.event.lastCall = (this.count == 1);
                _handler(this.event);
                this.event.firstCall = false;
                if (this.count > 0)
                    if (--this.count == 0)
                        _time.deleteTimerByItsInternalId(this.idWindow);
            };
            this.idWindow = window.setInterval(callback, this.timeoutReal, _arguments);
            this.active = true;
        }
        /**
         * Returns the window-id of the timer, which was returned by setInterval
         */
        get id() {
            return this.idWindow;
        }
        /**
         * Returns the time-intervall for calls to the handler
         */
        get lapse() {
            return this.elapse;
        }
        /**
         * Attaches a copy of this at its current state to the same [[Time]]-instance. Used internally when rescaling [[Time]]
         */
        installCopy() {
            return new Timer(this.time, this.elapse, this.count, this.handler, this.event.arguments);
        }
        /**
         * Clears the timer, removing it from the interval-timers handled by window
         */
        clear() {
            // if (this.type == TIMER_TYPE.TIMEOUT) {
            //     if (this.active)
            //         // save remaining time to timeout as new timeout for restart
            //         this.timeout = this.timeout * (1 - (performance.now() - this.startTimeReal) / this.timeoutReal);
            //     window.clearTimeout(this.id);
            // }
            // else
            // TODO: reusing timer starts interval anew. Should be remaining interval as timeout, then starting interval anew 
            window.clearInterval(this.idWindow);
            this.active = false;
        }
    }
    FudgeCore.Timer = Timer;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Handles file transfer from a Fudge-Browserapp to the local filesystem without a local server.
     * Saves to the download-path given by the browser, loads from the player's choice.
     */
    class FileIoBrowserLocal extends FudgeCore.EventTargetStatic {
        // TODO: refactor to async function to be handled using promise, instead of using event target
        static load() {
            FileIoBrowserLocal.selector = document.createElement("input");
            FileIoBrowserLocal.selector.type = "file";
            FileIoBrowserLocal.selector.multiple = true;
            FileIoBrowserLocal.selector.hidden = true;
            FileIoBrowserLocal.selector.addEventListener("change", FileIoBrowserLocal.handleFileSelect);
            document.body.appendChild(FileIoBrowserLocal.selector);
            FileIoBrowserLocal.selector.click();
        }
        // TODO: refactor to async function to be handled using promise, instead of using event target
        static save(_toSave) {
            for (let filename in _toSave) {
                let content = _toSave[filename];
                let blob = new Blob([content], { type: "text/plain" });
                let url = window.URL.createObjectURL(blob);
                //*/ using anchor element for download
                let downloader;
                downloader = document.createElement("a");
                downloader.setAttribute("href", url);
                downloader.setAttribute("download", filename);
                document.body.appendChild(downloader);
                downloader.click();
                document.body.removeChild(downloader);
                window.URL.revokeObjectURL(url);
            }
            let event = new CustomEvent("fileSaved" /* FILE_SAVED */, { detail: { mapFilenameToContent: _toSave } });
            FileIoBrowserLocal.targetStatic.dispatchEvent(event);
        }
        static async handleFileSelect(_event) {
            FudgeCore.Debug.fudge("-------------------------------- handleFileSelect");
            document.body.removeChild(FileIoBrowserLocal.selector);
            let fileList = _event.target.files;
            FudgeCore.Debug.fudge(fileList, fileList.length);
            if (fileList.length == 0)
                return;
            let loaded = {};
            await FileIoBrowserLocal.loadFiles(fileList, loaded);
            let event = new CustomEvent("fileLoaded" /* FILE_LOADED */, { detail: { mapFilenameToContent: loaded } });
            FileIoBrowserLocal.targetStatic.dispatchEvent(event);
        }
        static async loadFiles(_fileList, _loaded) {
            for (let file of _fileList) {
                const content = await new Response(file).text();
                _loaded[file.name] = content;
            }
        }
    }
    FudgeCore.FileIoBrowserLocal = FileIoBrowserLocal;
})(FudgeCore || (FudgeCore = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRnVkZ2VDb3JlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vU291cmNlL0RlYnVnL0RlYnVnVGFyZ2V0LnRzIiwiLi4vU291cmNlL0RlYnVnL0RlYnVnSW50ZXJmYWNlcy50cyIsIi4uL1NvdXJjZS9EZWJ1Zy9EZWJ1Z0NvbnNvbGUudHMiLCIuLi9Tb3VyY2UvRGVidWcvRGVidWcudHMiLCIuLi9Tb3VyY2UvRXZlbnQvRXZlbnQudHMiLCIuLi9Tb3VyY2UvVHJhbnNmZXIvTXV0YWJsZS50cyIsIi4uL1NvdXJjZS9UcmFuc2Zlci9TZXJpYWxpemVyLnRzIiwiLi4vU291cmNlL1JlbmRlci9SZW5kZXJJbmplY3Rvci50cyIsIi4uL1NvdXJjZS9SZW5kZXIvUmVuZGVySW5qZWN0b3JTaGFkZXIudHMiLCIuLi9Tb3VyY2UvUmVuZGVyL1JlbmRlckluamVjdG9yQ29hdC50cyIsIi4uL1NvdXJjZS9SZW5kZXIvUmVuZGVySW5qZWN0b3JNZXNoLnRzIiwiLi4vU291cmNlL0VuZ2luZS9SZWN5Y2xlci50cyIsIi4uL1NvdXJjZS9NYXRoL1ZlY3RvcjIudHMiLCIuLi9Tb3VyY2UvTWF0aC9SZWN0YW5nbGUudHMiLCIuLi9Tb3VyY2UvUmVuZGVyL1JlbmRlck9wZXJhdG9yLnRzIiwiLi4vU291cmNlL1JlZmVyZW5jZXMudHMiLCIuLi9Tb3VyY2UvQW5pbWF0aW9uL0FuaW1hdGlvbi50cyIsIi4uL1NvdXJjZS9BbmltYXRpb24vQW5pbWF0aW9uRnVuY3Rpb24udHMiLCIuLi9Tb3VyY2UvQW5pbWF0aW9uL0FuaW1hdGlvbktleS50cyIsIi4uL1NvdXJjZS9BbmltYXRpb24vQW5pbWF0aW9uU2VxdWVuY2UudHMiLCIuLi9Tb3VyY2UvQXVkaW8vQXVkaW8udHMiLCIuLi9Tb3VyY2UvQXVkaW8vQXVkaW9NYW5hZ2VyLnRzIiwiLi4vU291cmNlL0F1ZGlvL0F1ZGlvT3NjaWxsYXRvci50cyIsIi4uL1NvdXJjZS9Db2F0L0NvYXQudHMiLCIuLi9Tb3VyY2UvQ29hdC9Db2F0VGV4dHVyZWQudHMiLCIuLi9Tb3VyY2UvQ29tcG9uZW50L0NvbXBvbmVudC50cyIsIi4uL1NvdXJjZS9Db21wb25lbnQvQ29tcG9uZW50QW5pbWF0b3IudHMiLCIuLi9Tb3VyY2UvQ29tcG9uZW50L0NvbXBvbmVudEF1ZGlvLnRzIiwiLi4vU291cmNlL0NvbXBvbmVudC9Db21wb25lbnRBdWRpb0xpc3RlbmVyLnRzIiwiLi4vU291cmNlL0NvbXBvbmVudC9Db21wb25lbnRDYW1lcmEudHMiLCIuLi9Tb3VyY2UvQ29tcG9uZW50L0NvbXBvbmVudExpZ2h0LnRzIiwiLi4vU291cmNlL0NvbXBvbmVudC9Db21wb25lbnRNYXRlcmlhbC50cyIsIi4uL1NvdXJjZS9Db21wb25lbnQvQ29tcG9uZW50TWVzaC50cyIsIi4uL1NvdXJjZS9Db21wb25lbnQvQ29tcG9uZW50U2NyaXB0LnRzIiwiLi4vU291cmNlL0NvbXBvbmVudC9Db21wb25lbnRUcmFuc2Zvcm0udHMiLCIuLi9Tb3VyY2UvQ29udHJvbC9Db250cm9sLnRzIiwiLi4vU291cmNlL0NvbnRyb2wvQXhpcy50cyIsIi4uL1NvdXJjZS9Db250cm9sL0tleWJvYXJkLnRzIiwiLi4vU291cmNlL0RlYnVnL0RlYnVnQWxlcnQudHMiLCIuLi9Tb3VyY2UvRGVidWcvRGVidWdEaWFsb2cudHMiLCIuLi9Tb3VyY2UvRGVidWcvRGVidWdUZXh0QXJlYS50cyIsIi4uL1NvdXJjZS9FbmdpbmUvQ29sb3IudHMiLCIuLi9Tb3VyY2UvRW5naW5lL01hdGVyaWFsLnRzIiwiLi4vU291cmNlL0VuZ2luZS9SZXNvdXJjZU1hbmFnZXIudHMiLCIuLi9Tb3VyY2UvRW5naW5lL1ZpZXdwb3J0LnRzIiwiLi4vU291cmNlL0V2ZW50L0V2ZW50QXVkaW8udHMiLCIuLi9Tb3VyY2UvRXZlbnQvRXZlbnREcmFnRHJvcC50cyIsIi4uL1NvdXJjZS9FdmVudC9FdmVudEtleWJvYXJkLnRzIiwiLi4vU291cmNlL0V2ZW50L0V2ZW50UG9pbnRlci50cyIsIi4uL1NvdXJjZS9FdmVudC9FdmVudFRpbWVyLnRzIiwiLi4vU291cmNlL0V2ZW50L0V2ZW50V2hlZWwudHMiLCIuLi9Tb3VyY2UvTGlnaHQvTGlnaHQudHMiLCIuLi9Tb3VyY2UvTWF0aC9GcmFtaW5nLnRzIiwiLi4vU291cmNlL01hdGgvTWF0cml4M3gzLnRzIiwiLi4vU291cmNlL01hdGgvTWF0cml4NHg0LnRzIiwiLi4vU291cmNlL01hdGgvUmFuZG9tLnRzIiwiLi4vU291cmNlL01hdGgvVmVjdG9yMy50cyIsIi4uL1NvdXJjZS9NZXNoL01lc2gudHMiLCIuLi9Tb3VyY2UvTWVzaC9NZXNoQ3ViZS50cyIsIi4uL1NvdXJjZS9NZXNoL01lc2hIZWlnaHRNYXAudHMiLCIuLi9Tb3VyY2UvTWVzaC9NZXNoUHlyYW1pZC50cyIsIi4uL1NvdXJjZS9NZXNoL01lc2hRdWFkLnRzIiwiLi4vU291cmNlL01lc2gvTWVzaFNwaGVyZS50cyIsIi4uL1NvdXJjZS9NZXNoL01lc2hTcHJpdGUudHMiLCIuLi9Tb3VyY2UvTm9kZS9Ob2RlLnRzIiwiLi4vU291cmNlL05vZGUvTm9kZVJlc291cmNlLnRzIiwiLi4vU291cmNlL05vZGUvTm9kZVJlc291cmNlSW5zdGFuY2UudHMiLCIuLi9Tb3VyY2UvUmF5L1JheS50cyIsIi4uL1NvdXJjZS9SYXkvUmF5SGl0LnRzIiwiLi4vU291cmNlL1JlbmRlci9SZW5kZXJNYW5hZ2VyLnRzIiwiLi4vU291cmNlL1JlbmRlci9SZW5kZXJQYXJ0aWNsZXMudHMiLCIuLi9Tb3VyY2UvU2hhZGVyL1NoYWRlci50cyIsIi4uL1NvdXJjZS9TaGFkZXIvU2hhZGVyRmxhdC50cyIsIi4uL1NvdXJjZS9TaGFkZXIvU2hhZGVyTWF0Q2FwLnRzIiwiLi4vU291cmNlL1NoYWRlci9TaGFkZXJSYXlDYXN0LnRzIiwiLi4vU291cmNlL1NoYWRlci9TaGFkZXJUZXh0dXJlLnRzIiwiLi4vU291cmNlL1NoYWRlci9TaGFkZXJVbmlDb2xvci50cyIsIi4uL1NvdXJjZS9UZXh0dXJlL1RleHR1cmUudHMiLCIuLi9Tb3VyY2UvVGltZS9Mb29wLnRzIiwiLi4vU291cmNlL1RpbWUvVGltZS50cyIsIi4uL1NvdXJjZS9UaW1lL1RpbWVyLnRzIiwiLi4vU291cmNlL1RyYW5zZmVyL0ZpbGVJb0Jyb3dzZXJMb2NhbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUEsSUFBVSxTQUFTLENBZ0JsQjtBQWhCRCxXQUFVLFNBQVM7SUFDakI7O09BRUc7SUFDSCxNQUFzQixXQUFXO1FBRXhCLE1BQU0sQ0FBQyxjQUFjLENBQUMsUUFBZ0IsRUFBRSxHQUFHLEtBQWU7WUFDL0QsSUFBSSxHQUFHLEdBQVcsUUFBUSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsMkJBQTJCO1lBQ2xFLEtBQUssSUFBSSxHQUFHLElBQUksS0FBSztnQkFDbkIsSUFBSSxHQUFHLFlBQVksTUFBTTtvQkFDdkIsR0FBRyxJQUFJLElBQUksR0FBRyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsK0JBQStCOztvQkFFNUUsR0FBRyxJQUFJLElBQUksR0FBRyxHQUFHLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQywrQkFBK0I7WUFDakUsT0FBTyxHQUFHLENBQUM7UUFDYixDQUFDO0tBQ0Y7SUFYcUIscUJBQVcsY0FXaEMsQ0FBQTtBQUNILENBQUMsRUFoQlMsU0FBUyxLQUFULFNBQVMsUUFnQmxCO0FDaEJELG9DQUFvQztBQUNwQyxJQUFVLFNBQVMsQ0E4QmxCO0FBL0JELG9DQUFvQztBQUNwQyxXQUFVLFNBQVM7SUFDakI7O09BRUc7SUFDSCxJQUFZLFlBY1g7SUFkRCxXQUFZLFlBQVk7UUFDdEIsK0NBQVcsQ0FBQTtRQUNYLCtDQUFXLENBQUE7UUFDWCw2Q0FBVSxDQUFBO1FBQ1YsK0NBQVcsQ0FBQTtRQUNYLGlEQUFZLENBQUE7UUFDWixrREFBWSxDQUFBO1FBQ1osbURBQWEsQ0FBQTtRQUNiLG1EQUFhLENBQUE7UUFDYixxRUFBc0IsQ0FBQTtRQUN0Qix5REFBZ0IsQ0FBQTtRQUNoQix3REFB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QUksR0FBRyxHQUFXLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUNyQyxJQUFJLEdBQUcsR0FBVyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDckMsSUFBSSxHQUFHLEdBQVcsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQ3JDLElBQUksR0FBRyxHQUFXLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUNyQyxJQUFJLEdBQUcsR0FBVyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDckMsSUFBSSxHQUFHLEdBQVcsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQ3JDLElBQUksR0FBRyxHQUFXLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUNyQyxJQUFJLEdBQUcsR0FBVyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDckMsSUFBSSxHQUFHLEdBQVcsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQ3JDLElBQUksR0FBRyxHQUFXLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUNyQyxJQUFJLEdBQUcsR0FBVyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDckMsSUFBSSxHQUFHLEdBQVcsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQ3JDLElBQUksR0FBRyxHQUFXLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUNyQyxJQUFJLEdBQUcsR0FBVyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDckMsSUFBSSxHQUFHLEdBQVcsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQ3JDLElBQUksR0FBRyxHQUFXLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUNyQyxJQUFJLEdBQUcsR0FBVyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDckMsSUFBSSxNQUFNLEdBQWMsSUFBSSxTQUFTLENBQUM7WUFDdEMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUM7Z0JBQ2QsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2dCQUNqQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7Z0JBQ2pDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztnQkFDakMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2dCQUNqQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7Z0JBQ2pDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztnQkFDakMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2dCQUNqQyxHQUFH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QUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUNiO2dCQUNFLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2dCQUM3QyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztnQkFDN0MsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7Z0JBQzdDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2dCQUM3QyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztnQkFDN0MsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7Z0JBQzdDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2dCQUM3QyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztnQkFDN0MsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7Z0JBQzdDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2dCQUM3QyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztnQkFDN0MsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7Z0JBQzdDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2dCQUM3QyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztnQkFDN0MsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7Z0JBQzdDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2FBQzlDLENBQUMsQ0FBQztZQUNMLE9BQU8sTUFBTSxDQUFDO1FBQ2hCLENBQUM7UUFFRDs7O1dBR0c7UUFDSSxNQUFNLENBQUMsU0FBUyxDQUFDLE9BQWtCO1lBQ3hDLElBQUksQ0FBQyxHQUFpQixPQUFPLENBQUMsSUFBSSxDQUFDO1lBQ25DLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksSUFBSSxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDN0IsSUFBSSxJQUFJLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM3QixJQUFJLElBQUksR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzdCLElBQUksSUFBSSxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDN0IsSUFBSSxJQUFJLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM3QixJQUFJLElBQUksR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzdCLElBQUksSUFBSSxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDN0IsSUFBSSxJQUFJLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM3QixJQUFJLElBQUksR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzdCLElBQUksSUFBSSxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDN0IsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzlCLElBQUksS0FBSyxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDOUIsSUFBSSxL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LEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUN2RixDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUN2RixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUMzRixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUMzRixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUMzRixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFD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NEJBQWtCLHFCQXVEOUIsQ0FBQTtBQUNMLENBQUMsRUFoRVMsU0FBUyxLQUFULFNBQVMsUUFnRWxCIiwic291cmNlc0NvbnRlbnQiOlsibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQmFzZSBjbGFzcyBmb3IgdGhlIGRpZmZlcmVudCBEZWJ1Z1RhcmdldHMsIG1haW5seSBmb3IgdGVjaG5pY2FsIHB1cnBvc2Ugb2YgaW5oZXJpdGFuY2VcclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgRGVidWdUYXJnZXQge1xyXG4gICAgcHVibGljIGRlbGVnYXRlczogTWFwRGVidWdGaWx0ZXJUb0RlbGVnYXRlO1xyXG4gICAgcHVibGljIHN0YXRpYyBtZXJnZUFyZ3VtZW50cyhfbWVzc2FnZTogT2JqZWN0LCAuLi5fYXJnczogT2JqZWN0W10pOiBzdHJpbmcge1xyXG4gICAgICBsZXQgb3V0OiBzdHJpbmcgPSBfbWVzc2FnZS50b1N0cmluZygpOyAvL0pTT04uc3RyaW5naWZ5KF9tZXNzYWdlKTtcclxuICAgICAgZm9yIChsZXQgYXJnIG9mIF9hcmdzKVxyXG4gICAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBOdW1iZXIpXHJcbiAgICAgICAgICBvdXQgKz0gXCIsIFwiICsgYXJnLnRvUHJlY2lzaW9uKDIpLnRvU3RyaW5nKCk7IC8vSlNPTi5zdHJpbmdpZnkoYXJnLCBudWxsLCAyKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICBvdXQgKz0gXCIsIFwiICsgYXJnLnRvU3RyaW5nKCk7IC8vSlNPTi5zdHJpbmdpZnkoYXJnLCBudWxsLCAyKTtcclxuICAgICAgcmV0dXJuIG91dDtcclxuICAgIH1cclxuICB9XHJcbn0iLCIvLyA8cmVmZXJlbmNlIHBhdGg9XCJEZWJ1Z0FsZXJ0LnRzXCIvPlxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBUaGUgZmlsdGVycyBjb3JyZXNwb25kaW5nIHRvIGRlYnVnIGFjdGl2aXRpZXMsIG1vcmUgdG8gY29tZVxyXG4gICAqL1xyXG4gIGV4cG9ydCBlbnVtIERFQlVHX0ZJTFRFUiB7XHJcbiAgICBOT05FID0gMHgwMCxcclxuICAgIElORk8gPSAweDAxLFxyXG4gICAgTE9HID0gMHgwMixcclxuICAgIFdBUk4gPSAweDA0LFxyXG4gICAgRVJST1IgPSAweDA4LFxyXG4gICAgRlVER0UgPSAweDEwLFxyXG4gICAgQ0xFQVIgPSAweDEwMCxcclxuICAgIEdST1VQID0gMHgxMDEsXHJcbiAgICBHUk9VUENPTExBUFNFRCA9IDB4MTAyLFxyXG4gICAgR1JPVVBFTkQgPSAweDEwNCxcclxuICAgIE1FU1NBR0VTID0gSU5GTyB8IExPRyB8IFdBUk4gfCBFUlJPUiB8IEZVREdFLFxyXG4gICAgRk9STUFUID0gQ0xFQVIgfCBHUk9VUCB8IEdST1VQQ09MTEFQU0VEIHwgR1JPVVBFTkQsXHJcbiAgICBBTEwgPSBNRVNTQUdFUyB8IEZPUk1BVFxyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGNvbnN0IERFQlVHX1NZTUJPTDogeyBbZmlsdGVyOiBudW1iZXJdOiBzdHJpbmc7IH0gPSB7XHJcbiAgICBbREVCVUdfRklMVEVSLklORk9dOiBcIuKck1wiLFxyXG4gICAgW0RFQlVHX0ZJTFRFUi5MT0ddOiBcIuKcjlwiLFxyXG4gICAgW0RFQlVHX0ZJTFRFUi5XQVJOXTogXCLimqBcIixcclxuICAgIFtERUJVR19GSUxURVIuRVJST1JdOiBcIuKdjFwiLFxyXG4gICAgW0RFQlVHX0ZJTFRFUi5GVURHRV06IFwi8J+OslwiXHJcbiAgfTtcclxuXHJcbiAgZXhwb3J0IHR5cGUgTWFwRGVidWdUYXJnZXRUb0RlbGVnYXRlID0gTWFwPERlYnVnVGFyZ2V0LCBGdW5jdGlvbj47XHJcbiAgZXhwb3J0IGludGVyZmFjZSBNYXBEZWJ1Z0ZpbHRlclRvRGVsZWdhdGUgeyBbZmlsdGVyOiBudW1iZXJdOiBGdW5jdGlvbjsgfVxyXG59IiwiLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCJEZWJ1Z1RhcmdldC50c1wiLz5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogUm91dGluZyB0byB0aGUgc3RhbmRhcmQtY29uc29sZVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBEZWJ1Z0NvbnNvbGUgZXh0ZW5kcyBEZWJ1Z1RhcmdldCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIGRlbGVnYXRlczogTWFwRGVidWdGaWx0ZXJUb0RlbGVnYXRlID0ge1xyXG4gICAgICBbREVCVUdfRklMVEVSLklORk9dOiBjb25zb2xlLmluZm8sXHJcbiAgICAgIFtERUJVR19GSUxURVIuTE9HXTogY29uc29sZS5sb2csXHJcbiAgICAgIFtERUJVR19GSUxURVIuV0FSTl06IGNvbnNvbGUud2FybixcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5FUlJPUl06IGNvbnNvbGUuZXJyb3IsXHJcbiAgICAgIFtERUJVR19GSUxURVIuRlVER0VdOiBEZWJ1Z0NvbnNvbGUuZnVkZ2UsXHJcbiAgICAgIFtERUJVR19GSUxURVIuQ0xFQVJdOiBjb25zb2xlLmNsZWFyLFxyXG4gICAgICBbREVCVUdfRklMVEVSLkdST1VQXTogY29uc29sZS5ncm91cCxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5HUk9VUENPTExBUFNFRF06IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQsXHJcbiAgICAgIFtERUJVR19GSUxURVIuR1JPVVBFTkRdOiBjb25zb2xlLmdyb3VwRW5kXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGlzcGxheXMgY3JpdGljYWwgaW5mb3JtYXRpb24gYWJvdXQgZmFpbHVyZXMsIHdoaWNoIGlzIGVtcGhhc2l6ZWQgZS5nLiBieSBjb2xvclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGZ1ZGdlKF9tZXNzYWdlOiBPYmplY3QsIC4uLl9hcmdzOiBPYmplY3RbXSk6IHZvaWQge1xyXG4gICAgICBjb25zb2xlLmRlYnVnKFwi8J+OslwiLCBfbWVzc2FnZSwgLi4uX2FyZ3MpO1xyXG4gICAgICAvLyBsZXQgdHJhY2U6IHN0cmluZ1tdID0gbmV3IEVycm9yKFwiVGVzdFwiKS5zdGFjay5zcGxpdChcIlxcblwiKTtcclxuICAgICAgLy8gY29uc29sZS5sb2codHJhY2VbNF0pO1xyXG4gICAgICAvLyBjb25zb2xlLnRyYWNlKFwiVGVzdFwiKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCIvLyAvIDxyZWZlcmVuY2UgcGF0aD1cIkRlYnVnVGFyZ2V0LnRzXCIvPlxyXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiRGVidWdJbnRlcmZhY2VzLnRzXCIvPlxyXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiRGVidWdDb25zb2xlLnRzXCIvPlxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBUaGUgRGVidWctQ2xhc3Mgb2ZmZXJzIGZ1bmN0aW9ucyBrbm93biBmcm9tIHRoZSBjb25zb2xlLW9iamVjdCBhbmQgYWRkaXRpb25zLCBcclxuICAgKiByb3V0aW5nIHRoZSBpbmZvcm1hdGlvbiB0byB2YXJpb3VzIFtbRGVidWdUYXJnZXRzXV0gdGhhdCBjYW4gYmUgZWFzaWx5IGRlZmluZWQgYnkgdGhlIGRldmVsb3BlcnMgYW5kIHJlZ2lzdGVyZCBieSB1c2Vyc1xyXG4gICAqIE92ZXJyaWRlIGZ1bmN0aW9ucyBpbiBzdWJjbGFzc2VzIG9mIFtbRGVidWdUYXJnZXRdXSBhbmQgcmVnaXN0ZXIgdGhlbSBhcyB0aGVpciBkZWxlZ2F0ZXNcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgRGVidWcge1xyXG4gICAgLyoqXHJcbiAgICAgKiBGb3IgZWFjaCBzZXQgZmlsdGVyLCB0aGlzIGFzc29jaWF0aXZlIGFycmF5IGtlZXBzIHJlZmVyZW5jZXMgdG8gdGhlIHJlZ2lzdGVyZWQgZGVsZWdhdGUgZnVuY3Rpb25zIG9mIHRoZSBjaG9zZW4gW1tEZWJ1Z1RhcmdldHNdXVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBkZWxlZ2F0ZXM6IHsgW2ZpbHRlcjogbnVtYmVyXTogTWFwRGVidWdUYXJnZXRUb0RlbGVnYXRlIH0gPSBEZWJ1Zy5zZXR1cENvbnNvbGUoKTtcclxuXHJcbiAgICAvLyBUT0RPOiBjcmVhdGUgZmlsdGVyIERFQlVHX0ZJTFRFUi5GVURHRSBzb2xlbHkgZm9yIG1lc3NhZ2VzIGZyb20gRlVER0VcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlLSAvIEFjdGl2YXRlIGEgZmlsdGVyIGZvciB0aGUgZ2l2ZW4gRGVidWdUYXJnZXQuIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHNldEZpbHRlcihfdGFyZ2V0OiBEZWJ1Z1RhcmdldCwgX2ZpbHRlcjogREVCVUdfRklMVEVSKTogdm9pZCB7XHJcbiAgICAgIGZvciAobGV0IGZpbHRlciBpbiBEZWJ1Zy5kZWxlZ2F0ZXMpXHJcbiAgICAgICAgRGVidWcuZGVsZWdhdGVzW2ZpbHRlcl0uZGVsZXRlKF90YXJnZXQpO1xyXG5cclxuICAgICAgZm9yIChsZXQgZmlsdGVyIGluIERFQlVHX0ZJTFRFUikge1xyXG4gICAgICAgIGxldCBwYXJzZWQ6IG51bWJlciA9IHBhcnNlSW50KGZpbHRlcik7XHJcbiAgICAgICAgaWYgKGlzTmFOKHBhcnNlZCkpXHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBpZiAoW0RFQlVHX0ZJTFRFUi5NRVNTQUdFUywgREVCVUdfRklMVEVSLkZPUk1BVCwgREVCVUdfRklMVEVSLkFMTF0uaW5kZXhPZihwYXJzZWQpICE9IC0xKVxyXG4gICAgICAgICAgLy8gZG9udCBkZWxlZ2F0ZSBjb21ib3MuLi4gXHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICBpZiAoX2ZpbHRlciAmIHBhcnNlZClcclxuICAgICAgICAgIERlYnVnLmRlbGVnYXRlc1twYXJzZWRdLnNldChfdGFyZ2V0LCBfdGFyZ2V0LmRlbGVnYXRlc1twYXJzZWRdKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5mbyguLi4pIGRpc3BsYXlzIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gd2l0aCBsb3cgcHJpb3JpdHlcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBpbmZvKF9tZXNzYWdlOiBPYmplY3QsIC4uLl9hcmdzOiBPYmplY3RbXSk6IHZvaWQge1xyXG4gICAgICBEZWJ1Zy5kZWxlZ2F0ZShERUJVR19GSUxURVIuSU5GTywgX21lc3NhZ2UsIF9hcmdzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGlzcGxheXMgaW5mb3JtYXRpb24gd2l0aCBtZWRpdW0gcHJpb3JpdHlcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBsb2coX21lc3NhZ2U6IE9iamVjdCwgLi4uX2FyZ3M6IE9iamVjdFtdKTogdm9pZCB7XHJcbiAgICAgIERlYnVnLmRlbGVnYXRlKERFQlVHX0ZJTFRFUi5MT0csIF9tZXNzYWdlLCBfYXJncyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERpc3BsYXlzIGluZm9ybWF0aW9uIGFib3V0IG5vbi1jb25mb3JtaXRpZXMgaW4gdXNhZ2UsIHdoaWNoIGlzIGVtcGhhc2l6ZWQgZS5nLiBieSBjb2xvclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHdhcm4oX21lc3NhZ2U6IE9iamVjdCwgLi4uX2FyZ3M6IE9iamVjdFtdKTogdm9pZCB7XHJcbiAgICAgIERlYnVnLmRlbGVnYXRlKERFQlVHX0ZJTFRFUi5XQVJOLCBfbWVzc2FnZSwgX2FyZ3MpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwbGF5cyBjcml0aWNhbCBpbmZvcm1hdGlvbiBhYm91dCBmYWlsdXJlcywgd2hpY2ggaXMgZW1waGFzaXplZCBlLmcuIGJ5IGNvbG9yXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZXJyb3IoX21lc3NhZ2U6IE9iamVjdCwgLi4uX2FyZ3M6IE9iamVjdFtdKTogdm9pZCB7XHJcbiAgICAgIERlYnVnLmRlbGVnYXRlKERFQlVHX0ZJTFRFUi5FUlJPUiwgX21lc3NhZ2UsIF9hcmdzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGlzcGxheXMgbWVzc2FnZXMgZnJvbSBGVURHRVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGZ1ZGdlKF9tZXNzYWdlOiBPYmplY3QsIC4uLl9hcmdzOiBPYmplY3RbXSk6IHZvaWQge1xyXG4gICAgICBEZWJ1Zy5kZWxlZ2F0ZShERUJVR19GSUxURVIuRlVER0UsIF9tZXNzYWdlLCBfYXJncyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyB0aGUgb3V0cHV0IGFuZCByZW1vdmVzIHByZXZpb3VzIG1lc3NhZ2VzIGlmIHBvc3NpYmxlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgY2xlYXIoKTogdm9pZCB7XHJcbiAgICAgIERlYnVnLmRlbGVnYXRlKERFQlVHX0ZJTFRFUi5DTEVBUiwgbnVsbCwgbnVsbCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE9wZW5zIGEgbmV3IGdyb3VwIGZvciBtZXNzYWdlc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdyb3VwKF9uYW1lOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgRGVidWcuZGVsZWdhdGUoREVCVUdfRklMVEVSLkdST1VQLCBfbmFtZSwgbnVsbCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE9wZW5zIGEgbmV3IGdyb3VwIGZvciBtZXNzYWdlcyB0aGF0IGlzIGNvbGxhcHNlZCBhdCBmaXJzdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdyb3VwQ29sbGFwc2VkKF9uYW1lOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgRGVidWcuZGVsZWdhdGUoREVCVUdfRklMVEVSLkdST1VQQ09MTEFQU0VELCBfbmFtZSwgbnVsbCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENsb3NlcyB0aGUgeW91bmdlc3QgZ3JvdXBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBncm91cEVuZCgpOiB2b2lkIHtcclxuICAgICAgRGVidWcuZGVsZWdhdGUoREVCVUdfRklMVEVSLkdST1VQRU5ELCBudWxsLCBudWxsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTG9va3VwIGFsbCBkZWxlZ2F0ZXMgcmVnaXN0ZXJlZCB0byB0aGUgZmlsdGVyIGFuZCBjYWxsIHRoZW0gdXNpbmcgdGhlIGdpdmVuIGFyZ3VtZW50c1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBkZWxlZ2F0ZShfZmlsdGVyOiBERUJVR19GSUxURVIsIF9tZXNzYWdlOiBPYmplY3QsIF9hcmdzOiBPYmplY3RbXSk6IHZvaWQge1xyXG4gICAgICBsZXQgZGVsZWdhdGVzOiBNYXBEZWJ1Z1RhcmdldFRvRGVsZWdhdGUgPSBEZWJ1Zy5kZWxlZ2F0ZXNbX2ZpbHRlcl07XHJcbiAgICAgIGZvciAobGV0IGRlbGVnYXRlIG9mIGRlbGVnYXRlcy52YWx1ZXMoKSlcclxuICAgICAgICBpZiAoZGVsZWdhdGUpXHJcbiAgICAgICAgICBpZiAoX2FyZ3MgJiYgX2FyZ3MubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgZGVsZWdhdGUoX21lc3NhZ2UsIC4uLl9hcmdzKTtcclxuICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgZGVsZWdhdGUoX21lc3NhZ2UpO1xyXG5cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogc2V0dXAgcm91dGluZyB0byBzdGFuZGFyZCBjb25zb2xlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIHNldHVwQ29uc29sZSgpOiB7fSB7XHJcbiAgICAgIGxldCByZXN1bHQ6IHsgW2ZpbHRlcjogbnVtYmVyXTogTWFwRGVidWdUYXJnZXRUb0RlbGVnYXRlIH0gPSB7fTtcclxuICAgICAgbGV0IGZpbHRlcnM6IERFQlVHX0ZJTFRFUltdID0gW1xyXG4gICAgICAgIERFQlVHX0ZJTFRFUi5JTkZPLCBERUJVR19GSUxURVIuTE9HLCBERUJVR19GSUxURVIuV0FSTiwgREVCVUdfRklMVEVSLkVSUk9SLCBERUJVR19GSUxURVIuRlVER0UsXHJcbiAgICAgICAgREVCVUdfRklMVEVSLkNMRUFSLCBERUJVR19GSUxURVIuR1JPVVAsIERFQlVHX0ZJTFRFUi5HUk9VUENPTExBUFNFRCwgREVCVUdfRklMVEVSLkdST1VQRU5EXHJcbiAgICAgIF07XHJcblxyXG4gICAgICBmb3IgKGxldCBmaWx0ZXIgb2YgZmlsdGVycylcclxuICAgICAgICByZXN1bHRbZmlsdGVyXSA9IG5ldyBNYXAoW1tEZWJ1Z0NvbnNvbGUsIERlYnVnQ29uc29sZS5kZWxlZ2F0ZXNbZmlsdGVyXV1dKTtcclxuXHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgICBleHBvcnQgaW50ZXJmYWNlIE1hcEV2ZW50VHlwZVRvTGlzdGVuZXIge1xyXG4gICAgICAgIFtldmVudFR5cGU6IHN0cmluZ106IEV2ZW50TGlzdGVuZXJbXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFR5cGVzIG9mIGV2ZW50cyBzcGVjaWZpYyB0byBGdWRnZSwgaW4gYWRkaXRpb24gdG8gdGhlIHN0YW5kYXJkIERPTS9Ccm93c2VyLVR5cGVzIGFuZCBjdXN0b20gc3RyaW5nc1xyXG4gICAgICovXHJcbiAgICBleHBvcnQgY29uc3QgZW51bSBFVkVOVCB7XHJcbiAgICAgICAgLyoqIGRpc3BhdGNoZWQgdG8gdGFyZ2V0cyByZWdpc3RlcmVkIGF0IFtbTG9vcF1dLCB3aGVuIHJlcXVlc3RlZCBhbmltYXRpb24gZnJhbWUgc3RhcnRzICovXHJcbiAgICAgICAgTE9PUF9GUkFNRSA9IFwibG9vcEZyYW1lXCIsXHJcbiAgICAgICAgLyoqIGRpc3BhdGNoZWQgdG8gYSBbW0NvbXBvbmVudF1dIHdoZW4gaXRzIGJlaW5nIGFkZGVkIHRvIGEgW1tOb2RlXV0gKi9cclxuICAgICAgICBDT01QT05FTlRfQUREID0gXCJjb21wb25lbnRBZGRcIixcclxuICAgICAgICAvKiogZGlzcGF0Y2hlZCB0byBhIFtbQ29tcG9uZW50XV0gd2hlbiBpdHMgYmVpbmcgcmVtb3ZlZCBmcm9tIGEgW1tOb2RlXV0gKi9cclxuICAgICAgICBDT01QT05FTlRfUkVNT1ZFID0gXCJjb21wb25lbnRSZW1vdmVcIixcclxuICAgICAgICAvKiogZGlzcGF0Y2hlZCB0byBhIFtbQ29tcG9uZW50XV0gd2hlbiBpdHMgYmVpbmcgYWN0aXZhdGVkICovXHJcbiAgICAgICAgQ09NUE9ORU5UX0FDVElWQVRFID0gXCJjb21wb25lbnRBY3RpdmF0ZVwiLFxyXG4gICAgICAgIC8qKiBkaXNwYXRjaGVkIHRvIGEgW1tDb21wb25lbnRdXSB3aGVuIGl0cyBiZWluZyBkZWFjdGl2YXRlZCAqL1xyXG4gICAgICAgIENPTVBPTkVOVF9ERUFDVElWQVRFID0gXCJjb21wb25lbnREZWFjdGl2YXRlXCIsXHJcbiAgICAgICAgLyoqIGRpc3BhdGNoZWQgdG8gYSBjaGlsZCBbW05vZGVdXSBhbmQgaXRzIGFuY2VzdG9ycyBhZnRlciBpdCB3YXMgYXBwZW5kZWQgdG8gYSBwYXJlbnQgKi9cclxuICAgICAgICBDSElMRF9BUFBFTkQgPSBcImNoaWxkQXBwZW5kXCIsXHJcbiAgICAgICAgLyoqIGRpc3BhdGNoZWQgdG8gYSBjaGlsZCBbW05vZGVdXSBhbmQgaXRzIGFuY2VzdG9ycyBqdXN0IGJlZm9yZSBpdHMgYmVpbmcgcmVtb3ZlZCBmcm9tIGl0cyBwYXJlbnQgKi9cclxuICAgICAgICBDSElMRF9SRU1PVkUgPSBcImNoaWxkUmVtb3ZlXCIsXHJcbiAgICAgICAgLyoqIGRpc3BhdGNoZWQgdG8gYSBbW011dGFibGVdXSB3aGVuIGl0cyBiZWluZyBtdXRhdGVkICovXHJcbiAgICAgICAgTVVUQVRFID0gXCJtdXRhdGVcIixcclxuICAgICAgICAvKiogZGlzcGF0Y2hlZCB0byBbW1ZpZXdwb3J0XV0gd2hlbiBpdCBnZXRzIHRoZSBmb2N1cyB0byByZWNlaXZlIGtleWJvYXJkIGlucHV0ICovXHJcbiAgICAgICAgRk9DVVNfSU4gPSBcImZvY3VzaW5cIixcclxuICAgICAgICAvKiogZGlzcGF0Y2hlZCB0byBbW1ZpZXdwb3J0XV0gd2hlbiBpdCBsb3NlcyB0aGUgZm9jdXMgdG8gcmVjZWl2ZSBrZXlib2FyZCBpbnB1dCAqL1xyXG4gICAgICAgIEZPQ1VTX09VVCA9IFwiZm9jdXNvdXRcIixcclxuICAgICAgICAvKiogZGlzcGF0Y2hlZCB0byBbW05vZGVdXSB3aGVuIGl0J3MgZG9uZSBzZXJpYWxpemluZyAqL1xyXG4gICAgICAgIE5PREVfU0VSSUFMSVpFRCA9IFwibm9kZVNlcmlhbGl6ZWRcIixcclxuICAgICAgICAvKiogZGlzcGF0Y2hlZCB0byBbW05vZGVdXSB3aGVuIGl0J3MgZG9uZSBkZXNlcmlhbGl6aW5nLCBzbyBhbGwgY29tcG9uZW50cywgY2hpbGRyZW4gYW5kIGF0dHJpYnV0ZXMgYXJlIGF2YWlsYWJsZSAqL1xyXG4gICAgICAgIE5PREVfREVTRVJJQUxJWkVEID0gXCJub2RlRGVzZXJpYWxpemVkXCIsXHJcbiAgICAgICAgLyoqIGRpc3BhdGNoZWQgdG8gW1tOb2RlUmVzb3VyY2VJbnN0YW5jZV1dIHdoZW4gaXQncyBjb250ZW50IGlzIHNldCBhY2NvcmRpbmcgdG8gYSBzZXJpYWxpemF0aW9uIG9mIGEgW1tOb2RlUmVzb3VyY2VdXSAgKi9cclxuICAgICAgICBOT0RFUkVTT1VSQ0VfSU5TVEFOVElBVEVEID0gXCJub2RlUmVzb3VyY2VJbnN0YW50aWF0ZWRcIixcclxuICAgICAgICAvKiogZGlzcGF0Y2hlZCB0byBbW1RpbWVdXSB3aGVuIGl0J3Mgc2NhbGluZyBjaGFuZ2VkICAqL1xyXG4gICAgICAgIFRJTUVfU0NBTEVEID0gXCJ0aW1lU2NhbGVkXCIsXHJcbiAgICAgICAgLyoqIGRpc3BhdGNoZWQgdG8gW1tGaWxlSW9dXSB3aGVuIGEgbGlzdCBvZiBmaWxlcyBoYXMgYmVlbiBsb2FkZWQgICovXHJcbiAgICAgICAgRklMRV9MT0FERUQgPSBcImZpbGVMb2FkZWRcIixcclxuICAgICAgICAvKiogZGlzcGF0Y2hlZCB0byBbW0ZpbGVJb11dIHdoZW4gYSBsaXN0IG9mIGZpbGVzIGhhcyBiZWVuIHNhdmVkICovXHJcbiAgICAgICAgRklMRV9TQVZFRCA9IFwiZmlsZVNhdmVkXCJcclxuICAgIH1cclxuXHJcblxyXG4gICAgZXhwb3J0IHR5cGUgRXZlbnTGkiA9IEV2ZW50UG9pbnRlciB8IEV2ZW50RHJhZ0Ryb3AgfCBFdmVudFdoZWVsIHwgRXZlbnRLZXlib2FyZCB8IEV2ZW50O1xyXG5cclxuICAgIGV4cG9ydCB0eXBlIEV2ZW50TGlzdGVuZXLGkiA9XHJcbiAgICAgICAgKChfZXZlbnQ6IEV2ZW50UG9pbnRlcikgPT4gdm9pZCkgfFxyXG4gICAgICAgICgoX2V2ZW50OiBFdmVudERyYWdEcm9wKSA9PiB2b2lkKSB8XHJcbiAgICAgICAgKChfZXZlbnQ6IEV2ZW50V2hlZWwpID0+IHZvaWQpIHxcclxuICAgICAgICAoKF9ldmVudDogRXZlbnRLZXlib2FyZCkgPT4gdm9pZCkgfFxyXG4gICAgICAgICgoX2V2ZW50OiBFdmVudMaSKSA9PiB2b2lkKSB8XHJcbiAgICAgICAgRXZlbnRMaXN0ZW5lck9iamVjdDtcclxuXHJcbiAgICBleHBvcnQgY2xhc3MgRXZlbnRUYXJnZXTGkiBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcclxuICAgICAgICBhZGRFdmVudExpc3RlbmVyKF90eXBlOiBzdHJpbmcsIF9oYW5kbGVyOiBFdmVudExpc3RlbmVyxpIsIF9vcHRpb25zPzogYm9vbGVhbiB8IEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zKTogdm9pZCB7XHJcbiAgICAgICAgICAgIHN1cGVyLmFkZEV2ZW50TGlzdGVuZXIoX3R5cGUsIDxFdmVudExpc3RlbmVyT3JFdmVudExpc3RlbmVyT2JqZWN0Pl9oYW5kbGVyLCBfb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoX3R5cGU6IHN0cmluZywgX2hhbmRsZXI6IEV2ZW50TGlzdGVuZXLGkiwgX29wdGlvbnM/OiBib29sZWFuIHwgQWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMpOiB2b2lkIHtcclxuICAgICAgICAgICAgc3VwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihfdHlwZSwgPEV2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3Q+X2hhbmRsZXIsIF9vcHRpb25zKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRpc3BhdGNoRXZlbnQoX2V2ZW50OiBFdmVudMaSKTogYm9vbGVhbiB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdXBlci5kaXNwYXRjaEV2ZW50KF9ldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQmFzZSBjbGFzcyBmb3IgRXZlbnRUYXJnZXQgc2luZ2xldG9ucywgd2hpY2ggYXJlIGZpeGVkIGVudGl0aWVzIGluIHRoZSBzdHJ1Y3R1cmUgb2YgRnVkZ2UsIHN1Y2ggYXMgdGhlIGNvcmUgbG9vcCBcclxuICAgICAqL1xyXG4gICAgZXhwb3J0IGNsYXNzIEV2ZW50VGFyZ2V0U3RhdGljIGV4dGVuZHMgRXZlbnRUYXJnZXTGkiB7XHJcbiAgICAgICAgcHJvdGVjdGVkIHN0YXRpYyB0YXJnZXRTdGF0aWM6IEV2ZW50VGFyZ2V0U3RhdGljID0gbmV3IEV2ZW50VGFyZ2V0U3RhdGljKCk7XHJcblxyXG4gICAgICAgIHByb3RlY3RlZCBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgYWRkRXZlbnRMaXN0ZW5lcihfdHlwZTogc3RyaW5nLCBfaGFuZGxlcjogRXZlbnRMaXN0ZW5lcik6IHZvaWQge1xyXG4gICAgICAgICAgICBFdmVudFRhcmdldFN0YXRpYy50YXJnZXRTdGF0aWMuYWRkRXZlbnRMaXN0ZW5lcihfdHlwZSwgX2hhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwdWJsaWMgc3RhdGljIHJlbW92ZUV2ZW50TGlzdGVuZXIoX3R5cGU6IHN0cmluZywgX2hhbmRsZXI6IEV2ZW50TGlzdGVuZXIpOiB2b2lkIHtcclxuICAgICAgICAgICAgRXZlbnRUYXJnZXRTdGF0aWMudGFyZ2V0U3RhdGljLnJlbW92ZUV2ZW50TGlzdGVuZXIoX3R5cGUsIF9oYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBkaXNwYXRjaEV2ZW50KF9ldmVudDogRXZlbnQpOiBib29sZWFuIHtcclxuICAgICAgICAgICAgRXZlbnRUYXJnZXRTdGF0aWMudGFyZ2V0U3RhdGljLmRpc3BhdGNoRXZlbnQoX2V2ZW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9FdmVudC9FdmVudC50c1wiLz5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogSW50ZXJmYWNlIGRlc2NyaWJpbmcgdGhlIGRhdGF0eXBlcyBvZiB0aGUgYXR0cmlidXRlcyBhIG11dGF0b3IgYXMgc3RyaW5ncyBcclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIE11dGF0b3JBdHRyaWJ1dGVUeXBlcyB7XHJcbiAgICBbYXR0cmlidXRlOiBzdHJpbmddOiBzdHJpbmcgfCBPYmplY3Q7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEludGVyZmFjZSBkZXNjcmliaW5nIGEgbXV0YXRvciwgd2hpY2ggaXMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgd2l0aCBuYW1lcyBvZiBhdHRyaWJ1dGVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIHZhbHVlc1xyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgTXV0YXRvciB7XHJcbiAgICBbYXR0cmlidXRlOiBzdHJpbmddOiBHZW5lcmFsO1xyXG4gIH1cclxuXHJcbiAgLypcclxuICAgKiBJbnRlcmZhY2VzIGRlZGljYXRlZCBmb3IgZWFjaCBwdXJwb3NlLiBFeHRyYSBhdHRyaWJ1dGUgbmVjZXNzYXJ5IGZvciBjb21waWxldGltZSB0eXBlIGNoZWNraW5nLCBub3QgZXhpc3RlbnQgYXQgcnVudGltZVxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgTXV0YXRvckZvckFuaW1hdGlvbiBleHRlbmRzIE11dGF0b3IgeyByZWFkb25seSBmb3JBbmltYXRpb246IG51bGw7IH1cclxuICBleHBvcnQgaW50ZXJmYWNlIE11dGF0b3JGb3JVc2VySW50ZXJmYWNlIGV4dGVuZHMgTXV0YXRvciB7IHJlYWRvbmx5IGZvclVzZXJJbnRlcmZhY2U6IG51bGw7IH1cclxuICAvLyBleHBvcnQgaW50ZXJmYWNlIE11dGF0b3JGb3JDb21wb25lbnQgZXh0ZW5kcyBNdXRhdG9yIHsgcmVhZG9ubHkgZm9yVXNlckNvbXBvbmVudDogbnVsbDsgfVxyXG5cclxuICAvKipcclxuICAgKiBDb2xsZWN0IGFwcGxpY2FibGUgYXR0cmlidXRlcyBvZiB0aGUgaW5zdGFuY2UgYW5kIGNvcGllcyBvZiB0aGVpciB2YWx1ZXMgaW4gYSBNdXRhdG9yLW9iamVjdFxyXG4gICAqL1xyXG4gIGV4cG9ydCBmdW5jdGlvbiBnZXRNdXRhdG9yT2ZBcmJpdHJhcnkoX29iamVjdDogT2JqZWN0KTogTXV0YXRvciB7XHJcbiAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHt9O1xyXG4gICAgbGV0IGF0dHJpYnV0ZXM6IChzdHJpbmcgfCBudW1iZXIgfCBzeW1ib2wpW10gPSBSZWZsZWN0Lm93bktleXMoUmVmbGVjdC5nZXRQcm90b3R5cGVPZihfb2JqZWN0KSk7XHJcbiAgICBmb3IgKGxldCBhdHRyaWJ1dGUgb2YgYXR0cmlidXRlcykge1xyXG4gICAgICBsZXQgdmFsdWU6IE9iamVjdCA9IFJlZmxlY3QuZ2V0KF9vYmplY3QsIGF0dHJpYnV0ZSk7XHJcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKVxyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAvLyBpZiAodmFsdWUgaW5zdGFuY2VvZiBPYmplY3QgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIE11dGFibGUpKVxyXG4gICAgICAvLyAgIGNvbnRpbnVlO1xyXG4gICAgICBtdXRhdG9yW2F0dHJpYnV0ZS50b1N0cmluZygpXSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEJhc2UgY2xhc3MgZm9yIGFsbCB0eXBlcyBiZWluZyBtdXRhYmxlIHVzaW5nIFtbTXV0YXRvcl1dLW9iamVjdHMsIHRodXMgcHJvdmlkaW5nIGFuZCB1c2luZyBpbnRlcmZhY2VzIGNyZWF0ZWQgYXQgcnVudGltZS4gIFxyXG4gICAqIE11dGFibGVzIHByb3ZpZGUgYSBbW011dGF0b3JdXSB0aGF0IGlzIGJ1aWxkIGJ5IGNvbGxlY3RpbmcgYWxsIG9iamVjdC1wcm9wZXJ0aWVzIHRoYXQgYXJlIGVpdGhlciBvZiBhIHByaW1pdGl2ZSB0eXBlIG9yIGFnYWluIE11dGFibGUuXHJcbiAgICogU3ViY2xhc3NlcyBjYW4gZWl0aGVyIHJlZHVjZSB0aGUgc3RhbmRhcmQgW1tNdXRhdG9yXV0gYnVpbHQgYnkgdGhpcyBiYXNlIGNsYXNzIGJ5IGRlbGV0aW5nIHByb3BlcnRpZXMgb3IgaW1wbGVtZW50IGFuIGluZGl2aWR1YWwgZ2V0TXV0YXRvci1tZXRob2QuXHJcbiAgICogVGhlIHByb3ZpZGVkIHByb3BlcnRpZXMgb2YgdGhlIFtbTXV0YXRvcl1dIG11c3QgbWF0Y2ggcHVibGljIHByb3BlcnRpZXMgb3IgZ2V0dGVycy9zZXR0ZXJzIG9mIHRoZSBvYmplY3QuXHJcbiAgICogT3RoZXJ3aXNlLCB0aGV5IHdpbGwgYmUgaWdub3JlZCBpZiBub3QgaGFuZGxlZCBieSBhbiBvdmVycmlkZSBvZiB0aGUgbXV0YXRlLW1ldGhvZCBpbiB0aGUgc3ViY2xhc3MgYW5kIHRocm93IGVycm9ycyBpbiBhbiBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCB1c2VyLWludGVyZmFjZSBmb3IgdGhlIG9iamVjdC5cclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgTXV0YWJsZSBleHRlbmRzIEV2ZW50VGFyZ2V0xpIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHR5cGUgb2YgdGhpcyBtdXRhYmxlIHN1YmNsYXNzIGFzIHRoZSBuYW1lIG9mIHRoZSBydW50aW1lIGNsYXNzXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdHlwZSBvZiB0aGUgbXV0YWJsZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHR5cGUoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29sbGVjdCBhcHBsaWNhYmxlIGF0dHJpYnV0ZXMgb2YgdGhlIGluc3RhbmNlIGFuZCBjb3BpZXMgb2YgdGhlaXIgdmFsdWVzIGluIGEgTXV0YXRvci1vYmplY3RcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0ge307XHJcblxyXG4gICAgICAvLyBjb2xsZWN0IHByaW1pdGl2ZSBhbmQgbXV0YWJsZSBhdHRyaWJ1dGVzXHJcbiAgICAgIGZvciAobGV0IGF0dHJpYnV0ZSBpbiB0aGlzKSB7XHJcbiAgICAgICAgbGV0IHZhbHVlOiBPYmplY3QgPSB0aGlzW2F0dHJpYnV0ZV07XHJcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pXHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBPYmplY3QgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIE11dGFibGUpICYmICEodmFsdWUuaGFzT3duUHJvcGVydHkoXCJpZFJlc291cmNlXCIpKSlcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIG11dGF0b3JbYXR0cmlidXRlXSA9IHRoaXNbYXR0cmlidXRlXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gbXV0YXRvciBjYW4gYmUgcmVkdWNlZCBidXQgbm90IGV4dGVuZGVkIVxyXG4gICAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnMobXV0YXRvcik7XHJcbiAgICAgIC8vIGRlbGV0ZSB1bndhbnRlZCBhdHRyaWJ1dGVzXHJcbiAgICAgIHRoaXMucmVkdWNlTXV0YXRvcihtdXRhdG9yKTtcclxuXHJcbiAgICAgIC8vIHJlcGxhY2UgcmVmZXJlbmNlcyB0byBtdXRhYmxlIG9iamVjdHMgd2l0aCByZWZlcmVuY2VzIHRvIGNvcGllc1xyXG4gICAgICBmb3IgKGxldCBhdHRyaWJ1dGUgaW4gbXV0YXRvcikge1xyXG4gICAgICAgIGxldCB2YWx1ZTogT2JqZWN0ID0gbXV0YXRvclthdHRyaWJ1dGVdO1xyXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE11dGFibGUpXHJcbiAgICAgICAgICBtdXRhdG9yW2F0dHJpYnV0ZV0gPSB2YWx1ZS5nZXRNdXRhdG9yKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29sbGVjdCB0aGUgYXR0cmlidXRlcyBvZiB0aGUgaW5zdGFuY2UgYW5kIHRoZWlyIHZhbHVlcyBhcHBsaWNhYmxlIGZvciBhbmltYXRpb24uXHJcbiAgICAgKiBCYXNpYyBmdW5jdGlvbmFsaXR5IGlzIGlkZW50aWNhbCB0byBbW2dldE11dGF0b3JdXSwgcmV0dXJuZWQgbXV0YXRvciBzaG91bGQgdGhlbiBiZSByZWR1Y2VkIGJ5IHRoZSBzdWJjbGFzc2VkIGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yRm9yQW5pbWF0aW9uKCk6IE11dGF0b3JGb3JBbmltYXRpb24ge1xyXG4gICAgICByZXR1cm4gPE11dGF0b3JGb3JBbmltYXRpb24+dGhpcy5nZXRNdXRhdG9yKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbGxlY3QgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIGluc3RhbmNlIGFuZCB0aGVpciB2YWx1ZXMgYXBwbGljYWJsZSBmb3IgdGhlIHVzZXIgaW50ZXJmYWNlLlxyXG4gICAgICogQmFzaWMgZnVuY3Rpb25hbGl0eSBpcyBpZGVudGljYWwgdG8gW1tnZXRNdXRhdG9yXV0sIHJldHVybmVkIG11dGF0b3Igc2hvdWxkIHRoZW4gYmUgcmVkdWNlZCBieSB0aGUgc3ViY2xhc3NlZCBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvckZvclVzZXJJbnRlcmZhY2UoKTogTXV0YXRvckZvclVzZXJJbnRlcmZhY2Uge1xyXG4gICAgICByZXR1cm4gPE11dGF0b3JGb3JVc2VySW50ZXJmYWNlPnRoaXMuZ2V0TXV0YXRvcigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb2xsZWN0IHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBpbnN0YW5jZSBhbmQgdGhlaXIgdmFsdWVzIGFwcGxpY2FibGUgZm9yIGluZGl2aXVhbGl6YXRpb24gYnkgdGhlIGNvbXBvbmVudC5cclxuICAgICAqIEJhc2ljIGZ1bmN0aW9uYWxpdHkgaXMgaWRlbnRpY2FsIHRvIFtbZ2V0TXV0YXRvcl1dLCByZXR1cm5lZCBtdXRhdG9yIHNob3VsZCB0aGVuIGJlIHJlZHVjZWQgYnkgdGhlIHN1YmNsYXNzZWQgaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgLy8gcHVibGljIGdldE11dGF0b3JGb3JDb21wb25lbnQoKTogTXV0YXRvckZvckNvbXBvbmVudCB7XHJcbiAgICAvLyAgICAgcmV0dXJuIDxNdXRhdG9yRm9yQ29tcG9uZW50PnRoaXMuZ2V0TXV0YXRvcigpO1xyXG4gICAgLy8gfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIGFzc29jaWF0aXZlIGFycmF5IHdpdGggdGhlIHNhbWUgYXR0cmlidXRlcyBhcyB0aGUgZ2l2ZW4gbXV0YXRvciwgYnV0IHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgdHlwZXMgYXMgc3RyaW5nLXZhbHVlc1xyXG4gICAgICogRG9lcyBub3QgcmVjdXJzZSBpbnRvIG9iamVjdHMhXHJcbiAgICAgKiBAcGFyYW0gX211dGF0b3IgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yQXR0cmlidXRlVHlwZXMoX211dGF0b3I6IE11dGF0b3IpOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMge1xyXG4gICAgICBsZXQgdHlwZXM6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyA9IHt9O1xyXG4gICAgICBmb3IgKGxldCBhdHRyaWJ1dGUgaW4gX211dGF0b3IpIHtcclxuICAgICAgICBsZXQgdHlwZTogc3RyaW5nID0gbnVsbDtcclxuICAgICAgICBsZXQgdmFsdWU6IG51bWJlciB8IGJvb2xlYW4gfCBzdHJpbmcgfCBvYmplY3QgPSBfbXV0YXRvclthdHRyaWJ1dGVdO1xyXG4gICAgICAgIGlmIChfbXV0YXRvclthdHRyaWJ1dGVdICE9IHVuZGVmaW5lZClcclxuICAgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PSBcIm9iamVjdFwiKVxyXG4gICAgICAgICAgICB0eXBlID0gKDxHZW5lcmFsPnRoaXMpW2F0dHJpYnV0ZV0uY29uc3RydWN0b3IubmFtZTtcclxuICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiAodmFsdWUpID09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICAgICAgdHlwZSA9IHZhbHVlW1wibmFtZVwiXTtcclxuICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdHlwZSA9IF9tdXRhdG9yW2F0dHJpYnV0ZV0uY29uc3RydWN0b3IubmFtZTtcclxuICAgICAgICB0eXBlc1thdHRyaWJ1dGVdID0gdHlwZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdHlwZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gbXV0YXRvciBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0gX211dGF0b3IgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB1cGRhdGVNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIGZvciAobGV0IGF0dHJpYnV0ZSBpbiBfbXV0YXRvcikge1xyXG4gICAgICAgIGxldCB2YWx1ZTogT2JqZWN0ID0gX211dGF0b3JbYXR0cmlidXRlXTtcclxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNdXRhYmxlKVxyXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5nZXRNdXRhdG9yKCk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgX211dGF0b3JbYXR0cmlidXRlXSA9ICg8R2VuZXJhbD50aGlzKVthdHRyaWJ1dGVdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIGF0dHJpYnV0ZSB2YWx1ZXMgb2YgdGhlIGluc3RhbmNlIGFjY29yZGluZyB0byB0aGUgc3RhdGUgb2YgdGhlIG11dGF0b3IuIE11c3QgYmUgcHJvdGVjdGVkLi4uIVxyXG4gICAgICogQHBhcmFtIF9tdXRhdG9yXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgLy8gVE9ETzogZG9uJ3QgYXNzaWduIHVua25vd24gcHJvcGVydGllc1xyXG4gICAgICBmb3IgKGxldCBhdHRyaWJ1dGUgaW4gX211dGF0b3IpIHtcclxuICAgICAgICBsZXQgdmFsdWU6IE11dGF0b3IgPSA8TXV0YXRvcj5fbXV0YXRvclthdHRyaWJ1dGVdO1xyXG4gICAgICAgIGxldCBtdXRhbnQ6IE9iamVjdCA9ICg8R2VuZXJhbD50aGlzKVthdHRyaWJ1dGVdO1xyXG4gICAgICAgIGlmIChtdXRhbnQgaW5zdGFuY2VvZiBNdXRhYmxlKVxyXG4gICAgICAgICAgbXV0YW50Lm11dGF0ZSh2YWx1ZSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgKDxHZW5lcmFsPnRoaXMpW2F0dHJpYnV0ZV0gPSB2YWx1ZTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULk1VVEFURSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWR1Y2VzIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBnZW5lcmFsIG11dGF0b3IgYWNjb3JkaW5nIHRvIGRlc2lyZWQgb3B0aW9ucyBmb3IgbXV0YXRpb24uIFRvIGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzZXNcclxuICAgICAqIEBwYXJhbSBfbXV0YXRvciBcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkO1xyXG4gIH1cclxufVxyXG4iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tYW55XHJcbiAgICBleHBvcnQgdHlwZSBHZW5lcmFsID0gYW55O1xyXG5cclxuICAgIGV4cG9ydCBpbnRlcmZhY2UgU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgICAgW3R5cGU6IHN0cmluZ106IEdlbmVyYWw7XHJcbiAgICB9XHJcbiAgICBleHBvcnQgaW50ZXJmYWNlIFNlcmlhbGl6YWJsZSB7XHJcbiAgICAgICAgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb247XHJcbiAgICAgICAgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBTZXJpYWxpemFibGU7XHJcbiAgICB9XHJcblxyXG4gICAgaW50ZXJmYWNlIE5hbWVzcGFjZVJlZ2lzdGVyIHtcclxuICAgICAgICBbbmFtZTogc3RyaW5nXTogT2JqZWN0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlcyB0aGUgZXh0ZXJuYWwgc2VyaWFsaXphdGlvbiBhbmQgZGVzZXJpYWxpemF0aW9uIG9mIFtbU2VyaWFsaXphYmxlXV0gb2JqZWN0cy4gVGhlIGludGVybmFsIHByb2Nlc3MgaXMgaGFuZGxlZCBieSB0aGUgb2JqZWN0cyB0aGVtc2VsdmVzLiAgXHJcbiAgICAgKiBBIFtbU2VyaWFsaXphdGlvbl1dIG9iamVjdCBjYW4gYmUgY3JlYXRlZCBmcm9tIGEgW1tTZXJpYWxpemFibGVdXSBvYmplY3QgYW5kIGEgSlNPTi1TdHJpbmcgbWF5IGJlIGNyZWF0ZWQgZnJvbSB0aGF0LiAgXHJcbiAgICAgKiBWaWNlIHZlcnNhLCBhIEpTT04tU3RyaW5nIGNhbiBiZSBwYXJzZWQgdG8gYSBbW1NlcmlhbGl6YXRpb25dXSB3aGljaCBjYW4gYmUgZGVzZXJpYWxpemVkIHRvIGEgW1tTZXJpYWxpemFibGVdXSBvYmplY3QuXHJcbiAgICAgKiBgYGBwbGFpbnRleHRcclxuICAgICAqICBbU2VyaWFsaXphYmxlXSDihpIgKHNlcmlhbGl6ZSkg4oaSIFtTZXJpYWxpemF0aW9uXSDihpIgKHN0cmluZ2lmeSkgIFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKGk1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1N0cmluZ11cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDihpNcclxuICAgICAqICBbU2VyaWFsaXphYmxlXSDihpAgKGRlc2VyaWFsaXplKSDihpAgW1NlcmlhbGl6YXRpb25dIOKGkCAocGFyc2UpXHJcbiAgICAgKiBgYGAgICAgICBcclxuICAgICAqIFdoaWxlIHRoZSBpbnRlcm5hbCBzZXJpYWxpemUvZGVzZXJpYWxpemUgbWV0aG9kcyBvZiB0aGUgb2JqZWN0cyBjYXJlIG9mIHRoZSBzZWxlY3Rpb24gb2YgaW5mb3JtYXRpb24gbmVlZGVkIHRvIHJlY3JlYXRlIHRoZSBvYmplY3QgYW5kIGl0cyBzdHJ1Y3R1cmUsICBcclxuICAgICAqIHRoZSBbW1NlcmlhbGl6ZXJdXSBrZWVwcyB0cmFjayBvZiB0aGUgbmFtZXNwYWNlcyBhbmQgY2xhc3NlcyBpbiBvcmRlciB0byByZWNyZWF0ZSBbW1NlcmlhbGl6YWJsZV1dIG9iamVjdHMuIFRoZSBnZW5lcmFsIHN0cnVjdHVyZSBvZiBhIFtbU2VyaWFsaXphdGlvbl1dIGlzIGFzIGZvbGxvd3MgIFxyXG4gICAgICogYGBgcGxhaW50ZXh0XHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgIG5hbWVzcGFjZU5hbWUuY2xhc3NOYW1lOiB7XHJcbiAgICAgKiAgICAgICAgICBwcm9wZXJ0eU5hbWU6IHByb3BlcnR5VmFsdWUsXHJcbiAgICAgKiAgICAgICAgICAuLi4sXHJcbiAgICAgKiAgICAgICAgICBwcm9wZXJ0eU5hbWVPZlJlZmVyZW5jZTogU2VyaWFsaXphdGlvbk9mVGhlUmVmZXJlbmNlZE9iamVjdCxcclxuICAgICAqICAgICAgICAgIC4uLixcclxuICAgICAqICAgICAgICAgIGNvbnN0cnVjdG9yTmFtZU9mU3VwZXJjbGFzczogU2VyaWFsaXphdGlvbk9mU3VwZXJDbGFzc1xyXG4gICAgICogICAgICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqIFNpbmNlIHRoZSBpbnN0YW5jZSBvZiB0aGUgc3VwZXJjbGFzcyBpcyBjcmVhdGVkIGF1dG9tYXRpY2FsbHkgd2hlbiBhbiBvYmplY3QgaXMgY3JlYXRlZCwgXHJcbiAgICAgKiB0aGUgU2VyaWFsaXphdGlvbk9mU3VwZXJDbGFzcyBvbWl0cyB0aGUgdGhlIG5hbWVzcGFjZU5hbWUuY2xhc3NOYW1lIGtleSBhbmQgY29uc2lzdHMgb25seSBvZiBpdHMgdmFsdWUuIFxyXG4gICAgICogVGhlIGNvbnN0cnVjdG9yTmFtZU9mU3VwZXJjbGFzcyBpcyBnaXZlbiBpbnN0ZWFkIGFzIGEgcHJvcGVydHkgbmFtZSBpbiB0aGUgc2VyaWFsaXphdGlvbiBvZiB0aGUgc3ViY2xhc3MuXHJcbiAgICAgKi9cclxuICAgIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTZXJpYWxpemVyIHtcclxuICAgICAgICAvKiogSW4gb3JkZXIgZm9yIHRoZSBTZXJpYWxpemVyIHRvIGNyZWF0ZSBjbGFzcyBpbnN0YW5jZXMsIGl0IG5lZWRzIGFjY2VzcyB0byB0aGUgYXBwcm9wcmlhdGUgbmFtZXNwYWNlcyAqL1xyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIG5hbWVzcGFjZXM6IE5hbWVzcGFjZVJlZ2lzdGVyID0geyBcIsaSXCI6IEZ1ZGdlQ29yZSB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWdpc3RlcnMgYSBuYW1lc3BhY2UgdG8gdGhlIFtbU2VyaWFsaXplcl1dLCB0byBlbmFibGUgYXV0b21hdGljIGluc3RhbnRpYXRpb24gb2YgY2xhc3NlcyBkZWZpbmVkIHdpdGhpblxyXG4gICAgICAgICAqIEBwYXJhbSBfbmFtZXNwYWNlIFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgcmVnaXN0ZXJOYW1lc3BhY2UoX25hbWVzcGFjZTogT2JqZWN0KTogdm9pZCB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IG5hbWUgaW4gU2VyaWFsaXplci5uYW1lc3BhY2VzKVxyXG4gICAgICAgICAgICAgICAgaWYgKFNlcmlhbGl6ZXIubmFtZXNwYWNlc1tuYW1lXSA9PSBfbmFtZXNwYWNlKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGxldCBuYW1lOiBzdHJpbmcgPSBTZXJpYWxpemVyLmZpbmROYW1lc3BhY2VJbihfbmFtZXNwYWNlLCB3aW5kb3cpO1xyXG4gICAgICAgICAgICBpZiAoIW5hbWUpXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwYXJlbnROYW1lIGluIFNlcmlhbGl6ZXIubmFtZXNwYWNlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBTZXJpYWxpemVyLmZpbmROYW1lc3BhY2VJbihfbmFtZXNwYWNlLCBTZXJpYWxpemVyLm5hbWVzcGFjZXNbcGFyZW50TmFtZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBwYXJlbnROYW1lICsgXCIuXCIgKyBuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIW5hbWUpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOYW1lc3BhY2Ugbm90IGZvdW5kLiBNYXliZSBwYXJlbnQgbmFtZXNwYWNlIGhhc24ndCBiZWVuIHJlZ2lzdGVyZWQgYmVmb3JlP1wiKTtcclxuXHJcbiAgICAgICAgICAgIFNlcmlhbGl6ZXIubmFtZXNwYWNlc1tuYW1lXSA9IF9uYW1lc3BhY2U7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIGphdmFzY3JpcHQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgc2VyaWFsaXphYmxlIEZVREdFLW9iamVjdCBnaXZlbixcclxuICAgICAgICAgKiBpbmNsdWRpbmcgYXR0YWNoZWQgY29tcG9uZW50cywgY2hpbGRyZW4sIHN1cGVyY2xhc3Mtb2JqZWN0cyBhbGwgaW5mb3JtYXRpb24gbmVlZGVkIGZvciByZWNvbnN0cnVjdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSBfb2JqZWN0IEFuIG9iamVjdCB0byBzZXJpYWxpemUsIGltcGxlbWVudGluZyB0aGUgW1tTZXJpYWxpemFibGVdXSBpbnRlcmZhY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBwdWJsaWMgc3RhdGljIHNlcmlhbGl6ZShfb2JqZWN0OiBTZXJpYWxpemFibGUpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7fTtcclxuICAgICAgICAgICAgLy8gVE9ETzogc2F2ZSB0aGUgbmFtZXNwYWNlIHdpdGggdGhlIGNvbnN0cnVjdG9ycyBuYW1lXHJcbiAgICAgICAgICAgIC8vIHNlcmlhbGl6YXRpb25bX29iamVjdC5jb25zdHJ1Y3Rvci5uYW1lXSA9IF9vYmplY3Quc2VyaWFsaXplKCk7XHJcbiAgICAgICAgICAgIGxldCBwYXRoOiBzdHJpbmcgPSB0aGlzLmdldEZ1bGxQYXRoKF9vYmplY3QpO1xyXG4gICAgICAgICAgICBpZiAoIXBhdGgpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5hbWVzcGFjZSBvZiBzZXJpYWxpemFibGUgb2JqZWN0IG9mIHR5cGUgJHtfb2JqZWN0LmNvbnN0cnVjdG9yLm5hbWV9IG5vdCBmb3VuZC4gTWF5YmUgdGhlIG5hbWVzcGFjZSBoYXNuJ3QgYmVlbiByZWdpc3RlcmVkIG9yIHRoZSBjbGFzcyBub3QgZXhwb3J0ZWQ/YCk7XHJcbiAgICAgICAgICAgIHNlcmlhbGl6YXRpb25bcGF0aF0gPSBfb2JqZWN0LnNlcmlhbGl6ZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgICAgICAgICAgLy8gcmV0dXJuIF9vYmplY3Quc2VyaWFsaXplKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgRlVER0Utb2JqZWN0IHJlY29uc3RydWN0ZWQgZnJvbSB0aGUgaW5mb3JtYXRpb24gaW4gdGhlIFtbU2VyaWFsaXphdGlvbl1dIGdpdmVuLFxyXG4gICAgICAgICAqIGluY2x1ZGluZyBhdHRhY2hlZCBjb21wb25lbnRzLCBjaGlsZHJlbiwgc3VwZXJjbGFzcy1vYmplY3RzXHJcbiAgICAgICAgICogQHBhcmFtIF9zZXJpYWxpemF0aW9uIFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBTZXJpYWxpemFibGUge1xyXG4gICAgICAgICAgICBsZXQgcmVjb25zdHJ1Y3Q6IFNlcmlhbGl6YWJsZTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIC8vIGxvb3AgY29uc3RydWN0ZWQgc29sZWx5IHRvIGFjY2VzcyB0eXBlLXByb3BlcnR5LiBPbmx5IG9uZSBleHBlY3RlZCFcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHBhdGggaW4gX3NlcmlhbGl6YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyByZWNvbnN0cnVjdCA9IG5ldyAoPEdlbmVyYWw+RnVkZ2UpW3R5cGVOYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICByZWNvbnN0cnVjdCA9IFNlcmlhbGl6ZXIucmVjb25zdHJ1Y3QocGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVjb25zdHJ1Y3QgPSByZWNvbnN0cnVjdC5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltwYXRoXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlY29uc3RydWN0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRlc2VyaWFsaXphdGlvbiBmYWlsZWQ6IFwiICsgX2Vycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vVE9ETzogaW1wbGVtZW50IHByZXR0aWZpZXIgdG8gbWFrZSBKU09OLVN0cmluZ2lmaWNhdGlvbiBvZiBzZXJpYWxpemF0aW9ucyBtb3JlIHJlYWRhYmxlLCBlLmcuIHBsYWNpbmcgeCwgeSBhbmQgeiBpbiBvbmUgbGluZVxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgcHJldHRpZnkoX2pzb246IHN0cmluZyk6IHN0cmluZyB7IHJldHVybiBfanNvbjsgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgZm9ybWF0dGVkLCBodW1hbiByZWFkYWJsZSBKU09OLVN0cmluZywgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBbW1NlcmlhbGl6YWlvbl1dIHRoYXQgbWF5IGhhdmUgYmVlbiBjcmVhdGVkIGJ5IFtbU2VyaWFsaXplcl1dLnNlcmlhbGl6ZVxyXG4gICAgICAgICAqIEBwYXJhbSBfc2VyaWFsaXphdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgc3RyaW5naWZ5KF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogc3RyaW5nIHtcclxuICAgICAgICAgICAgLy8gYWRqdXN0bWVudHMgdG8gc2VyaWFsaXphdGlvbiBjYW4gYmUgbWFkZSBoZXJlIGJlZm9yZSBzdHJpbmdpZmljYXRpb24sIGlmIGRlc2lyZWRcclxuICAgICAgICAgICAgbGV0IGpzb246IHN0cmluZyA9IEpTT04uc3RyaW5naWZ5KF9zZXJpYWxpemF0aW9uLCBudWxsLCAyKTtcclxuICAgICAgICAgICAgbGV0IHByZXR0eTogc3RyaW5nID0gU2VyaWFsaXplci5wcmV0dGlmeShqc29uKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByZXR0eTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBbW1NlcmlhbGl6YXRpb25dXSBjcmVhdGVkIGZyb20gdGhlIGdpdmVuIEpTT04tU3RyaW5nLiBSZXN1bHQgbWF5IGJlIHBhc3NlZCB0byBbW1NlcmlhbGl6ZXJdXS5kZXNlcmlhbGl6ZVxyXG4gICAgICAgICAqIEBwYXJhbSBfanNvbiBcclxuICAgICAgICAgKi9cclxuICAgICAgICBwdWJsaWMgc3RhdGljIHBhcnNlKF9qc29uOiBzdHJpbmcpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoX2pzb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBvZiB0aGUgY2xhc3MgZGVmaW5lZCB3aXRoIHRoZSBmdWxsIHBhdGggaW5jbHVkaW5nIHRoZSBuYW1lc3BhY2VOYW1lKHMpIGFuZCB0aGUgY2xhc3NOYW1lIHNlcGVyYXRlZCBieSBkb3RzKC4pIFxyXG4gICAgICAgICAqIEBwYXJhbSBfcGF0aCBcclxuICAgICAgICAgKi9cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyByZWNvbnN0cnVjdChfcGF0aDogc3RyaW5nKTogU2VyaWFsaXphYmxlIHtcclxuICAgICAgICAgICAgbGV0IHR5cGVOYW1lOiBzdHJpbmcgPSBfcGF0aC5zdWJzdHIoX3BhdGgubGFzdEluZGV4T2YoXCIuXCIpICsgMSk7XHJcbiAgICAgICAgICAgIGxldCBuYW1lc3BhY2U6IE9iamVjdCA9IFNlcmlhbGl6ZXIuZ2V0TmFtZXNwYWNlKF9wYXRoKTtcclxuICAgICAgICAgICAgaWYgKCFuYW1lc3BhY2UpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5hbWVzcGFjZSBvZiBzZXJpYWxpemFibGUgb2JqZWN0IG9mIHR5cGUgJHt0eXBlTmFtZX0gbm90IGZvdW5kLiBNYXliZSB0aGUgbmFtZXNwYWNlIGhhc24ndCBiZWVuIHJlZ2lzdGVyZWQ/YCk7XHJcbiAgICAgICAgICAgIGxldCByZWNvbnN0cnVjdGlvbjogU2VyaWFsaXphYmxlID0gbmV3ICg8R2VuZXJhbD5uYW1lc3BhY2UpW3R5cGVOYW1lXTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlY29uc3RydWN0aW9uO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgZnVsbCBwYXRoIHRvIHRoZSBjbGFzcyBvZiB0aGUgb2JqZWN0LCBpZiBmb3VuZCBpbiB0aGUgcmVnaXN0ZXJlZCBuYW1lc3BhY2VzXHJcbiAgICAgICAgICogQHBhcmFtIF9vYmplY3QgXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgZ2V0RnVsbFBhdGgoX29iamVjdDogU2VyaWFsaXphYmxlKTogc3RyaW5nIHtcclxuICAgICAgICAgICAgbGV0IHR5cGVOYW1lOiBzdHJpbmcgPSBfb2JqZWN0LmNvbnN0cnVjdG9yLm5hbWU7XHJcbiAgICAgICAgICAgIC8vIERlYnVnLmxvZyhcIlNlYXJjaGluZyBuYW1lc3BhY2Ugb2Y6IFwiICsgdHlwZU5hbWUpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lc3BhY2VOYW1lIGluIFNlcmlhbGl6ZXIubmFtZXNwYWNlcykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kOiBHZW5lcmFsID0gKDxHZW5lcmFsPlNlcmlhbGl6ZXIubmFtZXNwYWNlcylbbmFtZXNwYWNlTmFtZV1bdHlwZU5hbWVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kICYmIF9vYmplY3QgaW5zdGFuY2VvZiBmb3VuZClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZXNwYWNlTmFtZSArIFwiLlwiICsgdHlwZU5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBuYW1lc3BhY2Utb2JqZWN0IGRlZmluZWQgd2l0aGluIHRoZSBmdWxsIHBhdGgsIGlmIHJlZ2lzdGVyZWRcclxuICAgICAgICAgKiBAcGFyYW0gX3BhdGhcclxuICAgICAgICAgKi9cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBnZXROYW1lc3BhY2UoX3BhdGg6IHN0cmluZyk6IE9iamVjdCB7XHJcbiAgICAgICAgICAgIGxldCBuYW1lc3BhY2VOYW1lOiBzdHJpbmcgPSBfcGF0aC5zdWJzdHIoMCwgX3BhdGgubGFzdEluZGV4T2YoXCIuXCIpKTtcclxuICAgICAgICAgICAgcmV0dXJuIFNlcmlhbGl6ZXIubmFtZXNwYWNlc1tuYW1lc3BhY2VOYW1lXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZpbmRzIHRoZSBuYW1lc3BhY2Utb2JqZWN0IGluIHByb3BlcnRpZXMgb2YgdGhlIHBhcmVudC1vYmplY3QgKGUuZy4gd2luZG93KSwgaWYgcHJlc2VudFxyXG4gICAgICAgICAqIEBwYXJhbSBfbmFtZXNwYWNlIFxyXG4gICAgICAgICAqIEBwYXJhbSBfcGFyZW50IFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIGZpbmROYW1lc3BhY2VJbihfbmFtZXNwYWNlOiBPYmplY3QsIF9wYXJlbnQ6IE9iamVjdCk6IHN0cmluZyB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHByb3AgaW4gX3BhcmVudClcclxuICAgICAgICAgICAgICAgIGlmICgoPEdlbmVyYWw+X3BhcmVudClbcHJvcF0gPT0gX25hbWVzcGFjZSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcDtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGNsYXNzIFJlbmRlckluamVjdG9yIHtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGluamVjdChfY29uc3RydWN0b3I6IEZ1bmN0aW9uLCBfaW5qZWN0b3I6IHR5cGVvZiBSZW5kZXJJbmplY3Rvcik6IHZvaWQge1xyXG4gICAgICBsZXQgaW5qZWN0aW9uOiBGdW5jdGlvbiA9IFJlZmxlY3QuZ2V0KF9pbmplY3RvciwgXCJpbmplY3RcIiArIF9jb25zdHJ1Y3Rvci5uYW1lKTtcclxuICAgICAgaWYgKCFpbmplY3Rpb24pIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiTm8gaW5qZWN0aW9uIGRlY29yYXRvciBkZWZpbmVkIGZvciBcIiArIF9jb25zdHJ1Y3Rvci5uYW1lKTtcclxuICAgICAgfVxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2NvbnN0cnVjdG9yLnByb3RvdHlwZSwgXCJ1c2VSZW5kZXJEYXRhXCIsIHtcclxuICAgICAgICB2YWx1ZTogaW5qZWN0aW9uXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBjbGFzcyBSZW5kZXJJbmplY3RvclNoYWRlciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIGRlY29yYXRlKF9jb25zdHJ1Y3RvcjogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9jb25zdHJ1Y3RvciwgXCJ1c2VQcm9ncmFtXCIsIHtcclxuICAgICAgICB2YWx1ZTogUmVuZGVySW5qZWN0b3JTaGFkZXIudXNlUHJvZ3JhbVxyXG4gICAgICB9KTtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9jb25zdHJ1Y3RvciwgXCJkZWxldGVQcm9ncmFtXCIsIHtcclxuICAgICAgICB2YWx1ZTogUmVuZGVySW5qZWN0b3JTaGFkZXIuZGVsZXRlUHJvZ3JhbVxyXG4gICAgICB9KTtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9jb25zdHJ1Y3RvciwgXCJjcmVhdGVQcm9ncmFtXCIsIHtcclxuICAgICAgICB2YWx1ZTogUmVuZGVySW5qZWN0b3JTaGFkZXIuY3JlYXRlUHJvZ3JhbVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIHVzZVByb2dyYW0odGhpczogdHlwZW9mIFNoYWRlcik6IHZvaWQge1xyXG4gICAgICBpZiAoIXRoaXMucHJvZ3JhbSlcclxuICAgICAgICB0aGlzLmNyZWF0ZVByb2dyYW0oKTtcclxuICAgICAgbGV0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJPcGVyYXRvci5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcbiAgICAgIGNyYzMudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xyXG4gICAgICBjcmMzLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuYXR0cmlidXRlc1tcImFfcG9zaXRpb25cIl0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZGVsZXRlUHJvZ3JhbSh0aGlzOiB0eXBlb2YgU2hhZGVyKTogdm9pZCB7XHJcbiAgICAgIGxldCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyT3BlcmF0b3IuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG4gICAgICBpZiAodGhpcy5wcm9ncmFtKSB7XHJcbiAgICAgICAgY3JjMy5kZWxldGVQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuYXR0cmlidXRlcztcclxuICAgICAgICBkZWxldGUgdGhpcy51bmlmb3JtcztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgY3JlYXRlUHJvZ3JhbSh0aGlzOiB0eXBlb2YgU2hhZGVyKTogdm9pZCB7XHJcbiAgICAgIERlYnVnLmZ1ZGdlKFwiQ3JlYXRlIHNoYWRlciBwcm9ncmFtXCIsIHRoaXMubmFtZSk7XHJcbiAgICAgIGxldCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyT3BlcmF0b3IuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG4gICAgICBsZXQgcHJvZ3JhbTogV2ViR0xQcm9ncmFtID0gY3JjMy5jcmVhdGVQcm9ncmFtKCk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY3JjMy5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgUmVuZGVyT3BlcmF0b3IuYXNzZXJ0PFdlYkdMU2hhZGVyPihjb21waWxlU2hhZGVyKHRoaXMuZ2V0VmVydGV4U2hhZGVyU291cmNlKCksIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVkVSVEVYX1NIQURFUikpKTtcclxuICAgICAgICBjcmMzLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBSZW5kZXJPcGVyYXRvci5hc3NlcnQ8V2ViR0xTaGFkZXI+KGNvbXBpbGVTaGFkZXIodGhpcy5nZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZSQUdNRU5UX1NIQURFUikpKTtcclxuICAgICAgICBjcmMzLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xyXG4gICAgICAgIGxldCBlcnJvcjogc3RyaW5nID0gUmVuZGVyT3BlcmF0b3IuYXNzZXJ0PHN0cmluZz4oY3JjMy5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSk7XHJcbiAgICAgICAgaWYgKGVycm9yICE9PSBcIlwiKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBsaW5raW5nIFNoYWRlcjogXCIgKyBlcnJvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xyXG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IGRldGVjdEF0dHJpYnV0ZXMoKTtcclxuICAgICAgICB0aGlzLnVuaWZvcm1zID0gZGV0ZWN0VW5pZm9ybXMoKTtcclxuXHJcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xyXG4gICAgICAgIERlYnVnLmVycm9yKF9lcnJvcik7XHJcbiAgICAgICAgZGVidWdnZXI7XHJcbiAgICAgIH1cclxuXHJcblxyXG4gICAgICBmdW5jdGlvbiBjb21waWxlU2hhZGVyKF9zaGFkZXJDb2RlOiBzdHJpbmcsIF9zaGFkZXJUeXBlOiBHTGVudW0pOiBXZWJHTFNoYWRlciB8IG51bGwge1xyXG4gICAgICAgIGxldCB3ZWJHTFNoYWRlcjogV2ViR0xTaGFkZXIgPSBjcmMzLmNyZWF0ZVNoYWRlcihfc2hhZGVyVHlwZSk7XHJcbiAgICAgICAgY3JjMy5zaGFkZXJTb3VyY2Uod2ViR0xTaGFkZXIsIF9zaGFkZXJDb2RlKTtcclxuICAgICAgICBjcmMzLmNvbXBpbGVTaGFkZXIod2ViR0xTaGFkZXIpO1xyXG4gICAgICAgIGxldCBlcnJvcjogc3RyaW5nID0gUmVuZGVyT3BlcmF0b3IuYXNzZXJ0PHN0cmluZz4oY3JjMy5nZXRTaGFkZXJJbmZvTG9nKHdlYkdMU2hhZGVyKSk7XHJcbiAgICAgICAgaWYgKGVycm9yICE9PSBcIlwiKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBjb21waWxpbmcgc2hhZGVyOiBcIiArIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGFueSBjb21waWxhdGlvbiBlcnJvcnMuXHJcbiAgICAgICAgaWYgKCFjcmMzLmdldFNoYWRlclBhcmFtZXRlcih3ZWJHTFNoYWRlciwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5DT01QSUxFX1NUQVRVUykpIHtcclxuICAgICAgICAgIGFsZXJ0KGNyYzMuZ2V0U2hhZGVySW5mb0xvZyh3ZWJHTFNoYWRlcikpO1xyXG4gICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB3ZWJHTFNoYWRlcjtcclxuICAgICAgfVxyXG4gICAgICBmdW5jdGlvbiBkZXRlY3RBdHRyaWJ1dGVzKCk6IHsgW25hbWU6IHN0cmluZ106IG51bWJlciB9IHtcclxuICAgICAgICBsZXQgZGV0ZWN0ZWRBdHRyaWJ1dGVzOiB7IFtuYW1lOiBzdHJpbmddOiBudW1iZXIgfSA9IHt9O1xyXG4gICAgICAgIGxldCBhdHRyaWJ1dGVDb3VudDogbnVtYmVyID0gY3JjMy5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQUNUSVZFX0FUVFJJQlVURVMpO1xyXG4gICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBhdHRyaWJ1dGVDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICBsZXQgYXR0cmlidXRlSW5mbzogV2ViR0xBY3RpdmVJbmZvID0gUmVuZGVyT3BlcmF0b3IuYXNzZXJ0PFdlYkdMQWN0aXZlSW5mbz4oY3JjMy5nZXRBY3RpdmVBdHRyaWIocHJvZ3JhbSwgaSkpO1xyXG4gICAgICAgICAgaWYgKCFhdHRyaWJ1dGVJbmZvKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZGV0ZWN0ZWRBdHRyaWJ1dGVzW2F0dHJpYnV0ZUluZm8ubmFtZV0gPSBjcmMzLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIGF0dHJpYnV0ZUluZm8ubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZXRlY3RlZEF0dHJpYnV0ZXM7XHJcbiAgICAgIH1cclxuICAgICAgZnVuY3Rpb24gZGV0ZWN0VW5pZm9ybXMoKTogeyBbbmFtZTogc3RyaW5nXTogV2ViR0xVbmlmb3JtTG9jYXRpb24gfSB7XHJcbiAgICAgICAgbGV0IGRldGVjdGVkVW5pZm9ybXM6IHsgW25hbWU6IHN0cmluZ106IFdlYkdMVW5pZm9ybUxvY2F0aW9uIH0gPSB7fTtcclxuICAgICAgICBsZXQgdW5pZm9ybUNvdW50OiBudW1iZXIgPSBjcmMzLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BQ1RJVkVfVU5JRk9STVMpO1xyXG4gICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB1bmlmb3JtQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgbGV0IGluZm86IFdlYkdMQWN0aXZlSW5mbyA9IFJlbmRlck9wZXJhdG9yLmFzc2VydDxXZWJHTEFjdGl2ZUluZm8+KGNyYzMuZ2V0QWN0aXZlVW5pZm9ybShwcm9ncmFtLCBpKSk7XHJcbiAgICAgICAgICBpZiAoIWluZm8pIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBkZXRlY3RlZFVuaWZvcm1zW2luZm8ubmFtZV0gPSBSZW5kZXJPcGVyYXRvci5hc3NlcnQ8V2ViR0xVbmlmb3JtTG9jYXRpb24+KGNyYzMuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIGluZm8ubmFtZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGV0ZWN0ZWRVbmlmb3JtcztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBjbGFzcyBSZW5kZXJJbmplY3RvckNvYXQgZXh0ZW5kcyBSZW5kZXJJbmplY3RvciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIGRlY29yYXRlKF9jb25zdHJ1Y3RvcjogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgUmVuZGVySW5qZWN0b3IuaW5qZWN0KF9jb25zdHJ1Y3RvciwgUmVuZGVySW5qZWN0b3JDb2F0KTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGluamVjdENvYXRDb2xvcmVkKHRoaXM6IENvYXQsIF9zaGFkZXI6IHR5cGVvZiBTaGFkZXIsIF9jbXBNYXRlcmlhbDogQ29tcG9uZW50TWF0ZXJpYWwpOiB2b2lkIHtcclxuICAgICAgbGV0IGNvbG9yVW5pZm9ybUxvY2F0aW9uOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiA9IF9zaGFkZXIudW5pZm9ybXNbXCJ1X2NvbG9yXCJdO1xyXG4gICAgICBsZXQgY29sb3I6IENvbG9yID0gQ29sb3IuTVVMVElQTFkoKDxDb2F0Q29sb3JlZD50aGlzKS5jb2xvciwgX2NtcE1hdGVyaWFsLmNsclByaW1hcnkpO1xyXG4gICAgICBSZW5kZXJPcGVyYXRvci5nZXRSZW5kZXJpbmdDb250ZXh0KCkudW5pZm9ybTRmdihjb2xvclVuaWZvcm1Mb2NhdGlvbiwgY29sb3IuZ2V0QXJyYXkoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBpbmplY3RDb2F0VGV4dHVyZWQodGhpczogQ29hdCwgX3NoYWRlcjogdHlwZW9mIFNoYWRlciwgX2NtcE1hdGVyaWFsOiBDb21wb25lbnRNYXRlcmlhbCk6IHZvaWQge1xyXG4gICAgICBsZXQgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlck9wZXJhdG9yLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcclxuICAgICAgaWYgKHRoaXMucmVuZGVyRGF0YSkge1xyXG4gICAgICAgIC8vIGJ1ZmZlcnMgZXhpc3RcclxuICAgICAgICBsZXQgY29sb3JVbmlmb3JtTG9jYXRpb246IFdlYkdMVW5pZm9ybUxvY2F0aW9uID0gX3NoYWRlci51bmlmb3Jtc1tcInVfY29sb3JcIl07XHJcbiAgICAgICAgbGV0IGNvbG9yOiBDb2xvciA9IENvbG9yLk1VTFRJUExZKCg8Q29hdFRleHR1cmVkPnRoaXMpLmNvbG9yLCBfY21wTWF0ZXJpYWwuY2xyUHJpbWFyeSk7XHJcbiAgICAgICAgUmVuZGVyT3BlcmF0b3IuZ2V0UmVuZGVyaW5nQ29udGV4dCgpLnVuaWZvcm00ZnYoY29sb3JVbmlmb3JtTG9jYXRpb24sIGNvbG9yLmdldEFycmF5KCkpO1xyXG5cclxuICAgICAgICBjcmMzLmFjdGl2ZVRleHR1cmUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFMCk7XHJcbiAgICAgICAgY3JjMy5iaW5kVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIHRoaXMucmVuZGVyRGF0YVtcInRleHR1cmUwXCJdKTtcclxuICAgICAgICBjcmMzLnVuaWZvcm0xaShfc2hhZGVyLnVuaWZvcm1zW1widV90ZXh0dXJlXCJdLCAwKTtcclxuICAgICAgICBjcmMzLnVuaWZvcm1NYXRyaXgzZnYoX3NoYWRlci51bmlmb3Jtc1tcInVfcGl2b3RcIl0sIGZhbHNlLCBfY21wTWF0ZXJpYWwucGl2b3QuZ2V0KCkpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHRoaXMucmVuZGVyRGF0YSA9IHt9O1xyXG4gICAgICAgIC8vIFRPRE86IGNoZWNrIGlmIGFsbCBXZWJHTC1DcmVhdGlvbnMgYXJlIGFzc2VydGVkXHJcbiAgICAgICAgY29uc3QgdGV4dHVyZTogV2ViR0xUZXh0dXJlID0gUmVuZGVyTWFuYWdlci5hc3NlcnQ8V2ViR0xUZXh0dXJlPihjcmMzLmNyZWF0ZVRleHR1cmUoKSk7XHJcbiAgICAgICAgY3JjMy5iaW5kVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIHRleHR1cmUpO1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY3JjMy50ZXhJbWFnZTJEKGNyYzMuVEVYVFVSRV8yRCwgMCwgY3JjMy5SR0JBLCBjcmMzLlJHQkEsIGNyYzMuVU5TSUdORURfQllURSwgKDxDb2F0VGV4dHVyZWQ+dGhpcykudGV4dHVyZS5pbWFnZSk7XHJcbiAgICAgICAgICBjcmMzLnRleEltYWdlMkQoXHJcbiAgICAgICAgICAgIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgMCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5SR0JBLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlJHQkEsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5TSUdORURfQllURSxcclxuICAgICAgICAgICAgKDxDb2F0VGV4dHVyZWQ+dGhpcykudGV4dHVyZS5pbWFnZVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcclxuICAgICAgICAgIERlYnVnLmVycm9yKF9lcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNyYzMudGV4UGFyYW1ldGVyaShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV9NQUdfRklMVEVSLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk5FQVJFU1QpO1xyXG4gICAgICAgIGNyYzMudGV4UGFyYW1ldGVyaShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV9NSU5fRklMVEVSLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk5FQVJFU1QpO1xyXG4gICAgICAgIGNyYzMuZ2VuZXJhdGVNaXBtYXAoY3JjMy5URVhUVVJFXzJEKTtcclxuICAgICAgICB0aGlzLnJlbmRlckRhdGFbXCJ0ZXh0dXJlMFwiXSA9IHRleHR1cmU7XHJcblxyXG4gICAgICAgIGNyYzMuYmluZFRleHR1cmUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBudWxsKTtcclxuXHJcbiAgICAgICAgdGhpcy51c2VSZW5kZXJEYXRhKF9zaGFkZXIsIF9jbXBNYXRlcmlhbCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGluamVjdENvYXRNYXRDYXAodGhpczogQ29hdCwgX3NoYWRlcjogdHlwZW9mIFNoYWRlciwgX2NtcE1hdGVyaWFsOiBDb21wb25lbnRNYXRlcmlhbCk6IHZvaWQge1xyXG4gICAgICBsZXQgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlck9wZXJhdG9yLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcclxuXHJcbiAgICAgIGxldCBjb2xvclVuaWZvcm1Mb2NhdGlvbjogV2ViR0xVbmlmb3JtTG9jYXRpb24gPSBfc2hhZGVyLnVuaWZvcm1zW1widV90aW50X2NvbG9yXCJdO1xyXG4gICAgICBsZXQgeyByLCBnLCBiLCBhIH0gPSAoPENvYXRNYXRDYXA+dGhpcykuY29sb3I7XHJcbiAgICAgIGxldCB0aW50Q29sb3JBcnJheTogRmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShbciwgZywgYiwgYV0pO1xyXG4gICAgICBjcmMzLnVuaWZvcm00ZnYoY29sb3JVbmlmb3JtTG9jYXRpb24sIHRpbnRDb2xvckFycmF5KTtcclxuXHJcbiAgICAgIGxldCBmbG9hdFVuaWZvcm1Mb2NhdGlvbjogV2ViR0xVbmlmb3JtTG9jYXRpb24gPSBfc2hhZGVyLnVuaWZvcm1zW1wic2hhZGVfc21vb3RoXCJdO1xyXG4gICAgICBsZXQgc2hhZGVTbW9vdGg6IG51bWJlciA9ICg8Q29hdE1hdENhcD50aGlzKS5zaGFkZVNtb290aDtcclxuICAgICAgY3JjMy51bmlmb3JtMWkoZmxvYXRVbmlmb3JtTG9jYXRpb24sIHNoYWRlU21vb3RoKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLnJlbmRlckRhdGEpIHtcclxuICAgICAgICAvLyBidWZmZXJzIGV4aXN0XHJcbiAgICAgICAgY3JjMy5hY3RpdmVUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRTApO1xyXG4gICAgICAgIGNyYzMuYmluZFRleHR1cmUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCB0aGlzLnJlbmRlckRhdGFbXCJ0ZXh0dXJlMFwiXSk7XHJcbiAgICAgICAgY3JjMy51bmlmb3JtMWkoX3NoYWRlci51bmlmb3Jtc1tcInVfdGV4dHVyZVwiXSwgMCk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJEYXRhID0ge307XHJcbiAgICAgICAgLy8gVE9ETzogY2hlY2sgaWYgYWxsIFdlYkdMLUNyZWF0aW9ucyBhcmUgYXNzZXJ0ZWRcclxuICAgICAgICBjb25zdCB0ZXh0dXJlOiBXZWJHTFRleHR1cmUgPSBSZW5kZXJNYW5hZ2VyLmFzc2VydDxXZWJHTFRleHR1cmU+KGNyYzMuY3JlYXRlVGV4dHVyZSgpKTtcclxuICAgICAgICBjcmMzLmJpbmRUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjcmMzLnRleEltYWdlMkQoY3JjMy5URVhUVVJFXzJELCAwLCBjcmMzLlJHQkEsIGNyYzMuUkdCQSwgY3JjMy5VTlNJR05FRF9CWVRFLCAoPENvYXRNYXRDYXA+dGhpcykudGV4dHVyZS5pbWFnZSk7XHJcbiAgICAgICAgICBjcmMzLnRleEltYWdlMkQoXHJcbiAgICAgICAgICAgIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgMCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5SR0JBLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlJHQkEsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5TSUdORURfQllURSxcclxuICAgICAgICAgICAgKDxDb2F0TWF0Q2FwPnRoaXMpLnRleHR1cmUuaW1hZ2VcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XHJcbiAgICAgICAgICBEZWJ1Zy5lcnJvcihfZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjcmMzLnRleFBhcmFtZXRlcmkoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfTUFHX0ZJTFRFUiwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ORUFSRVNUKTtcclxuICAgICAgICBjcmMzLnRleFBhcmFtZXRlcmkoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfTUlOX0ZJTFRFUiwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ORUFSRVNUKTtcclxuICAgICAgICBjcmMzLmdlbmVyYXRlTWlwbWFwKGNyYzMuVEVYVFVSRV8yRCk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJEYXRhW1widGV4dHVyZTBcIl0gPSB0ZXh0dXJlO1xyXG5cclxuICAgICAgICBjcmMzLmJpbmRUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgbnVsbCk7XHJcbiAgICAgICAgdGhpcy51c2VSZW5kZXJEYXRhKF9zaGFkZXIsIF9jbXBNYXRlcmlhbCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgaW50ZXJmYWNlIFJlbmRlckJ1ZmZlcnMge1xyXG4gICAgdmVydGljZXM6IFdlYkdMQnVmZmVyO1xyXG4gICAgaW5kaWNlczogV2ViR0xCdWZmZXI7XHJcbiAgICBuSW5kaWNlczogbnVtYmVyO1xyXG4gICAgdGV4dHVyZVVWczogV2ViR0xCdWZmZXI7XHJcbiAgICBub3JtYWxzRmFjZTogV2ViR0xCdWZmZXI7XHJcbiAgfVxyXG5cclxuICBleHBvcnQgY2xhc3MgUmVuZGVySW5qZWN0b3JNZXNoIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgZGVjb3JhdGUoX2NvbnN0cnVjdG9yOiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2NvbnN0cnVjdG9yLnByb3RvdHlwZSwgXCJ1c2VSZW5kZXJCdWZmZXJzXCIsIHtcclxuICAgICAgICB2YWx1ZTogUmVuZGVySW5qZWN0b3JNZXNoLnVzZVJlbmRlckJ1ZmZlcnNcclxuICAgICAgfSk7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfY29uc3RydWN0b3IucHJvdG90eXBlLCBcImNyZWF0ZVJlbmRlckJ1ZmZlcnNcIiwge1xyXG4gICAgICAgIHZhbHVlOiBSZW5kZXJJbmplY3Rvck1lc2guY3JlYXRlUmVuZGVyQnVmZmVyc1xyXG4gICAgICB9KTtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIFwiZGVsZXRlUmVuZGVyQnVmZmVyc1wiLCB7XHJcbiAgICAgICAgdmFsdWU6IFJlbmRlckluamVjdG9yTWVzaC5kZWxldGVSZW5kZXJCdWZmZXJzXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgY3JlYXRlUmVuZGVyQnVmZmVycyh0aGlzOiBNZXNoKTogdm9pZCB7XHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiY3JlYXRlUmVuZGVyQnVmZmVyc1wiLCB0aGlzKTtcclxuICAgICAgLy8gcmV0dXJuO1xyXG5cclxuICAgICAgbGV0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJPcGVyYXRvci5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcbiAgICAgIGxldCB2ZXJ0aWNlczogV2ViR0xCdWZmZXIgPSBSZW5kZXJPcGVyYXRvci5hc3NlcnQ8V2ViR0xCdWZmZXI+KGNyYzMuY3JlYXRlQnVmZmVyKCkpO1xyXG4gICAgICBjcmMzLmJpbmRCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BUlJBWV9CVUZGRVIsIHZlcnRpY2VzKTtcclxuICAgICAgY3JjMy5idWZmZXJEYXRhKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQVJSQVlfQlVGRkVSLCB0aGlzLnZlcnRpY2VzLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlNUQVRJQ19EUkFXKTtcclxuXHJcbiAgICAgIGxldCBpbmRpY2VzOiBXZWJHTEJ1ZmZlciA9IFJlbmRlck9wZXJhdG9yLmFzc2VydDxXZWJHTEJ1ZmZlcj4oY3JjMy5jcmVhdGVCdWZmZXIoKSk7XHJcbiAgICAgIGNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBpbmRpY2VzKTtcclxuICAgICAgY3JjMy5idWZmZXJEYXRhKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kaWNlcywgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5TVEFUSUNfRFJBVyk7XHJcblxyXG4gICAgICBsZXQgdGV4dHVyZVVWczogV2ViR0xCdWZmZXIgPSBjcmMzLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAgICBjcmMzLmJpbmRCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BUlJBWV9CVUZGRVIsIHRleHR1cmVVVnMpO1xyXG4gICAgICBjcmMzLmJ1ZmZlckRhdGEoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BUlJBWV9CVUZGRVIsIHRoaXMudGV4dHVyZVVWcywgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5TVEFUSUNfRFJBVyk7XHJcblxyXG4gICAgICBsZXQgbm9ybWFsc0ZhY2U6IFdlYkdMQnVmZmVyID0gUmVuZGVyT3BlcmF0b3IuYXNzZXJ0PFdlYkdMQnVmZmVyPihjcmMzLmNyZWF0ZUJ1ZmZlcigpKTtcclxuICAgICAgY3JjMy5iaW5kQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQVJSQVlfQlVGRkVSLCBub3JtYWxzRmFjZSk7XHJcbiAgICAgIGNyYzMuYnVmZmVyRGF0YShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgdGhpcy5ub3JtYWxzRmFjZSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5TVEFUSUNfRFJBVyk7XHJcblxyXG4gICAgICBsZXQgcmVuZGVyQnVmZmVyczogUmVuZGVyQnVmZmVycyA9IHtcclxuICAgICAgICB2ZXJ0aWNlczogdmVydGljZXMsXHJcbiAgICAgICAgaW5kaWNlczogaW5kaWNlcyxcclxuICAgICAgICBuSW5kaWNlczogdGhpcy5nZXRJbmRleENvdW50KCksXHJcbiAgICAgICAgdGV4dHVyZVVWczogdGV4dHVyZVVWcyxcclxuICAgICAgICBub3JtYWxzRmFjZTogbm9ybWFsc0ZhY2VcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHRoaXMucmVuZGVyQnVmZmVycyA9IHJlbmRlckJ1ZmZlcnM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyB1c2VSZW5kZXJCdWZmZXJzKHRoaXM6IE1lc2gsIF9zaGFkZXI6IHR5cGVvZiBTaGFkZXIsIF93b3JsZDogTWF0cml4NHg0LCBfcHJvamVjdGlvbjogTWF0cml4NHg0LCBfaWQ/OiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgLy8gY29uc29sZS5sb2coXCJ1c2VSZW5kZXJCdWZmZXJzXCIsIHRoaXMpO1xyXG4gICAgICAvLyByZXR1cm47XHJcbiAgICAgIGxldCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyT3BlcmF0b3IuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG5cclxuICAgICAgbGV0IGFQb3NpdGlvbjogbnVtYmVyID0gX3NoYWRlci5hdHRyaWJ1dGVzW1wiYV9wb3NpdGlvblwiXTtcclxuICAgICAgY3JjMy5iaW5kQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQVJSQVlfQlVGRkVSLCB0aGlzLnJlbmRlckJ1ZmZlcnMudmVydGljZXMpO1xyXG4gICAgICBjcmMzLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGFQb3NpdGlvbik7XHJcbiAgICAgIFJlbmRlck9wZXJhdG9yLnNldEF0dHJpYnV0ZVN0cnVjdHVyZShhUG9zaXRpb24sIE1lc2guZ2V0QnVmZmVyU3BlY2lmaWNhdGlvbigpKTtcclxuXHJcbiAgICAgIGNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLnJlbmRlckJ1ZmZlcnMuaW5kaWNlcyk7XHJcblxyXG4gICAgICBsZXQgdVByb2plY3Rpb246IFdlYkdMVW5pZm9ybUxvY2F0aW9uID0gX3NoYWRlci51bmlmb3Jtc1tcInVfcHJvamVjdGlvblwiXTtcclxuICAgICAgY3JjMy51bmlmb3JtTWF0cml4NGZ2KHVQcm9qZWN0aW9uLCBmYWxzZSwgX3Byb2plY3Rpb24uZ2V0KCkpO1xyXG5cclxuICAgICAgLy8gZmVlZCBpbiBmYWNlIG5vcm1hbHMgaWYgc2hhZGVyIGFjY2VwdHMgdV93b3JsZC4gXHJcbiAgICAgIGxldCB1V29ybGQ6IFdlYkdMVW5pZm9ybUxvY2F0aW9uID0gX3NoYWRlci51bmlmb3Jtc1tcInVfd29ybGRcIl07XHJcbiAgICAgIGlmICh1V29ybGQpIHtcclxuICAgICAgICBjcmMzLnVuaWZvcm1NYXRyaXg0ZnYodVdvcmxkLCBmYWxzZSwgX3dvcmxkLmdldCgpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IGFOb3JtYWw6IG51bWJlciA9IF9zaGFkZXIuYXR0cmlidXRlc1tcImFfbm9ybWFsXCJdO1xyXG4gICAgICBpZiAoYU5vcm1hbCkge1xyXG4gICAgICAgIGNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgdGhpcy5yZW5kZXJCdWZmZXJzLm5vcm1hbHNGYWNlKTtcclxuICAgICAgICBjcmMzLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGFOb3JtYWwpO1xyXG4gICAgICAgIFJlbmRlck9wZXJhdG9yLnNldEF0dHJpYnV0ZVN0cnVjdHVyZShhTm9ybWFsLCBNZXNoLmdldEJ1ZmZlclNwZWNpZmljYXRpb24oKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGZlZWQgaW4gdGV4dHVyZSBjb29yZGluYXRlcyBpZiBzaGFkZXIgYWNjZXB0cyBhX3RleHR1cmVVVnNcclxuICAgICAgbGV0IGFUZXh0dXJlVVZzOiBudW1iZXIgPSBfc2hhZGVyLmF0dHJpYnV0ZXNbXCJhX3RleHR1cmVVVnNcIl07XHJcbiAgICAgIGlmIChhVGV4dHVyZVVWcykge1xyXG4gICAgICAgIGNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgdGhpcy5yZW5kZXJCdWZmZXJzLnRleHR1cmVVVnMpO1xyXG4gICAgICAgIGNyYzMuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYVRleHR1cmVVVnMpOyAvLyBlbmFibGUgdGhlIGJ1ZmZlclxyXG4gICAgICAgIGNyYzMudmVydGV4QXR0cmliUG9pbnRlcihhVGV4dHVyZVVWcywgMiwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GTE9BVCwgZmFsc2UsIDAsIDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBmZWVkIGluIGFuIGlkIG9mIHRoZSBub2RlIGlmIHNoYWRlciBhY2NlcHRzIHVfaWQuIFVzZWQgZm9yIHBpY2tpbmdcclxuICAgICAgbGV0IHVJZDogV2ViR0xVbmlmb3JtTG9jYXRpb24gPSBfc2hhZGVyLnVuaWZvcm1zW1widV9pZFwiXTtcclxuICAgICAgaWYgKHVJZClcclxuICAgICAgICBSZW5kZXJPcGVyYXRvci5nZXRSZW5kZXJpbmdDb250ZXh0KCkudW5pZm9ybTFpKHVJZCwgX2lkKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGRlbGV0ZVJlbmRlckJ1ZmZlcnMoX3JlbmRlckJ1ZmZlcnM6IFJlbmRlckJ1ZmZlcnMpOiB2b2lkIHtcclxuICAgICAgLy8gY29uc29sZS5sb2coXCJkZWxldGVSZW5kZXJCdWZmZXJzXCIsIHRoaXMpO1xyXG4gICAgICAvLyByZXR1cm47XHJcbiAgICAgIGxldCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyT3BlcmF0b3IuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG4gICAgICBpZiAoX3JlbmRlckJ1ZmZlcnMpIHtcclxuICAgICAgICBjcmMzLmJpbmRCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BUlJBWV9CVUZGRVIsIG51bGwpO1xyXG4gICAgICAgIGNyYzMuZGVsZXRlQnVmZmVyKF9yZW5kZXJCdWZmZXJzLnZlcnRpY2VzKTtcclxuICAgICAgICBjcmMzLmRlbGV0ZUJ1ZmZlcihfcmVuZGVyQnVmZmVycy50ZXh0dXJlVVZzKTtcclxuICAgICAgICBjcmMzLmJpbmRCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbnVsbCk7XHJcbiAgICAgICAgY3JjMy5kZWxldGVCdWZmZXIoX3JlbmRlckJ1ZmZlcnMuaW5kaWNlcyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBLZWVwcyBhIGRlcG90IG9mIG9iamVjdHMgdGhhdCBoYXZlIGJlZW4gbWFya2VkIGZvciByZXVzZSwgc29ydGVkIGJ5IHR5cGUuICBcclxuICAgKiBVc2luZyBbW1JlY3ljbGVyXV0gcmVkdWNlcyBsb2FkIG9uIHRoZSBjYXJiYWdlIGNvbGxlY3RvciBhbmQgdGh1cyBzdXBwb3J0cyBzbW9vdGggcGVyZm9ybWFuY2VcclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgUmVjeWNsZXIge1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZGVwb3Q6IHsgW3R5cGU6IHN0cmluZ106IE9iamVjdFtdIH0gPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZldGNoZXMgYW4gb2JqZWN0IG9mIHRoZSByZXF1ZXN0ZWQgdHlwZSBmcm9tIHRoZSBkZXBvdCwgb3IgcmV0dXJucyBhIG5ldyBvbmUsIGlmIHRoZSBkZXBvdCB3YXMgZW1wdHkgXHJcbiAgICAgKiBAcGFyYW0gX1QgVGhlIGNsYXNzIGlkZW50aWZpZXIgb2YgdGhlIGRlc2lyZWQgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0PFQ+KF9UOiBuZXcgKCkgPT4gVCk6IFQge1xyXG4gICAgICBsZXQga2V5OiBzdHJpbmcgPSBfVC5uYW1lO1xyXG4gICAgICBsZXQgaW5zdGFuY2VzOiBPYmplY3RbXSA9IFJlY3ljbGVyLmRlcG90W2tleV07XHJcbiAgICAgIGlmIChpbnN0YW5jZXMgJiYgaW5zdGFuY2VzLmxlbmd0aCA+IDApXHJcbiAgICAgICAgcmV0dXJuIDxUPmluc3RhbmNlcy5wb3AoKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHJldHVybiBuZXcgX1QoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gYW4gb2JqZWN0IG9mIHRoZSByZXF1ZXN0ZWQgdHlwZSBpbiB0aGUgZGVwb3QsIGJ1dCBkb2VzIG5vdCByZW1vdmUgaXQgdGhlcmUuIFxyXG4gICAgICogSWYgbm8gb2JqZWN0IG9mIHRoZSByZXF1ZXN0ZWQgdHlwZSB3YXMgaW4gdGhlIGRlcG90LCBvbmUgaXMgY3JlYXRlZCwgc3RvcmVkIGFuZCBib3Jyb3dlZC5cclxuICAgICAqIEZvciBzaG9ydCB0ZXJtIHVzYWdlIG9mIG9iamVjdHMgaW4gYSBsb2NhbCBzY29wZSwgd2hlbiB0aGVyZSB3aWxsIGJlIG5vIG90aGVyIGNhbGwgdG8gUmVjeWNsZXIuZ2V0IG9yIC5ib3Jyb3chXHJcbiAgICAgKiBAcGFyYW0gX1QgVGhlIGNsYXNzIGlkZW50aWZpZXIgb2YgdGhlIGRlc2lyZWQgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgYm9ycm93PFQ+KF9UOiBuZXcgKCkgPT4gVCk6IFQge1xyXG4gICAgICBsZXQgdDogVDtcclxuICAgICAgbGV0IGtleTogc3RyaW5nID0gX1QubmFtZTtcclxuICAgICAgbGV0IGluc3RhbmNlczogT2JqZWN0W10gPSBSZWN5Y2xlci5kZXBvdFtrZXldO1xyXG4gICAgICBpZiAoIWluc3RhbmNlcyB8fCBpbnN0YW5jZXMubGVuZ3RoID09IDApIHtcclxuICAgICAgICB0ID0gbmV3IF9UKCk7XHJcbiAgICAgICAgUmVjeWNsZXIuc3RvcmUodCk7XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIDxUPmluc3RhbmNlc1swXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0b3JlcyB0aGUgb2JqZWN0IGluIHRoZSBkZXBvdCBmb3IgbGF0ZXIgcmVjeWNsaW5nLiBVc2VycyBhcmUgcmVzcG9uc2libGUgZm9yIHRocm93aW5nIGluIG9iamVjdHMgdGhhdCBhcmUgYWJvdXQgdG8gbG9vc2Ugc2NvcGUgYW5kIGFyZSBub3QgcmVmZXJlbmNlZCBieSBhbnkgb3RoZXJcclxuICAgICAqIEBwYXJhbSBfaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzdG9yZShfaW5zdGFuY2U6IE9iamVjdCk6IHZvaWQge1xyXG4gICAgICBsZXQga2V5OiBzdHJpbmcgPSBfaW5zdGFuY2UuY29uc3RydWN0b3IubmFtZTtcclxuICAgICAgLy9EZWJ1Zy5sb2coa2V5KTtcclxuICAgICAgbGV0IGluc3RhbmNlczogT2JqZWN0W10gPSBSZWN5Y2xlci5kZXBvdFtrZXldIHx8IFtdO1xyXG4gICAgICBpbnN0YW5jZXMucHVzaChfaW5zdGFuY2UpO1xyXG4gICAgICBSZWN5Y2xlci5kZXBvdFtrZXldID0gaW5zdGFuY2VzO1xyXG4gICAgICAvLyBEZWJ1Zy5sb2coYE9iamVjdE1hbmFnZXIuZGVwb3RbJHtrZXl9XTogJHtPYmplY3RNYW5hZ2VyLmRlcG90W2tleV0ubGVuZ3RofWApO1xyXG4gICAgICAvL0RlYnVnLmxvZyh0aGlzLmRlcG90KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEVtcHR5cyB0aGUgZGVwb3Qgb2YgYSBnaXZlbiB0eXBlLCBsZWF2aW5nIHRoZSBvYmplY3RzIGZvciB0aGUgZ2FyYmFnZSBjb2xsZWN0b3IuIE1heSByZXN1bHQgaW4gYSBzaG9ydCBzdGFsbCB3aGVuIG1hbnkgb2JqZWN0cyB3ZXJlIGluXHJcbiAgICAgKiBAcGFyYW0gX1RcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBkdW1wPFQ+KF9UOiBuZXcgKCkgPT4gVCk6IHZvaWQge1xyXG4gICAgICBsZXQga2V5OiBzdHJpbmcgPSBfVC5uYW1lO1xyXG4gICAgICBSZWN5Y2xlci5kZXBvdFtrZXldID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbXB0eXMgYWxsIGRlcG90cywgbGVhdmluZyBhbGwgb2JqZWN0cyB0byB0aGUgZ2FyYmFnZSBjb2xsZWN0b3IuIE1heSByZXN1bHQgaW4gYSBzaG9ydCBzdGFsbCB3aGVuIG1hbnkgb2JqZWN0cyB3ZXJlIGluXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZHVtcEFsbCgpOiB2b2lkIHtcclxuICAgICAgUmVjeWNsZXIuZGVwb3QgPSB7fTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBTdG9yZXMgYW5kIG1hbmlwdWxhdGVzIGEgdHdvZGltZW5zaW9uYWwgdmVjdG9yIGNvbXByaXNlZCBvZiB0aGUgY29tcG9uZW50cyB4IGFuZCB5XHJcbiAgICogYGBgcGxhaW50ZXh0XHJcbiAgICogICAgICAgICAgICAreVxyXG4gICAqICAgICAgICAgICAgIHxfXyAreFxyXG4gICAqIGBgYFxyXG4gICAqIEBhdXRob3JzIEx1a2FzIFNjaGV1ZXJsZSwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgVmVjdG9yMiBleHRlbmRzIE11dGFibGUge1xyXG4gICAgcHJpdmF0ZSBkYXRhOiBGbG9hdDMyQXJyYXk7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF94OiBudW1iZXIgPSAwLCBfeTogbnVtYmVyID0gMCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KFtfeCwgX3ldKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgeCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5kYXRhWzBdO1xyXG4gICAgfVxyXG4gICAgZ2V0IHkoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZGF0YVsxXTtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgeChfeDogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuZGF0YVswXSA9IF94O1xyXG4gICAgfVxyXG4gICAgc2V0IHkoX3k6IG51bWJlcikge1xyXG4gICAgICB0aGlzLmRhdGFbMV0gPSBfeTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIGdldCBtYWduaXR1ZGUoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIE1hdGguaHlwb3QoLi4udGhpcy5kYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHNxdWFyZSBvZiB0aGUgbWFnbml0dWRlIG9mIHRoZSB2ZWN0b3Igd2l0aG91dCBjYWxjdWxhdGluZyBhIHNxdWFyZSByb290LiBGYXN0ZXIgZm9yIHNpbXBsZSBwcm94aW1pdHkgZXZhbHVhdGlvbi5cclxuICAgICAqL1xyXG4gICAgZ2V0IG1hZ25pdHVkZVNxdWFyZWQoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIFZlY3RvcjIuRE9UKHRoaXMsIHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEEgc2hvcnRoYW5kIGZvciB3cml0aW5nIGBuZXcgVmVjdG9yMigwLCAwKWAuXHJcbiAgICAgKiBAcmV0dXJucyBBIG5ldyB2ZWN0b3Igd2l0aCB0aGUgdmFsdWVzICgwLCAwKVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFpFUk8oKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCB2ZWN0b3I6IFZlY3RvcjIgPSBuZXcgVmVjdG9yMigpO1xyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEEgc2hvcnRoYW5kIGZvciB3cml0aW5nIGBuZXcgVmVjdG9yMihfc2NhbGUsIF9zY2FsZSlgLlxyXG4gICAgICogQHBhcmFtIF9zY2FsZSB0aGUgc2NhbGUgb2YgdGhlIHZlY3Rvci4gRGVmYXVsdDogMVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIE9ORShfc2NhbGU6IG51bWJlciA9IDEpOiBWZWN0b3IyIHtcclxuICAgICAgbGV0IHZlY3RvcjogVmVjdG9yMiA9IG5ldyBWZWN0b3IyKF9zY2FsZSwgX3NjYWxlKTtcclxuICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBBIHNob3J0aGFuZCBmb3Igd3JpdGluZyBgbmV3IFZlY3RvcjIoMCwgeSlgLlxyXG4gICAgICogQHBhcmFtIF9zY2FsZSBUaGUgbnVtYmVyIHRvIHdyaXRlIGluIHRoZSB5IGNvb3JkaW5hdGUuIERlZmF1bHQ6IDFcclxuICAgICAqIEByZXR1cm5zIEEgbmV3IHZlY3RvciB3aXRoIHRoZSB2YWx1ZXMgKDAsIF9zY2FsZSlcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBZKF9zY2FsZTogbnVtYmVyID0gMSk6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgdmVjdG9yOiBWZWN0b3IyID0gbmV3IFZlY3RvcjIoMCwgX3NjYWxlKTtcclxuICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBBIHNob3J0aGFuZCBmb3Igd3JpdGluZyBgbmV3IFZlY3RvcjIoeCwgMClgLlxyXG4gICAgICogQHBhcmFtIF9zY2FsZSBUaGUgbnVtYmVyIHRvIHdyaXRlIGluIHRoZSB4IGNvb3JkaW5hdGUuIERlZmF1bHQ6IDFcclxuICAgICAqIEByZXR1cm5zIEEgbmV3IHZlY3RvciB3aXRoIHRoZSB2YWx1ZXMgKF9zY2FsZSwgMClcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBYKF9zY2FsZTogbnVtYmVyID0gMSk6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgdmVjdG9yOiBWZWN0b3IyID0gbmV3IFZlY3RvcjIoX3NjYWxlLCAwKTtcclxuICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIFRSQU5TRk9STUFUSU9OKF92ZWN0b3I6IFZlY3RvcjIsIF9tYXRyaXg6IE1hdHJpeDN4MywgX2luY2x1ZGVUcmFuc2xhdGlvbjogYm9vbGVhbiA9IHRydWUpOiBWZWN0b3IyIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMiA9IG5ldyBWZWN0b3IyKCk7XHJcbiAgICAgIGxldCBtOiBGbG9hdDMyQXJyYXkgPSBfbWF0cml4LmdldCgpO1xyXG4gICAgICBsZXQgW3gsIHldID0gX3ZlY3Rvci5nZXQoKTtcclxuICAgICAgcmVzdWx0LnggPSBtWzBdICogeCArIG1bM10gKiB5O1xyXG4gICAgICByZXN1bHQueSA9IG1bMV0gKiB4ICsgbVs0XSAqIHk7XHJcblxyXG4gICAgICBpZiAoX2luY2x1ZGVUcmFuc2xhdGlvbikge1xyXG4gICAgICAgIHJlc3VsdC5hZGQoX21hdHJpeC50cmFuc2xhdGlvbik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOb3JtYWxpemVzIGEgZ2l2ZW4gdmVjdG9yIHRvIHRoZSBnaXZlbiBsZW5ndGggd2l0aG91dCBlZGl0aW5nIHRoZSBvcmlnaW5hbCB2ZWN0b3IuXHJcbiAgICAgKiBAcGFyYW0gX3ZlY3RvciB0aGUgdmVjdG9yIHRvIG5vcm1hbGl6ZVxyXG4gICAgICogQHBhcmFtIF9sZW5ndGggdGhlIGxlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gZGVmYXVsdHMgdG8gMVxyXG4gICAgICogQHJldHVybnMgYSBuZXcgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgbm9ybWFsaXNlZCB2ZWN0b3Igc2NhbGVkIGJ5IHRoZSBnaXZlbiBsZW5ndGhcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBOT1JNQUxJWkFUSU9OKF92ZWN0b3I6IFZlY3RvcjIsIF9sZW5ndGg6IG51bWJlciA9IDEpOiBWZWN0b3IyIHtcclxuICAgICAgbGV0IHZlY3RvcjogVmVjdG9yMiA9IFZlY3RvcjIuWkVSTygpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGxldCBbeCwgeV0gPSBfdmVjdG9yLmRhdGE7XHJcbiAgICAgICAgbGV0IGZhY3RvcjogbnVtYmVyID0gX2xlbmd0aCAvIE1hdGguaHlwb3QoeCwgeSk7XHJcbiAgICAgICAgdmVjdG9yLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KFtfdmVjdG9yLnggKiBmYWN0b3IsIF92ZWN0b3IueSAqIGZhY3Rvcl0pO1xyXG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcclxuICAgICAgICBEZWJ1Zy5mdWRnZShfZXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB2ZWN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTY2FsZXMgYSBnaXZlbiB2ZWN0b3IgYnkgYSBnaXZlbiBzY2FsZSB3aXRob3V0IGNoYW5naW5nIHRoZSBvcmlnaW5hbCB2ZWN0b3JcclxuICAgICAqIEBwYXJhbSBfdmVjdG9yIFRoZSB2ZWN0b3IgdG8gc2NhbGUuXHJcbiAgICAgKiBAcGFyYW0gX3NjYWxlIFRoZSBzY2FsZSB0byBzY2FsZSB3aXRoLlxyXG4gICAgICogQHJldHVybnMgQSBuZXcgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgc2NhbGVkIHZlcnNpb24gb2YgdGhlIGdpdmVuIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFNDQUxFKF92ZWN0b3I6IFZlY3RvcjIsIF9zY2FsZTogbnVtYmVyKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCB2ZWN0b3I6IFZlY3RvcjIgPSBuZXcgVmVjdG9yMihfdmVjdG9yLnggKiBfc2NhbGUsIF92ZWN0b3IueSAqIF9zY2FsZSk7XHJcbiAgICAgIHJldHVybiB2ZWN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdW1zIHVwIG11bHRpcGxlIHZlY3RvcnMuXHJcbiAgICAgKiBAcGFyYW0gX3ZlY3RvcnMgQSBzZXJpZXMgb2YgdmVjdG9ycyB0byBzdW0gdXBcclxuICAgICAqIEByZXR1cm5zIEEgbmV3IHZlY3RvciByZXByZXNlbnRpbmcgdGhlIHN1bSBvZiB0aGUgZ2l2ZW4gdmVjdG9yc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFNVTSguLi5fdmVjdG9yczogVmVjdG9yMltdKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjIgPSBuZXcgVmVjdG9yMigpO1xyXG4gICAgICBmb3IgKGxldCB2ZWN0b3Igb2YgX3ZlY3RvcnMpXHJcbiAgICAgICAgcmVzdWx0LmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KFtyZXN1bHQueCArIHZlY3Rvci54LCByZXN1bHQueSArIHZlY3Rvci55XSk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJ0cmFjdHMgdHdvIHZlY3RvcnMuXHJcbiAgICAgKiBAcGFyYW0gX2EgVGhlIHZlY3RvciB0byBzdWJ0cmFjdCBmcm9tLlxyXG4gICAgICogQHBhcmFtIF9iIFRoZSB2ZWN0b3IgdG8gc3VidHJhY3QuXHJcbiAgICAgKiBAcmV0dXJucyBBIG5ldyB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBkaWZmZXJlbmNlIG9mIHRoZSBnaXZlbiB2ZWN0b3JzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgRElGRkVSRU5DRShfYTogVmVjdG9yMiwgX2I6IFZlY3RvcjIpOiBWZWN0b3IyIHtcclxuICAgICAgbGV0IHZlY3RvcjogVmVjdG9yMiA9IG5ldyBWZWN0b3IyO1xyXG4gICAgICB2ZWN0b3IuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoW19hLnggLSBfYi54LCBfYS55IC0gX2IueV0pO1xyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgdGhlIGRvdHByb2R1Y3Qgb2YgMiB2ZWN0b3JzLlxyXG4gICAgICogQHBhcmFtIF9hIFRoZSB2ZWN0b3IgdG8gbXVsdGlwbHkuXHJcbiAgICAgKiBAcGFyYW0gX2IgVGhlIHZlY3RvciB0byBtdWx0aXBseSBieS5cclxuICAgICAqIEByZXR1cm5zIEEgbmV3IHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGRvdHByb2R1Y3Qgb2YgdGhlIGdpdmVuIHZlY3RvcnNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBET1QoX2E6IFZlY3RvcjIsIF9iOiBWZWN0b3IyKTogbnVtYmVyIHtcclxuICAgICAgbGV0IHNjYWxhclByb2R1Y3Q6IG51bWJlciA9IF9hLnggKiBfYi54ICsgX2EueSAqIF9iLnk7XHJcbiAgICAgIHJldHVybiBzY2FsYXJQcm9kdWN0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gVmVjdG9ycy4gRHVlIHRvIHRoZW0gYmVpbmcgb25seSAyIERpbWVuc2lvbmFsLCB0aGUgcmVzdWx0IGlzIGEgc2luZ2xlIG51bWJlcixcclxuICAgICAqIHdoaWNoIGltcGxpY2l0bHkgaXMgb24gdGhlIFogYXhpcy4gSXQgaXMgYWxzbyB0aGUgc2lnbmVkIG1hZ25pdHVkZSBvZiB0aGUgcmVzdWx0LlxyXG4gICAgICogQHBhcmFtIF9hIFZlY3RvciB0byBjb21wdXRlIHRoZSBjcm9zcyBwcm9kdWN0IG9uXHJcbiAgICAgKiBAcGFyYW0gX2IgVmVjdG9yIHRvIGNvbXB1dGUgdGhlIGNyb3NzIHByb2R1Y3Qgd2l0aFxyXG4gICAgICogQHJldHVybnMgQSBudW1iZXIgcmVwcmVzZW50aW5nIHJlc3VsdCBvZiB0aGUgY3Jvc3MgcHJvZHVjdC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBDUk9TU1BST0RVQ1QoX2E6IFZlY3RvcjIsIF9iOiBWZWN0b3IyKTogbnVtYmVyIHtcclxuICAgICAgbGV0IGNyb3NzUHJvZHVjdDogbnVtYmVyID0gX2EueCAqIF9iLnkgLSBfYS55ICogX2IueDtcclxuICAgICAgcmV0dXJuIGNyb3NzUHJvZHVjdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIG9ydGhvZ29uYWwgdmVjdG9yIHRvIHRoZSBnaXZlbiB2ZWN0b3IuIFJvdGF0ZXMgY291bnRlcmNsb2Nrd2lzZSBieSBkZWZhdWx0LlxyXG4gICAgICogYGBgcGxhaW50ZXh0XHJcbiAgICAgKiDihpEgPT4g4oaQID0+IOKGkyA9PiDihpIgPT4g4oaRXHJcbiAgICAgKiBgYGBcclxuICAgICAqIEBwYXJhbSBfdmVjdG9yIFZlY3RvciB0byBnZXQgdGhlIG9ydGhvZ29uYWwgZXF1aXZhbGVudCBvZlxyXG4gICAgICogQHBhcmFtIF9jbG9ja3dpc2UgU2hvdWxkIHRoZSByb3RhdGlvbiBiZSBjbG9ja3dpc2UgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBjb3VudGVyY2xvY2t3aXNlPyBkZWZhdWx0OiBmYWxzZVxyXG4gICAgICogQHJldHVybnMgQSBWZWN0b3IgdGhhdCBpcyBvcnRob2dvbmFsIHRvIGFuZCBoYXMgdGhlIHNhbWUgbWFnbml0dWRlIGFzIHRoZSBnaXZlbiBWZWN0b3IuICBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBPUlRIT0dPTkFMKF92ZWN0b3I6IFZlY3RvcjIsIF9jbG9ja3dpc2U6IGJvb2xlYW4gPSBmYWxzZSk6IFZlY3RvcjIge1xyXG4gICAgICBpZiAoX2Nsb2Nrd2lzZSkgcmV0dXJuIG5ldyBWZWN0b3IyKF92ZWN0b3IueSwgLV92ZWN0b3IueCk7XHJcbiAgICAgIGVsc2UgcmV0dXJuIG5ldyBWZWN0b3IyKC1fdmVjdG9yLnksIF92ZWN0b3IueCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNvb3JkaW5hdGVzIG9mIHRoaXMgYW5kIHRoZSBnaXZlbiB2ZWN0b3IgYXJlIHRvIGJlIGNvbnNpZGVyZWQgaWRlbnRpY2FsIHdpdGhpbiB0aGUgZ2l2ZW4gdG9sZXJhbmNlXHJcbiAgICAgKiBUT0RPOiBleGFtaW5lLCBpZiB0b2xlcmFuY2UgYXMgY3JpdGVyaXVtIGZvciB0aGUgZGlmZmVyZW5jZSBpcyBhcHByb3ByaWF0ZSB3aXRoIHZlcnkgbGFyZ2UgY29vcmRpbmF0ZSB2YWx1ZXMgb3IgaWYgX3RvbGVyYW5jZSBzaG91bGQgYmUgbXVsdGlwbGllZCBieSBjb29yZGluYXRlIHZhbHVlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBlcXVhbHMoX2NvbXBhcmU6IFZlY3RvcjIsIF90b2xlcmFuY2U6IG51bWJlciA9IE51bWJlci5FUFNJTE9OKTogYm9vbGVhbiB7XHJcbiAgICAgIGlmIChNYXRoLmFicyh0aGlzLnggLSBfY29tcGFyZS54KSA+IF90b2xlcmFuY2UpIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKE1hdGguYWJzKHRoaXMueSAtIF9jb21wYXJlLnkpID4gX3RvbGVyYW5jZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdGhlIGdpdmVuIHZlY3RvciB0byB0aGUgZXhlY3V0aW5nIHZlY3RvciwgY2hhbmdpbmcgdGhlIGV4ZWN1dG9yLlxyXG4gICAgICogQHBhcmFtIF9hZGRlbmQgVGhlIHZlY3RvciB0byBhZGQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhZGQoX2FkZGVuZDogVmVjdG9yMik6IHZvaWQge1xyXG4gICAgICB0aGlzLmRhdGEgPSBuZXcgVmVjdG9yMihfYWRkZW5kLnggKyB0aGlzLngsIF9hZGRlbmQueSArIHRoaXMueSkuZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN1YnRyYWN0cyB0aGUgZ2l2ZW4gdmVjdG9yIGZyb20gdGhlIGV4ZWN1dGluZyB2ZWN0b3IsIGNoYW5naW5nIHRoZSBleGVjdXRvci5cclxuICAgICAqIEBwYXJhbSBfc3VidHJhaGVuZCBUaGUgdmVjdG9yIHRvIHN1YnRyYWN0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3VidHJhY3QoX3N1YnRyYWhlbmQ6IFZlY3RvcjIpOiB2b2lkIHtcclxuICAgICAgdGhpcy5kYXRhID0gbmV3IFZlY3RvcjIodGhpcy54IC0gX3N1YnRyYWhlbmQueCwgdGhpcy55IC0gX3N1YnRyYWhlbmQueSkuZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNjYWxlcyB0aGUgVmVjdG9yIGJ5IHRoZSBfc2NhbGUuXHJcbiAgICAgKiBAcGFyYW0gX3NjYWxlIFRoZSBzY2FsZSB0byBtdWx0aXBseSB0aGUgdmVjdG9yIHdpdGguXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzY2FsZShfc2NhbGU6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICB0aGlzLmRhdGEgPSBuZXcgVmVjdG9yMihfc2NhbGUgKiB0aGlzLngsIF9zY2FsZSAqIHRoaXMueSkuZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE5vcm1hbGl6ZXMgdGhlIHZlY3Rvci5cclxuICAgICAqIEBwYXJhbSBfbGVuZ3RoIEEgbW9kaWZpY2F0b3IgdG8gZ2V0IGEgZGlmZmVyZW50IGxlbmd0aCBvZiBub3JtYWxpemVkIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG5vcm1hbGl6ZShfbGVuZ3RoOiBudW1iZXIgPSAxKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuZGF0YSA9IFZlY3RvcjIuTk9STUFMSVpBVElPTih0aGlzLCBfbGVuZ3RoKS5kYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgVmVjdG9yIHRvIHRoZSBnaXZlbiBwYXJhbWV0ZXJzLiBPbW1pdHRlZCBwYXJhbWV0ZXJzIGRlZmF1bHQgdG8gMC5cclxuICAgICAqIEBwYXJhbSBfeCBuZXcgeCB0byBzZXRcclxuICAgICAqIEBwYXJhbSBfeSBuZXcgeSB0byBzZXRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldChfeDogbnVtYmVyID0gMCwgX3k6IG51bWJlciA9IDApOiB2b2lkIHtcclxuICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShbX3gsIF95XSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiB0aGUgZGF0YSBvZiB0aGUgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkodGhpcy5kYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIEEgZGVlcCBjb3B5IG9mIHRoZSB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgY29weSgpOiBWZWN0b3IyIHtcclxuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKHRoaXMueCwgdGhpcy55KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdHJhbnNmb3JtKF9tYXRyaXg6IE1hdHJpeDN4MywgX2luY2x1ZGVUcmFuc2xhdGlvbjogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcclxuICAgICAgdGhpcy5kYXRhID0gVmVjdG9yMi5UUkFOU0ZPUk1BVElPTih0aGlzLCBfbWF0cml4LCBfaW5jbHVkZVRyYW5zbGF0aW9uKS5kYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHotY29tcG9uZW50IG9mIHRoZSBnaXZlbiBtYWduaXR1ZGUgKGRlZmF1bHQ9MCkgdG8gdGhlIHZlY3RvciBhbmQgcmV0dXJucyBhIG5ldyBWZWN0b3IzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b1ZlY3RvcjMoX3o6IG51bWJlciA9IDApOiBWZWN0b3IzIHtcclxuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKHRoaXMueCwgdGhpcy55LCB6KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuICAgICAgbGV0IHJlc3VsdDogc3RyaW5nID0gYCgke3RoaXMueC50b1ByZWNpc2lvbig1KX0sICR7dGhpcy55LnRvUHJlY2lzaW9uKDUpfSlgO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHtcclxuICAgICAgICB4OiB0aGlzLmRhdGFbMF0sIHk6IHRoaXMuZGF0YVsxXVxyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7LyoqICovIH1cclxuICB9XHJcbn0iLCIvLy88cmVmZXJlbmNlIHBhdGg9XCIuLi9FbmdpbmUvUmVjeWNsZXIudHNcIi8+XHJcbi8vLzxyZWZlcmVuY2UgcGF0aD1cIlZlY3RvcjIudHNcIi8+XHJcblxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBEZWZpbmVzIHRoZSBvcmlnaW4gb2YgYSByZWN0YW5nbGVcclxuICAgKi9cclxuICBleHBvcnQgZW51bSBPUklHSU4yRCB7XHJcbiAgICBUT1BMRUZUID0gMHgwMCxcclxuICAgIFRPUENFTlRFUiA9IDB4MDEsXHJcbiAgICBUT1BSSUdIVCA9IDB4MDIsXHJcbiAgICBDRU5URVJMRUZUID0gMHgxMCxcclxuICAgIENFTlRFUiA9IDB4MTEsXHJcbiAgICBDRU5URVJSSUdIVCA9IDB4MTIsXHJcbiAgICBCT1RUT01MRUZUID0gMHgyMCxcclxuICAgIEJPVFRPTUNFTlRFUiA9IDB4MjEsXHJcbiAgICBCT1RUT01SSUdIVCA9IDB4MjJcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlZmluZXMgYSByZWN0YW5nbGUgd2l0aCBwb3NpdGlvbiBhbmQgc2l6ZSBhbmQgYWRkIGNvbWZvcnRhYmxlIG1ldGhvZHMgdG8gaXRcclxuICAgKiBAYXV0aG9yIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFJlY3RhbmdsZSBleHRlbmRzIE11dGFibGUge1xyXG4gICAgcHVibGljIHBvc2l0aW9uOiBWZWN0b3IyID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjIpO1xyXG4gICAgcHVibGljIHNpemU6IFZlY3RvcjIgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMik7XHJcblxyXG4gICAgY29uc3RydWN0b3IoX3g6IG51bWJlciA9IDAsIF95OiBudW1iZXIgPSAwLCBfd2lkdGg6IG51bWJlciA9IDEsIF9oZWlnaHQ6IG51bWJlciA9IDEsIF9vcmlnaW46IE9SSUdJTjJEID0gT1JJR0lOMkQuVE9QTEVGVCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLnNldFBvc2l0aW9uQW5kU2l6ZShfeCwgX3ksIF93aWR0aCwgX2hlaWdodCwgX29yaWdpbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHJlY3RhbmdsZSBjcmVhdGVkIHdpdGggdGhlIGdpdmVuIHBhcmFtZXRlcnNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBHRVQoX3g6IG51bWJlciA9IDAsIF95OiBudW1iZXIgPSAwLCBfd2lkdGg6IG51bWJlciA9IDEsIF9oZWlnaHQ6IG51bWJlciA9IDEsIF9vcmlnaW46IE9SSUdJTjJEID0gT1JJR0lOMkQuVE9QTEVGVCk6IFJlY3RhbmdsZSB7XHJcbiAgICAgIGxldCByZWN0OiBSZWN0YW5nbGUgPSBSZWN5Y2xlci5nZXQoUmVjdGFuZ2xlKTtcclxuICAgICAgcmVjdC5zZXRQb3NpdGlvbkFuZFNpemUoX3gsIF95LCBfd2lkdGgsIF9oZWlnaHQpO1xyXG4gICAgICByZXR1cm4gcmVjdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHBvc2l0aW9uIGFuZCBzaXplIG9mIHRoZSByZWN0YW5nbGUgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBwYXJhbWV0ZXJzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRQb3NpdGlvbkFuZFNpemUoX3g6IG51bWJlciA9IDAsIF95OiBudW1iZXIgPSAwLCBfd2lkdGg6IG51bWJlciA9IDEsIF9oZWlnaHQ6IG51bWJlciA9IDEsIF9vcmlnaW46IE9SSUdJTjJEID0gT1JJR0lOMkQuVE9QTEVGVCk6IHZvaWQge1xyXG4gICAgICB0aGlzLnNpemUuc2V0KF93aWR0aCwgX2hlaWdodCk7XHJcbiAgICAgIHN3aXRjaCAoX29yaWdpbiAmIDB4MDMpIHtcclxuICAgICAgICBjYXNlIDB4MDA6IHRoaXMucG9zaXRpb24ueCA9IF94OyBicmVhaztcclxuICAgICAgICBjYXNlIDB4MDE6IHRoaXMucG9zaXRpb24ueCA9IF94IC0gX3dpZHRoIC8gMjsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAweDAyOiB0aGlzLnBvc2l0aW9uLnggPSBfeCAtIF93aWR0aDsgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgc3dpdGNoIChfb3JpZ2luICYgMHgzMCkge1xyXG4gICAgICAgIGNhc2UgMHgwMDogdGhpcy5wb3NpdGlvbi55ID0gX3k7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMHgxMDogdGhpcy5wb3NpdGlvbi55ID0gX3kgLSBfaGVpZ2h0IC8gMjsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAweDIwOiB0aGlzLnBvc2l0aW9uLnkgPSBfeSAtIF9oZWlnaHQ7IGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHBvaW50VG9SZWN0KF9wb2ludDogVmVjdG9yMiwgX3RhcmdldDogUmVjdGFuZ2xlKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjIgPSBfcG9pbnQuY29weTtcclxuICAgICAgcmVzdWx0LnN1YnRyYWN0KHRoaXMucG9zaXRpb24pO1xyXG4gICAgICByZXN1bHQueCAqPSBfdGFyZ2V0LndpZHRoIC8gdGhpcy53aWR0aDtcclxuICAgICAgcmVzdWx0LnkgKj0gX3RhcmdldC5oZWlnaHQgLyB0aGlzLmhlaWdodDtcclxuICAgICAgcmVzdWx0LmFkZChfdGFyZ2V0LnBvc2l0aW9uKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgeCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi54O1xyXG4gICAgfVxyXG4gICAgZ2V0IHkoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24ueTtcclxuICAgIH1cclxuICAgIGdldCB3aWR0aCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5zaXplLng7XHJcbiAgICB9XHJcbiAgICBnZXQgaGVpZ2h0KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNpemUueTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgbGVmdG1vc3QgZXhwYW5zaW9uLCByZXNwZWN0aW5nIGFsc28gbmVnYXRpdmUgdmFsdWVzIG9mIHdpZHRoXHJcbiAgICAgKi9cclxuICAgIGdldCBsZWZ0KCk6IG51bWJlciB7XHJcbiAgICAgIGlmICh0aGlzLnNpemUueCA+IDApXHJcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24ueDtcclxuICAgICAgcmV0dXJuICh0aGlzLnBvc2l0aW9uLnggKyB0aGlzLnNpemUueCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgdG9wbW9zdCBleHBhbnNpb24sIHJlc3BlY3RpbmcgYWxzbyBuZWdhdGl2ZSB2YWx1ZXMgb2YgaGVpZ2h0XHJcbiAgICAgKi9cclxuICAgIGdldCB0b3AoKTogbnVtYmVyIHtcclxuICAgICAgaWYgKHRoaXMuc2l6ZS55ID4gMClcclxuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi55O1xyXG4gICAgICByZXR1cm4gKHRoaXMucG9zaXRpb24ueSArIHRoaXMuc2l6ZS55KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSByaWdodG1vc3QgZXhwYW5zaW9uLCByZXNwZWN0aW5nIGFsc28gbmVnYXRpdmUgdmFsdWVzIG9mIHdpZHRoXHJcbiAgICAgKi9cclxuICAgIGdldCByaWdodCgpOiBudW1iZXIge1xyXG4gICAgICBpZiAodGhpcy5zaXplLnggPiAwKVxyXG4gICAgICAgIHJldHVybiAodGhpcy5wb3NpdGlvbi54ICsgdGhpcy5zaXplLngpO1xyXG4gICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi54O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIGxvd2VzdCBleHBhbnNpb24sIHJlc3BlY3RpbmcgYWxzbyBuZWdhdGl2ZSB2YWx1ZXMgb2YgaGVpZ2h0XHJcbiAgICAgKi9cclxuICAgIGdldCBib3R0b20oKTogbnVtYmVyIHtcclxuICAgICAgaWYgKHRoaXMuc2l6ZS55ID4gMClcclxuICAgICAgICByZXR1cm4gKHRoaXMucG9zaXRpb24ueSArIHRoaXMuc2l6ZS55KTtcclxuICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24ueTtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgeChfeDogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMucG9zaXRpb24ueCA9IF94O1xyXG4gICAgfVxyXG4gICAgc2V0IHkoX3k6IG51bWJlcikge1xyXG4gICAgICB0aGlzLnBvc2l0aW9uLnkgPSBfeTtcclxuICAgIH1cclxuICAgIHNldCB3aWR0aChfd2lkdGg6IG51bWJlcikge1xyXG4gICAgICB0aGlzLnBvc2l0aW9uLnggPSBfd2lkdGg7XHJcbiAgICB9XHJcbiAgICBzZXQgaGVpZ2h0KF9oZWlnaHQ6IG51bWJlcikge1xyXG4gICAgICB0aGlzLnBvc2l0aW9uLnkgPSBfaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgc2V0IGxlZnQoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5zaXplLnggPSB0aGlzLnJpZ2h0IC0gX3ZhbHVlO1xyXG4gICAgICB0aGlzLnBvc2l0aW9uLnggPSBfdmFsdWU7XHJcbiAgICB9XHJcbiAgICBzZXQgdG9wKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuc2l6ZS55ID0gdGhpcy5ib3R0b20gLSBfdmFsdWU7XHJcbiAgICAgIHRoaXMucG9zaXRpb24ueSA9IF92YWx1ZTtcclxuICAgIH1cclxuICAgIHNldCByaWdodChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLnNpemUueCA9IHRoaXMucG9zaXRpb24ueCArIF92YWx1ZTtcclxuICAgIH1cclxuICAgIHNldCBib3R0b20oX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5zaXplLnkgPSB0aGlzLnBvc2l0aW9uLnkgKyBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBjb3B5KCk6IFJlY3RhbmdsZSB7XHJcbiAgICAgIHJldHVybiBSZWN0YW5nbGUuR0VUKHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHBvaW50IGlzIGluc2lkZSBvZiB0aGlzIHJlY3RhbmdsZSBvciBvbiB0aGUgYm9yZGVyXHJcbiAgICAgKiBAcGFyYW0gX3BvaW50XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpc0luc2lkZShfcG9pbnQ6IFZlY3RvcjIpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIChfcG9pbnQueCA+PSB0aGlzLmxlZnQgJiYgX3BvaW50LnggPD0gdGhpcy5yaWdodCAmJiBfcG9pbnQueSA+PSB0aGlzLnRvcCAmJiBfcG9pbnQueSA8PSB0aGlzLmJvdHRvbSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGNvbGxpZGVzKF9yZWN0OiBSZWN0YW5nbGUpOiBib29sZWFuIHtcclxuICAgICAgaWYgKHRoaXMubGVmdCA+IF9yZWN0LnJpZ2h0KSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmICh0aGlzLnJpZ2h0IDwgX3JlY3QubGVmdCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAodGhpcy50b3AgPiBfcmVjdC5ib3R0b20pIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKHRoaXMuYm90dG9tIDwgX3JlY3QudG9wKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG4gICAgICBsZXQgcmVzdWx0OiBzdHJpbmcgPSBgxpIuUmVjdGFuZ2xlKHBvc2l0aW9uOiR7dGhpcy5wb3NpdGlvbi50b1N0cmluZygpfSwgc2l6ZToke3RoaXMuc2l6ZS50b1N0cmluZygpfWA7XHJcbiAgICAgIHJlc3VsdCArPSBgLCBsZWZ0OiR7dGhpcy5sZWZ0LnRvUHJlY2lzaW9uKDUpfSwgdG9wOiR7dGhpcy50b3AudG9QcmVjaXNpb24oNSl9LCByaWdodDoke3RoaXMucmlnaHQudG9QcmVjaXNpb24oNSl9LCBib3R0b206JHt0aGlzLmJvdHRvbS50b1ByZWNpc2lvbig1KX1gO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7LyogKi8gfVxyXG4gIH1cclxufSIsIi8vLzxyZWZlcmVuY2UgcGF0aD1cIlJlbmRlckluamVjdG9yLnRzXCIvPlxyXG4vLy88cmVmZXJlbmNlIHBhdGg9XCJSZW5kZXJJbmplY3RvclNoYWRlci50c1wiLz5cclxuLy8vPHJlZmVyZW5jZSBwYXRoPVwiUmVuZGVySW5qZWN0b3JDb2F0LnRzXCIvPlxyXG4vLy88cmVmZXJlbmNlIHBhdGg9XCJSZW5kZXJJbmplY3Rvck1lc2gudHNcIi8+XHJcbi8vLzxyZWZlcmVuY2UgcGF0aD1cIi4uL01hdGgvUmVjdGFuZ2xlLnRzXCIvPlxyXG5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGRlY2xhcmUgbGV0IGZ1ZGdlQ29uZmlnOiBHZW5lcmFsO1xyXG5cclxuICBleHBvcnQgZW51bSBCTEVORCB7XHJcbiAgICBPUEFRVUUsIFRSQU5TUEFSRU5ULCBQQVJUSUNMRVxyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGludGVyZmFjZSBCdWZmZXJTcGVjaWZpY2F0aW9uIHtcclxuICAgIHNpemU6IG51bWJlcjsgICAvLyBUaGUgc2l6ZSBvZiB0aGUgZGF0YXNhbXBsZS5cclxuICAgIGRhdGFUeXBlOiBudW1iZXI7IC8vIFRoZSBkYXRhdHlwZSBvZiB0aGUgc2FtcGxlIChlLmcuIGdsLkZMT0FULCBnbC5CWVRFLCBldGMuKVxyXG4gICAgbm9ybWFsaXplOiBib29sZWFuOyAvLyBGbGFnIHRvIG5vcm1hbGl6ZSB0aGUgZGF0YS5cclxuICAgIHN0cmlkZTogbnVtYmVyOyAvLyBOdW1iZXIgb2YgaW5kaWNlcyB0aGF0IHdpbGwgYmUgc2tpcHBlZCBlYWNoIGl0ZXJhdGlvbi5cclxuICAgIG9mZnNldDogbnVtYmVyOyAvLyBJbmRleCBvZiB0aGUgZWxlbWVudCB0byBiZWdpbiB3aXRoLlxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQmFzZSBjbGFzcyBmb3IgUmVuZGVyTWFuYWdlciwgaGFuZGxpbmcgdGhlIGNvbm5lY3Rpb24gdG8gdGhlIHJlbmRlcmluZyBzeXN0ZW0sIGluIHRoaXMgY2FzZSBXZWJHTC5cclxuICAgKiBNZXRob2RzIGFuZCBhdHRyaWJ1dGVzIG9mIHRoaXMgY2xhc3Mgc2hvdWxkIG5vdCBiZSBjYWxsZWQgZGlyZWN0bHksIG9ubHkgdGhyb3VnaCBbW1JlbmRlck1hbmFnZXJdXVxyXG4gICAqL1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBSZW5kZXJPcGVyYXRvciB7XHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJPcGVyYXRvci5pbml0aWFsaXplKCk7XHJcbiAgICBwcml2YXRlIHN0YXRpYyByZWN0Vmlld3BvcnQ6IFJlY3RhbmdsZSA9IFJlbmRlck9wZXJhdG9yLmdldENhbnZhc1JlY3QoKTtcclxuXHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogV3JhcHBlciBmdW5jdGlvbiB0byB1dGlsaXplIHRoZSBidWZmZXJTcGVjaWZpY2F0aW9uIGludGVyZmFjZSB3aGVuIHBhc3NpbmcgZGF0YSB0byB0aGUgc2hhZGVyIHZpYSBhIGJ1ZmZlci5cclxuICAgICAqIEBwYXJhbSBfYXR0cmlidXRlTG9jYXRpb24gIFRoZSBsb2NhdGlvbiBvZiB0aGUgYXR0cmlidXRlIG9uIHRoZSBzaGFkZXIsIHRvIHdoaWNoIHRoZXkgZGF0YSB3aWxsIGJlIHBhc3NlZC5cclxuICAgICAqIEBwYXJhbSBfYnVmZmVyU3BlY2lmaWNhdGlvbiAgSW50ZXJmYWNlIHBhc3NpbmcgZGF0YXB1bGxzcGVjaWZpY2F0aW9ucyB0byB0aGUgYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHNldEF0dHJpYnV0ZVN0cnVjdHVyZShfYXR0cmlidXRlTG9jYXRpb246IG51bWJlciwgX2J1ZmZlclNwZWNpZmljYXRpb246IEJ1ZmZlclNwZWNpZmljYXRpb24pOiB2b2lkIHtcclxuICAgICAgUmVuZGVyT3BlcmF0b3IuY3JjMy52ZXJ0ZXhBdHRyaWJQb2ludGVyKF9hdHRyaWJ1dGVMb2NhdGlvbiwgX2J1ZmZlclNwZWNpZmljYXRpb24uc2l6ZSwgX2J1ZmZlclNwZWNpZmljYXRpb24uZGF0YVR5cGUsIF9idWZmZXJTcGVjaWZpY2F0aW9uLm5vcm1hbGl6ZSwgX2J1ZmZlclNwZWNpZmljYXRpb24uc3RyaWRlLCBfYnVmZmVyU3BlY2lmaWNhdGlvbi5vZmZzZXQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBDaGVja3MgdGhlIGZpcnN0IHBhcmFtZXRlciBhbmQgdGhyb3dzIGFuIGV4Y2VwdGlvbiB3aXRoIHRoZSBXZWJHTC1lcnJvcmNvZGUgaWYgdGhlIHZhbHVlIGlzIG51bGxcclxuICAgICogQHBhcmFtIF92YWx1ZSAgdmFsdWUgdG8gY2hlY2sgYWdhaW5zdCBudWxsXHJcbiAgICAqIEBwYXJhbSBfbWVzc2FnZSAgb3B0aW9uYWwsIGFkZGl0aW9uYWwgbWVzc2FnZSBmb3IgdGhlIGV4Y2VwdGlvblxyXG4gICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgYXNzZXJ0PFQ+KF92YWx1ZTogVCB8IG51bGwsIF9tZXNzYWdlOiBzdHJpbmcgPSBcIlwiKTogVCB7XHJcbiAgICAgIGlmIChfdmFsdWUgPT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBc3NlcnRpb24gZmFpbGVkLiAke19tZXNzYWdlfSwgV2ViR0wtRXJyb3I6ICR7UmVuZGVyT3BlcmF0b3IuY3JjMyA/IFJlbmRlck9wZXJhdG9yLmNyYzMuZ2V0RXJyb3IoKSA6IFwiXCJ9YCk7XHJcbiAgICAgIHJldHVybiBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplcyBvZmZzY3JlZW4tY2FudmFzLCByZW5kZXJpbmdjb250ZXh0IGFuZCBoYXJkd2FyZSB2aWV3cG9ydC4gQ2FsbCBvbmNlIGJlZm9yZSBjcmVhdGluZyBhbnkgcmVzb3VyY2VzIGxpa2UgbWVzaGVzIG9yIHNoYWRlcnNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBpbml0aWFsaXplKF9hbnRpYWxpYXM/OiBib29sZWFuLCBfYWxwaGE/OiBib29sZWFuKTogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCB7XHJcbiAgICAgIGZ1ZGdlQ29uZmlnID0gZnVkZ2VDb25maWcgfHwge307XHJcbiAgICAgIGxldCBjb250ZXh0QXR0cmlidXRlczogV2ViR0xDb250ZXh0QXR0cmlidXRlcyA9IHtcclxuICAgICAgICBhbHBoYTogKF9hbHBoYSAhPSB1bmRlZmluZWQpID8gX2FscGhhIDogZnVkZ2VDb25maWcuYWxwaGEgfHwgZmFsc2UsXHJcbiAgICAgICAgYW50aWFsaWFzOiAoX2FudGlhbGlhcyAhPSB1bmRlZmluZWQpID8gX2FudGlhbGlhcyA6IGZ1ZGdlQ29uZmlnLmFudGlhbGlhcyB8fCBmYWxzZSxcclxuICAgICAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IGZhbHNlXHJcbiAgICAgIH07XHJcbiAgICAgIERlYnVnLmZ1ZGdlKFwiSW5pdGlhbGl6ZSBSZW5kZXJNYW5hZ2VyXCIsIGNvbnRleHRBdHRyaWJ1dGVzKTtcclxuICAgICAgbGV0IGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xyXG4gICAgICBsZXQgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dDtcclxuICAgICAgY3JjMyA9IFJlbmRlck9wZXJhdG9yLmFzc2VydDxXZWJHTDJSZW5kZXJpbmdDb250ZXh0PihcclxuICAgICAgICBjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsMlwiLCBjb250ZXh0QXR0cmlidXRlcyksXHJcbiAgICAgICAgXCJXZWJHTC1jb250ZXh0IGNvdWxkbid0IGJlIGNyZWF0ZWRcIlxyXG4gICAgICApO1xyXG4gICAgICBSZW5kZXJPcGVyYXRvci5jcmMzID0gY3JjMztcclxuICAgICAgLy8gRW5hYmxlIGJhY2tmYWNlLSBhbmQgekJ1ZmZlci1jdWxsaW5nLlxyXG4gICAgICBjcmMzLmVuYWJsZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkNVTExfRkFDRSk7XHJcbiAgICAgIGNyYzMuZW5hYmxlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuREVQVEhfVEVTVCk7XHJcbiAgICAgIGNyYzMuZW5hYmxlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQkxFTkQpO1xyXG4gICAgICBjcmMzLmJsZW5kRXF1YXRpb24oV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GVU5DX0FERCk7XHJcbiAgICAgIFJlbmRlck9wZXJhdG9yLnNldEJsZW5kTW9kZShCTEVORC5UUkFOU1BBUkVOVCk7XHJcbiAgICAgIC8vIFJlbmRlck9wZXJhdG9yLmNyYzMucGl4ZWxTdG9yZWkoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0cnVlKTtcclxuICAgICAgUmVuZGVyT3BlcmF0b3IucmVjdFZpZXdwb3J0ID0gUmVuZGVyT3BlcmF0b3IuZ2V0Q2FudmFzUmVjdCgpO1xyXG4gICAgICByZXR1cm4gY3JjMztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhIHJlZmVyZW5jZSB0byB0aGUgb2Zmc2NyZWVuLWNhbnZhc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENhbnZhcygpOiBIVE1MQ2FudmFzRWxlbWVudCB7XHJcbiAgICAgIHJldHVybiA8SFRNTENhbnZhc0VsZW1lbnQ+UmVuZGVyT3BlcmF0b3IuY3JjMy5jYW52YXM7IC8vIFRPRE86IGVuYWJsZSBPZmZzY3JlZW5DYW52YXNcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhIHJlZmVyZW5jZSB0byB0aGUgcmVuZGVyaW5nIGNvbnRleHRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXRSZW5kZXJpbmdDb250ZXh0KCk6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQge1xyXG4gICAgICByZXR1cm4gUmVuZGVyT3BlcmF0b3IuY3JjMztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhIHJlY3RhbmdsZSBkZXNjcmliaW5nIHRoZSBzaXplIG9mIHRoZSBvZmZzY3JlZW4tY2FudmFzLiB4LHkgYXJlIDAgYXQgYWxsIHRpbWVzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENhbnZhc1JlY3QoKTogUmVjdGFuZ2xlIHtcclxuICAgICAgbGV0IGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQgPSA8SFRNTENhbnZhc0VsZW1lbnQ+UmVuZGVyT3BlcmF0b3IuY3JjMy5jYW52YXM7XHJcbiAgICAgIHJldHVybiBSZWN0YW5nbGUuR0VUKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHNpemUgb2YgdGhlIG9mZnNjcmVlbi1jYW52YXMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc2V0Q2FudmFzU2l6ZShfd2lkdGg6IG51bWJlciwgX2hlaWdodDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIFJlbmRlck9wZXJhdG9yLmNyYzMuY2FudmFzLndpZHRoID0gX3dpZHRoO1xyXG4gICAgICBSZW5kZXJPcGVyYXRvci5jcmMzLmNhbnZhcy5oZWlnaHQgPSBfaGVpZ2h0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBhcmVhIG9uIHRoZSBvZmZzY3JlZW4tY2FudmFzIHRvIHJlbmRlciB0aGUgY2FtZXJhIGltYWdlIHRvLlxyXG4gICAgICogQHBhcmFtIF9yZWN0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc2V0Vmlld3BvcnRSZWN0YW5nbGUoX3JlY3Q6IFJlY3RhbmdsZSk6IHZvaWQge1xyXG4gICAgICBPYmplY3QuYXNzaWduKFJlbmRlck9wZXJhdG9yLnJlY3RWaWV3cG9ydCwgX3JlY3QpO1xyXG4gICAgICBSZW5kZXJPcGVyYXRvci5jcmMzLnZpZXdwb3J0KF9yZWN0LngsIF9yZWN0LnksIF9yZWN0LndpZHRoLCBfcmVjdC5oZWlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmUgdGhlIGFyZWEgb24gdGhlIG9mZnNjcmVlbi1jYW52YXMgdGhlIGNhbWVyYSBpbWFnZSBnZXRzIHJlbmRlcmVkIHRvLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldFZpZXdwb3J0UmVjdGFuZ2xlKCk6IFJlY3RhbmdsZSB7XHJcbiAgICAgIHJldHVybiBSZW5kZXJPcGVyYXRvci5yZWN0Vmlld3BvcnQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBzZXREZXB0aFRlc3QoX3Rlc3Q6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgaWYgKF90ZXN0KVxyXG4gICAgICAgIFJlbmRlck9wZXJhdG9yLmNyYzMuZW5hYmxlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuREVQVEhfVEVTVCk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBSZW5kZXJPcGVyYXRvci5jcmMzLmRpc2FibGUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ERVBUSF9URVNUKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIHNldEJsZW5kTW9kZShfbW9kZTogQkxFTkQpOiB2b2lkIHtcclxuICAgICAgc3dpdGNoIChfbW9kZSkge1xyXG4gICAgICAgIGNhc2UgQkxFTkQuT1BBUVVFOlxyXG4gICAgICAgICAgUmVuZGVyT3BlcmF0b3IuY3JjMy5ibGVuZEZ1bmMoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5PTkUsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuWkVSTyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEJMRU5ELlRSQU5TUEFSRU5UOlxyXG4gICAgICAgICAgUmVuZGVyT3BlcmF0b3IuY3JjMy5ibGVuZEZ1bmMoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5TUkNfQUxQSEEsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuT05FX01JTlVTX1NSQ19BTFBIQSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEJMRU5ELlBBUlRJQ0xFOlxyXG4gICAgICAgICAgUmVuZGVyT3BlcmF0b3IuY3JjMy5ibGVuZEZ1bmMoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5TUkNfQUxQSEEsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRFNUX0FMUEhBKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhdyBhIG1lc2ggYnVmZmVyIHVzaW5nIHRoZSBnaXZlbiBpbmZvcyBhbmQgdGhlIGNvbXBsZXRlIHByb2plY3Rpb24gbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgZHJhdyhfbWVzaDogTWVzaCwgY21wTWF0ZXJpYWw6IENvbXBvbmVudE1hdGVyaWFsLCBfZmluYWw6IE1hdHJpeDR4NCwgX3Byb2plY3Rpb246IE1hdHJpeDR4NCk6IHZvaWQge1xyXG4gICAgICBsZXQgc2hhZGVyOiB0eXBlb2YgU2hhZGVyID0gY21wTWF0ZXJpYWwubWF0ZXJpYWwuZ2V0U2hhZGVyKCk7XHJcbiAgICAgIGxldCBjb2F0OiBDb2F0ID0gY21wTWF0ZXJpYWwubWF0ZXJpYWwuZ2V0Q29hdCgpO1xyXG4gICAgICBzaGFkZXIudXNlUHJvZ3JhbSgpO1xyXG4gICAgICBfbWVzaC51c2VSZW5kZXJCdWZmZXJzKHNoYWRlciwgX2ZpbmFsLCBfcHJvamVjdGlvbik7XHJcbiAgICAgIGNvYXQudXNlUmVuZGVyRGF0YShzaGFkZXIsIGNtcE1hdGVyaWFsKTtcclxuICAgICAgUmVuZGVyT3BlcmF0b3IuY3JjMy5kcmF3RWxlbWVudHMoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5UUklBTkdMRVMsIF9tZXNoLnJlbmRlckJ1ZmZlcnMubkluZGljZXMsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5TSUdORURfU0hPUlQsIDApO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJEZWJ1Zy9EZWJ1Z1RhcmdldC50c1wiLz5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkRlYnVnL0RlYnVnLnRzXCIvPlxyXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiRXZlbnQvRXZlbnQudHNcIi8+XHJcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJUcmFuc2Zlci9NdXRhYmxlLnRzXCIvPiAgXHJcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJUcmFuc2Zlci9TZXJpYWxpemVyLnRzXCIvPiBcclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlJlbmRlci9SZW5kZXJPcGVyYXRvci50c1wiLz5cclxuIiwiLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9UcmFuc2Zlci9NdXRhYmxlLnRzXCIvPlxyXG5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogSG9sZHMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIEFuaW1hdGlvblN0cnVjdHVyZSB0aGF0IHRoZSBBbmltYXRpb24gdXNlcyB0byBtYXAgdGhlIFNlcXVlbmNlcyB0byB0aGUgQXR0cmlidXRlcy5cclxuICAgKiBCdWlsdCBvdXQgb2YgYSBbW05vZGVdXSdzIHNlcmlhbHNhdGlvbiwgaXQgc3dhcHMgdGhlIHZhbHVlcyB3aXRoIFtbQW5pbWF0aW9uU2VxdWVuY2VdXXMuXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBBbmltYXRpb25TdHJ1Y3R1cmUge1xyXG4gICAgW2F0dHJpYnV0ZTogc3RyaW5nXTogU2VyaWFsaXphdGlvbiB8IEFuaW1hdGlvblNlcXVlbmNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgKiBBbiBhc3NvY2lhdGl2ZSBhcnJheSBtYXBwaW5nIG5hbWVzIG9mIGxhYmxlcyB0byB0aW1lc3RhbXBzLlxyXG4gICogTGFiZWxzIG5lZWQgdG8gYmUgdW5pcXVlIHBlciBBbmltYXRpb24uXHJcbiAgKiBAYXV0aG9yIEx1a2FzIFNjaGV1ZXJsZSwgSEZVLCAyMDE5XHJcbiAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIEFuaW1hdGlvbkxhYmVsIHtcclxuICAgIFtuYW1lOiBzdHJpbmddOiBudW1iZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAqIEhvbGRzIGluZm9ybWF0aW9uIGFib3V0IEFuaW1hdGlvbiBFdmVudCBUcmlnZ2Vyc1xyXG4gICogQGF1dGhvciBMdWthcyBTY2hldWVybGUsIEhGVSwgMjAxOVxyXG4gICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBBbmltYXRpb25FdmVudFRyaWdnZXIge1xyXG4gICAgW25hbWU6IHN0cmluZ106IG51bWJlcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEludGVybmFsbHkgdXNlZCB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gdGhlIHZhcmlvdXMgZ2VuZXJhdGVkIHN0cnVjdHVyZXMgYW5kIGV2ZW50cy5cclxuICAgKiBAYXV0aG9yIEx1a2FzIFNjaGV1ZXJsZSwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZW51bSBBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUge1xyXG4gICAgLyoqRGVmYXVsdDogZm9yd2FyZCwgY29udGlub3VzICovXHJcbiAgICBOT1JNQUwsXHJcbiAgICAvKipiYWNrd2FyZCwgY29udGlub3VzICovXHJcbiAgICBSRVZFUlNFLFxyXG4gICAgLyoqZm9yd2FyZCwgcmFzdGVyZWQgKi9cclxuICAgIFJBU1RFUkVELFxyXG4gICAgLyoqYmFja3dhcmQsIHJhc3RlcmVkICovXHJcbiAgICBSQVNURVJFRFJFVkVSU0VcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFuaW1hdGlvbiBDbGFzcyB0byBob2xkIGFsbCByZXF1aXJlZCBPYmplY3RzIHRoYXQgYXJlIHBhcnQgb2YgYW4gQW5pbWF0aW9uLlxyXG4gICAqIEFsc28gaG9sZHMgZnVuY3Rpb25zIHRvIHBsYXkgc2FpZCBBbmltYXRpb24uXHJcbiAgICogQ2FuIGJlIGFkZGVkIHRvIGEgTm9kZSBhbmQgcGxheWVkIHRocm91Z2ggW1tDb21wb25lbnRBbmltYXRvcl1dLlxyXG4gICAqIEBhdXRob3IgTHVrYXMgU2NoZXVlcmxlLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQW5pbWF0aW9uIGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZVJlc291cmNlIHtcclxuICAgIGlkUmVzb3VyY2U6IHN0cmluZztcclxuICAgIG5hbWU6IHN0cmluZztcclxuICAgIHRvdGFsVGltZTogbnVtYmVyID0gMDtcclxuICAgIGxhYmVsczogQW5pbWF0aW9uTGFiZWwgPSB7fTtcclxuICAgIHN0ZXBzUGVyU2Vjb25kOiBudW1iZXIgPSAxMDtcclxuICAgIGFuaW1hdGlvblN0cnVjdHVyZTogQW5pbWF0aW9uU3RydWN0dXJlO1xyXG4gICAgZXZlbnRzOiBBbmltYXRpb25FdmVudFRyaWdnZXIgPSB7fTtcclxuICAgIHByaXZhdGUgZnJhbWVzUGVyU2Vjb25kOiBudW1iZXIgPSA2MDtcclxuXHJcbiAgICAvLyBwcm9jZXNzZWQgZXZlbnRsaXN0IGFuZCBhbmltYXRpb24gc3RydWN1dHJlcyBmb3IgcGxheWJhY2suXHJcbiAgICBwcml2YXRlIGV2ZW50c1Byb2Nlc3NlZDogTWFwPEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRSwgQW5pbWF0aW9uRXZlbnRUcmlnZ2VyPiA9IG5ldyBNYXA8QU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLCBBbmltYXRpb25FdmVudFRyaWdnZXI+KCk7XHJcbiAgICBwcml2YXRlIGFuaW1hdGlvblN0cnVjdHVyZXNQcm9jZXNzZWQ6IE1hcDxBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUsIEFuaW1hdGlvblN0cnVjdHVyZT4gPSBuZXcgTWFwPEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRSwgQW5pbWF0aW9uU3RydWN0dXJlPigpO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKF9uYW1lOiBzdHJpbmcsIF9hbmltU3RydWN0dXJlOiBBbmltYXRpb25TdHJ1Y3R1cmUgPSB7fSwgX2ZwczogbnVtYmVyID0gNjApIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5uYW1lID0gX25hbWU7XHJcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RydWN0dXJlID0gX2FuaW1TdHJ1Y3R1cmU7XHJcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RydWN0dXJlc1Byb2Nlc3NlZC5zZXQoQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLk5PUk1BTCwgX2FuaW1TdHJ1Y3R1cmUpO1xyXG4gICAgICB0aGlzLmZyYW1lc1BlclNlY29uZCA9IF9mcHM7XHJcbiAgICAgIHRoaXMuY2FsY3VsYXRlVG90YWxUaW1lKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgYSBuZXcgXCJNdXRhdG9yXCIgd2l0aCB0aGUgaW5mb3JtYXRpb24gdG8gYXBwbHkgdG8gdGhlIFtbTm9kZV1dIHRoZSBbW0NvbXBvbmVudEFuaW1hdG9yXV0gaXMgYXR0YWNoZWQgdG8gd2l0aCBbW05vZGUuYXBwbHlBbmltYXRpb24oKV1dLlxyXG4gICAgICogQHBhcmFtIF90aW1lIFRoZSB0aW1lIGF0IHdoaWNoIHRoZSBhbmltYXRpb24gY3VycmVudGx5IGlzIGF0XHJcbiAgICAgKiBAcGFyYW0gX2RpcmVjdGlvbiBUaGUgZGlyZWN0aW9uIGluIHdoaWNoIHRoZSBhbmltYXRpb24gaXMgc3VwcG9zZWQgdG8gYmUgcGxheWluZyBiYWNrLiA+MCA9PSBmb3J3YXJkLCAwID09IHN0b3AsIDwwID09IGJhY2t3YXJkc1xyXG4gICAgICogQHBhcmFtIF9wbGF5YmFjayBUaGUgcGxheWJhY2ttb2RlIHRoZSBhbmltYXRpb24gaXMgc3VwcG9zZWQgdG8gYmUgY2FsY3VsYXRlZCB3aXRoLlxyXG4gICAgICogQHJldHVybnMgYSBcIk11dGF0b3JcIiB0byBhcHBseS5cclxuICAgICAqL1xyXG4gICAgZ2V0TXV0YXRlZChfdGltZTogbnVtYmVyLCBfZGlyZWN0aW9uOiBudW1iZXIsIF9wbGF5YmFjazogQU5JTUFUSU9OX1BMQVlCQUNLKTogTXV0YXRvciB7ICAgICAvL1RPRE86IGZpbmQgYSBiZXR0ZXIgbmFtZSBmb3IgdGhpc1xyXG4gICAgICBsZXQgbTogTXV0YXRvciA9IHt9O1xyXG4gICAgICBpZiAoX3BsYXliYWNrID09IEFOSU1BVElPTl9QTEFZQkFDSy5USU1FQkFTRURfQ09OVElOT1VTKSB7XHJcbiAgICAgICAgaWYgKF9kaXJlY3Rpb24gPj0gMCkge1xyXG4gICAgICAgICAgbSA9IHRoaXMudHJhdmVyc2VTdHJ1Y3R1cmVGb3JNdXRhdG9yKHRoaXMuZ2V0UHJvY2Vzc2VkQW5pbWF0aW9uU3RydWN0dXJlKEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5OT1JNQUwpLCBfdGltZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG0gPSB0aGlzLnRyYXZlcnNlU3RydWN0dXJlRm9yTXV0YXRvcih0aGlzLmdldFByb2Nlc3NlZEFuaW1hdGlvblN0cnVjdHVyZShBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuUkVWRVJTRSksIF90aW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKF9kaXJlY3Rpb24gPj0gMCkge1xyXG4gICAgICAgICAgbSA9IHRoaXMudHJhdmVyc2VTdHJ1Y3R1cmVGb3JNdXRhdG9yKHRoaXMuZ2V0UHJvY2Vzc2VkQW5pbWF0aW9uU3RydWN0dXJlKEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5SQVNURVJFRCksIF90aW1lKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbSA9IHRoaXMudHJhdmVyc2VTdHJ1Y3R1cmVGb3JNdXRhdG9yKHRoaXMuZ2V0UHJvY2Vzc2VkQW5pbWF0aW9uU3RydWN0dXJlKEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5SQVNURVJFRFJFVkVSU0UpLCBfdGltZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIHRoZSBuYW1lcyBvZiB0aGUgZXZlbnRzIHRoZSBbW0NvbXBvbmVudEFuaW1hdG9yXV0gbmVlZHMgdG8gZmlyZSBiZXR3ZWVuIF9taW4gYW5kIF9tYXguIFxyXG4gICAgICogQHBhcmFtIF9taW4gVGhlIG1pbmltdW0gdGltZSAoaW5jbHVzaXZlKSB0byBjaGVjayBiZXR3ZWVuXHJcbiAgICAgKiBAcGFyYW0gX21heCBUaGUgbWF4aW11bSB0aW1lIChleGNsdXNpdmUpIHRvIGNoZWNrIGJldHdlZW5cclxuICAgICAqIEBwYXJhbSBfcGxheWJhY2sgVGhlIHBsYXliYWNrIG1vZGUgdG8gY2hlY2sgaW4uIEhhcyBhbiBlZmZlY3Qgb24gd2hlbiB0aGUgRXZlbnRzIGFyZSBmaXJlZC4gXHJcbiAgICAgKiBAcGFyYW0gX2RpcmVjdGlvbiBUaGUgZGlyZWN0aW9uIHRoZSBhbmltYXRpb24gaXMgc3VwcG9zZWQgdG8gcnVuIGluLiA+MCA9PSBmb3J3YXJkLCAwID09IHN0b3AsIDwwID09IGJhY2t3YXJkc1xyXG4gICAgICogQHJldHVybnMgYSBsaXN0IG9mIHN0cmluZ3Mgd2l0aCB0aGUgbmFtZXMgb2YgdGhlIGN1c3RvbSBldmVudHMgdG8gZmlyZS5cclxuICAgICAqL1xyXG4gICAgZ2V0RXZlbnRzVG9GaXJlKF9taW46IG51bWJlciwgX21heDogbnVtYmVyLCBfcGxheWJhY2s6IEFOSU1BVElPTl9QTEFZQkFDSywgX2RpcmVjdGlvbjogbnVtYmVyKTogc3RyaW5nW10ge1xyXG4gICAgICBsZXQgZXZlbnRMaXN0OiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgICBsZXQgbWluU2VjdGlvbjogbnVtYmVyID0gTWF0aC5mbG9vcihfbWluIC8gdGhpcy50b3RhbFRpbWUpO1xyXG4gICAgICBsZXQgbWF4U2VjdGlvbjogbnVtYmVyID0gTWF0aC5mbG9vcihfbWF4IC8gdGhpcy50b3RhbFRpbWUpO1xyXG4gICAgICBfbWluID0gX21pbiAlIHRoaXMudG90YWxUaW1lO1xyXG4gICAgICBfbWF4ID0gX21heCAlIHRoaXMudG90YWxUaW1lO1xyXG5cclxuICAgICAgd2hpbGUgKG1pblNlY3Rpb24gPD0gbWF4U2VjdGlvbikge1xyXG4gICAgICAgIGxldCBldmVudFRyaWdnZXJzOiBBbmltYXRpb25FdmVudFRyaWdnZXIgPSB0aGlzLmdldENvcnJlY3RFdmVudExpc3QoX2RpcmVjdGlvbiwgX3BsYXliYWNrKTtcclxuICAgICAgICBpZiAobWluU2VjdGlvbiA9PSBtYXhTZWN0aW9uKSB7XHJcbiAgICAgICAgICBldmVudExpc3QgPSBldmVudExpc3QuY29uY2F0KHRoaXMuY2hlY2tFdmVudHNCZXR3ZWVuKGV2ZW50VHJpZ2dlcnMsIF9taW4sIF9tYXgpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZXZlbnRMaXN0ID0gZXZlbnRMaXN0LmNvbmNhdCh0aGlzLmNoZWNrRXZlbnRzQmV0d2VlbihldmVudFRyaWdnZXJzLCBfbWluLCB0aGlzLnRvdGFsVGltZSkpO1xyXG4gICAgICAgICAgX21pbiA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1pblNlY3Rpb24rKztcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGV2ZW50TGlzdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYW4gRXZlbnQgdG8gdGhlIExpc3Qgb2YgZXZlbnRzLlxyXG4gICAgICogQHBhcmFtIF9uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCAobmVlZHMgdG8gYmUgdW5pcXVlIHBlciBBbmltYXRpb24pLlxyXG4gICAgICogQHBhcmFtIF90aW1lIFRoZSB0aW1lc3RhbXAgb2YgdGhlIGV2ZW50IChpbiBtaWxsaXNlY29uZHMpLlxyXG4gICAgICovXHJcbiAgICBzZXRFdmVudChfbmFtZTogc3RyaW5nLCBfdGltZTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuZXZlbnRzW19uYW1lXSA9IF90aW1lO1xyXG4gICAgICB0aGlzLmV2ZW50c1Byb2Nlc3NlZC5jbGVhcigpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhlIGV2ZW50IHdpdGggdGhlIGdpdmVuIG5hbWUgZnJvbSB0aGUgbGlzdCBvZiBldmVudHMuXHJcbiAgICAgKiBAcGFyYW0gX25hbWUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gcmVtb3ZlLlxyXG4gICAgICovXHJcbiAgICByZW1vdmVFdmVudChfbmFtZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgIGRlbGV0ZSB0aGlzLmV2ZW50c1tfbmFtZV07XHJcbiAgICAgIHRoaXMuZXZlbnRzUHJvY2Vzc2VkLmNsZWFyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGdldExhYmVscygpOiBFbnVtZXJhdG9yIHtcclxuICAgICAgLy9UT0RPOiB0aGlzIGFjdHVhbGx5IG5lZWRzIHRlc3RpbmdcclxuICAgICAgbGV0IGVuOiBFbnVtZXJhdG9yID0gbmV3IEVudW1lcmF0b3IodGhpcy5sYWJlbHMpO1xyXG4gICAgICByZXR1cm4gZW47XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGZwcygpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5mcmFtZXNQZXJTZWNvbmQ7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IGZwcyhfZnBzOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5mcmFtZXNQZXJTZWNvbmQgPSBfZnBzO1xyXG4gICAgICB0aGlzLmV2ZW50c1Byb2Nlc3NlZC5jbGVhcigpO1xyXG4gICAgICB0aGlzLmFuaW1hdGlvblN0cnVjdHVyZXNQcm9jZXNzZWQuY2xlYXIoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIChSZS0pQ2FsY3VsYXRlIHRoZSB0b3RhbCB0aW1lIG9mIHRoZSBBbmltYXRpb24uIENhbGN1bGF0aW9uLWhlYXZ5LCB1c2Ugb25seSBpZiBhY3R1YWxseSBuZWVkZWQuXHJcbiAgICAgKi9cclxuICAgIGNhbGN1bGF0ZVRvdGFsVGltZSgpOiB2b2lkIHtcclxuICAgICAgdGhpcy50b3RhbFRpbWUgPSAwO1xyXG4gICAgICB0aGlzLnRyYXZlcnNlU3RydWN0dXJlRm9yVGltZSh0aGlzLmFuaW1hdGlvblN0cnVjdHVyZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIHRyYW5zZmVyXHJcbiAgICBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzOiBTZXJpYWxpemF0aW9uID0ge1xyXG4gICAgICAgIGlkUmVzb3VyY2U6IHRoaXMuaWRSZXNvdXJjZSxcclxuICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgbGFiZWxzOiB7fSxcclxuICAgICAgICBldmVudHM6IHt9LFxyXG4gICAgICAgIGZwczogdGhpcy5mcmFtZXNQZXJTZWNvbmQsXHJcbiAgICAgICAgc3BzOiB0aGlzLnN0ZXBzUGVyU2Vjb25kXHJcbiAgICAgIH07XHJcbiAgICAgIGZvciAobGV0IG5hbWUgaW4gdGhpcy5sYWJlbHMpIHtcclxuICAgICAgICBzLmxhYmVsc1tuYW1lXSA9IHRoaXMubGFiZWxzW25hbWVdO1xyXG4gICAgICB9XHJcbiAgICAgIGZvciAobGV0IG5hbWUgaW4gdGhpcy5ldmVudHMpIHtcclxuICAgICAgICBzLmV2ZW50c1tuYW1lXSA9IHRoaXMuZXZlbnRzW25hbWVdO1xyXG4gICAgICB9XHJcbiAgICAgIHMuYW5pbWF0aW9uU3RydWN0dXJlID0gdGhpcy50cmF2ZXJzZVN0cnVjdHVyZUZvclNlcmlhbGlzYXRpb24odGhpcy5hbmltYXRpb25TdHJ1Y3R1cmUpO1xyXG4gICAgICByZXR1cm4gcztcclxuICAgIH1cclxuICAgIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogU2VyaWFsaXphYmxlIHtcclxuICAgICAgdGhpcy5pZFJlc291cmNlID0gX3NlcmlhbGl6YXRpb24uaWRSZXNvdXJjZTtcclxuICAgICAgdGhpcy5uYW1lID0gX3NlcmlhbGl6YXRpb24ubmFtZTtcclxuICAgICAgdGhpcy5mcmFtZXNQZXJTZWNvbmQgPSBfc2VyaWFsaXphdGlvbi5mcHM7XHJcbiAgICAgIHRoaXMuc3RlcHNQZXJTZWNvbmQgPSBfc2VyaWFsaXphdGlvbi5zcHM7XHJcbiAgICAgIHRoaXMubGFiZWxzID0ge307XHJcbiAgICAgIGZvciAobGV0IG5hbWUgaW4gX3NlcmlhbGl6YXRpb24ubGFiZWxzKSB7XHJcbiAgICAgICAgdGhpcy5sYWJlbHNbbmFtZV0gPSBfc2VyaWFsaXphdGlvbi5sYWJlbHNbbmFtZV07XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5ldmVudHMgPSB7fTtcclxuICAgICAgZm9yIChsZXQgbmFtZSBpbiBfc2VyaWFsaXphdGlvbi5ldmVudHMpIHtcclxuICAgICAgICB0aGlzLmV2ZW50c1tuYW1lXSA9IF9zZXJpYWxpemF0aW9uLmV2ZW50c1tuYW1lXTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmV2ZW50c1Byb2Nlc3NlZCA9IG5ldyBNYXA8QU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLCBBbmltYXRpb25FdmVudFRyaWdnZXI+KCk7XHJcblxyXG4gICAgICB0aGlzLmFuaW1hdGlvblN0cnVjdHVyZSA9IHRoaXMudHJhdmVyc2VTdHJ1Y3R1cmVGb3JEZXNlcmlhbGlzYXRpb24oX3NlcmlhbGl6YXRpb24uYW5pbWF0aW9uU3RydWN0dXJlKTtcclxuXHJcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RydWN0dXJlc1Byb2Nlc3NlZCA9IG5ldyBNYXA8QU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLCBBbmltYXRpb25TdHJ1Y3R1cmU+KCk7XHJcblxyXG4gICAgICB0aGlzLmNhbGN1bGF0ZVRvdGFsVGltZSgpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xyXG4gICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemUoKTtcclxuICAgIH1cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci50b3RhbFRpbWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyYXZlcnNlcyBhbiBBbmltYXRpb25TdHJ1Y3R1cmUgYW5kIHJldHVybnMgdGhlIFNlcmlhbGl6YXRpb24gb2Ygc2FpZCBTdHJ1Y3R1cmUuXHJcbiAgICAgKiBAcGFyYW0gX3N0cnVjdHVyZSBUaGUgQW5pbWF0aW9uIFN0cnVjdHVyZSBhdCB0aGUgY3VycmVudCBsZXZlbCB0byB0cmFuc2Zvcm0gaW50byB0aGUgU2VyaWFsaXphdGlvbi5cclxuICAgICAqIEByZXR1cm5zIHRoZSBmaWxsZWQgU2VyaWFsaXphdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSB0cmF2ZXJzZVN0cnVjdHVyZUZvclNlcmlhbGlzYXRpb24oX3N0cnVjdHVyZTogQW5pbWF0aW9uU3RydWN0dXJlKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBuZXdTZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge307XHJcbiAgICAgIGZvciAobGV0IG4gaW4gX3N0cnVjdHVyZSkge1xyXG4gICAgICAgIGlmIChfc3RydWN0dXJlW25dIGluc3RhbmNlb2YgQW5pbWF0aW9uU2VxdWVuY2UpIHtcclxuICAgICAgICAgIG5ld1NlcmlhbGl6YXRpb25bbl0gPSBfc3RydWN0dXJlW25dLnNlcmlhbGl6ZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuZXdTZXJpYWxpemF0aW9uW25dID0gdGhpcy50cmF2ZXJzZVN0cnVjdHVyZUZvclNlcmlhbGlzYXRpb24oPEFuaW1hdGlvblN0cnVjdHVyZT5fc3RydWN0dXJlW25dKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG5ld1NlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyYXZlcnNlcyBhIFNlcmlhbGl6YXRpb24gdG8gY3JlYXRlIGEgbmV3IEFuaW1hdGlvblN0cnVjdHVyZS5cclxuICAgICAqIEBwYXJhbSBfc2VyaWFsaXphdGlvbiBUaGUgc2VyaWFsaXphdGlvbiB0byB0cmFuc2ZlciBpbnRvIGFuIEFuaW1hdGlvblN0cnVjdHVyZVxyXG4gICAgICogQHJldHVybnMgdGhlIG5ld2x5IGNyZWF0ZWQgQW5pbWF0aW9uU3RydWN0dXJlLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHRyYXZlcnNlU3RydWN0dXJlRm9yRGVzZXJpYWxpc2F0aW9uKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogQW5pbWF0aW9uU3RydWN0dXJlIHtcclxuICAgICAgbGV0IG5ld1N0cnVjdHVyZTogQW5pbWF0aW9uU3RydWN0dXJlID0ge307XHJcbiAgICAgIGZvciAobGV0IG4gaW4gX3NlcmlhbGl6YXRpb24pIHtcclxuICAgICAgICBpZiAoX3NlcmlhbGl6YXRpb25bbl0uYW5pbWF0aW9uU2VxdWVuY2UpIHtcclxuICAgICAgICAgIGxldCBhbmltU2VxOiBBbmltYXRpb25TZXF1ZW5jZSA9IG5ldyBBbmltYXRpb25TZXF1ZW5jZSgpO1xyXG4gICAgICAgICAgbmV3U3RydWN0dXJlW25dID0gYW5pbVNlcS5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltuXSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG5ld1N0cnVjdHVyZVtuXSA9IHRoaXMudHJhdmVyc2VTdHJ1Y3R1cmVGb3JEZXNlcmlhbGlzYXRpb24oX3NlcmlhbGl6YXRpb25bbl0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbmV3U3RydWN0dXJlO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kcyB0aGUgbGlzdCBvZiBldmVudHMgdG8gYmUgdXNlZCB3aXRoIHRoZXNlIHNldHRpbmdzLlxyXG4gICAgICogQHBhcmFtIF9kaXJlY3Rpb24gVGhlIGRpcmVjdGlvbiB0aGUgYW5pbWF0aW9uIGlzIHBsYXlpbmcgaW4uXHJcbiAgICAgKiBAcGFyYW0gX3BsYXliYWNrIFRoZSBwbGF5YmFja21vZGUgdGhlIGFuaW1hdGlvbiBpcyBwbGF5aW5nIGluLlxyXG4gICAgICogQHJldHVybnMgVGhlIGNvcnJlY3QgQW5pbWF0aW9uRXZlbnRUcmlnZ2VyIE9iamVjdCB0byB1c2VcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBnZXRDb3JyZWN0RXZlbnRMaXN0KF9kaXJlY3Rpb246IG51bWJlciwgX3BsYXliYWNrOiBBTklNQVRJT05fUExBWUJBQ0spOiBBbmltYXRpb25FdmVudFRyaWdnZXIge1xyXG4gICAgICBpZiAoX3BsYXliYWNrICE9IEFOSU1BVElPTl9QTEFZQkFDSy5GUkFNRUJBU0VEKSB7XHJcbiAgICAgICAgaWYgKF9kaXJlY3Rpb24gPj0gMCkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJvY2Vzc2VkRXZlbnRUcmlnZ2VyKEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5OT1JNQUwpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRQcm9jZXNzZWRFdmVudFRyaWdnZXIoQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlJFVkVSU0UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoX2RpcmVjdGlvbiA+PSAwKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRQcm9jZXNzZWRFdmVudFRyaWdnZXIoQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlJBU1RFUkVEKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJvY2Vzc2VkRXZlbnRUcmlnZ2VyKEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5SQVNURVJFRFJFVkVSU0UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhdmVyc2VzIGFuIEFuaW1hdGlvblN0cnVjdHVyZSB0byB0dXJuIGl0IGludG8gdGhlIFwiTXV0YXRvclwiIHRvIHJldHVybiB0byB0aGUgQ29tcG9uZW50LlxyXG4gICAgICogQHBhcmFtIF9zdHJ1Y3R1cmUgVGhlIHN0cmN1dHVyZSB0byB0cmF2ZXJzZVxyXG4gICAgICogQHBhcmFtIF90aW1lIHRoZSBwb2ludCBpbiB0aW1lIHRvIHdyaXRlIHRoZSBhbmltYXRpb24gbnVtYmVycyBpbnRvLlxyXG4gICAgICogQHJldHVybnMgVGhlIFwiTXV0YXRvclwiIGZpbGxlZCB3aXRoIHRoZSBjb3JyZWN0IHZhbHVlcyBhdCB0aGUgZ2l2ZW4gdGltZS4gXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdHJhdmVyc2VTdHJ1Y3R1cmVGb3JNdXRhdG9yKF9zdHJ1Y3R1cmU6IEFuaW1hdGlvblN0cnVjdHVyZSwgX3RpbWU6IG51bWJlcik6IE11dGF0b3Ige1xyXG4gICAgICBsZXQgbmV3TXV0YXRvcjogTXV0YXRvciA9IHt9O1xyXG4gICAgICBmb3IgKGxldCBuIGluIF9zdHJ1Y3R1cmUpIHtcclxuICAgICAgICBpZiAoX3N0cnVjdHVyZVtuXSBpbnN0YW5jZW9mIEFuaW1hdGlvblNlcXVlbmNlKSB7XHJcbiAgICAgICAgICBuZXdNdXRhdG9yW25dID0gKDxBbmltYXRpb25TZXF1ZW5jZT5fc3RydWN0dXJlW25dKS5ldmFsdWF0ZShfdGltZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG5ld011dGF0b3Jbbl0gPSB0aGlzLnRyYXZlcnNlU3RydWN0dXJlRm9yTXV0YXRvcig8QW5pbWF0aW9uU3RydWN0dXJlPl9zdHJ1Y3R1cmVbbl0sIF90aW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG5ld011dGF0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmF2ZXJzZXMgdGhlIGN1cnJlbnQgQW5pbWF0aW9uU3RyY3V0dXJlIHRvIGZpbmQgdGhlIHRvdGFsVGltZSBvZiB0aGlzIGFuaW1hdGlvbi5cclxuICAgICAqIEBwYXJhbSBfc3RydWN0dXJlIFRoZSBzdHJ1Y3R1cmUgdG8gdHJhdmVyc2VcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSB0cmF2ZXJzZVN0cnVjdHVyZUZvclRpbWUoX3N0cnVjdHVyZTogQW5pbWF0aW9uU3RydWN0dXJlKTogdm9pZCB7XHJcbiAgICAgIGZvciAobGV0IG4gaW4gX3N0cnVjdHVyZSkge1xyXG4gICAgICAgIGlmIChfc3RydWN0dXJlW25dIGluc3RhbmNlb2YgQW5pbWF0aW9uU2VxdWVuY2UpIHtcclxuICAgICAgICAgIGxldCBzZXF1ZW5jZTogQW5pbWF0aW9uU2VxdWVuY2UgPSA8QW5pbWF0aW9uU2VxdWVuY2U+X3N0cnVjdHVyZVtuXTtcclxuICAgICAgICAgIGlmIChzZXF1ZW5jZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGxldCBzZXF1ZW5jZVRpbWU6IG51bWJlciA9IHNlcXVlbmNlLmdldEtleShzZXF1ZW5jZS5sZW5ndGggLSAxKS5UaW1lO1xyXG4gICAgICAgICAgICB0aGlzLnRvdGFsVGltZSA9IHNlcXVlbmNlVGltZSA+IHRoaXMudG90YWxUaW1lID8gc2VxdWVuY2VUaW1lIDogdGhpcy50b3RhbFRpbWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMudHJhdmVyc2VTdHJ1Y3R1cmVGb3JUaW1lKDxBbmltYXRpb25TdHJ1Y3R1cmU+X3N0cnVjdHVyZVtuXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbnN1cmVzIHRoZSBleGlzdGFuY2Ugb2YgdGhlIHJlcXVlc3RlZCBbW0FuaW1hdGlvblN0cmN1dHVyZV1dIGFuZCByZXR1cm5zIGl0LlxyXG4gICAgICogQHBhcmFtIF90eXBlIHRoZSB0eXBlIG9mIHRoZSBzdHJ1Y3R1cmUgdG8gZ2V0XHJcbiAgICAgKiBAcmV0dXJucyB0aGUgcmVxdWVzdGVkIFtbQW5pbWF0aW9uU3RydWN0dXJlXV1cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBnZXRQcm9jZXNzZWRBbmltYXRpb25TdHJ1Y3R1cmUoX3R5cGU6IEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRSk6IEFuaW1hdGlvblN0cnVjdHVyZSB7XHJcbiAgICAgIGlmICghdGhpcy5hbmltYXRpb25TdHJ1Y3R1cmVzUHJvY2Vzc2VkLmhhcyhfdHlwZSkpIHtcclxuICAgICAgICB0aGlzLmNhbGN1bGF0ZVRvdGFsVGltZSgpO1xyXG4gICAgICAgIGxldCBhZTogQW5pbWF0aW9uU3RydWN0dXJlID0ge307XHJcbiAgICAgICAgc3dpdGNoIChfdHlwZSkge1xyXG4gICAgICAgICAgY2FzZSBBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuTk9STUFMOlxyXG4gICAgICAgICAgICBhZSA9IHRoaXMuYW5pbWF0aW9uU3RydWN0dXJlO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlJFVkVSU0U6XHJcbiAgICAgICAgICAgIGFlID0gdGhpcy50cmF2ZXJzZVN0cnVjdHVyZUZvck5ld1N0cnVjdHVyZSh0aGlzLmFuaW1hdGlvblN0cnVjdHVyZSwgdGhpcy5jYWxjdWxhdGVSZXZlcnNlU2VxdWVuY2UuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSBBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuUkFTVEVSRUQ6XHJcbiAgICAgICAgICAgIGFlID0gdGhpcy50cmF2ZXJzZVN0cnVjdHVyZUZvck5ld1N0cnVjdHVyZSh0aGlzLmFuaW1hdGlvblN0cnVjdHVyZSwgdGhpcy5jYWxjdWxhdGVSYXN0ZXJlZFNlcXVlbmNlLmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlJBU1RFUkVEUkVWRVJTRTpcclxuICAgICAgICAgICAgYWUgPSB0aGlzLnRyYXZlcnNlU3RydWN0dXJlRm9yTmV3U3RydWN0dXJlKHRoaXMuZ2V0UHJvY2Vzc2VkQW5pbWF0aW9uU3RydWN0dXJlKEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5SRVZFUlNFKSwgdGhpcy5jYWxjdWxhdGVSYXN0ZXJlZFNlcXVlbmNlLmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdHJ1Y3R1cmVzUHJvY2Vzc2VkLnNldChfdHlwZSwgYWUpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLmFuaW1hdGlvblN0cnVjdHVyZXNQcm9jZXNzZWQuZ2V0KF90eXBlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEVuc3VyZXMgdGhlIGV4aXN0YW5jZSBvZiB0aGUgcmVxdWVzdGVkIFtbQW5pbWF0aW9uRXZlbnRUcmlnZ2VyXV0gYW5kIHJldHVybnMgaXQuXHJcbiAgICAgKiBAcGFyYW0gX3R5cGUgVGhlIHR5cGUgb2YgQW5pbWF0aW9uRXZlbnRUcmlnZ2VyIHRvIGdldFxyXG4gICAgICogQHJldHVybnMgdGhlIHJlcXVlc3RlZCBbW0FuaW1hdGlvbkV2ZW50VHJpZ2dlcl1dXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZ2V0UHJvY2Vzc2VkRXZlbnRUcmlnZ2VyKF90eXBlOiBBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUpOiBBbmltYXRpb25FdmVudFRyaWdnZXIge1xyXG4gICAgICBpZiAoIXRoaXMuZXZlbnRzUHJvY2Vzc2VkLmhhcyhfdHlwZSkpIHtcclxuICAgICAgICB0aGlzLmNhbGN1bGF0ZVRvdGFsVGltZSgpO1xyXG4gICAgICAgIGxldCBldjogQW5pbWF0aW9uRXZlbnRUcmlnZ2VyID0ge307XHJcbiAgICAgICAgc3dpdGNoIChfdHlwZSkge1xyXG4gICAgICAgICAgY2FzZSBBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuTk9STUFMOlxyXG4gICAgICAgICAgICBldiA9IHRoaXMuZXZlbnRzO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlJFVkVSU0U6XHJcbiAgICAgICAgICAgIGV2ID0gdGhpcy5jYWxjdWxhdGVSZXZlcnNlRXZlbnRUcmlnZ2Vycyh0aGlzLmV2ZW50cyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSBBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuUkFTVEVSRUQ6XHJcbiAgICAgICAgICAgIGV2ID0gdGhpcy5jYWxjdWxhdGVSYXN0ZXJlZEV2ZW50VHJpZ2dlcnModGhpcy5ldmVudHMpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlJBU1RFUkVEUkVWRVJTRTpcclxuICAgICAgICAgICAgZXYgPSB0aGlzLmNhbGN1bGF0ZVJhc3RlcmVkRXZlbnRUcmlnZ2Vycyh0aGlzLmdldFByb2Nlc3NlZEV2ZW50VHJpZ2dlcihBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuUkVWRVJTRSkpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ldmVudHNQcm9jZXNzZWQuc2V0KF90eXBlLCBldik7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMuZXZlbnRzUHJvY2Vzc2VkLmdldChfdHlwZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmF2ZXJzZXMgYW4gZXhpc3Rpbmcgc3RydWN0dXJlIHRvIGFwcGx5IGEgcmVjYWxjdWxhdGlvbiBmdW5jdGlvbiB0byB0aGUgQW5pbWF0aW9uU3RydWN0dXJlIHRvIHN0b3JlIGluIGEgbmV3IFN0cnVjdHVyZS5cclxuICAgICAqIEBwYXJhbSBfb2xkU3RydWN0dXJlIFRoZSBvbGQgc3RydWN0dXJlIHRvIHRyYXZlcnNlXHJcbiAgICAgKiBAcGFyYW0gX2Z1bmN0aW9uVG9Vc2UgVGhlIGZ1bmN0aW9uIHRvIHVzZSB0byByZWNhbGN1bGF0ZWQgdGhlIHN0cnVjdHVyZS5cclxuICAgICAqIEByZXR1cm5zIEEgbmV3IEFuaW1hdGlvbiBTdHJ1Y3R1cmUgd2l0aCB0aGUgcmVjYWx1bGF0ZWQgQW5pbWF0aW9uIFNlcXVlbmNlcy5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSB0cmF2ZXJzZVN0cnVjdHVyZUZvck5ld1N0cnVjdHVyZShfb2xkU3RydWN0dXJlOiBBbmltYXRpb25TdHJ1Y3R1cmUsIF9mdW5jdGlvblRvVXNlOiBGdW5jdGlvbik6IEFuaW1hdGlvblN0cnVjdHVyZSB7XHJcbiAgICAgIGxldCBuZXdTdHJ1Y3R1cmU6IEFuaW1hdGlvblN0cnVjdHVyZSA9IHt9O1xyXG4gICAgICBmb3IgKGxldCBuIGluIF9vbGRTdHJ1Y3R1cmUpIHtcclxuICAgICAgICBpZiAoX29sZFN0cnVjdHVyZVtuXSBpbnN0YW5jZW9mIEFuaW1hdGlvblNlcXVlbmNlKSB7XHJcbiAgICAgICAgICBuZXdTdHJ1Y3R1cmVbbl0gPSBfZnVuY3Rpb25Ub1VzZShfb2xkU3RydWN0dXJlW25dKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbmV3U3RydWN0dXJlW25dID0gdGhpcy50cmF2ZXJzZVN0cnVjdHVyZUZvck5ld1N0cnVjdHVyZSg8QW5pbWF0aW9uU3RydWN0dXJlPl9vbGRTdHJ1Y3R1cmVbbl0sIF9mdW5jdGlvblRvVXNlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG5ld1N0cnVjdHVyZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSByZXZlcnNlZCBBbmltYXRpb24gU2VxdWVuY2Ugb3V0IG9mIGEgZ2l2ZW4gU2VxdWVuY2UuXHJcbiAgICAgKiBAcGFyYW0gX3NlcXVlbmNlIFRoZSBzZXF1ZW5jZSB0byBjYWxjdWxhdGUgdGhlIG5ldyBzZXF1ZW5jZSBvdXQgb2ZcclxuICAgICAqIEByZXR1cm5zIFRoZSByZXZlcnNlZCBTZXF1ZW5jZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNhbGN1bGF0ZVJldmVyc2VTZXF1ZW5jZShfc2VxdWVuY2U6IEFuaW1hdGlvblNlcXVlbmNlKTogQW5pbWF0aW9uU2VxdWVuY2Uge1xyXG4gICAgICBsZXQgc2VxOiBBbmltYXRpb25TZXF1ZW5jZSA9IG5ldyBBbmltYXRpb25TZXF1ZW5jZSgpO1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgX3NlcXVlbmNlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IG9sZEtleTogQW5pbWF0aW9uS2V5ID0gX3NlcXVlbmNlLmdldEtleShpKTtcclxuICAgICAgICBsZXQga2V5OiBBbmltYXRpb25LZXkgPSBuZXcgQW5pbWF0aW9uS2V5KHRoaXMudG90YWxUaW1lIC0gb2xkS2V5LlRpbWUsIG9sZEtleS5WYWx1ZSwgb2xkS2V5LlNsb3BlT3V0LCBvbGRLZXkuU2xvcGVJbiwgb2xkS2V5LkNvbnN0YW50KTtcclxuICAgICAgICBzZXEuYWRkS2V5KGtleSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHNlcTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSByYXN0ZXJlZCBbW0FuaW1hdGlvblNlcXVlbmNlXV0gb3V0IG9mIGEgZ2l2ZW4gc2VxdWVuY2UuXHJcbiAgICAgKiBAcGFyYW0gX3NlcXVlbmNlIFRoZSBzZXF1ZW5jZSB0byBjYWxjdWxhdGUgdGhlIG5ldyBzZXF1ZW5jZSBvdXQgb2ZcclxuICAgICAqIEByZXR1cm5zIHRoZSByYXN0ZXJlZCBzZXF1ZW5jZS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjYWxjdWxhdGVSYXN0ZXJlZFNlcXVlbmNlKF9zZXF1ZW5jZTogQW5pbWF0aW9uU2VxdWVuY2UpOiBBbmltYXRpb25TZXF1ZW5jZSB7XHJcbiAgICAgIGxldCBzZXE6IEFuaW1hdGlvblNlcXVlbmNlID0gbmV3IEFuaW1hdGlvblNlcXVlbmNlKCk7XHJcbiAgICAgIGxldCBmcmFtZVRpbWU6IG51bWJlciA9IDEwMDAgLyB0aGlzLmZyYW1lc1BlclNlY29uZDtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMudG90YWxUaW1lOyBpICs9IGZyYW1lVGltZSkge1xyXG4gICAgICAgIGxldCBrZXk6IEFuaW1hdGlvbktleSA9IG5ldyBBbmltYXRpb25LZXkoaSwgX3NlcXVlbmNlLmV2YWx1YXRlKGkpLCAwLCAwLCB0cnVlKTtcclxuICAgICAgICBzZXEuYWRkS2V5KGtleSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHNlcTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgcmV2ZXJzZWQgW1tBbmltYXRpb25FdmVudFRyaWdnZXJdXSBvYmplY3QgYmFzZWQgb24gdGhlIGdpdmVuIG9uZS4gIFxyXG4gICAgICogQHBhcmFtIF9ldmVudHMgdGhlIGV2ZW50IG9iamVjdCB0byBjYWxjdWxhdGUgdGhlIG5ldyBvbmUgb3V0IG9mXHJcbiAgICAgKiBAcmV0dXJucyB0aGUgcmV2ZXJzZWQgZXZlbnQgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY2FsY3VsYXRlUmV2ZXJzZUV2ZW50VHJpZ2dlcnMoX2V2ZW50czogQW5pbWF0aW9uRXZlbnRUcmlnZ2VyKTogQW5pbWF0aW9uRXZlbnRUcmlnZ2VyIHtcclxuICAgICAgbGV0IGFlOiBBbmltYXRpb25FdmVudFRyaWdnZXIgPSB7fTtcclxuICAgICAgZm9yIChsZXQgbmFtZSBpbiBfZXZlbnRzKSB7XHJcbiAgICAgICAgYWVbbmFtZV0gPSB0aGlzLnRvdGFsVGltZSAtIF9ldmVudHNbbmFtZV07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGFlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSByYXN0ZXJlZCBbW0FuaW1hdGlvbkV2ZW50VHJpZ2dlcl1dIG9iamVjdCBiYXNlZCBvbiB0aGUgZ2l2ZW4gb25lLiAgXHJcbiAgICAgKiBAcGFyYW0gX2V2ZW50cyB0aGUgZXZlbnQgb2JqZWN0IHRvIGNhbGN1bGF0ZSB0aGUgbmV3IG9uZSBvdXQgb2ZcclxuICAgICAqIEByZXR1cm5zIHRoZSByYXN0ZXJlZCBldmVudCBvYmplY3RcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjYWxjdWxhdGVSYXN0ZXJlZEV2ZW50VHJpZ2dlcnMoX2V2ZW50czogQW5pbWF0aW9uRXZlbnRUcmlnZ2VyKTogQW5pbWF0aW9uRXZlbnRUcmlnZ2VyIHtcclxuICAgICAgbGV0IGFlOiBBbmltYXRpb25FdmVudFRyaWdnZXIgPSB7fTtcclxuICAgICAgbGV0IGZyYW1lVGltZTogbnVtYmVyID0gMTAwMCAvIHRoaXMuZnJhbWVzUGVyU2Vjb25kO1xyXG4gICAgICBmb3IgKGxldCBuYW1lIGluIF9ldmVudHMpIHtcclxuICAgICAgICBhZVtuYW1lXSA9IF9ldmVudHNbbmFtZV0gLSAoX2V2ZW50c1tuYW1lXSAlIGZyYW1lVGltZSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGFlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB3aGljaCBldmVudHMgbGF5IGJldHdlZW4gdHdvIGdpdmVuIHRpbWVzIGFuZCByZXR1cm5zIHRoZSBuYW1lcyBvZiB0aGUgb25lcyB0aGF0IGRvLlxyXG4gICAgICogQHBhcmFtIF9ldmVudFRyaWdnZXJzIFRoZSBldmVudCBvYmplY3QgdG8gY2hlY2sgdGhlIGV2ZW50cyBpbnNpZGUgb2ZcclxuICAgICAqIEBwYXJhbSBfbWluIHRoZSBtaW5pbXVtIG9mIHRoZSByYW5nZSB0byBjaGVjayBiZXR3ZWVuIChpbmNsdXNpdmUpXHJcbiAgICAgKiBAcGFyYW0gX21heCB0aGUgbWF4aW11bSBvZiB0aGUgcmFuZ2UgdG8gY2hlY2sgYmV0d2VlbiAoZXhjbHVzaXZlKVxyXG4gICAgICogQHJldHVybnMgYW4gYXJyYXkgb2YgdGhlIG5hbWVzIG9mIHRoZSBldmVudHMgaW4gdGhlIGdpdmVuIHJhbmdlLiBcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjaGVja0V2ZW50c0JldHdlZW4oX2V2ZW50VHJpZ2dlcnM6IEFuaW1hdGlvbkV2ZW50VHJpZ2dlciwgX21pbjogbnVtYmVyLCBfbWF4OiBudW1iZXIpOiBzdHJpbmdbXSB7XHJcbiAgICAgIGxldCBldmVudHNUb1RyaWdnZXI6IHN0cmluZ1tdID0gW107XHJcbiAgICAgIGZvciAobGV0IG5hbWUgaW4gX2V2ZW50VHJpZ2dlcnMpIHtcclxuICAgICAgICBpZiAoX21pbiA8PSBfZXZlbnRUcmlnZ2Vyc1tuYW1lXSAmJiBfZXZlbnRUcmlnZ2Vyc1tuYW1lXSA8IF9tYXgpIHtcclxuICAgICAgICAgIGV2ZW50c1RvVHJpZ2dlci5wdXNoKG5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZXZlbnRzVG9UcmlnZ2VyO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vVHJhbnNmZXIvU2VyaWFsaXplci50c1wiLz5cclxuLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9UcmFuc2Zlci9NdXRhYmxlLnRzXCIvPlxyXG5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlcyB0aGUgdmFsdWVzIGJldHdlZW4gW1tBbmltYXRpb25LZXldXXMuXHJcbiAgICogUmVwcmVzZW50ZWQgaW50ZXJuYWxseSBieSBhIGN1YmljIGZ1bmN0aW9uIChgZih4KSA9IGF4wrMgKyBieMKyICsgY3ggKyBkYCkuIFxyXG4gICAqIE9ubHkgbmVlZHMgdG8gYmUgcmVjYWxjdWxhdGVkIHdoZW4gdGhlIGtleXMgY2hhbmdlLCBzbyBhdCBydW50aW1lIGl0IHNob3VsZCBvbmx5IGJlIGNhbGN1bGF0ZWQgb25jZS5cclxuICAgKiBAYXV0aG9yIEx1a2FzIFNjaGV1ZXJsZSwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEFuaW1hdGlvbkZ1bmN0aW9uIHtcclxuICAgIHByaXZhdGUgYTogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgYjogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgYzogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgZDogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUga2V5SW46IEFuaW1hdGlvbktleTtcclxuICAgIHByaXZhdGUga2V5T3V0OiBBbmltYXRpb25LZXk7XHJcblxyXG5cclxuICAgIGNvbnN0cnVjdG9yKF9rZXlJbjogQW5pbWF0aW9uS2V5LCBfa2V5T3V0OiBBbmltYXRpb25LZXkgPSBudWxsKSB7XHJcbiAgICAgIHRoaXMua2V5SW4gPSBfa2V5SW47XHJcbiAgICAgIHRoaXMua2V5T3V0ID0gX2tleU91dDtcclxuICAgICAgdGhpcy5jYWxjdWxhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiBhdCB0aGUgZ2l2ZW4gdGltZS5cclxuICAgICAqIEBwYXJhbSBfdGltZSB0aGUgcG9pbnQgaW4gdGltZSBhdCB3aGljaCB0byBldmFsdWF0ZSB0aGUgZnVuY3Rpb24gaW4gbWlsbGlzZWNvbmRzLiBXaWxsIGJlIGNvcnJlY3RlZCBmb3Igb2Zmc2V0IGludGVybmFsbHkuXHJcbiAgICAgKiBAcmV0dXJucyB0aGUgdmFsdWUgYXQgdGhlIGdpdmVuIHRpbWVcclxuICAgICAqL1xyXG4gICAgZXZhbHVhdGUoX3RpbWU6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgIF90aW1lIC09IHRoaXMua2V5SW4uVGltZTtcclxuICAgICAgbGV0IHRpbWUyOiBudW1iZXIgPSBfdGltZSAqIF90aW1lO1xyXG4gICAgICBsZXQgdGltZTM6IG51bWJlciA9IHRpbWUyICogX3RpbWU7XHJcbiAgICAgIHJldHVybiB0aGlzLmEgKiB0aW1lMyArIHRoaXMuYiAqIHRpbWUyICsgdGhpcy5jICogX3RpbWUgKyB0aGlzLmQ7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IHNldEtleUluKF9rZXlJbjogQW5pbWF0aW9uS2V5KSB7XHJcbiAgICAgIHRoaXMua2V5SW4gPSBfa2V5SW47XHJcbiAgICAgIHRoaXMuY2FsY3VsYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IHNldEtleU91dChfa2V5T3V0OiBBbmltYXRpb25LZXkpIHtcclxuICAgICAgdGhpcy5rZXlPdXQgPSBfa2V5T3V0O1xyXG4gICAgICB0aGlzLmNhbGN1bGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogKFJlLSlDYWxjdWxhdGVzIHRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBjdWJpYyBmdW5jdGlvbi5cclxuICAgICAqIFNlZSBodHRwczovL21hdGguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzMxNzM0NjkvY2FsY3VsYXRlLWN1YmljLWVxdWF0aW9uLWZyb20tdHdvLXBvaW50cy1hbmQtdHdvLXNsb3Blcy12YXJpYWJseVxyXG4gICAgICogYW5kIGh0dHBzOi8vamlya2FkZWxsb3JvLmdpdGh1Yi5pby9GVURHRS9Eb2N1bWVudGF0aW9uL0xvZ3MvMTkwNDEwX05vdGl6ZW5fTFNcclxuICAgICAqL1xyXG4gICAgY2FsY3VsYXRlKCk6IHZvaWQge1xyXG4gICAgICBpZiAoIXRoaXMua2V5SW4pIHtcclxuICAgICAgICB0aGlzLmQgPSB0aGlzLmMgPSB0aGlzLmIgPSB0aGlzLmEgPSAwO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIXRoaXMua2V5T3V0IHx8IHRoaXMua2V5SW4uQ29uc3RhbnQpIHtcclxuICAgICAgICB0aGlzLmQgPSB0aGlzLmtleUluLlZhbHVlO1xyXG4gICAgICAgIHRoaXMuYyA9IHRoaXMuYiA9IHRoaXMuYSA9IDA7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgeDE6IG51bWJlciA9IHRoaXMua2V5T3V0LlRpbWUgLSB0aGlzLmtleUluLlRpbWU7XHJcblxyXG4gICAgICB0aGlzLmQgPSB0aGlzLmtleUluLlZhbHVlO1xyXG4gICAgICB0aGlzLmMgPSB0aGlzLmtleUluLlNsb3BlT3V0O1xyXG5cclxuICAgICAgdGhpcy5hID0gKC14MSAqICh0aGlzLmtleUluLlNsb3BlT3V0ICsgdGhpcy5rZXlPdXQuU2xvcGVJbikgLSAyICogdGhpcy5rZXlJbi5WYWx1ZSArIDIgKiB0aGlzLmtleU91dC5WYWx1ZSkgLyAtTWF0aC5wb3coeDEsIDMpO1xyXG4gICAgICB0aGlzLmIgPSAodGhpcy5rZXlPdXQuU2xvcGVJbiAtIHRoaXMua2V5SW4uU2xvcGVPdXQgLSAzICogdGhpcy5hICogTWF0aC5wb3coeDEsIDIpKSAvICgyICogeDEpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn0iLCIvLyAvIDxyZWZlcmVuY2UgcGF0aD1cIi4uL1RyYW5zZmVyL1NlcmlhbGl6ZXIudHNcIi8+XHJcbi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vVHJhbnNmZXIvTXV0YWJsZS50c1wiLz5cclxuXHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEhvbGRzIGluZm9ybWF0aW9uIGFib3V0IHNldCBwb2ludHMgaW4gdGltZSwgdGhlaXIgYWNjb21wYW55aW5nIHZhbHVlcyBhcyB3ZWxsIGFzIHRoZWlyIHNsb3Blcy4gXHJcbiAgICogQWxzbyBob2xkcyBhIHJlZmVyZW5jZSB0byB0aGUgW1tBbmltYXRpb25GdW5jdGlvbl1dcyB0aGF0IGNvbWUgaW4gYW5kIG91dCBvZiB0aGUgc2lkZXMuIFRoZSBbW0FuaW1hdGlvbkZ1bmN0aW9uXV1zIGFyZSBoYW5kbGVkIGJ5IHRoZSBbW0FuaW1hdGlvblNlcXVlbmNlXV1zLlxyXG4gICAqIFNhdmVkIGluc2lkZSBhbiBbW0FuaW1hdGlvblNlcXVlbmNlXV0uXHJcbiAgICogQGF1dGhvciBMdWthcyBTY2hldWVybGUsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBBbmltYXRpb25LZXkgZXh0ZW5kcyBNdXRhYmxlIGltcGxlbWVudHMgU2VyaWFsaXphYmxlIHtcclxuICAgIC8vIFRPRE86IGNoZWNrIGlmIGZ1bmN0aW9uSW4gY2FuIGJlIHJlbW92ZWRcclxuICAgIC8qKkRvbid0IG1vZGlmeSB0aGlzIHVubGVzcyB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZy4qL1xyXG4gICAgZnVuY3Rpb25JbjogQW5pbWF0aW9uRnVuY3Rpb247XHJcbiAgICAvKipEb24ndCBtb2RpZnkgdGhpcyB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmcuKi9cclxuICAgIGZ1bmN0aW9uT3V0OiBBbmltYXRpb25GdW5jdGlvbjtcclxuICAgIFxyXG4gICAgYnJva2VuOiBib29sZWFuO1xyXG5cclxuICAgIHByaXZhdGUgdGltZTogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSB2YWx1ZTogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBjb25zdGFudDogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICAgIHByaXZhdGUgc2xvcGVJbjogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgc2xvcGVPdXQ6IG51bWJlciA9IDA7XHJcblxyXG4gICAgY29uc3RydWN0b3IoX3RpbWU6IG51bWJlciA9IDAsIF92YWx1ZTogbnVtYmVyID0gMCwgX3Nsb3BlSW46IG51bWJlciA9IDAsIF9zbG9wZU91dDogbnVtYmVyID0gMCwgX2NvbnN0YW50OiBib29sZWFuID0gZmFsc2UpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy50aW1lID0gX3RpbWU7XHJcbiAgICAgIHRoaXMudmFsdWUgPSBfdmFsdWU7XHJcbiAgICAgIHRoaXMuc2xvcGVJbiA9IF9zbG9wZUluO1xyXG4gICAgICB0aGlzLnNsb3BlT3V0ID0gX3Nsb3BlT3V0O1xyXG4gICAgICB0aGlzLmNvbnN0YW50ID0gX2NvbnN0YW50O1xyXG5cclxuICAgICAgdGhpcy5icm9rZW4gPSB0aGlzLnNsb3BlSW4gIT0gLXRoaXMuc2xvcGVPdXQ7XHJcbiAgICAgIHRoaXMuZnVuY3Rpb25PdXQgPSBuZXcgQW5pbWF0aW9uRnVuY3Rpb24odGhpcywgbnVsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IFRpbWUoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMudGltZTtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgVGltZShfdGltZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMudGltZSA9IF90aW1lO1xyXG4gICAgICB0aGlzLmZ1bmN0aW9uSW4uY2FsY3VsYXRlKCk7XHJcbiAgICAgIHRoaXMuZnVuY3Rpb25PdXQuY2FsY3VsYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IFZhbHVlKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHNldCBWYWx1ZShfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLnZhbHVlID0gX3ZhbHVlO1xyXG4gICAgICB0aGlzLmZ1bmN0aW9uSW4uY2FsY3VsYXRlKCk7XHJcbiAgICAgIHRoaXMuZnVuY3Rpb25PdXQuY2FsY3VsYXRlKCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGdldCBDb25zdGFudCgpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY29uc3RhbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IENvbnN0YW50KF9jb25zdGFudDogYm9vbGVhbikge1xyXG4gICAgICB0aGlzLmNvbnN0YW50ID0gX2NvbnN0YW50O1xyXG4gICAgICB0aGlzLmZ1bmN0aW9uSW4uY2FsY3VsYXRlKCk7XHJcbiAgICAgIHRoaXMuZnVuY3Rpb25PdXQuY2FsY3VsYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IFNsb3BlSW4oKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc2xvcGVJbjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgc2V0IFNsb3BlSW4oX3Nsb3BlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5zbG9wZUluID0gX3Nsb3BlO1xyXG4gICAgICB0aGlzLmZ1bmN0aW9uSW4uY2FsY3VsYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IFNsb3BlT3V0KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNsb3BlT3V0O1xyXG4gICAgfVxyXG5cclxuICAgIHNldCBTbG9wZU91dChfc2xvcGU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLnNsb3BlT3V0ID0gX3Nsb3BlO1xyXG4gICAgICB0aGlzLmZ1bmN0aW9uT3V0LmNhbGN1bGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RhdGljIGNvbXBhcmF0aW9uIGZ1bmN0aW9uIHRvIHVzZSBpbiBhbiBhcnJheSBzb3J0IGZ1bmN0aW9uIHRvIHNvcnQgdGhlIGtleXMgYnkgdGhlaXIgdGltZS5cclxuICAgICAqIEBwYXJhbSBfYSB0aGUgYW5pbWF0aW9uIGtleSB0byBjaGVja1xyXG4gICAgICogQHBhcmFtIF9iIHRoZSBhbmltYXRpb24ga2V5IHRvIGNoZWNrIGFnYWluc3RcclxuICAgICAqIEByZXR1cm5zID4wIGlmIGE+YiwgMCBpZiBhPWIsIDwwIGlmIGE8YlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY29tcGFyZShfYTogQW5pbWF0aW9uS2V5LCBfYjogQW5pbWF0aW9uS2V5KTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIF9hLnRpbWUgLSBfYi50aW1lO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiB0cmFuc2ZlclxyXG4gICAgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgczogU2VyaWFsaXphdGlvbiA9IHt9O1xyXG4gICAgICBzLnRpbWUgPSB0aGlzLnRpbWU7XHJcbiAgICAgIHMudmFsdWUgPSB0aGlzLnZhbHVlO1xyXG4gICAgICBzLnNsb3BlSW4gPSB0aGlzLnNsb3BlSW47XHJcbiAgICAgIHMuc2xvcGVPdXQgPSB0aGlzLnNsb3BlT3V0O1xyXG4gICAgICBzLmNvbnN0YW50ID0gdGhpcy5jb25zdGFudDtcclxuICAgICAgcmV0dXJuIHM7XHJcbiAgICB9XHJcblxyXG4gICAgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBTZXJpYWxpemFibGUge1xyXG4gICAgICB0aGlzLnRpbWUgPSBfc2VyaWFsaXphdGlvbi50aW1lO1xyXG4gICAgICB0aGlzLnZhbHVlID0gX3NlcmlhbGl6YXRpb24udmFsdWU7XHJcbiAgICAgIHRoaXMuc2xvcGVJbiA9IF9zZXJpYWxpemF0aW9uLnNsb3BlSW47XHJcbiAgICAgIHRoaXMuc2xvcGVPdXQgPSBfc2VyaWFsaXphdGlvbi5zbG9wZU91dDtcclxuICAgICAgdGhpcy5jb25zdGFudCA9IF9zZXJpYWxpemF0aW9uLmNvbnN0YW50O1xyXG5cclxuICAgICAgdGhpcy5icm9rZW4gPSB0aGlzLnNsb3BlSW4gIT0gLXRoaXMuc2xvcGVPdXQ7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xyXG4gICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemUoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICAvL1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gIH1cclxuXHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBBIHNlcXVlbmNlIG9mIFtbQW5pbWF0aW9uS2V5XV1zIHRoYXQgaXMgbWFwcGVkIHRvIGFuIGF0dHJpYnV0ZSBvZiBhIFtbTm9kZV1dIG9yIGl0cyBbW0NvbXBvbmVudF1dcyBpbnNpZGUgdGhlIFtbQW5pbWF0aW9uXV0uXHJcbiAgICogUHJvdmlkZXMgZnVuY3Rpb25zIHRvIG1vZGlmeSBzYWlkIGtleXNcclxuICAgKiBAYXV0aG9yIEx1a2FzIFNjaGV1ZXJsZSwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEFuaW1hdGlvblNlcXVlbmNlIGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZSB7XHJcbiAgICBwcml2YXRlIGtleXM6IEFuaW1hdGlvbktleVtdID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFdmFsdWF0ZXMgdGhlIHNlcXVlbmNlIGF0IHRoZSBnaXZlbiBwb2ludCBpbiB0aW1lLlxyXG4gICAgICogQHBhcmFtIF90aW1lIHRoZSBwb2ludCBpbiB0aW1lIGF0IHdoaWNoIHRvIGV2YWx1YXRlIHRoZSBzZXF1ZW5jZSBpbiBtaWxsaXNlY29uZHMuXHJcbiAgICAgKiBAcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHNlcXVlbmNlIGF0IHRoZSBnaXZlbiB0aW1lLiAwIGlmIHRoZXJlIGFyZSBubyBrZXlzLlxyXG4gICAgICovXHJcbiAgICBldmFsdWF0ZShfdGltZTogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgICAgaWYgKHRoaXMua2V5cy5sZW5ndGggPT0gMClcclxuICAgICAgICByZXR1cm4gMDsgLy9UT0RPOiBzaG91bGRuJ3QgcmV0dXJuIDAgYnV0IHNvbWV0aGluZyBpbmRpY2F0aW5nIG5vIGNoYW5nZSwgbGlrZSBudWxsLiBwcm9iYWJseSBuZWVkcyB0byBiZSBjaGFuZ2VkIGluIE5vZGUgYXMgd2VsbCB0byBpZ25vcmUgbm9uLW51bWVyaWMgdmFsdWVzIGluIHRoZSBhcHBseUFuaW1hdGlvbiBmdW5jdGlvblxyXG4gICAgICBpZiAodGhpcy5rZXlzLmxlbmd0aCA9PSAxIHx8IHRoaXMua2V5c1swXS5UaW1lID49IF90aW1lKVxyXG4gICAgICAgIHJldHVybiB0aGlzLmtleXNbMF0uVmFsdWU7XHJcblxyXG5cclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMua2V5cy5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICBpZiAodGhpcy5rZXlzW2ldLlRpbWUgPD0gX3RpbWUgJiYgdGhpcy5rZXlzW2kgKyAxXS5UaW1lID4gX3RpbWUpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLmtleXNbaV0uZnVuY3Rpb25PdXQuZXZhbHVhdGUoX3RpbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy5rZXlzW3RoaXMua2V5cy5sZW5ndGggLSAxXS5WYWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBuZXcga2V5IHRvIHRoZSBzZXF1ZW5jZS5cclxuICAgICAqIEBwYXJhbSBfa2V5IHRoZSBrZXkgdG8gYWRkXHJcbiAgICAgKi9cclxuICAgIGFkZEtleShfa2V5OiBBbmltYXRpb25LZXkpOiB2b2lkIHtcclxuICAgICAgdGhpcy5rZXlzLnB1c2goX2tleSk7XHJcbiAgICAgIHRoaXMua2V5cy5zb3J0KEFuaW1hdGlvbktleS5jb21wYXJlKTtcclxuICAgICAgdGhpcy5yZWdlbmVyYXRlRnVuY3Rpb25zKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgZ2l2ZW4ga2V5IGZyb20gdGhlIHNlcXVlbmNlLlxyXG4gICAgICogQHBhcmFtIF9rZXkgdGhlIGtleSB0byByZW1vdmVcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlS2V5KF9rZXk6IEFuaW1hdGlvbktleSk6IHZvaWQge1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5rZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKHRoaXMua2V5c1tpXSA9PSBfa2V5KSB7XHJcbiAgICAgICAgICB0aGlzLmtleXMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgdGhpcy5yZWdlbmVyYXRlRnVuY3Rpb25zKCk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBBbmltYXRpb24gS2V5IGF0IHRoZSBnaXZlbiBpbmRleCBmcm9tIHRoZSBrZXlzLlxyXG4gICAgICogQHBhcmFtIF9pbmRleCB0aGUgemVyby1iYXNlZCBpbmRleCBhdCB3aGljaCB0byByZW1vdmUgdGhlIGtleVxyXG4gICAgICogQHJldHVybnMgdGhlIHJlbW92ZWQgQW5pbWF0aW9uS2V5IGlmIHN1Y2Nlc3NmdWwsIG51bGwgb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICByZW1vdmVLZXlBdEluZGV4KF9pbmRleDogbnVtYmVyKTogQW5pbWF0aW9uS2V5IHtcclxuICAgICAgaWYgKF9pbmRleCA8IDAgfHwgX2luZGV4ID49IHRoaXMua2V5cy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICBsZXQgYWs6IEFuaW1hdGlvbktleSA9IHRoaXMua2V5c1tfaW5kZXhdO1xyXG4gICAgICB0aGlzLmtleXMuc3BsaWNlKF9pbmRleCwgMSk7XHJcbiAgICAgIHRoaXMucmVnZW5lcmF0ZUZ1bmN0aW9ucygpO1xyXG4gICAgICByZXR1cm4gYWs7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEga2V5IGZyb20gdGhlIHNlcXVlbmNlIGF0IHRoZSBkZXNpcmVkIGluZGV4LlxyXG4gICAgICogQHBhcmFtIF9pbmRleCB0aGUgemVyby1iYXNlZCBpbmRleCBhdCB3aGljaCB0byBnZXQgdGhlIGtleVxyXG4gICAgICogQHJldHVybnMgdGhlIEFuaW1hdGlvbktleSBhdCB0aGUgaW5kZXggaWYgaXQgZXhpc3RzLCBudWxsIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgZ2V0S2V5KF9pbmRleDogbnVtYmVyKTogQW5pbWF0aW9uS2V5IHtcclxuICAgICAgaWYgKF9pbmRleCA8IDAgfHwgX2luZGV4ID49IHRoaXMua2V5cy5sZW5ndGgpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIHJldHVybiB0aGlzLmtleXNbX2luZGV4XTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgbGVuZ3RoKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmtleXMubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiB0cmFuc2ZlclxyXG4gICAgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgczogU2VyaWFsaXphdGlvbiA9IHtcclxuICAgICAgICBrZXlzOiBbXSxcclxuICAgICAgICBhbmltYXRpb25TZXF1ZW5jZTogdHJ1ZVxyXG4gICAgICB9O1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5rZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgcy5rZXlzW2ldID0gdGhpcy5rZXlzW2ldLnNlcmlhbGl6ZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBzO1xyXG4gICAgfVxyXG4gICAgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBTZXJpYWxpemFibGUge1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgX3NlcmlhbGl6YXRpb24ua2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIC8vIHRoaXMua2V5cy5wdXNoKDxBbmltYXRpb25LZXk+U2VyaWFsaXplci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5rZXlzW2ldKSk7XHJcbiAgICAgICAgbGV0IGs6IEFuaW1hdGlvbktleSA9IG5ldyBBbmltYXRpb25LZXkoKTtcclxuICAgICAgICBrLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLmtleXNbaV0pO1xyXG4gICAgICAgIHRoaXMua2V5c1tpXSA9IGs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMucmVnZW5lcmF0ZUZ1bmN0aW9ucygpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIC8vXHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvKipcclxuICAgICAqIFV0aWxpdHkgZnVuY3Rpb24gdGhhdCAocmUtKWdlbmVyYXRlcyBhbGwgZnVuY3Rpb25zIGluIHRoZSBzZXF1ZW5jZS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSByZWdlbmVyYXRlRnVuY3Rpb25zKCk6IHZvaWQge1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5rZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IGY6IEFuaW1hdGlvbkZ1bmN0aW9uID0gbmV3IEFuaW1hdGlvbkZ1bmN0aW9uKHRoaXMua2V5c1tpXSk7XHJcbiAgICAgICAgdGhpcy5rZXlzW2ldLmZ1bmN0aW9uT3V0ID0gZjtcclxuICAgICAgICBpZiAoaSA9PSB0aGlzLmtleXMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgLy9UT0RPOiBjaGVjayBpZiB0aGlzIGlzIGV2ZW4gdXNlZnVsLiBNYXliZSB1cGRhdGUgdGhlIHJ1bmNvbmRpdGlvbiB0byBsZW5ndGggLSAxIGluc3RlYWQuIE1pZ2h0IGJlIHJlZHVuZGFudCBpZiBmdW5jdGlvbkluIGlzIHJlbW92ZWQsIHNlZSBUT0RPIGluIEFuaW1hdGlvbktleS5cclxuICAgICAgICAgIGYuc2V0S2V5T3V0ID0gdGhpcy5rZXlzWzBdO1xyXG4gICAgICAgICAgdGhpcy5rZXlzWzBdLmZ1bmN0aW9uSW4gPSBmO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGYuc2V0S2V5T3V0ID0gdGhpcy5rZXlzW2kgKyAxXTtcclxuICAgICAgICB0aGlzLmtleXNbaSArIDFdLmZ1bmN0aW9uSW4gPSBmO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogRXh0ZW5zaW9uIG9mIEF1ZGlvQnVmZmVyIHdpdGggYSBsb2FkIG1ldGhvZCB0aGF0IGNyZWF0ZXMgYSBidWZmZXIgaW4gdGhlIFtbQXVkaW9NYW5hZ2VyXV0uZGVmYXVsdCB0byBiZSB1c2VkIHdpdGggW1tDb21wb25lbnRBdWRpb11dXHJcbiAgICogQGF1dGhvcnMgVGhvbWFzIERvcm5lciwgSEZVLCAyMDE5IHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjBcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQXVkaW8gZXh0ZW5kcyBBdWRpb0J1ZmZlciB7XHJcbiAgICAvKipcclxuICAgICAqIEFzeW5jaHJvbm91c2x5IGxvYWRzIHRoZSBhdWRpbyAobXAzKSBmcm9tIHRoZSBnaXZlbiB1cmxcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBhc3luYyBsb2FkKF91cmw6IHN0cmluZyk6IFByb21pc2U8QXVkaW8+IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2U6IFJlc3BvbnNlID0gYXdhaXQgd2luZG93LmZldGNoKF91cmwpO1xyXG4gICAgICBjb25zdCBhcnJheUJ1ZmZlcjogQXJyYXlCdWZmZXIgPSBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xyXG4gICAgICByZXR1cm4gPEF1ZGlvPihhd2FpdCBBdWRpb01hbmFnZXIuZGVmYXVsdC5kZWNvZGVBdWRpb0RhdGEoYXJyYXlCdWZmZXIpKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBFeHRlbmRzIHRoZSBzdGFuZGFyZCBBdWRpb0NvbnRleHQgZm9yIGludGVncmF0aW9uIHdpdGggRlVER0UtZ3JhcGhzLlxyXG4gICAqIENyZWF0ZXMgYSBkZWZhdWx0IG9iamVjdCBhdCBzdGFydHVwIHRvIGJlIGFkZHJlc3NlZCBhcyBBdWRpb01hbmFnZXIgZGVmYXVsdC5cclxuICAgKiBPdGhlciBvYmplY3RzIG9mIHRoaXMgY2xhc3MgbWF5IGJlIGNyZWF0ZSBmb3Igc3BlY2lhbCBwdXJwb3Nlcy5cclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQXVkaW9NYW5hZ2VyIGV4dGVuZHMgQXVkaW9Db250ZXh0IHtcclxuICAgIC8qKiBUaGUgZGVmYXVsdCBjb250ZXh0IHRoYXQgbWF5IGJlIHVzZWQgdGhyb3VnaG91dCB0aGUgcHJvamVjdCB3aXRob3V0IHRoZSBuZWVkIHRvIGNyZWF0ZSBvdGhlcnMgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgZGVmYXVsdDogQXVkaW9NYW5hZ2VyID0gbmV3IEF1ZGlvTWFuYWdlcih7IGxhdGVuY3lIaW50OiBcImludGVyYWN0aXZlXCIsIHNhbXBsZVJhdGU6IDQ0MTAwIH0pO1xyXG4gICAgLyoqIFRoZSBtYXN0ZXIgdm9sdW1lIGFsbCBBdWRpb05vZGVzIGluIHRoZSBjb250ZXh0IHNob3VsZCBhdHRhY2ggdG8gKi9cclxuICAgIHB1YmxpYyByZWFkb25seSBnYWluOiBHYWluTm9kZTtcclxuICAgIHByaXZhdGUgZ3JhcGg6IE5vZGUgPSBudWxsO1xyXG4gICAgcHJpdmF0ZSBjbXBMaXN0ZW5lcjogQ29tcG9uZW50QXVkaW9MaXN0ZW5lciA9IG51bGw7XHJcblxyXG4gICAgY29uc3RydWN0b3IoY29udGV4dE9wdGlvbnM/OiBBdWRpb0NvbnRleHRPcHRpb25zKSB7XHJcbiAgICAgIHN1cGVyKGNvbnRleHRPcHRpb25zKTtcclxuICAgICAgdGhpcy5nYWluID0gdGhpcy5jcmVhdGVHYWluKCk7XHJcbiAgICAgIHRoaXMuZ2Fpbi5jb25uZWN0KHRoaXMuZGVzdGluYXRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBtYXN0ZXIgdm9sdW1lXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQgdm9sdW1lKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuZ2Fpbi5nYWluLnZhbHVlID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBtYXN0ZXIgdm9sdW1lXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgdm9sdW1lKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdhaW4uZ2Fpbi52YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZXMgRlVER0UtZ3JhcGggdG8gbGlzdGVuIHRvLiBFYWNoIFtbQ29tcG9uZW50QXVkaW9dXSBpbiB0aGUgZ3JhcGggd2lsbCBjb25uZWN0IHRvIHRoaXMgY29udGV4dHMgbWFzdGVyIGdhaW4sIGFsbCBvdGhlcnMgZGlzY29ubmVjdC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGxpc3RlblRvID0gKF9ncmFwaDogTm9kZSB8IG51bGwpOiB2b2lkID0+IHtcclxuICAgICAgaWYgKHRoaXMuZ3JhcGgpXHJcbiAgICAgICAgdGhpcy5ncmFwaC5icm9hZGNhc3RFdmVudChuZXcgRXZlbnQoRVZFTlRfQVVESU8uQ0hJTERfUkVNT1ZFKSk7XHJcbiAgICAgIGlmICghX2dyYXBoKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgdGhpcy5ncmFwaCA9IF9ncmFwaDtcclxuICAgICAgdGhpcy5ncmFwaC5icm9hZGNhc3RFdmVudChuZXcgRXZlbnQoRVZFTlRfQVVESU8uQ0hJTERfQVBQRU5EKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZSB0aGUgRlVER0UtZ3JhcGggY3VycmVudGx5IGxpc3RlbmluZyB0b1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0R3JhcGhMaXN0ZW5pbmdUbyA9ICgpOiBOb2RlID0+IHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ3JhcGg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIFtbQ29tcG9uZW50QXVkaW9MaXN0ZW5lcl1dIHRoYXQgc2VydmVzIHRoZSBzcGF0aWFsIGxvY2F0aW9uIGFuZCBvcmllbnRhdGlvbiBmb3IgdGhpcyBjb250ZXh0cyBsaXN0ZW5lclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbGlzdGVuID0gKF9jbXBMaXN0ZW5lcjogQ29tcG9uZW50QXVkaW9MaXN0ZW5lciB8IG51bGwpOiB2b2lkID0+IHtcclxuICAgICAgdGhpcy5jbXBMaXN0ZW5lciA9IF9jbXBMaXN0ZW5lcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIHNwYXRpYWwgc2V0dGluZ3Mgb2YgdGhlIEF1ZGlvTm9kZXMgZWZmZWN0ZWQgaW4gdGhlIGN1cnJlbnQgRlVER0UtZ3JhcGhcclxuICAgICAqL1xyXG4gICAgcHVibGljIHVwZGF0ZSA9ICgpOiB2b2lkID0+IHtcclxuICAgICAgdGhpcy5ncmFwaC5icm9hZGNhc3RFdmVudChuZXcgRXZlbnQoRVZFTlRfQVVESU8uVVBEQVRFKSk7XHJcbiAgICAgIGlmICh0aGlzLmNtcExpc3RlbmVyKVxyXG4gICAgICAgIHRoaXMuY21wTGlzdGVuZXIudXBkYXRlKHRoaXMubGlzdGVuZXIpO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIi8vIG5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gICAgXHJcbi8vICAgICAvKipcclxuLy8gICAgICAqIEVudW1lcmF0b3IgZm9yIGFsbCBwb3NzaWJsZSBPc2NpbGxhdG9yIFR5cGVzXHJcbi8vICAgICAgKi9cclxuLy8gICAgIHR5cGUgT1NDSUxMQVRPUl9UWVBFID0gXCJzaW5lXCIgfCBcInNxdWFyZVwiIHwgXCJzYXd0b290aFwiIHwgXCJ0cmlhbmdsZVwiIHwgXCJjdXN0b21cIjtcclxuXHJcbi8vICAgICAvKipcclxuLy8gICAgICAqIEludGVyZmFjZSB0byBjcmVhdGUgQ3VzdG9tIE9zY2lsbGF0b3IgVHlwZXMuXHJcbi8vICAgICAgKiBTdGFydC0vRW5kcG9pbnQgb2YgYSBjdXN0dW0gY3VydmUgZS5nLiBzaW5lIGN1cnZlLlxyXG4vLyAgICAgICogQm90aCBwYXJhbWV0ZXJzIG5lZWQgdG8gYmUgaW5iZXR3ZWVuIC0xIGFuZCAxLlxyXG4vLyAgICAgICogQHBhcmFtIHN0YXJ0cG9pbnQgc3RhcnRwb2ludCBvZiBhIGN1cnZlIFxyXG4vLyAgICAgICogQHBhcmFtIGVuZHBvaW50IEVuZHBvaW50IG9mIGEgY3VydmUgXHJcbi8vICAgICAgKi9cclxuLy8gICAgIGludGVyZmFjZSBPc2NpbGxhdG9yV2F2ZSB7XHJcbi8vICAgICAgICAgc3RhcnRwb2ludDogbnVtYmVyO1xyXG4vLyAgICAgICAgIGVuZHBvaW50OiBudW1iZXI7XHJcbi8vICAgICB9XHJcbi8vICAgICAvKipcclxuLy8gICAgICAqIEFkZCBhbiBbW0F1ZGlvRmlsdGVyXV0gdG8gYW4gW1tBdWRpb11dXHJcbi8vICAgICAgKiBAYXV0aG9ycyBUaG9tYXMgRG9ybmVyLCBIRlUsIDIwMTlcclxuLy8gICAgICAqL1xyXG4vLyAgICAgZXhwb3J0IGNsYXNzIEF1ZGlvT3NjaWxsYXRvciB7XHJcblxyXG4vLyAgICAgICAgIHB1YmxpYyBhdWRpb09zY2lsbGF0b3I6IE9zY2lsbGF0b3JOb2RlOyBcclxuXHJcbi8vICAgICAgICAgcHJpdmF0ZSBmcmVxdWVuY3k6IG51bWJlcjtcclxuLy8gICAgICAgICBwcml2YXRlIG9zY2lsbGF0b3JUeXBlOiBPU0NJTExBVE9SX1RZUEU7XHJcbi8vICAgICAgICAgcHJpdmF0ZSBvc2NpbGxhdG9yV2F2ZTogUGVyaW9kaWNXYXZlO1xyXG5cclxuLy8gICAgICAgICBwcml2YXRlIGxvY2FsR2FpbjogR2Fpbk5vZGU7XHJcbi8vICAgICAgICAgcHJpdmF0ZSBsb2NhbEdhaW5WYWx1ZTogbnVtYmVyO1xyXG5cclxuLy8gICAgICAgICBjb25zdHJ1Y3RvcihfYXVkaW9TZXR0aW5nczogQXVkaW9TZXR0aW5ncywgX29zY2lsbGF0b3JUeXBlPzogT1NDSUxMQVRPUl9UWVBFKSB7XHJcbi8vICAgICAgICAgICAgIHRoaXMuYXVkaW9Pc2NpbGxhdG9yID0gX2F1ZGlvU2V0dGluZ3MuZ2V0QXVkaW9Db250ZXh0KCkuY3JlYXRlT3NjaWxsYXRvcigpO1xyXG4vLyAgICAgICAgICAgICB0aGlzLmxvY2FsR2FpbiA9IF9hdWRpb1NldHRpbmdzLmdldEF1ZGlvQ29udGV4dCgpLmNyZWF0ZUdhaW4oKTtcclxuLy8gICAgICAgICAgICAgdGhpcy5vc2NpbGxhdG9yVHlwZSA9IF9vc2NpbGxhdG9yVHlwZTtcclxuLy8gICAgICAgICAgICAgaWYgKHRoaXMub3NjaWxsYXRvclR5cGUgIT0gXCJjdXN0b21cIikge1xyXG4vLyAgICAgICAgICAgICAgICAgdGhpcy5hdWRpb09zY2lsbGF0b3IudHlwZSA9IHRoaXMub3NjaWxsYXRvclR5cGU7XHJcbi8vICAgICAgICAgICAgIH1cclxuLy8gICAgICAgICAgICAgZWxzZSB7XHJcbi8vICAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3NjaWxsYXRvcldhdmUpIHtcclxuLy8gICAgICAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvT3NjaWxsYXRvci5zZXRQZXJpb2RpY1dhdmUodGhpcy5vc2NpbGxhdG9yV2F2ZSk7XHJcbi8vICAgICAgICAgICAgICAgICB9XHJcbi8vICAgICAgICAgICAgICAgICBlbHNlIHtcclxuLy8gICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkNyZWF0ZSBhIEN1c3RvbSBQZXJpb2RpYyBXYXZlIGZpcnN0IHRvIHVzZSBDdXN0b20gVHlwZVwiKTtcclxuLy8gICAgICAgICAgICAgICAgIH1cclxuLy8gICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgIH1cclxuXHJcbi8vICAgICAgICAgcHVibGljIHNldE9zY2lsbGF0b3JUeXBlKF9vc2NpbGxhdG9yVHlwZTogT1NDSUxMQVRPUl9UWVBFKTogdm9pZCB7XHJcbi8vICAgICAgICAgICAgIGlmICh0aGlzLm9zY2lsbGF0b3JUeXBlICE9IFwiY3VzdG9tXCIpIHtcclxuLy8gICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9Pc2NpbGxhdG9yLnR5cGUgPSB0aGlzLm9zY2lsbGF0b3JUeXBlO1xyXG4vLyAgICAgICAgICAgICB9XHJcbi8vICAgICAgICAgICAgIGVsc2Uge1xyXG4vLyAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9zY2lsbGF0b3JXYXZlKSB7XHJcbi8vICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdWRpb09zY2lsbGF0b3Iuc2V0UGVyaW9kaWNXYXZlKHRoaXMub3NjaWxsYXRvcldhdmUpO1xyXG4vLyAgICAgICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgICAgICB9XHJcbi8vICAgICAgICAgfVxyXG5cclxuLy8gICAgICAgICBwdWJsaWMgZ2V0T3NjaWxsYXRvclR5cGUoKTogT1NDSUxMQVRPUl9UWVBFIHtcclxuLy8gICAgICAgICAgICAgcmV0dXJuIHRoaXMub3NjaWxsYXRvclR5cGU7XHJcbi8vICAgICAgICAgfVxyXG5cclxuLy8gICAgICAgICBwdWJsaWMgY3JlYXRlUGVyaW9kaWNXYXZlKF9hdWRpb1NldHRpbmdzOiBBdWRpb1NldHRpbmdzLCBfcmVhbDogT3NjaWxsYXRvcldhdmUsIF9pbWFnOiBPc2NpbGxhdG9yV2F2ZSk6IHZvaWQge1xyXG4vLyAgICAgICAgICAgICBsZXQgd2F2ZVJlYWw6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XHJcbi8vICAgICAgICAgICAgIHdhdmVSZWFsWzBdID0gX3JlYWwuc3RhcnRwb2ludDtcclxuLy8gICAgICAgICAgICAgd2F2ZVJlYWxbMV0gPSBfcmVhbC5lbmRwb2ludDtcclxuXHJcbi8vICAgICAgICAgICAgIGxldCB3YXZlSW1hZzogRmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcclxuLy8gICAgICAgICAgICAgd2F2ZUltYWdbMF0gPSBfaW1hZy5zdGFydHBvaW50O1xyXG4vLyAgICAgICAgICAgICB3YXZlSW1hZ1sxXSA9IF9pbWFnLmVuZHBvaW50O1xyXG5cclxuLy8gICAgICAgICAgICAgdGhpcy5vc2NpbGxhdG9yV2F2ZSA9IF9hdWRpb1NldHRpbmdzLmdldEF1ZGlvQ29udGV4dCgpLmNyZWF0ZVBlcmlvZGljV2F2ZSh3YXZlUmVhbCwgd2F2ZUltYWcpO1xyXG4vLyAgICAgICAgIH1cclxuXHJcbi8vICAgICAgICAgcHVibGljIHNldExvY2FsR2FpbihfbG9jYWxHYWluOiBHYWluTm9kZSk6IHZvaWQge1xyXG4vLyAgICAgICAgICAgICB0aGlzLmxvY2FsR2FpbiA9IF9sb2NhbEdhaW47XHJcbi8vICAgICAgICAgfVxyXG5cclxuLy8gICAgICAgICBwdWJsaWMgZ2V0TG9jYWxHYWluKCk6IEdhaW5Ob2RlIHtcclxuLy8gICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxHYWluO1xyXG4vLyAgICAgICAgIH1cclxuXHJcbi8vICAgICAgICAgcHVibGljIHNldExvY2FsR2FpblZhbHVlKF9sb2NhbEdhaW5WYWx1ZTogbnVtYmVyKTogdm9pZCB7XHJcbi8vICAgICAgICAgICAgIHRoaXMubG9jYWxHYWluVmFsdWUgPSBfbG9jYWxHYWluVmFsdWU7XHJcbi8vICAgICAgICAgICAgIHRoaXMubG9jYWxHYWluLmdhaW4udmFsdWUgPSB0aGlzLmxvY2FsR2FpblZhbHVlO1xyXG4vLyAgICAgICAgIH1cclxuXHJcbi8vICAgICAgICAgcHVibGljIGdldExvY2FsR2FpblZhbHVlKCk6IG51bWJlciB7XHJcbi8vICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsR2FpblZhbHVlO1xyXG4vLyAgICAgICAgIH1cclxuXHJcbi8vICAgICAgICAgcHVibGljIHNldEZyZXF1ZW5jeShfYXVkaW9TZXR0aW5nczogQXVkaW9TZXR0aW5ncywgX2ZyZXF1ZW5jeTogbnVtYmVyKTogdm9pZCB7XHJcbi8vICAgICAgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gX2ZyZXF1ZW5jeTtcclxuLy8gICAgICAgICAgICAgdGhpcy5hdWRpb09zY2lsbGF0b3IuZnJlcXVlbmN5LnNldFZhbHVlQXRUaW1lKHRoaXMuZnJlcXVlbmN5LCBfYXVkaW9TZXR0aW5ncy5nZXRBdWRpb0NvbnRleHQoKS5jdXJyZW50VGltZSk7XHJcbi8vICAgICAgICAgfVxyXG5cclxuLy8gICAgICAgICBwdWJsaWMgZ2V0RnJlcXVlbmN5KCk6IG51bWJlciB7XHJcbi8vICAgICAgICAgICAgIHJldHVybiB0aGlzLmZyZXF1ZW5jeTtcclxuLy8gICAgICAgICB9XHJcblxyXG4vLyAgICAgICAgIHB1YmxpYyBjcmVhdGVTbmFyZShfYXVkaW9TZXR0aW5nczogQXVkaW9TZXR0aW5ncyk6IHZvaWQge1xyXG4vLyAgICAgICAgICAgICB0aGlzLnNldE9zY2lsbGF0b3JUeXBlKFwidHJpYW5nbGVcIik7XHJcbi8vICAgICAgICAgICAgIHRoaXMuc2V0RnJlcXVlbmN5KF9hdWRpb1NldHRpbmdzLCAxMDApO1xyXG4vLyAgICAgICAgICAgICB0aGlzLnNldExvY2FsR2FpblZhbHVlKDApO1xyXG4vLyAgICAgICAgICAgICB0aGlzLmxvY2FsR2Fpbi5nYWluLnNldFZhbHVlQXRUaW1lKDAsIF9hdWRpb1NldHRpbmdzLmdldEF1ZGlvQ29udGV4dCgpLmN1cnJlbnRUaW1lKTtcclxuLy8gICAgICAgICAgICAgdGhpcy5sb2NhbEdhaW4uZ2Fpbi5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKDAuMDEsIF9hdWRpb1NldHRpbmdzLmdldEF1ZGlvQ29udGV4dCgpLmN1cnJlbnRUaW1lICsgLjEpO1xyXG5cclxuLy8gICAgICAgICAgICAgdGhpcy5hdWRpb09zY2lsbGF0b3IuY29ubmVjdCh0aGlzLmxvY2FsR2Fpbik7XHJcbi8vICAgICAgICAgfVxyXG4vLyAgICAgfVxyXG4vLyB9IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgICAvKipcclxuICAgICAqIEhvbGRzIGRhdGEgdG8gZmVlZCBpbnRvIGEgW1tTaGFkZXJdXSB0byBkZXNjcmliZSB0aGUgc3VyZmFjZSBvZiBbW01lc2hdXS4gIFxyXG4gICAgICogW1tNYXRlcmlhbF1dcyByZWZlcmVuY2UgW1tDb2F0XV0gYW5kIFtbU2hhZGVyXV0uICAgXHJcbiAgICAgKiBUaGUgbWV0aG9kIHVzZVJlbmRlckRhdGEgd2lsbCBiZSBpbmplY3RlZCBieSBbW1JlbmRlckluamVjdG9yXV0gYXQgcnVudGltZSwgZXh0ZW5kaW5nIHRoZSBmdW5jdGlvbmFsaXR5IG9mIHRoaXMgY2xhc3MgdG8gZGVhbCB3aXRoIHRoZSByZW5kZXJlci5cclxuICAgICAqL1xyXG4gICAgZXhwb3J0IGNsYXNzIENvYXQgZXh0ZW5kcyBNdXRhYmxlIGltcGxlbWVudHMgU2VyaWFsaXphYmxlIHtcclxuICAgICAgICBwdWJsaWMgbmFtZTogc3RyaW5nID0gXCJDb2F0XCI7XHJcbiAgICAgICAgcHJvdGVjdGVkIHJlbmRlckRhdGE6IHtba2V5OiBzdHJpbmddOiB1bmtub3dufTtcclxuXHJcbiAgICAgICAgcHVibGljIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICAgICAgICBzdXBlci5tdXRhdGUoX211dGF0b3IpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHVzZVJlbmRlckRhdGEoX3NoYWRlcjogdHlwZW9mIFNoYWRlciwgX2NtcE1hdGVyaWFsOiBDb21wb25lbnRNYXRlcmlhbCk6IHZvaWQgey8qIGluamVjdGVkIGJ5IFJlbmRlckluamVjdG9yKi8gfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgICAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gdGhpcy5nZXRNdXRhdG9yKCk7IFxyXG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVibGljIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogU2VyaWFsaXphYmxlIHtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKCk6IHZvaWQgeyAvKiovIH1cclxuICAgICAgICAvLyNlbmRyZWdpb25cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzaW1wbGVzdCBbW0NvYXRdXSBwcm92aWRpbmcganVzdCBhIGNvbG9yXHJcbiAgICAgKi9cclxuICAgIEBSZW5kZXJJbmplY3RvckNvYXQuZGVjb3JhdGVcclxuICAgIGV4cG9ydCBjbGFzcyBDb2F0Q29sb3JlZCBleHRlbmRzIENvYXQge1xyXG4gICAgICAgIHB1YmxpYyBjb2xvcjogQ29sb3I7XHJcblxyXG4gICAgICAgIGNvbnN0cnVjdG9yKF9jb2xvcj86IENvbG9yKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29sb3IgPSBfY29sb3IgfHwgbmV3IENvbG9yKDAuNSwgMC41LCAwLjUsIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgW1tDb2F0XV0gdG8gYmUgdXNlZCBieSB0aGUgTWF0Q2FwIFNoYWRlciBwcm92aWRpbmcgYSB0ZXh0dXJlLCBhIHRpbnQgY29sb3IgKDAuNSBncmV5IGlzIG5ldXRyYWwpLiBTZXQgc2hhZGVTbW9vdGggdG8gMSBmb3Igc21vb3RoIHNoYWRpbmcuXHJcbiAgICAgKi9cclxuICAgIEBSZW5kZXJJbmplY3RvckNvYXQuZGVjb3JhdGVcclxuICAgIGV4cG9ydCBjbGFzcyBDb2F0TWF0Q2FwIGV4dGVuZHMgQ29hdCB7XHJcbiAgICAgICAgcHVibGljIHRleHR1cmU6IFRleHR1cmVJbWFnZSA9IG51bGw7XHJcbiAgICAgICAgcHVibGljIGNvbG9yOiBDb2xvciA9IG5ldyBDb2xvcigwLjUsIDAuNSwgMC41LCAxKTtcclxuICAgICAgICBwdWJsaWMgc2hhZGVTbW9vdGg6IG51bWJlcjtcclxuXHJcbiAgICAgICAgY29uc3RydWN0b3IoX3RleHR1cmU/OiBUZXh0dXJlSW1hZ2UsIF9jb2xvcj86IENvbG9yLCBfc2hhZGVTbW9vdGg/OiBudW1iZXIpIHtcclxuICAgICAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICAgICAgdGhpcy50ZXh0dXJlID0gX3RleHR1cmUgfHwgbmV3IFRleHR1cmVJbWFnZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbG9yID0gX2NvbG9yIHx8IG5ldyBDb2xvcigwLjUsIDAuNSwgMC41LCAxKTtcclxuICAgICAgICAgICAgdGhpcy5zaGFkZVNtb290aCA9IF9zaGFkZVNtb290aCB8fCAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEEgW1tDb2F0XV0gcHJvdmlkaW5nIGEgdGV4dHVyZSBhbmQgYWRkaXRpb25hbCBkYXRhIGZvciB0ZXh0dXJpbmdcclxuICAgKi9cclxuICBAUmVuZGVySW5qZWN0b3JDb2F0LmRlY29yYXRlXHJcbiAgZXhwb3J0IGNsYXNzIENvYXRUZXh0dXJlZCBleHRlbmRzIENvYXQge1xyXG4gICAgLy8gVE9ETzogc2VlIGlmIGNvbG9yIHNob3VsZCBiZSBnZW5lcmFsaXplZFxyXG4gICAgcHVibGljIGNvbG9yOiBDb2xvciA9IG5ldyBDb2xvcigxLCAxLCAxLCAxKTtcclxuICAgIHB1YmxpYyB0ZXh0dXJlOiBUZXh0dXJlSW1hZ2UgPSBudWxsO1xyXG4gICAgLy8ganVzdCBpZGVhcyBzbyBmYXJcclxuICAgIHB1YmxpYyB0aWxpbmdYOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgdGlsaW5nWTogbnVtYmVyO1xyXG4gICAgcHVibGljIHJlcGV0aXRpb246IGJvb2xlYW47XHJcblxyXG4gICAgLy8gY29uc3RydWN0b3IoX3RleHR1cmU6IFRleHR1cmVJbWFnZSwgX2NvbG9yPzogQ29sb3IpIHtcclxuICAgIC8vICAgc3VwZXIoKTtcclxuICAgIC8vICAgdGhpcy50ZXh0dXJlID0gX3RleHR1cmU7XHJcbiAgICAvLyAgIHRoaXMuY29sb3IgPSBfY29sb3IgfHwgbmV3IENvbG9yKDEsIDEsIDEsIDEpO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIC8vIHB1YmxpYyBnZXRNdXRhdG9yRm9yQ29tcG9uZW50KCk6IE11dGF0b3JGb3JDb21wb25lbnQge1xyXG4gICAgLy8gICBsZXQgbXV0YXRvclBpdm90OiBNdXRhdG9yRm9yQ29tcG9uZW50ID0gPE11dGF0b3JGb3JDb21wb25lbnQ+PHVua25vd24+dGhpcy5waXZvdC5nZXRNdXRhdG9yKCk7XHJcbiAgICAvLyAgIHJldHVybiBtdXRhdG9yUGl2b3Q7XHJcbiAgICAvLyB9XHJcblxyXG4gICAgLy8gcHVibGljIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvckZvckNvbXBvbmVudCk6IHZvaWQge1xyXG4gICAgLy8gICB0aGlzLnBpdm90Lm11dGF0ZShfbXV0YXRvcik7XHJcbiAgICAvLyB9XHJcbiAgfVxyXG59IiwiLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9UcmFuc2Zlci9TZXJpYWxpemVyLnRzXCIvPlxyXG4vLyAvIDxyZWZlcmVuY2UgcGF0aD1cIi4uL1RyYW5zZmVyL011dGFibGUudHNcIi8+XHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKiBcclxuICAgKiBTdXBlcmNsYXNzIGZvciBhbGwgW1tDb21wb25lbnRdXXMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gW1tOb2RlXV1zLlxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIwIHwgSmFzY2hhIEthcmFnw7ZsLCBIRlUsIDIwMTkgIFxyXG4gICAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9KaXJrYURlbGxPcm8vRlVER0Uvd2lraS9Db21wb25lbnRcclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgQ29tcG9uZW50IGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZSB7XHJcbiAgICAvKiogc3ViY2xhc3NlcyBnZXQgYSBpU3ViY2xhc3MgbnVtYmVyIGZvciBpZGVudGlmaWNhdGlvbiAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlcjtcclxuICAgIC8qKiByZWZlcnMgYmFjayB0byB0aGlzIGNsYXNzIGZyb20gYW55IHN1YmNsYXNzIGUuZy4gaW4gb3JkZXIgdG8gZmluZCBjb21wYXRpYmxlIG90aGVyIHJlc291cmNlcyovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGJhc2VDbGFzczogdHlwZW9mIENvbXBvbmVudCA9IENvbXBvbmVudDtcclxuICAgIC8qKiBsaXN0IG9mIGFsbCB0aGUgc3ViY2xhc3NlcyBkZXJpdmVkIGZyb20gdGhpcyBjbGFzcywgaWYgdGhleSByZWdpc3RlcmVkIHByb3Blcmx5Ki9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgc3ViY2xhc3NlczogdHlwZW9mIENvbXBvbmVudFtdID0gW107XHJcblxyXG4gICAgcHJvdGVjdGVkIHNpbmdsZXRvbjogYm9vbGVhbiA9IHRydWU7XHJcbiAgICBwcml2YXRlIGNvbnRhaW5lcjogTm9kZSB8IG51bGwgPSBudWxsO1xyXG4gICAgcHJpdmF0ZSBhY3RpdmU6IGJvb2xlYW4gPSB0cnVlO1xyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVnaXN0ZXJTdWJjbGFzcyhfc3ViY2xhc3M6IHR5cGVvZiBDb21wb25lbnQpOiBudW1iZXIgeyByZXR1cm4gQ29tcG9uZW50LnN1YmNsYXNzZXMucHVzaChfc3ViY2xhc3MpIC0gMTsgfVxyXG5cclxuICAgIHB1YmxpYyBhY3RpdmF0ZShfb246IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgdGhpcy5hY3RpdmUgPSBfb247XHJcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoX29uID8gRVZFTlQuQ09NUE9ORU5UX0FDVElWQVRFIDogRVZFTlQuQ09NUE9ORU5UX0RFQUNUSVZBVEUpKTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBnZXQgaXNBY3RpdmUoKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLmFjdGl2ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIElzIHRydWUsIHdoZW4gb25seSBvbmUgaW5zdGFuY2Ugb2YgdGhlIGNvbXBvbmVudCBjbGFzcyBjYW4gYmUgYXR0YWNoZWQgdG8gYSBub2RlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgaXNTaW5nbGV0b24oKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNpbmdsZXRvbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIHRoZSBub2RlLCB0aGlzIGNvbXBvbmVudCBpcyBjdXJyZW50bHkgYXR0YWNoZWQgdG9cclxuICAgICAqIEByZXR1cm5zIFRoZSBjb250YWluZXIgbm9kZSBvciBudWxsLCBpZiB0aGUgY29tcG9uZW50IGlzIG5vdCBhdHRhY2hlZCB0b1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Q29udGFpbmVyKCk6IE5vZGUgfCBudWxsIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmllcyB0byBhZGQgdGhlIGNvbXBvbmVudCB0byB0aGUgZ2l2ZW4gbm9kZSwgcmVtb3ZpbmcgaXQgZnJvbSB0aGUgcHJldmlvdXMgY29udGFpbmVyIGlmIGFwcGxpY2FibGVcclxuICAgICAqIEBwYXJhbSBfY29udGFpbmVyIFRoZSBub2RlIHRvIGF0dGFjaCB0aGlzIGNvbXBvbmVudCB0b1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0Q29udGFpbmVyKF9jb250YWluZXI6IE5vZGUgfCBudWxsKTogdm9pZCB7XHJcbiAgICAgIGlmICh0aGlzLmNvbnRhaW5lciA9PSBfY29udGFpbmVyKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgbGV0IHByZXZpb3VzQ29udGFpbmVyOiBOb2RlID0gdGhpcy5jb250YWluZXI7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKHByZXZpb3VzQ29udGFpbmVyKVxyXG4gICAgICAgICAgcHJldmlvdXNDb250YWluZXIucmVtb3ZlQ29tcG9uZW50KHRoaXMpO1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gX2NvbnRhaW5lcjtcclxuICAgICAgICBpZiAodGhpcy5jb250YWluZXIpXHJcbiAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRDb21wb25lbnQodGhpcyk7XHJcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gcHJldmlvdXNDb250YWluZXI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgYWN0aXZlOiB0aGlzLmFjdGl2ZVxyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFNlcmlhbGl6YWJsZSB7XHJcbiAgICAgIHRoaXMuYWN0aXZlID0gX3NlcmlhbGl6YXRpb24uYWN0aXZlO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICBkZWxldGUgX211dGF0b3Iuc2luZ2xldG9uO1xyXG4gICAgICBkZWxldGUgX211dGF0b3IuY29udGFpbmVyO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59IiwiLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9UaW1lL0xvb3AudHNcIi8+XHJcbi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vQW5pbWF0aW9uL0FuaW1hdGlvbi50c1wiLz5cclxuXHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEhvbGRzIGRpZmZlcmVudCBwbGF5bW9kZXMgdGhlIGFuaW1hdGlvbiB1c2VzIHRvIHBsYXkgYmFjayBpdHMgYW5pbWF0aW9uLlxyXG4gICAqIEBhdXRob3IgTHVrYXMgU2NoZXVlcmxlLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgZW51bSBBTklNQVRJT05fUExBWU1PREUge1xyXG4gICAgLyoqUGxheXMgYW5pbWF0aW9uIGluIGEgbG9vcDogaXQgcmVzdGFydHMgb25jZSBpdCBoaXQgdGhlIGVuZC4qL1xyXG4gICAgTE9PUCxcclxuICAgIC8qKlBsYXlzIGFuaW1hdGlvbiBvbmNlIGFuZCBzdG9wcyBhdCB0aGUgbGFzdCBrZXkvZnJhbWUqL1xyXG4gICAgUExBWU9OQ0UsXHJcbiAgICAvKipQbGF5cyBhbmltYXRpb24gb25jZSBhbmQgc3RvcHMgb24gdGhlIGZpcnN0IGtleS9mcmFtZSAqL1xyXG4gICAgUExBWU9OQ0VTVE9QQUZURVIsXHJcbiAgICAvKipQbGF5cyBhbmltYXRpb24gbGlrZSBMT09QLCBidXQgYmFja3dhcmRzLiovXHJcbiAgICBSRVZFUlNFTE9PUCxcclxuICAgIC8qKkNhdXNlcyB0aGUgYW5pbWF0aW9uIG5vdCB0byBwbGF5IGF0IGFsbC4gVXNlZnVsIGZvciBqdW1waW5nIHRvIHZhcmlvdXMgcG9zaXRpb25zIGluIHRoZSBhbmltYXRpb24gd2l0aG91dCBwcm9jZWVkaW5nIGluIHRoZSBhbmltYXRpb24uKi9cclxuICAgIFNUT1BcclxuICAgIC8vVE9ETzogYWRkIGFuIElOSEVSSVQgYW5kIGEgUElOR1BPTkcgbW9kZVxyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGVudW0gQU5JTUFUSU9OX1BMQVlCQUNLIHtcclxuICAgIC8vVE9ETzogYWRkIGFuIGluLWRlcHRoIGRlc2NyaXB0aW9uIG9mIHdoYXQgaGFwcGVucyB0byB0aGUgYW5pbWF0aW9uIChhbmQgZXZlbnRzKSBkZXBlbmRpbmcgb24gdGhlIFBsYXliYWNrLiBVc2UgR3JhcGhzIHRvIGV4cGxhaW4uXHJcbiAgICAvKipDYWxjdWxhdGVzIHRoZSBzdGF0ZSBvZiB0aGUgYW5pbWF0aW9uIGF0IHRoZSBleGFjdCBwb3NpdGlvbiBvZiB0aW1lLiBJZ25vcmVzIEZQUyB2YWx1ZSBvZiBhbmltYXRpb24uKi9cclxuICAgIFRJTUVCQVNFRF9DT05USU5PVVMsXHJcbiAgICAvKipMaW1pdHMgdGhlIGNhbGN1bGF0aW9uIG9mIHRoZSBzdGF0ZSBvZiB0aGUgYW5pbWF0aW9uIHRvIHRoZSBGUFMgdmFsdWUgb2YgdGhlIGFuaW1hdGlvbi4gU2tpcHMgZnJhbWVzIGlmIG5lZWRlZC4qL1xyXG4gICAgVElNRUJBU0VEX1JBU1RFUkVEX1RPX0ZQUyxcclxuICAgIC8qKlVzZXMgdGhlIEZQUyB2YWx1ZSBvZiB0aGUgYW5pbWF0aW9uIHRvIGFkdmFuY2Ugb25jZSBwZXIgZnJhbWUsIG5vIG1hdHRlciB0aGUgc3BlZWQgb2YgdGhlIGZyYW1lcy4gRG9lc24ndCBza2lwIGFueSBmcmFtZXMuKi9cclxuICAgIEZSQU1FQkFTRURcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhvbGRzIGEgcmVmZXJlbmNlIHRvIGFuIFtbQW5pbWF0aW9uXV0gYW5kIGNvbnRyb2xzIGl0LiBDb250cm9scyBwbGF5YmFjayBhbmQgcGxheW1vZGUgYXMgd2VsbCBhcyBzcGVlZC5cclxuICAgKiBAYXV0aG9ycyBMdWthcyBTY2hldWVybGUsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb21wb25lbnRBbmltYXRvciBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gQ29tcG9uZW50LnJlZ2lzdGVyU3ViY2xhc3MoQ29tcG9uZW50QW5pbWF0b3IpO1xyXG4gICAgLy9UT0RPOiBhZGQgZnVuY3Rpb25hbGl0eSB0byBibGVuZCBmcm9tIG9uZSBhbmltYXRpb24gdG8gYW5vdGhlci5cclxuICAgIGFuaW1hdGlvbjogQW5pbWF0aW9uO1xyXG4gICAgcGxheW1vZGU6IEFOSU1BVElPTl9QTEFZTU9ERTtcclxuICAgIHBsYXliYWNrOiBBTklNQVRJT05fUExBWUJBQ0s7XHJcbiAgICBzcGVlZFNjYWxlc1dpdGhHbG9iYWxTcGVlZDogYm9vbGVhbiA9IHRydWU7XHJcblxyXG4gICAgcHJpdmF0ZSBsb2NhbFRpbWU6IFRpbWU7XHJcbiAgICBwcml2YXRlIHNwZWVkU2NhbGU6IG51bWJlciA9IDE7XHJcbiAgICBwcml2YXRlIGxhc3RUaW1lOiBudW1iZXIgPSAwO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKF9hbmltYXRpb246IEFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oXCJcIiksIF9wbGF5bW9kZTogQU5JTUFUSU9OX1BMQVlNT0RFID0gQU5JTUFUSU9OX1BMQVlNT0RFLkxPT1AsIF9wbGF5YmFjazogQU5JTUFUSU9OX1BMQVlCQUNLID0gQU5JTUFUSU9OX1BMQVlCQUNLLlRJTUVCQVNFRF9DT05USU5PVVMpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5hbmltYXRpb24gPSBfYW5pbWF0aW9uO1xyXG4gICAgICB0aGlzLnBsYXltb2RlID0gX3BsYXltb2RlO1xyXG4gICAgICB0aGlzLnBsYXliYWNrID0gX3BsYXliYWNrO1xyXG5cclxuICAgICAgdGhpcy5sb2NhbFRpbWUgPSBuZXcgVGltZSgpO1xyXG5cclxuICAgICAgLy9UT0RPOiB1cGRhdGUgYW5pbWF0aW9uIHRvdGFsIHRpbWUgd2hlbiBsb2FkaW5nIGEgZGlmZmVyZW50IGFuaW1hdGlvbj9cclxuICAgICAgdGhpcy5hbmltYXRpb24uY2FsY3VsYXRlVG90YWxUaW1lKCk7XHJcblxyXG4gICAgICBMb29wLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuTE9PUF9GUkFNRSwgdGhpcy51cGRhdGVBbmltYXRpb25Mb29wLmJpbmQodGhpcykpO1xyXG4gICAgICBUaW1lLmdhbWUuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5USU1FX1NDQUxFRCwgdGhpcy51cGRhdGVTY2FsZS5iaW5kKHRoaXMpKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgc3BlZWQoX3M6IG51bWJlcikge1xyXG4gICAgICB0aGlzLnNwZWVkU2NhbGUgPSBfcztcclxuICAgICAgdGhpcy51cGRhdGVTY2FsZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSnVtcHMgdG8gYSBjZXJ0YWluIHRpbWUgaW4gdGhlIGFuaW1hdGlvbiB0byBwbGF5IGZyb20gdGhlcmUuXHJcbiAgICAgKiBAcGFyYW0gX3RpbWUgVGhlIHRpbWUgdG8ganVtcCB0b1xyXG4gICAgICovXHJcbiAgICBqdW1wVG8oX3RpbWU6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICB0aGlzLmxvY2FsVGltZS5zZXQoX3RpbWUpO1xyXG4gICAgICB0aGlzLmxhc3RUaW1lID0gX3RpbWU7XHJcbiAgICAgIF90aW1lID0gX3RpbWUgJSB0aGlzLmFuaW1hdGlvbi50b3RhbFRpbWU7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0gdGhpcy5hbmltYXRpb24uZ2V0TXV0YXRlZChfdGltZSwgdGhpcy5jYWxjdWxhdGVEaXJlY3Rpb24oX3RpbWUpLCB0aGlzLnBsYXliYWNrKTtcclxuICAgICAgdGhpcy5nZXRDb250YWluZXIoKS5hcHBseUFuaW1hdGlvbihtdXRhdG9yKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgdGltZSBvZiB0aGUgYW5pbWF0aW9uLCBtb2R1bGF0ZWQgZm9yIGFuaW1hdGlvbiBsZW5ndGguXHJcbiAgICAgKi9cclxuICAgIGdldEN1cnJlbnRUaW1lKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmxvY2FsVGltZS5nZXQoKSAlIHRoaXMuYW5pbWF0aW9uLnRvdGFsVGltZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZvcmNlcyBhbiB1cGRhdGUgb2YgdGhlIGFuaW1hdGlvbiBmcm9tIG91dHNpZGUuIFVzZWQgaW4gdGhlIFZpZXdBbmltYXRpb24uIFNob3VsZG4ndCBiZSB1c2VkIGR1cmluZyB0aGUgZ2FtZS5cclxuICAgICAqIEBwYXJhbSBfdGltZSB0aGUgKHVuc2NhbGVkKSB0aW1lIHRvIHVwZGF0ZSB0aGUgYW5pbWF0aW9uIHdpdGguXHJcbiAgICAgKiBAcmV0dXJucyBhIFR1cGVsIGNvbnRhaW5pbmcgdGhlIE11dGF0b3IgZm9yIEFuaW1hdGlvbiBhbmQgdGhlIHBsYXltb2RlIGNvcnJlY3RlZCB0aW1lLiBcclxuICAgICAqL1xyXG4gICAgdXBkYXRlQW5pbWF0aW9uKF90aW1lOiBudW1iZXIpOiBbTXV0YXRvciwgbnVtYmVyXSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUFuaW1hdGlvbkxvb3AobnVsbCwgX3RpbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiB0cmFuc2ZlclxyXG4gICAgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgczogU2VyaWFsaXphdGlvbiA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICBzW1wiYW5pbWF0aW9uXCJdID0gdGhpcy5hbmltYXRpb24uc2VyaWFsaXplKCk7XHJcbiAgICAgIHNbXCJwbGF5bW9kZVwiXSA9IHRoaXMucGxheW1vZGU7XHJcbiAgICAgIHNbXCJwbGF5YmFja1wiXSA9IHRoaXMucGxheWJhY2s7XHJcbiAgICAgIHNbXCJzcGVlZFNjYWxlXCJdID0gdGhpcy5zcGVlZFNjYWxlO1xyXG4gICAgICBzW1wic3BlZWRTY2FsZXNXaXRoR2xvYmFsU3BlZWRcIl0gPSB0aGlzLnNwZWVkU2NhbGVzV2l0aEdsb2JhbFNwZWVkO1xyXG5cclxuICAgICAgc1tzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG5cclxuICAgICAgcmV0dXJuIHM7XHJcbiAgICB9XHJcblxyXG4gICAgZGVzZXJpYWxpemUoX3M6IFNlcmlhbGl6YXRpb24pOiBTZXJpYWxpemFibGUge1xyXG4gICAgICB0aGlzLmFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oXCJcIik7XHJcbiAgICAgIHRoaXMuYW5pbWF0aW9uLmRlc2VyaWFsaXplKF9zLmFuaW1hdGlvbik7XHJcbiAgICAgIHRoaXMucGxheWJhY2sgPSBfcy5wbGF5YmFjaztcclxuICAgICAgdGhpcy5wbGF5bW9kZSA9IF9zLnBsYXltb2RlO1xyXG4gICAgICB0aGlzLnNwZWVkU2NhbGUgPSBfcy5zcGVlZFNjYWxlO1xyXG4gICAgICB0aGlzLnNwZWVkU2NhbGVzV2l0aEdsb2JhbFNwZWVkID0gX3Muc3BlZWRTY2FsZXNXaXRoR2xvYmFsU3BlZWQ7XHJcblxyXG4gICAgICBzdXBlci5kZXNlcmlhbGl6ZShfc1tzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIHVwZGF0ZUFuaW1hdGlvblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBBbmltYXRpb24uXHJcbiAgICAgKiBHZXRzIGNhbGxlZCBldmVyeSB0aW1lIHRoZSBMb29wIGZpcmVzIHRoZSBMT09QX0ZSQU1FIEV2ZW50LlxyXG4gICAgICogVXNlcyB0aGUgYnVpbHQtaW4gdGltZSB1bmxlc3MgYSBkaWZmZXJlbnQgdGltZSBpcyBzcGVjaWZpZWQuXHJcbiAgICAgKiBNYXkgYWxzbyBiZSBjYWxsZWQgZnJvbSB1cGRhdGVBbmltYXRpb24oKS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSB1cGRhdGVBbmltYXRpb25Mb29wKF9lOiBFdmVudCwgX3RpbWU6IG51bWJlcik6IFtNdXRhdG9yLCBudW1iZXJdIHtcclxuICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uLnRvdGFsVGltZSA9PSAwKVxyXG4gICAgICAgIHJldHVybiBbbnVsbCwgMF07XHJcbiAgICAgIGxldCB0aW1lOiBudW1iZXIgPSBfdGltZSB8fCB0aGlzLmxvY2FsVGltZS5nZXQoKTtcclxuICAgICAgaWYgKHRoaXMucGxheWJhY2sgPT0gQU5JTUFUSU9OX1BMQVlCQUNLLkZSQU1FQkFTRUQpIHtcclxuICAgICAgICB0aW1lID0gdGhpcy5sYXN0VGltZSArICgxMDAwIC8gdGhpcy5hbmltYXRpb24uZnBzKTtcclxuICAgICAgfVxyXG4gICAgICBsZXQgZGlyZWN0aW9uOiBudW1iZXIgPSB0aGlzLmNhbGN1bGF0ZURpcmVjdGlvbih0aW1lKTtcclxuICAgICAgdGltZSA9IHRoaXMuYXBwbHlQbGF5bW9kZXModGltZSk7XHJcbiAgICAgIHRoaXMuZXhlY3V0ZUV2ZW50cyh0aGlzLmFuaW1hdGlvbi5nZXRFdmVudHNUb0ZpcmUodGhpcy5sYXN0VGltZSwgdGltZSwgdGhpcy5wbGF5YmFjaywgZGlyZWN0aW9uKSk7XHJcblxyXG4gICAgICBpZiAodGhpcy5sYXN0VGltZSAhPSB0aW1lKSB7XHJcbiAgICAgICAgdGhpcy5sYXN0VGltZSA9IHRpbWU7XHJcbiAgICAgICAgdGltZSA9IHRpbWUgJSB0aGlzLmFuaW1hdGlvbi50b3RhbFRpbWU7XHJcbiAgICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSB0aGlzLmFuaW1hdGlvbi5nZXRNdXRhdGVkKHRpbWUsIGRpcmVjdGlvbiwgdGhpcy5wbGF5YmFjayk7XHJcbiAgICAgICAgaWYgKHRoaXMuZ2V0Q29udGFpbmVyKCkpIHtcclxuICAgICAgICAgIHRoaXMuZ2V0Q29udGFpbmVyKCkuYXBwbHlBbmltYXRpb24obXV0YXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbbXV0YXRvciwgdGltZV07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIFtudWxsLCB0aW1lXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpcmVzIGFsbCBjdXN0b20gZXZlbnRzIHRoZSBBbmltYXRpb24gc2hvdWxkIGhhdmUgZmlyZWQgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgZnJhbWUuXHJcbiAgICAgKiBAcGFyYW0gZXZlbnRzIGEgbGlzdCBvZiBuYW1lcyBvZiBjdXN0b20gZXZlbnRzIHRvIGZpcmVcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBleGVjdXRlRXZlbnRzKGV2ZW50czogc3RyaW5nW10pOiB2b2lkIHtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoZXZlbnRzW2ldKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGFjdHVhbCB0aW1lIHRvIHVzZSwgdXNpbmcgdGhlIGN1cnJlbnQgcGxheW1vZGVzLlxyXG4gICAgICogQHBhcmFtIF90aW1lIHRoZSB0aW1lIHRvIGFwcGx5IHRoZSBwbGF5bW9kZXMgdG9cclxuICAgICAqIEByZXR1cm5zIHRoZSByZWNhbGN1bGF0ZWQgdGltZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGFwcGx5UGxheW1vZGVzKF90aW1lOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICBzd2l0Y2ggKHRoaXMucGxheW1vZGUpIHtcclxuICAgICAgICBjYXNlIEFOSU1BVElPTl9QTEFZTU9ERS5TVE9QOlxyXG4gICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxUaW1lLmdldE9mZnNldCgpO1xyXG4gICAgICAgIGNhc2UgQU5JTUFUSU9OX1BMQVlNT0RFLlBMQVlPTkNFOlxyXG4gICAgICAgICAgaWYgKF90aW1lID49IHRoaXMuYW5pbWF0aW9uLnRvdGFsVGltZSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0aW9uLnRvdGFsVGltZSAtIDAuMDE7ICAgICAvL1RPRE86IHRoaXMgbWlnaHQgY2F1c2Ugc29tZSBpc3N1ZXNcclxuICAgICAgICAgIGVsc2UgcmV0dXJuIF90aW1lO1xyXG4gICAgICAgIGNhc2UgQU5JTUFUSU9OX1BMQVlNT0RFLlBMQVlPTkNFU1RPUEFGVEVSOlxyXG4gICAgICAgICAgaWYgKF90aW1lID49IHRoaXMuYW5pbWF0aW9uLnRvdGFsVGltZSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0aW9uLnRvdGFsVGltZSArIDAuMDE7ICAgICAvL1RPRE86IHRoaXMgbWlnaHQgY2F1c2Ugc29tZSBpc3N1ZXNcclxuICAgICAgICAgIGVsc2UgcmV0dXJuIF90aW1lO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICByZXR1cm4gX3RpbWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgYW5kIHJldHVybnMgdGhlIGRpcmVjdGlvbiB0aGUgYW5pbWF0aW9uIHNob3VsZCBjdXJyZW50bHkgYmUgcGxheWluZyBpbi5cclxuICAgICAqIEBwYXJhbSBfdGltZSB0aGUgdGltZSBhdCB3aGljaCB0byBjYWxjdWxhdGUgdGhlIGRpcmVjdGlvblxyXG4gICAgICogQHJldHVybnMgMSBpZiBmb3J3YXJkLCAwIGlmIHN0b3AsIC0xIGlmIGJhY2t3YXJkc1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNhbGN1bGF0ZURpcmVjdGlvbihfdGltZTogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgICAgc3dpdGNoICh0aGlzLnBsYXltb2RlKSB7XHJcbiAgICAgICAgY2FzZSBBTklNQVRJT05fUExBWU1PREUuU1RPUDpcclxuICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIC8vIGNhc2UgQU5JTUFUSU9OX1BMQVlNT0RFLlBJTkdQT05HOlxyXG4gICAgICAgIC8vICAgaWYgKE1hdGguZmxvb3IoX3RpbWUgLyB0aGlzLmFuaW1hdGlvbi50b3RhbFRpbWUpICUgMiA9PSAwKVxyXG4gICAgICAgIC8vICAgICByZXR1cm4gMTtcclxuICAgICAgICAvLyAgIGVsc2VcclxuICAgICAgICAvLyAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIGNhc2UgQU5JTUFUSU9OX1BMQVlNT0RFLlJFVkVSU0VMT09QOlxyXG4gICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIGNhc2UgQU5JTUFUSU9OX1BMQVlNT0RFLlBMQVlPTkNFOlxyXG4gICAgICAgIGNhc2UgQU5JTUFUSU9OX1BMQVlNT0RFLlBMQVlPTkNFU1RPUEFGVEVSOlxyXG4gICAgICAgICAgaWYgKF90aW1lID49IHRoaXMuYW5pbWF0aW9uLnRvdGFsVGltZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgIH1cclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIHNjYWxlIG9mIHRoZSBhbmltYXRpb24gaWYgdGhlIHVzZXIgY2hhbmdlcyBpdCBvciBpZiB0aGUgZ2xvYmFsIGdhbWUgdGltZXIgY2hhbmdlZCBpdHMgc2NhbGUuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdXBkYXRlU2NhbGUoKTogdm9pZCB7XHJcbiAgICAgIGxldCBuZXdTY2FsZTogbnVtYmVyID0gdGhpcy5zcGVlZFNjYWxlO1xyXG4gICAgICBpZiAodGhpcy5zcGVlZFNjYWxlc1dpdGhHbG9iYWxTcGVlZClcclxuICAgICAgICBuZXdTY2FsZSAqPSBUaW1lLmdhbWUuZ2V0U2NhbGUoKTtcclxuICAgICAgdGhpcy5sb2NhbFRpbWUuc2V0U2NhbGUobmV3U2NhbGUpO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGVudW0gQVVESU9fUEFOTkVSIHtcclxuICAgIENPTkVfSU5ORVJfQU5HTEUgPSBcImNvbmVJbm5lckFuZ2xlXCIsXHJcbiAgICBDT05FX09VVEVSX0FOR0xFID0gXCJjb25lT3V0ZXJBbmdsZVwiLFxyXG4gICAgQ09ORV9PVVRFUl9HQUlOID0gXCJjb25lT3V0ZXJHYWluXCIsXHJcbiAgICBESVNUQU5DRV9NT0RFTCA9IFwiZGlzdGFuY2VNb2RlbFwiLFxyXG4gICAgTUFYX0RJU1RBTkNFID0gXCJtYXhEaXN0YW5jZVwiLFxyXG4gICAgUEFOTklOR19NT0RFTCA9IFwicGFubmluZ01vZGVsXCIsXHJcbiAgICBSRUZfRElTVEFOQ0UgPSBcInJlZkRpc3RhbmNlXCIsXHJcbiAgICBST0xMT0ZGX0ZBQ1RPUiA9IFwicm9sbG9mZkZhY3RvclwiXHJcbiAgfVxyXG5cclxuICBleHBvcnQgZW51bSBBVURJT19OT0RFX1RZUEUge1xyXG4gICAgU09VUkNFLCBQQU5ORVIsIEdBSU5cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEJ1aWxkcyBhIG1pbmltYWwgYXVkaW8gZ3JhcGggKGJ5IGRlZmF1bHQgaW4gW1tBdWRpb01hbmFnZXJdXS5kZWZhdWx0KSBhbmQgc3luY2hyb25pemVzIGl0IHdpdGggdGhlIGNvbnRhaW5pbmcgW1tOb2RlXV1cclxuICAgKiBgYGBwbGFpbnRleHRcclxuICAgKiDilIwgQXVkaW9NYW5hZ2VyKC5kZWZhdWx0KSDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcclxuICAgKiDilIIg4pSMIENvbXBvbmVudEF1ZGlvIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgICAgICAgICDilIJcclxuICAgKiDilIIg4pSCICAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUkCDilIIg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSQIOKUgiAgXHJcbiAgICog4pSCIOKUgiAgICDilIJzb3VyY2XilIIg4oaSIOKUgnBhbm5lcuKUgiDihpIg4pSCIGdhaW4g4pSCIOKGkiDilIIgZ2FpbiDilIIg4pSCXHJcbiAgICog4pSCIOKUgiAgICDilJTilIDilIDilIDilIDilIDilIDilJggICDilJTilIDilIDilIDilIDilIDilIDilJggICDilJTilIDilIDilIDilIDilIDilIDilJgg4pSCIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUmCDilIIgIFxyXG4gICAqIOKUgiDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJggICAgICAgICAg4pSCXHJcbiAgICog4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXHJcbiAgICogYGBgXHJcbiAgICogQGF1dGhvcnMgVGhvbWFzIERvcm5lciwgSEZVLCAyMDE5IHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29tcG9uZW50QXVkaW8gZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IENvbXBvbmVudC5yZWdpc3RlclN1YmNsYXNzKENvbXBvbmVudEF1ZGlvKTtcclxuICAgIC8qKiBwbGFjZXMgYW5kIGRpcmVjdHMgdGhlIHBhbm5lciByZWxhdGl2ZSB0byB0aGUgd29ybGQgdHJhbnNmb3JtIG9mIHRoZSBbW05vZGVdXSAgKi9cclxuICAgIHB1YmxpYyBwaXZvdDogTWF0cml4NHg0ID0gTWF0cml4NHg0LklERU5USVRZKCk7XHJcbiAgICBcclxuICAgIHByb3RlY3RlZCBzaW5nbGV0b246IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIFxyXG4gICAgcHJpdmF0ZSBnYWluOiBHYWluTm9kZTtcclxuICAgIHByaXZhdGUgcGFubmVyOiBQYW5uZXJOb2RlO1xyXG4gICAgcHJpdmF0ZSBzb3VyY2U6IEF1ZGlvQnVmZmVyU291cmNlTm9kZTtcclxuICAgIHByaXZhdGUgYXVkaW9NYW5hZ2VyOiBBdWRpb01hbmFnZXI7XHJcbiAgICBwcml2YXRlIHBsYXlpbmc6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIHByaXZhdGUgbGlzdGVuZWQ6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihfYXVkaW86IEF1ZGlvID0gbnVsbCwgX2xvb3A6IGJvb2xlYW4gPSBmYWxzZSwgX3N0YXJ0OiBib29sZWFuID0gZmFsc2UsIF9hdWRpb01hbmFnZXI6IEF1ZGlvTWFuYWdlciA9IEF1ZGlvTWFuYWdlci5kZWZhdWx0KSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuaW5zdGFsbChfYXVkaW9NYW5hZ2VyKTtcclxuICAgICAgdGhpcy5jcmVhdGVTb3VyY2UoX2F1ZGlvLCBfbG9vcCk7XHJcblxyXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuQ09NUE9ORU5UX0FERCwgdGhpcy5oYW5kbGVBdHRhY2gpO1xyXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuQ09NUE9ORU5UX1JFTU9WRSwgdGhpcy5oYW5kbGVBdHRhY2gpO1xyXG5cclxuICAgICAgaWYgKF9zdGFydClcclxuICAgICAgICB0aGlzLnBsYXkoX3N0YXJ0KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IGF1ZGlvKF9hdWRpbzogQXVkaW8pIHtcclxuICAgICAgdGhpcy5zb3VyY2UuYnVmZmVyID0gX2F1ZGlvO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgYXVkaW8oKTogQXVkaW8ge1xyXG4gICAgICByZXR1cm4gPEF1ZGlvPnRoaXMuc291cmNlLmJ1ZmZlcjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IHZvbHVtZShfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLmdhaW4uZ2Fpbi52YWx1ZSA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHZvbHVtZSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5nYWluLmdhaW4udmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHByb3BlcnR5IG9mIHRoZSBwYW5uZXIgdG8gdGhlIGdpdmVuIHZhbHVlLiBVc2UgdG8gbWFuaXB1bGF0ZSByYW5nZSBhbmQgcm9sbG9mZiBldGMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRQYW5uZXIoX3Byb3BlcnR5OiBBVURJT19QQU5ORVIsIF92YWx1ZTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5wYW5uZXIsIHsgW19wcm9wZXJ0eV06IF92YWx1ZSB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPOiBtYXkgYmUgdXNlZCBmb3Igc2VyaWFsaXphdGlvbiBvZiBBdWRpb05vZGVzXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvck9mTm9kZShfdHlwZTogQVVESU9fTk9ERV9UWVBFKTogTXV0YXRvciB7XHJcbiAgICAgIGxldCBub2RlOiBBdWRpb05vZGUgPSB0aGlzLmdldEF1ZGlvTm9kZShfdHlwZSk7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0gZ2V0TXV0YXRvck9mQXJiaXRyYXJ5KG5vZGUpO1xyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHNwZWNpZmllZCBBdWRpb05vZGUgb2YgdGhlIHN0YW5kYXJkIGdyYXBoIGZvciBmdXJ0aGVyIG1hbmlwdWxhdGlvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0QXVkaW9Ob2RlKF90eXBlOiBBVURJT19OT0RFX1RZUEUpOiBBdWRpb05vZGUge1xyXG4gICAgICBzd2l0Y2ggKF90eXBlKSB7XHJcbiAgICAgICAgY2FzZSBBVURJT19OT0RFX1RZUEUuU09VUkNFOiByZXR1cm4gdGhpcy5zb3VyY2U7XHJcbiAgICAgICAgY2FzZSBBVURJT19OT0RFX1RZUEUuUEFOTkVSOiByZXR1cm4gdGhpcy5wYW5uZXI7XHJcbiAgICAgICAgY2FzZSBBVURJT19OT0RFX1RZUEUuR0FJTjogcmV0dXJuIHRoaXMuZ2FpbjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RhcnQgb3Igc3RvcCBwbGF5aW5nIHRoZSBhdWRpb1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcGxheShfb246IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgaWYgKF9vbikge1xyXG4gICAgICAgIHRoaXMuY3JlYXRlU291cmNlKHRoaXMuYXVkaW8sIHRoaXMuc291cmNlLmxvb3ApO1xyXG4gICAgICAgIHRoaXMuc291cmNlLnN0YXJ0KDAsIDApO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2VcclxuICAgICAgICB0aGlzLnNvdXJjZS5zdG9wKCk7XHJcbiAgICAgIHRoaXMucGxheWluZyA9IF9vbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGlzUGxheWluZygpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIHRoaXMucGxheWluZztcclxuICAgIH1cclxuICAgIHB1YmxpYyBnZXQgaXNBdHRhY2hlZCgpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29udGFpbmVyKCkgIT0gbnVsbDtcclxuICAgIH1cclxuICAgIHB1YmxpYyBnZXQgaXNMaXN0ZW5lZCgpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluc2VydHMgQXVkaW9Ob2RlcyBiZXR3ZWVuIHRoZSBwYW5uZXIgYW5kIHRoZSBsb2NhbCBnYWluIG9mIHRoaXMgW1tDb21wb25lbnRBdWRpb11dXHJcbiAgICAgKiBfaW5wdXQgYW5kIF9vdXRwdXQgbWF5IGJlIHRoZSBzYW1lIEF1ZGlvTm9kZSwgaWYgdGhlcmUgaXMgb25seSBvbmUgdG8gaW5zZXJ0LFxyXG4gICAgICogb3IgbWF5IGhhdmUgbXVsdGlwbGUgQXVkaW9Ob2RlIGJldHdlZW4gdGhlbSB0byBjcmVhdGUgYW4gZWZmZWN0LWdyYXBoLlxcXHJcbiAgICAgKiBOb3RlIHRoYXQgW1tDb21wb25lbnRBdWRpb11dIGRvZXMgbm90IGtlZXAgdHJhY2sgb2YgaW5zZXJ0ZWQgQXVkaW9Ob2RlcyFcclxuICAgICAqIGBgYHBsYWludGV4dFxyXG4gICAgICog4pSMIEF1ZGlvTWFuYWdlciguZGVmYXVsdCkg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXHJcbiAgICAgKiDilIIg4pSMIENvbXBvbmVudEF1ZGlvIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgICAgICAgICDilIJcclxuICAgICAqIOKUgiDilIIgICAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSQICAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSQICAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSQICAgICAgICAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUkCDilIIg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSQIOKUgiAgXHJcbiAgICAgKiDilIIg4pSCICAgIOKUgnNvdXJjZeKUgiDihpIg4pSCcGFubmVy4pSCIOKGkiDilIJfaW5wdXTilIIg4oaSIC4uLiAg4oaSIOKUgl9vdXRwdXTilIIg4oaSIOKUgiBnYWluIOKUgiDihpIg4pSCIGdhaW4g4pSCIOKUglxyXG4gICAgICog4pSCIOKUgiAgICDilJTilIDilIDilIDilIDilIDilIDilJggICDilJTilIDilIDilIDilIDilIDilIDilJggICDilJTilIDilIDilIDilIDilIDilIDilJggICAgICAgICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSYIOKUgiDilJTilIDilIDilIDilIDilIDilIDilJgg4pSCICBcclxuICAgICAqIOKUgiDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJggICAgICAgICAg4pSCXHJcbiAgICAgKiDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaW5zZXJ0QXVkaW9Ob2RlcyhfaW5wdXQ6IEF1ZGlvTm9kZSwgX291dHB1dDogQXVkaW9Ob2RlKTogdm9pZCB7XHJcbiAgICAgIHRoaXMucGFubmVyLmRpc2Nvbm5lY3QoMCk7XHJcbiAgICAgIGlmICghX2lucHV0ICYmICFfb3V0cHV0KSB7XHJcbiAgICAgICAgdGhpcy5wYW5uZXIuY29ubmVjdCh0aGlzLmdhaW4pO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnBhbm5lci5jb25uZWN0KF9pbnB1dCk7XHJcbiAgICAgIF9vdXRwdXQuY29ubmVjdCh0aGlzLmdhaW4pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWN0aXZhdGUgb3ZlcnJpZGUuIENvbm5lY3RzIG9yIGRpc2Nvbm5lY3RzIEF1ZGlvTm9kZXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFjdGl2YXRlKF9vbjogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICBzdXBlci5hY3RpdmF0ZShfb24pO1xyXG4gICAgICB0aGlzLnVwZGF0ZUNvbm5lY3Rpb24oKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbm5lY3RzIHRoaXMgY29tcG9uZW50cyBnYWluLW5vZGUgdG8gdGhlIGdhaW4gbm9kZSBvZiB0aGUgQXVkaW9NYW5hZ2VyIHRoaXMgY29tcG9uZW50IHJ1bnMgb24uXHJcbiAgICAgKiBPbmx5IGNhbGwgdGhpcyBtZXRob2QgaWYgdGhlIGNvbXBvbmVudCBpcyBub3QgYXR0YWNoZWQgdG8gYSBbW05vZGVdXSBidXQgbmVlZHMgdG8gYmUgaGVhcmQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjb25uZWN0KF9vbjogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICBpZiAoX29uKVxyXG4gICAgICAgIHRoaXMuZ2Fpbi5jb25uZWN0KHRoaXMuYXVkaW9NYW5hZ2VyLmdhaW4pO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgdGhpcy5nYWluLmRpc2Nvbm5lY3QodGhpcy5hdWRpb01hbmFnZXIuZ2Fpbik7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBpbnN0YWxsKF9hdWRpb01hbmFnZXI6IEF1ZGlvTWFuYWdlciA9IEF1ZGlvTWFuYWdlci5kZWZhdWx0KTogdm9pZCB7XHJcbiAgICAgIGxldCBhY3RpdmU6IGJvb2xlYW4gPSB0aGlzLmlzQWN0aXZlO1xyXG4gICAgICB0aGlzLmFjdGl2YXRlKGZhbHNlKTtcclxuICAgICAgdGhpcy5hdWRpb01hbmFnZXIgPSBfYXVkaW9NYW5hZ2VyO1xyXG4gICAgICB0aGlzLnBhbm5lciA9IF9hdWRpb01hbmFnZXIuY3JlYXRlUGFubmVyKCk7XHJcbiAgICAgIHRoaXMuZ2FpbiA9IF9hdWRpb01hbmFnZXIuY3JlYXRlR2FpbigpO1xyXG4gICAgICB0aGlzLnBhbm5lci5jb25uZWN0KHRoaXMuZ2Fpbik7XHJcbiAgICAgIHRoaXMuZ2Fpbi5jb25uZWN0KF9hdWRpb01hbmFnZXIuZ2Fpbik7XHJcbiAgICAgIHRoaXMuYWN0aXZhdGUoYWN0aXZlKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGNyZWF0ZVNvdXJjZShfYXVkaW86IEF1ZGlvLCBfbG9vcDogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICBpZiAodGhpcy5zb3VyY2UpIHtcclxuICAgICAgICB0aGlzLnNvdXJjZS5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UuYnVmZmVyID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnNvdXJjZSA9IHRoaXMuYXVkaW9NYW5hZ2VyLmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xyXG4gICAgICB0aGlzLnNvdXJjZS5jb25uZWN0KHRoaXMucGFubmVyKTtcclxuXHJcbiAgICAgIGlmIChfYXVkaW8pXHJcbiAgICAgICAgdGhpcy5hdWRpbyA9IF9hdWRpbztcclxuICAgICAgdGhpcy5zb3VyY2UubG9vcCA9IF9sb29wO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgdXBkYXRlQ29ubmVjdGlvbigpOiB2b2lkIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICB0aGlzLmNvbm5lY3QodGhpcy5pc0FjdGl2ZSAmJiB0aGlzLmlzQXR0YWNoZWQgJiYgdGhpcy5saXN0ZW5lZCk7XHJcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xyXG4gICAgICAgIC8vIG5vcFxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQXV0b21hdGljYWxseSBjb25uZWN0cy9kaXNjb25uZWN0cyBBdWRpb05vZGVzIHdoZW4gYWRkaW5nL3JlbW92aW5nIHRoaXMgY29tcG9uZW50IHRvL2Zyb20gYSBub2RlLiBcclxuICAgICAqIFRoZXJlZm9yZSB1bnVzZWQgQXVkaW9Ob2RlcyBtYXkgYmUgZ2FyYmFnZSBjb2xsZWN0ZWQgd2hlbiBhbiB1bnVzZWQgY29tcG9uZW50IGlzIGNvbGxlY3RlZFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGhhbmRsZUF0dGFjaCA9IChfZXZlbnQ6IEV2ZW50KTogdm9pZCA9PiB7XHJcbiAgICAgIC8vIERlYnVnLmxvZyhfZXZlbnQpO1xyXG4gICAgICBpZiAoX2V2ZW50LnR5cGUgPT0gRVZFTlQuQ09NUE9ORU5UX0FERCkge1xyXG4gICAgICAgIHRoaXMuZ2V0Q29udGFpbmVyKCkuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVF9BVURJTy5DSElMRF9BUFBFTkQsIHRoaXMuaGFuZGxlR3JhcGgsIHRydWUpO1xyXG4gICAgICAgIHRoaXMuZ2V0Q29udGFpbmVyKCkuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVF9BVURJTy5DSElMRF9SRU1PVkUsIHRoaXMuaGFuZGxlR3JhcGgsIHRydWUpO1xyXG4gICAgICAgIHRoaXMuZ2V0Q29udGFpbmVyKCkuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVF9BVURJTy5VUERBVEUsIHRoaXMudXBkYXRlLCB0cnVlKTtcclxuICAgICAgICB0aGlzLmxpc3RlbmVkID0gdGhpcy5nZXRDb250YWluZXIoKS5pc0Rlc2NlbmRhbnRPZihBdWRpb01hbmFnZXIuZGVmYXVsdC5nZXRHcmFwaExpc3RlbmluZ1RvKCkpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHRoaXMuZ2V0Q29udGFpbmVyKCkucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVF9BVURJTy5DSElMRF9BUFBFTkQsIHRoaXMuaGFuZGxlR3JhcGgsIHRydWUpO1xyXG4gICAgICAgIHRoaXMuZ2V0Q29udGFpbmVyKCkucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVF9BVURJTy5DSElMRF9SRU1PVkUsIHRoaXMuaGFuZGxlR3JhcGgsIHRydWUpO1xyXG4gICAgICAgIHRoaXMuZ2V0Q29udGFpbmVyKCkucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVF9BVURJTy5VUERBVEUsIHRoaXMudXBkYXRlLCB0cnVlKTtcclxuICAgICAgICB0aGlzLmxpc3RlbmVkID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy51cGRhdGVDb25uZWN0aW9uKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQXV0b21hdGljYWxseSBjb25uZWN0cy9kaXNjb25uZWN0cyBBdWRpb05vZGVzIHdoZW4gYXBwZW5kaW5nL3JlbW92aW5nIHRoZSBGVURHRS1ncmFwaCB0aGUgY29tcG9uZW50IGlzIGluLiBcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBoYW5kbGVHcmFwaCA9IChfZXZlbnQ6IEV2ZW50KTogdm9pZCA9PiB7XHJcbiAgICAgIC8vIERlYnVnLmxvZyhfZXZlbnQpO1xyXG4gICAgICB0aGlzLmxpc3RlbmVkID0gKF9ldmVudC50eXBlID09IEVWRU5UX0FVRElPLkNISUxEX0FQUEVORCk7XHJcbiAgICAgIHRoaXMudXBkYXRlQ29ubmVjdGlvbigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBcclxuICAgICAqIFVwZGF0ZXMgdGhlIHBhbm5lciBub2RlLCBpdHMgcG9zaXRpb24gYW5kIGRpcmVjdGlvbiwgdXNpbmcgdGhlIHdvcmxkbWF0cml4IG9mIHRoZSBjb250YWluZXIgYW5kIHRoZSBwaXZvdCBvZiB0aGlzIGNvbXBvbmVudC4gXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdXBkYXRlID0gKF9ldmVudDogRXZlbnQpOiB2b2lkID0+IHtcclxuICAgICAgbGV0IG10eFJlc3VsdDogTWF0cml4NHg0ID0gdGhpcy5waXZvdDtcclxuICAgICAgaWYgKHRoaXMuZ2V0Q29udGFpbmVyKCkpXHJcbiAgICAgICAgbXR4UmVzdWx0ID0gTWF0cml4NHg0Lk1VTFRJUExJQ0FUSU9OKHRoaXMuZ2V0Q29udGFpbmVyKCkubXR4V29ybGQsIHRoaXMucGl2b3QpO1xyXG5cclxuICAgICAgLy8gRGVidWcubG9nKG10eFJlc3VsdC50b1N0cmluZygpKTtcclxuICAgICAgbGV0IHBvc2l0aW9uOiBWZWN0b3IzID0gbXR4UmVzdWx0LnRyYW5zbGF0aW9uO1xyXG4gICAgICBsZXQgZm9yd2FyZDogVmVjdG9yMyA9IFZlY3RvcjMuVFJBTlNGT1JNQVRJT04oVmVjdG9yMy5aKDEpLCBtdHhSZXN1bHQsIGZhbHNlKTtcclxuXHJcbiAgICAgIHRoaXMucGFubmVyLnBvc2l0aW9uWC52YWx1ZSA9IHBvc2l0aW9uLng7XHJcbiAgICAgIHRoaXMucGFubmVyLnBvc2l0aW9uWS52YWx1ZSA9IHBvc2l0aW9uLnk7XHJcbiAgICAgIHRoaXMucGFubmVyLnBvc2l0aW9uWi52YWx1ZSA9IHBvc2l0aW9uLno7XHJcblxyXG4gICAgICB0aGlzLnBhbm5lci5vcmllbnRhdGlvblgudmFsdWUgPSBmb3J3YXJkLng7XHJcbiAgICAgIHRoaXMucGFubmVyLm9yaWVudGF0aW9uWS52YWx1ZSA9IGZvcndhcmQueTtcclxuICAgICAgdGhpcy5wYW5uZXIub3JpZW50YXRpb25aLnZhbHVlID0gZm9yd2FyZC56O1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFNlcnZlcyB0byBzZXQgdGhlIHNwYXRpYWwgbG9jYXRpb24gYW5kIG9yaWVudGF0aW9uIG9mIEF1ZGlvTGlzdGVuZXJzIHJlbGF0aXZlIHRvIHRoZVxyXG4gICAqIHdvcmxkIHRyYW5zZm9ybSBvZiB0aGUgW1tOb2RlXV0gaXQgaXMgYXR0YWNoZWQgdG8uXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29tcG9uZW50QXVkaW9MaXN0ZW5lciBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gQ29tcG9uZW50LnJlZ2lzdGVyU3ViY2xhc3MoQ29tcG9uZW50QXVkaW9MaXN0ZW5lcik7XHJcbiAgICBwdWJsaWMgcGl2b3Q6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgcG9zaXRpb24gYW5kIG9yaWVudGF0aW9uIG9mIHRoZSBnaXZlbiBBdWRpb0xpc3RlbmVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB1cGRhdGUoX2xpc3RlbmVyOiBBdWRpb0xpc3RlbmVyKTogdm9pZCB7XHJcbiAgICAgIGxldCBtdHhSZXN1bHQ6IE1hdHJpeDR4NCA9IHRoaXMucGl2b3Q7XHJcbiAgICAgIGlmICh0aGlzLmdldENvbnRhaW5lcigpKVxyXG4gICAgICAgIG10eFJlc3VsdCA9IE1hdHJpeDR4NC5NVUxUSVBMSUNBVElPTih0aGlzLmdldENvbnRhaW5lcigpLm10eFdvcmxkLCB0aGlzLnBpdm90KTtcclxuXHJcbiAgICAgIC8vIERlYnVnLmxvZyhtdHhSZXN1bHQudG9TdHJpbmcoKSk7XHJcbiAgICAgIGxldCBwb3NpdGlvbjogVmVjdG9yMyA9IG10eFJlc3VsdC50cmFuc2xhdGlvbjtcclxuICAgICAgbGV0IGZvcndhcmQ6IFZlY3RvcjMgPSBWZWN0b3IzLlRSQU5TRk9STUFUSU9OKFZlY3RvcjMuWigxKSwgbXR4UmVzdWx0LCBmYWxzZSk7XHJcbiAgICAgIGxldCB1cDogVmVjdG9yMyA9IFZlY3RvcjMuVFJBTlNGT1JNQVRJT04oVmVjdG9yMy5ZKCksIG10eFJlc3VsdCwgZmFsc2UpO1xyXG5cclxuICAgICAgX2xpc3RlbmVyLnBvc2l0aW9uWC52YWx1ZSA9IHBvc2l0aW9uLng7XHJcbiAgICAgIF9saXN0ZW5lci5wb3NpdGlvblkudmFsdWUgPSBwb3NpdGlvbi55O1xyXG4gICAgICBfbGlzdGVuZXIucG9zaXRpb25aLnZhbHVlID0gcG9zaXRpb24uejtcclxuXHJcbiAgICAgIF9saXN0ZW5lci5mb3J3YXJkWC52YWx1ZSA9IGZvcndhcmQueDtcclxuICAgICAgX2xpc3RlbmVyLmZvcndhcmRZLnZhbHVlID0gZm9yd2FyZC55O1xyXG4gICAgICBfbGlzdGVuZXIuZm9yd2FyZFoudmFsdWUgPSBmb3J3YXJkLno7XHJcblxyXG4gICAgICBfbGlzdGVuZXIudXBYLnZhbHVlID0gdXAueDtcclxuICAgICAgX2xpc3RlbmVyLnVwWS52YWx1ZSA9IHVwLnk7XHJcbiAgICAgIF9saXN0ZW5lci51cFoudmFsdWUgPSB1cC56O1xyXG5cclxuICAgICAgLy8gRGVidWcubG9nKG10eFJlc3VsdC50cmFuc2xhdGlvbi50b1N0cmluZygpLCBmb3J3YXJkLnRvU3RyaW5nKCksIHVwLnRvU3RyaW5nKCkpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCIvLyAvIDxyZWZlcmVuY2UgcGF0aD1cIkNvbXBvbmVudC50c1wiLz5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGVudW0gRklFTERfT0ZfVklFVyB7XHJcbiAgICBIT1JJWk9OVEFMLCBWRVJUSUNBTCwgRElBR09OQUxcclxuICB9XHJcbiAgLyoqXHJcbiAgICogRGVmaW5lcyBpZGVudGlmaWVycyBmb3IgdGhlIHZhcmlvdXMgcHJvamVjdGlvbnMgYSBjYW1lcmEgY2FuIHByb3ZpZGUuICBcclxuICAgKiBUT0RPOiBjaGFuZ2UgYmFjayB0byBudW1iZXIgZW51bSBpZiBzdHJpbmdzIG5vdCBuZWVkZWRcclxuICAgKi9cclxuICBleHBvcnQgZW51bSBQUk9KRUNUSU9OIHtcclxuICAgIENFTlRSQUwgPSBcImNlbnRyYWxcIixcclxuICAgIE9SVEhPR1JBUEhJQyA9IFwib3J0aG9ncmFwaGljXCIsXHJcbiAgICBESU1FVFJJQyA9IFwiZGltZXRyaWNcIixcclxuICAgIFNURVJFTyA9IFwic3RlcmVvXCJcclxuICB9XHJcbiAgLyoqXHJcbiAgICogVGhlIGNhbWVyYSBjb21wb25lbnQgaG9sZHMgdGhlIHByb2plY3Rpb24tbWF0cml4IGFuZCBvdGhlciBkYXRhIG5lZWRlZCB0byByZW5kZXIgYSBzY2VuZSBmcm9tIHRoZSBwZXJzcGVjdGl2ZSBvZiB0aGUgbm9kZSBpdCBpcyBhdHRhY2hlZCB0by5cclxuICAgKiBAYXV0aG9ycyBKYXNjaGEgS2FyYWfDtmwsIEhGVSwgMjAxOSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIENvbXBvbmVudENhbWVyYSBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gQ29tcG9uZW50LnJlZ2lzdGVyU3ViY2xhc3MoQ29tcG9uZW50Q2FtZXJhKTtcclxuICAgIHB1YmxpYyBwaXZvdDogTWF0cml4NHg0ID0gTWF0cml4NHg0LklERU5USVRZKCk7XHJcbiAgICBwdWJsaWMgYmFja2dyb3VuZENvbG9yOiBDb2xvciA9IG5ldyBDb2xvcigwLCAwLCAwLCAxKTsgLy8gVGhlIGNvbG9yIG9mIHRoZSBiYWNrZ3JvdW5kIHRoZSBjYW1lcmEgd2lsbCByZW5kZXIuXHJcbiAgICAvL3ByaXZhdGUgb3J0aG9ncmFwaGljOiBib29sZWFuID0gZmFsc2U7IC8vIERldGVybWluZXMgd2hldGhlciB0aGUgaW1hZ2Ugd2lsbCBiZSByZW5kZXJlZCB3aXRoIHBlcnNwZWN0aXZlIG9yIG9ydGhvZ3JhcGhpYyBwcm9qZWN0aW9uLlxyXG4gICAgcHJpdmF0ZSBwcm9qZWN0aW9uOiBQUk9KRUNUSU9OID0gUFJPSkVDVElPTi5DRU5UUkFMO1xyXG4gICAgcHJpdmF0ZSB0cmFuc2Zvcm06IE1hdHJpeDR4NCA9IG5ldyBNYXRyaXg0eDQ7IC8vIFRoZSBtYXRyaXggdG8gbXVsdGlwbHkgZWFjaCBzY2VuZSBvYmplY3RzIHRyYW5zZm9ybWF0aW9uIGJ5LCB0byBkZXRlcm1pbmUgd2hlcmUgaXQgd2lsbCBiZSBkcmF3bi5cclxuICAgIHByaXZhdGUgZmllbGRPZlZpZXc6IG51bWJlciA9IDQ1OyAvLyBUaGUgY2FtZXJhJ3Mgc2Vuc29yYW5nbGUuXHJcbiAgICBwcml2YXRlIGFzcGVjdFJhdGlvOiBudW1iZXIgPSAxLjA7XHJcbiAgICBwcml2YXRlIGRpcmVjdGlvbjogRklFTERfT0ZfVklFVyA9IEZJRUxEX09GX1ZJRVcuRElBR09OQUw7XHJcbiAgICBwcml2YXRlIGJhY2tncm91bmRFbmFibGVkOiBib29sZWFuID0gdHJ1ZTsgLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0aGUgYmFja2dyb3VuZCBvZiB0aGlzIGNhbWVyYSB3aWxsIGJlIHJlbmRlcmVkLlxyXG4gICAgLy8gVE9ETzogZXhhbWluZSwgaWYgYmFja2dyb3VuZCBzaG91bGQgYmUgYW4gYXR0cmlidXRlIG9mIENhbWVyYSBvciBWaWV3cG9ydFxyXG5cclxuICAgIHB1YmxpYyBnZXRQcm9qZWN0aW9uKCk6IFBST0pFQ1RJT04ge1xyXG4gICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRCYWNrZ3JvdW5kRW5hYmxlZCgpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYmFja2dyb3VuZEVuYWJsZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEFzcGVjdCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5hc3BlY3RSYXRpbztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0RmllbGRPZlZpZXcoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZmllbGRPZlZpZXc7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldERpcmVjdGlvbigpOiBGSUVMRF9PRl9WSUVXIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbXVsdGlwbGlrYXRpb24gb2YgdGhlIHdvcmxkdHJhbnNmb3JtYXRpb24gb2YgdGhlIGNhbWVyYSBjb250YWluZXIgd2l0aCB0aGUgcHJvamVjdGlvbiBtYXRyaXhcclxuICAgICAqIEByZXR1cm5zIHRoZSB3b3JsZC1wcm9qZWN0aW9uLW1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IFZpZXdQcm9qZWN0aW9uTWF0cml4KCk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIC8vVE9ETzogb3B0aW1pemUsIG5vIG5lZWQgdG8gcmVjYWxjdWxhdGUgaWYgbmVpdGhlciBtdHhXb3JsZCBub3IgcGl2b3QgaGF2ZSBjaGFuZ2VkXHJcbiAgICAgIGxldCBtdHhDYW1lcmE6IE1hdHJpeDR4NCA9IHRoaXMucGl2b3Q7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgbXR4Q2FtZXJhID0gTWF0cml4NHg0Lk1VTFRJUExJQ0FUSU9OKHRoaXMuZ2V0Q29udGFpbmVyKCkubXR4V29ybGQsIHRoaXMucGl2b3QpO1xyXG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcclxuICAgICAgICAvLyBubyBjb250YWluZXIgbm9kZSBvciBubyB3b3JsZCB0cmFuc2Zvcm1hdGlvbiBmb3VuZCAtPiBjb250aW51ZSB3aXRoIHBpdm90IG9ubHlcclxuICAgICAgfVxyXG4gICAgICBsZXQgbXR4V29ybGRQcm9qZWN0aW9uOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSU5WRVJTSU9OKG10eENhbWVyYSk7XHJcbiAgICAgIG10eFdvcmxkUHJvamVjdGlvbiA9IE1hdHJpeDR4NC5NVUxUSVBMSUNBVElPTih0aGlzLnRyYW5zZm9ybSwgbXR4V29ybGRQcm9qZWN0aW9uKTtcclxuICAgICAgcmV0dXJuIG10eFdvcmxkUHJvamVjdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgY2FtZXJhIHRvIHBlcnNwZWN0aXZlIHByb2plY3Rpb24uIFRoZSB3b3JsZCBvcmlnaW4gaXMgaW4gdGhlIGNlbnRlciBvZiB0aGUgY2FudmFzZWxlbWVudC5cclxuICAgICAqIEBwYXJhbSBfYXNwZWN0IFRoZSBhc3BlY3QgcmF0aW8gYmV0d2VlbiB3aWR0aCBhbmQgaGVpZ2h0IG9mIHByb2plY3Rpb25zcGFjZS4oRGVmYXVsdCA9IGNhbnZhcy5jbGllbnRXaWR0aCAvIGNhbnZhcy5DbGllbnRIZWlnaHQpXHJcbiAgICAgKiBAcGFyYW0gX2ZpZWxkT2ZWaWV3IFRoZSBmaWVsZCBvZiB2aWV3IGluIERlZ3JlZXMuIChEZWZhdWx0ID0gNDUpXHJcbiAgICAgKiBAcGFyYW0gX2RpcmVjdGlvbiBUaGUgcGxhbmUgb24gd2hpY2ggdGhlIGZpZWxkT2ZWaWV3LUFuZ2xlIGlzIGdpdmVuIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcHJvamVjdENlbnRyYWwoX2FzcGVjdDogbnVtYmVyID0gdGhpcy5hc3BlY3RSYXRpbywgX2ZpZWxkT2ZWaWV3OiBudW1iZXIgPSB0aGlzLmZpZWxkT2ZWaWV3LCBfZGlyZWN0aW9uOiBGSUVMRF9PRl9WSUVXID0gdGhpcy5kaXJlY3Rpb24pOiB2b2lkIHtcclxuICAgICAgdGhpcy5hc3BlY3RSYXRpbyA9IF9hc3BlY3Q7XHJcbiAgICAgIHRoaXMuZmllbGRPZlZpZXcgPSBfZmllbGRPZlZpZXc7XHJcbiAgICAgIHRoaXMuZGlyZWN0aW9uID0gX2RpcmVjdGlvbjtcclxuICAgICAgdGhpcy5wcm9qZWN0aW9uID0gUFJPSkVDVElPTi5DRU5UUkFMO1xyXG4gICAgICB0aGlzLnRyYW5zZm9ybSA9IE1hdHJpeDR4NC5QUk9KRUNUSU9OX0NFTlRSQUwoX2FzcGVjdCwgdGhpcy5maWVsZE9mVmlldywgMSwgMjAwMCwgdGhpcy5kaXJlY3Rpb24pOyAvLyBUT0RPOiByZW1vdmUgbWFnaWMgbnVtYmVyc1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGNhbWVyYSB0byBvcnRob2dyYXBoaWMgcHJvamVjdGlvbi4gVGhlIG9yaWdpbiBpcyBpbiB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXMuXHJcbiAgICAgKiBAcGFyYW0gX2xlZnQgVGhlIHBvc2l0aW9udmFsdWUgb2YgdGhlIHByb2plY3Rpb25zcGFjZSdzIGxlZnQgYm9yZGVyLiAoRGVmYXVsdCA9IDApXHJcbiAgICAgKiBAcGFyYW0gX3JpZ2h0IFRoZSBwb3NpdGlvbnZhbHVlIG9mIHRoZSBwcm9qZWN0aW9uc3BhY2UncyByaWdodCBib3JkZXIuIChEZWZhdWx0ID0gY2FudmFzLmNsaWVudFdpZHRoKVxyXG4gICAgICogQHBhcmFtIF9ib3R0b20gVGhlIHBvc2l0aW9udmFsdWUgb2YgdGhlIHByb2plY3Rpb25zcGFjZSdzIGJvdHRvbSBib3JkZXIuKERlZmF1bHQgPSBjYW52YXMuY2xpZW50SGVpZ2h0KVxyXG4gICAgICogQHBhcmFtIF90b3AgVGhlIHBvc2l0aW9udmFsdWUgb2YgdGhlIHByb2plY3Rpb25zcGFjZSdzIHRvcCBib3JkZXIuKERlZmF1bHQgPSAwKVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcHJvamVjdE9ydGhvZ3JhcGhpYyhfbGVmdDogbnVtYmVyID0gMCwgX3JpZ2h0OiBudW1iZXIgPSBSZW5kZXJNYW5hZ2VyLmdldENhbnZhcygpLmNsaWVudFdpZHRoLCBfYm90dG9tOiBudW1iZXIgPSBSZW5kZXJNYW5hZ2VyLmdldENhbnZhcygpLmNsaWVudEhlaWdodCwgX3RvcDogbnVtYmVyID0gMCk6IHZvaWQge1xyXG4gICAgICB0aGlzLnByb2plY3Rpb24gPSBQUk9KRUNUSU9OLk9SVEhPR1JBUEhJQztcclxuICAgICAgdGhpcy50cmFuc2Zvcm0gPSBNYXRyaXg0eDQuUFJPSkVDVElPTl9PUlRIT0dSQVBISUMoX2xlZnQsIF9yaWdodCwgX2JvdHRvbSwgX3RvcCwgNDAwLCAtNDAwKTsgLy8gVE9ETzogZXhhbWluZSBtYWdpYyBudW1iZXJzIVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBjYWxjdWxhdGVkIG5vcm1lZCBkaW1lbnNpb24gb2YgdGhlIHByb2plY3Rpb24gc3VyZmFjZSwgdGhhdCBpcyBpbiB0aGUgaHlwb3RoZXRpY2FsIGRpc3RhbmNlIG9mIDEgdG8gdGhlIGNhbWVyYVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0UHJvamVjdGlvblJlY3RhbmdsZSgpOiBSZWN0YW5nbGUge1xyXG4gICAgICBsZXQgdGFuRm92OiBudW1iZXIgPSBNYXRoLnRhbihNYXRoLlBJICogdGhpcy5maWVsZE9mVmlldyAvIDM2MCk7IC8vIEhhbGYgb2YgdGhlIGFuZ2xlLCB0byBjYWxjdWxhdGUgZGltZW5zaW9uIGZyb20gdGhlIGNlbnRlciAtPiByaWdodCBhbmdsZVxyXG4gICAgICBsZXQgdGFuSG9yaXpvbnRhbDogbnVtYmVyID0gMDtcclxuICAgICAgbGV0IHRhblZlcnRpY2FsOiBudW1iZXIgPSAwO1xyXG5cclxuICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uID09IEZJRUxEX09GX1ZJRVcuRElBR09OQUwpIHtcclxuICAgICAgICBsZXQgYXNwZWN0OiBudW1iZXIgPSBNYXRoLnNxcnQodGhpcy5hc3BlY3RSYXRpbyk7XHJcbiAgICAgICAgdGFuSG9yaXpvbnRhbCA9IHRhbkZvdiAqIGFzcGVjdDtcclxuICAgICAgICB0YW5WZXJ0aWNhbCA9IHRhbkZvdiAvIGFzcGVjdDtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmICh0aGlzLmRpcmVjdGlvbiA9PSBGSUVMRF9PRl9WSUVXLlZFUlRJQ0FMKSB7XHJcbiAgICAgICAgdGFuVmVydGljYWwgPSB0YW5Gb3Y7XHJcbiAgICAgICAgdGFuSG9yaXpvbnRhbCA9IHRhblZlcnRpY2FsICogdGhpcy5hc3BlY3RSYXRpbztcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHsvL0ZPVl9ESVJFQ1RJT04uSE9SSVpPTlRBTFxyXG4gICAgICAgIHRhbkhvcml6b250YWwgPSB0YW5Gb3Y7XHJcbiAgICAgICAgdGFuVmVydGljYWwgPSB0YW5Ib3Jpem9udGFsIC8gdGhpcy5hc3BlY3RSYXRpbztcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIFJlY3RhbmdsZS5HRVQoMCwgMCwgdGFuSG9yaXpvbnRhbCAqIDIsIHRhblZlcnRpY2FsICogMik7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHByb2plY3QoX3BvaW50SW5Xb3JsZFNwYWNlOiBWZWN0b3IzKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjM7XHJcbiAgICAgIHJlc3VsdCA9IFZlY3RvcjMuVFJBTlNGT1JNQVRJT04oX3BvaW50SW5Xb3JsZFNwYWNlLCB0aGlzLlZpZXdQcm9qZWN0aW9uTWF0cml4KTtcclxuICAgICAgbGV0IG06IEZsb2F0MzJBcnJheSA9IHRoaXMuVmlld1Byb2plY3Rpb25NYXRyaXguZ2V0KCk7XHJcbiAgICAgIGxldCB3OiBudW1iZXIgPSBtWzNdICogX3BvaW50SW5Xb3JsZFNwYWNlLnggKyBtWzddICogX3BvaW50SW5Xb3JsZFNwYWNlLnkgKyBtWzExXSAqIF9wb2ludEluV29ybGRTcGFjZS56ICsgbVsxNV07XHJcbiAgICAgIHJlc3VsdC5zY2FsZSgxIC8gdyk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHtcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuYmFja2dyb3VuZENvbG9yLFxyXG4gICAgICAgIGJhY2tncm91bmRFbmFibGVkOiB0aGlzLmJhY2tncm91bmRFbmFibGVkLFxyXG4gICAgICAgIHByb2plY3Rpb246IHRoaXMucHJvamVjdGlvbixcclxuICAgICAgICBmaWVsZE9mVmlldzogdGhpcy5maWVsZE9mVmlldyxcclxuICAgICAgICBkaXJlY3Rpb246IHRoaXMuZGlyZWN0aW9uLFxyXG4gICAgICAgIGFzcGVjdDogdGhpcy5hc3BlY3RSYXRpbyxcclxuICAgICAgICBwaXZvdDogdGhpcy5waXZvdC5zZXJpYWxpemUoKSxcclxuICAgICAgICBbc3VwZXIuY29uc3RydWN0b3IubmFtZV06IHN1cGVyLnNlcmlhbGl6ZSgpXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFNlcmlhbGl6YWJsZSB7XHJcbiAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gX3NlcmlhbGl6YXRpb24uYmFja2dyb3VuZENvbG9yO1xyXG4gICAgICB0aGlzLmJhY2tncm91bmRFbmFibGVkID0gX3NlcmlhbGl6YXRpb24uYmFja2dyb3VuZEVuYWJsZWQ7XHJcbiAgICAgIHRoaXMucHJvamVjdGlvbiA9IF9zZXJpYWxpemF0aW9uLnByb2plY3Rpb247XHJcbiAgICAgIHRoaXMuZmllbGRPZlZpZXcgPSBfc2VyaWFsaXphdGlvbi5maWVsZE9mVmlldztcclxuICAgICAgdGhpcy5hc3BlY3RSYXRpbyA9IF9zZXJpYWxpemF0aW9uLmFzcGVjdDtcclxuICAgICAgdGhpcy5kaXJlY3Rpb24gPSBfc2VyaWFsaXphdGlvbi5kaXJlY3Rpb247XHJcbiAgICAgIHRoaXMucGl2b3QuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24ucGl2b3QpO1xyXG4gICAgICBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XHJcbiAgICAgIHN3aXRjaCAodGhpcy5wcm9qZWN0aW9uKSB7XHJcbiAgICAgICAgY2FzZSBQUk9KRUNUSU9OLk9SVEhPR1JBUEhJQzpcclxuICAgICAgICAgIHRoaXMucHJvamVjdE9ydGhvZ3JhcGhpYygpOyAvLyBUT0RPOiBzZXJpYWxpemUgYW5kIGRlc2VyaWFsaXplIHBhcmFtZXRlcnNcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgUFJPSkVDVElPTi5DRU5UUkFMOlxyXG4gICAgICAgICAgdGhpcy5wcm9qZWN0Q2VudHJhbCgpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3JBdHRyaWJ1dGVUeXBlcyhfbXV0YXRvcjogTXV0YXRvcik6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyB7XHJcbiAgICAgIGxldCB0eXBlczogTXV0YXRvckF0dHJpYnV0ZVR5cGVzID0gc3VwZXIuZ2V0TXV0YXRvckF0dHJpYnV0ZVR5cGVzKF9tdXRhdG9yKTtcclxuICAgICAgaWYgKHR5cGVzLmRpcmVjdGlvbilcclxuICAgICAgICB0eXBlcy5kaXJlY3Rpb24gPSBGSUVMRF9PRl9WSUVXO1xyXG4gICAgICBpZiAodHlwZXMucHJvamVjdGlvbilcclxuICAgICAgICB0eXBlcy5wcm9qZWN0aW9uID0gUFJPSkVDVElPTjtcclxuICAgICAgcmV0dXJuIHR5cGVzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgc3VwZXIubXV0YXRlKF9tdXRhdG9yKTtcclxuXHJcbiAgICAgIHN3aXRjaCAodGhpcy5wcm9qZWN0aW9uKSB7XHJcbiAgICAgICAgY2FzZSBQUk9KRUNUSU9OLkNFTlRSQUw6XHJcbiAgICAgICAgICB0aGlzLnByb2plY3RDZW50cmFsKHRoaXMuYXNwZWN0UmF0aW8sIHRoaXMuZmllbGRPZlZpZXcsIHRoaXMuZGlyZWN0aW9uKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLnRyYW5zZm9ybTtcclxuICAgICAgc3VwZXIucmVkdWNlTXV0YXRvcihfbXV0YXRvcik7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICB9XHJcbn0iLCIvLyAvPHJlZmVyZW5jZSBwYXRoPVwiLi4vTGlnaHQvTGlnaHQudHNcIi8+XHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBBdHRhY2hlcyBhIFtbTGlnaHRdXSB0byB0aGUgbm9kZVxyXG4gICAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyBpZGVudGlmaWVycyBmb3IgdGhlIHZhcmlvdXMgdHlwZXMgb2YgbGlnaHQgdGhpcyBjb21wb25lbnQgY2FuIHByb3ZpZGUuICBcclxuICAgICAqL1xyXG4gICAgLy8gZXhwb3J0IGVudW0gTElHSFRfVFlQRSB7XHJcbiAgICAvLyAgICAgQU1CSUVOVCA9IFwiYW1iaWVudFwiLFxyXG4gICAgLy8gICAgIERJUkVDVElPTkFMID0gXCJkaXJlY3Rpb25hbFwiLFxyXG4gICAgLy8gICAgIFBPSU5UID0gXCJwb2ludFwiLFxyXG4gICAgLy8gICAgIFNQT1QgPSBcInNwb3RcIlxyXG4gICAgLy8gfVxyXG5cclxuICAgIGV4cG9ydCBjbGFzcyBDb21wb25lbnRMaWdodCBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRMaWdodCk7XHJcbiAgICAgICAgLy8gcHJpdmF0ZSBzdGF0aWMgY29uc3RydWN0b3JzOiB7IFt0eXBlOiBzdHJpbmddOiBHZW5lcmFsIH0gPSB7IFtMSUdIVF9UWVBFLkFNQklFTlRdOiBMaWdodEFtYmllbnQsIFtMSUdIVF9UWVBFLkRJUkVDVElPTkFMXTogTGlnaHREaXJlY3Rpb25hbCwgW0xJR0hUX1RZUEUuUE9JTlRdOiBMaWdodFBvaW50LCBbTElHSFRfVFlQRS5TUE9UXTogTGlnaHRTcG90IH07XHJcbiAgICAgICAgcHVibGljIHBpdm90OiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKTtcclxuICAgICAgICBwdWJsaWMgbGlnaHQ6IExpZ2h0ID0gbnVsbDtcclxuXHJcbiAgICAgICAgY29uc3RydWN0b3IoX2xpZ2h0OiBMaWdodCA9IG5ldyBMaWdodEFtYmllbnQoKSkge1xyXG4gICAgICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgICAgICB0aGlzLnNpbmdsZXRvbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmxpZ2h0ID0gX2xpZ2h0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHNldFR5cGU8VCBleHRlbmRzIExpZ2h0PihfY2xhc3M6IG5ldyAoKSA9PiBUKTogdm9pZCB7XHJcbiAgICAgICAgICAgIGxldCBtdHJPbGQ6IE11dGF0b3IgPSB7fTtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGlnaHQpXHJcbiAgICAgICAgICAgICAgICBtdHJPbGQgPSB0aGlzLmxpZ2h0LmdldE11dGF0b3IoKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubGlnaHQgPSBuZXcgX2NsYXNzKCk7XHJcbiAgICAgICAgICAgIHRoaXMubGlnaHQubXV0YXRlKG10ck9sZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIGEgW1tNYXRlcmlhbF1dIHRvIHRoZSBub2RlXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29tcG9uZW50TWF0ZXJpYWwgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IENvbXBvbmVudC5yZWdpc3RlclN1YmNsYXNzKENvbXBvbmVudE1hdGVyaWFsKTtcclxuICAgIHB1YmxpYyBtYXRlcmlhbDogTWF0ZXJpYWw7XHJcbiAgICBwdWJsaWMgY2xyUHJpbWFyeTogQ29sb3IgPSBDb2xvci5DU1MoXCJ3aGl0ZVwiKTtcclxuICAgIHB1YmxpYyBjbHJTZWNvbmRhcnk6IENvbG9yID0gQ29sb3IuQ1NTKFwid2hpdGVcIik7XHJcbiAgICBwdWJsaWMgcGl2b3Q6IE1hdHJpeDN4MyA9IE1hdHJpeDN4My5JREVOVElUWSgpO1xyXG4gICAgLy8gcHVibGljIG11dGF0b3JDb2F0OiBNdXRhdG9yRm9yQ29tcG9uZW50O1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbWF0ZXJpYWw6IE1hdGVyaWFsID0gbnVsbCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLm1hdGVyaWFsID0gX21hdGVyaWFsO1xyXG4gICAgICAvLyB0aGlzLm11dGF0b3JDb2F0ID0gX21hdGVyaWFsLmdldENvYXQoKS5nZXRNdXRhdG9yRm9yQ29tcG9uZW50KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbjtcclxuICAgICAgLyogYXQgdGhpcyBwb2ludCBvZiB0aW1lLCBzZXJpYWxpemF0aW9uIGFzIHJlc291cmNlIGFuZCBhcyBpbmxpbmUgb2JqZWN0IGlzIHBvc3NpYmxlLiBUT0RPOiBjaGVjayBpZiBpbmxpbmUgYmVjb21lcyBvYnNvbGV0ZSAqL1xyXG4gICAgICBsZXQgaWRNYXRlcmlhbDogc3RyaW5nID0gdGhpcy5tYXRlcmlhbC5pZFJlc291cmNlO1xyXG4gICAgICBpZiAoaWRNYXRlcmlhbClcclxuICAgICAgICBzZXJpYWxpemF0aW9uID0geyBpZE1hdGVyaWFsOiBpZE1hdGVyaWFsIH07XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBzZXJpYWxpemF0aW9uID0geyBtYXRlcmlhbDogU2VyaWFsaXplci5zZXJpYWxpemUodGhpcy5tYXRlcmlhbCkgfTtcclxuXHJcbiAgICAgIHNlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBTZXJpYWxpemFibGUge1xyXG4gICAgICBsZXQgbWF0ZXJpYWw6IE1hdGVyaWFsO1xyXG4gICAgICBpZiAoX3NlcmlhbGl6YXRpb24uaWRNYXRlcmlhbClcclxuICAgICAgICBtYXRlcmlhbCA9IDxNYXRlcmlhbD5SZXNvdXJjZU1hbmFnZXIuZ2V0KF9zZXJpYWxpemF0aW9uLmlkTWF0ZXJpYWwpO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgbWF0ZXJpYWwgPSA8TWF0ZXJpYWw+U2VyaWFsaXplci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5tYXRlcmlhbCk7XHJcbiAgICAgIHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbDtcclxuICAgICAgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBwdWJsaWMgZ2V0TXV0YXRvckZvclVzZXJJbnRlcmZhY2UoKTogTXV0YXRvckZvclVzZXJJbnRlcmZhY2Uge1xyXG4gICAgLy8gICBsZXQgbXV0YXRvckNvYXQ6IE11dGF0b3JGb3JDb21wb25lbnQgPSB0aGlzLm1hdGVyaWFsLmdldENvYXQoKS5nZXRNdXRhdG9yRm9yQ29tcG9uZW50KCk7XHJcbiAgICAvLyAgIHJldHVybiA8TXV0YXRvckZvclVzZXJJbnRlcmZhY2U+PHVua25vd24+bXV0YXRvckNvYXQ7XHJcbiAgICAvLyB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBBdHRhY2hlcyBhIFtbTWVzaF1dIHRvIHRoZSBub2RlXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29tcG9uZW50TWVzaCBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gQ29tcG9uZW50LnJlZ2lzdGVyU3ViY2xhc3MoQ29tcG9uZW50TWVzaCk7XHJcbiAgICBwdWJsaWMgcGl2b3Q6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpO1xyXG4gICAgcHVibGljIG1lc2g6IE1lc2ggPSBudWxsO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbWVzaDogTWVzaCA9IG51bGwpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5tZXNoID0gX21lc2g7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbjtcclxuICAgICAgLyogYXQgdGhpcyBwb2ludCBvZiB0aW1lLCBzZXJpYWxpemF0aW9uIGFzIHJlc291cmNlIGFuZCBhcyBpbmxpbmUgb2JqZWN0IGlzIHBvc3NpYmxlLiBUT0RPOiBjaGVjayBpZiBpbmxpbmUgYmVjb21lcyBvYnNvbGV0ZSAqL1xyXG4gICAgICBsZXQgaWRNZXNoOiBzdHJpbmcgPSB0aGlzLm1lc2guaWRSZXNvdXJjZTtcclxuICAgICAgaWYgKGlkTWVzaClcclxuICAgICAgICBzZXJpYWxpemF0aW9uID0geyBpZE1lc2g6IGlkTWVzaCB9O1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgc2VyaWFsaXphdGlvbiA9IHsgbWVzaDogU2VyaWFsaXplci5zZXJpYWxpemUodGhpcy5tZXNoKSB9O1xyXG5cclxuICAgICAgc2VyaWFsaXphdGlvbi5waXZvdCA9IHRoaXMucGl2b3Quc2VyaWFsaXplKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogU2VyaWFsaXphYmxlIHtcclxuICAgICAgbGV0IG1lc2g6IE1lc2g7XHJcbiAgICAgIGlmIChfc2VyaWFsaXphdGlvbi5pZE1lc2gpXHJcbiAgICAgICAgbWVzaCA9IDxNZXNoPlJlc291cmNlTWFuYWdlci5nZXQoX3NlcmlhbGl6YXRpb24uaWRNZXNoKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIG1lc2ggPSA8TWVzaD5TZXJpYWxpemVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLm1lc2gpO1xyXG4gICAgICB0aGlzLm1lc2ggPSBtZXNoO1xyXG5cclxuICAgICAgdGhpcy5waXZvdC5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5waXZvdCk7XHJcbiAgICAgIHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3JGb3JVc2VySW50ZXJmYWNlKCk6IE11dGF0b3JGb3JVc2VySW50ZXJmYWNlIHtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3JGb3JVc2VySW50ZXJmYWNlID0gPE11dGF0b3JGb3JVc2VySW50ZXJmYWNlPnRoaXMuZ2V0TXV0YXRvcigpO1xyXG4gICAgICBpZiAoIXRoaXMubWVzaClcclxuICAgICAgICBtdXRhdG9yLm1lc2ggPSBNZXNoO1xyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gIH1cclxufVxyXG4iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBCYXNlIGNsYXNzIGZvciBzY3JpcHRzIHRoZSB1c2VyIHdyaXRlc1xyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL0ppcmthRGVsbE9yby9GVURHRS93aWtpL0NvbXBvbmVudFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb21wb25lbnRTY3JpcHQgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgLy8gcmVnaXN0ZXJpbmcgdGhpcyBkb2Vzbid0IG1ha2Ugc2Vuc2UsIG9ubHkgaXRzIHN1YmNsYXNzZXMuIE9yIHRoaXMgY29tcG9uZW50IG11c3QgcmVmZXIgdG8gc2NyaXB0cyB0byBiZSBhdHRhY2hlZCB0byB0aGlzIGNvbXBvbmVudFxyXG4gICAgLy8gVE9ETzogcmV0aGluayAmIHJlZmFjdG9yXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gQ29tcG9uZW50LnJlZ2lzdGVyU3ViY2xhc3MoQ29tcG9uZW50U2NyaXB0KTtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLnNpbmdsZXRvbiA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldE11dGF0b3IoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBTZXJpYWxpemFibGUge1xyXG4gICAgICB0aGlzLm11dGF0ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG5cclxuICBleHBvcnQgZW51bSBCQVNFIHtcclxuICAgIFNFTEYsIFBBUkVOVCwgV09STEQsIE5PREVcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIGEgdHJhbnNmb3JtLVtbTWF0cml4NHg0XV0gdG8gdGhlIG5vZGUsIG1vdmluZywgc2NhbGluZyBhbmQgcm90YXRpbmcgaXQgaW4gc3BhY2UgcmVsYXRpdmUgdG8gaXRzIHBhcmVudC5cclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb21wb25lbnRUcmFuc2Zvcm0gZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IENvbXBvbmVudC5yZWdpc3RlclN1YmNsYXNzKENvbXBvbmVudFRyYW5zZm9ybSk7XHJcbiAgICBwdWJsaWMgbG9jYWw6IE1hdHJpeDR4NDtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX21hdHJpeDogTWF0cml4NHg0ID0gTWF0cml4NHg0LklERU5USVRZKCkpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5sb2NhbCA9IF9tYXRyaXg7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZm9ybWF0aW9ucyByZXNwZWN0aW5nIHRoZSBoaWVyYXJjaHlcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkanVzdHMgdGhlIHJvdGF0aW9uIHRvIHBvaW50IHRoZSB6LWF4aXMgZGlyZWN0bHkgYXQgdGhlIGdpdmVuIHRhcmdldCBwb2ludCBpbiB3b3JsZCBzcGFjZSBhbmQgdGlsdHMgaXQgdG8gYWNjb3JkIHdpdGggdGhlIGdpdmVuIHVwIHZlY3RvcixcclxuICAgICAqIHJlc3BlY3RpdmVseSBjYWxjdWxhdGluZyB5YXcgYW5kIHBpdGNoLiBJZiBubyB1cCB2ZWN0b3IgaXMgZ2l2ZW4sIHRoZSBwcmV2aW91cyB1cC12ZWN0b3IgaXMgdXNlZC4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBsb29rQXQoX3RhcmdldFdvcmxkOiBWZWN0b3IzLCBfdXA/OiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIGxldCBjb250YWluZXI6IE5vZGUgPSB0aGlzLmdldENvbnRhaW5lcigpO1xyXG4gICAgICBpZiAoIWNvbnRhaW5lciAmJiAhY29udGFpbmVyLmdldFBhcmVudCgpKVxyXG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsLmxvb2tBdChfdGFyZ2V0V29ybGQsIF91cCk7XHJcblxyXG4gICAgICAvLyBjb21wb25lbnQgaXMgYXR0YWNoZWQgdG8gYSBjaGlsZCBub2RlIC0+IHRyYW5zZm9ybSByZXNwZWN0aW5nIHRoZSBoaWVyYXJjaHlcclxuICAgICAgbGV0IG10eFdvcmxkOiBNYXRyaXg0eDQgPSBjb250YWluZXIubXR4V29ybGQuY29weTtcclxuICAgICAgbXR4V29ybGQubG9va0F0KF90YXJnZXRXb3JsZCwgX3VwLCB0cnVlKTtcclxuICAgICAgbGV0IGxvY2FsOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuUkVMQVRJVkUobXR4V29ybGQsIG51bGwsIGNvbnRhaW5lci5nZXRQYXJlbnQoKS5tdHhXb3JsZEludmVyc2UpO1xyXG4gICAgICB0aGlzLmxvY2FsID0gbG9jYWw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGp1c3RzIHRoZSByb3RhdGlvbiB0byBtYXRjaCBpdHMgeS1heGlzIHdpdGggdGhlIGdpdmVuIHVwLXZlY3RvciBhbmQgZmFjaW5nIGl0cyB6LWF4aXMgdG93YXJkIHRoZSBnaXZlbiB0YXJnZXQgYXQgbWluaW1hbCBhbmdsZSxcclxuICAgICAqIHJlc3BlY3RpdmVseSBjYWxjdWxhdGluZyB5YXcgb25seS4gSWYgbm8gdXAgdmVjdG9yIGlzIGdpdmVuLCB0aGUgcHJldmlvdXMgdXAtdmVjdG9yIGlzIHVzZWQuIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2hvd1RvKF90YXJnZXRXb3JsZDogVmVjdG9yMywgX3VwPzogVmVjdG9yMyk6IHZvaWQge1xyXG4gICAgICBsZXQgY29udGFpbmVyOiBOb2RlID0gdGhpcy5nZXRDb250YWluZXIoKTtcclxuICAgICAgaWYgKCFjb250YWluZXIgJiYgIWNvbnRhaW5lci5nZXRQYXJlbnQoKSlcclxuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbC5zaG93VG8oX3RhcmdldFdvcmxkLCBfdXApO1xyXG5cclxuICAgICAgLy8gY29tcG9uZW50IGlzIGF0dGFjaGVkIHRvIGEgY2hpbGQgbm9kZSAtPiB0cmFuc2Zvcm0gcmVzcGVjdGluZyB0aGUgaGllcmFyY2h5XHJcbiAgICAgIGxldCBtdHhXb3JsZDogTWF0cml4NHg0ID0gY29udGFpbmVyLm10eFdvcmxkLmNvcHk7XHJcbiAgICAgIG10eFdvcmxkLnNob3dUbyhfdGFyZ2V0V29ybGQsIF91cCwgdHJ1ZSk7XHJcbiAgICAgIGxldCBsb2NhbDogTWF0cml4NHg0ID0gTWF0cml4NHg0LlJFTEFUSVZFKG10eFdvcmxkLCBudWxsLCBjb250YWluZXIuZ2V0UGFyZW50KCkubXR4V29ybGRJbnZlcnNlKTtcclxuICAgICAgdGhpcy5sb2NhbCA9IGxvY2FsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmVjYWxjdWxhdGVzIHRoaXMgbG9jYWwgbWF0cml4IHRvIHlpZWxkIHRoZSBpZGVudGljYWwgd29ybGQgbWF0cml4IGJhc2VkIG9uIHRoZSBnaXZlbiBub2RlLlxyXG4gICAgICogVXNlIHJlYmFzZSBiZWZvcmUgYXBwZW5kaW5nIHRoZSBjb250YWluZXIgb2YgdGhpcyBjb21wb25lbnQgdG8gYW5vdGhlciBub2RlIHdoaWxlIHByZXNlcnZpbmcgaXRzIHRyYW5zZm9ybWF0aW9uIGluIHRoZSB3b3JsZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlYmFzZShfbm9kZTogTm9kZSA9IG51bGwpOiB2b2lkIHtcclxuICAgICAgbGV0IG10eFJlc3VsdDogTWF0cml4NHg0ID0gdGhpcy5sb2NhbDtcclxuICAgICAgbGV0IGNvbnRhaW5lcjogTm9kZSA9IHRoaXMuZ2V0Q29udGFpbmVyKCk7XHJcbiAgICAgIGlmIChjb250YWluZXIpXHJcbiAgICAgICAgbXR4UmVzdWx0ID0gY29udGFpbmVyLm10eFdvcmxkO1xyXG5cclxuICAgICAgaWYgKF9ub2RlKVxyXG4gICAgICAgIG10eFJlc3VsdCA9IE1hdHJpeDR4NC5SRUxBVElWRShtdHhSZXN1bHQsIG51bGwsIF9ub2RlLm10eFdvcmxkSW52ZXJzZSk7XHJcblxyXG4gICAgICB0aGlzLmxvY2FsID0gbXR4UmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgZ2l2ZW4gdHJhbnNmb3JtYXRpb24gcmVsYXRpdmUgdG8gdGhlIHNlbGVjdGVkIGJhc2UgKFNFTEYsIFBBUkVOVCwgV09STEQpIG9yIGEgcGFydGljdWxhciBvdGhlciBub2RlIChOT0RFKVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdHJhbnNmb3JtKF90cmFuc2Zvcm06IE1hdHJpeDR4NCwgX2Jhc2U6IEJBU0UgPSBCQVNFLlNFTEYsIF9ub2RlOiBOb2RlID0gbnVsbCk6IHZvaWQge1xyXG4gICAgICBzd2l0Y2ggKF9iYXNlKSB7XHJcbiAgICAgICAgY2FzZSBCQVNFLlNFTEY6XHJcbiAgICAgICAgICB0aGlzLmxvY2FsLm11bHRpcGx5KF90cmFuc2Zvcm0pO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBCQVNFLlBBUkVOVDpcclxuICAgICAgICAgIHRoaXMubG9jYWwubXVsdGlwbHkoX3RyYW5zZm9ybSwgdHJ1ZSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEJBU0UuTk9ERTpcclxuICAgICAgICAgIGlmICghX25vZGUpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJBU0UuTk9ERSByZXF1aXJlcyBhIG5vZGUgZ2l2ZW4gYXMgYmFzZVwiKTtcclxuICAgICAgICBjYXNlIEJBU0UuV09STEQ6XHJcbiAgICAgICAgICB0aGlzLnJlYmFzZShfbm9kZSk7XHJcbiAgICAgICAgICB0aGlzLmxvY2FsLm11bHRpcGx5KF90cmFuc2Zvcm0sIHRydWUpO1xyXG5cclxuICAgICAgICAgIGxldCBjb250YWluZXI6IE5vZGUgPSB0aGlzLmdldENvbnRhaW5lcigpO1xyXG4gICAgICAgICAgaWYgKGNvbnRhaW5lcikge1xyXG4gICAgICAgICAgICBpZiAoX2Jhc2UgPT0gQkFTRS5OT0RFKVxyXG4gICAgICAgICAgICAgIC8vIGZpeCBtdHhXb3JsZCBvZiBjb250YWluZXIgZm9yIHN1YnNlcXVlbnQgcmViYXNpbmcgXHJcbiAgICAgICAgICAgICAgY29udGFpbmVyLm10eFdvcmxkLnNldChNYXRyaXg0eDQuTVVMVElQTElDQVRJT04oX25vZGUubXR4V29ybGQsIGNvbnRhaW5lci5tdHhMb2NhbCkpO1xyXG5cclxuICAgICAgICAgICAgbGV0IHBhcmVudDogTm9kZSA9IGNvbnRhaW5lci5nZXRQYXJlbnQoKTtcclxuICAgICAgICAgICAgaWYgKHBhcmVudCkge1xyXG4gICAgICAgICAgICAgIC8vIGZpeCBtdHhMb2NhbCBmb3IgY3VycmVudCBwYXJlbnRcclxuICAgICAgICAgICAgICB0aGlzLnJlYmFzZShjb250YWluZXIuZ2V0UGFyZW50KCkpO1xyXG4gICAgICAgICAgICAgIGNvbnRhaW5lci5tdHhXb3JsZC5zZXQoTWF0cml4NHg0Lk1VTFRJUExJQ0FUSU9OKGNvbnRhaW5lci5nZXRQYXJlbnQoKS5tdHhXb3JsZCwgY29udGFpbmVyLm10eExvY2FsKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge1xyXG4gICAgICAgIGxvY2FsOiB0aGlzLmxvY2FsLnNlcmlhbGl6ZSgpLFxyXG4gICAgICAgIFtzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXTogc3VwZXIuc2VyaWFsaXplKClcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBTZXJpYWxpemFibGUge1xyXG4gICAgICBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XHJcbiAgICAgIHRoaXMubG9jYWwuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24ubG9jYWwpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBwdWJsaWMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAvLyAgICAgdGhpcy5sb2NhbC5tdXRhdGUoX211dGF0b3IpO1xyXG4gICAgLy8gfVxyXG4gICAgLy8gcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7IFxyXG4gICAgLy8gICAgIHJldHVybiB0aGlzLmxvY2FsLmdldE11dGF0b3IoKTtcclxuICAgIC8vIH1cclxuXHJcbiAgICAvLyBwdWJsaWMgZ2V0TXV0YXRvckF0dHJpYnV0ZVR5cGVzKF9tdXRhdG9yOiBNdXRhdG9yKTogTXV0YXRvckF0dHJpYnV0ZVR5cGVzIHtcclxuICAgIC8vICAgICBsZXQgdHlwZXM6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyA9IHRoaXMubG9jYWwuZ2V0TXV0YXRvckF0dHJpYnV0ZVR5cGVzKF9tdXRhdG9yKTtcclxuICAgIC8vICAgICByZXR1cm4gdHlwZXM7XHJcbiAgICAvLyB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLndvcmxkO1xyXG4gICAgICBzdXBlci5yZWR1Y2VNdXRhdG9yKF9tdXRhdG9yKTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gIH1cclxufVxyXG4iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgY29uc3QgZW51bSBFVkVOVF9DT05UUk9MIHtcclxuICAgIElOUFVUID0gXCJpbnB1dFwiLFxyXG4gICAgT1VUUFVUID0gXCJvdXRwdXRcIlxyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGNvbnN0IGVudW0gQ09OVFJPTF9UWVBFIHtcclxuICAgIC8qKiBUaGUgb3V0cHV0IHNpbXBseSBmb2xsb3dzIHRoZSBzY2FsZWQgYW5kIGRlbGF5ZWQgaW5wdXQgKi9cclxuICAgIFBST1BPUlRJT05BTCxcclxuICAgIC8qKiBUaGUgb3V0cHV0IHZhbHVlIGNoYW5nZXMgb3ZlciB0aW1lIHdpdGggYSByYXRlIGdpdmVuIGJ5IHRoZSBzY2FsZWQgYW5kIGRlbGF5ZWQgaW5wdXQgKi9cclxuICAgIElOVEVHUkFMLFxyXG4gICAgLyoqIFRoZSBvdXRwdXQgdmFsdWUgcmVhY3RzIHRvIGNoYW5nZXMgb2YgdGhlIHNjYWxlZCBpbnB1dCBhbmQgZHJvcHMgdG8gMCB3aXRoIGdpdmVuIGRlbGF5LCBpZiBpbnB1dCByZW1haW5zIGNvbnN0YW50ICovXHJcbiAgICBESUZGRVJFTlRJQUxcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFByb2Nlc3NlcyBpbnB1dCBzaWduYWxzIG9mIHR5cGUgbnVtYmVyIGFuZCBnZW5lcmF0ZXMgYW4gb3V0cHV0IHNpZ25hbCBvZiB0aGUgc2FtZSB0eXBlIHVzaW5nIFxyXG4gICAqIHByb3BvcnRpb25hbCwgaW50ZWdyYWwgb3IgZGlmZmVyZW50aWFsIG1hcHBpbmcsIGFuIGFtcGxpZmljYXRpb24gZmFjdG9yIGFuZCBhIGxpbmVhciBkYW1wZW5pbmcvZGVsYXlcclxuICAgKiBgYGBwbGFpbnRleHRcclxuICAgKiAgICAgICAgICDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcclxuICAgKiAgICAgICAgICDilIIgICDilIzilIDilIDilIDilIDilIDilIDilIDilJAgICDilIzilIDilIDilIDilIDilIDilJAgICAgICBwYXNzIHRocm91Z2ggKFByb3BvcnRpb25hbCkgICAgICDilIJcclxuICAgKiAgSW5wdXQg4oaSIOKUgiDihpIg4pSCYW1wbGlmeeKUgiDihpIg4pSCZGVsYXnilIIg4oaSIOKanyBzdW0gdXAgb3ZlciB0aW1lIChJbnRlZ3JhbCkg4pqeIOKGkiDilIIg4oaSIE91dHB1dFxyXG4gICAqICAgICAgICAgIOKUgiAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUmCAgICAgIHBhc3MgY2hhbmdlICAoRGlmZmVyZW50aWFsKSAgICAgIOKUglxyXG4gICAqICAgICAgICAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmCBcclxuICAgKiBgYGBcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29udHJvbCBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcclxuICAgIHB1YmxpYyByZWFkb25seSB0eXBlOiBDT05UUk9MX1RZUEU7XHJcbiAgICBwdWJsaWMgYWN0aXZlOiBib29sZWFuO1xyXG4gICAgcHVibGljIG5hbWU6IHN0cmluZztcclxuXHJcbiAgICBwcm90ZWN0ZWQgcmF0ZURpc3BhdGNoT3V0cHV0OiBudW1iZXIgPSAwO1xyXG4gICAgcHJvdGVjdGVkIHZhbHVlUHJldmlvdXM6IG51bWJlciA9IDA7XHJcbiAgICBwcm90ZWN0ZWQgb3V0cHV0QmFzZTogbnVtYmVyID0gMDtcclxuICAgIHByb3RlY3RlZCBvdXRwdXRUYXJnZXQ6IG51bWJlciA9IDA7XHJcbiAgICBwcm90ZWN0ZWQgb3V0cHV0UHJldmlvdXM6IG51bWJlciA9IDA7XHJcbiAgICBwcm90ZWN0ZWQgb3V0cHV0VGFyZ2V0UHJldmlvdXM6IG51bWJlciA9IDA7XHJcbiAgICBwcm90ZWN0ZWQgZmFjdG9yOiBudW1iZXIgPSAwO1xyXG5cclxuICAgIHByb3RlY3RlZCB0aW1lOiBUaW1lID0gVGltZS5nYW1lO1xyXG4gICAgcHJvdGVjdGVkIHRpbWVWYWx1ZURlbGF5OiBudW1iZXIgPSAwO1xyXG4gICAgcHJvdGVjdGVkIHRpbWVPdXRwdXRUYXJnZXRTZXQ6IG51bWJlciA9IDA7XHJcbiAgICBwcm90ZWN0ZWQgaWRUaW1lcjogbnVtYmVyID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKF9uYW1lOiBzdHJpbmcsIF9mYWN0b3I6IG51bWJlciA9IDEsIF90eXBlOiBDT05UUk9MX1RZUEUgPSBDT05UUk9MX1RZUEUuUFJPUE9SVElPTkFMLCBfYWN0aXZlOiBib29sZWFuID0gdHJ1ZSkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLmZhY3RvciA9IF9mYWN0b3I7XHJcbiAgICAgIHRoaXMudHlwZSA9IF90eXBlO1xyXG4gICAgICB0aGlzLmFjdGl2ZSA9IF9hY3RpdmU7XHJcbiAgICAgIHRoaXMubmFtZSA9IF9uYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSB0aW1lLW9iamVjdCB0byBiZSB1c2VkIHdoZW4gY2FsY3VsYXRpbmcgdGhlIG91dHB1dCBpbiBbW0NPTlRST0xfVFlQRS5JTlRFR1JBTF1dXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRUaW1lYmFzZShfdGltZTogVGltZSk6IHZvaWQge1xyXG4gICAgICB0aGlzLnRpbWUgPSBfdGltZTtcclxuICAgICAgdGhpcy5jYWxjdWxhdGVPdXRwdXQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZlZWQgYW4gaW5wdXQgdmFsdWUgaW50byB0aGlzIGNvbnRyb2wgYW5kIGZpcmUgdGhlIGV2ZW50cyBbW0VWRU5UX0NPTlRST0wuSU5QVVRdXSBhbmQgW1tFVkVOVF9DT05UUk9MLk9VVFBVVF1dXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRJbnB1dChfaW5wdXQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICB0aGlzLm91dHB1dEJhc2UgPSB0aGlzLmNhbGN1bGF0ZU91dHB1dCgpO1xyXG4gICAgICB0aGlzLnZhbHVlUHJldmlvdXMgPSB0aGlzLmdldFZhbHVlRGVsYXllZCgpO1xyXG4gICAgICB0aGlzLm91dHB1dFRhcmdldCA9IHRoaXMuZmFjdG9yICogX2lucHV0O1xyXG4gICAgICB0aGlzLnRpbWVPdXRwdXRUYXJnZXRTZXQgPSB0aGlzLnRpbWUuZ2V0KCk7XHJcblxyXG4gICAgICBpZiAodGhpcy50eXBlID09IENPTlRST0xfVFlQRS5ESUZGRVJFTlRJQUwpIHtcclxuICAgICAgICB0aGlzLnZhbHVlUHJldmlvdXMgPSB0aGlzLm91dHB1dFRhcmdldCAtIHRoaXMub3V0cHV0VGFyZ2V0UHJldmlvdXM7XHJcbiAgICAgICAgdGhpcy5vdXRwdXRUYXJnZXRQcmV2aW91cyA9IHRoaXMub3V0cHV0VGFyZ2V0O1xyXG4gICAgICAgIHRoaXMub3V0cHV0VGFyZ2V0ID0gMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVF9DT05UUk9MLklOUFVUKSk7XHJcbiAgICAgIGlmICh0aGlzLnR5cGUgPT0gQ09OVFJPTF9UWVBFLkRJRkZFUkVOVElBTClcclxuICAgICAgICB0aGlzLmRpc3BhdGNoT3V0cHV0KHRoaXMudmFsdWVQcmV2aW91cyk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICB0aGlzLmRpc3BhdGNoT3V0cHV0KG51bGwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSB0aW1lIHRvIHRha2UgZm9yIHRoZSBpbnRlcm5hbCBsaW5lYXIgZGFtcGVuaW5nIHVudGlsIHRoZSBmaW5hbCBvdXB1dCB2YWx1ZSBpcyByZWFjaGVkXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXREZWxheShfdGltZTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIHRoaXMudGltZVZhbHVlRGVsYXkgPSBNYXRoLm1heCgwLCBfdGltZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIG51bWJlciBvZiBvdXRwdXQtZXZlbnRzIHRvIGRpc3BhdGNoIHBlciBzZWNvbmQuIFxyXG4gICAgICogQXQgdGhlIGRlZmF1bHQgb2YgMCwgdGhlIGNvbnRyb2wgb3V0cHV0IG11c3QgYmUgcG9sbGVkIGFuZCB3aWxsIG9ubHkgYWN0aXZlbHkgZGlzcGF0Y2hlZCBvbmNlIGVhY2ggdGltZSBpbnB1dCBvY2N1cnMgYW5kIHRoZSBvdXRwdXQgY2hhbmdlcy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFJhdGVEaXNwYXRjaE91dHB1dChfcmF0ZURpc3BhdGNoT3V0cHV0OiBudW1iZXIgPSAwKTogdm9pZCB7XHJcbiAgICAgIHRoaXMucmF0ZURpc3BhdGNoT3V0cHV0ID0gX3JhdGVEaXNwYXRjaE91dHB1dDtcclxuICAgICAgdGhpcy50aW1lLmRlbGV0ZVRpbWVyKHRoaXMuaWRUaW1lcik7XHJcbiAgICAgIHRoaXMuaWRUaW1lciA9IHVuZGVmaW5lZDtcclxuICAgICAgaWYgKHRoaXMucmF0ZURpc3BhdGNoT3V0cHV0KVxyXG4gICAgICAgIHRoaXMuaWRUaW1lciA9IHRoaXMudGltZS5zZXRUaW1lcigxMDAwIC8gdGhpcy5yYXRlRGlzcGF0Y2hPdXRwdXQsIDAsIHRoaXMuZGlzcGF0Y2hPdXRwdXQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBmYWN0b3IgdG8gbXVsdGlwbHkgdGhlIGlucHV0IHZhbHVlIGdpdmVuIHdpdGggW1tzZXRJbnB1dF1dIHdpdGhcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldEZhY3RvcihfZmFjdG9yOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy5mYWN0b3IgPSBfZmFjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBvdXRwdXQgb2YgdGhpcyBjb250cm9sXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRPdXRwdXQoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY2FsY3VsYXRlT3V0cHV0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBvdXRwdXQgb2YgdGhpcyBjb250cm9sXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBjYWxjdWxhdGVPdXRwdXQoKTogbnVtYmVyIHtcclxuICAgICAgbGV0IG91dHB1dDogbnVtYmVyID0gMDtcclxuICAgICAgbGV0IHZhbHVlOiBudW1iZXIgPSB0aGlzLmdldFZhbHVlRGVsYXllZCgpO1xyXG5cclxuICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcclxuICAgICAgICBjYXNlIENPTlRST0xfVFlQRS5JTlRFR1JBTDpcclxuICAgICAgICAgIGxldCB0aW1lQ3VycmVudDogbnVtYmVyID0gdGhpcy50aW1lLmdldCgpO1xyXG4gICAgICAgICAgbGV0IHRpbWVFbGFwc2VkU2luY2VJbnB1dDogbnVtYmVyID0gdGltZUN1cnJlbnQgLSB0aGlzLnRpbWVPdXRwdXRUYXJnZXRTZXQ7XHJcbiAgICAgICAgICBvdXRwdXQgPSB0aGlzLm91dHB1dEJhc2U7XHJcblxyXG4gICAgICAgICAgaWYgKHRoaXMudGltZVZhbHVlRGVsYXkgPiAwKSB7XHJcbiAgICAgICAgICAgIGlmICh0aW1lRWxhcHNlZFNpbmNlSW5wdXQgPCB0aGlzLnRpbWVWYWx1ZURlbGF5KSB7XHJcbiAgICAgICAgICAgICAgb3V0cHV0ICs9IDAuNSAqICh0aGlzLnZhbHVlUHJldmlvdXMgKyB2YWx1ZSkgKiB0aW1lRWxhcHNlZFNpbmNlSW5wdXQ7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgb3V0cHV0ICs9IDAuNSAqICh0aGlzLnZhbHVlUHJldmlvdXMgKyB2YWx1ZSkgKiB0aGlzLnRpbWVWYWx1ZURlbGF5O1xyXG4gICAgICAgICAgICAgIHRpbWVFbGFwc2VkU2luY2VJbnB1dCAtPSB0aGlzLnRpbWVWYWx1ZURlbGF5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBvdXRwdXQgKz0gdmFsdWUgKiB0aW1lRWxhcHNlZFNpbmNlSW5wdXQ7XHJcbiAgICAgICAgICAvLyB2YWx1ZSArPSAwLjUgKiAodGhpcy5pbnB1dFByZXZpb3VzIC0gaW5wdXQpICogdGhpcy50aW1lSW5wdXREZWxheSArIGlucHV0ICogdGltZUVsYXBzZWRTaW5jZUlucHV0O1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBDT05UUk9MX1RZUEUuRElGRkVSRU5USUFMOlxyXG4gICAgICAgIGNhc2UgQ09OVFJPTF9UWVBFLlBST1BPUlRJT05BTDpcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgb3V0cHV0ID0gdmFsdWU7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZ2V0VmFsdWVEZWxheWVkKCk6IG51bWJlciB7XHJcbiAgICAgIGlmICh0aGlzLnRpbWVWYWx1ZURlbGF5ID4gMCkge1xyXG4gICAgICAgIGxldCB0aW1lRWxhcHNlZFNpbmNlSW5wdXQ6IG51bWJlciA9IHRoaXMudGltZS5nZXQoKSAtIHRoaXMudGltZU91dHB1dFRhcmdldFNldDtcclxuICAgICAgICBpZiAodGltZUVsYXBzZWRTaW5jZUlucHV0IDwgdGhpcy50aW1lVmFsdWVEZWxheSlcclxuICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlUHJldmlvdXMgKyAodGhpcy5vdXRwdXRUYXJnZXQgLSB0aGlzLnZhbHVlUHJldmlvdXMpICogdGltZUVsYXBzZWRTaW5jZUlucHV0IC8gdGhpcy50aW1lVmFsdWVEZWxheTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy5vdXRwdXRUYXJnZXQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBkaXNwYXRjaE91dHB1dCA9IChfZXZlbnRPclZhbHVlOiBFdmVudFRpbWVyIHwgbnVtYmVyKTogdm9pZCA9PiB7XHJcbiAgICAgIGxldCB0aW1lcjogVGltZXIgPSB0aGlzLnRpbWUuZ2V0VGltZXIodGhpcy5pZFRpbWVyKTtcclxuICAgICAgbGV0IG91dHB1dDogbnVtYmVyO1xyXG4gICAgICBpZiAodHlwZW9mIChfZXZlbnRPclZhbHVlKSA9PSBcIm51bWJlclwiKVxyXG4gICAgICAgIG91dHB1dCA9IF9ldmVudE9yVmFsdWU7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBvdXRwdXQgPSB0aGlzLmNhbGN1bGF0ZU91dHB1dCgpO1xyXG4gICAgICBsZXQgb3V0cHV0Q2hhbmdlZDogYm9vbGVhbiA9IChvdXRwdXQgIT0gdGhpcy5vdXRwdXRQcmV2aW91cyk7XHJcblxyXG4gICAgICBpZiAodGltZXIpXHJcbiAgICAgICAgdGltZXIuYWN0aXZlID0gb3V0cHV0Q2hhbmdlZDtcclxuXHJcbiAgICAgIGlmICghb3V0cHV0Q2hhbmdlZClcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICB0aGlzLm91dHB1dFByZXZpb3VzID0gb3V0cHV0O1xyXG5cclxuICAgICAgbGV0IGV2ZW50OiBDdXN0b21FdmVudCA9IG5ldyBDdXN0b21FdmVudChFVkVOVF9DT05UUk9MLk9VVFBVVCwge1xyXG4gICAgICAgIGRldGFpbDoge1xyXG4gICAgICAgICAgb3V0cHV0OiBvdXRwdXRcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgIH1cclxuICB9XHJcbn0iLCIvLy88cmVmZXJlbmNlIHBhdGg9XCJDb250cm9sLnRzXCIvPlxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBIYW5kbGVzIG11bHRpcGxlIGNvbnRyb2xzIGFzIGlucHV0cyBhbmQgY3JlYXRlcyBhbiBvdXRwdXQgZnJvbSB0aGF0LlxyXG4gICAqIEFzIGEgc3ViY2xhc3Mgb2YgW1tDb250cm9sXV0sIGF4aXMgY2FsY3VsYXRlcyB0aGUgb3VwdXQgc3VtbWluZyB1cCB0aGUgaW5wdXRzIGFuZCBwcm9jZXNzaW5nIHRoZSByZXN1bHQgdXNpbmcgaXRzIG93biBzZXR0aW5ncy4gIFxyXG4gICAqIERpc3BhdGNoZXMgW1tFVkVOVF9DT05UUk9MLk9VVFBVVF1dIGFuZCBbW0VWRU5UX0NPTlRST0wuSU5QVVRdXSB3aGVuIG9uZSBvZiB0aGUgY29udHJvbHMgZGlzcGF0Y2hlcyB0aGVtLlxyXG4gICAqIGBgYHBsYWludGV4dFxyXG4gICAqICAgICAgICAgICDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcclxuICAgKiAgICAgICAgICAg4pSCIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxyXG4gICAqICAgSW5wdXQg4oaSIOKUgiDilIJjb250cm9s4pSCXFwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxyXG4gICAqICAgICAgICAgICDilIIg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYIFxcICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxyXG4gICAqICAgICAgICAgICDilIIg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQICBcXOKUjOKUgOKUgOKUgOKUkCAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgIOKUglxyXG4gICAqICAgSW5wdXQg4oaSIOKUgiDilIJjb250cm9s4pSCLS0t4pSCc3Vt4pSCIOKGkiDilIJpbnRlcm5hbCBjb250cm9sIOKUgiDihpIg4pSCIOKGkiBPdXRwdXRcclxuICAgKiAgICAgICAgICAg4pSCIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgL+KUlOKUgOKUgOKUgOKUmCAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgIOKUglxyXG4gICAqICAgICAgICAgICDilIIg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQIC8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXHJcbiAgICogICBJbnB1dCDihpIg4pSCIOKUgmNvbnRyb2zilIIvICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcclxuICAgKiAgICAgICAgICAg4pSCIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxyXG4gICAqICAgICAgICAgICDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJggIFxyXG4gICAqIGBgYFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBBeGlzIGV4dGVuZHMgQ29udHJvbCB7XHJcbiAgICBwcml2YXRlIGNvbnRyb2xzOiBNYXA8c3RyaW5nLCBDb250cm9sPiA9IG5ldyBNYXAoKTtcclxuICAgIHByaXZhdGUgc3VtUHJldmlvdXM6IG51bWJlciA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgdGhlIGNvbnRyb2wgZ2l2ZW4gdG8gdGhlIGxpc3Qgb2YgY29udHJvbHMgZmVlZGluZyBpbnRvIHRoaXMgYXhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWRkQ29udHJvbChfY29udHJvbDogQ29udHJvbCk6IHZvaWQge1xyXG4gICAgICB0aGlzLmNvbnRyb2xzLnNldChfY29udHJvbC5uYW1lLCBfY29udHJvbCk7XHJcbiAgICAgIF9jb250cm9sLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRfQ09OVFJPTC5JTlBVVCwgdGhpcy5obmRJbnB1dEV2ZW50KTtcclxuICAgICAgX2NvbnRyb2wuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVF9DT05UUk9MLk9VVFBVVCwgdGhpcy5obmRPdXRwdXRFdmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjb250cm9sIHdpdGggdGhlIGdpdmVuIG5hbWVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldENvbnRyb2woX25hbWU6IHN0cmluZyk6IENvbnRyb2wge1xyXG4gICAgICByZXR1cm4gdGhpcy5jb250cm9scy5nZXQoX25hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgY29udHJvbCB3aXRoIHRoZSBnaXZlbiBuYW1lXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZW1vdmVDb250cm9sKF9uYW1lOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgbGV0IGNvbnRyb2w6IENvbnRyb2wgPSB0aGlzLmdldENvbnRyb2woX25hbWUpO1xyXG4gICAgICBpZiAoY29udHJvbCkge1xyXG4gICAgICAgIGNvbnRyb2wucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVF9DT05UUk9MLklOUFVULCB0aGlzLmhuZElucHV0RXZlbnQpO1xyXG4gICAgICAgIGNvbnRyb2wucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVF9DT05UUk9MLk9VVFBVVCwgdGhpcy5obmRPdXRwdXRFdmVudCk7XHJcbiAgICAgICAgdGhpcy5jb250cm9scy5kZWxldGUoX25hbWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGlzIGF4aXMgYWZ0ZXIgc3VtbWluZyB1cCBhbGwgaW5wdXRzIGFuZCBwcm9jZXNzaW5nIHRoZSBzdW0gYWNjb3JkaW5nIHRvIHRoZSBheGlzJyBzZXR0aW5nc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0T3V0cHV0KCk6IG51bWJlciB7XHJcbiAgICAgIGxldCBzdW1JbnB1dDogbnVtYmVyID0gMDtcclxuICAgICAgZm9yIChsZXQgY29udHJvbCBvZiB0aGlzLmNvbnRyb2xzKSB7XHJcblxyXG4gICAgICAgIGlmIChjb250cm9sWzFdLmFjdGl2ZSlcclxuICAgICAgICAgIHN1bUlucHV0ICs9IGNvbnRyb2xbMV0uZ2V0T3V0cHV0KCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzdW1JbnB1dCAhPSB0aGlzLnN1bVByZXZpb3VzKVxyXG4gICAgICAgIHN1cGVyLnNldElucHV0KHN1bUlucHV0KTtcclxuXHJcbiAgICAgIHRoaXMuc3VtUHJldmlvdXMgPSBzdW1JbnB1dDtcclxuXHJcbiAgICAgIHJldHVybiBzdXBlci5nZXRPdXRwdXQoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGhuZE91dHB1dEV2ZW50OiBFdmVudExpc3RlbmVyID0gKF9ldmVudDogRXZlbnQpOiB2b2lkID0+IHtcclxuICAgICAgbGV0IGNvbnRyb2w6IENvbnRyb2wgPSAoPENvbnRyb2w+X2V2ZW50LnRhcmdldCk7XHJcbiAgICAgIGxldCBldmVudDogQ3VzdG9tRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoRVZFTlRfQ09OVFJPTC5PVVRQVVQsIHtkZXRhaWw6IHtcclxuICAgICAgICBjb250cm9sOiBjb250cm9sLCBcclxuICAgICAgICBpbnB1dDogKDxDdXN0b21FdmVudD5fZXZlbnQpLmRldGFpbC5vdXRwdXQsXHJcbiAgICAgICAgb3V0cHV0OiB0aGlzLmdldE91dHB1dCgpXHJcbiAgICAgIH19KTtcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGhuZElucHV0RXZlbnQ6IEV2ZW50TGlzdGVuZXIgPSAoX2V2ZW50OiBFdmVudCk6IHZvaWQgPT4ge1xyXG4gICAgICBsZXQgZXZlbnQ6IEV2ZW50ID0gbmV3IEV2ZW50KEVWRU5UX0NPTlRST0wuSU5QVVQsIF9ldmVudCk7XHJcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgaW50ZXJmYWNlIEtleVByZXNzZWQge1xyXG4gICAgW2NvZGU6IHN0cmluZ106IGJvb2xlYW47XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb2xsZWN0cyB0aGUga2V5cyBwcmVzc2VkIG9uIHRoZSBrZXlib2FyZCBhbmQgc3RvcmVzIHRoZWlyIHN0YXR1cy4gXHJcbiAgICovXHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIEtleWJvYXJkIHtcclxuICAgIHByaXZhdGUgc3RhdGljIGtleXNQcmVzc2VkOiBLZXlQcmVzc2VkID0gS2V5Ym9hcmQuaW5pdGlhbGl6ZSgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIG9uZSBvZiB0aGUgZ2l2ZW4ga2V5cyBpcyBpcyBjdXJyZW50bHkgYmVpbmcgcHJlc3NlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBpc1ByZXNzZWRPbmUoX2tleXM6IEtFWUJPQVJEX0NPREVbXSk6IGJvb2xlYW4ge1xyXG4gICAgICBmb3IgKGxldCBjb2RlIG9mIF9rZXlzKSB7XHJcbiAgICAgICAgaWYgKEtleWJvYXJkLmtleXNQcmVzc2VkW2NvZGVdKVxyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGFsbCBvZiB0aGUgZ2l2ZW4ga2V5cyBhcmUgY3VycmVudGx5IGJlaW5nIHByZXNzZWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBpc1ByZXNzZWRDb21ibyhfa2V5czogS0VZQk9BUkRfQ09ERVtdKTogYm9vbGVhbiB7XHJcbiAgICAgIGZvciAobGV0IGNvZGUgb2YgX2tleXMpIHtcclxuICAgICAgICBpZiAoIUtleWJvYXJkLmtleXNQcmVzc2VkW2NvZGVdKVxyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgZ2l2ZW4gYXMgX2FjdGl2ZSBpZiBvbmUgb3IsIHdoZW4gX2NvbWJvIGlzIHRydWUsIGFsbCBvZiB0aGUgZ2l2ZW4ga2V5cyBhcmUgcHJlc3NlZC5cclxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIGdpdmVuIGFzIF9pbmFjdGl2ZSBpZiBub3QuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgbWFwVG9WYWx1ZTxUPihfYWN0aXZlOiBULCBfaW5hY3RpdmU6IFQsIF9rZXlzOiBLRVlCT0FSRF9DT0RFW10sIF9jb21ibzogYm9vbGVhbiA9IGZhbHNlKTogVCB7XHJcbiAgICAgIGlmICghX2NvbWJvICYmIEtleWJvYXJkLmlzUHJlc3NlZE9uZShfa2V5cykpXHJcbiAgICAgICAgcmV0dXJuIF9hY3RpdmU7XHJcbiAgICAgIGlmIChLZXlib2FyZC5pc1ByZXNzZWRDb21ibyhfa2V5cykpXHJcbiAgICAgICAgcmV0dXJuIF9hY3RpdmU7XHJcbiAgICAgIHJldHVybiBfaW5hY3RpdmU7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgaW5pdGlhbGl6ZSgpOiBLZXlQcmVzc2VkIHtcclxuICAgICAgbGV0IHN0b3JlOiBLZXlQcmVzc2VkID0ge307XHJcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIEtleWJvYXJkLmhuZEtleUludGVyYWN0aW9uKTtcclxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIEtleWJvYXJkLmhuZEtleUludGVyYWN0aW9uKTtcclxuICAgICAgcmV0dXJuIHN0b3JlO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGhuZEtleUludGVyYWN0aW9uKF9ldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xyXG4gICAgICBLZXlib2FyZC5rZXlzUHJlc3NlZFtfZXZlbnQuY29kZV0gPSAoX2V2ZW50LnR5cGUgPT0gXCJrZXlkb3duXCIpO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiRGVidWdUYXJnZXQudHNcIi8+XHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFJvdXRpbmcgdG8gdGhlIGFsZXJ0IGJveFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBEZWJ1Z0FsZXJ0IGV4dGVuZHMgRGVidWdUYXJnZXQge1xyXG4gICAgcHVibGljIHN0YXRpYyBkZWxlZ2F0ZXM6IE1hcERlYnVnRmlsdGVyVG9EZWxlZ2F0ZSA9IHtcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5JTkZPXTogRGVidWdBbGVydC5jcmVhdGVEZWxlZ2F0ZShERUJVR19TWU1CT0xbREVCVUdfRklMVEVSLklORk9dKSxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5MT0ddOiBEZWJ1Z0FsZXJ0LmNyZWF0ZURlbGVnYXRlKERFQlVHX1NZTUJPTFtERUJVR19GSUxURVIuTE9HXSksXHJcbiAgICAgIFtERUJVR19GSUxURVIuV0FSTl06IERlYnVnQWxlcnQuY3JlYXRlRGVsZWdhdGUoREVCVUdfU1lNQk9MW0RFQlVHX0ZJTFRFUi5XQVJOXSksXHJcbiAgICAgIFtERUJVR19GSUxURVIuRVJST1JdOiBEZWJ1Z0FsZXJ0LmNyZWF0ZURlbGVnYXRlKERFQlVHX1NZTUJPTFtERUJVR19GSUxURVIuRVJST1JdKSxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5GVURHRV06IERlYnVnQWxlcnQuY3JlYXRlRGVsZWdhdGUoREVCVUdfU1lNQk9MW0RFQlVHX0ZJTFRFUi5GVURHRV0pXHJcbiAgICB9O1xyXG4gICAgcHVibGljIHN0YXRpYyBjcmVhdGVEZWxlZ2F0ZShfaGVhZGxpbmU6IHN0cmluZyk6IEZ1bmN0aW9uIHtcclxuICAgICAgbGV0IGRlbGVnYXRlOiBGdW5jdGlvbiA9IGZ1bmN0aW9uIChfbWVzc2FnZTogT2JqZWN0LCAuLi5fYXJnczogT2JqZWN0W10pOiB2b2lkIHtcclxuICAgICAgICBsZXQgYXJnczogc3RyaW5nW10gPSBfYXJncy5tYXAoX2FyZyA9PiBfYXJnLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIGxldCBvdXQ6IHN0cmluZyA9IF9oZWFkbGluZSArIFwiIFwiICsgRGVidWdUYXJnZXQubWVyZ2VBcmd1bWVudHMoX21lc3NhZ2UsIGFyZ3MpO1xyXG4gICAgICAgIGFsZXJ0KG91dCk7XHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBkZWxlZ2F0ZTtcclxuICAgIH1cclxuICB9XHJcbn0iLCIvLyAvIDxyZWZlcmVuY2UgcGF0aD1cIkRlYnVnVGFyZ2V0LnRzXCIvPlxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAgIC8qKlxyXG4gICAgICogUm91dGluZyB0byBhIEhUTUxEaWFsb2dFbGVtZW50XHJcbiAgICAgKi9cclxuICAgIGV4cG9ydCBjbGFzcyBEZWJ1Z0RpYWxvZyBleHRlbmRzIERlYnVnVGFyZ2V0IHtcclxuICAgICAgICAvLyBUT0RPOiBjaGVja291dCBIVE1MRGlhbG9nRWxlbWVudDsgISEhXHJcbiAgICB9XHJcbn0iLCIvLyAvIDxyZWZlcmVuY2UgcGF0aD1cIkRlYnVnVGFyZ2V0LnRzXCIvPlxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBSb3V0ZSB0byBhbiBIVE1MVGV4dEFyZWEsIG1heSBiZSBvYnNvbGV0ZSB3aGVuIHVzaW5nIEhUTUxEaWFsb2dFbGVtZW50XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIERlYnVnVGV4dEFyZWEgZXh0ZW5kcyBEZWJ1Z1RhcmdldCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHRleHRBcmVhOiBIVE1MVGV4dEFyZWFFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpO1xyXG4gICAgcHVibGljIHN0YXRpYyBhdXRvU2Nyb2xsOiBib29sZWFuID0gdHJ1ZTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGRlbGVnYXRlczogTWFwRGVidWdGaWx0ZXJUb0RlbGVnYXRlID0ge1xyXG4gICAgICBbREVCVUdfRklMVEVSLklORk9dOiBEZWJ1Z1RleHRBcmVhLmNyZWF0ZURlbGVnYXRlKERFQlVHX1NZTUJPTFtERUJVR19GSUxURVIuSU5GT10pLFxyXG4gICAgICBbREVCVUdfRklMVEVSLkxPR106IERlYnVnVGV4dEFyZWEuY3JlYXRlRGVsZWdhdGUoREVCVUdfU1lNQk9MW0RFQlVHX0ZJTFRFUi5MT0ddKSxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5XQVJOXTogRGVidWdUZXh0QXJlYS5jcmVhdGVEZWxlZ2F0ZShERUJVR19TWU1CT0xbREVCVUdfRklMVEVSLldBUk5dKSxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5FUlJPUl06IERlYnVnVGV4dEFyZWEuY3JlYXRlRGVsZWdhdGUoREVCVUdfU1lNQk9MW0RFQlVHX0ZJTFRFUi5FUlJPUl0pLFxyXG4gICAgICBbREVCVUdfRklMVEVSLkZVREdFXTogRGVidWdUZXh0QXJlYS5jcmVhdGVEZWxlZ2F0ZShERUJVR19TWU1CT0xbREVCVUdfRklMVEVSLkZVREdFXSksXHJcbiAgICAgIFtERUJVR19GSUxURVIuQ0xFQVJdOiBEZWJ1Z1RleHRBcmVhLmNsZWFyLFxyXG4gICAgICBbREVCVUdfRklMVEVSLkdST1VQXTogRGVidWdUZXh0QXJlYS5ncm91cCxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5HUk9VUENPTExBUFNFRF06IERlYnVnVGV4dEFyZWEuZ3JvdXAsXHJcbiAgICAgIFtERUJVR19GSUxURVIuR1JPVVBFTkRdOiBEZWJ1Z1RleHRBcmVhLmdyb3VwRW5kXHJcbiAgICB9O1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ3JvdXBzOiBzdHJpbmdbXSA9IFtdO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgY2xlYXIoKTogdm9pZCB7XHJcbiAgICAgIERlYnVnVGV4dEFyZWEudGV4dEFyZWEudGV4dENvbnRlbnQgPSBcIlwiO1xyXG4gICAgICBEZWJ1Z1RleHRBcmVhLmdyb3VwcyA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ3JvdXAoX25hbWU6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICBEZWJ1Z1RleHRBcmVhLnByaW50KFwi4pa8IFwiICsgX25hbWUpO1xyXG4gICAgICBEZWJ1Z1RleHRBcmVhLmdyb3Vwcy5wdXNoKF9uYW1lKTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzdGF0aWMgZ3JvdXBFbmQoKTogdm9pZCB7XHJcbiAgICAgIERlYnVnVGV4dEFyZWEuZ3JvdXBzLnBvcCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgY3JlYXRlRGVsZWdhdGUoX2hlYWRsaW5lOiBzdHJpbmcpOiBGdW5jdGlvbiB7XHJcbiAgICAgIGxldCBkZWxlZ2F0ZTogRnVuY3Rpb24gPSBmdW5jdGlvbiAoX21lc3NhZ2U6IE9iamVjdCwgLi4uX2FyZ3M6IE9iamVjdFtdKTogdm9pZCB7XHJcbiAgICAgICAgRGVidWdUZXh0QXJlYS5wcmludChfaGVhZGxpbmUgKyBcIiBcIiArIERlYnVnVGFyZ2V0Lm1lcmdlQXJndW1lbnRzKF9tZXNzYWdlLCBfYXJncykpO1xyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gZGVsZWdhdGU7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0SW5kZW50YXRpb24oX2xldmVsOiBudW1iZXIpOiBzdHJpbmcge1xyXG4gICAgICBsZXQgcmVzdWx0OiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgX2xldmVsOyBpKyspXHJcbiAgICAgICAgcmVzdWx0ICs9IFwifCBcIjtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBwcmludChfdGV4dDogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgIERlYnVnVGV4dEFyZWEudGV4dEFyZWEudGV4dENvbnRlbnQgKz0gRGVidWdUZXh0QXJlYS5nZXRJbmRlbnRhdGlvbihEZWJ1Z1RleHRBcmVhLmdyb3Vwcy5sZW5ndGgpICsgX3RleHQgKyBcIlxcblwiO1xyXG4gICAgICBpZiAoRGVidWdUZXh0QXJlYS5hdXRvU2Nyb2xsKVxyXG4gICAgICAgIERlYnVnVGV4dEFyZWEudGV4dEFyZWEuc2Nyb2xsVG9wID0gRGVidWdUZXh0QXJlYS50ZXh0QXJlYS5zY3JvbGxIZWlnaHQ7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogRGVmaW5lcyBhIGNvbG9yIGFzIHZhbHVlcyBpbiB0aGUgcmFuZ2Ugb2YgMCB0byAxIGZvciB0aGUgZm91ciBjaGFubmVscyByZWQsIGdyZWVuLCBibHVlIGFuZCBhbHBoYSAoZm9yIG9wYWNpdHkpXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIENvbG9yIGV4dGVuZHMgTXV0YWJsZSB7IC8vaW1wbGVtZW50cyBTZXJpYWxpemFibGUge1xyXG4gICAgLy8gY3JjMiBvbmx5IHVzZWQgZm9yIGNvbnZlcnRpbmcgY29sb3JzIGZyb20gc3RyaW5ncyBwcmVkZWZpbmVkIGJ5IENTU1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgY3JjMjogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKS5nZXRDb250ZXh0KFwiMmRcIik7XHJcblxyXG4gICAgcHVibGljIHI6IG51bWJlcjtcclxuICAgIHB1YmxpYyBnOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgYjogbnVtYmVyO1xyXG4gICAgcHVibGljIGE6IG51bWJlcjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihfcjogbnVtYmVyID0gMSwgX2c6IG51bWJlciA9IDEsIF9iOiBudW1iZXIgPSAxLCBfYTogbnVtYmVyID0gMSkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLnNldE5vcm1SR0JBKF9yLCBfZywgX2IsIF9hKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldEhleEZyb21DU1NLZXl3b3JkKF9rZXl3b3JkOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICBDb2xvci5jcmMyLmZpbGxTdHlsZSA9IF9rZXl3b3JkO1xyXG4gICAgICByZXR1cm4gQ29sb3IuY3JjMi5maWxsU3R5bGU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBDU1MoX2tleXdvcmQ6IHN0cmluZywgX2FscGhhOiBudW1iZXIgPSAxKTogQ29sb3Ige1xyXG4gICAgICBsZXQgaGV4OiBzdHJpbmcgPSBDb2xvci5nZXRIZXhGcm9tQ1NTS2V5d29yZChfa2V5d29yZCk7XHJcbiAgICAgIGxldCBjb2xvcjogQ29sb3IgPSBuZXcgQ29sb3IoXHJcbiAgICAgICAgcGFyc2VJbnQoaGV4LnN1YnN0cigxLCAyKSwgMTYpIC8gMjU1LFxyXG4gICAgICAgIHBhcnNlSW50KGhleC5zdWJzdHIoMywgMiksIDE2KSAvIDI1NSxcclxuICAgICAgICBwYXJzZUludChoZXguc3Vic3RyKDUsIDIpLCAxNikgLyAyNTUsXHJcbiAgICAgICAgX2FscGhhKTtcclxuICAgICAgcmV0dXJuIGNvbG9yO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIE1VTFRJUExZKF9jb2xvcjE6IENvbG9yLCBfY29sb3IyOiBDb2xvcik6IENvbG9yIHtcclxuICAgICAgcmV0dXJuIG5ldyBDb2xvcihfY29sb3IxLnIgKiBfY29sb3IyLnIsIF9jb2xvcjEuZyAqIF9jb2xvcjIuZywgX2NvbG9yMS5iICogX2NvbG9yMi5iLCBfY29sb3IxLmEgKiBfY29sb3IyLmEpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXROb3JtUkdCQShfcjogbnVtYmVyLCBfZzogbnVtYmVyLCBfYjogbnVtYmVyLCBfYTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuciA9IE1hdGgubWluKDEsIE1hdGgubWF4KDAsIF9yKSk7XHJcbiAgICAgIHRoaXMuZyA9IE1hdGgubWluKDEsIE1hdGgubWF4KDAsIF9nKSk7XHJcbiAgICAgIHRoaXMuYiA9IE1hdGgubWluKDEsIE1hdGgubWF4KDAsIF9iKSk7XHJcbiAgICAgIHRoaXMuYSA9IE1hdGgubWluKDEsIE1hdGgubWF4KDAsIF9hKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldEJ5dGVzUkdCQShfcjogbnVtYmVyLCBfZzogbnVtYmVyLCBfYjogbnVtYmVyLCBfYTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuc2V0Tm9ybVJHQkEoX3IgLyAyNTUsIF9nIC8gMjU1LCBfYiAvIDI1NSwgX2EgLyAyNTUpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRBcnJheSgpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbdGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdGhpcy5hXSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldEFycmF5Tm9ybVJHQkEoX2NvbG9yOiBGbG9hdDMyQXJyYXkpOiB2b2lkIHtcclxuICAgICAgdGhpcy5zZXROb3JtUkdCQShfY29sb3JbMF0sIF9jb2xvclsxXSwgX2NvbG9yWzJdLCBfY29sb3JbM10pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXRBcnJheUJ5dGVzUkdCQShfY29sb3I6IFVpbnQ4Q2xhbXBlZEFycmF5KTogdm9pZCB7XHJcbiAgICAgIHRoaXMuc2V0Qnl0ZXNSR0JBKF9jb2xvclswXSwgX2NvbG9yWzFdLCBfY29sb3JbMl0sIF9jb2xvclszXSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEFycmF5Qnl0ZXNSR0JBKCk6IFVpbnQ4Q2xhbXBlZEFycmF5IHtcclxuICAgICAgcmV0dXJuIG5ldyBVaW50OENsYW1wZWRBcnJheShbdGhpcy5yICogMjU1LCB0aGlzLmcgKiAyNTUsIHRoaXMuYiAqIDI1NSwgdGhpcy5hICogMjU1XSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFkZChfY29sb3I6IENvbG9yKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuciArPSBfY29sb3IucjtcclxuICAgICAgdGhpcy5nICs9IF9jb2xvci5nO1xyXG4gICAgICB0aGlzLmIgKz0gX2NvbG9yLmI7XHJcbiAgICAgIHRoaXMuYSArPSBfY29sb3IuYTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0Q1NTKCk6IHN0cmluZyB7XHJcbiAgICAgIGxldCBieXRlczogVWludDhDbGFtcGVkQXJyYXkgPSB0aGlzLmdldEFycmF5Qnl0ZXNSR0JBKCk7XHJcbiAgICAgIHJldHVybiBgUkdCQSgke2J5dGVzWzBdfSwgJHtieXRlc1sxXX0sICR7Ynl0ZXNbMl19LCAke2J5dGVzWzNdfSlgO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRIZXgoKTogc3RyaW5nIHtcclxuICAgICAgbGV0IGJ5dGVzOiBVaW50OENsYW1wZWRBcnJheSA9IHRoaXMuZ2V0QXJyYXlCeXRlc1JHQkEoKTtcclxuICAgICAgbGV0IGhleDogc3RyaW5nID0gXCJcIjtcclxuICAgICAgZm9yIChsZXQgYnl0ZSBvZiBieXRlcylcclxuICAgICAgICBoZXggKz0gYnl0ZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpO1xyXG4gICAgICByZXR1cm4gaGV4O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXRIZXgoX2hleDogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgIGxldCBieXRlczogVWludDhDbGFtcGVkQXJyYXkgPSB0aGlzLmdldEFycmF5Qnl0ZXNSR0JBKCk7XHJcbiAgICAgIGxldCBjaGFubmVsOiBudW1iZXIgPSAwO1xyXG4gICAgICBmb3IgKGxldCBieXRlIGluIGJ5dGVzKVxyXG4gICAgICAgIGJ5dGVzW2J5dGVdID0gcGFyc2VJbnQoX2hleC5zdWJzdHIoY2hhbm5lbCsrICogMiwgMiksIDE2KTtcclxuICAgICAgdGhpcy5zZXRBcnJheUJ5dGVzUkdCQShieXRlcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHsvKiogKi8gfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEJhc2VjbGFzcyBmb3IgbWF0ZXJpYWxzLiBDb21iaW5lcyBhIFtbU2hhZGVyXV0gd2l0aCBhIGNvbXBhdGlibGUgW1tDb2F0XV1cclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBNYXRlcmlhbCBleHRlbmRzIE11dGFibGUgaW1wbGVtZW50cyBTZXJpYWxpemFibGVSZXNvdXJjZSB7XHJcbiAgICAvKiogVGhlIG5hbWUgdG8gY2FsbCB0aGUgTWF0ZXJpYWwgYnkuICovXHJcbiAgICBwdWJsaWMgbmFtZTogc3RyaW5nO1xyXG4gICAgcHVibGljIGlkUmVzb3VyY2U6IHN0cmluZyA9IHVuZGVmaW5lZDtcclxuICAgIHByaXZhdGUgc2hhZGVyVHlwZTogdHlwZW9mIFNoYWRlcjsgLy8gVGhlIHNoYWRlciBwcm9ncmFtIHVzZWQgYnkgdGhpcyBCYXNlTWF0ZXJpYWxcclxuICAgIHByaXZhdGUgY29hdDogQ29hdDtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX25hbWU6IHN0cmluZywgX3NoYWRlcj86IHR5cGVvZiBTaGFkZXIsIF9jb2F0PzogQ29hdCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLm5hbWUgPSBfbmFtZTtcclxuICAgICAgdGhpcy5zaGFkZXJUeXBlID0gX3NoYWRlcjtcclxuICAgICAgaWYgKF9zaGFkZXIpIHtcclxuICAgICAgICBpZiAoX2NvYXQpXHJcbiAgICAgICAgICB0aGlzLnNldENvYXQoX2NvYXQpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIHRoaXMuc2V0Q29hdCh0aGlzLmNyZWF0ZUNvYXRNYXRjaGluZ1NoYWRlcigpKTtcclxuICAgICAgfVxyXG4gICAgICBSZXNvdXJjZU1hbmFnZXIucmVnaXN0ZXIodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFtbQ29hdF1dIGluc3RhbmNlIHRoYXQgaXMgdmFsaWQgZm9yIHRoZSBbW1NoYWRlcl1dIHJlZmVyZW5jZWQgYnkgdGhpcyBtYXRlcmlhbFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY3JlYXRlQ29hdE1hdGNoaW5nU2hhZGVyKCk6IENvYXQge1xyXG4gICAgICBsZXQgY29hdDogQ29hdCA9IG5ldyAodGhpcy5zaGFkZXJUeXBlLmdldENvYXQoKSkoKTtcclxuICAgICAgcmV0dXJuIGNvYXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYWtlcyB0aGlzIG1hdGVyaWFsIHJlZmVyZW5jZSB0aGUgZ2l2ZW4gW1tDb2F0XV0gaWYgaXQgaXMgY29tcGF0aWJsZSB3aXRoIHRoZSByZWZlcmVuY2VkIFtbU2hhZGVyXV1cclxuICAgICAqIEBwYXJhbSBfY29hdCBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldENvYXQoX2NvYXQ6IENvYXQpOiB2b2lkIHtcclxuICAgICAgaWYgKF9jb2F0LmNvbnN0cnVjdG9yICE9IHRoaXMuc2hhZGVyVHlwZS5nZXRDb2F0KCkpXHJcbiAgICAgICAgaWYgKF9jb2F0IGluc3RhbmNlb2YgdGhpcy5zaGFkZXJUeXBlLmdldENvYXQoKSlcclxuICAgICAgICAgIERlYnVnLmZ1ZGdlKFwiQ29hdCBpcyBleHRlbnNpb24gb2YgQ29hdCByZXF1aXJlZCBieSBzaGFkZXJcIik7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgdGhyb3cgKG5ldyBFcnJvcihcIlNoYWRlciBhbmQgY29hdCBkb24ndCBtYXRjaFwiKSk7XHJcbiAgICAgIHRoaXMuY29hdCA9IF9jb2F0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudGx5IHJlZmVyZW5jZWQgW1tDb2F0XV0gaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldENvYXQoKTogQ29hdCB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNvYXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2VzIHRoZSBtYXRlcmlhbHMgcmVmZXJlbmNlIHRvIHRoZSBnaXZlbiBbW1NoYWRlcl1dLCBjcmVhdGVzIGFuZCByZWZlcmVuY2VzIGEgbmV3IFtbQ29hdF1dIGluc3RhbmNlICBcclxuICAgICAqIGFuZCBtdXRhdGVzIHRoZSBuZXcgY29hdCB0byBwcmVzZXJ2ZSBtYXRjaGluZyBwcm9wZXJ0aWVzLlxyXG4gICAgICogQHBhcmFtIF9zaGFkZXJUeXBlIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0U2hhZGVyKF9zaGFkZXJUeXBlOiB0eXBlb2YgU2hhZGVyKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuc2hhZGVyVHlwZSA9IF9zaGFkZXJUeXBlO1xyXG4gICAgICBsZXQgY29hdDogQ29hdCA9IHRoaXMuY3JlYXRlQ29hdE1hdGNoaW5nU2hhZGVyKCk7XHJcbiAgICAgIGNvYXQubXV0YXRlKHRoaXMuY29hdC5nZXRNdXRhdG9yKCkpO1xyXG4gICAgICB0aGlzLnNldENvYXQoY29hdCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBbW1NoYWRlcl1dIHJlZmVyZW5jZWQgYnkgdGhpcyBtYXRlcmlhbFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0U2hhZGVyKCk6IHR5cGVvZiBTaGFkZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5zaGFkZXJUeXBlO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIC8vIFRPRE86IHRoaXMgdHlwZSBvZiBzZXJpYWxpemF0aW9uIHdhcyBpbXBsZW1lbnRlZCBmb3IgaW1wbGljaXQgTWF0ZXJpYWwgY3JlYXRlLiBDaGVjayBpZiBvYnNvbGV0ZSB3aGVuIG9ubHkgb25lIG1hdGVyaWFsIGNsYXNzIGV4aXN0cyBhbmQvb3IgbWF0ZXJpYWxzIGFyZSBzdG9yZWQgc2VwYXJhdGVseVxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgIGlkUmVzb3VyY2U6IHRoaXMuaWRSZXNvdXJjZSxcclxuICAgICAgICBzaGFkZXI6IHRoaXMuc2hhZGVyVHlwZS5uYW1lLFxyXG4gICAgICAgIGNvYXQ6IFNlcmlhbGl6ZXIuc2VyaWFsaXplKHRoaXMuY29hdClcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBTZXJpYWxpemFibGUge1xyXG4gICAgICB0aGlzLm5hbWUgPSBfc2VyaWFsaXphdGlvbi5uYW1lO1xyXG4gICAgICB0aGlzLmlkUmVzb3VyY2UgPSBfc2VyaWFsaXphdGlvbi5pZFJlc291cmNlO1xyXG4gICAgICAvLyBUT0RPOiBwcm92aWRlIGZvciBzaGFkZXJzIGluIHRoZSB1c2VycyBuYW1lc3BhY2UuIFNlZSBTZXJpYWxpemVyIGZ1bGxwYXRoIGV0Yy5cclxuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBuby1hbnlcclxuICAgICAgdGhpcy5zaGFkZXJUeXBlID0gKDxhbnk+RnVkZ2VDb3JlKVtfc2VyaWFsaXphdGlvbi5zaGFkZXJdO1xyXG4gICAgICBsZXQgY29hdDogQ29hdCA9IDxDb2F0PlNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24uY29hdCk7XHJcbiAgICAgIHRoaXMuc2V0Q29hdChjb2F0KTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIC8vXHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAgIGV4cG9ydCBpbnRlcmZhY2UgU2VyaWFsaXphYmxlUmVzb3VyY2UgZXh0ZW5kcyBTZXJpYWxpemFibGUge1xyXG4gICAgICAgIGlkUmVzb3VyY2U6IHN0cmluZztcclxuICAgIH1cclxuXHJcbiAgICBleHBvcnQgaW50ZXJmYWNlIFJlc291cmNlcyB7XHJcbiAgICAgICAgW2lkUmVzb3VyY2U6IHN0cmluZ106IFNlcmlhbGl6YWJsZVJlc291cmNlO1xyXG4gICAgfVxyXG5cclxuICAgIGV4cG9ydCBpbnRlcmZhY2UgU2VyaWFsaXphdGlvbk9mUmVzb3VyY2VzIHtcclxuICAgICAgICBbaWRSZXNvdXJjZTogc3RyaW5nXTogU2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0YXRpYyBjbGFzcyBoYW5kbGluZyB0aGUgcmVzb3VyY2VzIHVzZWQgd2l0aCB0aGUgY3VycmVudCBGVURHRS1pbnN0YW5jZS4gIFxyXG4gICAgICogS2VlcHMgYSBsaXN0IG9mIHRoZSByZXNvdXJjZXMgYW5kIGdlbmVyYXRlcyBpZHMgdG8gcmV0cmlldmUgdGhlbS4gIFxyXG4gICAgICogUmVzb3VyY2VzIGFyZSBvYmplY3RzIHJlZmVyZW5jZWQgbXVsdGlwbGUgdGltZXMgYnV0IHN1cHBvc2VkIHRvIGJlIHN0b3JlZCBvbmx5IG9uY2VcclxuICAgICAqL1xyXG4gICAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFJlc291cmNlTWFuYWdlciB7XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyByZXNvdXJjZXM6IFJlc291cmNlcyA9IHt9O1xyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbk9mUmVzb3VyY2VzID0gbnVsbDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2VuZXJhdGVzIGFuIGlkIGZvciB0aGUgcmVzb3VyY2VzIGFuZCByZWdpc3RlcnMgaXQgd2l0aCB0aGUgbGlzdCBvZiByZXNvdXJjZXMgXHJcbiAgICAgICAgICogQHBhcmFtIF9yZXNvdXJjZSBcclxuICAgICAgICAgKi9cclxuICAgICAgICBwdWJsaWMgc3RhdGljIHJlZ2lzdGVyKF9yZXNvdXJjZTogU2VyaWFsaXphYmxlUmVzb3VyY2UpOiB2b2lkIHtcclxuICAgICAgICAgICAgaWYgKCFfcmVzb3VyY2UuaWRSZXNvdXJjZSlcclxuICAgICAgICAgICAgICAgIF9yZXNvdXJjZS5pZFJlc291cmNlID0gUmVzb3VyY2VNYW5hZ2VyLmdlbmVyYXRlSWQoX3Jlc291cmNlKTtcclxuICAgICAgICAgICAgUmVzb3VyY2VNYW5hZ2VyLnJlc291cmNlc1tfcmVzb3VyY2UuaWRSZXNvdXJjZV0gPSBfcmVzb3VyY2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZW5lcmF0ZSBhIHVzZXIgcmVhZGFibGUgYW5kIHVuaXF1ZSBpZCB1c2luZyB0aGUgdHlwZSBvZiB0aGUgcmVzb3VyY2UsIHRoZSBkYXRlIGFuZCByYW5kb20gbnVtYmVyc1xyXG4gICAgICAgICAqIEBwYXJhbSBfcmVzb3VyY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGdlbmVyYXRlSWQoX3Jlc291cmNlOiBTZXJpYWxpemFibGVSZXNvdXJjZSk6IHN0cmluZyB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IGJ1aWxkIGlkIGFuZCBpbnRlZ3JhdGUgaW5mbyBmcm9tIHJlc291cmNlLCBub3QganVzdCBkYXRlXHJcbiAgICAgICAgICAgIGxldCBpZFJlc291cmNlOiBzdHJpbmc7XHJcbiAgICAgICAgICAgIGRvXHJcbiAgICAgICAgICAgICAgICBpZFJlc291cmNlID0gX3Jlc291cmNlLmNvbnN0cnVjdG9yLm5hbWUgKyBcInxcIiArIG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSArIFwifFwiICsgTWF0aC5yYW5kb20oKS50b1ByZWNpc2lvbig1KS5zdWJzdHIoMiwgNSk7XHJcbiAgICAgICAgICAgIHdoaWxlIChSZXNvdXJjZU1hbmFnZXIucmVzb3VyY2VzW2lkUmVzb3VyY2VdKTtcclxuICAgICAgICAgICAgcmV0dXJuIGlkUmVzb3VyY2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZXN0cywgaWYgYW4gb2JqZWN0IGlzIGEgW1tTZXJpYWxpemFibGVSZXNvdXJjZV1dXHJcbiAgICAgICAgICogQHBhcmFtIF9vYmplY3QgVGhlIG9iamVjdCB0byBleGFtaW5lXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBpc1Jlc291cmNlKF9vYmplY3Q6IFNlcmlhbGl6YWJsZSk6IGJvb2xlYW4ge1xyXG4gICAgICAgICAgICByZXR1cm4gKFJlZmxlY3QuaGFzKF9vYmplY3QsIFwiaWRSZXNvdXJjZVwiKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXRyaWV2ZXMgdGhlIHJlc291cmNlIHN0b3JlZCB3aXRoIHRoZSBnaXZlbiBpZFxyXG4gICAgICAgICAqIEBwYXJhbSBfaWRSZXNvdXJjZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgZ2V0KF9pZFJlc291cmNlOiBzdHJpbmcpOiBTZXJpYWxpemFibGVSZXNvdXJjZSB7XHJcbiAgICAgICAgICAgIGxldCByZXNvdXJjZTogU2VyaWFsaXphYmxlUmVzb3VyY2UgPSBSZXNvdXJjZU1hbmFnZXIucmVzb3VyY2VzW19pZFJlc291cmNlXTtcclxuICAgICAgICAgICAgaWYgKCFyZXNvdXJjZSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSBSZXNvdXJjZU1hbmFnZXIuc2VyaWFsaXphdGlvbltfaWRSZXNvdXJjZV07XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNlcmlhbGl6YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5lcnJvcihcIlJlc291cmNlIG5vdCBmb3VuZFwiLCBfaWRSZXNvdXJjZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXNvdXJjZSA9IFJlc291cmNlTWFuYWdlci5kZXNlcmlhbGl6ZVJlc291cmNlKHNlcmlhbGl6YXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXNvdXJjZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYW5kIHJlZ2lzdGVycyBhIHJlc291cmNlIGZyb20gYSBbW05vZGVdXSwgY29weWluZyB0aGUgY29tcGxldGUgZ3JhcGggc3RhcnRpbmcgd2l0aCBpdFxyXG4gICAgICAgICAqIEBwYXJhbSBfbm9kZSBBIG5vZGUgdG8gY3JlYXRlIHRoZSByZXNvdXJjZSBmcm9tXHJcbiAgICAgICAgICogQHBhcmFtIF9yZXBsYWNlV2l0aEluc3RhbmNlIGlmIHRydWUgKGRlZmF1bHQpLCB0aGUgbm9kZSB1c2VkIGFzIG9yaWdpbiBpcyByZXBsYWNlZCBieSBhIFtbTm9kZVJlc291cmNlSW5zdGFuY2VdXSBvZiB0aGUgW1tOb2RlUmVzb3VyY2VdXSBjcmVhdGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyByZWdpc3Rlck5vZGVBc1Jlc291cmNlKF9ub2RlOiBOb2RlLCBfcmVwbGFjZVdpdGhJbnN0YW5jZTogYm9vbGVhbiA9IHRydWUpOiBOb2RlUmVzb3VyY2Uge1xyXG4gICAgICAgICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IF9ub2RlLnNlcmlhbGl6ZSgpO1xyXG4gICAgICAgICAgICBsZXQgbm9kZVJlc291cmNlOiBOb2RlUmVzb3VyY2UgPSBuZXcgTm9kZVJlc291cmNlKFwiTm9kZVJlc291cmNlXCIpO1xyXG4gICAgICAgICAgICBub2RlUmVzb3VyY2UuZGVzZXJpYWxpemUoc2VyaWFsaXphdGlvbik7XHJcbiAgICAgICAgICAgIFJlc291cmNlTWFuYWdlci5yZWdpc3Rlcihub2RlUmVzb3VyY2UpO1xyXG5cclxuICAgICAgICAgICAgaWYgKF9yZXBsYWNlV2l0aEluc3RhbmNlICYmIF9ub2RlLmdldFBhcmVudCgpKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgaW5zdGFuY2U6IE5vZGVSZXNvdXJjZUluc3RhbmNlID0gbmV3IE5vZGVSZXNvdXJjZUluc3RhbmNlKG5vZGVSZXNvdXJjZSk7XHJcbiAgICAgICAgICAgICAgICBfbm9kZS5nZXRQYXJlbnQoKS5yZXBsYWNlQ2hpbGQoX25vZGUsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5vZGVSZXNvdXJjZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNlcmlhbGl6ZSBhbGwgcmVzb3VyY2VzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbk9mUmVzb3VyY2VzIHtcclxuICAgICAgICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb25PZlJlc291cmNlcyA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpZFJlc291cmNlIGluIFJlc291cmNlTWFuYWdlci5yZXNvdXJjZXMpIHtcclxuICAgICAgICAgICAgICAgIGxldCByZXNvdXJjZTogU2VyaWFsaXphYmxlUmVzb3VyY2UgPSBSZXNvdXJjZU1hbmFnZXIucmVzb3VyY2VzW2lkUmVzb3VyY2VdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlkUmVzb3VyY2UgIT0gcmVzb3VyY2UuaWRSZXNvdXJjZSlcclxuICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5lcnJvcihcIlJlc291cmNlLWlkIG1pc21hdGNoXCIsIHJlc291cmNlKTtcclxuICAgICAgICAgICAgICAgIHNlcmlhbGl6YXRpb25baWRSZXNvdXJjZV0gPSBTZXJpYWxpemVyLnNlcmlhbGl6ZShyZXNvdXJjZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGUgcmVzb3VyY2VzIGZyb20gYSBzZXJpYWxpemF0aW9uLCBkZWxldGluZyBhbGwgcmVzb3VyY2VzIHByZXZpb3VzbHkgcmVnaXN0ZXJlZFxyXG4gICAgICAgICAqIEBwYXJhbSBfc2VyaWFsaXphdGlvbiBcclxuICAgICAgICAgKi9cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uT2ZSZXNvdXJjZXMpOiBSZXNvdXJjZXMge1xyXG4gICAgICAgICAgICBSZXNvdXJjZU1hbmFnZXIuc2VyaWFsaXphdGlvbiA9IF9zZXJpYWxpemF0aW9uO1xyXG4gICAgICAgICAgICBSZXNvdXJjZU1hbmFnZXIucmVzb3VyY2VzID0ge307XHJcbiAgICAgICAgICAgIGZvciAobGV0IGlkUmVzb3VyY2UgaW4gX3NlcmlhbGl6YXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gX3NlcmlhbGl6YXRpb25baWRSZXNvdXJjZV07XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVzb3VyY2U6IFNlcmlhbGl6YWJsZVJlc291cmNlID0gUmVzb3VyY2VNYW5hZ2VyLmRlc2VyaWFsaXplUmVzb3VyY2Uoc2VyaWFsaXphdGlvbik7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzb3VyY2UpXHJcbiAgICAgICAgICAgICAgICAgICAgUmVzb3VyY2VNYW5hZ2VyLnJlc291cmNlc1tpZFJlc291cmNlXSA9IHJlc291cmNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBSZXNvdXJjZU1hbmFnZXIucmVzb3VyY2VzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgZGVzZXJpYWxpemVSZXNvdXJjZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFNlcmlhbGl6YWJsZVJlc291cmNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIDxTZXJpYWxpemFibGVSZXNvdXJjZT5TZXJpYWxpemVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBDb250cm9scyB0aGUgcmVuZGVyaW5nIG9mIGEgZ3JhcGgsIHVzaW5nIHRoZSBnaXZlbiBbW0NvbXBvbmVudENhbWVyYV1dLFxyXG4gICAqIGFuZCB0aGUgcHJvcGFnYXRpb24gb2YgdGhlIHJlbmRlcmVkIGltYWdlIGZyb20gdGhlIG9mZnNjcmVlbiByZW5kZXJidWZmZXIgdG8gdGhlIHRhcmdldCBjYW52YXNcclxuICAgKiB0aHJvdWdoIGEgc2VyaWVzIG9mIFtbRnJhbWluZ11dIG9iamVjdHMuIFRoZSBzdGFnZXMgaW52b2x2ZWQgYXJlIGluIG9yZGVyIG9mIHJlbmRlcmluZ1xyXG4gICAqIFtbUmVuZGVyTWFuYWdlcl1dLnZpZXdwb3J0IC0+IFtbVmlld3BvcnRdXS5zb3VyY2UgLT4gW1tWaWV3cG9ydF1dLmRlc3RpbmF0aW9uIC0+IERPTS1DYW52YXMgLT4gQ2xpZW50KENTUylcclxuICAgKiBAYXV0aG9ycyBKYXNjaGEgS2FyYWfDtmwsIEhGVSwgMjAxOSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFZpZXdwb3J0IGV4dGVuZHMgRXZlbnRUYXJnZXTGkiB7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBmb2N1czogVmlld3BvcnQ7XHJcblxyXG4gICAgcHVibGljIG5hbWU6IHN0cmluZyA9IFwiVmlld3BvcnRcIjsgLy8gVGhlIG5hbWUgdG8gY2FsbCB0aGlzIHZpZXdwb3J0IGJ5LlxyXG4gICAgcHVibGljIGNhbWVyYTogQ29tcG9uZW50Q2FtZXJhID0gbnVsbDsgLy8gVGhlIGNhbWVyYSByZXByZXNlbnRpbmcgdGhlIHZpZXcgcGFyYW1ldGVycyB0byByZW5kZXIgdGhlIGdyYXBoLlxyXG5cclxuICAgIHB1YmxpYyByZWN0U291cmNlOiBSZWN0YW5nbGU7XHJcbiAgICBwdWJsaWMgcmVjdERlc3RpbmF0aW9uOiBSZWN0YW5nbGU7XHJcblxyXG4gICAgLy8gVE9ETzogdmVyaWZ5IGlmIGNsaWVudCB0byBjYW52YXMgc2hvdWxkIGJlIGluIFZpZXdwb3J0IG9yIHNvbWV3aGVyZSBlbHNlIChXaW5kb3csIENvbnRhaW5lcj8pXHJcbiAgICAvLyBNdWx0aXBsZSB2aWV3cG9ydHMgdXNpbmcgdGhlIHNhbWUgY2FudmFzIHNob3VsZG4ndCBkaWZmZXIgaGVyZS4uLlxyXG4gICAgLy8gZGlmZmVyZW50IGZyYW1pbmcgbWV0aG9kcyBjYW4gYmUgdXNlZCwgdGhpcyBpcyB0aGUgZGVmYXVsdFxyXG4gICAgcHVibGljIGZyYW1lQ2xpZW50VG9DYW52YXM6IEZyYW1pbmdTY2FsZWQgPSBuZXcgRnJhbWluZ1NjYWxlZCgpO1xyXG4gICAgcHVibGljIGZyYW1lQ2FudmFzVG9EZXN0aW5hdGlvbjogRnJhbWluZ0NvbXBsZXggPSBuZXcgRnJhbWluZ0NvbXBsZXgoKTtcclxuICAgIHB1YmxpYyBmcmFtZURlc3RpbmF0aW9uVG9Tb3VyY2U6IEZyYW1pbmdTY2FsZWQgPSBuZXcgRnJhbWluZ1NjYWxlZCgpO1xyXG4gICAgcHVibGljIGZyYW1lU291cmNlVG9SZW5kZXI6IEZyYW1pbmdTY2FsZWQgPSBuZXcgRnJhbWluZ1NjYWxlZCgpO1xyXG5cclxuICAgIHB1YmxpYyBhZGp1c3RpbmdGcmFtZXM6IGJvb2xlYW4gPSB0cnVlO1xyXG4gICAgcHVibGljIGFkanVzdGluZ0NhbWVyYTogYm9vbGVhbiA9IHRydWU7XHJcblxyXG5cclxuICAgIHByaXZhdGUgZ3JhcGg6IE5vZGUgPSBudWxsOyAvLyBUaGUgZmlyc3Qgbm9kZSBpbiB0aGUgZ3JhcGggdGhhdCB3aWxsIGJlIHJlbmRlcmVkLlxyXG4gICAgcHJpdmF0ZSBjcmMyOiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgPSBudWxsO1xyXG4gICAgcHJpdmF0ZSBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50ID0gbnVsbDtcclxuICAgIHByaXZhdGUgcGlja0J1ZmZlcnM6IFBpY2tCdWZmZXJbXSA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29ubmVjdHMgdGhlIHZpZXdwb3J0IHRvIHRoZSBnaXZlbiBjYW52YXMgdG8gcmVuZGVyIHRoZSBnaXZlbiBncmFwaCB0byB1c2luZyB0aGUgZ2l2ZW4gY2FtZXJhLWNvbXBvbmVudCwgYW5kIG5hbWVzIHRoZSB2aWV3cG9ydCBhcyBnaXZlbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGluaXRpYWxpemUoX25hbWU6IHN0cmluZywgX2dyYXBoOiBOb2RlLCBfY2FtZXJhOiBDb21wb25lbnRDYW1lcmEsIF9jYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KTogdm9pZCB7XHJcbiAgICAgIHRoaXMubmFtZSA9IF9uYW1lO1xyXG4gICAgICB0aGlzLmNhbWVyYSA9IF9jYW1lcmE7XHJcbiAgICAgIHRoaXMuY2FudmFzID0gX2NhbnZhcztcclxuICAgICAgdGhpcy5jcmMyID0gX2NhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcblxyXG4gICAgICB0aGlzLnJlY3RTb3VyY2UgPSBSZW5kZXJNYW5hZ2VyLmdldENhbnZhc1JlY3QoKTtcclxuICAgICAgdGhpcy5yZWN0RGVzdGluYXRpb24gPSB0aGlzLmdldENsaWVudFJlY3RhbmdsZSgpO1xyXG5cclxuICAgICAgdGhpcy5zZXRHcmFwaChfZ3JhcGgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZSB0aGUgMkQtY29udGV4dCBhdHRhY2hlZCB0byB0aGUgZGVzdGluYXRpb24gY2FudmFzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRDb250ZXh0KCk6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNyYzI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlIHRoZSBzaXplIG9mIHRoZSBkZXN0aW5hdGlvbiBjYW52YXMgYXMgYSByZWN0YW5nbGUsIHggYW5kIHkgYXJlIGFsd2F5cyAwIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Q2FudmFzUmVjdGFuZ2xlKCk6IFJlY3RhbmdsZSB7XHJcbiAgICAgIHJldHVybiBSZWN0YW5nbGUuR0VUKDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZSB0aGUgY2xpZW50IHJlY3RhbmdsZSB0aGUgY2FudmFzIGlzIGRpc3BsYXllZCBhbmQgZml0IGluLCB4IGFuZCB5IGFyZSBhbHdheXMgMCBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldENsaWVudFJlY3RhbmdsZSgpOiBSZWN0YW5nbGUge1xyXG4gICAgICAvLyBGVURHRSBkb2Vzbid0IGNhcmUgYWJvdXQgd2hlcmUgdGhlIGNsaWVudCByZWN0IGlzLCBvbmx5IGFib3V0IHRoZSBzaXplIG1hdHRlcnMuXHJcbiAgICAgIC8vIHJldHVybiBSZWN0YW5nbGUuR0VUKHRoaXMuY2FudmFzLm9mZnNldExlZnQsIHRoaXMuY2FudmFzLm9mZnNldFRvcCwgdGhpcy5jYW52YXMuY2xpZW50V2lkdGgsIHRoaXMuY2FudmFzLmNsaWVudEhlaWdodCk7XHJcbiAgICAgIHJldHVybiBSZWN0YW5nbGUuR0VUKDAsIDAsIHRoaXMuY2FudmFzLmNsaWVudFdpZHRoLCB0aGlzLmNhbnZhcy5jbGllbnRIZWlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBncmFwaCB0byBiZSBkcmF3biBpbiB0aGUgdmlld3BvcnQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRHcmFwaChfZ3JhcGg6IE5vZGUpOiB2b2lkIHtcclxuICAgICAgaWYgKHRoaXMuZ3JhcGgpIHtcclxuICAgICAgICB0aGlzLmdyYXBoLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlQuQ09NUE9ORU5UX0FERCwgdGhpcy5obmRDb21wb25lbnRFdmVudCk7XHJcbiAgICAgICAgdGhpcy5ncmFwaC5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5ULkNPTVBPTkVOVF9SRU1PVkUsIHRoaXMuaG5kQ29tcG9uZW50RXZlbnQpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuZ3JhcGggPSBfZ3JhcGg7XHJcbiAgICAgIGlmICh0aGlzLmdyYXBoKSB7XHJcbiAgICAgICAgdGhpcy5ncmFwaC5hZGRFdmVudExpc3RlbmVyKEVWRU5ULkNPTVBPTkVOVF9BREQsIHRoaXMuaG5kQ29tcG9uZW50RXZlbnQpO1xyXG4gICAgICAgIHRoaXMuZ3JhcGguYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5DT01QT05FTlRfUkVNT1ZFLCB0aGlzLmhuZENvbXBvbmVudEV2ZW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRHcmFwaCgpOiBOb2RlIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ3JhcGg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2dzIHRoaXMgdmlld3BvcnRzIHNjZW5lZ3JhcGggdG8gdGhlIGNvbnNvbGUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzaG93U2NlbmVHcmFwaCgpOiB2b2lkIHtcclxuICAgICAgLy8gVE9ETzogbW92ZSB0byBkZWJ1Zy1jbGFzc1xyXG4gICAgICBsZXQgb3V0cHV0OiBzdHJpbmcgPSBcIlNjZW5lR3JhcGggZm9yIHRoaXMgdmlld3BvcnQ6XCI7XHJcbiAgICAgIG91dHB1dCArPSBcIlxcbiBcXG5cIjtcclxuICAgICAgb3V0cHV0ICs9IHRoaXMuZ3JhcGgubmFtZTtcclxuICAgICAgRGVidWcubG9nKG91dHB1dCArIFwiICAgPT4gUk9PVE5PREVcIiArIHRoaXMuY3JlYXRlU2NlbmVHcmFwaCh0aGlzLmdyYXBoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gI3JlZ2lvbiBEcmF3aW5nXHJcbiAgICAvKipcclxuICAgICAqIERyYXcgdGhpcyB2aWV3cG9ydFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZHJhdygpOiB2b2lkIHtcclxuICAgICAgUmVuZGVyTWFuYWdlci5yZXNldEZyYW1lQnVmZmVyKCk7XHJcbiAgICAgIGlmICghdGhpcy5jYW1lcmEuaXNBY3RpdmUpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBpZiAodGhpcy5hZGp1c3RpbmdGcmFtZXMpXHJcbiAgICAgICAgdGhpcy5hZGp1c3RGcmFtZXMoKTtcclxuICAgICAgaWYgKHRoaXMuYWRqdXN0aW5nQ2FtZXJhKVxyXG4gICAgICAgIHRoaXMuYWRqdXN0Q2FtZXJhKCk7XHJcblxyXG4gICAgICBSZW5kZXJNYW5hZ2VyLmNsZWFyKHRoaXMuY2FtZXJhLmJhY2tncm91bmRDb2xvcik7XHJcbiAgICAgIFJlbmRlck1hbmFnZXIuZHJhd0dyYXBoKHRoaXMuZ3JhcGgsIHRoaXMuY2FtZXJhKTtcclxuXHJcbiAgICAgIHRoaXMuY3JjMi5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgdGhpcy5jcmMyLmRyYXdJbWFnZShcclxuICAgICAgICBSZW5kZXJNYW5hZ2VyLmdldENhbnZhcygpLFxyXG4gICAgICAgIHRoaXMucmVjdFNvdXJjZS54LCB0aGlzLnJlY3RTb3VyY2UueSwgdGhpcy5yZWN0U291cmNlLndpZHRoLCB0aGlzLnJlY3RTb3VyY2UuaGVpZ2h0LFxyXG4gICAgICAgIHRoaXMucmVjdERlc3RpbmF0aW9uLngsIHRoaXMucmVjdERlc3RpbmF0aW9uLnksIHRoaXMucmVjdERlc3RpbmF0aW9uLndpZHRoLCB0aGlzLnJlY3REZXN0aW5hdGlvbi5oZWlnaHRcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogRHJhdyB0aGlzIHZpZXdwb3J0IGZvciBSYXlDYXN0XHJcbiAgICAqL1xyXG4gICAgcHVibGljIGNyZWF0ZVBpY2tCdWZmZXJzKCk6IHZvaWQge1xyXG4gICAgICBpZiAodGhpcy5hZGp1c3RpbmdGcmFtZXMpXHJcbiAgICAgICAgdGhpcy5hZGp1c3RGcmFtZXMoKTtcclxuICAgICAgaWYgKHRoaXMuYWRqdXN0aW5nQ2FtZXJhKVxyXG4gICAgICAgIHRoaXMuYWRqdXN0Q2FtZXJhKCk7XHJcbiAgICAgIHRoaXMucGlja0J1ZmZlcnMgPSBSZW5kZXJNYW5hZ2VyLmRyYXdHcmFwaEZvclJheUNhc3QodGhpcy5ncmFwaCwgdGhpcy5jYW1lcmEpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgcGlja05vZGVBdChfcG9zOiBWZWN0b3IyKTogUmF5SGl0W10ge1xyXG4gICAgICAvLyB0aGlzLmNyZWF0ZVBpY2tCdWZmZXJzKCk7XHJcbiAgICAgIGxldCBoaXRzOiBSYXlIaXRbXSA9IFJlbmRlck1hbmFnZXIucGlja05vZGVBdChfcG9zLCB0aGlzLnBpY2tCdWZmZXJzLCB0aGlzLnJlY3RTb3VyY2UpO1xyXG4gICAgICBoaXRzLnNvcnQoKGE6IFJheUhpdCwgYjogUmF5SGl0KSA9PiAoYi56QnVmZmVyID4gMCkgPyAoYS56QnVmZmVyID4gMCkgPyBhLnpCdWZmZXIgLSBiLnpCdWZmZXIgOiAxIDogLTEpO1xyXG4gICAgICByZXR1cm4gaGl0cztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkanVzdCBhbGwgZnJhbWVzIGludm9sdmVkIGluIHRoZSByZW5kZXJpbmcgcHJvY2VzcyBmcm9tIHRoZSBkaXNwbGF5IGFyZWEgaW4gdGhlIGNsaWVudCB1cCB0byB0aGUgcmVuZGVyZXIgY2FudmFzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhZGp1c3RGcmFtZXMoKTogdm9pZCB7XHJcbiAgICAgIC8vIGdldCB0aGUgcmVjdGFuZ2xlIG9mIHRoZSBjYW52YXMgYXJlYSBhcyBkaXNwbGF5ZWQgKGNvbnNpZGVyIGNzcylcclxuICAgICAgbGV0IHJlY3RDbGllbnQ6IFJlY3RhbmdsZSA9IHRoaXMuZ2V0Q2xpZW50UmVjdGFuZ2xlKCk7XHJcbiAgICAgIC8vIGFkanVzdCB0aGUgY2FudmFzIHNpemUgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBmcmFtaW5nIGFwcGxpZWQgdG8gY2xpZW50XHJcbiAgICAgIGxldCByZWN0Q2FudmFzOiBSZWN0YW5nbGUgPSB0aGlzLmZyYW1lQ2xpZW50VG9DYW52YXMuZ2V0UmVjdChyZWN0Q2xpZW50KTtcclxuICAgICAgdGhpcy5jYW52YXMud2lkdGggPSByZWN0Q2FudmFzLndpZHRoO1xyXG4gICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSByZWN0Q2FudmFzLmhlaWdodDtcclxuICAgICAgLy8gYWRqdXN0IHRoZSBkZXN0aW5hdGlvbiBhcmVhIG9uIHRoZSB0YXJnZXQtY2FudmFzIHRvIHJlbmRlciB0byBieSBhcHBseWluZyB0aGUgZnJhbWluZyB0byBjYW52YXNcclxuICAgICAgdGhpcy5yZWN0RGVzdGluYXRpb24gPSB0aGlzLmZyYW1lQ2FudmFzVG9EZXN0aW5hdGlvbi5nZXRSZWN0KHJlY3RDYW52YXMpO1xyXG4gICAgICAvLyBhZGp1c3QgdGhlIGFyZWEgb24gdGhlIHNvdXJjZS1jYW52YXMgdG8gcmVuZGVyIGZyb20gYnkgYXBwbHlpbmcgdGhlIGZyYW1pbmcgdG8gZGVzdGluYXRpb24gYXJlYVxyXG4gICAgICB0aGlzLnJlY3RTb3VyY2UgPSB0aGlzLmZyYW1lRGVzdGluYXRpb25Ub1NvdXJjZS5nZXRSZWN0KHRoaXMucmVjdERlc3RpbmF0aW9uKTtcclxuICAgICAgLy8gaGF2aW5nIGFuIG9mZnNldCBzb3VyY2UgZG9lcyBtYWtlIHNlbnNlIG9ubHkgd2hlbiBtdWx0aXBsZSB2aWV3cG9ydHMgZGlzcGxheSBwYXJ0cyBvZiB0aGUgc2FtZSByZW5kZXJpbmcuIEZvciBub3c6IHNoaWZ0IGl0IHRvIDAsMFxyXG4gICAgICB0aGlzLnJlY3RTb3VyY2UueCA9IHRoaXMucmVjdFNvdXJjZS55ID0gMDtcclxuICAgICAgLy8gc3RpbGwsIGEgcGFydGlhbCBpbWFnZSBvZiB0aGUgcmVuZGVyaW5nIG1heSBiZSByZXRyaWV2ZWQgYnkgbW92aW5nIGFuZCByZXNpemluZyB0aGUgcmVuZGVyIHZpZXdwb3J0XHJcbiAgICAgIGxldCByZWN0UmVuZGVyOiBSZWN0YW5nbGUgPSB0aGlzLmZyYW1lU291cmNlVG9SZW5kZXIuZ2V0UmVjdCh0aGlzLnJlY3RTb3VyY2UpO1xyXG4gICAgICBSZW5kZXJNYW5hZ2VyLnNldFZpZXdwb3J0UmVjdGFuZ2xlKHJlY3RSZW5kZXIpO1xyXG4gICAgICAvLyBubyBtb3JlIHRyYW5zZm9ybWF0aW9uIGFmdGVyIHRoaXMgZm9yIG5vdywgb2Zmc2NyZWVuIGNhbnZhcyBhbmQgcmVuZGVyLXZpZXdwb3J0IGhhdmUgdGhlIHNhbWUgc2l6ZVxyXG4gICAgICBSZW5kZXJNYW5hZ2VyLnNldENhbnZhc1NpemUocmVjdFJlbmRlci53aWR0aCwgcmVjdFJlbmRlci5oZWlnaHQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGp1c3QgdGhlIGNhbWVyYSBwYXJhbWV0ZXJzIHRvIGZpdCB0aGUgcmVuZGVyaW5nIGludG8gdGhlIHJlbmRlciB2aWVwb3J0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhZGp1c3RDYW1lcmEoKTogdm9pZCB7XHJcbiAgICAgIGxldCByZWN0OiBSZWN0YW5nbGUgPSBSZW5kZXJNYW5hZ2VyLmdldFZpZXdwb3J0UmVjdGFuZ2xlKCk7XHJcbiAgICAgIHRoaXMuY2FtZXJhLnByb2plY3RDZW50cmFsKHJlY3Qud2lkdGggLyByZWN0LmhlaWdodCwgdGhpcy5jYW1lcmEuZ2V0RmllbGRPZlZpZXcoKSk7XHJcbiAgICB9XHJcbiAgICAvLyAjZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIFBvaW50c1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgW1tSYXldXSBpbiB3b3JsZCBjb29yZGluYXRlcyBmcm9tIHRoaXMgY2FtZXJhIHRocm91Z2ggdGhlIHBvaW50IGdpdmVuIGluIGNsaWVudCBzcGFjZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0UmF5RnJvbUNsaWVudChfcG9pbnQ6IFZlY3RvcjIpOiBSYXkge1xyXG4gICAgICBsZXQgcG9zUHJvamVjdGlvbjogVmVjdG9yMiA9IHRoaXMucG9pbnRDbGllbnRUb1Byb2plY3Rpb24oX3BvaW50KTtcclxuICAgICAgbGV0IHJheTogUmF5ID0gbmV3IFJheShuZXcgVmVjdG9yMygtcG9zUHJvamVjdGlvbi54LCBwb3NQcm9qZWN0aW9uLnksIDEpKTtcclxuXHJcbiAgICAgIC8vIHJheS5kaXJlY3Rpb24uc2NhbGUoY2FtZXJhLmRpc3RhbmNlKTtcclxuICAgICAgcmF5Lm9yaWdpbi50cmFuc2Zvcm0odGhpcy5jYW1lcmEucGl2b3QpO1xyXG4gICAgICByYXkuZGlyZWN0aW9uLnRyYW5zZm9ybSh0aGlzLmNhbWVyYS5waXZvdCwgZmFsc2UpO1xyXG4gICAgICBsZXQgY2FtZXJhTm9kZTogTm9kZSA9IHRoaXMuY2FtZXJhLmdldENvbnRhaW5lcigpXHJcbiAgICAgIGlmIChjYW1lcmFOb2RlKSB7XHJcbiAgICAgICAgcmF5Lm9yaWdpbi50cmFuc2Zvcm0oY2FtZXJhTm9kZS5tdHhXb3JsZCk7XHJcbiAgICAgICAgcmF5LmRpcmVjdGlvbi50cmFuc2Zvcm0oY2FtZXJhTm9kZS5tdHhXb3JsZCwgZmFsc2UpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByYXk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHBvaW50V29ybGRUb0NsaWVudChfcG9zaXRpb246IFZlY3RvcjMpOiBWZWN0b3IyIHtcclxuICAgICAgbGV0IHByb2plY3Rpb246IFZlY3RvcjMgPSB0aGlzLmNhbWVyYS5wcm9qZWN0KF9wb3NpdGlvbik7XHJcbiAgICAgIGxldCBwb3NDbGllbnQ6IFZlY3RvcjIgPSB0aGlzLnBvaW50Q2xpcFRvQ2xpZW50KHByb2plY3Rpb24udG9WZWN0b3IyKCkpO1xyXG4gICAgICByZXR1cm4gcG9zQ2xpZW50O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHBvaW50IG9uIHRoZSBzb3VyY2UtcmVjdGFuZ2xlIG1hdGNoaW5nIHRoZSBnaXZlbiBwb2ludCBvbiB0aGUgY2xpZW50IHJlY3RhbmdsZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcG9pbnRDbGllbnRUb1NvdXJjZShfY2xpZW50OiBWZWN0b3IyKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjIgPSB0aGlzLmZyYW1lQ2xpZW50VG9DYW52YXMuZ2V0UG9pbnQoX2NsaWVudCwgdGhpcy5nZXRDbGllbnRSZWN0YW5nbGUoKSk7XHJcbiAgICAgIHJlc3VsdCA9IHRoaXMuZnJhbWVDYW52YXNUb0Rlc3RpbmF0aW9uLmdldFBvaW50KHJlc3VsdCwgdGhpcy5nZXRDYW52YXNSZWN0YW5nbGUoKSk7XHJcbiAgICAgIHJlc3VsdCA9IHRoaXMuZnJhbWVEZXN0aW5hdGlvblRvU291cmNlLmdldFBvaW50KHJlc3VsdCwgdGhpcy5yZWN0U291cmNlKTtcclxuICAgICAgLy9UT0RPOiB3aGVuIFNvdXJjZSwgUmVuZGVyIGFuZCBSZW5kZXJWaWV3cG9ydCBkZXZpYXRlLCBjb250aW51ZSB0cmFuc2Zvcm1hdGlvbiBcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHBvaW50IG9uIHRoZSByZW5kZXItcmVjdGFuZ2xlIG1hdGNoaW5nIHRoZSBnaXZlbiBwb2ludCBvbiB0aGUgc291cmNlIHJlY3RhbmdsZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcG9pbnRTb3VyY2VUb1JlbmRlcihfc291cmNlOiBWZWN0b3IyKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCBwcm9qZWN0aW9uUmVjdGFuZ2xlOiBSZWN0YW5nbGUgPSB0aGlzLmNhbWVyYS5nZXRQcm9qZWN0aW9uUmVjdGFuZ2xlKCk7XHJcbiAgICAgIGxldCBwb2ludDogVmVjdG9yMiA9IHRoaXMuZnJhbWVTb3VyY2VUb1JlbmRlci5nZXRQb2ludChfc291cmNlLCBwcm9qZWN0aW9uUmVjdGFuZ2xlKTtcclxuICAgICAgcmV0dXJuIHBvaW50O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHBvaW50IG9uIHRoZSByZW5kZXItcmVjdGFuZ2xlIG1hdGNoaW5nIHRoZSBnaXZlbiBwb2ludCBvbiB0aGUgY2xpZW50IHJlY3RhbmdsZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcG9pbnRDbGllbnRUb1JlbmRlcihfY2xpZW50OiBWZWN0b3IyKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCBwb2ludDogVmVjdG9yMiA9IHRoaXMucG9pbnRDbGllbnRUb1NvdXJjZShfY2xpZW50KTtcclxuICAgICAgcG9pbnQgPSB0aGlzLnBvaW50U291cmNlVG9SZW5kZXIocG9pbnQpO1xyXG4gICAgICAvL1RPRE86IHdoZW4gUmVuZGVyIGFuZCBSZW5kZXJWaWV3cG9ydCBkZXZpYXRlLCBjb250aW51ZSB0cmFuc2Zvcm1hdGlvbiBcclxuICAgICAgcmV0dXJuIHBvaW50O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHBvaW50IGluIG5vcm1lZCB2aWV3LXJlY3RhbmdsZSBtYXRjaGluZyB0aGUgZ2l2ZW4gcG9pbnQgb24gdGhlIGNsaWVudCByZWN0YW5nbGVcclxuICAgICAqIFRoZSB2aWV3LXJlY3RhbmdsZSBtYXRjaGVzIHRoZSBjbGllbnQgc2l6ZSBpbiB0aGUgaHlwb3RoZXRpY2FsIGRpc3RhbmNlIG9mIDEgdG8gdGhlIGNhbWVyYSwgaXRzIG9yaWdpbiBpbiB0aGUgY2VudGVyIGFuZCB5LWF4aXMgcG9pbnRpbmcgdXBcclxuICAgICAqIFRPRE86IGV4YW1pbmUsIGlmIHRoaXMgc2hvdWxkIGJlIGEgY2FtZXJhLW1ldGhvZC4gQ3VycmVudCBpbXBsZW1lbnRhdGlvbiBpcyBmb3IgY2VudHJhbC1wcm9qZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwb2ludENsaWVudFRvUHJvamVjdGlvbihfY2xpZW50OiBWZWN0b3IyKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCBwb3NSZW5kZXI6IFZlY3RvcjIgPSB0aGlzLnBvaW50Q2xpZW50VG9SZW5kZXIoX2NsaWVudCk7XHJcbiAgICAgIGxldCByZWN0UmVuZGVyOiBSZWN0YW5nbGUgPSB0aGlzLmZyYW1lU291cmNlVG9SZW5kZXIuZ2V0UmVjdCh0aGlzLnJlY3RTb3VyY2UpO1xyXG4gICAgICBsZXQgcmVjdFByb2plY3Rpb246IFJlY3RhbmdsZSA9IHRoaXMuY2FtZXJhLmdldFByb2plY3Rpb25SZWN0YW5nbGUoKTtcclxuXHJcbiAgICAgIGxldCBwb3NQcm9qZWN0aW9uOiBWZWN0b3IyID0gbmV3IFZlY3RvcjIoXHJcbiAgICAgICAgcmVjdFByb2plY3Rpb24ud2lkdGggKiBwb3NSZW5kZXIueCAvIHJlY3RSZW5kZXIud2lkdGgsXHJcbiAgICAgICAgcmVjdFByb2plY3Rpb24uaGVpZ2h0ICogcG9zUmVuZGVyLnkgLyByZWN0UmVuZGVyLmhlaWdodFxyXG4gICAgICApO1xyXG5cclxuICAgICAgcG9zUHJvamVjdGlvbi5zdWJ0cmFjdChuZXcgVmVjdG9yMihyZWN0UHJvamVjdGlvbi53aWR0aCAvIDIsIHJlY3RQcm9qZWN0aW9uLmhlaWdodCAvIDIpKTtcclxuICAgICAgcG9zUHJvamVjdGlvbi55ICo9IC0xO1xyXG5cclxuICAgICAgcmV0dXJuIHBvc1Byb2plY3Rpb247XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcG9pbnQgaW4gdGhlIGNsaWVudCByZWN0YW5nbGUgbWF0Y2hpbmcgdGhlIGdpdmVuIHBvaW50IGluIG5vcm1lZCBjbGlwc3BhY2UgcmVjdGFuZ2xlLCBcclxuICAgICAqIHdoaWNoIHN0cmV0Y2hlcyBmcm9tIC0xIHRvIDEgaW4gYm90aCBkaW1lbnNpb25zLCB5IHBvaW50aW5nIHVwXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwb2ludENsaXBUb0NsaWVudChfbm9ybWVkOiBWZWN0b3IyKTogVmVjdG9yMiB7XHJcbiAgICAgIC8vIGxldCByZWN0Q2xpZW50OiBSZWN0YW5nbGUgPSB0aGlzLmdldENsaWVudFJlY3RhbmdsZSgpO1xyXG4gICAgICAvLyBsZXQgcmVzdWx0OiBWZWN0b3IyID0gVmVjdG9yMi5PTkUoMC41KTtcclxuICAgICAgLy8gcmVzdWx0LnggKj0gKF9ub3JtZWQueCArIDEpICogcmVjdENsaWVudC53aWR0aDtcclxuICAgICAgLy8gcmVzdWx0LnkgKj0gKDEgLSBfbm9ybWVkLnkpICogcmVjdENsaWVudC5oZWlnaHQ7XHJcbiAgICAgIC8vIHJlc3VsdC5hZGQocmVjdENsaWVudC5wb3NpdGlvbik7XHJcbiAgICAgIC8vVE9ETzogY2hlY2sgaWYgcmVjdERlc3RpbmF0aW9uIGNhbiBiZSBzYWZlbHkgKGFuZCBtb3JlIHBlcmZvbWFudCkgYmUgdXNlZCBpbnN0ZWFkIGdldENsaWVudFJlY3RhbmdsZVxyXG4gICAgICBsZXQgcG9pbnRDbGllbnQ6IFZlY3RvcjIgPSBSZW5kZXJNYW5hZ2VyLnJlY3RDbGlwLnBvaW50VG9SZWN0KF9ub3JtZWQsIHRoaXMucmVjdERlc3RpbmF0aW9uKTtcclxuICAgICAgcmV0dXJuIHBvaW50Q2xpZW50O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcG9pbnQgaW4gdGhlIGNsaWVudCByZWN0YW5nbGUgbWF0Y2hpbmcgdGhlIGdpdmVuIHBvaW50IGluIG5vcm1lZCBjbGlwc3BhY2UgcmVjdGFuZ2xlLCBcclxuICAgICAqIHdoaWNoIHN0cmV0Y2hlcyBmcm9tIC0xIHRvIDEgaW4gYm90aCBkaW1lbnNpb25zLCB5IHBvaW50aW5nIHVwXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwb2ludENsaXBUb0NhbnZhcyhfbm9ybWVkOiBWZWN0b3IyKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCBwb2ludENhbnZhczogVmVjdG9yMiA9IFJlbmRlck1hbmFnZXIucmVjdENsaXAucG9pbnRUb1JlY3QoX25vcm1lZCwgdGhpcy5nZXRDYW52YXNSZWN0YW5nbGUoKSk7XHJcbiAgICAgIHJldHVybiBwb2ludENhbnZhcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcG9pbnRDbGllbnRUb1NjcmVlbihfY2xpZW50OiBWZWN0b3IyKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCBzY3JlZW46IFZlY3RvcjIgPSBuZXcgVmVjdG9yMih0aGlzLmNhbnZhcy5vZmZzZXRMZWZ0ICsgX2NsaWVudC54LCB0aGlzLmNhbnZhcy5vZmZzZXRUb3AgKyBfY2xpZW50LnkpO1xyXG4gICAgICByZXR1cm4gc2NyZWVuO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8gI3JlZ2lvbiBFdmVudHMgKHBhc3NpbmcgZnJvbSBjYW52YXMgdG8gdmlld3BvcnQgYW5kIGZyb20gdGhlcmUgaW50byBncmFwaClcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgdmlld3BvcnQgY3VycmVudGx5IGhhcyBmb2N1cyBhbmQgdGh1cyByZWNlaXZlcyBrZXlib2FyZCBldmVudHNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBoYXNGb2N1cygpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIChWaWV3cG9ydC5mb2N1cyA9PSB0aGlzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3dpdGNoIHRoZSB2aWV3cG9ydHMgZm9jdXMgb24gb3Igb2ZmLiBPbmx5IG9uZSB2aWV3cG9ydCBpbiBvbmUgRlVER0UgaW5zdGFuY2UgY2FuIGhhdmUgdGhlIGZvY3VzLCB0aHVzIHJlY2VpdmluZyBrZXlib2FyZCBldmVudHMuIFxyXG4gICAgICogU28gYSB2aWV3cG9ydCBjdXJyZW50bHkgaGF2aW5nIHRoZSBmb2N1cyB3aWxsIGxvc2UgaXQsIHdoZW4gYW5vdGhlciBvbmUgcmVjZWl2ZXMgaXQuIFRoZSB2aWV3cG9ydHMgZmlyZSBbW0V2ZW50XV1zIGFjY29yZGluZ2x5LlxyXG4gICAgICogIFxyXG4gICAgICogQHBhcmFtIF9vbiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldEZvY3VzKF9vbjogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICBpZiAoX29uKSB7XHJcbiAgICAgICAgaWYgKFZpZXdwb3J0LmZvY3VzID09IHRoaXMpXHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgaWYgKFZpZXdwb3J0LmZvY3VzKVxyXG4gICAgICAgICAgVmlld3BvcnQuZm9jdXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuRk9DVVNfT1VUKSk7XHJcbiAgICAgICAgVmlld3BvcnQuZm9jdXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuRk9DVVNfSU4pKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBpZiAoVmlld3BvcnQuZm9jdXMgIT0gdGhpcylcclxuICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVC5GT0NVU19PVVQpKTtcclxuICAgICAgICBWaWV3cG9ydC5mb2N1cyA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGUtIC8gQWN0aXZhdGVzIHRoZSBnaXZlbiBwb2ludGVyIGV2ZW50IHRvIGJlIHByb3BhZ2F0ZWQgaW50byB0aGUgdmlld3BvcnQgYXMgRlVER0UtRXZlbnQgXHJcbiAgICAgKiBAcGFyYW0gX3R5cGUgXHJcbiAgICAgKiBAcGFyYW0gX29uIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWN0aXZhdGVQb2ludGVyRXZlbnQoX3R5cGU6IEVWRU5UX1BPSU5URVIsIF9vbjogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICB0aGlzLmFjdGl2YXRlRXZlbnQodGhpcy5jYW52YXMsIF90eXBlLCB0aGlzLmhuZFBvaW50ZXJFdmVudCwgX29uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGUtIC8gQWN0aXZhdGVzIHRoZSBnaXZlbiBrZXlib2FyZCBldmVudCB0byBiZSBwcm9wYWdhdGVkIGludG8gdGhlIHZpZXdwb3J0IGFzIEZVREdFLUV2ZW50XHJcbiAgICAgKiBAcGFyYW0gX3R5cGUgXHJcbiAgICAgKiBAcGFyYW0gX29uIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWN0aXZhdGVLZXlib2FyZEV2ZW50KF90eXBlOiBFVkVOVF9LRVlCT0FSRCwgX29uOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuYWN0aXZhdGVFdmVudCh0aGlzLmNhbnZhcy5vd25lckRvY3VtZW50LCBfdHlwZSwgdGhpcy5obmRLZXlib2FyZEV2ZW50LCBfb24pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEZS0gLyBBY3RpdmF0ZXMgdGhlIGdpdmVuIGRyYWctZHJvcCBldmVudCB0byBiZSBwcm9wYWdhdGVkIGludG8gdGhlIHZpZXdwb3J0IGFzIEZVREdFLUV2ZW50XHJcbiAgICAgKiBAcGFyYW0gX3R5cGUgXHJcbiAgICAgKiBAcGFyYW0gX29uIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWN0aXZhdGVEcmFnRHJvcEV2ZW50KF90eXBlOiBFVkVOVF9EUkFHRFJPUCwgX29uOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgIGlmIChfdHlwZSA9PSBFVkVOVF9EUkFHRFJPUC5TVEFSVClcclxuICAgICAgICB0aGlzLmNhbnZhcy5kcmFnZ2FibGUgPSBfb247XHJcbiAgICAgIHRoaXMuYWN0aXZhdGVFdmVudCh0aGlzLmNhbnZhcywgX3R5cGUsIHRoaXMuaG5kRHJhZ0Ryb3BFdmVudCwgX29uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGUtIC8gQWN0aXZhdGVzIHRoZSB3aGVlbCBldmVudCB0byBiZSBwcm9wYWdhdGVkIGludG8gdGhlIHZpZXdwb3J0IGFzIEZVREdFLUV2ZW50XHJcbiAgICAgKiBAcGFyYW0gX3R5cGUgXHJcbiAgICAgKiBAcGFyYW0gX29uIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWN0aXZhdGVXaGVlbEV2ZW50KF90eXBlOiBFVkVOVF9XSEVFTCwgX29uOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuYWN0aXZhdGVFdmVudCh0aGlzLmNhbnZhcywgX3R5cGUsIHRoaXMuaG5kV2hlZWxFdmVudCwgX29uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlIGRyYWctZHJvcCBldmVudHMgYW5kIGRpc3BhdGNoIHRvIHZpZXdwb3J0IGFzIEZVREdFLUV2ZW50XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgaG5kRHJhZ0Ryb3BFdmVudDogRXZlbnRMaXN0ZW5lciA9IChfZXZlbnQ6IEV2ZW50KSA9PiB7XHJcbiAgICAgIGxldCBfZHJhZ2V2ZW50OiBFdmVudERyYWdEcm9wID0gPEV2ZW50RHJhZ0Ryb3A+X2V2ZW50O1xyXG4gICAgICBzd2l0Y2ggKF9kcmFnZXZlbnQudHlwZSkge1xyXG4gICAgICAgIGNhc2UgXCJkcmFnb3ZlclwiOlxyXG4gICAgICAgIGNhc2UgXCJkcm9wXCI6XHJcbiAgICAgICAgICBfZHJhZ2V2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICBfZHJhZ2V2ZW50LmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gXCJub25lXCI7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwiZHJhZ3N0YXJ0XCI6XHJcbiAgICAgICAgICAvLyBqdXN0IGR1bW15IGRhdGEsICB2YWxpZCBkYXRhIHNob3VsZCBiZSBzZXQgaW4gaGFuZGxlciByZWdpc3RlcmVkIGJ5IHRoZSB1c2VyXHJcbiAgICAgICAgICBfZHJhZ2V2ZW50LmRhdGFUcmFuc2Zlci5zZXREYXRhKFwidGV4dFwiLCBcIkhhbGxvXCIpO1xyXG4gICAgICAgICAgLy8gVE9ETzogY2hlY2sgaWYgdGhlcmUgaXMgYSBiZXR0ZXIgc29sdXRpb24gdG8gaGlkZSB0aGUgZ2hvc3QgaW1hZ2Ugb2YgdGhlIGRyYWdnYWJsZSBvYmplY3RcclxuICAgICAgICAgIF9kcmFnZXZlbnQuZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZShuZXcgSW1hZ2UoKSwgMCwgMCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBsZXQgZXZlbnQ6IEV2ZW50RHJhZ0Ryb3AgPSBuZXcgRXZlbnREcmFnRHJvcChcIsaSXCIgKyBfZXZlbnQudHlwZSwgX2RyYWdldmVudCk7XHJcbiAgICAgIHRoaXMuYWRkQ2FudmFzUG9zaXRpb24oZXZlbnQpO1xyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgcG9zaXRpb24gb2YgdGhlIHBvaW50ZXIgbWFwcGVkIHRvIGNhbnZhcy1jb29yZGluYXRlcyBhcyBjYW52YXNYLCBjYW52YXNZIHRvIHRoZSBldmVudFxyXG4gICAgICogQHBhcmFtIGV2ZW50XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYWRkQ2FudmFzUG9zaXRpb24oZXZlbnQ6IEV2ZW50UG9pbnRlciB8IEV2ZW50RHJhZ0Ryb3ApOiB2b2lkIHtcclxuICAgICAgZXZlbnQuY2FudmFzWCA9IHRoaXMuY2FudmFzLndpZHRoICogZXZlbnQucG9pbnRlclggLyBldmVudC5jbGllbnRSZWN0LndpZHRoO1xyXG4gICAgICBldmVudC5jYW52YXNZID0gdGhpcy5jYW52YXMuaGVpZ2h0ICogZXZlbnQucG9pbnRlclkgLyBldmVudC5jbGllbnRSZWN0LmhlaWdodDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlIHBvaW50ZXIgZXZlbnRzIGFuZCBkaXNwYXRjaCB0byB2aWV3cG9ydCBhcyBGVURHRS1FdmVudFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGhuZFBvaW50ZXJFdmVudDogRXZlbnRMaXN0ZW5lciA9IChfZXZlbnQ6IEV2ZW50KSA9PiB7XHJcbiAgICAgIGxldCBldmVudDogRXZlbnRQb2ludGVyID0gbmV3IEV2ZW50UG9pbnRlcihcIsaSXCIgKyBfZXZlbnQudHlwZSwgPEV2ZW50UG9pbnRlcj5fZXZlbnQpO1xyXG4gICAgICB0aGlzLmFkZENhbnZhc1Bvc2l0aW9uKGV2ZW50KTtcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlIGtleWJvYXJkIGV2ZW50cyBhbmQgZGlzcGF0Y2ggdG8gdmlld3BvcnQgYXMgRlVER0UtRXZlbnQsIGlmIHRoZSB2aWV3cG9ydCBoYXMgdGhlIGZvY3VzXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgaG5kS2V5Ym9hcmRFdmVudDogRXZlbnRMaXN0ZW5lciA9IChfZXZlbnQ6IEV2ZW50KSA9PiB7XHJcbiAgICAgIGlmICghdGhpcy5oYXNGb2N1cylcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIGxldCBldmVudDogRXZlbnRLZXlib2FyZCA9IG5ldyBFdmVudEtleWJvYXJkKFwixpJcIiArIF9ldmVudC50eXBlLCA8RXZlbnRLZXlib2FyZD5fZXZlbnQpO1xyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGUgd2hlZWwgZXZlbnQgYW5kIGRpc3BhdGNoIHRvIHZpZXdwb3J0IGFzIEZVREdFLUV2ZW50XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgaG5kV2hlZWxFdmVudDogRXZlbnRMaXN0ZW5lciA9IChfZXZlbnQ6IEV2ZW50KSA9PiB7XHJcbiAgICAgIGxldCBldmVudDogRXZlbnRXaGVlbCA9IG5ldyBFdmVudFdoZWVsKFwixpJcIiArIF9ldmVudC50eXBlLCA8RXZlbnRXaGVlbD5fZXZlbnQpO1xyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYWN0aXZhdGVFdmVudChfdGFyZ2V0OiBFdmVudFRhcmdldCwgX3R5cGU6IHN0cmluZywgX2hhbmRsZXI6IEV2ZW50TGlzdGVuZXIsIF9vbjogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICBfdHlwZSA9IF90eXBlLnNsaWNlKDEpOyAvLyBjaGlwIHRoZSDGkmxvcmVudGluXHJcbiAgICAgIGlmIChfb24pXHJcbiAgICAgICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKF90eXBlLCBfaGFuZGxlcik7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBfdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoX3R5cGUsIF9oYW5kbGVyKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGhuZENvbXBvbmVudEV2ZW50KF9ldmVudDogRXZlbnQpOiB2b2lkIHtcclxuICAgICAgRGVidWcuZnVkZ2UoX2V2ZW50KTtcclxuICAgIH1cclxuICAgIC8vICNlbmRyZWdpb25cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIG91dHB1dHN0cmluZyBhcyB2aXN1YWwgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2aWV3cG9ydHMgc2NlbmVncmFwaC4gQ2FsbGVkIGZvciB0aGUgcGFzc2VkIG5vZGUgYW5kIHJlY3Vyc2l2ZSBmb3IgYWxsIGl0cyBjaGlsZHJlbi5cclxuICAgICAqIEBwYXJhbSBfZnVkZ2VOb2RlIFRoZSBub2RlIHRvIGNyZWF0ZSBhIHNjZW5lZ3JhcGhlbnRyeSBmb3IuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY3JlYXRlU2NlbmVHcmFwaChfZnVkZ2VOb2RlOiBOb2RlKTogc3RyaW5nIHtcclxuICAgICAgLy8gVE9ETzogbW92ZSB0byBkZWJ1Zy1jbGFzc1xyXG4gICAgICBsZXQgb3V0cHV0OiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgICBmb3IgKGxldCBuYW1lIGluIF9mdWRnZU5vZGUuZ2V0Q2hpbGRyZW4oKSkge1xyXG4gICAgICAgIGxldCBjaGlsZDogTm9kZSA9IF9mdWRnZU5vZGUuZ2V0Q2hpbGRyZW4oKVtuYW1lXTtcclxuICAgICAgICBvdXRwdXQgKz0gXCJcXG5cIjtcclxuICAgICAgICBsZXQgY3VycmVudDogTm9kZSA9IGNoaWxkO1xyXG4gICAgICAgIGlmIChjdXJyZW50LmdldFBhcmVudCgpICYmIGN1cnJlbnQuZ2V0UGFyZW50KCkuZ2V0UGFyZW50KCkpXHJcbiAgICAgICAgICBvdXRwdXQgKz0gXCJ8XCI7XHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQuZ2V0UGFyZW50KCkgJiYgY3VycmVudC5nZXRQYXJlbnQoKS5nZXRQYXJlbnQoKSkge1xyXG4gICAgICAgICAgb3V0cHV0ICs9IFwiICAgXCI7XHJcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5nZXRQYXJlbnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgb3V0cHV0ICs9IFwiJy0tXCI7XHJcblxyXG4gICAgICAgIG91dHB1dCArPSBjaGlsZC5uYW1lO1xyXG4gICAgICAgIG91dHB1dCArPSB0aGlzLmNyZWF0ZVNjZW5lR3JhcGgoY2hpbGQpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gICAgZXhwb3J0IGNvbnN0IGVudW0gRVZFTlRfQVVESU8ge1xyXG4gICAgICAvKiogYnJvYWRjYXN0IHRvIGEgW1tOb2RlXV0gYW5kIGFsbCBpdHMgZGVzY2VuZGFudHMgaW4gdGhlIGdyYXBoIGFmdGVyIGl0IHdhcyBhcHBlbmRlZCB0byBhIHBhcmVudCAqL1xyXG4gICAgICBDSElMRF9BUFBFTkQgPSBcImNoaWxkQXBwZW5kVG9BdWRpb0dyYXBoXCIsXHJcbiAgICAgIC8qKiBicm9hZGNhc3QgdG8gYSBbW05vZGVdXSBhbmQgYWxsIGl0cyBkZXNjZW5kYW50cyBpbiB0aGUgZ3JhcGgganVzdCBiZWZvcmUgaXRzIGJlaW5nIHJlbW92ZWQgZnJvbSBpdHMgcGFyZW50ICovXHJcbiAgICAgIENISUxEX1JFTU9WRSA9IFwiY2hpbGRSZW1vdmVGcm9tQXVkaW9HcmFwaFwiLFxyXG4gICAgICAvKiogYnJvYWRjYXN0IHRvIGEgW1tOb2RlXV0gYW5kIGFsbCBpdHMgZGVzY2VuZGFudHMgaW4gdGhlIGdyYXBoIHRvIHVwZGF0ZSB0aGUgcGFubmVycyBpbiBBdWRpb0NvbXBvbmVudHMgKi9cclxuICAgICAgVVBEQVRFID0gXCJ1cGRhdGVBdWRpb0dyYXBoXCJcclxuICAgIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gICAgZXhwb3J0IGNvbnN0IGVudW0gRVZFTlRfRFJBR0RST1Age1xyXG4gICAgICAgIERSQUcgPSBcIsaSZHJhZ1wiLFxyXG4gICAgICAgIERST1AgPSBcIsaSZHJvcFwiLFxyXG4gICAgICAgIFNUQVJUID0gXCLGkmRyYWdzdGFydFwiLFxyXG4gICAgICAgIEVORCA9IFwixpJkcmFnZW5kXCIsXHJcbiAgICAgICAgT1ZFUiA9IFwixpJkcmFnb3ZlclwiXHJcbiAgICB9XHJcblxyXG4gICAgZXhwb3J0IGNsYXNzIEV2ZW50RHJhZ0Ryb3AgZXh0ZW5kcyBEcmFnRXZlbnQge1xyXG4gICAgICAgIHB1YmxpYyBwb2ludGVyWDogbnVtYmVyO1xyXG4gICAgICAgIHB1YmxpYyBwb2ludGVyWTogbnVtYmVyO1xyXG4gICAgICAgIHB1YmxpYyBjYW52YXNYOiBudW1iZXI7XHJcbiAgICAgICAgcHVibGljIGNhbnZhc1k6IG51bWJlcjtcclxuICAgICAgICBwdWJsaWMgY2xpZW50UmVjdDogQ2xpZW50UmVjdDtcclxuXHJcbiAgICAgICAgY29uc3RydWN0b3IodHlwZTogc3RyaW5nLCBfZXZlbnQ6IEV2ZW50RHJhZ0Ryb3ApIHtcclxuICAgICAgICAgICAgc3VwZXIodHlwZSwgX2V2ZW50KTtcclxuICAgICAgICAgICAgbGV0IHRhcmdldDogSFRNTEVsZW1lbnQgPSA8SFRNTEVsZW1lbnQ+X2V2ZW50LnRhcmdldDtcclxuICAgICAgICAgICAgdGhpcy5jbGllbnRSZWN0ID0gdGFyZ2V0LmdldENsaWVudFJlY3RzKClbMF07XHJcbiAgICAgICAgICAgIHRoaXMucG9pbnRlclggPSBfZXZlbnQuY2xpZW50WCAtIHRoaXMuY2xpZW50UmVjdC5sZWZ0O1xyXG4gICAgICAgICAgICB0aGlzLnBvaW50ZXJZID0gX2V2ZW50LmNsaWVudFkgLSB0aGlzLmNsaWVudFJlY3QudG9wO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gICAgZXhwb3J0IGNsYXNzIEV2ZW50S2V5Ym9hcmQgZXh0ZW5kcyBLZXlib2FyZEV2ZW50IHtcclxuICAgICAgICBjb25zdHJ1Y3Rvcih0eXBlOiBzdHJpbmcsIF9ldmVudDogRXZlbnRLZXlib2FyZCkge1xyXG4gICAgICAgICAgICBzdXBlcih0eXBlLCBfZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcHBpbmdzIG9mIHN0YW5kYXJkIERPTS9Ccm93c2VyLUV2ZW50cyBhcyBwYXNzZWQgZnJvbSBhIGNhbnZhcyB0byB0aGUgdmlld3BvcnRcclxuICAgICAqL1xyXG4gICAgZXhwb3J0IGNvbnN0IGVudW0gRVZFTlRfS0VZQk9BUkQge1xyXG4gICAgICAgIFVQID0gXCLGkmtleXVwXCIsXHJcbiAgICAgICAgRE9XTiA9IFwixpJrZXlkb3duXCIsXHJcbiAgICAgICAgUFJFU1MgPSBcIsaSa2V5cHJlc3NcIlxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGNvZGVzIHNlbnQgZnJvbSBhIHN0YW5kYXJkIGVuZ2xpc2gga2V5Ym9hcmQgbGF5b3V0XHJcbiAgICAgKi9cclxuICAgIGV4cG9ydCBlbnVtIEtFWUJPQVJEX0NPREUge1xyXG4gICAgICAgIEEgPSBcIktleUFcIixcclxuICAgICAgICBCID0gXCJLZXlCXCIsXHJcbiAgICAgICAgQyA9IFwiS2V5Q1wiLFxyXG4gICAgICAgIEQgPSBcIktleURcIixcclxuICAgICAgICBFID0gXCJLZXlFXCIsXHJcbiAgICAgICAgRiA9IFwiS2V5RlwiLFxyXG4gICAgICAgIEcgPSBcIktleUdcIixcclxuICAgICAgICBIID0gXCJLZXlIXCIsXHJcbiAgICAgICAgSSA9IFwiS2V5SVwiLFxyXG4gICAgICAgIEogPSBcIktleUpcIixcclxuICAgICAgICBLID0gXCJLZXlLXCIsXHJcbiAgICAgICAgTCA9IFwiS2V5TFwiLFxyXG4gICAgICAgIE0gPSBcIktleU1cIixcclxuICAgICAgICBOID0gXCJLZXlOXCIsXHJcbiAgICAgICAgTyA9IFwiS2V5T1wiLFxyXG4gICAgICAgIFAgPSBcIktleVBcIixcclxuICAgICAgICBRID0gXCJLZXlRXCIsXHJcbiAgICAgICAgUiA9IFwiS2V5UlwiLFxyXG4gICAgICAgIFMgPSBcIktleVNcIixcclxuICAgICAgICBUID0gXCJLZXlUXCIsXHJcbiAgICAgICAgVSA9IFwiS2V5VVwiLFxyXG4gICAgICAgIFYgPSBcIktleVZcIixcclxuICAgICAgICBXID0gXCJLZXlXXCIsXHJcbiAgICAgICAgWCA9IFwiS2V5WFwiLFxyXG4gICAgICAgIFkgPSBcIktleVlcIixcclxuICAgICAgICBaID0gXCJLZXlaXCIsXHJcbiAgICAgICAgRVNDID0gXCJFc2NhcGVcIixcclxuICAgICAgICBaRVJPID0gXCJEaWdpdDBcIixcclxuICAgICAgICBPTkUgPSBcIkRpZ2l0MVwiLFxyXG4gICAgICAgIFRXTyA9IFwiRGlnaXQyXCIsXHJcbiAgICAgICAgVEhSRUUgPSBcIkRpZ2l0M1wiLFxyXG4gICAgICAgIEZPVVIgPSBcIkRpZ2l0NFwiLFxyXG4gICAgICAgIEZJVkUgPSBcIkRpZ2l0NVwiLFxyXG4gICAgICAgIFNJWCA9IFwiRGlnaXQ2XCIsXHJcbiAgICAgICAgU0VWRU4gPSBcIkRpZ2l0N1wiLFxyXG4gICAgICAgIEVJR0hUID0gXCJEaWdpdDhcIixcclxuICAgICAgICBOSU5FID0gXCJEaWdpdDlcIixcclxuICAgICAgICBNSU5VUyA9IFwiTWludXNcIixcclxuICAgICAgICBFUVVBTCA9IFwiRXF1YWxcIixcclxuICAgICAgICBCQUNLU1BBQ0UgPSBcIkJhY2tzcGFjZVwiLFxyXG4gICAgICAgIFRBQlVMQVRPUiA9IFwiVGFiXCIsXHJcbiAgICAgICAgQlJBQ0tFVF9MRUZUID0gXCJCcmFja2V0TGVmdFwiLFxyXG4gICAgICAgIEJSQUNLRVRfUklHSFQgPSBcIkJyYWNrZXRSaWdodFwiLFxyXG4gICAgICAgIEVOVEVSID0gXCJFbnRlclwiLFxyXG4gICAgICAgIENUUkxfTEVGVCA9IFwiQ29udHJvbExlZnRcIixcclxuICAgICAgICBTRU1JQ09MT04gPSBcIlNlbWljb2xvblwiLFxyXG4gICAgICAgIFFVT1RFID0gXCJRdW90ZVwiLFxyXG4gICAgICAgIEJBQ0tfUVVPVEUgPSBcIkJhY2txdW90ZVwiLFxyXG4gICAgICAgIFNISUZUX0xFRlQgPSBcIlNoaWZ0TGVmdFwiLFxyXG4gICAgICAgIEJBQ0tTTEFTSCA9IFwiQmFja3NsYXNoXCIsXHJcbiAgICAgICAgQ09NTUEgPSBcIkNvbW1hXCIsXHJcbiAgICAgICAgUEVSSU9EID0gXCJQZXJpb2RcIixcclxuICAgICAgICBTTEFTSCA9IFwiU2xhc2hcIixcclxuICAgICAgICBTSElGVF9SSUdIVCA9IFwiU2hpZnRSaWdodFwiLFxyXG4gICAgICAgIE5VTVBBRF9NVUxUSVBMWSA9IFwiTnVtcGFkTXVsdGlwbHlcIixcclxuICAgICAgICBBTFRfTEVGVCA9IFwiQWx0TGVmdFwiLFxyXG4gICAgICAgIFNQQUNFID0gXCJTcGFjZVwiLFxyXG4gICAgICAgIENBUFNfTE9DSyA9IFwiQ2Fwc0xvY2tcIixcclxuICAgICAgICBGMSA9IFwiRjFcIixcclxuICAgICAgICBGMiA9IFwiRjJcIixcclxuICAgICAgICBGMyA9IFwiRjNcIixcclxuICAgICAgICBGNCA9IFwiRjRcIixcclxuICAgICAgICBGNSA9IFwiRjVcIixcclxuICAgICAgICBGNiA9IFwiRjZcIixcclxuICAgICAgICBGNyA9IFwiRjdcIixcclxuICAgICAgICBGOCA9IFwiRjhcIixcclxuICAgICAgICBGOSA9IFwiRjlcIixcclxuICAgICAgICBGMTAgPSBcIkYxMFwiLFxyXG4gICAgICAgIFBBVVNFID0gXCJQYXVzZVwiLFxyXG4gICAgICAgIFNDUk9MTF9MT0NLID0gXCJTY3JvbGxMb2NrXCIsXHJcbiAgICAgICAgTlVNUEFENyA9IFwiTnVtcGFkN1wiLFxyXG4gICAgICAgIE5VTVBBRDggPSBcIk51bXBhZDhcIixcclxuICAgICAgICBOVU1QQUQ5ID0gXCJOdW1wYWQ5XCIsXHJcbiAgICAgICAgTlVNUEFEX1NVQlRSQUNUID0gXCJOdW1wYWRTdWJ0cmFjdFwiLFxyXG4gICAgICAgIE5VTVBBRDQgPSBcIk51bXBhZDRcIixcclxuICAgICAgICBOVU1QQUQ1ID0gXCJOdW1wYWQ1XCIsXHJcbiAgICAgICAgTlVNUEFENiA9IFwiTnVtcGFkNlwiLFxyXG4gICAgICAgIE5VTVBBRF9BREQgPSBcIk51bXBhZEFkZFwiLFxyXG4gICAgICAgIE5VTVBBRDEgPSBcIk51bXBhZDFcIixcclxuICAgICAgICBOVU1QQUQyID0gXCJOdW1wYWQyXCIsXHJcbiAgICAgICAgTlVNUEFEMyA9IFwiTnVtcGFkM1wiLFxyXG4gICAgICAgIE5VTVBBRDAgPSBcIk51bXBhZDBcIixcclxuICAgICAgICBOVU1QQURfREVDSU1BTCA9IFwiTnVtcGFkRGVjaW1hbFwiLFxyXG4gICAgICAgIFBSSU5UX1NDUkVFTiA9IFwiUHJpbnRTY3JlZW5cIixcclxuICAgICAgICBJTlRMX0JBQ0tfU0xBU0ggPSBcIkludGxCYWNrU2xhc2hcIixcclxuICAgICAgICBGMTEgPSBcIkYxMVwiLFxyXG4gICAgICAgIEYxMiA9IFwiRjEyXCIsXHJcbiAgICAgICAgTlVNUEFEX0VRVUFMID0gXCJOdW1wYWRFcXVhbFwiLFxyXG4gICAgICAgIEYxMyA9IFwiRjEzXCIsXHJcbiAgICAgICAgRjE0ID0gXCJGMTRcIixcclxuICAgICAgICBGMTUgPSBcIkYxNVwiLFxyXG4gICAgICAgIEYxNiA9IFwiRjE2XCIsXHJcbiAgICAgICAgRjE3ID0gXCJGMTdcIixcclxuICAgICAgICBGMTggPSBcIkYxOFwiLFxyXG4gICAgICAgIEYxOSA9IFwiRjE5XCIsXHJcbiAgICAgICAgRjIwID0gXCJGMjBcIixcclxuICAgICAgICBGMjEgPSBcIkYyMVwiLFxyXG4gICAgICAgIEYyMiA9IFwiRjIyXCIsXHJcbiAgICAgICAgRjIzID0gXCJGMjNcIixcclxuICAgICAgICBGMjQgPSBcIkYyNFwiLFxyXG4gICAgICAgIEtBTkFfTU9ERSA9IFwiS2FuYU1vZGVcIixcclxuICAgICAgICBMQU5HMiA9IFwiTGFuZzJcIixcclxuICAgICAgICBMQU5HMSA9IFwiTGFuZzFcIixcclxuICAgICAgICBJTlRMX1JPID0gXCJJbnRsUm9cIixcclxuICAgICAgICBDT05WRVJUID0gXCJDb252ZXJ0XCIsXHJcbiAgICAgICAgTk9OX0NPTlZFUlQgPSBcIk5vbkNvbnZlcnRcIixcclxuICAgICAgICBJTlRMX1lFTiA9IFwiSW50bFllblwiLFxyXG4gICAgICAgIE5VTVBBRF9DT01NQSA9IFwiTnVtcGFkQ29tbWFcIixcclxuICAgICAgICBVTkRPID0gXCJVbmRvXCIsXHJcbiAgICAgICAgUEFTVEUgPSBcIlBhc3RlXCIsXHJcbiAgICAgICAgTUVESUFfVFJBQ0tfUFJFVklPVVMgPSBcIk1lZGlhVHJhY2tQcmV2aW91c1wiLFxyXG4gICAgICAgIENVVCA9IFwiQ3V0XCIsXHJcbiAgICAgICAgQ09QWSA9IFwiQ29weVwiLFxyXG4gICAgICAgIE1FRElBX1RSQUNLX05FWFQgPSBcIk1lZGlhVHJhY2tOZXh0XCIsXHJcbiAgICAgICAgTlVNUEFEX0VOVEVSID0gXCJOdW1wYWRFbnRlclwiLFxyXG4gICAgICAgIENUUkxfUklHSFQgPSBcIkNvbnRyb2xSaWdodFwiLFxyXG4gICAgICAgIEFVRElPX1ZPTFVNRV9NVVRFID0gXCJBdWRpb1ZvbHVtZU11dGVcIixcclxuICAgICAgICBMQVVOQ0hfQVBQMiA9IFwiTGF1bmNoQXBwMlwiLFxyXG4gICAgICAgIE1FRElBX1BMQVlfUEFVU0UgPSBcIk1lZGlhUGxheVBhdXNlXCIsXHJcbiAgICAgICAgTUVESUFfU1RPUCA9IFwiTWVkaWFTdG9wXCIsXHJcbiAgICAgICAgRUpFQ1QgPSBcIkVqZWN0XCIsXHJcbiAgICAgICAgQVVESU9fVk9MVU1FX0RPV04gPSBcIkF1ZGlvVm9sdW1lRG93blwiLFxyXG4gICAgICAgIFZPTFVNRV9ET1dOID0gXCJWb2x1bWVEb3duXCIsXHJcbiAgICAgICAgQVVESU9fVk9MVU1FX1VQID0gXCJBdWRpb1ZvbHVtZVVwXCIsXHJcbiAgICAgICAgVk9MVU1FX1VQID0gXCJWb2x1bWVVcFwiLFxyXG4gICAgICAgIEJST1dTRVJfSE9NRSA9IFwiQnJvd3NlckhvbWVcIixcclxuICAgICAgICBOVU1QQURfRElWSURFID0gXCJOdW1wYWREaXZpZGVcIixcclxuICAgICAgICBBTFRfUklHSFQgPSBcIkFsdFJpZ2h0XCIsXHJcbiAgICAgICAgSEVMUCA9IFwiSGVscFwiLFxyXG4gICAgICAgIE5VTV9MT0NLID0gXCJOdW1Mb2NrXCIsXHJcbiAgICAgICAgSE9NRSA9IFwiSG9tZVwiLFxyXG4gICAgICAgIEFSUk9XX1VQID0gXCJBcnJvd1VwXCIsXHJcbiAgICAgICAgQVJST1dfUklHSFQgPSBcIkFycm93UmlnaHRcIixcclxuICAgICAgICBBUlJPV19ET1dOID0gXCJBcnJvd0Rvd25cIixcclxuICAgICAgICBBUlJPV19MRUZUID0gXCJBcnJvd0xlZnRcIixcclxuICAgICAgICBFTkQgPSBcIkVuZFwiLFxyXG4gICAgICAgIFBBR0VfVVAgPSBcIlBhZ2VVcFwiLFxyXG4gICAgICAgIFBBR0VfRE9XTiA9IFwiUGFnZURvd25cIixcclxuICAgICAgICBJTlNFUlQgPSBcIkluc2VydFwiLFxyXG4gICAgICAgIERFTEVURSA9IFwiRGVsZXRlXCIsXHJcbiAgICAgICAgTUVUQV9MRUZUID0gXCJNZXRhX0xlZnRcIixcclxuICAgICAgICBPU19MRUZUID0gXCJPU0xlZnRcIixcclxuICAgICAgICBNRVRBX1JJR0hUID0gXCJNZXRhUmlnaHRcIixcclxuICAgICAgICBPU19SSUdIVCA9IFwiT1NSaWdodFwiLFxyXG4gICAgICAgIENPTlRFWFRfTUVOVSA9IFwiQ29udGV4dE1lbnVcIixcclxuICAgICAgICBQT1dFUiA9IFwiUG93ZXJcIixcclxuICAgICAgICBCUk9XU0VSX1NFQVJDSCA9IFwiQnJvd3NlclNlYXJjaFwiLFxyXG4gICAgICAgIEJST1dTRVJfRkFWT1JJVEVTID0gXCJCcm93c2VyRmF2b3JpdGVzXCIsXHJcbiAgICAgICAgQlJPV1NFUl9SRUZSRVNIID0gXCJCcm93c2VyUmVmcmVzaFwiLFxyXG4gICAgICAgIEJST1dTRVJfU1RPUCA9IFwiQnJvd3NlclN0b3BcIixcclxuICAgICAgICBCUk9XU0VSX0ZPUldBUkQgPSBcIkJyb3dzZXJGb3J3YXJkXCIsXHJcbiAgICAgICAgQlJPV1NFUl9CQUNLID0gXCJCcm93c2VyQmFja1wiLFxyXG4gICAgICAgIExBVU5DSF9BUFAxID0gXCJMYXVuY2hBcHAxXCIsXHJcbiAgICAgICAgTEFVTkNIX01BSUwgPSBcIkxhdW5jaE1haWxcIixcclxuICAgICAgICBMQVVOQ0hfTUVESUFfUExBWUVSID0gXCJMYXVuY2hNZWRpYVBsYXllclwiLFxyXG5cclxuICAgICAgICAvL21hYyBicmluZ3MgdGhpcyBidXR0dG9uXHJcbiAgICAgICAgRk4gPSBcIkZuXCIsIC8vbm8gZXZlbnQgZmlyZWQgYWN0dWFsbHlcclxuXHJcbiAgICAgICAgLy9MaW51eCBicmluZ3MgdGhlc2VcclxuICAgICAgICBBR0FJTiA9IFwiQWdhaW5cIixcclxuICAgICAgICBQUk9QUyA9IFwiUHJvcHNcIixcclxuICAgICAgICBTRUxFQ1QgPSBcIlNlbGVjdFwiLFxyXG4gICAgICAgIE9QRU4gPSBcIk9wZW5cIixcclxuICAgICAgICBGSU5EID0gXCJGaW5kXCIsXHJcbiAgICAgICAgV0FLRV9VUCA9IFwiV2FrZVVwXCIsXHJcbiAgICAgICAgTlVNUEFEX1BBUkVOVF9MRUZUID0gXCJOdW1wYWRQYXJlbnRMZWZ0XCIsXHJcbiAgICAgICAgTlVNUEFEX1BBUkVOVF9SSUdIVCA9IFwiTnVtcGFkUGFyZW50UmlnaHRcIixcclxuXHJcbiAgICAgICAgLy9hbmRyb2lkXHJcbiAgICAgICAgU0xFRVAgPSBcIlNsZWVwXCJcclxuICAgIH1cclxuICAgIC8qIFxyXG4gICAgRmlyZWZveCBjYW4ndCBtYWtlIHVzZSBvZiB0aG9zZSBidXR0b25zIGFuZCBDb21iaW5hdGlvbnM6XHJcbiAgICBTSU5HRUxFX0JVVFRPTlM6XHJcbiAgICAgRHJ1Y2ssXHJcbiAgICBDT01CSU5BVElPTlM6XHJcbiAgICAgU2hpZnQgKyBGMTAsIFNoaWZ0ICsgTnVtcGFkNSxcclxuICAgICBDVFJMICsgcSwgQ1RSTCArIEY0LFxyXG4gICAgIEFMVCArIEYxLCBBTFQgKyBGMiwgQUxUICsgRjMsIEFMVCArIEY3LCBBTFQgKyBGOCwgQUxUICsgRjEwXHJcbiAgICBPcGVyYSB3b24ndCBkbyBnb29kIHdpdGggdGhlc2UgQnV0dG9ucyBhbmQgY29tYmluYXRpb25zOlxyXG4gICAgU0lOR0xFX0JVVFRPTlM6XHJcbiAgICAgRmxvYXQzMkFycmF5LCBGMTEsIEFMVCxcclxuICAgIENPTUJJTkFUSU9OUzpcclxuICAgICBDVFJMICsgcSwgQ1RSTCArIHQsIENUUkwgKyBoLCBDVFJMICsgZywgQ1RSTCArIG4sIENUUkwgKyBmIFxyXG4gICAgIEFMVCArIEYxLCBBTFQgKyBGMiwgQUxUICsgRjQsIEFMVCArIEY1LCBBTFQgKyBGNiwgQUxUICsgRjcsIEFMVCArIEY4LCBBTFQgKyBGMTBcclxuICAgICAqL1xyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgICBleHBvcnQgY29uc3QgZW51bSBFVkVOVF9QT0lOVEVSIHtcclxuICAgICAgICBVUCA9IFwixpJwb2ludGVydXBcIixcclxuICAgICAgICBET1dOID0gXCLGknBvaW50ZXJkb3duXCIsXHJcbiAgICAgICAgTU9WRSA9IFwixpJwb2ludGVybW92ZVwiLFxyXG4gICAgICAgIE9WRVIgPSBcIsaScG9pbnRlcm92ZXJcIixcclxuICAgICAgICBFTlRFUiA9IFwixpJwb2ludGVyZW50ZXJcIixcclxuICAgICAgICBDQU5DRUwgPSBcIsaScG9pbnRlcmNhbmNlbFwiLFxyXG4gICAgICAgIE9VVCA9IFwixpJwb2ludGVyb3V0XCIsXHJcbiAgICAgICAgTEVBVkUgPSBcIsaScG9pbnRlcmxlYXZlXCIsXHJcbiAgICAgICAgR09UQ0FQVFVSRSA9IFwixpJnb3Rwb2ludGVyY2FwdHVyZVwiLFxyXG4gICAgICAgIExPU1RDQVBUVVJFID0gXCLGkmxvc3Rwb2ludGVyY2FwdHVyZVwiXHJcbiAgICB9XHJcblxyXG4gICAgZXhwb3J0IGNsYXNzIEV2ZW50UG9pbnRlciBleHRlbmRzIFBvaW50ZXJFdmVudCB7XHJcbiAgICAgICAgcHVibGljIHBvaW50ZXJYOiBudW1iZXI7XHJcbiAgICAgICAgcHVibGljIHBvaW50ZXJZOiBudW1iZXI7XHJcbiAgICAgICAgcHVibGljIGNhbnZhc1g6IG51bWJlcjtcclxuICAgICAgICBwdWJsaWMgY2FudmFzWTogbnVtYmVyO1xyXG4gICAgICAgIHB1YmxpYyBjbGllbnRSZWN0OiBDbGllbnRSZWN0O1xyXG5cclxuICAgICAgICBjb25zdHJ1Y3Rvcih0eXBlOiBzdHJpbmcsIF9ldmVudDogRXZlbnRQb2ludGVyKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKHR5cGUsIF9ldmVudCk7XHJcbiAgICAgICAgICAgIGxldCB0YXJnZXQ6IEhUTUxFbGVtZW50ID0gPEhUTUxFbGVtZW50Pl9ldmVudC50YXJnZXQ7XHJcbiAgICAgICAgICAgIHRoaXMuY2xpZW50UmVjdCA9IHRhcmdldC5nZXRDbGllbnRSZWN0cygpWzBdO1xyXG4gICAgICAgICAgICB0aGlzLnBvaW50ZXJYID0gX2V2ZW50LmNsaWVudFggLSB0aGlzLmNsaWVudFJlY3QubGVmdDtcclxuICAgICAgICAgICAgdGhpcy5wb2ludGVyWSA9IF9ldmVudC5jbGllbnRZIC0gdGhpcy5jbGllbnRSZWN0LnRvcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAgIGV4cG9ydCBjb25zdCBlbnVtIEVWRU5UX1RJTUVSIHtcclxuICAgICAgICBDQUxMID0gXCLGkmxhcHNlXCJcclxuICAgIH1cclxuXHJcbiAgICBleHBvcnQgY2xhc3MgRXZlbnRUaW1lciB7XHJcbiAgICAgICAgcHVibGljIHR5cGU6IEVWRU5UX1RJTUVSID0gRVZFTlRfVElNRVIuQ0FMTDtcclxuICAgICAgICBwdWJsaWMgdGFyZ2V0OiBUaW1lcjtcclxuICAgICAgICBwdWJsaWMgYXJndW1lbnRzOiBPYmplY3RbXTtcclxuICAgICAgICBwdWJsaWMgZmlyc3RDYWxsOiBib29sZWFuID0gdHJ1ZTtcclxuICAgICAgICBwdWJsaWMgbGFzdENhbGw6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICAgICAgY29uc3RydWN0b3IoX3RpbWVyOiBUaW1lciwgLi4uX2FyZ3VtZW50czogT2JqZWN0W10pIHtcclxuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSBfdGltZXI7XHJcbiAgICAgICAgICAgIHRoaXMuYXJndW1lbnRzID0gX2FyZ3VtZW50cztcclxuICAgICAgICAgICAgdGhpcy5maXJzdENhbGwgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gICAgZXhwb3J0IGNvbnN0IGVudW0gRVZFTlRfV0hFRUwge1xyXG4gICAgICAgIFdIRUVMID0gXCLGkndoZWVsXCJcclxuICAgIH1cclxuICAgIFxyXG4gICAgZXhwb3J0IGNsYXNzIEV2ZW50V2hlZWwgZXh0ZW5kcyBXaGVlbEV2ZW50IHtcclxuICAgICAgICBjb25zdHJ1Y3Rvcih0eXBlOiBzdHJpbmcsIF9ldmVudDogRXZlbnRXaGVlbCkge1xyXG4gICAgICAgICAgICBzdXBlcih0eXBlLCBfZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gICAgZXhwb3J0IHR5cGUgVHlwZU9mTGlnaHQgPSBuZXcgKCkgPT4gTGlnaHQ7XHJcbiAgICAvKipcclxuICAgICAqIEJhc2VjbGFzcyBmb3IgZGlmZmVyZW50IGtpbmRzIG9mIGxpZ2h0cy4gXHJcbiAgICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAgICovXHJcbiAgICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgTGlnaHQgZXh0ZW5kcyBNdXRhYmxlIHtcclxuICAgICAgICBwdWJsaWMgY29sb3I6IENvbG9yO1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKF9jb2xvcjogQ29sb3IgPSBuZXcgQ29sb3IoMSwgMSwgMSwgMSkpIHtcclxuICAgICAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICAgICAgdGhpcy5jb2xvciA9IF9jb2xvcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBnZXRUeXBlKCk6IFR5cGVPZkxpZ2h0IHtcclxuICAgICAgICAgICAgcmV0dXJuIDxUeXBlT2ZMaWdodD50aGlzLmNvbnN0cnVjdG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcigpOiB2b2lkIHsvKiovIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFtYmllbnQgbGlnaHQsIGNvbWluZyBmcm9tIGFsbCBkaXJlY3Rpb25zLCBpbGx1bWluYXRpbmcgZXZlcnl0aGluZyB3aXRoIGl0cyBjb2xvciBpbmRlcGVuZGVudCBvZiBwb3NpdGlvbiBhbmQgb3JpZW50YXRpb24gKGxpa2UgYSBmb2dneSBkYXkgb3IgaW4gdGhlIHNoYWRlcykgIFxyXG4gICAgICogYGBgcGxhaW50ZXh0XHJcbiAgICAgKiB+IH4gfiAgXHJcbiAgICAgKiAgfiB+IH4gIFxyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIGV4cG9ydCBjbGFzcyBMaWdodEFtYmllbnQgZXh0ZW5kcyBMaWdodCB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoX2NvbG9yOiBDb2xvciA9IG5ldyBDb2xvcigxLCAxLCAxLCAxKSkge1xyXG4gICAgICAgICAgICBzdXBlcihfY29sb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGlyZWN0aW9uYWwgbGlnaHQsIGlsbHVtaW5hdGluZyBldmVyeXRoaW5nIGZyb20gYSBzcGVjaWZpZWQgZGlyZWN0aW9uIHdpdGggaXRzIGNvbG9yIChsaWtlIHN0YW5kaW5nIGluIGJyaWdodCBzdW5saWdodCkgIFxyXG4gICAgICogYGBgcGxhaW50ZXh0XHJcbiAgICAgKiAtLS0+ICBcclxuICAgICAqIC0tLT4gIFxyXG4gICAgICogLS0tPiAgXHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgZXhwb3J0IGNsYXNzIExpZ2h0RGlyZWN0aW9uYWwgZXh0ZW5kcyBMaWdodCB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoX2NvbG9yOiBDb2xvciA9IG5ldyBDb2xvcigxLCAxLCAxLCAxKSkge1xyXG4gICAgICAgICAgICBzdXBlcihfY29sb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT21uaWRpcmVjdGlvbmFsIGxpZ2h0IGVtaXR0aW5nIGZyb20gaXRzIHBvc2l0aW9uLCBpbGx1bWluYXRpbmcgb2JqZWN0cyBkZXBlbmRpbmcgb24gdGhlaXIgcG9zaXRpb24gYW5kIGRpc3RhbmNlIHdpdGggaXRzIGNvbG9yIChsaWtlIGEgY29sb3JlZCBsaWdodCBidWxiKSAgXHJcbiAgICAgKiBgYGBwbGFpbnRleHRcclxuICAgICAqICAgICAgICAgLlxcfC8uXHJcbiAgICAgKiAgICAgICAgLS0gbyAtLVxyXG4gICAgICogICAgICAgICDCtC98XFxgXHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgZXhwb3J0IGNsYXNzIExpZ2h0UG9pbnQgZXh0ZW5kcyBMaWdodCB7XHJcbiAgICAgICAgcHVibGljIHJhbmdlOiBudW1iZXIgPSAxMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3BvdCBsaWdodCBlbWl0dGluZyB3aXRoaW4gYSBzcGVjaWZpZWQgYW5nbGUgZnJvbSBpdHMgcG9zaXRpb24sIGlsbHVtaW5hdGluZyBvYmplY3RzIGRlcGVuZGluZyBvbiB0aGVpciBwb3NpdGlvbiBhbmQgZGlzdGFuY2Ugd2l0aCBpdHMgY29sb3IgIFxyXG4gICAgICogYGBgcGxhaW50ZXh0XHJcbiAgICAgKiAgICAgICAgICBvICBcclxuICAgICAqICAgICAgICAgL3xcXCAgXHJcbiAgICAgKiAgICAgICAgLyB8IFxcIFxyXG4gICAgICogYGBgICAgXHJcbiAgICAgKi9cclxuICAgIGV4cG9ydCBjbGFzcyBMaWdodFNwb3QgZXh0ZW5kcyBMaWdodCB7XHJcbiAgICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgaW50ZXJmYWNlIEJvcmRlciB7XHJcbiAgICBsZWZ0OiBudW1iZXI7XHJcbiAgICB0b3A6IG51bWJlcjtcclxuICAgIHJpZ2h0OiBudW1iZXI7XHJcbiAgICBib3R0b206IG51bWJlcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZyYW1pbmcgZGVzY3JpYmVzIGhvdyB0byBtYXAgYSByZWN0YW5nbGUgaW50byBhIGdpdmVuIGZyYW1lXHJcbiAgICogYW5kIGhvdyBwb2ludHMgaW4gdGhlIGZyYW1lIGNvcnJlc3BvbmQgdG8gcG9pbnRzIGluIHRoZSByZXN1bHRpbmcgcmVjdGFuZ2xlIGFuZCB2aWNlIHZlcnNhXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTkgIFxyXG4gICAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9KaXJrYURlbGxPcm8vRlVER0Uvd2lraS9GcmFtaW5nXHJcbiAgICovXHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIEZyYW1pbmcgZXh0ZW5kcyBNdXRhYmxlIHtcclxuICAgIC8qKlxyXG4gICAgICogTWFwcyBhIHBvaW50IGluIHRoZSBnaXZlbiBmcmFtZSBhY2NvcmRpbmcgdG8gdGhpcyBmcmFtaW5nXHJcbiAgICAgKiBAcGFyYW0gX3BvaW50SW5GcmFtZSBUaGUgcG9pbnQgaW4gdGhlIGZyYW1lIGdpdmVuXHJcbiAgICAgKiBAcGFyYW0gX3JlY3RGcmFtZSBUaGUgZnJhbWUgdGhlIHBvaW50IGlzIHJlbGF0aXZlIHRvXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBnZXRQb2ludChfcG9pbnRJbkZyYW1lOiBWZWN0b3IyLCBfcmVjdEZyYW1lOiBSZWN0YW5nbGUpOiBWZWN0b3IyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwcyBhIHBvaW50IGluIGEgZ2l2ZW4gcmVjdGFuZ2xlIGJhY2sgdG8gYSBjYWxjdWxhdGVkIGZyYW1lIG9mIG9yaWdpblxyXG4gICAgICogQHBhcmFtIF9wb2ludCBUaGUgcG9pbnQgaW4gdGhlIHJlY3RhbmdsZVxyXG4gICAgICogQHBhcmFtIF9yZWN0IFRoZSByZWN0YW5nbGUgdGhlIHBvaW50IGlzIHJlbGF0aXZlIHRvXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBnZXRQb2ludEludmVyc2UoX3BvaW50OiBWZWN0b3IyLCBfcmVjdDogUmVjdGFuZ2xlKTogVmVjdG9yMjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRha2VzIGEgcmVjdGFuZ2xlIGFzIHRoZSBmcmFtZSBhbmQgY3JlYXRlcyBhIG5ldyByZWN0YW5nbGUgYWNjb3JkaW5nIHRvIHRoZSBmcmFtaW5nXHJcbiAgICAgKiBAcGFyYW0gX3JlY3RGcmFtZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0UmVjdChfcmVjdEZyYW1lOiBSZWN0YW5nbGUpOiBSZWN0YW5nbGU7XHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQgey8qKiAqLyB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgcmVzdWx0aW5nIHJlY3RhbmdsZSBoYXMgYSBmaXhlZCB3aWR0aCBhbmQgaGVpZ2h0IGFuZCBkaXNwbGF5IHNob3VsZCBzY2FsZSB0byBmaXQgdGhlIGZyYW1lXHJcbiAgICogUG9pbnRzIGFyZSBzY2FsZWQgaW4gdGhlIHNhbWUgcmF0aW9cclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgRnJhbWluZ0ZpeGVkIGV4dGVuZHMgRnJhbWluZyB7XHJcbiAgICBwdWJsaWMgd2lkdGg6IG51bWJlciA9IDMwMDtcclxuICAgIHB1YmxpYyBoZWlnaHQ6IG51bWJlciA9IDE1MDtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3dpZHRoOiBudW1iZXIgPSAzMDAsIF9oZWlnaHQ6IG51bWJlciA9IDE1MCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLnNldFNpemUoX3dpZHRoLCBfaGVpZ2h0KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0U2l6ZShfd2lkdGg6IG51bWJlciwgX2hlaWdodDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIHRoaXMud2lkdGggPSBfd2lkdGg7XHJcbiAgICAgIHRoaXMuaGVpZ2h0ID0gX2hlaWdodDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0UG9pbnQoX3BvaW50SW5GcmFtZTogVmVjdG9yMiwgX3JlY3RGcmFtZTogUmVjdGFuZ2xlKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjIgPSBuZXcgVmVjdG9yMihcclxuICAgICAgICB0aGlzLndpZHRoICogKF9wb2ludEluRnJhbWUueCAtIF9yZWN0RnJhbWUueCkgLyBfcmVjdEZyYW1lLndpZHRoLFxyXG4gICAgICAgIHRoaXMuaGVpZ2h0ICogKF9wb2ludEluRnJhbWUueSAtIF9yZWN0RnJhbWUueSkgLyBfcmVjdEZyYW1lLmhlaWdodFxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRQb2ludEludmVyc2UoX3BvaW50OiBWZWN0b3IyLCBfcmVjdDogUmVjdGFuZ2xlKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjIgPSBuZXcgVmVjdG9yMihcclxuICAgICAgICBfcG9pbnQueCAqIF9yZWN0LndpZHRoIC8gdGhpcy53aWR0aCArIF9yZWN0LngsXHJcbiAgICAgICAgX3BvaW50LnkgKiBfcmVjdC5oZWlnaHQgLyB0aGlzLmhlaWdodCArIF9yZWN0LnlcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0UmVjdChfcmVjdEZyYW1lOiBSZWN0YW5nbGUpOiBSZWN0YW5nbGUge1xyXG4gICAgICByZXR1cm4gUmVjdGFuZ2xlLkdFVCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIHJlc3VsdGluZyByZWN0YW5nbGUgYXJlIGZyYWN0aW9ucyBvZiB0aG9zZSBvZiB0aGUgZnJhbWUsIHNjYWxlZCBieSBub3JtZWQgdmFsdWVzIG5vcm1XaWR0aCBhbmQgbm9ybUhlaWdodC5cclxuICAgKiBEaXNwbGF5IHNob3VsZCBzY2FsZSB0byBmaXQgdGhlIGZyYW1lIGFuZCBwb2ludHMgYXJlIHNjYWxlZCBpbiB0aGUgc2FtZSByYXRpb1xyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBGcmFtaW5nU2NhbGVkIGV4dGVuZHMgRnJhbWluZyB7XHJcbiAgICBwdWJsaWMgbm9ybVdpZHRoOiBudW1iZXIgPSAxLjA7XHJcbiAgICBwdWJsaWMgbm9ybUhlaWdodDogbnVtYmVyID0gMS4wO1xyXG5cclxuICAgIHB1YmxpYyBzZXRTY2FsZShfbm9ybVdpZHRoOiBudW1iZXIsIF9ub3JtSGVpZ2h0OiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy5ub3JtV2lkdGggPSBfbm9ybVdpZHRoO1xyXG4gICAgICB0aGlzLm5vcm1IZWlnaHQgPSBfbm9ybUhlaWdodDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0UG9pbnQoX3BvaW50SW5GcmFtZTogVmVjdG9yMiwgX3JlY3RGcmFtZTogUmVjdGFuZ2xlKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjIgPSBuZXcgVmVjdG9yMihcclxuICAgICAgICB0aGlzLm5vcm1XaWR0aCAqIChfcG9pbnRJbkZyYW1lLnggLSBfcmVjdEZyYW1lLngpLFxyXG4gICAgICAgIHRoaXMubm9ybUhlaWdodCAqIChfcG9pbnRJbkZyYW1lLnkgLSBfcmVjdEZyYW1lLnkpXHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFBvaW50SW52ZXJzZShfcG9pbnQ6IFZlY3RvcjIsIF9yZWN0OiBSZWN0YW5nbGUpOiBWZWN0b3IyIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMiA9IG5ldyBWZWN0b3IyKFxyXG4gICAgICAgIF9wb2ludC54IC8gdGhpcy5ub3JtV2lkdGggKyBfcmVjdC54LFxyXG4gICAgICAgIF9wb2ludC55IC8gdGhpcy5ub3JtSGVpZ2h0ICsgX3JlY3QueVxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRSZWN0KF9yZWN0RnJhbWU6IFJlY3RhbmdsZSk6IFJlY3RhbmdsZSB7XHJcbiAgICAgIHJldHVybiBSZWN0YW5nbGUuR0VUKDAsIDAsIHRoaXMubm9ybVdpZHRoICogX3JlY3RGcmFtZS53aWR0aCwgdGhpcy5ub3JtSGVpZ2h0ICogX3JlY3RGcmFtZS5oZWlnaHQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHJlc3VsdGluZyByZWN0YW5nbGUgZml0cyBpbnRvIGEgbWFyZ2luIGdpdmVuIGFzIGZyYWN0aW9ucyBvZiB0aGUgc2l6ZSBvZiB0aGUgZnJhbWUgZ2l2ZW4gYnkgbm9ybUFuY2hvclxyXG4gICAqIHBsdXMgYW4gYWJzb2x1dGUgcGFkZGluZyBnaXZlbiBieSBwaXhlbEJvcmRlci4gRGlzcGxheSBzaG91bGQgZml0IGludG8gdGhpcy5cclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgRnJhbWluZ0NvbXBsZXggZXh0ZW5kcyBGcmFtaW5nIHtcclxuICAgIHB1YmxpYyBtYXJnaW46IEJvcmRlciA9IHsgbGVmdDogMCwgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwIH07XHJcbiAgICBwdWJsaWMgcGFkZGluZzogQm9yZGVyID0geyBsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAgfTtcclxuXHJcbiAgICBwdWJsaWMgZ2V0UG9pbnQoX3BvaW50SW5GcmFtZTogVmVjdG9yMiwgX3JlY3RGcmFtZTogUmVjdGFuZ2xlKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjIgPSBuZXcgVmVjdG9yMihcclxuICAgICAgICBfcG9pbnRJbkZyYW1lLnggLSB0aGlzLnBhZGRpbmcubGVmdCAtIHRoaXMubWFyZ2luLmxlZnQgKiBfcmVjdEZyYW1lLndpZHRoLFxyXG4gICAgICAgIF9wb2ludEluRnJhbWUueSAtIHRoaXMucGFkZGluZy50b3AgLSB0aGlzLm1hcmdpbi50b3AgKiBfcmVjdEZyYW1lLmhlaWdodFxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgcHVibGljIGdldFBvaW50SW52ZXJzZShfcG9pbnQ6IFZlY3RvcjIsIF9yZWN0OiBSZWN0YW5nbGUpOiBWZWN0b3IyIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMiA9IG5ldyBWZWN0b3IyKFxyXG4gICAgICAgIF9wb2ludC54ICsgdGhpcy5wYWRkaW5nLmxlZnQgKyB0aGlzLm1hcmdpbi5sZWZ0ICogX3JlY3Qud2lkdGgsXHJcbiAgICAgICAgX3BvaW50LnkgKyB0aGlzLnBhZGRpbmcudG9wICsgdGhpcy5tYXJnaW4udG9wICogX3JlY3QuaGVpZ2h0XHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFJlY3QoX3JlY3RGcmFtZTogUmVjdGFuZ2xlKTogUmVjdGFuZ2xlIHtcclxuICAgICAgaWYgKCFfcmVjdEZyYW1lKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgbGV0IG1pblg6IG51bWJlciA9IF9yZWN0RnJhbWUueCArIHRoaXMubWFyZ2luLmxlZnQgKiBfcmVjdEZyYW1lLndpZHRoICsgdGhpcy5wYWRkaW5nLmxlZnQ7XHJcbiAgICAgIGxldCBtaW5ZOiBudW1iZXIgPSBfcmVjdEZyYW1lLnkgKyB0aGlzLm1hcmdpbi50b3AgKiBfcmVjdEZyYW1lLmhlaWdodCArIHRoaXMucGFkZGluZy50b3A7XHJcbiAgICAgIGxldCBtYXhYOiBudW1iZXIgPSBfcmVjdEZyYW1lLnggKyAoMSAtIHRoaXMubWFyZ2luLnJpZ2h0KSAqIF9yZWN0RnJhbWUud2lkdGggLSB0aGlzLnBhZGRpbmcucmlnaHQ7XHJcbiAgICAgIGxldCBtYXhZOiBudW1iZXIgPSBfcmVjdEZyYW1lLnkgKyAoMSAtIHRoaXMubWFyZ2luLmJvdHRvbSkgKiBfcmVjdEZyYW1lLmhlaWdodCAtIHRoaXMucGFkZGluZy5ib3R0b207XHJcblxyXG4gICAgICByZXR1cm4gUmVjdGFuZ2xlLkdFVChtaW5YLCBtaW5ZLCBtYXhYIC0gbWluWCwgbWF4WSAtIG1pblkpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xyXG4gICAgICByZXR1cm4geyBtYXJnaW46IHRoaXMubWFyZ2luLCBwYWRkaW5nOiB0aGlzLnBhZGRpbmcgfTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVwcmVzZW50cyB0aGUgbWF0cml4IGFzIHRyYW5zbGF0aW9uLCByb3RhdGlvbiBhbmQgc2NhbGluZyB2ZWN0b3IsIGJlaW5nIGNhbGN1bGF0ZWQgZnJvbSB0aGUgbWF0cml4XHJcbiAgICovXHJcbiAgaW50ZXJmYWNlIFZlY3RvclJlcHJlc2VudGF0aW9uIHtcclxuICAgIHRyYW5zbGF0aW9uOiBWZWN0b3IyO1xyXG4gICAgcm90YXRpb246IG51bWJlcjtcclxuICAgIHNjYWxpbmc6IFZlY3RvcjI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTaW1wbGUgY2xhc3MgZm9yIDN4MyBtYXRyaXggb3BlcmF0aW9uc1xyXG4gICAqIEBhdXRob3JzIEphc2NoYSBLYXJhZ8O2bCwgSEZVLCAyMDE5IHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjBcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgTWF0cml4M3gzIGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZSB7XHJcbiAgICBwcml2YXRlIGRhdGE6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7IC8vIFRoZSBkYXRhIG9mIHRoZSBtYXRyaXguXHJcbiAgICBwcml2YXRlIG11dGF0b3I6IE11dGF0b3IgPSBudWxsOyAvLyBwcmVwYXJlZCBmb3Igb3B0aW1pemF0aW9uLCBrZWVwIG11dGF0b3IgdG8gcmVkdWNlIHJlZHVuZGFudCBjYWxjdWxhdGlvbiBhbmQgZm9yIGNvbXBhcmlzb24uIFNldCB0byBudWxsIHdoZW4gZGF0YSBjaGFuZ2VzIVxyXG4gICAgcHJpdmF0ZSB2ZWN0b3JzOiBWZWN0b3JSZXByZXNlbnRhdGlvbjsgLy8gdmVjdG9yIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgbWF0cml4XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KFtcclxuICAgICAgICAxLCAwLCAwLFxyXG4gICAgICAgIDAsIDEsIDAsXHJcbiAgICAgICAgMCwgMCwgMVxyXG4gICAgICBdKTtcclxuICAgICAgdGhpcy5yZXNldENhY2hlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogLSBnZXQ6IGEgY29weSBvZiB0aGUgY2FsY3VsYXRlZCB0cmFuc2xhdGlvbiB2ZWN0b3IgICBcclxuICAgICAqIC0gc2V0OiBlZmZlY3QgdGhlIG1hdHJpeCBpZ25vcmluZyBpdHMgcm90YXRpb24gYW5kIHNjYWxpbmdcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCB0cmFuc2xhdGlvbigpOiBWZWN0b3IyIHtcclxuICAgICAgaWYgKCF0aGlzLnZlY3RvcnMudHJhbnNsYXRpb24pXHJcbiAgICAgICAgdGhpcy52ZWN0b3JzLnRyYW5zbGF0aW9uID0gbmV3IFZlY3RvcjIodGhpcy5kYXRhWzZdLCB0aGlzLmRhdGFbN10pO1xyXG4gICAgICByZXR1cm4gdGhpcy52ZWN0b3JzLnRyYW5zbGF0aW9uLmNvcHk7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHRyYW5zbGF0aW9uKF90cmFuc2xhdGlvbjogVmVjdG9yMikge1xyXG4gICAgICB0aGlzLmRhdGEuc2V0KF90cmFuc2xhdGlvbi5nZXQoKSwgMTIpO1xyXG4gICAgICAvLyBubyBmdWxsIGNhY2hlIHJlc2V0IHJlcXVpcmVkXHJcbiAgICAgIHRoaXMudmVjdG9ycy50cmFuc2xhdGlvbiA9IF90cmFuc2xhdGlvbjtcclxuICAgICAgdGhpcy5tdXRhdG9yID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiAtIGdldDogYSBjb3B5IG9mIHRoZSBjYWxjdWxhdGVkIHJvdGF0aW9uIHZlY3RvciAgIFxyXG4gICAgICogLSBzZXQ6IGVmZmVjdCB0aGUgbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgcm90YXRpb24oKTogbnVtYmVyIHtcclxuICAgICAgaWYgKCF0aGlzLnZlY3RvcnMucm90YXRpb24pXHJcbiAgICAgICAgdGhpcy52ZWN0b3JzLnJvdGF0aW9uID0gdGhpcy5nZXRFdWxlckFuZ2xlcygpO1xyXG4gICAgICByZXR1cm4gdGhpcy52ZWN0b3JzLnJvdGF0aW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCByb3RhdGlvbihfcm90YXRpb246IG51bWJlcikge1xyXG4gICAgICB0aGlzLm11dGF0ZSh7IFwicm90YXRpb25cIjogX3JvdGF0aW9uIH0pO1xyXG4gICAgICB0aGlzLnJlc2V0Q2FjaGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiAtIGdldDogYSBjb3B5IG9mIHRoZSBjYWxjdWxhdGVkIHNjYWxlIHZlY3RvciAgIFxyXG4gICAgICogLSBzZXQ6IGVmZmVjdCB0aGUgbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgc2NhbGluZygpOiBWZWN0b3IyIHtcclxuICAgICAgaWYgKCF0aGlzLnZlY3RvcnMuc2NhbGluZylcclxuICAgICAgICB0aGlzLnZlY3RvcnMuc2NhbGluZyA9IG5ldyBWZWN0b3IyKFxyXG4gICAgICAgICAgTWF0aC5oeXBvdCh0aGlzLmRhdGFbMF0sIHRoaXMuZGF0YVsxXSksXHJcbiAgICAgICAgICBNYXRoLmh5cG90KHRoaXMuZGF0YVszXSwgdGhpcy5kYXRhWzRdKVxyXG4gICAgICAgICk7XHJcbiAgICAgIHJldHVybiB0aGlzLnZlY3RvcnMuc2NhbGluZy5jb3B5O1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBzY2FsaW5nKF9zY2FsaW5nOiBWZWN0b3IyKSB7XHJcbiAgICAgIHRoaXMubXV0YXRlKHsgXCJzY2FsaW5nXCI6IF9zY2FsaW5nIH0pO1xyXG4gICAgICB0aGlzLnJlc2V0Q2FjaGUoKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy9UT0RPOiBmaWd1cmUgb3V0IHdoYXQgdGhpcyBpcyB1c2VkIGZvclxyXG4gICAgcHVibGljIHN0YXRpYyBQUk9KRUNUSU9OKF93aWR0aDogbnVtYmVyLCBfaGVpZ2h0OiBudW1iZXIpOiBNYXRyaXgzeDMge1xyXG4gICAgICBsZXQgbWF0cml4OiBNYXRyaXgzeDMgPSBuZXcgTWF0cml4M3gzO1xyXG4gICAgICBtYXRyaXguZGF0YS5zZXQoW1xyXG4gICAgICAgIDIgLyBfd2lkdGgsIDAsIDAsXHJcbiAgICAgICAgMCwgLTIgLyBfaGVpZ2h0LCAwLFxyXG4gICAgICAgIC0xLCAxLCAxXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gbWF0cml4O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgSURFTlRJVFkoKTogTWF0cml4M3gzIHtcclxuICAgICAgY29uc3QgcmVzdWx0OiBNYXRyaXgzeDMgPSBSZWN5Y2xlci5nZXQoTWF0cml4M3gzKTtcclxuICAgICAgcmVzdWx0LmRhdGEuc2V0KFtcclxuICAgICAgICAxLCAwLCAwLFxyXG4gICAgICAgIDAsIDEsIDAsXHJcbiAgICAgICAgMCwgMCwgMVxyXG4gICAgICBdKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBtYXRyaXggdGhhdCB0cmFuc2xhdGVzIGNvb3JkaW5hdGVzIGFsb25nIHRoZSB4LSwgeS0gYW5kIHotYXhpcyBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBUUkFOU0xBVElPTihfdHJhbnNsYXRlOiBWZWN0b3IyKTogTWF0cml4M3gzIHtcclxuICAgICAgY29uc3QgbWF0cml4OiBNYXRyaXgzeDMgPSBSZWN5Y2xlci5nZXQoTWF0cml4M3gzKTtcclxuICAgICAgbWF0cml4LmRhdGEuc2V0KFtcclxuICAgICAgICAxLCAwLCAwLFxyXG4gICAgICAgIDAsIDEsIDAsXHJcbiAgICAgICAgX3RyYW5zbGF0ZS54LCBfdHJhbnNsYXRlLnksIDFcclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiBtYXRyaXg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbWF0cml4IHRoYXQgcm90YXRlcyBjb29yZGluYXRlcyBvbiB0aGUgei1heGlzIHdoZW4gbXVsdGlwbGllZCBieS5cclxuICAgICAqIEBwYXJhbSBfYW5nbGVJbkRlZ3JlZXMgVGhlIHZhbHVlIG9mIHRoZSByb3RhdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBST1RBVElPTihfYW5nbGVJbkRlZ3JlZXM6IG51bWJlcik6IE1hdHJpeDN4MyB7XHJcbiAgICAgIC8vIGNvbnN0IG1hdHJpeDogTWF0cml4M3gzID0gbmV3IE1hdHJpeDN4MztcclxuICAgICAgY29uc3QgbWF0cml4OiBNYXRyaXgzeDMgPSBSZWN5Y2xlci5nZXQoTWF0cml4M3gzKTtcclxuICAgICAgbGV0IGFuZ2xlSW5SYWRpYW5zOiBudW1iZXIgPSBfYW5nbGVJbkRlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwO1xyXG4gICAgICBsZXQgc2luOiBudW1iZXIgPSBNYXRoLnNpbihhbmdsZUluUmFkaWFucyk7XHJcbiAgICAgIGxldCBjb3M6IG51bWJlciA9IE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKTtcclxuICAgICAgbWF0cml4LmRhdGEuc2V0KFtcclxuICAgICAgICBjb3MsIHNpbiwgMCxcclxuICAgICAgICAtc2luLCBjb3MsIDAsXHJcbiAgICAgICAgMCwgMCwgMVxyXG4gICAgICBdKTtcclxuICAgICAgcmV0dXJuIG1hdHJpeDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBtYXRyaXggdGhhdCBzY2FsZXMgY29vcmRpbmF0ZXMgYWxvbmcgdGhlIHgtLCB5LSBhbmQgei1heGlzIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgU0NBTElORyhfc2NhbGFyOiBWZWN0b3IyKTogTWF0cml4M3gzIHtcclxuICAgICAgLy8gY29uc3QgbWF0cml4OiBNYXRyaXgzeDMgPSBuZXcgTWF0cml4M3gzO1xyXG4gICAgICBjb25zdCBtYXRyaXg6IE1hdHJpeDN4MyA9IFJlY3ljbGVyLmdldChNYXRyaXgzeDMpO1xyXG4gICAgICBtYXRyaXguZGF0YS5zZXQoW1xyXG4gICAgICAgIF9zY2FsYXIueCwgMCwgMCxcclxuICAgICAgICAwLCBfc2NhbGFyLnksIDAsXHJcbiAgICAgICAgMCwgMCwgMVxyXG4gICAgICBdKTtcclxuICAgICAgcmV0dXJuIG1hdHJpeDtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIE1VTFRJUExJQ0FUSU9OKF9hOiBNYXRyaXgzeDMsIF9iOiBNYXRyaXgzeDMpOiBNYXRyaXgzeDMge1xyXG4gICAgICBsZXQgYTAwOiBudW1iZXIgPSBfYS5kYXRhWzAgKiAzICsgMF07XHJcbiAgICAgIGxldCBhMDE6IG51bWJlciA9IF9hLmRhdGFbMCAqIDMgKyAxXTtcclxuICAgICAgbGV0IGEwMjogbnVtYmVyID0gX2EuZGF0YVswICogMyArIDJdO1xyXG4gICAgICBsZXQgYTEwOiBudW1iZXIgPSBfYS5kYXRhWzEgKiAzICsgMF07XHJcbiAgICAgIGxldCBhMTE6IG51bWJlciA9IF9hLmRhdGFbMSAqIDMgKyAxXTtcclxuICAgICAgbGV0IGExMjogbnVtYmVyID0gX2EuZGF0YVsxICogMyArIDJdO1xyXG4gICAgICBsZXQgYTIwOiBudW1iZXIgPSBfYS5kYXRhWzIgKiAzICsgMF07XHJcbiAgICAgIGxldCBhMjE6IG51bWJlciA9IF9hLmRhdGFbMiAqIDMgKyAxXTtcclxuICAgICAgbGV0IGEyMjogbnVtYmVyID0gX2EuZGF0YVsyICogMyArIDJdO1xyXG4gICAgICBsZXQgYjAwOiBudW1iZXIgPSBfYi5kYXRhWzAgKiAzICsgMF07XHJcbiAgICAgIGxldCBiMDE6IG51bWJlciA9IF9iLmRhdGFbMCAqIDMgKyAxXTtcclxuICAgICAgbGV0IGIwMjogbnVtYmVyID0gX2IuZGF0YVswICogMyArIDJdO1xyXG4gICAgICBsZXQgYjEwOiBudW1iZXIgPSBfYi5kYXRhWzEgKiAzICsgMF07XHJcbiAgICAgIGxldCBiMTE6IG51bWJlciA9IF9iLmRhdGFbMSAqIDMgKyAxXTtcclxuICAgICAgbGV0IGIxMjogbnVtYmVyID0gX2IuZGF0YVsxICogMyArIDJdO1xyXG4gICAgICBsZXQgYjIwOiBudW1iZXIgPSBfYi5kYXRhWzIgKiAzICsgMF07XHJcbiAgICAgIGxldCBiMjE6IG51bWJlciA9IF9iLmRhdGFbMiAqIDMgKyAxXTtcclxuICAgICAgbGV0IGIyMjogbnVtYmVyID0gX2IuZGF0YVsyICogMyArIDJdO1xyXG4gICAgICBsZXQgbWF0cml4OiBNYXRyaXgzeDMgPSBuZXcgTWF0cml4M3gzO1xyXG4gICAgICBtYXRyaXguZGF0YS5zZXQoW1xyXG4gICAgICAgIGIwMCAqIGEwMCArIGIwMSAqIGExMCArIGIwMiAqIGEyMCxcclxuICAgICAgICBiMDAgKiBhMDEgKyBiMDEgKiBhMTEgKyBiMDIgKiBhMjEsXHJcbiAgICAgICAgYjAwICogYTAyICsgYjAxICogYTEyICsgYjAyICogYTIyLFxyXG4gICAgICAgIGIxMCAqIGEwMCArIGIxMSAqIGExMCArIGIxMiAqIGEyMCxcclxuICAgICAgICBiMTAgKiBhMDEgKyBiMTEgKiBhMTEgKyBiMTIgKiBhMjEsXHJcbiAgICAgICAgYjEwICogYTAyICsgYjExICogYTEyICsgYjEyICogYTIyLFxyXG4gICAgICAgIGIyMCAqIGEwMCArIGIyMSAqIGExMCArIGIyMiAqIGEyMCxcclxuICAgICAgICBiMjAgKiBhMDEgKyBiMjEgKiBhMTEgKyBiMjIgKiBhMjEsXHJcbiAgICAgICAgYjIwICogYTAyICsgYjIxICogYTEyICsgYjIyICogYTIyXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gbWF0cml4O1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNsYXRpb25cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgdHJhbnNsYXRpb24gYnkgdGhlIGdpdmVuIHZlY3RvciB0byB0aGlzIG1hdHJpeCBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHRyYW5zbGF0ZShfYnk6IFZlY3RvcjIpOiB2b2lkIHtcclxuICAgICAgY29uc3QgbWF0cml4OiBNYXRyaXgzeDMgPSBNYXRyaXgzeDMuTVVMVElQTElDQVRJT04odGhpcywgTWF0cml4M3gzLlRSQU5TTEFUSU9OKF9ieSkpO1xyXG4gICAgICAvLyBUT0RPOiBwb3NzaWJsZSBvcHRpbWl6YXRpb24sIHRyYW5zbGF0aW9uIG1heSBhbHRlciBtdXRhdG9yIGluc3RlYWQgb2YgZGVsZXRpbmcgaXQuXHJcbiAgICAgIHRoaXMuc2V0KG1hdHJpeCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG1hdHJpeCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSB0cmFuc2xhdGlvbiBhbG9uZyB0aGUgeC1BeGlzIGJ5IHRoZSBnaXZlbiBhbW91bnQgdG8gdGhpcyBtYXRyaXggXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0cmFuc2xhdGVYKF94OiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy5kYXRhWzZdICs9IF94O1xyXG4gICAgICB0aGlzLm11dGF0b3IgPSBudWxsO1xyXG4gICAgICB0aGlzLnZlY3RvcnMudHJhbnNsYXRpb24gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSB0cmFuc2xhdGlvbiBhbG9uZyB0aGUgeS1BeGlzIGJ5IHRoZSBnaXZlbiBhbW91bnQgdG8gdGhpcyBtYXRyaXggXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0cmFuc2xhdGVZKF95OiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy5kYXRhWzddICs9IF95O1xyXG4gICAgICB0aGlzLm11dGF0b3IgPSBudWxsO1xyXG4gICAgICB0aGlzLnZlY3RvcnMudHJhbnNsYXRpb24gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIFNjYWxpbmdcclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgc2NhbGluZyBieSB0aGUgZ2l2ZW4gdmVjdG9yIHRvIHRoaXMgbWF0cml4IFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2NhbGUoX2J5OiBWZWN0b3IyKTogdm9pZCB7XHJcbiAgICAgIGNvbnN0IG1hdHJpeDogTWF0cml4M3gzID0gTWF0cml4M3gzLk1VTFRJUExJQ0FUSU9OKHRoaXMsIE1hdHJpeDN4My5TQ0FMSU5HKF9ieSkpO1xyXG4gICAgICB0aGlzLnNldChtYXRyaXgpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShtYXRyaXgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSBzY2FsaW5nIGFsb25nIHRoZSB4LUF4aXMgYnkgdGhlIGdpdmVuIGFtb3VudCB0byB0aGlzIG1hdHJpeCBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNjYWxlWChfYnk6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICBsZXQgdmVjdG9yOiBWZWN0b3IyID0gUmVjeWNsZXIuYm9ycm93KFZlY3RvcjIpO1xyXG4gICAgICB2ZWN0b3Iuc2V0KF9ieSwgMSk7XHJcbiAgICAgIHRoaXMuc2NhbGUodmVjdG9yKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgc2NhbGluZyBhbG9uZyB0aGUgeS1BeGlzIGJ5IHRoZSBnaXZlbiBhbW91bnQgdG8gdGhpcyBtYXRyaXggXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzY2FsZVkoX2J5OiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgbGV0IHZlY3RvcjogVmVjdG9yMiA9IFJlY3ljbGVyLmJvcnJvdyhWZWN0b3IyKTtcclxuICAgICAgdmVjdG9yLnNldCgxLCBfYnkpO1xyXG4gICAgICB0aGlzLnNjYWxlKHZlY3Rvcik7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcblxyXG4gICAgLy8jcmVnaW9uIFJvdGF0aW9uXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSByb3RhdGlvbiBhcm91bmQgdGhlIHotQXhpcyB0byB0aGlzIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcm90YXRlKF9hbmdsZUluRGVncmVlczogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIGNvbnN0IG1hdHJpeDogTWF0cml4M3gzID0gTWF0cml4M3gzLk1VTFRJUExJQ0FUSU9OKHRoaXMsIE1hdHJpeDN4My5ST1RBVElPTihfYW5nbGVJbkRlZ3JlZXMpKTtcclxuICAgICAgdGhpcy5zZXQobWF0cml4KTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUobWF0cml4KTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2Zvcm1hdGlvblxyXG4gICAgLyoqXHJcbiAgICAgKiBNdWx0aXBseSB0aGlzIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgcHVibGljIG11bHRpcGx5KF9tYXRyaXg6IE1hdHJpeDN4Myk6IHZvaWQge1xyXG4gICAgICB0aGlzLnNldChNYXRyaXgzeDMuTVVMVElQTElDQVRJT04odGhpcywgX21hdHJpeCkpO1xyXG4gICAgICB0aGlzLm11dGF0b3IgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIGFuZCByZXR1cm5zIHRoZSBldWxlci1hbmdsZXMgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHJvdGF0aW9uIG9mIHRoaXMgbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRFdWxlckFuZ2xlcygpOiBudW1iZXIge1xyXG4gICAgICBsZXQgc2NhbGluZzogVmVjdG9yMiA9IHRoaXMuc2NhbGluZztcclxuXHJcbiAgICAgIGxldCBzMDogbnVtYmVyID0gdGhpcy5kYXRhWzBdIC8gc2NhbGluZy54O1xyXG4gICAgICBsZXQgczE6IG51bWJlciA9IHRoaXMuZGF0YVsxXSAvIHNjYWxpbmcueDtcclxuICAgICAgbGV0IHMzOiBudW1iZXIgPSB0aGlzLmRhdGFbM10gLyBzY2FsaW5nLnk7XHJcbiAgICAgIGxldCBzNDogbnVtYmVyID0gdGhpcy5kYXRhWzRdIC8gc2NhbGluZy55O1xyXG5cclxuICAgICAgbGV0IHhTa2V3OiBudW1iZXIgPSBNYXRoLmF0YW4yKC1zMywgczQpO1xyXG4gICAgICBsZXQgeVNrZXc6IG51bWJlciA9IE1hdGguYXRhbjIoczAsIHMxKTtcclxuXHJcbiAgICAgIGxldCBzeTogbnVtYmVyID0gTWF0aC5oeXBvdChzMCwgczEpOyAvLyBwcm9iYWJseSAyLiBwYXJhbSBzaG91bGQgYmUgdGhpcy5kYXRhWzRdIC8gc2NhbGluZy55XHJcbiAgICAgIGxldCByb3RhdGlvbjogbnVtYmVyO1xyXG5cclxuICAgICAgaWYgKCEoc3kgPiAxZS02KSlcclxuICAgICAgICByb3RhdGlvbiA9IHlTa2V3O1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgcm90YXRpb24gPSB4U2tldztcclxuXHJcbiAgICAgIHJvdGF0aW9uICo9IDE4MCAvIE1hdGguUEk7XHJcblxyXG4gICAgICByZXR1cm4gcm90YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBlbGVtZW50cyBvZiB0aGlzIG1hdHJpeCB0byB0aGUgdmFsdWVzIG9mIHRoZSBnaXZlbiBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldChfdG86IE1hdHJpeDN4Myk6IHZvaWQge1xyXG4gICAgICAvLyB0aGlzLmRhdGEgPSBfdG8uZ2V0KCk7XHJcbiAgICAgIHRoaXMuZGF0YS5zZXQoX3RvLmRhdGEpO1xyXG4gICAgICB0aGlzLnJlc2V0Q2FjaGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIGDGki5NYXRyaXgzeDModHJhbnNsYXRpb246ICR7dGhpcy50cmFuc2xhdGlvbi50b1N0cmluZygpfSwgcm90YXRpb246ICR7dGhpcy5yb3RhdGlvbi50b1N0cmluZygpfSwgc2NhbGluZzogJHt0aGlzLnNjYWxpbmcudG9TdHJpbmcoKX1gO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIGVsZW1lbnRzIG9mIHRoaXMgbWF0cml4IGFzIGEgRmxvYXQzMkFycmF5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkodGhpcy5kYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhIGNvcHkgb2YgdGhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGNvcHkoKTogTWF0cml4M3gzIHtcclxuICAgICAgbGV0IGNvcHk6IE1hdHJpeDN4MyA9IG5ldyBNYXRyaXgzeDMoKTtcclxuICAgICAgY29weS5zZXQodGhpcyk7XHJcbiAgICAgIHJldHVybiBjb3B5O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIC8vIFRPRE86IHNhdmUgdHJhbnNsYXRpb24sIHJvdGF0aW9uIGFuZCBzY2FsZSBhcyB2ZWN0b3JzIGZvciByZWFkYWJpbGl0eSBhbmQgbWFuaXB1bGF0aW9uXHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gdGhpcy5nZXRNdXRhdG9yKCk7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogU2VyaWFsaXphYmxlIHtcclxuICAgICAgdGhpcy5tdXRhdGUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcclxuICAgICAgaWYgKHRoaXMubXV0YXRvcilcclxuICAgICAgICByZXR1cm4gdGhpcy5tdXRhdG9yO1xyXG5cclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSB7XHJcbiAgICAgICAgdHJhbnNsYXRpb246IHRoaXMudHJhbnNsYXRpb24uZ2V0TXV0YXRvcigpLFxyXG4gICAgICAgIHJvdGF0aW9uOiB0aGlzLnJvdGF0aW9uLFxyXG4gICAgICAgIHNjYWxpbmc6IHRoaXMuc2NhbGluZy5nZXRNdXRhdG9yKClcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIGNhY2hlIG11dGF0b3JcclxuICAgICAgdGhpcy5tdXRhdG9yID0gbXV0YXRvcjtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICBsZXQgb2xkVHJhbnNsYXRpb246IFZlY3RvcjIgPSB0aGlzLnRyYW5zbGF0aW9uO1xyXG4gICAgICBsZXQgb2xkUm90YXRpb246IG51bWJlciA9IHRoaXMucm90YXRpb247XHJcbiAgICAgIGxldCBvbGRTY2FsaW5nOiBWZWN0b3IyID0gdGhpcy5zY2FsaW5nO1xyXG4gICAgICBsZXQgbmV3VHJhbnNsYXRpb246IFZlY3RvcjIgPSA8VmVjdG9yMj5fbXV0YXRvcltcInRyYW5zbGF0aW9uXCJdO1xyXG4gICAgICBsZXQgbmV3Um90YXRpb246IG51bWJlciA9IDxudW1iZXI+X211dGF0b3JbXCJyb3RhdGlvblwiXTtcclxuICAgICAgbGV0IG5ld1NjYWxpbmc6IFZlY3RvcjIgPSA8VmVjdG9yMj5fbXV0YXRvcltcInNjYWxpbmdcIl07XHJcbiAgICAgIGxldCB2ZWN0b3JzOiBWZWN0b3JSZXByZXNlbnRhdGlvbiA9IHsgdHJhbnNsYXRpb246IG9sZFRyYW5zbGF0aW9uLCByb3RhdGlvbjogb2xkUm90YXRpb24sIHNjYWxpbmc6IG9sZFNjYWxpbmcgfTtcclxuICAgICAgaWYgKG5ld1RyYW5zbGF0aW9uKSB7XHJcbiAgICAgICAgdmVjdG9ycy50cmFuc2xhdGlvbiA9IG5ldyBWZWN0b3IyKFxyXG4gICAgICAgICAgbmV3VHJhbnNsYXRpb24ueCAhPSB1bmRlZmluZWQgPyBuZXdUcmFuc2xhdGlvbi54IDogb2xkVHJhbnNsYXRpb24ueCxcclxuICAgICAgICAgIG5ld1RyYW5zbGF0aW9uLnkgIT0gdW5kZWZpbmVkID8gbmV3VHJhbnNsYXRpb24ueSA6IG9sZFRyYW5zbGF0aW9uLnlcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2ZWN0b3JzLnJvdGF0aW9uID0gKG5ld1JvdGF0aW9uID09IHVuZGVmaW5lZCkgPyBvbGRSb3RhdGlvbiA6IG5ld1JvdGF0aW9uO1xyXG5cclxuICAgICAgaWYgKG5ld1NjYWxpbmcpIHtcclxuICAgICAgICB2ZWN0b3JzLnNjYWxpbmcgPSBuZXcgVmVjdG9yMihcclxuICAgICAgICAgIG5ld1NjYWxpbmcueCAhPSB1bmRlZmluZWQgPyBuZXdTY2FsaW5nLnggOiBvbGRTY2FsaW5nLngsXHJcbiAgICAgICAgICBuZXdTY2FsaW5nLnkgIT0gdW5kZWZpbmVkID8gbmV3U2NhbGluZy55IDogb2xkU2NhbGluZy55XHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVE9ETzogcG9zc2libGUgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIHdoZW4gb25seSBvbmUgb3IgdHdvIGNvbXBvbmVudHMgY2hhbmdlLCB0aGVuIHVzZSBvbGQgbWF0cml4IGluc3RlYWQgb2YgSURFTlRJVFkgYW5kIHRyYW5zZm9ybSBieSBkaWZmZXJlbmNlcy9xdW90aWVudHNcclxuICAgICAgbGV0IG1hdHJpeDogTWF0cml4M3gzID0gTWF0cml4M3gzLklERU5USVRZKCk7XHJcbiAgICAgIGlmICh2ZWN0b3JzLnRyYW5zbGF0aW9uKVxyXG4gICAgICAgIG1hdHJpeC50cmFuc2xhdGUodmVjdG9ycy50cmFuc2xhdGlvbik7XHJcbiAgICAgIGlmICh2ZWN0b3JzLnJvdGF0aW9uKSB7XHJcbiAgICAgICAgbWF0cml4LnJvdGF0ZSh2ZWN0b3JzLnJvdGF0aW9uKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodmVjdG9ycy5zY2FsaW5nKVxyXG4gICAgICAgIG1hdHJpeC5zY2FsZSh2ZWN0b3JzLnNjYWxpbmcpO1xyXG4gICAgICB0aGlzLnNldChtYXRyaXgpO1xyXG5cclxuICAgICAgdGhpcy52ZWN0b3JzID0gdmVjdG9ycztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvckF0dHJpYnV0ZVR5cGVzKF9tdXRhdG9yOiBNdXRhdG9yKTogTXV0YXRvckF0dHJpYnV0ZVR5cGVzIHtcclxuICAgICAgbGV0IHR5cGVzOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMgPSB7fTtcclxuICAgICAgaWYgKF9tdXRhdG9yLnRyYW5zbGF0aW9uKSB0eXBlcy50cmFuc2xhdGlvbiA9IFwiVmVjdG9yMlwiO1xyXG4gICAgICBpZiAoX211dGF0b3Iucm90YXRpb24pIHR5cGVzLnJvdGF0aW9uID0gXCJudW1iZXJcIjtcclxuICAgICAgaWYgKF9tdXRhdG9yLnNjYWxpbmcpIHR5cGVzLnNjYWxpbmcgPSBcIlZlY3RvcjJcIjtcclxuICAgICAgcmV0dXJuIHR5cGVzO1xyXG4gICAgfVxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHsvKiogKi8gfVxyXG5cclxuICAgIHByaXZhdGUgcmVzZXRDYWNoZSgpOiB2b2lkIHtcclxuICAgICAgdGhpcy52ZWN0b3JzID0geyB0cmFuc2xhdGlvbjogbnVsbCwgcm90YXRpb246IG51bGwsIHNjYWxpbmc6IG51bGwgfTtcclxuICAgICAgdGhpcy5tdXRhdG9yID0gbnVsbDtcclxuICAgIH1cclxuICB9XHJcbiAgLy8jZW5kcmVnaW9uXHJcblxyXG59XHJcbiIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG5cclxuICAvKipcclxuICAgKiBSZXByZXNlbnRzIHRoZSBtYXRyaXggYXMgdHJhbnNsYXRpb24sIHJvdGF0aW9uIGFuZCBzY2FsaW5nIHZlY3RvciwgYmVpbmcgY2FsY3VsYXRlZCBmcm9tIHRoZSBtYXRyaXhcclxuICAgKi9cclxuICBpbnRlcmZhY2UgVmVjdG9yUmVwcmVzZW50YXRpb24ge1xyXG4gICAgdHJhbnNsYXRpb246IFZlY3RvcjM7XHJcbiAgICByb3RhdGlvbjogVmVjdG9yMztcclxuICAgIHNjYWxpbmc6IFZlY3RvcjM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdG9yZXMgYSA0eDQgdHJhbnNmb3JtYXRpb24gbWF0cml4IGFuZCBwcm92aWRlcyBvcGVyYXRpb25zIGZvciBpdC5cclxuICAgKiBgYGBwbGFpbnRleHRcclxuICAgKiBbIDAsIDEsIDIsIDMgXSDihpAgcm93IHZlY3RvciB4XHJcbiAgICogWyA0LCA1LCA2LCA3IF0g4oaQIHJvdyB2ZWN0b3IgeVxyXG4gICAqIFsgOCwgOSwxMCwxMSBdIOKGkCByb3cgdmVjdG9yIHpcclxuICAgKiBbMTIsMTMsMTQsMTUgXSDihpAgdHJhbnNsYXRpb25cclxuICAgKiAgICAgICAgICAgIOKGkSAgaG9tb2dlbmVvdXMgY29sdW1uXHJcbiAgICogYGBgXHJcbiAgICogQGF1dGhvcnMgSmFzY2hhIEthcmFnw7ZsLCBIRlUsIDIwMTkgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG5cclxuICBleHBvcnQgY2xhc3MgTWF0cml4NHg0IGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZSB7XHJcbiAgICBwcml2YXRlIGRhdGE6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpOyAvLyBUaGUgZGF0YSBvZiB0aGUgbWF0cml4LlxyXG4gICAgcHJpdmF0ZSBtdXRhdG9yOiBNdXRhdG9yID0gbnVsbDsgLy8gcHJlcGFyZWQgZm9yIG9wdGltaXphdGlvbiwga2VlcCBtdXRhdG9yIHRvIHJlZHVjZSByZWR1bmRhbnQgY2FsY3VsYXRpb24gYW5kIGZvciBjb21wYXJpc29uLiBTZXQgdG8gbnVsbCB3aGVuIGRhdGEgY2hhbmdlcyFcclxuICAgIHByaXZhdGUgdmVjdG9yczogVmVjdG9yUmVwcmVzZW50YXRpb247IC8vIHZlY3RvciByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG1hdHJpeFxyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5kYXRhLnNldChbXHJcbiAgICAgICAgMSwgMCwgMCwgMCxcclxuICAgICAgICAwLCAxLCAwLCAwLFxyXG4gICAgICAgIDAsIDAsIDEsIDAsXHJcbiAgICAgICAgMCwgMCwgMCwgMVxyXG4gICAgICBdKTtcclxuICAgICAgdGhpcy5yZXNldENhY2hlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogLSBnZXQ6IGEgY29weSBvZiB0aGUgY2FsY3VsYXRlZCB0cmFuc2xhdGlvbiB2ZWN0b3IgICBcclxuICAgICAqIC0gc2V0OiBlZmZlY3QgdGhlIG1hdHJpeCBpZ25vcmluZyBpdHMgcm90YXRpb24gYW5kIHNjYWxpbmdcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCB0cmFuc2xhdGlvbigpOiBWZWN0b3IzIHtcclxuICAgICAgaWYgKCF0aGlzLnZlY3RvcnMudHJhbnNsYXRpb24pIHtcclxuICAgICAgICB0aGlzLnZlY3RvcnMudHJhbnNsYXRpb24gPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XHJcbiAgICAgICAgdGhpcy52ZWN0b3JzLnRyYW5zbGF0aW9uLnNldCh0aGlzLmRhdGFbMTJdLCB0aGlzLmRhdGFbMTNdLCB0aGlzLmRhdGFbMTRdKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy52ZWN0b3JzLnRyYW5zbGF0aW9uLmNvcHk7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHRyYW5zbGF0aW9uKF90cmFuc2xhdGlvbjogVmVjdG9yMykge1xyXG4gICAgICB0aGlzLmRhdGEuc2V0KF90cmFuc2xhdGlvbi5nZXQoKSwgMTIpO1xyXG4gICAgICAvLyBubyBmdWxsIGNhY2hlIHJlc2V0IHJlcXVpcmVkXHJcbiAgICAgIHRoaXMudmVjdG9ycy50cmFuc2xhdGlvbiA9IF90cmFuc2xhdGlvbi5jb3B5O1xyXG4gICAgICB0aGlzLm11dGF0b3IgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBcclxuICAgICAqIC0gZ2V0OiBhIGNvcHkgb2YgdGhlIGNhbGN1bGF0ZWQgcm90YXRpb24gdmVjdG9yICAgXHJcbiAgICAgKiAtIHNldDogZWZmZWN0IHRoZSBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCByb3RhdGlvbigpOiBWZWN0b3IzIHtcclxuICAgICAgaWYgKCF0aGlzLnZlY3RvcnMucm90YXRpb24pXHJcbiAgICAgICAgdGhpcy52ZWN0b3JzLnJvdGF0aW9uID0gdGhpcy5nZXRFdWxlckFuZ2xlcygpO1xyXG4gICAgICByZXR1cm4gdGhpcy52ZWN0b3JzLnJvdGF0aW9uLmNvcHk7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHJvdGF0aW9uKF9yb3RhdGlvbjogVmVjdG9yMykge1xyXG4gICAgICB0aGlzLm11dGF0ZSh7IFwicm90YXRpb25cIjogX3JvdGF0aW9uIH0pO1xyXG4gICAgICB0aGlzLnJlc2V0Q2FjaGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiAtIGdldDogYSBjb3B5IG9mIHRoZSBjYWxjdWxhdGVkIHNjYWxlIHZlY3RvciAgIFxyXG4gICAgICogLSBzZXQ6IGVmZmVjdCB0aGUgbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgc2NhbGluZygpOiBWZWN0b3IzIHtcclxuICAgICAgaWYgKCF0aGlzLnZlY3RvcnMuc2NhbGluZykge1xyXG4gICAgICAgIHRoaXMudmVjdG9ycy5zY2FsaW5nID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xyXG4gICAgICAgIHRoaXMudmVjdG9ycy5zY2FsaW5nLnNldChcclxuICAgICAgICAgIE1hdGguaHlwb3QodGhpcy5kYXRhWzBdLCB0aGlzLmRhdGFbMV0sIHRoaXMuZGF0YVsyXSksXHJcbiAgICAgICAgICBNYXRoLmh5cG90KHRoaXMuZGF0YVs0XSwgdGhpcy5kYXRhWzVdLCB0aGlzLmRhdGFbNl0pLFxyXG4gICAgICAgICAgTWF0aC5oeXBvdCh0aGlzLmRhdGFbOF0sIHRoaXMuZGF0YVs5XSwgdGhpcy5kYXRhWzEwXSlcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLnZlY3RvcnMuc2NhbGluZy5jb3B5O1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBzY2FsaW5nKF9zY2FsaW5nOiBWZWN0b3IzKSB7XHJcbiAgICAgIHRoaXMubXV0YXRlKHsgXCJzY2FsaW5nXCI6IF9zY2FsaW5nIH0pO1xyXG4gICAgICB0aGlzLnJlc2V0Q2FjaGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gU1RBVElDU1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZSBhIG5ldyBpZGVudGl0eSBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBJREVOVElUWSgpOiBNYXRyaXg0eDQge1xyXG4gICAgICAvLyBjb25zdCByZXN1bHQ6IE1hdHJpeDR4NCA9IG5ldyBNYXRyaXg0eDQoKTtcclxuICAgICAgY29uc3QgcmVzdWx0OiBNYXRyaXg0eDQgPSBSZWN5Y2xlci5nZXQoTWF0cml4NHg0KTtcclxuICAgICAgcmVzdWx0LmRhdGEuc2V0KFtcclxuICAgICAgICAxLCAwLCAwLCAwLFxyXG4gICAgICAgIDAsIDEsIDAsIDAsXHJcbiAgICAgICAgMCwgMCwgMSwgMCxcclxuICAgICAgICAwLCAwLCAwLCAxXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgYW5kIHJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdHdvIHBhc3NlZCBtYXRyaWNlcy5cclxuICAgICAqIEBwYXJhbSBfYSBUaGUgbWF0cml4IHRvIG11bHRpcGx5LlxyXG4gICAgICogQHBhcmFtIF9iIFRoZSBtYXRyaXggdG8gbXVsdGlwbHkgYnkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgTVVMVElQTElDQVRJT04oX2E6IE1hdHJpeDR4NCwgX2I6IE1hdHJpeDR4NCk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIGxldCBhOiBGbG9hdDMyQXJyYXkgPSBfYS5kYXRhO1xyXG4gICAgICBsZXQgYjogRmxvYXQzMkFycmF5ID0gX2IuZGF0YTtcclxuICAgICAgLy8gbGV0IG1hdHJpeDogTWF0cml4NHg0ID0gbmV3IE1hdHJpeDR4NCgpO1xyXG4gICAgICBjb25zdCBtYXRyaXg6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLmdldChNYXRyaXg0eDQpO1xyXG4gICAgICBsZXQgYTAwOiBudW1iZXIgPSBhWzAgKiA0ICsgMF07XHJcbiAgICAgIGxldCBhMDE6IG51bWJlciA9IGFbMCAqIDQgKyAxXTtcclxuICAgICAgbGV0IGEwMjogbnVtYmVyID0gYVswICogNCArIDJdO1xyXG4gICAgICBsZXQgYTAzOiBudW1iZXIgPSBhWzAgKiA0ICsgM107XHJcbiAgICAgIGxldCBhMTA6IG51bWJlciA9IGFbMSAqIDQgKyAwXTtcclxuICAgICAgbGV0IGExMTogbnVtYmVyID0gYVsxICogNCArIDFdO1xyXG4gICAgICBsZXQgYTEyOiBudW1iZXIgPSBhWzEgKiA0ICsgMl07XHJcbiAgICAgIGxldCBhMTM6IG51bWJlciA9IGFbMSAqIDQgKyAzXTtcclxuICAgICAgbGV0IGEyMDogbnVtYmVyID0gYVsyICogNCArIDBdO1xyXG4gICAgICBsZXQgYTIxOiBudW1iZXIgPSBhWzIgKiA0ICsgMV07XHJcbiAgICAgIGxldCBhMjI6IG51bWJlciA9IGFbMiAqIDQgKyAyXTtcclxuICAgICAgbGV0IGEyMzogbnVtYmVyID0gYVsyICogNCArIDNdO1xyXG4gICAgICBsZXQgYTMwOiBudW1iZXIgPSBhWzMgKiA0ICsgMF07XHJcbiAgICAgIGxldCBhMzE6IG51bWJlciA9IGFbMyAqIDQgKyAxXTtcclxuICAgICAgbGV0IGEzMjogbnVtYmVyID0gYVszICogNCArIDJdO1xyXG4gICAgICBsZXQgYTMzOiBudW1iZXIgPSBhWzMgKiA0ICsgM107XHJcbiAgICAgIGxldCBiMDA6IG51bWJlciA9IGJbMCAqIDQgKyAwXTtcclxuICAgICAgbGV0IGIwMTogbnVtYmVyID0gYlswICogNCArIDFdO1xyXG4gICAgICBsZXQgYjAyOiBudW1iZXIgPSBiWzAgKiA0ICsgMl07XHJcbiAgICAgIGxldCBiMDM6IG51bWJlciA9IGJbMCAqIDQgKyAzXTtcclxuICAgICAgbGV0IGIxMDogbnVtYmVyID0gYlsxICogNCArIDBdO1xyXG4gICAgICBsZXQgYjExOiBudW1iZXIgPSBiWzEgKiA0ICsgMV07XHJcbiAgICAgIGxldCBiMTI6IG51bWJlciA9IGJbMSAqIDQgKyAyXTtcclxuICAgICAgbGV0IGIxMzogbnVtYmVyID0gYlsxICogNCArIDNdO1xyXG4gICAgICBsZXQgYjIwOiBudW1iZXIgPSBiWzIgKiA0ICsgMF07XHJcbiAgICAgIGxldCBiMjE6IG51bWJlciA9IGJbMiAqIDQgKyAxXTtcclxuICAgICAgbGV0IGIyMjogbnVtYmVyID0gYlsyICogNCArIDJdO1xyXG4gICAgICBsZXQgYjIzOiBudW1iZXIgPSBiWzIgKiA0ICsgM107XHJcbiAgICAgIGxldCBiMzA6IG51bWJlciA9IGJbMyAqIDQgKyAwXTtcclxuICAgICAgbGV0IGIzMTogbnVtYmVyID0gYlszICogNCArIDFdO1xyXG4gICAgICBsZXQgYjMyOiBudW1iZXIgPSBiWzMgKiA0ICsgMl07XHJcbiAgICAgIGxldCBiMzM6IG51bWJlciA9IGJbMyAqIDQgKyAzXTtcclxuICAgICAgbWF0cml4LmRhdGEuc2V0KFxyXG4gICAgICAgIFtcclxuICAgICAgICAgIGIwMCAqIGEwMCArIGIwMSAqIGExMCArIGIwMiAqIGEyMCArIGIwMyAqIGEzMCxcclxuICAgICAgICAgIGIwMCAqIGEwMSArIGIwMSAqIGExMSArIGIwMiAqIGEyMSArIGIwMyAqIGEzMSxcclxuICAgICAgICAgIGIwMCAqIGEwMiArIGIwMSAqIGExMiArIGIwMiAqIGEyMiArIGIwMyAqIGEzMixcclxuICAgICAgICAgIGIwMCAqIGEwMyArIGIwMSAqIGExMyArIGIwMiAqIGEyMyArIGIwMyAqIGEzMyxcclxuICAgICAgICAgIGIxMCAqIGEwMCArIGIxMSAqIGExMCArIGIxMiAqIGEyMCArIGIxMyAqIGEzMCxcclxuICAgICAgICAgIGIxMCAqIGEwMSArIGIxMSAqIGExMSArIGIxMiAqIGEyMSArIGIxMyAqIGEzMSxcclxuICAgICAgICAgIGIxMCAqIGEwMiArIGIxMSAqIGExMiArIGIxMiAqIGEyMiArIGIxMyAqIGEzMixcclxuICAgICAgICAgIGIxMCAqIGEwMyArIGIxMSAqIGExMyArIGIxMiAqIGEyMyArIGIxMyAqIGEzMyxcclxuICAgICAgICAgIGIyMCAqIGEwMCArIGIyMSAqIGExMCArIGIyMiAqIGEyMCArIGIyMyAqIGEzMCxcclxuICAgICAgICAgIGIyMCAqIGEwMSArIGIyMSAqIGExMSArIGIyMiAqIGEyMSArIGIyMyAqIGEzMSxcclxuICAgICAgICAgIGIyMCAqIGEwMiArIGIyMSAqIGExMiArIGIyMiAqIGEyMiArIGIyMyAqIGEzMixcclxuICAgICAgICAgIGIyMCAqIGEwMyArIGIyMSAqIGExMyArIGIyMiAqIGEyMyArIGIyMyAqIGEzMyxcclxuICAgICAgICAgIGIzMCAqIGEwMCArIGIzMSAqIGExMCArIGIzMiAqIGEyMCArIGIzMyAqIGEzMCxcclxuICAgICAgICAgIGIzMCAqIGEwMSArIGIzMSAqIGExMSArIGIzMiAqIGEyMSArIGIzMyAqIGEzMSxcclxuICAgICAgICAgIGIzMCAqIGEwMiArIGIzMSAqIGExMiArIGIzMiAqIGEyMiArIGIzMyAqIGEzMixcclxuICAgICAgICAgIGIzMCAqIGEwMyArIGIzMSAqIGExMyArIGIzMiAqIGEyMyArIGIzMyAqIGEzM1xyXG4gICAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gbWF0cml4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgYW5kIHJldHVybnMgdGhlIGludmVyc2Ugb2YgYSBwYXNzZWQgbWF0cml4LlxyXG4gICAgICogQHBhcmFtIF9tYXRyaXggVGhlIG1hdHJpeCB0byBjb21wdXRlIHRoZSBpbnZlcnNlIG9mLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIElOVkVSU0lPTihfbWF0cml4OiBNYXRyaXg0eDQpOiBNYXRyaXg0eDQge1xyXG4gICAgICBsZXQgbTogRmxvYXQzMkFycmF5ID0gX21hdHJpeC5kYXRhO1xyXG4gICAgICBsZXQgbTAwOiBudW1iZXIgPSBtWzAgKiA0ICsgMF07XHJcbiAgICAgIGxldCBtMDE6IG51bWJlciA9IG1bMCAqIDQgKyAxXTtcclxuICAgICAgbGV0IG0wMjogbnVtYmVyID0gbVswICogNCArIDJdO1xyXG4gICAgICBsZXQgbTAzOiBudW1iZXIgPSBtWzAgKiA0ICsgM107XHJcbiAgICAgIGxldCBtMTA6IG51bWJlciA9IG1bMSAqIDQgKyAwXTtcclxuICAgICAgbGV0IG0xMTogbnVtYmVyID0gbVsxICogNCArIDFdO1xyXG4gICAgICBsZXQgbTEyOiBudW1iZXIgPSBtWzEgKiA0ICsgMl07XHJcbiAgICAgIGxldCBtMTM6IG51bWJlciA9IG1bMSAqIDQgKyAzXTtcclxuICAgICAgbGV0IG0yMDogbnVtYmVyID0gbVsyICogNCArIDBdO1xyXG4gICAgICBsZXQgbTIxOiBudW1iZXIgPSBtWzIgKiA0ICsgMV07XHJcbiAgICAgIGxldCBtMjI6IG51bWJlciA9IG1bMiAqIDQgKyAyXTtcclxuICAgICAgbGV0IG0yMzogbnVtYmVyID0gbVsyICogNCArIDNdO1xyXG4gICAgICBsZXQgbTMwOiBudW1iZXIgPSBtWzMgKiA0ICsgMF07XHJcbiAgICAgIGxldCBtMzE6IG51bWJlciA9IG1bMyAqIDQgKyAxXTtcclxuICAgICAgbGV0IG0zMjogbnVtYmVyID0gbVszICogNCArIDJdO1xyXG4gICAgICBsZXQgbTMzOiBudW1iZXIgPSBtWzMgKiA0ICsgM107XHJcbiAgICAgIGxldCB0bXAwOiBudW1iZXIgPSBtMjIgKiBtMzM7XHJcbiAgICAgIGxldCB0bXAxOiBudW1iZXIgPSBtMzIgKiBtMjM7XHJcbiAgICAgIGxldCB0bXAyOiBudW1iZXIgPSBtMTIgKiBtMzM7XHJcbiAgICAgIGxldCB0bXAzOiBudW1iZXIgPSBtMzIgKiBtMTM7XHJcbiAgICAgIGxldCB0bXA0OiBudW1iZXIgPSBtMTIgKiBtMjM7XHJcbiAgICAgIGxldCB0bXA1OiBudW1iZXIgPSBtMjIgKiBtMTM7XHJcbiAgICAgIGxldCB0bXA2OiBudW1iZXIgPSBtMDIgKiBtMzM7XHJcbiAgICAgIGxldCB0bXA3OiBudW1iZXIgPSBtMzIgKiBtMDM7XHJcbiAgICAgIGxldCB0bXA4OiBudW1iZXIgPSBtMDIgKiBtMjM7XHJcbiAgICAgIGxldCB0bXA5OiBudW1iZXIgPSBtMjIgKiBtMDM7XHJcbiAgICAgIGxldCB0bXAxMDogbnVtYmVyID0gbTAyICogbTEzO1xyXG4gICAgICBsZXQgdG1wMTE6IG51bWJlciA9IG0xMiAqIG0wMztcclxuICAgICAgbGV0IHRtcDEyOiBudW1iZXIgPSBtMjAgKiBtMzE7XHJcbiAgICAgIGxldCB0bXAxMzogbnVtYmVyID0gbTMwICogbTIxO1xyXG4gICAgICBsZXQgdG1wMTQ6IG51bWJlciA9IG0xMCAqIG0zMTtcclxuICAgICAgbGV0IHRtcDE1OiBudW1iZXIgPSBtMzAgKiBtMTE7XHJcbiAgICAgIGxldCB0bXAxNjogbnVtYmVyID0gbTEwICogbTIxO1xyXG4gICAgICBsZXQgdG1wMTc6IG51bWJlciA9IG0yMCAqIG0xMTtcclxuICAgICAgbGV0IHRtcDE4OiBudW1iZXIgPSBtMDAgKiBtMzE7XHJcbiAgICAgIGxldCB0bXAxOTogbnVtYmVyID0gbTMwICogbTAxO1xyXG4gICAgICBsZXQgdG1wMjA6IG51bWJlciA9IG0wMCAqIG0yMTtcclxuICAgICAgbGV0IHRtcDIxOiBudW1iZXIgPSBtMjAgKiBtMDE7XHJcbiAgICAgIGxldCB0bXAyMjogbnVtYmVyID0gbTAwICogbTExO1xyXG4gICAgICBsZXQgdG1wMjM6IG51bWJlciA9IG0xMCAqIG0wMTtcclxuXHJcbiAgICAgIGxldCB0MDogbnVtYmVyID0gKHRtcDAgKiBtMTEgKyB0bXAzICogbTIxICsgdG1wNCAqIG0zMSkgLVxyXG4gICAgICAgICh0bXAxICogbTExICsgdG1wMiAqIG0yMSArIHRtcDUgKiBtMzEpO1xyXG5cclxuICAgICAgbGV0IHQxOiBudW1iZXIgPSAodG1wMSAqIG0wMSArIHRtcDYgKiBtMjEgKyB0bXA5ICogbTMxKSAtXHJcbiAgICAgICAgKHRtcDAgKiBtMDEgKyB0bXA3ICogbTIxICsgdG1wOCAqIG0zMSk7XHJcbiAgICAgIGxldCB0MjogbnVtYmVyID0gKHRtcDIgKiBtMDEgKyB0bXA3ICogbTExICsgdG1wMTAgKiBtMzEpIC1cclxuICAgICAgICAodG1wMyAqIG0wMSArIHRtcDYgKiBtMTEgKyB0bXAxMSAqIG0zMSk7XHJcbiAgICAgIGxldCB0MzogbnVtYmVyID0gKHRtcDUgKiBtMDEgKyB0bXA4ICogbTExICsgdG1wMTEgKiBtMjEpIC1cclxuICAgICAgICAodG1wNCAqIG0wMSArIHRtcDkgKiBtMTEgKyB0bXAxMCAqIG0yMSk7XHJcblxyXG4gICAgICBsZXQgZDogbnVtYmVyID0gMS4wIC8gKG0wMCAqIHQwICsgbTEwICogdDEgKyBtMjAgKiB0MiArIG0zMCAqIHQzKTtcclxuXHJcbiAgICAgIC8vIGxldCBtYXRyaXg6IE1hdHJpeDR4NCA9IG5ldyBNYXRyaXg0eDQ7XHJcbiAgICAgIGNvbnN0IG1hdHJpeDogTWF0cml4NHg0ID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDR4NCk7XHJcbiAgICAgIG1hdHJpeC5kYXRhLnNldChbXHJcbiAgICAgICAgZCAqIHQwLCAvLyBbMF1cclxuICAgICAgICBkICogdDEsIC8vIFsxXVxyXG4gICAgICAgIGQgKiB0MiwgLy8gWzJdXHJcbiAgICAgICAgZCAqIHQzLCAvLyBbM11cclxuICAgICAgICBkICogKCh0bXAxICogbTEwICsgdG1wMiAqIG0yMCArIHRtcDUgKiBtMzApIC0gKHRtcDAgKiBtMTAgKyB0bXAzICogbTIwICsgdG1wNCAqIG0zMCkpLCAgICAgICAgLy8gWzRdXHJcbiAgICAgICAgZCAqICgodG1wMCAqIG0wMCArIHRtcDcgKiBtMjAgKyB0bXA4ICogbTMwKSAtICh0bXAxICogbTAwICsgdG1wNiAqIG0yMCArIHRtcDkgKiBtMzApKSwgICAgICAgIC8vIFs1XVxyXG4gICAgICAgIGQgKiAoKHRtcDMgKiBtMDAgKyB0bXA2ICogbTEwICsgdG1wMTEgKiBtMzApIC0gKHRtcDIgKiBtMDAgKyB0bXA3ICogbTEwICsgdG1wMTAgKiBtMzApKSwgICAgICAvLyBbNl1cclxuICAgICAgICBkICogKCh0bXA0ICogbTAwICsgdG1wOSAqIG0xMCArIHRtcDEwICogbTIwKSAtICh0bXA1ICogbTAwICsgdG1wOCAqIG0xMCArIHRtcDExICogbTIwKSksICAgICAgLy8gWzddXHJcbiAgICAgICAgZCAqICgodG1wMTIgKiBtMTMgKyB0bXAxNSAqIG0yMyArIHRtcDE2ICogbTMzKSAtICh0bXAxMyAqIG0xMyArIHRtcDE0ICogbTIzICsgdG1wMTcgKiBtMzMpKSwgIC8vIFs4XVxyXG4gICAgICAgIGQgKiAoKHRtcDEzICogbTAzICsgdG1wMTggKiBtMjMgKyB0bXAyMSAqIG0zMykgLSAodG1wMTIgKiBtMDMgKyB0bXAxOSAqIG0yMyArIHRtcDIwICogbTMzKSksICAvLyBbOV1cclxuICAgICAgICBkICogKCh0bXAxNCAqIG0wMyArIHRtcDE5ICogbTEzICsgdG1wMjIgKiBtMzMpIC0gKHRtcDE1ICogbTAzICsgdG1wMTggKiBtMTMgKyB0bXAyMyAqIG0zMykpLCAgLy8gWzEwXVxyXG4gICAgICAgIGQgKiAoKHRtcDE3ICogbTAzICsgdG1wMjAgKiBtMTMgKyB0bXAyMyAqIG0yMykgLSAodG1wMTYgKiBtMDMgKyB0bXAyMSAqIG0xMyArIHRtcDIyICogbTIzKSksICAvLyBbMTFdXHJcbiAgICAgICAgZCAqICgodG1wMTQgKiBtMjIgKyB0bXAxNyAqIG0zMiArIHRtcDEzICogbTEyKSAtICh0bXAxNiAqIG0zMiArIHRtcDEyICogbTEyICsgdG1wMTUgKiBtMjIpKSwgIC8vIFsxMl1cclxuICAgICAgICBkICogKCh0bXAyMCAqIG0zMiArIHRtcDEyICogbTAyICsgdG1wMTkgKiBtMjIpIC0gKHRtcDE4ICogbTIyICsgdG1wMjEgKiBtMzIgKyB0bXAxMyAqIG0wMikpLCAgLy8gWzEzXVxyXG4gICAgICAgIGQgKiAoKHRtcDE4ICogbTEyICsgdG1wMjMgKiBtMzIgKyB0bXAxNSAqIG0wMikgLSAodG1wMjIgKiBtMzIgKyB0bXAxNCAqIG0wMiArIHRtcDE5ICogbTEyKSksICAvLyBbMTRdXHJcbiAgICAgICAgZCAqICgodG1wMjIgKiBtMjIgKyB0bXAxNiAqIG0wMiArIHRtcDIxICogbTEyKSAtICh0bXAyMCAqIG0xMiArIHRtcDIzICogbTIyICsgdG1wMTcgKiBtMDIpKSAgLy8gWzE1XVxyXG4gICAgICBdKTtcclxuICAgICAgcmV0dXJuIG1hdHJpeDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIGFuZCByZXR1cm5zIGEgbWF0cml4IHdpdGggdGhlIGdpdmVuIHRyYW5zbGF0aW9uLCBpdHMgei1heGlzIHBvaW50aW5nIGRpcmVjdGx5IGF0IHRoZSBnaXZlbiB0YXJnZXQsXHJcbiAgICAgKiBhbmQgYSBtaW5pbWFsIGFuZ2xlIGJldHdlZW4gaXRzIHktYXhpcyBhbmQgdGhlIGdpdmVuIHVwLVZlY3RvciwgcmVzcGV0aXZlbHkgY2FsY3VsYXRpbmcgeWF3IGFuZCBwaXRjaC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBMT09LX0FUKF90cmFuc2xhdGlvbjogVmVjdG9yMywgX3RhcmdldDogVmVjdG9yMywgX3VwOiBWZWN0b3IzID0gVmVjdG9yMy5ZKCkpOiBNYXRyaXg0eDQge1xyXG4gICAgICAvLyBjb25zdCBtYXRyaXg6IE1hdHJpeDR4NCA9IG5ldyBNYXRyaXg0eDQ7XHJcbiAgICAgIGNvbnN0IG1hdHJpeDogTWF0cml4NHg0ID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDR4NCk7XHJcbiAgICAgIGxldCB6QXhpczogVmVjdG9yMyA9IFZlY3RvcjMuRElGRkVSRU5DRShfdGFyZ2V0LCBfdHJhbnNsYXRpb24pO1xyXG4gICAgICB6QXhpcy5ub3JtYWxpemUoKTtcclxuICAgICAgbGV0IHhBeGlzOiBWZWN0b3IzID0gVmVjdG9yMy5OT1JNQUxJWkFUSU9OKFZlY3RvcjMuQ1JPU1MoX3VwLCB6QXhpcykpO1xyXG4gICAgICBsZXQgeUF4aXM6IFZlY3RvcjMgPSBWZWN0b3IzLk5PUk1BTElaQVRJT04oVmVjdG9yMy5DUk9TUyh6QXhpcywgeEF4aXMpKTtcclxuICAgICAgbWF0cml4LmRhdGEuc2V0KFxyXG4gICAgICAgIFtcclxuICAgICAgICAgIHhBeGlzLngsIHhBeGlzLnksIHhBeGlzLnosIDAsXHJcbiAgICAgICAgICB5QXhpcy54LCB5QXhpcy55LCB5QXhpcy56LCAwLFxyXG4gICAgICAgICAgekF4aXMueCwgekF4aXMueSwgekF4aXMueiwgMCxcclxuICAgICAgICAgIF90cmFuc2xhdGlvbi54LFxyXG4gICAgICAgICAgX3RyYW5zbGF0aW9uLnksXHJcbiAgICAgICAgICBfdHJhbnNsYXRpb24ueixcclxuICAgICAgICAgIDFcclxuICAgICAgICBdKTtcclxuICAgICAgcmV0dXJuIG1hdHJpeDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIGFuZCByZXR1cm5zIGEgbWF0cml4IHdpdGggdGhlIGdpdmVuIHRyYW5zbGF0aW9uLCBpdHMgeS1heGlzIG1hdGNoaW5nIHRoZSBnaXZlbiB1cC12ZWN0b3JcclxuICAgICAqIGFuZCBpdHMgei1heGlzIGZhY2luZyB0b3dhcmRzIHRoZSBnaXZlbiB0YXJnZXQgYXQgYSBtaW5pbWFsIGFuZ2xlLCByZXNwZXRpdmVseSBjYWxjdWxhdGluZyB5YXcgb25seS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBTSE9XX1RPKF90cmFuc2xhdGlvbjogVmVjdG9yMywgX3RhcmdldDogVmVjdG9yMywgX3VwOiBWZWN0b3IzID0gVmVjdG9yMy5ZKCkpOiBNYXRyaXg0eDQge1xyXG4gICAgICAvLyBjb25zdCBtYXRyaXg6IE1hdHJpeDR4NCA9IG5ldyBNYXRyaXg0eDQ7XHJcbiAgICAgIGNvbnN0IG1hdHJpeDogTWF0cml4NHg0ID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDR4NCk7XHJcbiAgICAgIGxldCB6QXhpczogVmVjdG9yMyA9IFZlY3RvcjMuRElGRkVSRU5DRShfdGFyZ2V0LCBfdHJhbnNsYXRpb24pO1xyXG4gICAgICB6QXhpcy5ub3JtYWxpemUoKTtcclxuICAgICAgbGV0IHhBeGlzOiBWZWN0b3IzID0gVmVjdG9yMy5OT1JNQUxJWkFUSU9OKFZlY3RvcjMuQ1JPU1MoX3VwLCB6QXhpcykpO1xyXG4gICAgICAvLyBsZXQgeUF4aXM6IFZlY3RvcjMgPSBWZWN0b3IzLk5PUk1BTElaQVRJT04oVmVjdG9yMy5DUk9TUyh6QXhpcywgeEF4aXMpKTtcclxuICAgICAgekF4aXMgPSBWZWN0b3IzLk5PUk1BTElaQVRJT04oVmVjdG9yMy5DUk9TUyh4QXhpcywgX3VwKSk7XHJcbiAgICAgIG1hdHJpeC5kYXRhLnNldChcclxuICAgICAgICBbXHJcbiAgICAgICAgICB4QXhpcy54LCB4QXhpcy55LCB4QXhpcy56LCAwLFxyXG4gICAgICAgICAgX3VwLngsIF91cC55LCBfdXAueiwgMCxcclxuICAgICAgICAgIHpBeGlzLngsIHpBeGlzLnksIHpBeGlzLnosIDAsXHJcbiAgICAgICAgICBfdHJhbnNsYXRpb24ueCxcclxuICAgICAgICAgIF90cmFuc2xhdGlvbi55LFxyXG4gICAgICAgICAgX3RyYW5zbGF0aW9uLnosXHJcbiAgICAgICAgICAxXHJcbiAgICAgICAgXSk7XHJcbiAgICAgIHJldHVybiBtYXRyaXg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbWF0cml4IHRoYXQgdHJhbnNsYXRlcyBjb29yZGluYXRlcyBhbG9uZyB0aGUgeC0sIHktIGFuZCB6LWF4aXMgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgVFJBTlNMQVRJT04oX3RyYW5zbGF0ZTogVmVjdG9yMyk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIC8vIGxldCBtYXRyaXg6IE1hdHJpeDR4NCA9IG5ldyBNYXRyaXg0eDQ7XHJcbiAgICAgIGNvbnN0IG1hdHJpeDogTWF0cml4NHg0ID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDR4NCk7XHJcbiAgICAgIG1hdHJpeC5kYXRhLnNldChbXHJcbiAgICAgICAgMSwgMCwgMCwgMCxcclxuICAgICAgICAwLCAxLCAwLCAwLFxyXG4gICAgICAgIDAsIDAsIDEsIDAsXHJcbiAgICAgICAgX3RyYW5zbGF0ZS54LCBfdHJhbnNsYXRlLnksIF90cmFuc2xhdGUueiwgMVxyXG4gICAgICBdKTtcclxuICAgICAgcmV0dXJuIG1hdHJpeDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBtYXRyaXggdGhhdCByb3RhdGVzIGNvb3JkaW5hdGVzIG9uIHRoZSB4LWF4aXMgd2hlbiBtdWx0aXBsaWVkIGJ5LlxyXG4gICAgICogQHBhcmFtIF9hbmdsZUluRGVncmVlcyBUaGUgdmFsdWUgb2YgdGhlIHJvdGF0aW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFJPVEFUSU9OX1goX2FuZ2xlSW5EZWdyZWVzOiBudW1iZXIpOiBNYXRyaXg0eDQge1xyXG4gICAgICAvLyBjb25zdCBtYXRyaXg6IE1hdHJpeDR4NCA9IG5ldyBNYXRyaXg0eDQ7XHJcbiAgICAgIGNvbnN0IG1hdHJpeDogTWF0cml4NHg0ID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDR4NCk7XHJcbiAgICAgIGxldCBhbmdsZUluUmFkaWFuczogbnVtYmVyID0gX2FuZ2xlSW5EZWdyZWVzICogTWF0aC5QSSAvIDE4MDtcclxuICAgICAgbGV0IHNpbjogbnVtYmVyID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xyXG4gICAgICBsZXQgY29zOiBudW1iZXIgPSBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyk7XHJcbiAgICAgIG1hdHJpeC5kYXRhLnNldChbXHJcbiAgICAgICAgMSwgMCwgMCwgMCxcclxuICAgICAgICAwLCBjb3MsIHNpbiwgMCxcclxuICAgICAgICAwLCAtc2luLCBjb3MsIDAsXHJcbiAgICAgICAgMCwgMCwgMCwgMVxyXG4gICAgICBdKTtcclxuICAgICAgcmV0dXJuIG1hdHJpeDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBtYXRyaXggdGhhdCByb3RhdGVzIGNvb3JkaW5hdGVzIG9uIHRoZSB5LWF4aXMgd2hlbiBtdWx0aXBsaWVkIGJ5LlxyXG4gICAgICogQHBhcmFtIF9hbmdsZUluRGVncmVlcyBUaGUgdmFsdWUgb2YgdGhlIHJvdGF0aW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFJPVEFUSU9OX1koX2FuZ2xlSW5EZWdyZWVzOiBudW1iZXIpOiBNYXRyaXg0eDQge1xyXG4gICAgICAvLyBjb25zdCBtYXRyaXg6IE1hdHJpeDR4NCA9IG5ldyBNYXRyaXg0eDQ7XHJcbiAgICAgIGxldCBtYXRyaXg6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLmdldChNYXRyaXg0eDQpO1xyXG4gICAgICBsZXQgYW5nbGVJblJhZGlhbnM6IG51bWJlciA9IF9hbmdsZUluRGVncmVlcyAqIE1hdGguUEkgLyAxODA7XHJcbiAgICAgIGxldCBzaW46IG51bWJlciA9IE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKTtcclxuICAgICAgbGV0IGNvczogbnVtYmVyID0gTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpO1xyXG4gICAgICBtYXRyaXguZGF0YS5zZXQoW1xyXG4gICAgICAgIGNvcywgMCwgLXNpbiwgMCxcclxuICAgICAgICAwLCAxLCAwLCAwLFxyXG4gICAgICAgIHNpbiwgMCwgY29zLCAwLFxyXG4gICAgICAgIDAsIDAsIDAsIDFcclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiBtYXRyaXg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbWF0cml4IHRoYXQgcm90YXRlcyBjb29yZGluYXRlcyBvbiB0aGUgei1heGlzIHdoZW4gbXVsdGlwbGllZCBieS5cclxuICAgICAqIEBwYXJhbSBfYW5nbGVJbkRlZ3JlZXMgVGhlIHZhbHVlIG9mIHRoZSByb3RhdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBST1RBVElPTl9aKF9hbmdsZUluRGVncmVlczogbnVtYmVyKTogTWF0cml4NHg0IHtcclxuICAgICAgLy8gY29uc3QgbWF0cml4OiBNYXRyaXg0eDQgPSBuZXcgTWF0cml4NHg0O1xyXG4gICAgICBjb25zdCBtYXRyaXg6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLmdldChNYXRyaXg0eDQpO1xyXG4gICAgICBsZXQgYW5nbGVJblJhZGlhbnM6IG51bWJlciA9IF9hbmdsZUluRGVncmVlcyAqIE1hdGguUEkgLyAxODA7XHJcbiAgICAgIGxldCBzaW46IG51bWJlciA9IE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKTtcclxuICAgICAgbGV0IGNvczogbnVtYmVyID0gTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpO1xyXG4gICAgICBtYXRyaXguZGF0YS5zZXQoW1xyXG4gICAgICAgIGNvcywgc2luLCAwLCAwLFxyXG4gICAgICAgIC1zaW4sIGNvcywgMCwgMCxcclxuICAgICAgICAwLCAwLCAxLCAwLFxyXG4gICAgICAgIDAsIDAsIDAsIDFcclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiBtYXRyaXg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbWF0cml4IHRoYXQgc2NhbGVzIGNvb3JkaW5hdGVzIGFsb25nIHRoZSB4LSwgeS0gYW5kIHotYXhpcyBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFNDQUxJTkcoX3NjYWxhcjogVmVjdG9yMyk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIC8vIGNvbnN0IG1hdHJpeDogTWF0cml4NHg0ID0gbmV3IE1hdHJpeDR4NDtcclxuICAgICAgY29uc3QgbWF0cml4OiBNYXRyaXg0eDQgPSBSZWN5Y2xlci5nZXQoTWF0cml4NHg0KTtcclxuICAgICAgbWF0cml4LmRhdGEuc2V0KFtcclxuICAgICAgICBfc2NhbGFyLngsIDAsIDAsIDAsXHJcbiAgICAgICAgMCwgX3NjYWxhci55LCAwLCAwLFxyXG4gICAgICAgIDAsIDAsIF9zY2FsYXIueiwgMCxcclxuICAgICAgICAwLCAwLCAwLCAxXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gbWF0cml4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBtYXRyaXggcmVsYXRpdmUgdG8gdGhlIGdpdmVuIGJhc2UuXHJcbiAgICAgKiBJZiBrbm93biwgcGFzcyB0aGUgaW52ZXJzZSBvZiB0aGUgYmFzZSB0byBhdm9pZCB1bm5lY2Nlc2FyeSBjYWxjdWxhdGlvbiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBSRUxBVElWRShfbWF0cml4OiBNYXRyaXg0eDQsIF9iYXNlOiBNYXRyaXg0eDQsIF9pbnZlcnNlPzogTWF0cml4NHg0KTogTWF0cml4NHg0IHtcclxuICAgICAgbGV0IHJlc3VsdDogTWF0cml4NHg0ID0gX2ludmVyc2UgPyBfaW52ZXJzZSA6IE1hdHJpeDR4NC5JTlZFUlNJT04oX2Jhc2UpO1xyXG4gICAgICByZXN1bHQgPSBNYXRyaXg0eDQuTVVMVElQTElDQVRJT04ocmVzdWx0LCBfbWF0cml4KTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBQUk9KRUNUSU9OU1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBhbmQgcmV0dXJucyBhIG1hdHJpeCB0aGF0IGFwcGxpZXMgcGVyc3BlY3RpdmUgdG8gYW4gb2JqZWN0LCBpZiBpdHMgdHJhbnNmb3JtIGlzIG11bHRpcGxpZWQgYnkgaXQuXHJcbiAgICAgKiBAcGFyYW0gX2FzcGVjdCBUaGUgYXNwZWN0IHJhdGlvIGJldHdlZW4gd2lkdGggYW5kIGhlaWdodCBvZiBwcm9qZWN0aW9uc3BhY2UuKERlZmF1bHQgPSBjYW52YXMuY2xpZW50V2lkdGggLyBjYW52YXMuQ2xpZW50SGVpZ2h0KVxyXG4gICAgICogQHBhcmFtIF9maWVsZE9mVmlld0luRGVncmVlcyBUaGUgZmllbGQgb2YgdmlldyBpbiBEZWdyZWVzLiAoRGVmYXVsdCA9IDQ1KVxyXG4gICAgICogQHBhcmFtIF9uZWFyIFRoZSBuZWFyIGNsaXBzcGFjZSBib3JkZXIgb24gdGhlIHotYXhpcy5cclxuICAgICAqIEBwYXJhbSBfZmFyIFRoZSBmYXIgY2xpcHNwYWNlIGJvcmRlciBvbiB0aGUgei1heGlzLlxyXG4gICAgICogQHBhcmFtIF9kaXJlY3Rpb24gVGhlIHBsYW5lIG9uIHdoaWNoIHRoZSBmaWVsZE9mVmlldy1BbmdsZSBpcyBnaXZlbiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBQUk9KRUNUSU9OX0NFTlRSQUwoX2FzcGVjdDogbnVtYmVyLCBfZmllbGRPZlZpZXdJbkRlZ3JlZXM6IG51bWJlciwgX25lYXI6IG51bWJlciwgX2ZhcjogbnVtYmVyLCBfZGlyZWN0aW9uOiBGSUVMRF9PRl9WSUVXKTogTWF0cml4NHg0IHtcclxuICAgICAgLy9UT0RPOiBjYW1lcmEgbG9va3MgZG93biBuZWdhdGl2ZSB6LWRpcmVjdGlvbiwgc2hvdWxkIGJlIHBvc2l0aXZlXHJcbiAgICAgIGxldCBmaWVsZE9mVmlld0luUmFkaWFuczogbnVtYmVyID0gX2ZpZWxkT2ZWaWV3SW5EZWdyZWVzICogTWF0aC5QSSAvIDE4MDtcclxuICAgICAgbGV0IGY6IG51bWJlciA9IE1hdGgudGFuKDAuNSAqIChNYXRoLlBJIC0gZmllbGRPZlZpZXdJblJhZGlhbnMpKTtcclxuICAgICAgbGV0IHJhbmdlSW52OiBudW1iZXIgPSAxLjAgLyAoX25lYXIgLSBfZmFyKTtcclxuICAgICAgLy8gY29uc3QgbWF0cml4OiBNYXRyaXg0eDQgPSBuZXcgTWF0cml4NHg0O1xyXG4gICAgICBjb25zdCBtYXRyaXg6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLmdldChNYXRyaXg0eDQpO1xyXG4gICAgICBtYXRyaXguZGF0YS5zZXQoW1xyXG4gICAgICAgIGYsIDAsIDAsIDAsXHJcbiAgICAgICAgMCwgZiwgMCwgMCxcclxuICAgICAgICAwLCAwLCAoX25lYXIgKyBfZmFyKSAqIHJhbmdlSW52LCAtMSxcclxuICAgICAgICAwLCAwLCBfbmVhciAqIF9mYXIgKiByYW5nZUludiAqIDIsIDBcclxuICAgICAgXSk7XHJcblxyXG4gICAgICBpZiAoX2RpcmVjdGlvbiA9PSBGSUVMRF9PRl9WSUVXLkRJQUdPTkFMKSB7XHJcbiAgICAgICAgX2FzcGVjdCA9IE1hdGguc3FydChfYXNwZWN0KTtcclxuICAgICAgICBtYXRyaXguZGF0YVswXSA9IGYgLyBfYXNwZWN0O1xyXG4gICAgICAgIG1hdHJpeC5kYXRhWzVdID0gZiAqIF9hc3BlY3Q7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoX2RpcmVjdGlvbiA9PSBGSUVMRF9PRl9WSUVXLlZFUlRJQ0FMKVxyXG4gICAgICAgIG1hdHJpeC5kYXRhWzBdID0gZiAvIF9hc3BlY3Q7XHJcbiAgICAgIGVsc2UgLy9GT1ZfRElSRUNUSU9OLkhPUklaT05UQUxcclxuICAgICAgICBtYXRyaXguZGF0YVs1XSA9IGYgKiBfYXNwZWN0O1xyXG5cclxuICAgICAgLy8gSEFDSzogbWF0cml4IHNob3VsZCBsb29rIGluIHBvc2l0aXZlIHotZGlyZWN0aW9uLCBwcmVmZXJhYmx5IHRoZSBtYXRyaXggc2hvdWxkIGJlIGNhbGN1bGF0ZWQgbGlrZSB0aGF0IHJpZ2h0IGF3YXlcclxuICAgICAgbWF0cml4LnJvdGF0ZVkoMTgwKTtcclxuXHJcbiAgICAgIHJldHVybiBtYXRyaXg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBhbmQgcmV0dXJucyBhIG1hdHJpeCB0aGF0IGFwcGxpZXMgb3J0aG9ncmFwaGljIHByb2plY3Rpb24gdG8gYW4gb2JqZWN0LCBpZiBpdHMgdHJhbnNmb3JtIGlzIG11bHRpcGxpZWQgYnkgaXQuXHJcbiAgICAgKiBAcGFyYW0gX2xlZnQgVGhlIHBvc2l0aW9udmFsdWUgb2YgdGhlIHByb2plY3Rpb25zcGFjZSdzIGxlZnQgYm9yZGVyLlxyXG4gICAgICogQHBhcmFtIF9yaWdodCBUaGUgcG9zaXRpb252YWx1ZSBvZiB0aGUgcHJvamVjdGlvbnNwYWNlJ3MgcmlnaHQgYm9yZGVyLlxyXG4gICAgICogQHBhcmFtIF9ib3R0b20gVGhlIHBvc2l0aW9udmFsdWUgb2YgdGhlIHByb2plY3Rpb25zcGFjZSdzIGJvdHRvbSBib3JkZXIuXHJcbiAgICAgKiBAcGFyYW0gX3RvcCBUaGUgcG9zaXRpb252YWx1ZSBvZiB0aGUgcHJvamVjdGlvbnNwYWNlJ3MgdG9wIGJvcmRlci5cclxuICAgICAqIEBwYXJhbSBfbmVhciBUaGUgcG9zaXRpb252YWx1ZSBvZiB0aGUgcHJvamVjdGlvbnNwYWNlJ3MgbmVhciBib3JkZXIuXHJcbiAgICAgKiBAcGFyYW0gX2ZhciBUaGUgcG9zaXRpb252YWx1ZSBvZiB0aGUgcHJvamVjdGlvbnNwYWNlJ3MgZmFyIGJvcmRlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFBST0pFQ1RJT05fT1JUSE9HUkFQSElDKF9sZWZ0OiBudW1iZXIsIF9yaWdodDogbnVtYmVyLCBfYm90dG9tOiBudW1iZXIsIF90b3A6IG51bWJlciwgX25lYXI6IG51bWJlciA9IC00MDAsIF9mYXI6IG51bWJlciA9IDQwMCk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIC8vIGNvbnN0IG1hdHJpeDogTWF0cml4NHg0ID0gbmV3IE1hdHJpeDR4NDtcclxuICAgICAgY29uc3QgbWF0cml4OiBNYXRyaXg0eDQgPSBSZWN5Y2xlci5nZXQoTWF0cml4NHg0KTtcclxuICAgICAgbWF0cml4LmRhdGEuc2V0KFtcclxuICAgICAgICAyIC8gKF9yaWdodCAtIF9sZWZ0KSwgMCwgMCwgMCxcclxuICAgICAgICAwLCAyIC8gKF90b3AgLSBfYm90dG9tKSwgMCwgMCxcclxuICAgICAgICAwLCAwLCAyIC8gKF9uZWFyIC0gX2ZhciksIDAsXHJcbiAgICAgICAgKF9sZWZ0ICsgX3JpZ2h0KSAvIChfbGVmdCAtIF9yaWdodCksXHJcbiAgICAgICAgKF9ib3R0b20gKyBfdG9wKSAvIChfYm90dG9tIC0gX3RvcCksXHJcbiAgICAgICAgKF9uZWFyICsgX2ZhcikgLyAoX25lYXIgLSBfZmFyKSxcclxuICAgICAgICAxXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gbWF0cml4O1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIFJvdGF0aW9uXHJcbiAgICAvKipcclxuICAgICAqIFJvdGF0ZSB0aGlzIG1hdHJpeCBieSBnaXZlbiB2ZWN0b3IgaW4gdGhlIG9yZGVyIFosIFksIFguIFJpZ2h0IGhhbmQgcm90YXRpb24gaXMgdXNlZCwgdGh1bWIgcG9pbnRzIGluIGF4aXMgZGlyZWN0aW9uLCBmaW5nZXJzIGN1cmxpbmcgaW5kaWNhdGUgcm90YXRpb25cclxuICAgICAqIFRoZSByb3RhdGlvbiBpcyBhcHBlbmRlZCB0byBhbHJlYWR5IGFwcGxpZWQgdHJhbnNmb3JtcywgdGh1cyBtdWx0aXBsaWVkIGZyb20gdGhlIHJpZ2h0LiBTZXQgX2Zyb21MZWZ0IHRvIHRydWUgdG8gc3dpdGNoIGFuZCBwdXQgaXQgaW4gZnJvbnQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByb3RhdGUoX2J5OiBWZWN0b3IzLCBfZnJvbUxlZnQ6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xyXG4gICAgICB0aGlzLnJvdGF0ZVooX2J5LnosIF9mcm9tTGVmdCk7XHJcbiAgICAgIHRoaXMucm90YXRlWShfYnkueSwgX2Zyb21MZWZ0KTtcclxuICAgICAgdGhpcy5yb3RhdGVYKF9ieS54LCBfZnJvbUxlZnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHJvdGF0aW9uIGFyb3VuZCB0aGUgeC1heGlzIHRvIHRoaXMgbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByb3RhdGVYKF9hbmdsZUluRGVncmVlczogbnVtYmVyLCBfZnJvbUxlZnQ6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xyXG4gICAgICBsZXQgcm90YXRpb246IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5ST1RBVElPTl9YKF9hbmdsZUluRGVncmVlcyk7XHJcbiAgICAgIHRoaXMubXVsdGlwbHkocm90YXRpb24sIF9mcm9tTGVmdCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKHJvdGF0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSByb3RhdGlvbiBhcm91bmQgdGhlIHktYXhpcyB0byB0aGlzIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcm90YXRlWShfYW5nbGVJbkRlZ3JlZXM6IG51bWJlciwgX2Zyb21MZWZ0OiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcclxuICAgICAgbGV0IHJvdGF0aW9uOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuUk9UQVRJT05fWShfYW5nbGVJbkRlZ3JlZXMpO1xyXG4gICAgICB0aGlzLm11bHRpcGx5KHJvdGF0aW9uLCBfZnJvbUxlZnQpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShyb3RhdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgcm90YXRpb24gYXJvdW5kIHRoZSB6LWF4aXMgdG8gdGhpcyBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgcHVibGljIHJvdGF0ZVooX2FuZ2xlSW5EZWdyZWVzOiBudW1iZXIsIF9mcm9tTGVmdDogYm9vbGVhbiA9IGZhbHNlKTogdm9pZCB7XHJcbiAgICAgIGxldCByb3RhdGlvbjogTWF0cml4NHg0ID0gTWF0cml4NHg0LlJPVEFUSU9OX1ooX2FuZ2xlSW5EZWdyZWVzKTtcclxuICAgICAgdGhpcy5tdWx0aXBseShyb3RhdGlvbiwgX2Zyb21MZWZ0KTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUocm90YXRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRqdXN0cyB0aGUgcm90YXRpb24gb2YgdGhpcyBtYXRyaXggdG8gcG9pbnQgdGhlIHotYXhpcyBkaXJlY3RseSBhdCB0aGUgZ2l2ZW4gdGFyZ2V0IGFuZCB0aWx0cyBpdCB0byBhY2NvcmQgd2l0aCB0aGUgZ2l2ZW4gdXAgdmVjdG9yLFxyXG4gICAgICogcmVzcGVjdGl2ZWx5IGNhbGN1bGF0aW5nIHlhdyBhbmQgcGl0Y2guIElmIG5vIHVwIHZlY3RvciBpcyBnaXZlbiwgdGhlIHByZXZpb3VzIHVwLXZlY3RvciBpcyB1c2VkLiBcclxuICAgICAqIFdoZW4gX3ByZXNlcnZlU2NhbGluZyBpcyBmYWxzZSwgYSByb3RhdGVkIGlkZW50aXR5IG1hdHJpeCBpcyB0aGUgcmVzdWx0LiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGxvb2tBdChfdGFyZ2V0OiBWZWN0b3IzLCBfdXA/OiBWZWN0b3IzLCBfcHJlc2VydmVTY2FsaW5nOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xyXG4gICAgICBpZiAoIV91cClcclxuICAgICAgICBfdXAgPSB0aGlzLmdldFkoKTtcclxuXHJcbiAgICAgIGNvbnN0IG1hdHJpeDogTWF0cml4NHg0ID0gTWF0cml4NHg0LkxPT0tfQVQodGhpcy50cmFuc2xhdGlvbiwgX3RhcmdldCwgX3VwKTtcclxuICAgICAgaWYgKF9wcmVzZXJ2ZVNjYWxpbmcpXHJcbiAgICAgICAgbWF0cml4LnNjYWxlKHRoaXMuc2NhbGluZyk7XHJcbiAgICAgIHRoaXMuc2V0KG1hdHJpeCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG1hdHJpeCk7XHJcbiAgICB9XHJcbiAgICAvLyBUT0RPOiB0ZXN0aW5nIGxvb2thdCB0aGF0IHJlYWxseSBqdXN0IHJvdGF0ZXMgdGhlIG1hdHJpeCByYXRoZXIgdGhhbiBjcmVhdGluZyBhIG5ldyBvbmVcclxuICAgIHB1YmxpYyBsb29rQXRSb3RhdGUoX3RhcmdldDogVmVjdG9yMywgX3VwPzogVmVjdG9yMywgX3ByZXNlcnZlU2NhbGluZzogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcclxuICAgICAgaWYgKCFfdXApXHJcbiAgICAgICAgX3VwID0gdGhpcy5nZXRZKCk7XHJcblxyXG4gICAgICBsZXQgc2NhbGluZzogVmVjdG9yMyA9IHRoaXMuc2NhbGluZztcclxuICAgICAgbGV0IGRpZmZlcmVuY2U6IFZlY3RvcjMgPSBWZWN0b3IzLkRJRkZFUkVOQ0UoX3RhcmdldCwgdGhpcy50cmFuc2xhdGlvbik7XHJcbiAgICAgIGRpZmZlcmVuY2Uubm9ybWFsaXplKCk7XHJcbiAgICAgIGxldCBjb3M6IG51bWJlciA9IFZlY3RvcjMuRE9UKFZlY3RvcjMuTk9STUFMSVpBVElPTih0aGlzLmdldFooKSksIGRpZmZlcmVuY2UpO1xyXG4gICAgICBsZXQgc2luOiBudW1iZXIgPSBWZWN0b3IzLkRPVChWZWN0b3IzLk5PUk1BTElaQVRJT04odGhpcy5nZXRYKCkpLCBkaWZmZXJlbmNlKTtcclxuICAgICAgY29uc29sZS5sb2coc2luLCBjb3MpO1xyXG4gICAgICBsZXQgbXR4Um90YXRpb246IE1hdHJpeDR4NCA9IFJlY3ljbGVyLmJvcnJvdyhNYXRyaXg0eDQpO1xyXG4gICAgICBtdHhSb3RhdGlvbi5kYXRhLnNldChbXHJcbiAgICAgICAgY29zLCAwLCAtc2luLCAwLFxyXG4gICAgICAgIDAsIDEsIDAsIDAsXHJcbiAgICAgICAgc2luLCAwLCBjb3MsIDAsXHJcbiAgICAgICAgMCwgMCwgMCwgMVxyXG4gICAgICBdKTtcclxuICAgICAgdGhpcy5tdWx0aXBseShtdHhSb3RhdGlvbiwgZmFsc2UpO1xyXG5cclxuICAgICAgY29zID0gVmVjdG9yMy5ET1QoVmVjdG9yMy5OT1JNQUxJWkFUSU9OKHRoaXMuZ2V0WigpKSwgZGlmZmVyZW5jZSk7XHJcbiAgICAgIHNpbiA9IC1WZWN0b3IzLkRPVChWZWN0b3IzLk5PUk1BTElaQVRJT04odGhpcy5nZXRZKCkpLCBkaWZmZXJlbmNlKTtcclxuICAgICAgY29uc29sZS5sb2coc2luLCBjb3MpO1xyXG4gICAgICBtdHhSb3RhdGlvbi5kYXRhLnNldChbXHJcbiAgICAgICAgMSwgMCwgMCwgMCxcclxuICAgICAgICAwLCBjb3MsIHNpbiwgMCxcclxuICAgICAgICAwLCAtc2luLCBjb3MsIDAsXHJcbiAgICAgICAgMCwgMCwgMCwgMVxyXG4gICAgICBdKTtcclxuICAgICAgdGhpcy5tdWx0aXBseShtdHhSb3RhdGlvbiwgZmFsc2UpO1xyXG4gICAgICB0aGlzLnNjYWxpbmcgPSBzY2FsaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRqdXN0cyB0aGUgcm90YXRpb24gb2YgdGhpcyBtYXRyaXggdG8gbWF0Y2ggaXRzIHktYXhpcyB3aXRoIHRoZSBnaXZlbiB1cC12ZWN0b3IgYW5kIGZhY2luZyBpdHMgei1heGlzIHRvd2FyZCB0aGUgZ2l2ZW4gdGFyZ2V0IGF0IG1pbmltYWwgYW5nbGUsXHJcbiAgICAgKiByZXNwZWN0aXZlbHkgY2FsY3VsYXRpbmcgeWF3IG9ubHkuIElmIG5vIHVwIHZlY3RvciBpcyBnaXZlbiwgdGhlIHByZXZpb3VzIHVwLXZlY3RvciBpcyB1c2VkLiBcclxuICAgICAqIFdoZW4gX3ByZXNlcnZlU2NhbGluZyBpcyBmYWxzZSwgYSByb3RhdGVkIGlkZW50aXR5IG1hdHJpeCBpcyB0aGUgcmVzdWx0LiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNob3dUbyhfdGFyZ2V0OiBWZWN0b3IzLCBfdXA/OiBWZWN0b3IzLCBfcHJlc2VydmVTY2FsaW5nOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xyXG4gICAgICBpZiAoIV91cClcclxuICAgICAgICBfdXAgPSB0aGlzLmdldFkoKTtcclxuXHJcbiAgICAgIGNvbnN0IG1hdHJpeDogTWF0cml4NHg0ID0gTWF0cml4NHg0LlNIT1dfVE8odGhpcy50cmFuc2xhdGlvbiwgX3RhcmdldCwgX3VwKTtcclxuICAgICAgaWYgKF9wcmVzZXJ2ZVNjYWxpbmcpXHJcbiAgICAgICAgbWF0cml4LnNjYWxlKHRoaXMuc2NhbGluZyk7XHJcbiAgICAgIHRoaXMuc2V0KG1hdHJpeCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG1hdHJpeCk7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNsYXRpb25cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgdHJhbnNsYXRpb24gYnkgdGhlIGdpdmVuIHZlY3RvciB0byB0aGlzIG1hdHJpeC5cclxuICAgICAqIElmIF9sb2NhbCBpcyB0cnVlLCB0cmFuc2xhdGlvbiBvY2N1cnMgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHJvdGF0aW9uIGFuZCBzY2FsaW5nIG9mIHRoaXMgbWF0cml4LFxyXG4gICAgICogYWNjb3JkaW5nIHRvIHRoZSBwYXJlbnQgb3RoZXJ3aXNlLiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHRyYW5zbGF0ZShfYnk6IFZlY3RvcjMsIF9sb2NhbDogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcclxuICAgICAgaWYgKF9sb2NhbCkge1xyXG4gICAgICAgIGxldCB0cmFuc2xhdGlvbjogTWF0cml4NHg0ID0gTWF0cml4NHg0LlRSQU5TTEFUSU9OKF9ieSk7XHJcbiAgICAgICAgdGhpcy5tdWx0aXBseSh0cmFuc2xhdGlvbik7XHJcbiAgICAgICAgUmVjeWNsZXIuc3RvcmUodHJhbnNsYXRpb24pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuZGF0YVsxMl0gKz0gX2J5Lng7XHJcbiAgICAgICAgdGhpcy5kYXRhWzEzXSArPSBfYnkueTtcclxuICAgICAgICB0aGlzLmRhdGFbMTRdICs9IF9ieS56O1xyXG4gICAgICAgIHRoaXMubXV0YXRvciA9IG51bGw7XHJcbiAgICAgICAgaWYgKHRoaXMudmVjdG9ycy50cmFuc2xhdGlvbilcclxuICAgICAgICAgIFJlY3ljbGVyLnN0b3JlKHRoaXMudmVjdG9ycy50cmFuc2xhdGlvbik7XHJcbiAgICAgICAgdGhpcy52ZWN0b3JzLnRyYW5zbGF0aW9uID0gbnVsbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gY29uc3QgbWF0cml4OiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuTVVMVElQTElDQVRJT04odGhpcywgTWF0cml4NHg0LlRSQU5TTEFUSU9OKF9ieSkpO1xyXG4gICAgICAvLyAvLyBUT0RPOiBwb3NzaWJsZSBvcHRpbWl6YXRpb24sIHRyYW5zbGF0aW9uIG1heSBhbHRlciBtdXRhdG9yIGluc3RlYWQgb2YgZGVsZXRpbmcgaXQuXHJcbiAgICAgIC8vIHRoaXMuc2V0KG1hdHJpeCk7XHJcbiAgICAgIC8vIFJlY3ljbGVyLnN0b3JlKG1hdHJpeCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSB0cmFuc2xhdGlvbiBhbG9uZyB0aGUgeC1heGlzIGJ5IHRoZSBnaXZlbiBhbW91bnQgdG8gdGhpcyBtYXRyaXggXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0cmFuc2xhdGVYKF94OiBudW1iZXIsIF9sb2NhbDogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcclxuICAgICAgbGV0IHRyYW5zbGF0aW9uOiBWZWN0b3IzID0gVmVjdG9yMy5YKF94KTtcclxuICAgICAgdGhpcy50cmFuc2xhdGUodHJhbnNsYXRpb24sIF9sb2NhbCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKHRyYW5zbGF0aW9uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgdHJhbnNsYXRpb24gYWxvbmcgdGhlIHktYXhpcyBieSB0aGUgZ2l2ZW4gYW1vdW50IHRvIHRoaXMgbWF0cml4IFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdHJhbnNsYXRlWShfeTogbnVtYmVyLCBfbG9jYWw6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XHJcbiAgICAgIGxldCB0cmFuc2xhdGlvbjogVmVjdG9yMyA9IFZlY3RvcjMuWShfeSk7XHJcbiAgICAgIHRoaXMudHJhbnNsYXRlKHRyYW5zbGF0aW9uLCBfbG9jYWwpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZSh0cmFuc2xhdGlvbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIHRyYW5zbGF0aW9uIGFsb25nIHRoZSB6LWF4aXMgYnkgdGhlIGdpdmVuIGFtb3VudCB0byB0aGlzIG1hdHJpeCBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHRyYW5zbGF0ZVooX3o6IG51bWJlciwgX2xvY2FsOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xyXG4gICAgICBsZXQgdHJhbnNsYXRpb246IFZlY3RvcjMgPSBWZWN0b3IzLlooX3opO1xyXG4gICAgICB0aGlzLnRyYW5zbGF0ZSh0cmFuc2xhdGlvbiwgX2xvY2FsKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUodHJhbnNsYXRpb24pO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIFNjYWxpbmdcclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgc2NhbGluZyBieSB0aGUgZ2l2ZW4gdmVjdG9yIHRvIHRoaXMgbWF0cml4IFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2NhbGUoX2J5OiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIGNvbnN0IG1hdHJpeDogTWF0cml4NHg0ID0gTWF0cml4NHg0Lk1VTFRJUExJQ0FUSU9OKHRoaXMsIE1hdHJpeDR4NC5TQ0FMSU5HKF9ieSkpO1xyXG4gICAgICB0aGlzLnNldChtYXRyaXgpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShtYXRyaXgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgc2NhbGluZyBhbG9uZyB0aGUgeC1heGlzIGJ5IHRoZSBnaXZlbiBhbW91bnQgdG8gdGhpcyBtYXRyaXggXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzY2FsZVgoX2J5OiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgbGV0IHZlY3RvcjogVmVjdG9yMyA9IFJlY3ljbGVyLmJvcnJvdyhWZWN0b3IzKTtcclxuICAgICAgdmVjdG9yLnNldChfYnksIDEsIDEpO1xyXG4gICAgICB0aGlzLnNjYWxlKHZlY3Rvcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIHNjYWxpbmcgYWxvbmcgdGhlIHktYXhpcyBieSB0aGUgZ2l2ZW4gYW1vdW50IHRvIHRoaXMgbWF0cml4IFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2NhbGVZKF9ieTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIGxldCB2ZWN0b3I6IFZlY3RvcjMgPSBSZWN5Y2xlci5ib3Jyb3coVmVjdG9yMyk7XHJcbiAgICAgIHZlY3Rvci5zZXQoMSwgX2J5LCAxKTtcclxuICAgICAgdGhpcy5zY2FsZSh2ZWN0b3IpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSBzY2FsaW5nIGFsb25nIHRoZSB6LWF4aXMgYnkgdGhlIGdpdmVuIGFtb3VudCB0byB0aGlzIG1hdHJpeCBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNjYWxlWihfYnk6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICBsZXQgdmVjdG9yOiBWZWN0b3IzID0gUmVjeWNsZXIuYm9ycm93KFZlY3RvcjMpO1xyXG4gICAgICB2ZWN0b3Iuc2V0KDEsIDEsIF9ieSk7XHJcbiAgICAgIHRoaXMuc2NhbGUodmVjdG9yKTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2Zvcm1hdGlvblxyXG4gICAgLyoqXHJcbiAgICAgKiBNdWx0aXBseSB0aGlzIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgcHVibGljIG11bHRpcGx5KF9tYXRyaXg6IE1hdHJpeDR4NCwgX2Zyb21MZWZ0OiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcclxuICAgICAgY29uc3QgbWF0cml4OiBNYXRyaXg0eDQgPSBfZnJvbUxlZnQgPyBNYXRyaXg0eDQuTVVMVElQTElDQVRJT04oX21hdHJpeCwgdGhpcykgOiBNYXRyaXg0eDQuTVVMVElQTElDQVRJT04odGhpcywgX21hdHJpeCk7XHJcbiAgICAgIHRoaXMuc2V0KG1hdHJpeCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG1hdHJpeCk7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyBhbmQgcmV0dXJucyB0aGUgZXVsZXItYW5nbGVzIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCByb3RhdGlvbiBvZiB0aGlzIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0RXVsZXJBbmdsZXMoKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCBzY2FsaW5nOiBWZWN0b3IzID0gdGhpcy5zY2FsaW5nO1xyXG5cclxuICAgICAgbGV0IHMwOiBudW1iZXIgPSB0aGlzLmRhdGFbMF0gLyBzY2FsaW5nLng7XHJcbiAgICAgIGxldCBzMTogbnVtYmVyID0gdGhpcy5kYXRhWzFdIC8gc2NhbGluZy54O1xyXG4gICAgICBsZXQgczI6IG51bWJlciA9IHRoaXMuZGF0YVsyXSAvIHNjYWxpbmcueDtcclxuICAgICAgbGV0IHM2OiBudW1iZXIgPSB0aGlzLmRhdGFbNl0gLyBzY2FsaW5nLnk7XHJcbiAgICAgIGxldCBzMTA6IG51bWJlciA9IHRoaXMuZGF0YVsxMF0gLyBzY2FsaW5nLno7XHJcblxyXG4gICAgICBsZXQgc3k6IG51bWJlciA9IE1hdGguaHlwb3QoczAsIHMxKTsgLy8gcHJvYmFibHkgMi4gcGFyYW0gc2hvdWxkIGJlIHRoaXMuZGF0YVs0XSAvIHNjYWxpbmcueVxyXG5cclxuICAgICAgbGV0IHNpbmd1bGFyOiBib29sZWFuID0gc3kgPCAxZS02OyAvLyBJZlxyXG5cclxuICAgICAgbGV0IHgxOiBudW1iZXIsIHkxOiBudW1iZXIsIHoxOiBudW1iZXI7XHJcbiAgICAgIGxldCB4MjogbnVtYmVyLCB5MjogbnVtYmVyLCB6MjogbnVtYmVyO1xyXG5cclxuICAgICAgaWYgKCFzaW5ndWxhcikge1xyXG4gICAgICAgIHgxID0gTWF0aC5hdGFuMihzNiwgczEwKTtcclxuICAgICAgICB5MSA9IE1hdGguYXRhbjIoLXMyLCBzeSk7XHJcbiAgICAgICAgejEgPSBNYXRoLmF0YW4yKHMxLCBzMCk7XHJcblxyXG4gICAgICAgIHgyID0gTWF0aC5hdGFuMigtczYsIC1zMTApO1xyXG4gICAgICAgIHkyID0gTWF0aC5hdGFuMigtczIsIC1zeSk7XHJcbiAgICAgICAgejIgPSBNYXRoLmF0YW4yKC1zMSwgLXMwKTtcclxuXHJcbiAgICAgICAgaWYgKE1hdGguYWJzKHgyKSArIE1hdGguYWJzKHkyKSArIE1hdGguYWJzKHoyKSA8IE1hdGguYWJzKHgxKSArIE1hdGguYWJzKHkxKSArIE1hdGguYWJzKHoxKSkge1xyXG4gICAgICAgICAgeDEgPSB4MjtcclxuICAgICAgICAgIHkxID0geTI7XHJcbiAgICAgICAgICB6MSA9IHoyO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICB4MSA9IE1hdGguYXRhbjIoLXRoaXMuZGF0YVs5XSAvIHNjYWxpbmcueiwgdGhpcy5kYXRhWzVdIC8gc2NhbGluZy55KTtcclxuICAgICAgICB5MSA9IE1hdGguYXRhbjIoLXRoaXMuZGF0YVsyXSAvIHNjYWxpbmcueCwgc3kpO1xyXG4gICAgICAgIHoxID0gMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IHJvdGF0aW9uOiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xyXG4gICAgICByb3RhdGlvbi5zZXQoeDEsIHkxLCB6MSk7XHJcbiAgICAgIHJvdGF0aW9uLnNjYWxlKDE4MCAvIE1hdGguUEkpO1xyXG5cclxuICAgICAgcmV0dXJuIHJvdGF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgZWxlbWVudHMgb2YgdGhpcyBtYXRyaXggdG8gdGhlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQoX3RvOiBNYXRyaXg0eDQpOiB2b2lkIHtcclxuICAgICAgLy8gdGhpcy5kYXRhID0gX3RvLmdldCgpO1xyXG4gICAgICB0aGlzLmRhdGEuc2V0KF90by5kYXRhKTtcclxuICAgICAgdGhpcy5yZXNldENhY2hlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiBgxpIuTWF0cml4NHg0KHRyYW5zbGF0aW9uOiAke3RoaXMudHJhbnNsYXRpb24udG9TdHJpbmcoKX0sIHJvdGF0aW9uOiAke3RoaXMucm90YXRpb24udG9TdHJpbmcoKX0sIHNjYWxpbmc6ICR7dGhpcy5zY2FsaW5nLnRvU3RyaW5nKCl9YDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgZWxlbWVudHMgb2YgdGhpcyBtYXRyaXggYXMgYSBGbG9hdDMyQXJyYXlcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCgpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGNhcmRpbmFsIHgtYXhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0WCgpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgcmVzdWx0LnNldCh0aGlzLmRhdGFbMF0sIHRoaXMuZGF0YVsxXSwgdGhpcy5kYXRhWzJdKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGNhcmRpbmFsIHktYXhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0WSgpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgcmVzdWx0LnNldCh0aGlzLmRhdGFbNF0sIHRoaXMuZGF0YVs1XSwgdGhpcy5kYXRhWzZdKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGNhcmRpbmFsIHotYXhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0WigpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgcmVzdWx0LnNldCh0aGlzLmRhdGFbOF0sIHRoaXMuZGF0YVs5XSwgdGhpcy5kYXRhWzEwXSk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTd2FwcyB0aGUgdHdvIGNhcmRpbmFsIGF4aXMgYW5kIHJldmVyc2VzIHRoZSB0aGlyZCwgZWZmZWN0aXZlbHkgcm90YXRpbmcgdGhlIHRyYW5zZm9ybSAxODAgZGVncmVlcyBhcm91bmQgb25lIGFuZCA5MCBkZWdyZWVzIGFyb3VuZCBhIHNlY29uZCBheGlzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzd2FwWFkoKTogdm9pZCB7XHJcbiAgICAgIGxldCB0ZW1wOiBudW1iZXJbXSA9IFt0aGlzLmRhdGFbMF0sIHRoaXMuZGF0YVsxXSwgdGhpcy5kYXRhWzJdXTsgLy8gc3RvcmUgeC1heGlzXHJcbiAgICAgIHRoaXMuZGF0YS5zZXQoW3RoaXMuZGF0YVs0XSwgdGhpcy5kYXRhWzVdLCB0aGlzLmRhdGFbNl1dLCAwKTsgLy8gb3ZlcndyaXRlIHgtYXhpcyB3aXRoIHktYXhpc1xyXG4gICAgICB0aGlzLmRhdGEuc2V0KHRlbXAsIDQpOyAvLyBvdmVyd3JpdGUgWSB3aXRoIHRlbXBcclxuICAgICAgdGhpcy5kYXRhLnNldChbLXRoaXMuZGF0YVs4XSwgLXRoaXMuZGF0YVs5XSwgLXRoaXMuZGF0YVsxMF1dLCA4KTsgLy8gcmV2ZXJzZSB6LWF4aXNcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3dhcHMgdGhlIHR3byBjYXJkaW5hbCBheGlzIGFuZCByZXZlcnNlcyB0aGUgdGhpcmQsIGVmZmVjdGl2ZWx5IHJvdGF0aW5nIHRoZSB0cmFuc2Zvcm0gMTgwIGRlZ3JlZXMgYXJvdW5kIG9uZSBhbmQgOTAgZGVncmVlcyBhcm91bmQgYSBzZWNvbmQgYXhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3dhcFhaKCk6IHZvaWQge1xyXG4gICAgICBsZXQgdGVtcDogbnVtYmVyW10gPSBbdGhpcy5kYXRhWzBdLCB0aGlzLmRhdGFbMV0sIHRoaXMuZGF0YVsyXV07IC8vIHN0b3JlIHgtYXhpc1xyXG4gICAgICB0aGlzLmRhdGEuc2V0KFt0aGlzLmRhdGFbOF0sIHRoaXMuZGF0YVs5XSwgdGhpcy5kYXRhWzEwXV0sIDApOyAvLyBvdmVyd3JpdGUgeC1heGlzIHdpdGggei1heGlzXHJcbiAgICAgIHRoaXMuZGF0YS5zZXQodGVtcCwgOCk7IC8vIG92ZXJ3cml0ZSBaIHdpdGggdGVtcFxyXG4gICAgICB0aGlzLmRhdGEuc2V0KFstdGhpcy5kYXRhWzRdLCAtdGhpcy5kYXRhWzVdLCAtdGhpcy5kYXRhWzZdXSwgNCk7IC8vIHJldmVyc2UgeS1heGlzXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN3YXBzIHRoZSB0d28gY2FyZGluYWwgYXhpcyBhbmQgcmV2ZXJzZXMgdGhlIHRoaXJkLCBlZmZlY3RpdmVseSByb3RhdGluZyB0aGUgdHJhbnNmb3JtIDE4MCBkZWdyZWVzIGFyb3VuZCBvbmUgYW5kIDkwIGRlZ3JlZXMgYXJvdW5kIGEgc2Vjb25kIGF4aXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN3YXBZWigpOiB2b2lkIHtcclxuICAgICAgbGV0IHRlbXA6IG51bWJlcltdID0gW3RoaXMuZGF0YVs0XSwgdGhpcy5kYXRhWzVdLCB0aGlzLmRhdGFbNl1dOyAvLyBzdG9yZSB5LWF4aXNcclxuICAgICAgdGhpcy5kYXRhLnNldChbdGhpcy5kYXRhWzhdLCB0aGlzLmRhdGFbOV0sIHRoaXMuZGF0YVsxMF1dLCA0KTsgLy8gb3ZlcndyaXRlIHktYXhpcyB3aXRoIHotYXhpc1xyXG4gICAgICB0aGlzLmRhdGEuc2V0KHRlbXAsIDgpOyAvLyBvdmVyd3JpdGUgWiB3aXRoIHRlbXBcclxuICAgICAgdGhpcy5kYXRhLnNldChbLXRoaXMuZGF0YVswXSwgLXRoaXMuZGF0YVsxXSwgLXRoaXMuZGF0YVsyXV0sIDApOyAvLyByZXZlcnNlIHgtYXhpc1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGEgY29weSBvZiB0aGlzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgY29weSgpOiBNYXRyaXg0eDQge1xyXG4gICAgICBsZXQgY29weTogTWF0cml4NHg0ID0gbmV3IE1hdHJpeDR4NCgpO1xyXG4gICAgICBjb3B5LnNldCh0aGlzKTtcclxuICAgICAgcmV0dXJuIGNvcHk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFRyYW5zbGF0aW9uVG8oX3RhcmdldDogTWF0cml4NHg0KTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCBkaWZmZXJlbmNlOiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xyXG4gICAgICBkaWZmZXJlbmNlLnNldChfdGFyZ2V0LmRhdGFbMTJdIC0gdGhpcy5kYXRhWzEyXSwgX3RhcmdldC5kYXRhWzEzXSAtIHRoaXMuZGF0YVsxM10sIF90YXJnZXQuZGF0YVsxNF0gLSB0aGlzLmRhdGFbMTRdKTtcclxuICAgICAgcmV0dXJuIGRpZmZlcmVuY2U7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgLy8gVE9ETzogc2F2ZSB0cmFuc2xhdGlvbiwgcm90YXRpb24gYW5kIHNjYWxlIGFzIHZlY3RvcnMgZm9yIHJlYWRhYmlsaXR5IGFuZCBtYW5pcHVsYXRpb25cclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB0aGlzLmdldE11dGF0b3IoKTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBTZXJpYWxpemFibGUge1xyXG4gICAgICB0aGlzLm11dGF0ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xyXG4gICAgICBpZiAodGhpcy5tdXRhdG9yKVxyXG4gICAgICAgIHJldHVybiB0aGlzLm11dGF0b3I7XHJcblxyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHtcclxuICAgICAgICB0cmFuc2xhdGlvbjogdGhpcy50cmFuc2xhdGlvbi5nZXRNdXRhdG9yKCksXHJcbiAgICAgICAgcm90YXRpb246IHRoaXMucm90YXRpb24uZ2V0TXV0YXRvcigpLFxyXG4gICAgICAgIHNjYWxpbmc6IHRoaXMuc2NhbGluZy5nZXRNdXRhdG9yKClcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIGNhY2hlIG11dGF0b3JcclxuICAgICAgdGhpcy5tdXRhdG9yID0gbXV0YXRvcjtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICBsZXQgb2xkVHJhbnNsYXRpb246IFZlY3RvcjMgPSB0aGlzLnRyYW5zbGF0aW9uO1xyXG4gICAgICBsZXQgb2xkUm90YXRpb246IFZlY3RvcjMgPSB0aGlzLnJvdGF0aW9uO1xyXG4gICAgICBsZXQgb2xkU2NhbGluZzogVmVjdG9yMyA9IHRoaXMuc2NhbGluZztcclxuICAgICAgbGV0IG5ld1RyYW5zbGF0aW9uOiBWZWN0b3IzID0gPFZlY3RvcjM+X211dGF0b3JbXCJ0cmFuc2xhdGlvblwiXTtcclxuICAgICAgbGV0IG5ld1JvdGF0aW9uOiBWZWN0b3IzID0gPFZlY3RvcjM+X211dGF0b3JbXCJyb3RhdGlvblwiXTtcclxuICAgICAgbGV0IG5ld1NjYWxpbmc6IFZlY3RvcjMgPSA8VmVjdG9yMz5fbXV0YXRvcltcInNjYWxpbmdcIl07XHJcbiAgICAgIGxldCB2ZWN0b3JzOiBWZWN0b3JSZXByZXNlbnRhdGlvbiA9IHsgdHJhbnNsYXRpb246IG9sZFRyYW5zbGF0aW9uLCByb3RhdGlvbjogb2xkUm90YXRpb24sIHNjYWxpbmc6IG9sZFNjYWxpbmcgfTtcclxuICAgICAgaWYgKG5ld1RyYW5zbGF0aW9uKSB7XHJcbiAgICAgICAgdmVjdG9ycy50cmFuc2xhdGlvbiA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgICB2ZWN0b3JzLnRyYW5zbGF0aW9uLnNldChcclxuICAgICAgICAgIG5ld1RyYW5zbGF0aW9uLnggIT0gdW5kZWZpbmVkID8gbmV3VHJhbnNsYXRpb24ueCA6IG9sZFRyYW5zbGF0aW9uLngsXHJcbiAgICAgICAgICBuZXdUcmFuc2xhdGlvbi55ICE9IHVuZGVmaW5lZCA/IG5ld1RyYW5zbGF0aW9uLnkgOiBvbGRUcmFuc2xhdGlvbi55LFxyXG4gICAgICAgICAgbmV3VHJhbnNsYXRpb24ueiAhPSB1bmRlZmluZWQgPyBuZXdUcmFuc2xhdGlvbi56IDogb2xkVHJhbnNsYXRpb24uelxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG5ld1JvdGF0aW9uKSB7XHJcbiAgICAgICAgdmVjdG9ycy5yb3RhdGlvbiA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgICB2ZWN0b3JzLnJvdGF0aW9uLnNldChcclxuICAgICAgICAgIG5ld1JvdGF0aW9uLnggIT0gdW5kZWZpbmVkID8gbmV3Um90YXRpb24ueCA6IG9sZFJvdGF0aW9uLngsXHJcbiAgICAgICAgICBuZXdSb3RhdGlvbi55ICE9IHVuZGVmaW5lZCA/IG5ld1JvdGF0aW9uLnkgOiBvbGRSb3RhdGlvbi55LFxyXG4gICAgICAgICAgbmV3Um90YXRpb24ueiAhPSB1bmRlZmluZWQgPyBuZXdSb3RhdGlvbi56IDogb2xkUm90YXRpb24uelxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG5ld1NjYWxpbmcpIHtcclxuICAgICAgICB2ZWN0b3JzLnNjYWxpbmcgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XHJcbiAgICAgICAgdmVjdG9ycy5zY2FsaW5nLnNldChcclxuICAgICAgICAgIG5ld1NjYWxpbmcueCAhPSB1bmRlZmluZWQgPyBuZXdTY2FsaW5nLnggOiBvbGRTY2FsaW5nLngsXHJcbiAgICAgICAgICBuZXdTY2FsaW5nLnkgIT0gdW5kZWZpbmVkID8gbmV3U2NhbGluZy55IDogb2xkU2NhbGluZy55LFxyXG4gICAgICAgICAgbmV3U2NhbGluZy56ICE9IHVuZGVmaW5lZCA/IG5ld1NjYWxpbmcueiA6IG9sZFNjYWxpbmcuelxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFRPRE86IHBvc3NpYmxlIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiB3aGVuIG9ubHkgb25lIG9yIHR3byBjb21wb25lbnRzIGNoYW5nZSwgdGhlbiB1c2Ugb2xkIG1hdHJpeCBpbnN0ZWFkIG9mIElERU5USVRZIGFuZCB0cmFuc2Zvcm0gYnkgZGlmZmVyZW5jZXMvcXVvdGllbnRzXHJcbiAgICAgIGxldCBtYXRyaXg6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpO1xyXG4gICAgICBpZiAodmVjdG9ycy50cmFuc2xhdGlvbilcclxuICAgICAgICBtYXRyaXgudHJhbnNsYXRlKHZlY3RvcnMudHJhbnNsYXRpb24pO1xyXG4gICAgICBpZiAodmVjdG9ycy5yb3RhdGlvbikge1xyXG4gICAgICAgIG1hdHJpeC5yb3RhdGVaKHZlY3RvcnMucm90YXRpb24ueik7XHJcbiAgICAgICAgbWF0cml4LnJvdGF0ZVkodmVjdG9ycy5yb3RhdGlvbi55KTtcclxuICAgICAgICBtYXRyaXgucm90YXRlWCh2ZWN0b3JzLnJvdGF0aW9uLngpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh2ZWN0b3JzLnNjYWxpbmcpXHJcbiAgICAgICAgbWF0cml4LnNjYWxlKHZlY3RvcnMuc2NhbGluZyk7XHJcblxyXG4gICAgICB0aGlzLnNldChtYXRyaXgpO1xyXG4gICAgICB0aGlzLnZlY3RvcnMgPSB2ZWN0b3JzO1xyXG5cclxuICAgICAgUmVjeWNsZXIuc3RvcmUobWF0cml4KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvckF0dHJpYnV0ZVR5cGVzKF9tdXRhdG9yOiBNdXRhdG9yKTogTXV0YXRvckF0dHJpYnV0ZVR5cGVzIHtcclxuICAgICAgbGV0IHR5cGVzOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMgPSB7fTtcclxuICAgICAgaWYgKF9tdXRhdG9yLnRyYW5zbGF0aW9uKSB0eXBlcy50cmFuc2xhdGlvbiA9IFwiVmVjdG9yM1wiO1xyXG4gICAgICBpZiAoX211dGF0b3Iucm90YXRpb24pIHR5cGVzLnJvdGF0aW9uID0gXCJWZWN0b3IzXCI7XHJcbiAgICAgIGlmIChfbXV0YXRvci5zY2FsaW5nKSB0eXBlcy5zY2FsaW5nID0gXCJWZWN0b3IzXCI7XHJcbiAgICAgIHJldHVybiB0eXBlcztcclxuICAgIH1cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7LyoqICovIH1cclxuXHJcbiAgICBwcml2YXRlIHJlc2V0Q2FjaGUoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMudmVjdG9ycyA9IHsgdHJhbnNsYXRpb246IG51bGwsIHJvdGF0aW9uOiBudWxsLCBzY2FsaW5nOiBudWxsIH07XHJcbiAgICAgIHRoaXMubXV0YXRvciA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vI2VuZHJlZ2lvblxyXG59XHJcbiIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIENsYXNzIGZvciBjcmVhdGluZyByYW5kb20gdmFsdWVzLCBzdXBwb3J0aW5nIEphdmFzY3JpcHQncyBNYXRoLnJhbmRvbSBhbmQgYSBkZXRlcm1pbmlzdGlnIHBzZXVkby1yYW5kb20gbnVtYmVyIGdlbmVyYXRvciAoUFJORykgXHJcbiAgICogdGhhdCBjYW4gYmUgZmVkIHdpdGggYSBzZWVkIGFuZCB0aGVuIHJldHVybnMgYSByZXByb2R1Y2FibGUgc2V0IG9mIHJhbmRvbSBudW1iZXJzIChpZiB0aGUgcHJlY2lzaW9uIG9mIEphdmFzY3JpcHQgYWxsb3dzKSBcclxuICAgKiBcclxuICAgKiBAYXV0aG9yIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFJhbmRvbSB7XHJcbiAgICBwdWJsaWMgc3RhdGljIGRlZmF1bHQ6IFJhbmRvbSA9IG5ldyBSYW5kb20oKTtcclxuICAgIHByaXZhdGUgZ2VuZXJhdGU6IEZ1bmN0aW9uID0gTWF0aC5yYW5kb207XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgW1tSYW5kb21dXS4gSWYgZGVzaXJlZCwgY3JlYXRlcyBhIFBSTkcgd2l0aCBpdCBhbmQgZmVlZHMgdGhlIGdpdmVuIHNlZWQuXHJcbiAgICAgKiBAcGFyYW0gX293bkdlbmVyYXRvciBEZWZhdWx0IGlzIGZhbHNlXHJcbiAgICAgKiBAcGFyYW0gX3NlZWQgRGVmYXVsdCBpcyBNYXRoLnJhbmRvbSgpXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKF9vd25HZW5lcmF0b3I6IGJvb2xlYW4gPSBmYWxzZSwgX3NlZWQ6IG51bWJlciA9IE1hdGgucmFuZG9tKCkpIHtcclxuICAgICAgaWYgKF9vd25HZW5lcmF0b3IpXHJcbiAgICAgICAgdGhpcy5nZW5lcmF0ZSA9IFJhbmRvbS5jcmVhdGVHZW5lcmF0b3IoX3NlZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGRlcmVybWluc3RpYyBQUk5HIHdpdGggdGhlIGdpdmVuIHNlZWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBjcmVhdGVHZW5lcmF0b3IoX3NlZWQ6IG51bWJlcik6IEZ1bmN0aW9uIHtcclxuICAgICAgLy8gVE9ETzogcmVwbGFjZSB3aXRoIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIHRvIGdlbmVyYXRlIHByZWRpY3RhYmxlIHNlcXVlbmNlXHJcbiAgICAgIHJldHVybiBNYXRoLnJhbmRvbTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBub3JtZWQgcmFuZG9tIG51bWJlciwgdGh1cyBpbiB0aGUgcmFuZ2Ugb2YgWzAsIDFbXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXROb3JtKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcmFuZG9tIG51bWJlciBpbiB0aGUgcmFuZ2Ugb2YgZ2l2ZW4gW19taW4sIF9tYXhbXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRSYW5nZShfbWluOiBudW1iZXIsIF9tYXg6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiBfbWluICsgdGhpcy5nZW5lcmF0ZSgpICogKF9tYXggLSBfbWluKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSByYW5kb20gaW50ZWdlciBudW1iZXIgaW4gdGhlIHJhbmdlIG9mIGdpdmVuIGZsb29yZWQgW19taW4sIF9tYXhbXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRSYW5nZUZsb29yZWQoX21pbjogbnVtYmVyLCBfbWF4OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLmdldFJhbmdlKF9taW4sIF9tYXgpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBvciBmYWxzZSByYW5kb21seVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Qm9vbGVhbigpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGUoKSA8IDAuNTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgLTEgb3IgMSByYW5kb21seVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0U2lnbigpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5nZXRCb29sZWFuKCkgPyAxIDogLTE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcmFuZG9tbHkgc2VsZWN0ZWQgaW5kZXggaW50byB0aGUgZ2l2ZW4gYXJyYXlcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEluZGV4PFQ+KF9hcnJheTogQXJyYXk8VD4pOiBudW1iZXIge1xyXG4gICAgICBpZiAoX2FycmF5Lmxlbmd0aCA+IDApXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmFuZ2VGbG9vcmVkKDAsIF9hcnJheS5sZW5ndGgpO1xyXG4gICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgcmFuZG9tbHkgc2VsZWN0ZWQgZWxlbWVudCBmcm9tIHRoZSBnaXZlbiBhcnJheSBhbmQgcmV0dXJucyBpdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3BsaWNlPFQ+KF9hcnJheTogQXJyYXk8VD4pOiBUIHtcclxuICAgICAgcmV0dXJuIF9hcnJheS5zcGxpY2UodGhpcy5nZXRJbmRleChfYXJyYXkpLCAxKVswXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSByYW5kb21seSBzZWxlY3RlZCBrZXkgZnJvbSB0aGUgZ2l2ZW4gTWFwLWluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRLZXk8VCwgVT4oX21hcDogTWFwPFQsIFU+KTogVCB7XHJcbiAgICAgIGxldCBrZXlzOiBHZW5lcmFsID0gQXJyYXkuZnJvbShfbWFwLmtleXMoKSk7XHJcbiAgICAgIHJldHVybiBrZXlzW3RoaXMuZ2V0SW5kZXgoa2V5cyldO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHJhbmRvbWx5IHNlbGVjdGVkIHByb3BlcnR5IG5hbWUgZnJvbSB0aGUgZ2l2ZW4gb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRQcm9wZXJ0eU5hbWUoX29iamVjdDogT2JqZWN0KTogc3RyaW5nIHtcclxuICAgICAgbGV0IGtleXM6IHN0cmluZ1tdID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoX29iamVjdCk7XHJcbiAgICAgIHJldHVybiBrZXlzW3RoaXMuZ2V0SW5kZXgoa2V5cyldO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHJhbmRvbWx5IHNlbGVjdGVkIHN5bWJvbCBmcm9tIHRoZSBnaXZlbiBvYmplY3QsIGlmIHN5bWJvbHMgYXJlIHVzZWQgYXMga2V5c1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0UHJvcGVydHlTeW1ib2woX29iamVjdDogT2JqZWN0KTogc3ltYm9sIHtcclxuICAgICAgbGV0IGtleXM6IHN5bWJvbFtdID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhfb2JqZWN0KTtcclxuICAgICAgcmV0dXJuIGtleXNbdGhpcy5nZXRJbmRleChrZXlzKV07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGFuZGFyZCBbW1JhbmRvbV1dLWluc3RhbmNlIHVzaW5nIE1hdGgucmFuZG9tKCkuXHJcbiAgICovXHJcbiAgZXhwb3J0IGNvbnN0IHJhbmRvbTogUmFuZG9tID0gbmV3IFJhbmRvbSgpO1xyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogU3RvcmVzIGFuZCBtYW5pcHVsYXRlcyBhIHRocmVlZGltZW5zaW9uYWwgdmVjdG9yIGNvbXByaXNlZCBvZiB0aGUgY29tcG9uZW50cyB4LCB5IGFuZCB6XHJcbiAgICogYGBgcGxhaW50ZXh0XHJcbiAgICogICAgICAgICAgICAreVxyXG4gICAqICAgICAgICAgICAgIHxfXyAreFxyXG4gICAqICAgICAgICAgICAgL1xyXG4gICAqICAgICAgICAgICt6ICAgXHJcbiAgICogYGBgXHJcbiAgICogQGF1dGhvcnMgSmFzY2hhIEthcmFnw7ZsLCBIRlUsIDIwMTkgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBWZWN0b3IzIGV4dGVuZHMgTXV0YWJsZSB7XHJcbiAgICBwcml2YXRlIGRhdGE6IEZsb2F0MzJBcnJheTsgLy8gVE9ETzogY2hlY2sgd2h5IHRoaXMgc2hvdWxkbid0IGJlIHgseSx6IGFzIG51bWJlcnMuLi5cclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3g6IG51bWJlciA9IDAsIF95OiBudW1iZXIgPSAwLCBfejogbnVtYmVyID0gMCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KFtfeCwgX3ksIF96XSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETzogaW1wbGVtZW50IGVxdWFscy1mdW5jdGlvbnNcclxuICAgIGdldCB4KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmRhdGFbMF07XHJcbiAgICB9XHJcbiAgICBnZXQgeSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5kYXRhWzFdO1xyXG4gICAgfVxyXG4gICAgZ2V0IHooKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZGF0YVsyXTtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgeChfeDogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuZGF0YVswXSA9IF94O1xyXG4gICAgfVxyXG4gICAgc2V0IHkoX3k6IG51bWJlcikge1xyXG4gICAgICB0aGlzLmRhdGFbMV0gPSBfeTtcclxuICAgIH1cclxuICAgIHNldCB6KF96OiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5kYXRhWzJdID0gX3o7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBnZXQgbWFnbml0dWRlKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiBNYXRoLmh5cG90KC4uLnRoaXMuZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzcXVhcmUgb2YgdGhlIG1hZ25pdHVkZSBvZiB0aGUgdmVjdG9yIHdpdGhvdXQgY2FsY3VsYXRpbmcgYSBzcXVhcmUgcm9vdC4gRmFzdGVyIGZvciBzaW1wbGUgcHJveGltaXR5IGV2YWx1YXRpb24uXHJcbiAgICAgKi9cclxuICAgIGdldCBtYWduaXR1ZGVTcXVhcmVkKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiBWZWN0b3IzLkRPVCh0aGlzLCB0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gbGVuZ3RoIHBvaW50aW5nIGluIHgtZGlyZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgWChfc2NhbGU6IG51bWJlciA9IDEpOiBWZWN0b3IzIHtcclxuICAgICAgY29uc3QgdmVjdG9yOiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xyXG4gICAgICB2ZWN0b3IuZGF0YS5zZXQoW19zY2FsZSwgMCwgMF0pO1xyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBsZW5ndGggcG9pbnRpbmcgaW4geS1kaXJlY3Rpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBZKF9zY2FsZTogbnVtYmVyID0gMSk6IFZlY3RvcjMge1xyXG4gICAgICBjb25zdCB2ZWN0b3I6IFZlY3RvcjMgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XHJcbiAgICAgIHZlY3Rvci5kYXRhLnNldChbMCwgX3NjYWxlLCAwXSk7XHJcbiAgICAgIHJldHVybiB2ZWN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgdmVjdG9yIHdpdGggdGhlIGdpdmVuIGxlbmd0aCBwb2ludGluZyBpbiB6LWRpcmVjdGlvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFooX3NjYWxlOiBudW1iZXIgPSAxKTogVmVjdG9yMyB7XHJcbiAgICAgIGNvbnN0IHZlY3RvcjogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgdmVjdG9yLmRhdGEuc2V0KFswLCAwLCBfc2NhbGVdKTtcclxuICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSB2ZWN0b3Igd2l0aCB0aGUgdmFsdWUgMCBvbiBlYWNoIGF4aXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBaRVJPKCk6IFZlY3RvcjMge1xyXG4gICAgICBjb25zdCB2ZWN0b3I6IFZlY3RvcjMgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XHJcbiAgICAgIHZlY3Rvci5kYXRhLnNldChbMCwgMCwgMF0pO1xyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIHZlY3RvciBvZiB0aGUgZ2l2ZW4gc2l6ZSBvbiBlYWNoIG9mIHRoZSB0aHJlZSBheGlzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgT05FKF9zY2FsZTogbnVtYmVyID0gMSk6IFZlY3RvcjMge1xyXG4gICAgICBjb25zdCB2ZWN0b3I6IFZlY3RvcjMgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XHJcbiAgICAgIHZlY3Rvci5kYXRhLnNldChbX3NjYWxlLCBfc2NhbGUsIF9zY2FsZV0pO1xyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIHZlY3RvciB0aHJvdWdoIHRyYW5zZm9ybWF0aW9uIG9mIHRoZSBnaXZlbiB2ZWN0b3IgYnkgdGhlIGdpdmVuIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFRSQU5TRk9STUFUSU9OKF92ZWN0b3I6IFZlY3RvcjMsIF9tYXRyaXg6IE1hdHJpeDR4NCwgX2luY2x1ZGVUcmFuc2xhdGlvbjogYm9vbGVhbiA9IHRydWUpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgbGV0IG06IEZsb2F0MzJBcnJheSA9IF9tYXRyaXguZ2V0KCk7XHJcbiAgICAgIGxldCBbeCwgeSwgel0gPSBfdmVjdG9yLmdldCgpO1xyXG5cclxuICAgICAgcmVzdWx0LnggPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHo7XHJcbiAgICAgIHJlc3VsdC55ID0gbVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6O1xyXG4gICAgICByZXN1bHQueiA9IG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHo7XHJcblxyXG4gICAgICBpZiAoX2luY2x1ZGVUcmFuc2xhdGlvbikge1xyXG4gICAgICAgIHJlc3VsdC5hZGQoX21hdHJpeC50cmFuc2xhdGlvbik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgdmVjdG9yIHdoaWNoIGlzIGEgY29weSBvZiB0aGUgZ2l2ZW4gdmVjdG9yIHNjYWxlZCB0byB0aGUgZ2l2ZW4gbGVuZ3RoXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgTk9STUFMSVpBVElPTihfdmVjdG9yOiBWZWN0b3IzLCBfbGVuZ3RoOiBudW1iZXIgPSAxKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCBtYWduaXR1ZGU6IG51bWJlciA9IF92ZWN0b3IubWFnbml0dWRlO1xyXG4gICAgICBsZXQgdmVjdG9yOiBWZWN0b3IzO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGlmIChtYWduaXR1ZGUgPT0gMClcclxuICAgICAgICAgIHRocm93IChuZXcgUmFuZ2VFcnJvcihcIkltcG9zc2libGUgbm9ybWFsaXphdGlvblwiKSk7XHJcbiAgICAgICAgdmVjdG9yID0gVmVjdG9yMy5aRVJPKCk7XHJcbiAgICAgICAgbGV0IGZhY3RvcjogbnVtYmVyID0gX2xlbmd0aCAvIF92ZWN0b3IubWFnbml0dWRlO1xyXG4gICAgICAgIHZlY3Rvci5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShbX3ZlY3Rvci54ICogZmFjdG9yLCBfdmVjdG9yLnkgKiBmYWN0b3IsIF92ZWN0b3IueiAqIGZhY3Rvcl0pO1xyXG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcclxuICAgICAgICBEZWJ1Zy53YXJuKF9lcnJvcik7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHJlc3VsdGluZyB2ZWN0b3IgYXR0YWluZWQgYnkgYWRkaXRpb24gb2YgYWxsIGdpdmVuIHZlY3RvcnMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgU1VNKC4uLl92ZWN0b3JzOiBWZWN0b3IzW10pOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgZm9yIChsZXQgdmVjdG9yIG9mIF92ZWN0b3JzKVxyXG4gICAgICAgIHJlc3VsdC5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShbcmVzdWx0LnggKyB2ZWN0b3IueCwgcmVzdWx0LnkgKyB2ZWN0b3IueSwgcmVzdWx0LnogKyB2ZWN0b3Iuel0pO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSBzdWJ0cmFjdGlvbiBvZiB0d28gdmVjdG9ycy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBESUZGRVJFTkNFKF9taW51ZW5kOiBWZWN0b3IzLCBfc3VidHJhaGVuZDogVmVjdG9yMyk6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgdmVjdG9yOiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xyXG4gICAgICB2ZWN0b3IuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoW19taW51ZW5kLnggLSBfc3VidHJhaGVuZC54LCBfbWludWVuZC55IC0gX3N1YnRyYWhlbmQueSwgX21pbnVlbmQueiAtIF9zdWJ0cmFoZW5kLnpdKTtcclxuICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBuZXcgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gdmVjdG9yIHNjYWxlZCBieSB0aGUgZ2l2ZW4gc2NhbGluZyBmYWN0b3JcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBTQ0FMRShfdmVjdG9yOiBWZWN0b3IzLCBfc2NhbGluZzogbnVtYmVyKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCBzY2FsZWQ6IFZlY3RvcjMgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XHJcbiAgICAgIHNjYWxlZC5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShbX3ZlY3Rvci54ICogX3NjYWxpbmcsIF92ZWN0b3IueSAqIF9zY2FsaW5nLCBfdmVjdG9yLnogKiBfc2NhbGluZ10pO1xyXG4gICAgICByZXR1cm4gc2NhbGVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgdGhlIGNyb3NzcHJvZHVjdCBvZiAyIHZlY3RvcnMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgQ1JPU1MoX2E6IFZlY3RvcjMsIF9iOiBWZWN0b3IzKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCB2ZWN0b3I6IFZlY3RvcjMgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XHJcbiAgICAgIHZlY3Rvci5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAgICAgX2EueSAqIF9iLnogLSBfYS56ICogX2IueSxcclxuICAgICAgICBfYS56ICogX2IueCAtIF9hLnggKiBfYi56LFxyXG4gICAgICAgIF9hLnggKiBfYi55IC0gX2EueSAqIF9iLnhdKTtcclxuICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgdGhlIGRvdHByb2R1Y3Qgb2YgMiB2ZWN0b3JzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIERPVChfYTogVmVjdG9yMywgX2I6IFZlY3RvcjMpOiBudW1iZXIge1xyXG4gICAgICBsZXQgc2NhbGFyUHJvZHVjdDogbnVtYmVyID0gX2EueCAqIF9iLnggKyBfYS55ICogX2IueSArIF9hLnogKiBfYi56O1xyXG4gICAgICByZXR1cm4gc2NhbGFyUHJvZHVjdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgYW5kIHJldHVybnMgdGhlIHJlZmxlY3Rpb24gb2YgdGhlIGluY29taW5nIHZlY3RvciBhdCB0aGUgZ2l2ZW4gbm9ybWFsIHZlY3Rvci4gVGhlIGxlbmd0aCBvZiBub3JtYWwgc2hvdWxkIGJlIDEuXHJcbiAgICAgKiAgICAgX19fX19fX19fX19fX19fX19fXHJcbiAgICAgKiAgICAgICAgICAgL3xcXFxyXG4gICAgICogaW5jb21pbmcgLyB8IFxcIHJlZmxlY3Rpb25cclxuICAgICAqICAgICAgICAgLyAgfCAgXFwgICBcclxuICAgICAqICAgICAgICAgIG5vcm1hbFxyXG4gICAgICogXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgUkVGTEVDVElPTihfaW5jb21pbmc6IFZlY3RvcjMsIF9ub3JtYWw6IFZlY3RvcjMpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IGRvdDogbnVtYmVyID0gLVZlY3RvcjMuRE9UKF9pbmNvbWluZywgX25vcm1hbCk7XHJcbiAgICAgIGxldCByZWZsZWN0aW9uOiBWZWN0b3IzID0gVmVjdG9yMy5TVU0oX2luY29taW5nLCBWZWN0b3IzLlNDQUxFKF9ub3JtYWwsIDIgKiBkb3QpKTtcclxuICAgICAgcmV0dXJuIHJlZmxlY3Rpb247XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXZpZGVzIHRoZSBkaXZpZGVuZCBieSB0aGUgZGl2aXNvciBjb21wb25lbnQgYnkgY29tcG9uZW50IGFuZCByZXR1cm5zIHRoZSByZXN1bHRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBSQVRJTyhfZGl2aWRlbmQ6IFZlY3RvcjMsIF9kaXZpc29yOiBWZWN0b3IzKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCB2ZWN0b3I6IFZlY3RvcjMgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XHJcbiAgICAgIHZlY3Rvci5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShbX2RpdmlkZW5kLnggLyBfZGl2aXNvci54LCBfZGl2aWRlbmQueSAvIF9kaXZpc29yLnksIF9kaXZpZGVuZC56IC8gX2Rpdmlzb3Iuel0pO1xyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjb29yZGluYXRlcyBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gdmVjdG9yIGFyZSB0byBiZSBjb25zaWRlcmVkIGlkZW50aWNhbCB3aXRoaW4gdGhlIGdpdmVuIHRvbGVyYW5jZVxyXG4gICAgICogVE9ETzogZXhhbWluZSwgaWYgdG9sZXJhbmNlIGFzIGNyaXRlcml1bSBmb3IgdGhlIGRpZmZlcmVuY2UgaXMgYXBwcm9wcmlhdGUgd2l0aCB2ZXJ5IGxhcmdlIGNvb3JkaW5hdGUgdmFsdWVzIG9yIGlmIF90b2xlcmFuY2Ugc2hvdWxkIGJlIG11bHRpcGxpZWQgYnkgY29vcmRpbmF0ZSB2YWx1ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZXF1YWxzKF9jb21wYXJlOiBWZWN0b3IzLCBfdG9sZXJhbmNlOiBudW1iZXIgPSBOdW1iZXIuRVBTSUxPTik6IGJvb2xlYW4ge1xyXG4gICAgICBpZiAoTWF0aC5hYnModGhpcy54IC0gX2NvbXBhcmUueCkgPiBfdG9sZXJhbmNlKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmIChNYXRoLmFicyh0aGlzLnkgLSBfY29tcGFyZS55KSA+IF90b2xlcmFuY2UpIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKE1hdGguYWJzKHRoaXMueiAtIF9jb21wYXJlLnopID4gX3RvbGVyYW5jZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcG9zaXRpb24gZGVzY3JpYmVkIGJ5IHRoaXMgaXMgd2l0aGluIGEgY3ViZSB3aXRoIHRoZSBvcHBvc2l0ZSBjb3JuZXJzIDEgYW5kIDJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGlzSW5zaWRlQ3ViZShfY29ybmVyMTogVmVjdG9yMywgX2Nvcm5lcjI6IFZlY3RvcjMpOiBib29sZWFuIHtcclxuICAgICAgbGV0IGRpYWdvbmFsOiBWZWN0b3IzID0gVmVjdG9yMy5ESUZGRVJFTkNFKF9jb3JuZXIyLCBfY29ybmVyMSk7XHJcbiAgICAgIGxldCByZWxhdGl2ZTogVmVjdG9yMyA9IFZlY3RvcjMuRElGRkVSRU5DRSh0aGlzLCBfY29ybmVyMSk7XHJcbiAgICAgIGxldCByYXRpbzogVmVjdG9yMyA9IFZlY3RvcjMuUkFUSU8ocmVsYXRpdmUsIGRpYWdvbmFsKTtcclxuICAgICAgaWYgKHJhdGlvLnggPiAxIHx8IHJhdGlvLnggPCAwKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKHJhdGlvLnkgPiAxIHx8IHJhdGlvLnkgPCAwKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKHJhdGlvLnogPiAxIHx8IHJhdGlvLnogPCAwKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBvc2l0aW9uIGRlc2NyaWJlZCBieSB0aGlzIGlzIHdpdGhpbiBhIHNwaGVyZSB3aXRoIHRoZSBnaXZlbiBjZW50ZXIgYW5kIHJhZGl1c1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaXNJbnNpZGVTcGhlcmUoX2NlbnRlcjogVmVjdG9yMywgX3JhZGl1czogbnVtYmVyKTogYm9vbGVhbiB7XHJcbiAgICAgIGxldCBkaWZmZXJlbmNlOiBWZWN0b3IzID0gVmVjdG9yMy5ESUZGRVJFTkNFKHRoaXMsIF9jZW50ZXIpO1xyXG4gICAgICByZXR1cm4gZGlmZmVyZW5jZS5tYWduaXR1ZGVTcXVhcmVkIDwgKF9yYWRpdXMgKiBfcmFkaXVzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdGhlIGdpdmVuIHZlY3RvciB0byB0aGlzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhZGQoX2FkZGVuZDogVmVjdG9yMyk6IHZvaWQge1xyXG4gICAgICB0aGlzLmRhdGEuc2V0KFtfYWRkZW5kLnggKyB0aGlzLngsIF9hZGRlbmQueSArIHRoaXMueSwgX2FkZGVuZC56ICsgdGhpcy56XSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJ0cmFjdHMgdGhlIGdpdmVuIHZlY3RvciBmcm9tIHRoaXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN1YnRyYWN0KF9zdWJ0cmFoZW5kOiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuZGF0YS5zZXQoW3RoaXMueCAtIF9zdWJ0cmFoZW5kLngsIHRoaXMueSAtIF9zdWJ0cmFoZW5kLnksIHRoaXMueiAtIF9zdWJ0cmFoZW5kLnpdKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNjYWxlcyB0aGlzIHZlY3RvciBieSB0aGUgZ2l2ZW4gc2NhbGFyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzY2FsZShfc2NhbGFyOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy5kYXRhLnNldChbX3NjYWxhciAqIHRoaXMueCwgX3NjYWxhciAqIHRoaXMueSwgX3NjYWxhciAqIHRoaXMuel0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTm9ybWFsaXplcyB0aGlzIHRvIHRoZSBnaXZlbiBsZW5ndGgsIDEgYnkgZGVmYXVsdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbm9ybWFsaXplKF9sZW5ndGg6IG51bWJlciA9IDEpOiB2b2lkIHtcclxuICAgICAgdGhpcy5kYXRhID0gVmVjdG9yMy5OT1JNQUxJWkFUSU9OKHRoaXMsIF9sZW5ndGgpLmRhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIHRoZSBjb21wb25lbnRzIG9mIHRoaXMgdmVjdG9yIHdpdGggdGhlIGdpdmVuIG51bWJlcnNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldChfeDogbnVtYmVyID0gMCwgX3k6IG51bWJlciA9IDAsIF96OiBudW1iZXIgPSAwKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoW194LCBfeSwgX3pdKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyB2ZWN0b3IgYXMgYSBuZXcgRmxvYXQzMkFycmF5IChjb3B5KVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0KCk6IEZsb2F0MzJBcnJheSB7XHJcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KHRoaXMuZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGlzIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGNvcHkoKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCBjb3B5OiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xyXG4gICAgICBjb3B5LmRhdGEuc2V0KHRoaXMuZGF0YSk7XHJcbiAgICAgIHJldHVybiBjb3B5O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNmb3JtcyB0aGlzIHZlY3RvciBieSB0aGUgZ2l2ZW4gbWF0cml4LCBpbmNsdWRpbmcgb3IgZXhsdWRpbmcgdGhlIHRyYW5zbGF0aW9uLlxyXG4gICAgICogSW5jbHVkaW5nIGlzIHRoZSBkZWZhdWx0LCBleGNsdWRpbmcgd2lsbCBvbmx5IHJvdGF0ZSBhbmQgc2NhbGUgdGhpcyB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0cmFuc2Zvcm0oX21hdHJpeDogTWF0cml4NHg0LCBfaW5jbHVkZVRyYW5zbGF0aW9uOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xyXG4gICAgICB0aGlzLmRhdGEgPSBWZWN0b3IzLlRSQU5TRk9STUFUSU9OKHRoaXMsIF9tYXRyaXgsIF9pbmNsdWRlVHJhbnNsYXRpb24pLmRhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcm9wcyB0aGUgei1jb21wb25lbnQgYW5kIHJldHVybnMgYSBWZWN0b3IyIGNvbnNpc3Rpbmcgb2YgdGhlIHgtIGFuZCB5LWNvbXBvbmVudHNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHRvVmVjdG9yMigpOiBWZWN0b3IyIHtcclxuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKHRoaXMueCwgdGhpcy55KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZmxlY3RzIHRoaXMgdmVjdG9yIGF0IGEgZ2l2ZW4gbm9ybWFsLiBTZWUgW1tSRUZMRUNUSU9OXV1cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlZmxlY3QoX25vcm1hbDogVmVjdG9yMyk6IHZvaWQge1xyXG4gICAgICBjb25zdCByZWZsZWN0ZWQ6IFZlY3RvcjMgPSBWZWN0b3IzLlJFRkxFQ1RJT04odGhpcywgX25vcm1hbCk7XHJcbiAgICAgIHRoaXMuc2V0KHJlZmxlY3RlZC54LCByZWZsZWN0ZWQueSwgcmVmbGVjdGVkLnopO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShyZWZsZWN0ZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2h1ZmZsZXMgdGhlIGNvbXBvbmVudHMgb2YgdGhpcyB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNodWZmbGUoKTogdm9pZCB7XHJcbiAgICAgIGxldCBhOiBudW1iZXJbXSA9IEFycmF5LmZyb20odGhpcy5kYXRhKTtcclxuICAgICAgdGhpcy5zZXQoUmFuZG9tLmRlZmF1bHQuc3BsaWNlKGEpLCBSYW5kb20uZGVmYXVsdC5zcGxpY2UoYSksIGFbMF0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGZvcm1hdHRlZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgIGxldCByZXN1bHQ6IHN0cmluZyA9IGAoJHt0aGlzLngudG9QcmVjaXNpb24oNSl9LCAke3RoaXMueS50b1ByZWNpc2lvbig1KX0sICR7dGhpcy56LnRvUHJlY2lzaW9uKDUpfSlgO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXNlcyB0aGUgc3RhbmRhcmQgYXJyYXkubWFwIGZ1bmN0aW9uYWxpdHkgdG8gcGVyZm9ybSB0aGUgZ2l2ZW4gZnVuY3Rpb24gb24gYWxsIGNvbXBvbmVudHMgb2YgdGhpcyB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgcHVibGljIG1hcChfZnVuY3Rpb246ICh2YWx1ZTogbnVtYmVyLCBpbmRleDogbnVtYmVyLCBhcnJheTogRmxvYXQzMkFycmF5KSA9PiBudW1iZXIpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IGNvcHk6IFZlY3RvcjMgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XHJcbiAgICAgIGNvcHkuZGF0YSA9IHRoaXMuZGF0YS5tYXAoX2Z1bmN0aW9uKTtcclxuICAgICAgcmV0dXJuIGNvcHk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0ge1xyXG4gICAgICAgIHg6IHRoaXMuZGF0YVswXSwgeTogdGhpcy5kYXRhWzFdLCB6OiB0aGlzLmRhdGFbMl1cclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQgey8qKiAqLyB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgYWxsIG1lc2hlcy4gXHJcbiAgICogTWVzaGVzIHByb3ZpZGUgaW5kZXhlZCB2ZXJ0aWNlcywgdGhlIG9yZGVyIG9mIGluZGljZXMgdG8gY3JlYXRlIHRyaWdvbnMgYW5kIG5vcm1hbHMsIGFuZCB0ZXh0dXJlIGNvb3JkaW5hdGVzXHJcbiAgICogXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBAUmVuZGVySW5qZWN0b3JNZXNoLmRlY29yYXRlXHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIE1lc2ggaW1wbGVtZW50cyBTZXJpYWxpemFibGVSZXNvdXJjZSB7XHJcbiAgICAvKiogcmVmZXJzIGJhY2sgdG8gdGhpcyBjbGFzcyBmcm9tIGFueSBzdWJjbGFzcyBlLmcuIGluIG9yZGVyIHRvIGZpbmQgY29tcGF0aWJsZSBvdGhlciByZXNvdXJjZXMqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBiYXNlQ2xhc3M6IHR5cGVvZiBNZXNoID0gTWVzaDtcclxuICAgIC8qKiBsaXN0IG9mIGFsbCB0aGUgc3ViY2xhc3NlcyBkZXJpdmVkIGZyb20gdGhpcyBjbGFzcywgaWYgdGhleSByZWdpc3RlcmVkIHByb3Blcmx5Ki9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgc3ViY2xhc3NlczogdHlwZW9mIE1lc2hbXSA9IFtdO1xyXG5cclxuICAgIC8vIFRPRE86IGNoZWNrIGlmIHRoZXNlIGFycmF5cyBtdXN0IGJlIGNhY2hlZCBsaWtlIHRoaXMgb3IgaWYgY2FsbGluZyB0aGUgbWV0aG9kcyBpcyBiZXR0ZXIuXHJcbiAgICBwdWJsaWMgdmVydGljZXM6IEZsb2F0MzJBcnJheTtcclxuICAgIHB1YmxpYyBpbmRpY2VzOiBVaW50MTZBcnJheTtcclxuICAgIHB1YmxpYyB0ZXh0dXJlVVZzOiBGbG9hdDMyQXJyYXk7XHJcbiAgICBwdWJsaWMgbm9ybWFsc0ZhY2U6IEZsb2F0MzJBcnJheTtcclxuXHJcbiAgICBwdWJsaWMgaWRSZXNvdXJjZTogc3RyaW5nID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIHB1YmxpYyByZW5kZXJCdWZmZXJzOiBSZW5kZXJCdWZmZXJzOyAvKiBkZWZpbmVkIGJ5IFJlbmRlckluamVjdG9yKi9cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldEJ1ZmZlclNwZWNpZmljYXRpb24oKTogQnVmZmVyU3BlY2lmaWNhdGlvbiB7XHJcbiAgICAgIHJldHVybiB7IHNpemU6IDMsIGRhdGFUeXBlOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZMT0FULCBub3JtYWxpemU6IGZhbHNlLCBzdHJpZGU6IDAsIG9mZnNldDogMCB9O1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVnaXN0ZXJTdWJjbGFzcyhfc3ViQ2xhc3M6IHR5cGVvZiBNZXNoKTogbnVtYmVyIHsgcmV0dXJuIE1lc2guc3ViY2xhc3Nlcy5wdXNoKF9zdWJDbGFzcykgLSAxOyB9XHJcblxyXG5cclxuICAgIHB1YmxpYyB1c2VSZW5kZXJCdWZmZXJzKF9zaGFkZXI6IHR5cGVvZiBTaGFkZXIsIF93b3JsZDogTWF0cml4NHg0LCBfcHJvamVjdGlvbjogTWF0cml4NHg0LCBfaWQ/OiBudW1iZXIpOiB2b2lkIHsvKiBpbmplY3RlZCBieSBSZW5kZXJJbmplY3RvciovIH1cclxuICAgIHB1YmxpYyBjcmVhdGVSZW5kZXJCdWZmZXJzKCk6IHZvaWQgey8qIGluamVjdGVkIGJ5IFJlbmRlckluamVjdG9yKi8gfVxyXG4gICAgcHVibGljIGRlbGV0ZVJlbmRlckJ1ZmZlcnMoX3NoYWRlcjogdHlwZW9mIFNoYWRlcik6IHZvaWQgey8qIGluamVjdGVkIGJ5IFJlbmRlckluamVjdG9yKi8gfVxyXG5cclxuICAgIHB1YmxpYyBnZXRWZXJ0ZXhDb3VudCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy52ZXJ0aWNlcy5sZW5ndGggLyBNZXNoLmdldEJ1ZmZlclNwZWNpZmljYXRpb24oKS5zaXplO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGdldEluZGV4Q291bnQoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuaW5kaWNlcy5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGNyZWF0ZSgpOiB2b2lkIHtcclxuICAgICAgdGhpcy52ZXJ0aWNlcyA9IHRoaXMuY3JlYXRlVmVydGljZXMoKTtcclxuICAgICAgdGhpcy5pbmRpY2VzID0gdGhpcy5jcmVhdGVJbmRpY2VzKCk7XHJcbiAgICAgIHRoaXMudGV4dHVyZVVWcyA9IHRoaXMuY3JlYXRlVGV4dHVyZVVWcygpO1xyXG4gICAgICB0aGlzLm5vcm1hbHNGYWNlID0gdGhpcy5jcmVhdGVGYWNlTm9ybWFscygpO1xyXG4gICAgICB0aGlzLmNyZWF0ZVJlbmRlckJ1ZmZlcnMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTZXJpYWxpemUvRGVzZXJpYWxpemUgZm9yIGFsbCBtZXNoZXMgdGhhdCBjYWxjdWxhdGUgd2l0aG91dCBwYXJhbWV0ZXJzXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHtcclxuICAgICAgICBpZFJlc291cmNlOiB0aGlzLmlkUmVzb3VyY2VcclxuICAgICAgfTsgLy8gbm8gZGF0YSBuZWVkZWQgLi4uXHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogU2VyaWFsaXphYmxlIHtcclxuICAgICAgdGhpcy5jcmVhdGUoKTsgLy8gVE9ETzogbXVzdCBub3QgYmUgY3JlYXRlZCwgaWYgYW4gaWRlbnRpY2FsIG1lc2ggYWxyZWFkeSBleGlzdHNcclxuICAgICAgdGhpcy5pZFJlc291cmNlID0gX3NlcmlhbGl6YXRpb24uaWRSZXNvdXJjZTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcHVibGljIGFic3RyYWN0IGNyZWF0ZSgpOiB2b2lkO1xyXG5cclxuICAgIHByb3RlY3RlZCBjYWxjdWxhdGVGYWNlTm9ybWFscygpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICBsZXQgbm9ybWFsczogbnVtYmVyW10gPSBbXTtcclxuICAgICAgbGV0IHZlcnRpY2VzOiBWZWN0b3IzW10gPSBbXTtcclxuXHJcbiAgICAgIGZvciAobGV0IHY6IG51bWJlciA9IDA7IHYgPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgdiArPSAzKVxyXG4gICAgICAgIHZlcnRpY2VzLnB1c2gobmV3IFZlY3RvcjModGhpcy52ZXJ0aWNlc1t2XSwgdGhpcy52ZXJ0aWNlc1t2ICsgMV0sIHRoaXMudmVydGljZXNbdiArIDJdKSk7XHJcblxyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5pbmRpY2VzLmxlbmd0aDsgaSArPSAzKSB7XHJcbiAgICAgICAgbGV0IHZlcnRleDogbnVtYmVyW10gPSBbdGhpcy5pbmRpY2VzW2ldLCB0aGlzLmluZGljZXNbaSArIDFdLCB0aGlzLmluZGljZXNbaSArIDJdXTtcclxuXHJcbiAgICAgICAgbGV0IHYwOiBWZWN0b3IzID0gVmVjdG9yMy5ESUZGRVJFTkNFKHZlcnRpY2VzW3ZlcnRleFswXV0sIHZlcnRpY2VzW3ZlcnRleFsxXV0pO1xyXG4gICAgICAgIGxldCB2MTogVmVjdG9yMyA9IFZlY3RvcjMuRElGRkVSRU5DRSh2ZXJ0aWNlc1t2ZXJ0ZXhbMF1dLCB2ZXJ0aWNlc1t2ZXJ0ZXhbMl1dKTtcclxuICAgICAgICBsZXQgbm9ybWFsOiBWZWN0b3IzID0gVmVjdG9yMy5OT1JNQUxJWkFUSU9OKFZlY3RvcjMuQ1JPU1ModjAsIHYxKSk7XHJcbiAgICAgICAgbGV0IGluZGV4OiBudW1iZXIgPSB2ZXJ0ZXhbMl0gKiAzO1xyXG4gICAgICAgIG5vcm1hbHNbaW5kZXhdID0gbm9ybWFsLng7XHJcbiAgICAgICAgbm9ybWFsc1tpbmRleCArIDFdID0gbm9ybWFsLnk7XHJcbiAgICAgICAgbm9ybWFsc1tpbmRleCArIDJdID0gbm9ybWFsLno7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkobm9ybWFscyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IGNyZWF0ZVZlcnRpY2VzKCk6IEZsb2F0MzJBcnJheTtcclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBjcmVhdGVUZXh0dXJlVVZzKCk6IEZsb2F0MzJBcnJheTtcclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBjcmVhdGVJbmRpY2VzKCk6IFVpbnQxNkFycmF5O1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IGNyZWF0ZUZhY2VOb3JtYWxzKCk6IEZsb2F0MzJBcnJheTtcclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBHZW5lcmF0ZSBhIHNpbXBsZSBjdWJlIHdpdGggZWRnZXMgb2YgbGVuZ3RoIDEsIGVhY2ggZmFjZSBjb25zaXN0aW5nIG9mIHR3byB0cmlnb25zXHJcbiAgICogYGBgcGxhaW50ZXh0XHJcbiAgICogICAgICAgICAgICA0X19fXzdcclxuICAgKiAgICAgICAgICAgMC9fXzMvfFxyXG4gICAqICAgICAgICAgICAgfHw1X3x8NlxyXG4gICAqICAgICAgICAgICAxfC9fMnwvIFxyXG4gICAqIGBgYFxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE1lc2hDdWJlIGV4dGVuZHMgTWVzaCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gTWVzaC5yZWdpc3RlclN1YmNsYXNzKE1lc2hDdWJlKTtcclxuICAgXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuY3JlYXRlKCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHByb3RlY3RlZCBjcmVhdGVWZXJ0aWNlcygpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICBsZXQgdmVydGljZXM6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoW1xyXG4gICAgICAgICAgICAgICAgLy8gRmlyc3Qgd3JhcFxyXG4gICAgICAgICAgICAgICAgLy8gZnJvbnRcclxuICAgICAgICAgICAgICAgIC8qMCovIC0xLCAxLCAxLCAvKjEqLyAtMSwgLTEsIDEsICAvKjIqLyAxLCAtMSwgMSwgLyozKi8gMSwgMSwgMSxcclxuICAgICAgICAgICAgICAgIC8vIGJhY2tcclxuICAgICAgICAgICAgICAgIC8qNCovIC0xLCAxLCAtMSwgLyogNSovIC0xLCAtMSwgLTEsICAvKiA2Ki8gMSwgLTEsIC0xLCAvKiA3Ki8gMSwgMSwgLTEsXHJcbiAgICAgICAgICAgICAgICAvLyBTZWNvbmQgd3JhcFxyXG4gICAgICAgICAgICAgICAgLy8gZnJvbnRcclxuICAgICAgICAgICAgICAgIC8qMCovIC0xLCAxLCAxLCAvKjEqLyAtMSwgLTEsIDEsICAvKjIqLyAxLCAtMSwgMSwgLyozKi8gMSwgMSwgMSxcclxuICAgICAgICAgICAgICAgIC8vIGJhY2tcclxuICAgICAgICAgICAgICAgIC8qNCovIC0xLCAxLCAtMSwgLyogNSovIC0xLCAtMSwgLTEsICAvKiA2Ki8gMSwgLTEsIC0xLCAvKiA3Ki8gMSwgMSwgLTFcclxuICAgICAgXSk7XHJcblxyXG4gICAgICAvLyBzY2FsZSBkb3duIHRvIGEgbGVuZ3RoIG9mIDEgZm9yIGFsbCBlZGdlc1xyXG4gICAgICB2ZXJ0aWNlcyA9IHZlcnRpY2VzLm1hcChfdmFsdWUgPT4gX3ZhbHVlIC8gMik7XHJcblxyXG4gICAgICByZXR1cm4gdmVydGljZXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZUluZGljZXMoKTogVWludDE2QXJyYXkge1xyXG4gICAgICBsZXQgaW5kaWNlczogVWludDE2QXJyYXkgPSBuZXcgVWludDE2QXJyYXkoW1xyXG4gICAgICAgIC8vIEZpcnN0IHdyYXBcclxuICAgICAgICAvLyBmcm9udFxyXG4gICAgICAgIDEsIDIsIDAsIDIsIDMsIDAsXHJcbiAgICAgICAgLy8gcmlnaHRcclxuICAgICAgICAyLCA2LCAzLCA2LCA3LCAzLFxyXG4gICAgICAgIC8vIGJhY2tcclxuICAgICAgICA2LCA1LCA3LCA1LCA0LCA3LFxyXG5cclxuICAgICAgICAvLyBTZWNvbmQgd3JhcFxyXG4gICAgICAgIC8vIGxlZnRcclxuICAgICAgICA1ICsgOCwgMSArIDgsIDQgKyA4LCAxICsgOCwgMCArIDgsIDQgKyA4LFxyXG4gICAgICAgIC8vIHRvcFxyXG4gICAgICAgIDQgKyA4LCAwICsgOCwgMyArIDgsIDcgKyA4LCA0ICsgOCwgMyArIDgsXHJcbiAgICAgICAgLy8gYm90dG9tXHJcbiAgICAgICAgNSArIDgsIDYgKyA4LCAxICsgOCwgNiArIDgsIDIgKyA4LCAxICsgOFxyXG5cclxuICAgICAgICAvKixcclxuICAgICAgICAvLyBsZWZ0XHJcbiAgICAgICAgNCwgNSwgMSwgNCwgMSwgMCxcclxuICAgICAgICAvLyB0b3BcclxuICAgICAgICA0LCAwLCAzLCA0LCAzLCA3LFxyXG4gICAgICAgIC8vIGJvdHRvbVxyXG4gICAgICAgIDEsIDUsIDYsIDEsIDYsIDJcclxuICAgICAgICAqL1xyXG4gICAgICBdKTtcclxuICAgICAgcmV0dXJuIGluZGljZXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZVRleHR1cmVVVnMoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgbGV0IHRleHR1cmVVVnM6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoW1xyXG4gICAgICAgICAgICAgICAgLy8gRmlyc3Qgd3JhcFxyXG4gICAgICAgICAgICAgICAgLy8gZnJvbnRcclxuICAgICAgICAgICAgICAgIC8qMCovIDAsIDAsIC8qMSovIDAsIDEsICAvKjIqLyAxLCAxLCAvKjMqLyAxLCAwLFxyXG4gICAgICAgICAgICAgICAgLy8gYmFja1xyXG4gICAgICAgICAgICAgICAgLyo0Ki8gMywgMCwgLyo1Ki8gMywgMSwgIC8qNiovIDIsIDEsIC8qNyovIDIsIDAsXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU2Vjb25kIHdyYXBcclxuICAgICAgICAgICAgICAgIC8vIGZyb250XHJcbiAgICAgICAgICAgICAgICAvKjAqLyAxLCAwLCAvKjEqLyAxLCAxLCAgLyoyKi8gMSwgMiwgLyozKi8gMSwgLTEsXHJcbiAgICAgICAgICAgICAgICAvLyBiYWNrXHJcbiAgICAgICAgICAgICAgICAvKjQqLyAwLCAwLCAvKjUqLyAwLCAxLCAgLyo2Ki8gMCwgMiwgLyo3Ki8gMCwgLTFcclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiB0ZXh0dXJlVVZzO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBjcmVhdGVGYWNlTm9ybWFscygpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICBsZXQgbm9ybWFsczogRmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAgICAgICAgICAgICAvLyBmb3IgZWFjaCB0cmlhbmdsZSwgdGhlIGxhc3QgdmVydGV4IG9mIHRoZSB0aHJlZSBkZWZpbmluZyByZWZlcnMgdG8gdGhlIG5vcm1hbHZlY3RvciB3aGVuIHVzaW5nIGZsYXQgc2hhZGluZ1xyXG4gICAgICAgICAgICAgICAgLy8gRmlyc3Qgd3JhcFxyXG4gICAgICAgICAgICAgICAgLy8gZnJvbnRcclxuICAgICAgICAgICAgICAgIC8qMCovIDAsIDAsIDEsIC8qMSovIDAsIDAsIDAsIC8qMiovIDAsIDAsIDAsIC8qMyovIDEsIDAsIDAsXHJcbiAgICAgICAgICAgICAgICAvLyBiYWNrXHJcbiAgICAgICAgICAgICAgICAvKjQqLyAwLCAwLCAwLCAvKjUqLyAwLCAwLCAwLCAvKjYqLyAwLCAwLCAwLCAvKjcqLyAwLCAwLCAtMSxcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTZWNvbmQgd3JhcFxyXG4gICAgICAgICAgICAgICAgLy8gZnJvbnRcclxuICAgICAgICAgICAgICAgIC8qMCovIDAsIDAsIDAsIC8qMSovIDAsIC0xLCAwLCAvKjIqLyAwLCAwLCAwLCAvKjMqLyAwLCAxLCAwLFxyXG4gICAgICAgICAgICAgICAgLy8gYmFja1xyXG4gICAgICAgICAgICAgICAgLyo0Ki8gLTEsIDAsIDAsIC8qNSovIDAsIDAsIDAsIC8qNiovIDAsIDAsIDAsIC8qNyovIDAsIDAsIDBcclxuICAgICAgXSk7XHJcblxyXG4gICAgICAvL25vcm1hbHMgPSB0aGlzLmNyZWF0ZVZlcnRpY2VzKCk7XHJcblxyXG4gICAgICByZXR1cm4gbm9ybWFscztcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuXHJcbiAgLyoqIFRoaXMgZnVuY3Rpb24gdHlwZSB0YWtlcyB4IGFuZCB6IGFzIFBhcmFtZXRlcnMgYW5kIHJldHVybnMgYSBudW1iZXIgLSB0byBiZSB1c2VkIGFzIGEgaGVpZ2h0bWFwLiBcclxuICAgKiB4IGFuZCB6IGFyZSBtYXBwZWQgZnJvbSAwIHRvIDEgd2hlbiB1c2VkIHRvIGdlbmVyYXRlIGEgSGVpZ2h0bWFwIE1lc2hcclxuICAgKiBAYXV0aG9ycyBTaW1vbiBTdG9ybC1TY2h1bGtlLCBIRlUsIDIwMjAqL1xyXG4gIGV4cG9ydCB0eXBlIGhlaWdodE1hcEZ1bmN0aW9uID0gKHg6IG51bWJlciwgejogbnVtYmVyKSA9PiBudW1iZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlcyBhIHBsYW5hciBHcmlkIGFuZCBhcHBsaWVzIGEgSGVpZ2h0bWFwLUZ1bmN0aW9uIHRvIGl0LlxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgU2ltb24gU3RvcmwtU2NodWxrZSwgSEZVLCAyMDIwXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE1lc2hIZWlnaHRNYXAgZXh0ZW5kcyBNZXNoIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBNZXNoLnJlZ2lzdGVyU3ViY2xhc3MoTWVzaEhlaWdodE1hcCk7XHJcblxyXG4gICAgcHJpdmF0ZSByZXNvbHV0aW9uWDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSByZXNvbHV0aW9uWjogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBoZWlnaHRNYXBGdW5jdGlvbjogaGVpZ2h0TWFwRnVuY3Rpb247XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9yZXNvbHV0aW9uWDogbnVtYmVyID0gMTYsIF9yZXNvbHV0aW9uWjogbnVtYmVyID0gMTYsIF9oZWlnaHRNYXBGdW5jdGlvbj86IGhlaWdodE1hcEZ1bmN0aW9uKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMucmVzb2x1dGlvblggPSBfcmVzb2x1dGlvblg7XHJcbiAgICAgIHRoaXMucmVzb2x1dGlvblogPSBfcmVzb2x1dGlvblo7XHJcblxyXG4gICAgICBpZiAoX3Jlc29sdXRpb25aIHx8IF9yZXNvbHV0aW9uWCA8PSAwKSB7XHJcbiAgICAgICAgRGVidWcud2FybihcIkhlaWdodE1hcCBNZXNoIGNhbm5vdCBoYXZlIHJlc29sdXRpb24gdmFsdWVzIDwgMS4gXCIpO1xyXG4gICAgICAgIHRoaXMucmVzb2x1dGlvblggPSBNYXRoLm1heCgxLCB0aGlzLnJlc29sdXRpb25YKTtcclxuICAgICAgICB0aGlzLnJlc29sdXRpb25aID0gTWF0aC5tYXgoMSwgdGhpcy5yZXNvbHV0aW9uWik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChfaGVpZ2h0TWFwRnVuY3Rpb24pIHRoaXMuaGVpZ2h0TWFwRnVuY3Rpb24gPSBfaGVpZ2h0TWFwRnVuY3Rpb247XHJcbiAgICAgIGVsc2UgdGhpcy5oZWlnaHRNYXBGdW5jdGlvbiA9IGZ1bmN0aW9uIChfeDogbnVtYmVyLCBfeTogbnVtYmVyKTogbnVtYmVyIHsgcmV0dXJuIDA7IH07XHJcblxyXG4gICAgICB0aGlzLmNyZWF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBjcmVhdGVWZXJ0aWNlcygpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICBsZXQgdmVydGljZXM6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoKHRoaXMucmVzb2x1dGlvblggKyAxKSAqICh0aGlzLnJlc29sdXRpb25aICsgMSkgKiAzKTtcclxuXHJcbiAgICAgIC8vSXRlcmF0ZSBvdmVyIGVhY2ggY2VsbCB0byBnZW5lcmF0ZSBncmlkIG9mIHZlcnRpY2VzXHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDAsIHo6IG51bWJlciA9IDA7IHogPD0gdGhpcy5yZXNvbHV0aW9uWjsgeisrKSB7XHJcbiAgICAgICAgZm9yIChsZXQgeDogbnVtYmVyID0gMDsgeCA8PSB0aGlzLnJlc29sdXRpb25YOyB4KyspIHtcclxuICAgICAgICAgIC8vIFhcclxuICAgICAgICAgIHZlcnRpY2VzW2ldID0geCAvIHRoaXMucmVzb2x1dGlvblggLSAwLjU7XHJcbiAgICAgICAgICAvLyBBcHBseSBoZWlnaHRtYXAgdG8geSBjb29yZGluYXRlXHJcbiAgICAgICAgICB2ZXJ0aWNlc1tpICsgMV0gPSB0aGlzLmhlaWdodE1hcEZ1bmN0aW9uKHggLyB0aGlzLnJlc29sdXRpb25YLCB6IC8gdGhpcy5yZXNvbHV0aW9uWik7XHJcbiAgICAgICAgICAvLyBaXHJcbiAgICAgICAgICB2ZXJ0aWNlc1tpICsgMl0gPSB6IC8gdGhpcy5yZXNvbHV0aW9uWiAtIDAuNTtcclxuICAgICAgICAgIGkgKz0gMztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHZlcnRpY2VzO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBjcmVhdGVJbmRpY2VzKCk6IFVpbnQxNkFycmF5IHtcclxuICAgICAgbGV0IHZlcnQ6IG51bWJlciA9IDA7XHJcbiAgICAgIGxldCB0cmlzOiBudW1iZXIgPSAwO1xyXG5cclxuICAgICAgbGV0IGluZGljZXM6IFVpbnQxNkFycmF5ID0gbmV3IFVpbnQxNkFycmF5KHRoaXMucmVzb2x1dGlvblggKiB0aGlzLnJlc29sdXRpb25aICogNik7XHJcbiAgICAgIGZvciAobGV0IHo6IG51bWJlciA9IDA7IHogPCB0aGlzLnJlc29sdXRpb25aOyB6KyspIHtcclxuICAgICAgICBmb3IgKGxldCB4OiBudW1iZXIgPSAwOyB4IDwgdGhpcy5yZXNvbHV0aW9uWDsgeCsrKSB7XHJcblxyXG4gICAgICAgICAgLy8gRmlyc3QgdHJpYW5nbGUgb2YgZWFjaCBncmlkLWNlbGxcclxuICAgICAgICAgIGluZGljZXNbdHJpcyArIDBdID0gdmVydCArIDA7XHJcbiAgICAgICAgICBpbmRpY2VzW3RyaXMgKyAxXSA9IHZlcnQgKyB0aGlzLnJlc29sdXRpb25YICsgMTtcclxuICAgICAgICAgIGluZGljZXNbdHJpcyArIDJdID0gdmVydCArIDE7XHJcblxyXG4gICAgICAgICAgLy8gU2Vjb25kIHRyaWFuZ2xlIG9mIGVhY2ggZ3JpZC1jZWxsXHJcbiAgICAgICAgICBpbmRpY2VzW3RyaXMgKyAzXSA9IHZlcnQgKyAxO1xyXG4gICAgICAgICAgaW5kaWNlc1t0cmlzICsgNF0gPSB2ZXJ0ICsgdGhpcy5yZXNvbHV0aW9uWCArIDE7XHJcbiAgICAgICAgICBpbmRpY2VzW3RyaXMgKyA1XSA9IHZlcnQgKyB0aGlzLnJlc29sdXRpb25YICsgMjtcclxuICAgICAgICAgIHZlcnQrKztcclxuICAgICAgICAgIHRyaXMgKz0gNjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmVydCsrO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBpbmRpY2VzO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBjcmVhdGVUZXh0dXJlVVZzKCk6IEZsb2F0MzJBcnJheSB7XHJcbiAgICAgIGxldCB0ZXh0dXJlVVZzOiBGbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuaW5kaWNlcy5sZW5ndGggKiAyKTtcclxuXHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDAsIHo6IG51bWJlciA9IDA7IHogPD0gdGhpcy5yZXNvbHV0aW9uWjsgeisrKSB7XHJcbiAgICAgICAgZm9yIChsZXQgeDogbnVtYmVyID0gMDsgeCA8PSB0aGlzLnJlc29sdXRpb25YOyB4KyspIHtcclxuICAgICAgICAgIHRleHR1cmVVVnNbaV0gPSB4IC8gdGhpcy5yZXNvbHV0aW9uWDtcclxuICAgICAgICAgIHRleHR1cmVVVnNbaSArIDFdID0geiAvIHRoaXMucmVzb2x1dGlvblo7XHJcbiAgICAgICAgICBpICs9IDI7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0ZXh0dXJlVVZzO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBjcmVhdGVGYWNlTm9ybWFscygpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICByZXR1cm4gdGhpcy5jYWxjdWxhdGVGYWNlTm9ybWFscygpO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlIGEgc2ltcGxlIHB5cmFtaWQgd2l0aCBlZGdlcyBhdCB0aGUgYmFzZSBvZiBsZW5ndGggMSBhbmQgYSBoZWlnaHQgb2YgMS4gVGhlIHNpZGVzIGNvbnNpc3Rpbmcgb2Ygb25lLCB0aGUgYmFzZSBvZiB0d28gdHJpZ29uc1xyXG4gICAqIGBgYHBsYWludGV4dFxyXG4gICAqICAgICAgICAgICAgICAgNFxyXG4gICAqICAgICAgICAgICAgICAvXFxgLlxyXG4gICAqICAgICAgICAgICAgMy9fX1xcX1xcIDJcclxuICAgKiAgICAgICAgICAgMC9fX19fXFwvMVxyXG4gICAqIGBgYFxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE1lc2hQeXJhbWlkIGV4dGVuZHMgTWVzaCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gTWVzaC5yZWdpc3RlclN1YmNsYXNzKE1lc2hQeXJhbWlkKTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuY3JlYXRlKCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHByb3RlY3RlZCBjcmVhdGVWZXJ0aWNlcygpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICBsZXQgdmVydGljZXM6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoW1xyXG4gICAgICAgICAgICAgICAgLy8gZmxvb3JcclxuICAgICAgICAgICAgICAgIC8qMCovIC0xLCAwLCAxLCAvKjEqLyAxLCAwLCAxLCAgLyoyKi8gMSwgMCwgLTEsIC8qMyovIC0xLCAwLCAtMSxcclxuICAgICAgICAgICAgICAgIC8vIHRpcFxyXG4gICAgICAgICAgICAgICAgLyo0Ki8gMCwgMiwgMCwgIC8vIGRvdWJsZSBoZWlnaHQgd2lsbCBiZSBzY2FsZWQgZG93blxyXG4gICAgICAgICAgICAgICAgLy8gZmxvb3IgYWdhaW4gZm9yIHRleHR1cmluZyBhbmQgbm9ybWFsc1xyXG4gICAgICAgICAgICAgICAgLyo1Ki8gLTEsIDAsIDEsIC8qNiovIDEsIDAsIDEsICAvKjcqLyAxLCAwLCAtMSwgLyo4Ki8gLTEsIDAsIC0xXHJcbiAgICAgIF0pO1xyXG5cclxuICAgICAgLy8gc2NhbGUgZG93biB0byBhIGxlbmd0aCBvZiAxIGZvciBib3R0b20gZWRnZXMgYW5kIGhlaWdodFxyXG4gICAgICB2ZXJ0aWNlcyA9IHZlcnRpY2VzLm1hcChfdmFsdWUgPT4gX3ZhbHVlIC8gMik7XHJcbiAgICAgIHJldHVybiB2ZXJ0aWNlcztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlSW5kaWNlcygpOiBVaW50MTZBcnJheSB7XHJcbiAgICAgIGxldCBpbmRpY2VzOiBVaW50MTZBcnJheSA9IG5ldyBVaW50MTZBcnJheShbXHJcbiAgICAgICAgLy8gZnJvbnRcclxuICAgICAgICA0LCAwLCAxLFxyXG4gICAgICAgIC8vIHJpZ2h0XHJcbiAgICAgICAgNCwgMSwgMixcclxuICAgICAgICAvLyBiYWNrXHJcbiAgICAgICAgNCwgMiwgMyxcclxuICAgICAgICAvLyBsZWZ0XHJcbiAgICAgICAgNCwgMywgMCxcclxuICAgICAgICAvLyBib3R0b21cclxuICAgICAgICA1ICsgMCwgNSArIDIsIDUgKyAxLCA1ICsgMCwgNSArIDMsIDUgKyAyXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gaW5kaWNlcztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlVGV4dHVyZVVWcygpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICBsZXQgdGV4dHVyZVVWczogRmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAgICAgICAgICAgICAvLyBmcm9udFxyXG4gICAgICAgICAgICAgICAgLyowKi8gMCwgMSwgLyoxKi8gMC41LCAxLCAgLyoyKi8gMSwgMSwgLyozKi8gMC41LCAxLFxyXG4gICAgICAgICAgICAgICAgLy8gYmFja1xyXG4gICAgICAgICAgICAgICAgLyo0Ki8gMC41LCAwLFxyXG4gICAgICAgICAgICAgICAgLyo1Ki8gMCwgMCwgLyo2Ki8gMSwgMCwgIC8qNyovIDEsIDEsIC8qOCovIDAsIDFcclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiB0ZXh0dXJlVVZzO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBjcmVhdGVGYWNlTm9ybWFscygpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmNhbGN1bGF0ZUZhY2VOb3JtYWxzKCkpO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlIGEgc2ltcGxlIHF1YWQgd2l0aCBlZGdlcyBvZiBsZW5ndGggMSwgdGhlIGZhY2UgY29uc2lzdGluZyBvZiB0d28gdHJpZ29uc1xyXG4gICAqIGBgYHBsYWludGV4dFxyXG4gICAqICAgICAgICAwIF9fIDNcclxuICAgKiAgICAgICAgIHxfX3xcclxuICAgKiAgICAgICAgMSAgICAyICAgICAgICAgICAgIFxyXG4gICAqIGBgYCBcclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBNZXNoUXVhZCBleHRlbmRzIE1lc2gge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IE1lc2gucmVnaXN0ZXJTdWJjbGFzcyhNZXNoUXVhZCk7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLmNyZWF0ZSgpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlVmVydGljZXMoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgbGV0IHZlcnRpY2VzOiBGbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KFtcclxuICAgICAgICAgICAgICAgIC8qMCovIC0xLCAxLCAwLCAvKjEqLyAtMSwgLTEsIDAsICAvKjIqLyAxLCAtMSwgMCwgLyozKi8gMSwgMSwgMFxyXG4gICAgICBdKTtcclxuXHJcbiAgICAgIHZlcnRpY2VzID0gdmVydGljZXMubWFwKF92YWx1ZSA9PiBfdmFsdWUgLyAyKTtcclxuICAgICAgcmV0dXJuIHZlcnRpY2VzO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlSW5kaWNlcygpOiBVaW50MTZBcnJheSB7XHJcbiAgICAgIGxldCBpbmRpY2VzOiBVaW50MTZBcnJheSA9IG5ldyBVaW50MTZBcnJheShbXHJcbiAgICAgICAgMSwgMiwgMCwgMiwgMywgMFxyXG4gICAgICBdKTtcclxuICAgICAgcmV0dXJuIGluZGljZXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZVRleHR1cmVVVnMoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgbGV0IHRleHR1cmVVVnM6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoW1xyXG4gICAgICAgICAgICAgICAgLy8gZnJvbnRcclxuICAgICAgICAgICAgICAgIC8qMCovIDAsIDAsIC8qMSovIDAsIDEsICAvKjIqLyAxLCAxLCAvKjMqLyAxLCAwXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gdGV4dHVyZVVWcztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlRmFjZU5vcm1hbHMoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xyXG4gICAgICAgICAgICAgICAgLyowKi8gMCwgMCwgMSwgLyoxKi8gMCwgMCwgMCwgLyoyKi8gMCwgMCwgMCwgLyozKi8gMCwgMCwgMFxyXG4gICAgICBdKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBHZW5lcmF0ZSBhIFVWIFNwaGVyZSB3aXRoIGEgZ2l2ZW4gbnVtYmVyIG9mIHNlY3RvcnMgYW5kIHN0YWNrcyAoY2xhbXBlZCBhdCAxMjgqMTI4KVxyXG4gICAqIEltcGxlbWVudGF0aW9uIGJhc2VkIG9uIGh0dHA6Ly93d3cuc29uZ2hvLmNhL29wZW5nbC9nbF9zcGhlcmUuaHRtbFxyXG4gICAqIEBhdXRob3JzIFNpbW9uIFN0b3JsLVNjaHVsa2UsIEhGVSwgMjAyMCB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIwXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE1lc2hTcGhlcmUgZXh0ZW5kcyBNZXNoIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBNZXNoLnJlZ2lzdGVyU3ViY2xhc3MoTWVzaFNwaGVyZSk7XHJcblxyXG4gICAgcHVibGljIG5vcm1hbHM6IEZsb2F0MzJBcnJheTtcclxuXHJcbiAgICBwcml2YXRlIHNlY3RvcnM6IG51bWJlcjtcclxuICAgIHByaXZhdGUgc3RhY2tzOiBudW1iZXI7XHJcblxyXG4gICAgLy8gRGlydHkgV29ya2Fyb3VuZCB0byBoYXZlIGFjY2VzcyB0byB0aGUgbm9ybWFscyBmcm9tIGNyZWF0ZVZlcnRpY2VzKClcclxuICAgIC8vIHByaXZhdGUgbm9ybWFsczogQXJyYXk8bnVtYmVyPiA9IFtdO1xyXG4gICAgLy8gcHJpdmF0ZSB0ZXh0dXJlVVZzOiBBcnJheTxudW1iZXI+ID0gW107XHJcbiAgICAvLyBwdWJsaWMgdGV4dHVyZVVWczogRmxvYXQzMkFycmF5O1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3Rvcihfc2VjdG9yczogbnVtYmVyID0gMTIsIF9zdGFja3M6IG51bWJlciA9IDgpIHtcclxuICAgICAgc3VwZXIoKTtcclxuXHJcbiAgICAgIC8vQ2xhbXAgcmVzb2x1dGlvbiB0byBwcmV2ZW50IHBlcmZvcm1hbmNlIGlzc3Vlc1xyXG4gICAgICB0aGlzLnNlY3RvcnMgPSBNYXRoLm1pbihfc2VjdG9ycywgMTI4KTtcclxuICAgICAgdGhpcy5zdGFja3MgPSBNYXRoLm1pbihfc3RhY2tzLCAxMjgpO1xyXG5cclxuICAgICAgaWYgKF9zZWN0b3JzIDwgMyB8fCBfc3RhY2tzIDwgMikge1xyXG4gICAgICAgIERlYnVnLndhcm4oXCJVViBTcGhlcmUgbXVzdCBoYXZlIGF0IGxlYXN0IDMgc2VjdG9ycyBhbmQgMiBzdGFja3MgdG8gZm9ybSBhIDMtZGltZW5zaW9uYWwgc2hhcGUuXCIpO1xyXG4gICAgICAgIHRoaXMuc2VjdG9ycyA9IE1hdGgubWF4KDMsIF9zZWN0b3JzKTtcclxuICAgICAgICB0aGlzLnN0YWNrcyA9IE1hdGgubWF4KDIsIF9zdGFja3MpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmNyZWF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBjcmVhdGUoKTogdm9pZCB7XHJcbiAgICAgIGxldCB2ZXJ0aWNlczogQXJyYXk8bnVtYmVyPiA9IFtdO1xyXG4gICAgICBsZXQgbm9ybWFsczogbnVtYmVyW10gPSBbXTtcclxuICAgICAgbGV0IHRleHR1cmVVVnM6IG51bWJlcltdID0gW107XHJcblxyXG4gICAgICBsZXQgeDogbnVtYmVyO1xyXG4gICAgICBsZXQgejogbnVtYmVyO1xyXG4gICAgICBsZXQgeHo6IG51bWJlcjtcclxuICAgICAgbGV0IHk6IG51bWJlcjtcclxuXHJcblxyXG4gICAgICBsZXQgc2VjdG9yU3RlcDogbnVtYmVyID0gMiAqIE1hdGguUEkgLyB0aGlzLnNlY3RvcnM7XHJcbiAgICAgIGxldCBzdGFja1N0ZXA6IG51bWJlciA9IE1hdGguUEkgLyB0aGlzLnN0YWNrcztcclxuICAgICAgbGV0IHN0YWNrQW5nbGU6IG51bWJlcjtcclxuICAgICAgbGV0IHNlY3RvckFuZ2xlOiBudW1iZXI7XHJcblxyXG4gICAgICAvKiBhZGQgKHNlY3RvckNvdW50KzEpIHZlcnRpY2VzIHBlciBzdGFjay5cclxuICAgICAgdGhlIGZpcnN0IGFuZCBsYXN0IHZlcnRpY2VzIGhhdmUgc2FtZSBwb3NpdGlvbiBhbmQgbm9ybWFsLCBcclxuICAgICAgYnV0IGRpZmZlcmVudCB0ZXggY29vcmRzICovXHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPD0gdGhpcy5zdGFja3M7ICsraSkge1xyXG4gICAgICAgIHN0YWNrQW5nbGUgPSBNYXRoLlBJIC8gMiAtIGkgKiBzdGFja1N0ZXA7XHJcbiAgICAgICAgeHogPSBNYXRoLmNvcyhzdGFja0FuZ2xlKTtcclxuICAgICAgICB5ID0gTWF0aC5zaW4oc3RhY2tBbmdsZSk7XHJcblxyXG4gICAgICAgIC8vIGFkZCAoc2VjdG9yQ291bnQrMSkgdmVydGljZXMgcGVyIHN0YWNrXHJcbiAgICAgICAgLy8gdGhlIGZpcnN0IGFuZCBsYXN0IHZlcnRpY2VzIGhhdmUgc2FtZSBwb3NpdGlvbiBhbmQgbm9ybWFsLCBidXQgZGlmZmVyZW50IHRleCBjb29yZHNcclxuICAgICAgICBmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDw9IHRoaXMuc2VjdG9yczsgKytqKSB7XHJcbiAgICAgICAgICBzZWN0b3JBbmdsZSA9IGogKiBzZWN0b3JTdGVwO1xyXG5cclxuICAgICAgICAgIC8vdmVydGV4IHBvc2l0aW9uXHJcbiAgICAgICAgICB4ID0geHogKiBNYXRoLmNvcyhzZWN0b3JBbmdsZSk7XHJcbiAgICAgICAgICB6ID0geHogKiBNYXRoLnNpbihzZWN0b3JBbmdsZSk7XHJcbiAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKHgsIHksIHopO1xyXG5cclxuICAgICAgICAgIC8vbm9ybWFsc1xyXG4gICAgICAgICAgbm9ybWFscy5wdXNoKHgsIHksIHopO1xyXG5cclxuICAgICAgICAgIC8vVVYgQ29vcmRzXHJcbiAgICAgICAgICB0ZXh0dXJlVVZzLnB1c2goaiAvIHRoaXMuc2VjdG9ycyAqIC0xKTtcclxuICAgICAgICAgIHRleHR1cmVVVnMucHVzaChpIC8gdGhpcy5zdGFja3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gc2NhbGUgZG93blxyXG4gICAgICB2ZXJ0aWNlcyA9IHZlcnRpY2VzLm1hcChfdmFsdWUgPT4gX3ZhbHVlIC8gMik7XHJcblxyXG4gICAgICB0aGlzLnRleHR1cmVVVnMgPSBuZXcgRmxvYXQzMkFycmF5KHRleHR1cmVVVnMpO1xyXG4gICAgICB0aGlzLm5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KG5vcm1hbHMpO1xyXG4gICAgICB0aGlzLnZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSh2ZXJ0aWNlcyk7XHJcbiAgICAgIHRoaXMubm9ybWFsc0ZhY2UgPSB0aGlzLmNyZWF0ZUZhY2VOb3JtYWxzKCk7XHJcbiAgICAgIHRoaXMuaW5kaWNlcyA9IHRoaXMuY3JlYXRlSW5kaWNlcygpO1xyXG4gICAgICB0aGlzLmNyZWF0ZVJlbmRlckJ1ZmZlcnMoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlSW5kaWNlcygpOiBVaW50MTZBcnJheSB7XHJcbiAgICAgIGxldCBpbmRzOiBBcnJheTxudW1iZXI+ID0gW107XHJcblxyXG4gICAgICBsZXQgazE6IG51bWJlcjtcclxuICAgICAgbGV0IGsyOiBudW1iZXI7XHJcblxyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5zdGFja3M7ICsraSkge1xyXG4gICAgICAgIGsxID0gaSAqICh0aGlzLnNlY3RvcnMgKyAxKTsgICAvLyBiZWdpbm5pbmcgb2YgY3VycmVudCBzdGFja1xyXG4gICAgICAgIGsyID0gazEgKyB0aGlzLnNlY3RvcnMgKyAxOyAgICAvLyBiZWdpbm5pbmcgb2YgbmV4dCBzdGFja1xyXG5cclxuICAgICAgICBmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgdGhpcy5zZWN0b3JzOyArK2osICsrazEsICsrazIpIHtcclxuXHJcbiAgICAgICAgICAvLyAyIHRyaWFuZ2xlcyBwZXIgc2VjdG9yIGV4Y2x1ZGluZyBmaXJzdCBhbmQgbGFzdCBzdGFja3NcclxuICAgICAgICAgIC8vIGsxID0+IGsyID0+IGsxKzFcclxuICAgICAgICAgIGlmIChpICE9IDApIHtcclxuICAgICAgICAgICAgaW5kcy5wdXNoKGsxKTtcclxuICAgICAgICAgICAgaW5kcy5wdXNoKGsxICsgMSk7XHJcbiAgICAgICAgICAgIGluZHMucHVzaChrMik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKGkgIT0gKHRoaXMuc3RhY2tzIC0gMSkpIHtcclxuICAgICAgICAgICAgaW5kcy5wdXNoKGsxICsgMSk7XHJcbiAgICAgICAgICAgIGluZHMucHVzaChrMiArIDEpO1xyXG4gICAgICAgICAgICBpbmRzLnB1c2goazIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBsZXQgaW5kaWNlczogVWludDE2QXJyYXkgPSBuZXcgVWludDE2QXJyYXkoaW5kcyk7XHJcbiAgICAgIHJldHVybiBpbmRpY2VzO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBjcmVhdGVWZXJ0aWNlcygpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICByZXR1cm4gdGhpcy52ZXJ0aWNlcztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlVGV4dHVyZVVWcygpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICByZXR1cm4gdGhpcy50ZXh0dXJlVVZzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vVE9ETzogd2UgYWxzbyBuZWVkIFJFQUwgZmFjZSBub3JtYWxzXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlRmFjZU5vcm1hbHMoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgcmV0dXJuIHRoaXMubm9ybWFscztcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBHZW5lcmF0ZSB0d28gcXVhZHMgcGxhY2VkIGJhY2sgdG8gYmFjaywgdGhlIG9uZSBmYWNpbmcgaW4gbmVnYXRpdmUgWi1kaXJlY3Rpb24gaXMgdGV4dHVyZWQgcmV2ZXJzZWRcclxuICAgKiBgYGBwbGFpbnRleHRcclxuICAgKiAgICAgICAgMCBfXyAzXHJcbiAgICogICAgICAgICB8X198XHJcbiAgICogICAgICAgIDEgICAgMiAgICAgICAgICAgICBcclxuICAgKiBgYGAgXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjBcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgTWVzaFNwcml0ZSBleHRlbmRzIE1lc2gge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IE1lc2gucmVnaXN0ZXJTdWJjbGFzcyhNZXNoU3ByaXRlKTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuY3JlYXRlKCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHByb3RlY3RlZCBjcmVhdGVWZXJ0aWNlcygpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICBsZXQgdmVydGljZXM6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoW1xyXG4gICAgICAgIC8qMCovIC0xLCAxLCAwLCAvKjEqLyAtMSwgLTEsIDAsICAvKjIqLyAxLCAtMSwgMCwgLyozKi8gMSwgMSwgMFxyXG4gICAgICBdKTtcclxuXHJcbiAgICAgIHZlcnRpY2VzID0gdmVydGljZXMubWFwKF92YWx1ZSA9PiBfdmFsdWUgLyAyKTtcclxuXHJcbiAgICAgIHJldHVybiB2ZXJ0aWNlcztcclxuICAgIH1cclxuICAgIHByb3RlY3RlZCBjcmVhdGVJbmRpY2VzKCk6IFVpbnQxNkFycmF5IHtcclxuICAgICAgbGV0IGluZGljZXM6IFVpbnQxNkFycmF5ID0gbmV3IFVpbnQxNkFycmF5KFtcclxuICAgICAgICAxLCAyLCAwLCAyLCAzLCAwLCAvL2Zyb250XHJcbiAgICAgICAgMCwgMywgMSwgMywgMiwgMSAgLy9iYWNrXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gaW5kaWNlcztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlVGV4dHVyZVVWcygpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICBsZXQgdGV4dHVyZVVWczogRmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAgICAgLy8gZnJvbnRcclxuICAgICAgICAvKjAqLyAwLCAwLCAvKjEqLyAwLCAxLCAgLyoyKi8gMSwgMSwgLyozKi8gMSwgMFxyXG4gICAgICBdKTtcclxuICAgICAgcmV0dXJuIHRleHR1cmVVVnM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZUZhY2VOb3JtYWxzKCk6IEZsb2F0MzJBcnJheSB7XHJcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KFtcclxuICAgICAgICAvKjA6IG5vcm1hbCBvZiBmcm9udCBmYWNlKi9cclxuICAgICAgICAwLCAwLCAxLFxyXG4gICAgICAgIC8qMTogbm9ybWFsIG9mIGJhY2sgZmFjZSovXHJcbiAgICAgICAgMCwgMCwgLTEsXHJcbiAgICAgICAgLyoyKi9cclxuICAgICAgICAwLCAwLCAwLFxyXG4gICAgICAgIC8qMyovXHJcbiAgICAgICAgMCwgMCwgMFxyXG4gICAgICBdKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgaW50ZXJmYWNlIE1hcENsYXNzVG9Db21wb25lbnRzIHtcclxuICAgIFtjbGFzc05hbWU6IHN0cmluZ106IENvbXBvbmVudFtdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVwcmVzZW50cyBhIG5vZGUgaW4gdGhlIHNjZW5ldHJlZS5cclxuICAgKiBAYXV0aG9ycyBKYXNjaGEgS2FyYWfDtmwsIEhGVSwgMjAxOSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL0ppcmthRGVsbE9yby9GVURHRS93aWtpL0dyYXBoXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE5vZGUgZXh0ZW5kcyBFdmVudFRhcmdldMaSIGltcGxlbWVudHMgU2VyaWFsaXphYmxlIHtcclxuICAgIHB1YmxpYyBuYW1lOiBzdHJpbmc7IC8vIFRoZSBuYW1lIHRvIGNhbGwgdGhpcyBub2RlIGJ5LlxyXG4gICAgcHVibGljIHJlYWRvbmx5IG10eFdvcmxkOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKTtcclxuICAgIHB1YmxpYyB0aW1lc3RhbXBVcGRhdGU6IG51bWJlciA9IDA7XHJcblxyXG4gICAgcHJpdmF0ZSBwYXJlbnQ6IE5vZGUgfCBudWxsID0gbnVsbDsgLy8gVGhlIHBhcmVudCBvZiB0aGlzIG5vZGUuXHJcbiAgICBwcml2YXRlIGNoaWxkcmVuOiBOb2RlW10gPSBbXTsgLy8gYXJyYXkgb2YgY2hpbGQgbm9kZXMgYXBwZW5kZWQgdG8gdGhpcyBub2RlLlxyXG4gICAgcHJpdmF0ZSBjb21wb25lbnRzOiBNYXBDbGFzc1RvQ29tcG9uZW50cyA9IHt9O1xyXG4gICAgLy8gcHJpdmF0ZSB0YWdzOiBzdHJpbmdbXSA9IFtdOyAvLyBOYW1lcyBvZiB0YWdzIHRoYXQgYXJlIGF0dGFjaGVkIHRvIHRoaXMgbm9kZS4gKFRPRE86IEFzIG9mIHlldCBubyBmdW5jdGlvbmFsaXR5KVxyXG4gICAgLy8gcHJpdmF0ZSBsYXllcnM6IHN0cmluZ1tdID0gW107IC8vIE5hbWVzIG9mIHRoZSBsYXllcnMgdGhpcyBub2RlIGlzIG9uLiAoVE9ETzogQXMgb2YgeWV0IG5vIGZ1bmN0aW9uYWxpdHkpXHJcbiAgICBwcml2YXRlIGxpc3RlbmVyczogTWFwRXZlbnRUeXBlVG9MaXN0ZW5lciA9IHt9O1xyXG4gICAgcHJpdmF0ZSBjYXB0dXJlczogTWFwRXZlbnRUeXBlVG9MaXN0ZW5lciA9IHt9O1xyXG4gICAgcHJpdmF0ZSBhY3RpdmU6IGJvb2xlYW4gPSB0cnVlO1xyXG5cclxuICAgIHByaXZhdGUgd29ybGRJbnZlcnNlVXBkYXRlZDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSB3b3JsZEludmVyc2U6IE1hdHJpeDR4NDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgbm9kZSB3aXRoIGEgbmFtZSBhbmQgaW5pdGlhbGl6ZXMgYWxsIGF0dHJpYnV0ZXNcclxuICAgICAqIEBwYXJhbSBfbmFtZSBUaGUgbmFtZSBieSB3aGljaCB0aGUgbm9kZSBjYW4gYmUgY2FsbGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX25hbWU6IHN0cmluZykge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLm5hbWUgPSBfbmFtZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYWN0aXZhdGUoX29uOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuYWN0aXZlID0gX29uO1xyXG4gICAgICAvLyBUT0RPOiBjaGVjayBpZiBDT01QT05FTlRfQUNUSVZBVEUvREVBQ1RJVkFURSBpcyB0aGUgY29ycmVjdCBldmVudCB0byBkaXNwYXRjaC4gU2hvdWxkbid0IGl0IGJlIHNvbWV0aGluZyBsaWtlIE5PREVfQUNUSVZBVEUvREVBQ1RJVkFURT9cclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChfb24gPyBFVkVOVC5DT01QT05FTlRfQUNUSVZBVEUgOiBFVkVOVC5DT01QT05FTlRfREVBQ1RJVkFURSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgaXNBY3RpdmUoKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLmFjdGl2ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNob3J0Y3V0IHRvIHJldHJpZXZlIHRoaXMgbm9kZXMgW1tDb21wb25lbnRUcmFuc2Zvcm1dXVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGNtcFRyYW5zZm9ybSgpOiBDb21wb25lbnRUcmFuc2Zvcm0ge1xyXG4gICAgICByZXR1cm4gPENvbXBvbmVudFRyYW5zZm9ybT50aGlzLmdldENvbXBvbmVudHMoQ29tcG9uZW50VHJhbnNmb3JtKVswXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNob3J0Y3V0IHRvIHJldHJpZXZlIHRoZSBsb2NhbCBbW01hdHJpeDR4NF1dIGF0dGFjaGVkIHRvIHRoaXMgbm9kZXMgW1tDb21wb25lbnRUcmFuc2Zvcm1dXSAgXHJcbiAgICAgKiBGYWlscyBpZiBubyBbW0NvbXBvbmVudFRyYW5zZm9ybV1dIGlzIGF0dGFjaGVkXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgbXR4TG9jYWwoKTogTWF0cml4NHg0IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY21wVHJhbnNmb3JtLmxvY2FsO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBwdWJsaWMgZ2V0IG10eFdvcmxkSW52ZXJzZSgpOiBNYXRyaXg0eDQge1xyXG4gICAgICBpZiAodGhpcy53b3JsZEludmVyc2VVcGRhdGVkICE9IHRoaXMudGltZXN0YW1wVXBkYXRlKVxyXG4gICAgICAgIHRoaXMud29ybGRJbnZlcnNlID0gTWF0cml4NHg0LklOVkVSU0lPTih0aGlzLm10eFdvcmxkKTtcclxuXHJcbiAgICAgIHRoaXMud29ybGRJbnZlcnNlVXBkYXRlZCA9IHRoaXMudGltZXN0YW1wVXBkYXRlO1xyXG4gICAgICByZXR1cm4gdGhpcy53b3JsZEludmVyc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gI3JlZ2lvbiBTY2VuZXRyZWVcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGlzIG5vZGVzIHBhcmVudCBub2RlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRQYXJlbnQoKTogTm9kZSB8IG51bGwge1xyXG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFjZXMgYmFjayB0aGUgYW5jZXN0b3JzIG9mIHRoaXMgbm9kZSBhbmQgcmV0dXJucyB0aGUgZmlyc3RcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEFuY2VzdG9yKCk6IE5vZGUgfCBudWxsIHtcclxuICAgICAgbGV0IGFuY2VzdG9yOiBOb2RlID0gdGhpcztcclxuICAgICAgd2hpbGUgKGFuY2VzdG9yLmdldFBhcmVudCgpKVxyXG4gICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IuZ2V0UGFyZW50KCk7XHJcbiAgICAgIHJldHVybiBhbmNlc3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBhdHRhY2hlZCB0byB0aGlzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgbkNoaWxkcmVuKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgY2hpbGQgYXQgdGhlIGdpdmVuIGluZGV4IGluIHRoZSBsaXN0IG9mIGNoaWxkcmVuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRDaGlsZChfaW5kZXg6IG51bWJlcik6IE5vZGUge1xyXG4gICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltfaW5kZXhdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBsaXN0IG9mIGNoaWxkcmVuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRDaGlsZHJlbigpOiBOb2RlW10ge1xyXG4gICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5zbGljZSgwKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgcmVmZXJlbmNlcyB0byBjaGlsZG5vZGVzIHdpdGggdGhlIHN1cHBsaWVkIG5hbWUuIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Q2hpbGRyZW5CeU5hbWUoX25hbWU6IHN0cmluZyk6IE5vZGVbXSB7XHJcbiAgICAgIGxldCBmb3VuZDogTm9kZVtdID0gW107XHJcbiAgICAgIGZvdW5kID0gdGhpcy5jaGlsZHJlbi5maWx0ZXIoKF9ub2RlOiBOb2RlKSA9PiBfbm9kZS5uYW1lID09IF9uYW1lKTtcclxuICAgICAgcmV0dXJuIGZvdW5kO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2ltcGx5IGNhbGxzIFtbYWRkQ2hpbGRdXS4gVGhpcyByZWZlcmVuY2UgaXMgaGVyZSBzb2xlbHkgYmVjYXVzZSBhcHBlbmRDaGlsZCBpcyB0aGUgZXF1aXZhbGVudCBtZXRob2QgaW4gRE9NLlxyXG4gICAgICogU2VlIGFuZCBwcmVmZXJhYmx5IHVzZSBbW2FkZENoaWxkXV1cclxuICAgICAqL1xyXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBtZW1iZXItb3JkZXJpbmdcclxuICAgIHB1YmxpYyByZWFkb25seSBhcHBlbmRDaGlsZDogKF9jaGlsZDogTm9kZSkgPT4gdm9pZCA9IHRoaXMuYWRkQ2hpbGQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHRoZSBnaXZlbiByZWZlcmVuY2UgdG8gYSBub2RlIHRvIHRoZSBsaXN0IG9mIGNoaWxkcmVuLCBpZiBub3QgYWxyZWFkeSBpblxyXG4gICAgICogQHRocm93cyBFcnJvciB3aGVuIHRyeWluZyB0byBhZGQgYW4gYW5jZXN0b3Igb2YgdGhpcyBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFkZENoaWxkKF9jaGlsZDogTm9kZSk6IHZvaWQge1xyXG4gICAgICBpZiAodGhpcy5jaGlsZHJlbi5pbmNsdWRlcyhfY2hpbGQpKVxyXG4gICAgICAgIC8vIF9ub2RlIGlzIGFscmVhZHkgYSBjaGlsZCBvZiB0aGlzXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgbGV0IGluQXVkaW9HcmFwaDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgICBsZXQgZ3JhcGhMaXN0ZW5lZDogTm9kZSA9IEF1ZGlvTWFuYWdlci5kZWZhdWx0LmdldEdyYXBoTGlzdGVuaW5nVG8oKTtcclxuICAgICAgbGV0IGFuY2VzdG9yOiBOb2RlID0gdGhpcztcclxuICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XHJcbiAgICAgICAgYW5jZXN0b3IudGltZXN0YW1wVXBkYXRlID0gMDtcclxuICAgICAgICBpbkF1ZGlvR3JhcGggPSBpbkF1ZGlvR3JhcGggfHwgKGFuY2VzdG9yID09IGdyYXBoTGlzdGVuZWQpO1xyXG4gICAgICAgIGlmIChhbmNlc3RvciA9PSBfY2hpbGQpXHJcbiAgICAgICAgICB0aHJvdyAobmV3IEVycm9yKFwiQ3ljbGljIHJlZmVyZW5jZSBwcm9oaWJpdGVkIGluIG5vZGUgaGllcmFyY2h5LCBhbmNlc3RvcnMgbXVzdCBub3QgYmUgYWRkZWQgYXMgY2hpbGRyZW5cIikpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgcHJldmlvdXNQYXJlbnQ6IE5vZGUgPSBfY2hpbGQucGFyZW50O1xyXG4gICAgICBpZiAocHJldmlvdXNQYXJlbnQpXHJcbiAgICAgICAgcHJldmlvdXNQYXJlbnQucmVtb3ZlQ2hpbGQoX2NoaWxkKTtcclxuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKF9jaGlsZCk7XHJcbiAgICAgIF9jaGlsZC5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICBfY2hpbGQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuQ0hJTERfQVBQRU5ELCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xyXG4gICAgICBpZiAoaW5BdWRpb0dyYXBoKVxyXG4gICAgICAgIF9jaGlsZC5icm9hZGNhc3RFdmVudChuZXcgRXZlbnQoRVZFTlRfQVVESU8uQ0hJTERfQVBQRU5EKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSByZWZlcmVuY2UgdG8gdGhlIGdpdmUgbm9kZSBmcm9tIHRoZSBsaXN0IG9mIGNoaWxkcmVuXHJcbiAgICAgKiBAcGFyYW0gX2NoaWxkIFRoZSBub2RlIHRvIGJlIHJlbW92ZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZW1vdmVDaGlsZChfY2hpbGQ6IE5vZGUpOiB2b2lkIHtcclxuICAgICAgbGV0IGZvdW5kOiBudW1iZXIgPSB0aGlzLmZpbmRDaGlsZChfY2hpbGQpO1xyXG4gICAgICBpZiAoZm91bmQgPCAwKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIF9jaGlsZC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVC5DSElMRF9SRU1PVkUsIHsgYnViYmxlczogdHJ1ZSB9KSk7XHJcbiAgICAgIGlmICh0aGlzLmlzRGVzY2VuZGFudE9mKEF1ZGlvTWFuYWdlci5kZWZhdWx0LmdldEdyYXBoTGlzdGVuaW5nVG8oKSkpXHJcbiAgICAgICAgX2NoaWxkLmJyb2FkY2FzdEV2ZW50KG5ldyBFdmVudChFVkVOVF9BVURJTy5DSElMRF9SRU1PVkUpKTtcclxuICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoZm91bmQsIDEpO1xyXG4gICAgICBfY2hpbGQucGFyZW50ID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBub2RlIGluIHRoZSBsaXN0IG9mIGNoaWxkcmVuIG9yIC0xIGlmIG5vdCBmb3VuZFxyXG4gICAgICogQHBhcmFtIF9zZWFyY2ggVGhlIG5vZGUgdG8gYmUgZm91bmQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBmaW5kQ2hpbGQoX3NlYXJjaDogTm9kZSk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmluZGV4T2YoX3NlYXJjaCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXBsYWNlcyBhIGNoaWxkIG5vZGUgd2l0aCBhbm90aGVyLCBwcmVzZXJ2aW5nIHRoZSBwb3NpdGlvbiBpbiB0aGUgbGlzdCBvZiBjaGlsZHJlblxyXG4gICAgICogQHBhcmFtIF9yZXBsYWNlIFRoZSBub2RlIHRvIGJlIHJlcGxhY2VkXHJcbiAgICAgKiBAcGFyYW0gX3dpdGggVGhlIG5vZGUgdG8gcmVwbGFjZSB3aXRoXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZXBsYWNlQ2hpbGQoX3JlcGxhY2U6IE5vZGUsIF93aXRoOiBOb2RlKTogYm9vbGVhbiB7XHJcbiAgICAgIGxldCBmb3VuZDogbnVtYmVyID0gdGhpcy5maW5kQ2hpbGQoX3JlcGxhY2UpO1xyXG4gICAgICBpZiAoZm91bmQgPCAwKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgIGxldCBwcmV2aW91c1BhcmVudDogTm9kZSA9IF93aXRoLmdldFBhcmVudCgpO1xyXG4gICAgICBpZiAocHJldmlvdXNQYXJlbnQpXHJcbiAgICAgICAgcHJldmlvdXNQYXJlbnQucmVtb3ZlQ2hpbGQoX3dpdGgpO1xyXG5cclxuICAgICAgX3JlcGxhY2UucGFyZW50ID0gbnVsbDtcclxuICAgICAgdGhpcy5jaGlsZHJlbltmb3VuZF0gPSBfd2l0aDtcclxuICAgICAgX3dpdGgucGFyZW50ID0gdGhpcztcclxuXHJcbiAgICAgIF93aXRoLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULkNISUxEX0FQUEVORCwgeyBidWJibGVzOiB0cnVlIH0pKTtcclxuICAgICAgaWYgKHRoaXMuaXNEZXNjZW5kYW50T2YoQXVkaW9NYW5hZ2VyLmRlZmF1bHQuZ2V0R3JhcGhMaXN0ZW5pbmdUbygpKSlcclxuICAgICAgICBfd2l0aC5icm9hZGNhc3RFdmVudChuZXcgRXZlbnQoRVZFTlRfQVVESU8uQ0hJTERfQVBQRU5EKSk7XHJcblxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRvciB5aWVsZGluZyB0aGUgbm9kZSBhbmQgYWxsIGRlY2VuZGFudHMgaW4gdGhlIGdyYXBoIGJlbG93IGZvciBpdGVyYXRpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBncmFwaCgpOiBJdGVyYWJsZUl0ZXJhdG9yPE5vZGU+IHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2V0R3JhcGhHZW5lcmF0b3IoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgaXNVcGRhdGVkKF90aW1lc3RhbXBVcGRhdGU6IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gKHRoaXMudGltZXN0YW1wVXBkYXRlID09IF90aW1lc3RhbXBVcGRhdGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBpc0Rlc2NlbmRhbnRPZihfYW5jZXN0b3I6IE5vZGUpOiBib29sZWFuIHtcclxuICAgICAgbGV0IG5vZGU6IE5vZGUgPSB0aGlzO1xyXG4gICAgICB3aGlsZSAobm9kZSAmJiBub2RlICE9IF9hbmNlc3RvcilcclxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XHJcbiAgICAgIHJldHVybiAobm9kZSAhPSBudWxsKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgYSBNdXRhdG9yIGZyb20gW1tBbmltYXRpb25dXSB0byBhbGwgaXRzIGNvbXBvbmVudHMgYW5kIHRyYW5zZmVycyBpdCB0byBpdHMgY2hpbGRyZW4uXHJcbiAgICAgKiBAcGFyYW0gX211dGF0b3IgVGhlIG11dGF0b3IgZ2VuZXJhdGVkIGZyb20gYW4gW1tBbmltYXRpb25dXVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXBwbHlBbmltYXRpb24oX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgaWYgKF9tdXRhdG9yLmNvbXBvbmVudHMpIHtcclxuICAgICAgICBmb3IgKGxldCBjb21wb25lbnROYW1lIGluIF9tdXRhdG9yLmNvbXBvbmVudHMpIHtcclxuICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudHNbY29tcG9uZW50TmFtZV0pIHtcclxuICAgICAgICAgICAgbGV0IG11dGF0b3JPZkNvbXBvbmVudDogTXV0YXRvciA9IDxNdXRhdG9yPl9tdXRhdG9yLmNvbXBvbmVudHM7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgaW4gbXV0YXRvck9mQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50c1tjb21wb25lbnROYW1lXVsraV0pIHtcclxuICAgICAgICAgICAgICAgIGxldCBjb21wb25lbnRUb011dGF0ZTogQ29tcG9uZW50ID0gdGhpcy5jb21wb25lbnRzW2NvbXBvbmVudE5hbWVdWytpXTtcclxuICAgICAgICAgICAgICAgIGxldCBtdXRhdG9yQXJyYXk6IE11dGF0b3JbXSA9ICg8QXJyYXk8TXV0YXRvcj4+bXV0YXRvck9mQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdKTtcclxuICAgICAgICAgICAgICAgIGxldCBtdXRhdG9yV2l0aENvbXBvbmVudE5hbWU6IE11dGF0b3IgPSA8TXV0YXRvcj5tdXRhdG9yQXJyYXlbK2ldO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY25hbWUgaW4gbXV0YXRvcldpdGhDb21wb25lbnROYW1lKSB7ICAgLy8gdHJpY2sgdXNlZCB0byBnZXQgdGhlIG9ubHkgZW50cnkgaW4gdGhlIGxpc3RcclxuICAgICAgICAgICAgICAgICAgbGV0IG11dGF0b3JUb0dpdmU6IE11dGF0b3IgPSA8TXV0YXRvcj5tdXRhdG9yV2l0aENvbXBvbmVudE5hbWVbY25hbWVdO1xyXG4gICAgICAgICAgICAgICAgICBjb21wb25lbnRUb011dGF0ZS5tdXRhdGUobXV0YXRvclRvR2l2ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChfbXV0YXRvci5jaGlsZHJlbikge1xyXG4gICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCAoPEFycmF5PE9iamVjdD4+X211dGF0b3IuY2hpbGRyZW4pLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBsZXQgbmFtZTogc3RyaW5nID0gKDxOb2RlPig8QXJyYXk8TXV0YXRvcj4+X211dGF0b3IuY2hpbGRyZW4pW2ldW1wixpIuTm9kZVwiXSkubmFtZTtcclxuICAgICAgICAgIGxldCBjaGlsZE5vZGVzOiBOb2RlW10gPSB0aGlzLmdldENoaWxkcmVuQnlOYW1lKG5hbWUpO1xyXG4gICAgICAgICAgZm9yIChsZXQgY2hpbGROb2RlIG9mIGNoaWxkTm9kZXMpIHtcclxuICAgICAgICAgICAgY2hpbGROb2RlLmFwcGx5QW5pbWF0aW9uKDxNdXRhdG9yPig8QXJyYXk8TXV0YXRvcj4+X211dGF0b3IuY2hpbGRyZW4pW2ldW1wixpIuTm9kZVwiXSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyAjZW5kcmVnaW9uXHJcblxyXG4gICAgLy8gI3JlZ2lvbiBDb21wb25lbnRzXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGFsbCBjb21wb25lbnRzIGF0dGFjaGVkIHRvIHRoaXMgbm9kZSwgaW5kZXBlbmRlbnQgb2YgdHlwZS4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRBbGxDb21wb25lbnRzKCk6IENvbXBvbmVudFtdIHtcclxuICAgICAgbGV0IGFsbDogQ29tcG9uZW50W10gPSBbXTtcclxuICAgICAgZm9yIChsZXQgdHlwZSBpbiB0aGlzLmNvbXBvbmVudHMpIHtcclxuICAgICAgICBhbGwgPSBhbGwuY29uY2F0KHRoaXMuY29tcG9uZW50c1t0eXBlXSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGFsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgbGlzdCBvZiBjb21wb25lbnRzIG9mIHRoZSBnaXZlbiBjbGFzcyBhdHRhY2hlZCB0byB0aGlzIG5vZGUuIFxyXG4gICAgICogQHBhcmFtIF9jbGFzcyBUaGUgY2xhc3Mgb2YgdGhlIGNvbXBvbmVudHMgdG8gYmUgZm91bmQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRDb21wb25lbnRzPFQgZXh0ZW5kcyBDb21wb25lbnQ+KF9jbGFzczogbmV3ICgpID0+IFQpOiBUW10ge1xyXG4gICAgICByZXR1cm4gPFRbXT4odGhpcy5jb21wb25lbnRzW19jbGFzcy5uYW1lXSB8fCBbXSkuc2xpY2UoMCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGNvbXBvbnRlbnQgZm91bmQgb2YgdGhlIGdpdmVuIGNsYXNzIGF0dGFjaGVkIHRoaXMgbm9kZSBvciBudWxsLCBpZiBsaXN0IGlzIGVtcHR5IG9yIGRvZXNuJ3QgZXhpc3RcclxuICAgICAqIEBwYXJhbSBfY2xhc3MgVGhlIGNsYXNzIG9mIHRoZSBjb21wb25lbnRzIHRvIGJlIGZvdW5kLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Q29tcG9uZW50PFQgZXh0ZW5kcyBDb21wb25lbnQ+KF9jbGFzczogbmV3ICgpID0+IFQpOiBUIHtcclxuICAgICAgbGV0IGxpc3Q6IFRbXSA9IDxUW10+dGhpcy5jb21wb25lbnRzW19jbGFzcy5uYW1lXTtcclxuICAgICAgaWYgKGxpc3QpXHJcbiAgICAgICAgcmV0dXJuIGxpc3RbMF07XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgc3VwcGxpZWQgY29tcG9uZW50IGludG8gdGhlIG5vZGVzIGNvbXBvbmVudCBtYXAuXHJcbiAgICAgKiBAcGFyYW0gX2NvbXBvbmVudCBUaGUgY29tcG9uZW50IHRvIGJlIHB1c2hlZCBpbnRvIHRoZSBhcnJheS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFkZENvbXBvbmVudChfY29tcG9uZW50OiBDb21wb25lbnQpOiB2b2lkIHtcclxuICAgICAgaWYgKF9jb21wb25lbnQuZ2V0Q29udGFpbmVyKCkgPT0gdGhpcylcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIGxldCBjbXBMaXN0OiBDb21wb25lbnRbXSA9IHRoaXMuY29tcG9uZW50c1tfY29tcG9uZW50LnR5cGVdO1xyXG4gICAgICBpZiAoY21wTGlzdCA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHRoaXMuY29tcG9uZW50c1tfY29tcG9uZW50LnR5cGVdID0gW19jb21wb25lbnRdO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgaWYgKGNtcExpc3QubGVuZ3RoICYmIF9jb21wb25lbnQuaXNTaW5nbGV0b24pXHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb21wb25lbnQgaXMgbWFya2VkIHNpbmdsZXRvbiBhbmQgY2FuJ3QgYmUgYXR0YWNoZWQsIG5vIG1vcmUgdGhhbiBvbmUgYWxsb3dlZFwiKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICBjbXBMaXN0LnB1c2goX2NvbXBvbmVudCk7XHJcblxyXG4gICAgICBfY29tcG9uZW50LnNldENvbnRhaW5lcih0aGlzKTtcclxuICAgICAgX2NvbXBvbmVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVC5DT01QT05FTlRfQUREKSk7XHJcbiAgICB9XHJcbiAgICAvKiogXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBjb21wb25lbnQgZnJvbSB0aGUgbm9kZSwgaWYgaXQgd2FzIGF0dGFjaGVkLCBhbmQgc2V0cyBpdHMgcGFyZW50IHRvIG51bGwuIFxyXG4gICAgICogQHBhcmFtIF9jb21wb25lbnQgVGhlIGNvbXBvbmVudCB0byBiZSByZW1vdmVkXHJcbiAgICAgKiBAdGhyb3dzIEV4Y2VwdGlvbiB3aGVuIGNvbXBvbmVudCBpcyBub3QgZm91bmRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlbW92ZUNvbXBvbmVudChfY29tcG9uZW50OiBDb21wb25lbnQpOiB2b2lkIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBsZXQgY29tcG9uZW50c09mVHlwZTogQ29tcG9uZW50W10gPSB0aGlzLmNvbXBvbmVudHNbX2NvbXBvbmVudC50eXBlXTtcclxuICAgICAgICBsZXQgZm91bmRBdDogbnVtYmVyID0gY29tcG9uZW50c09mVHlwZS5pbmRleE9mKF9jb21wb25lbnQpO1xyXG4gICAgICAgIGlmIChmb3VuZEF0IDwgMClcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBfY29tcG9uZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULkNPTVBPTkVOVF9SRU1PVkUpKTtcclxuICAgICAgICBjb21wb25lbnRzT2ZUeXBlLnNwbGljZShmb3VuZEF0LCAxKTtcclxuICAgICAgICBfY29tcG9uZW50LnNldENvbnRhaW5lcihudWxsKTtcclxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gcmVtb3ZlIGNvbXBvbmVudCAnJHtfY29tcG9uZW50fSdpbiBub2RlIG5hbWVkICcke3RoaXMubmFtZX0nYCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vICNlbmRyZWdpb25cclxuXHJcbiAgICAvLyAjcmVnaW9uIFNlcmlhbGl6YXRpb25cclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge1xyXG4gICAgICAgIG5hbWU6IHRoaXMubmFtZVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgbGV0IGNvbXBvbmVudHM6IFNlcmlhbGl6YXRpb24gPSB7fTtcclxuICAgICAgZm9yIChsZXQgdHlwZSBpbiB0aGlzLmNvbXBvbmVudHMpIHtcclxuICAgICAgICBjb21wb25lbnRzW3R5cGVdID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgY29tcG9uZW50IG9mIHRoaXMuY29tcG9uZW50c1t0eXBlXSkge1xyXG4gICAgICAgICAgLy8gY29tcG9uZW50c1t0eXBlXS5wdXNoKGNvbXBvbmVudC5zZXJpYWxpemUoKSk7XHJcbiAgICAgICAgICBjb21wb25lbnRzW3R5cGVdLnB1c2goU2VyaWFsaXplci5zZXJpYWxpemUoY29tcG9uZW50KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHNlcmlhbGl6YXRpb25bXCJjb21wb25lbnRzXCJdID0gY29tcG9uZW50cztcclxuXHJcbiAgICAgIGxldCBjaGlsZHJlbjogU2VyaWFsaXphdGlvbltdID0gW107XHJcbiAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcclxuICAgICAgICBjaGlsZHJlbi5wdXNoKFNlcmlhbGl6ZXIuc2VyaWFsaXplKGNoaWxkKSk7XHJcbiAgICAgIH1cclxuICAgICAgc2VyaWFsaXphdGlvbltcImNoaWxkcmVuXCJdID0gY2hpbGRyZW47XHJcblxyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULk5PREVfU0VSSUFMSVpFRCkpO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBTZXJpYWxpemFibGUge1xyXG4gICAgICB0aGlzLm5hbWUgPSBfc2VyaWFsaXphdGlvbi5uYW1lO1xyXG4gICAgICAvLyB0aGlzLnBhcmVudCA9IGlzIHNldCB3aGVuIHRoZSBub2RlcyBhcmUgYWRkZWRcclxuXHJcbiAgICAgIC8vIGRlc2VyaWFsaXplIGNvbXBvbmVudHMgZmlyc3Qgc28gc2NyaXB0cyBjYW4gcmVhY3QgdG8gY2hpbGRyZW4gYmVpbmcgYXBwZW5kZWRcclxuICAgICAgZm9yIChsZXQgdHlwZSBpbiBfc2VyaWFsaXphdGlvbi5jb21wb25lbnRzKSB7XHJcbiAgICAgICAgZm9yIChsZXQgc2VyaWFsaXplZENvbXBvbmVudCBvZiBfc2VyaWFsaXphdGlvbi5jb21wb25lbnRzW3R5cGVdKSB7XHJcbiAgICAgICAgICBsZXQgZGVzZXJpYWxpemVkQ29tcG9uZW50OiBDb21wb25lbnQgPSA8Q29tcG9uZW50PlNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoc2VyaWFsaXplZENvbXBvbmVudCk7XHJcbiAgICAgICAgICB0aGlzLmFkZENvbXBvbmVudChkZXNlcmlhbGl6ZWRDb21wb25lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yIChsZXQgc2VyaWFsaXplZENoaWxkIG9mIF9zZXJpYWxpemF0aW9uLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgbGV0IGRlc2VyaWFsaXplZENoaWxkOiBOb2RlID0gPE5vZGU+U2VyaWFsaXplci5kZXNlcmlhbGl6ZShzZXJpYWxpemVkQ2hpbGQpO1xyXG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoZGVzZXJpYWxpemVkQ2hpbGQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULk5PREVfREVTRVJJQUxJWkVEKSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLy8gI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vICNyZWdpb24gRXZlbnRzXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgdG8gdGhlIG5vZGUuIFRoZSBnaXZlbiBoYW5kbGVyIHdpbGwgYmUgY2FsbGVkIHdoZW4gYSBtYXRjaGluZyBldmVudCBpcyBwYXNzZWQgdG8gdGhlIG5vZGUuXHJcbiAgICAgKiBEZXZpYXRpbmcgZnJvbSB0aGUgc3RhbmRhcmQgRXZlbnRUYXJnZXQsIGhlcmUgdGhlIF9oYW5kbGVyIG11c3QgYmUgYSBmdW5jdGlvbiBhbmQgX2NhcHR1cmUgaXMgdGhlIG9ubHkgb3B0aW9uLlxyXG4gICAgICogQHBhcmFtIF90eXBlIFRoZSB0eXBlIG9mIHRoZSBldmVudCwgc2hvdWxkIGJlIGFuIGVudW1lcmF0ZWQgdmFsdWUgb2YgTk9ERV9FVkVOVCwgY2FuIGJlIGFueSBzdHJpbmdcclxuICAgICAqIEBwYXJhbSBfaGFuZGxlciBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBldmVudCByZWFjaGVzIHRoaXMgbm9kZVxyXG4gICAgICogQHBhcmFtIF9jYXB0dXJlIFdoZW4gdHJ1ZSwgdGhlIGxpc3RlbmVyIGxpc3RlbnMgaW4gdGhlIGNhcHR1cmUgcGhhc2UsIHdoZW4gdGhlIGV2ZW50IHRyYXZlbHMgZGVlcGVyIGludG8gdGhlIGhpZXJhcmNoeSBvZiBub2Rlcy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFkZEV2ZW50TGlzdGVuZXIoX3R5cGU6IEVWRU5UIHwgc3RyaW5nLCBfaGFuZGxlcjogRXZlbnRMaXN0ZW5lciwgX2NhcHR1cmU6IGJvb2xlYW4gLyp8IEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zKi8gPSBmYWxzZSk6IHZvaWQge1xyXG4gICAgICBsZXQgbGlzdExpc3RlbmVyczogTWFwRXZlbnRUeXBlVG9MaXN0ZW5lciA9IF9jYXB0dXJlID8gdGhpcy5jYXB0dXJlcyA6IHRoaXMubGlzdGVuZXJzO1xyXG4gICAgICBpZiAoIWxpc3RMaXN0ZW5lcnNbX3R5cGVdKVxyXG4gICAgICAgIGxpc3RMaXN0ZW5lcnNbX3R5cGVdID0gW107XHJcbiAgICAgIGxpc3RMaXN0ZW5lcnNbX3R5cGVdLnB1c2goX2hhbmRsZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGFuIGV2ZW50IGxpc3RlbmVyIGZyb20gdGhlIG5vZGUuIFRoZSBzaWduYXR1ciBtdXN0IG1hdGNoIHRoZSBvbmUgdXNlZCB3aXRoIGFkZEV2ZW50TGlzdGVuZXJcclxuICAgICAqIEBwYXJhbSBfdHlwZSBUaGUgdHlwZSBvZiB0aGUgZXZlbnQsIHNob3VsZCBiZSBhbiBlbnVtZXJhdGVkIHZhbHVlIG9mIE5PREVfRVZFTlQsIGNhbiBiZSBhbnkgc3RyaW5nXHJcbiAgICAgKiBAcGFyYW0gX2hhbmRsZXIgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgZXZlbnQgcmVhY2hlcyB0aGlzIG5vZGVcclxuICAgICAqIEBwYXJhbSBfY2FwdHVyZSBXaGVuIHRydWUsIHRoZSBsaXN0ZW5lciBsaXN0ZW5zIGluIHRoZSBjYXB0dXJlIHBoYXNlLCB3aGVuIHRoZSBldmVudCB0cmF2ZWxzIGRlZXBlciBpbnRvIHRoZSBoaWVyYXJjaHkgb2Ygbm9kZXMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZW1vdmVFdmVudExpc3RlbmVyKF90eXBlOiBFVkVOVCB8IHN0cmluZywgX2hhbmRsZXI6IEV2ZW50TGlzdGVuZXIsIF9jYXB0dXJlOiBib29sZWFuIC8qfCBBZGRFdmVudExpc3RlbmVyT3B0aW9ucyovID0gZmFsc2UpOiB2b2lkIHtcclxuICAgICAgbGV0IGxpc3RlbmVyc0ZvclR5cGU6IEV2ZW50TGlzdGVuZXJbXSA9IF9jYXB0dXJlID8gdGhpcy5jYXB0dXJlc1tfdHlwZV0gOiB0aGlzLmxpc3RlbmVyc1tfdHlwZV07XHJcbiAgICAgIGlmIChsaXN0ZW5lcnNGb3JUeXBlKVxyXG4gICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IGxpc3RlbmVyc0ZvclR5cGUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXHJcbiAgICAgICAgICBpZiAobGlzdGVuZXJzRm9yVHlwZVtpXSA9PSBfaGFuZGxlcilcclxuICAgICAgICAgICAgbGlzdGVuZXJzRm9yVHlwZS5zcGxpY2UoaSwgMSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERpc3BhdGNoZXMgYSBzeW50aGV0aWMgZXZlbnQgdG8gdGFyZ2V0LiBUaGlzIGltcGxlbWVudGF0aW9uIGFsd2F5cyByZXR1cm5zIHRydWUgKHN0YW5kYXJkOiByZXR1cm4gdHJ1ZSBvbmx5IGlmIGVpdGhlciBldmVudCdzIGNhbmNlbGFibGUgYXR0cmlidXRlIHZhbHVlIGlzIGZhbHNlIG9yIGl0cyBwcmV2ZW50RGVmYXVsdCgpIG1ldGhvZCB3YXMgbm90IGludm9rZWQpXHJcbiAgICAgKiBUaGUgZXZlbnQgdHJhdmVscyBpbnRvIHRoZSBoaWVyYXJjaHkgdG8gdGhpcyBub2RlIGRpc3BhdGNoaW5nIHRoZSBldmVudCwgaW52b2tpbmcgbWF0Y2hpbmcgaGFuZGxlcnMgb2YgdGhlIG5vZGVzIGFuY2VzdG9ycyBsaXN0ZW5pbmcgdG8gdGhlIGNhcHR1cmUgcGhhc2UsIFxyXG4gICAgICogdGhhbiB0aGUgbWF0Y2hpbmcgaGFuZGxlciBvZiB0aGUgdGFyZ2V0IG5vZGUgaW4gdGhlIHRhcmdldCBwaGFzZSwgYW5kIGJhY2sgb3V0IG9mIHRoZSBoaWVyYXJjaHkgaW4gdGhlIGJ1YmJsaW5nIHBoYXNlLCBpbnZva2luZyBhcHByb3ByaWF0ZSBoYW5kbGVycyBvZiB0aGUgYW52ZXN0b3JzXHJcbiAgICAgKiBAcGFyYW0gX2V2ZW50IFRoZSBldmVudCB0byBkaXNwYXRjaFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZGlzcGF0Y2hFdmVudChfZXZlbnQ6IEV2ZW50KTogYm9vbGVhbiB7XHJcbiAgICAgIGxldCBhbmNlc3RvcnM6IE5vZGVbXSA9IFtdO1xyXG4gICAgICBsZXQgdXBjb21pbmc6IE5vZGUgPSB0aGlzO1xyXG4gICAgICAvLyBvdmVyd3JpdGUgZXZlbnQgdGFyZ2V0XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXZlbnQsIFwidGFyZ2V0XCIsIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB0aGlzIH0pO1xyXG4gICAgICAvLyBUT0RPOiBjb25zaWRlciB1c2luZyBSZWZsZWN0IGluc3RlYWQgb2YgT2JqZWN0IHRocm91Z2hvdXQuIFNlZSBhbHNvIFJlbmRlciBhbmQgTXV0YWJsZS4uLlxyXG4gICAgICB3aGlsZSAodXBjb21pbmcucGFyZW50KVxyXG4gICAgICAgIGFuY2VzdG9ycy5wdXNoKHVwY29taW5nID0gdXBjb21pbmcucGFyZW50KTtcclxuXHJcbiAgICAgIC8vIGNhcHR1cmUgcGhhc2VcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9ldmVudCwgXCJldmVudFBoYXNlXCIsIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBFdmVudC5DQVBUVVJJTkdfUEhBU0UgfSk7XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IGFuY2VzdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgIGxldCBhbmNlc3RvcjogTm9kZSA9IGFuY2VzdG9yc1tpXTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V2ZW50LCBcImN1cnJlbnRUYXJnZXRcIiwgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGFuY2VzdG9yIH0pO1xyXG4gICAgICAgIGxldCBjYXB0dXJlczogRXZlbnRMaXN0ZW5lcltdID0gYW5jZXN0b3IuY2FwdHVyZXNbX2V2ZW50LnR5cGVdIHx8IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGhhbmRsZXIgb2YgY2FwdHVyZXMpXHJcbiAgICAgICAgICBoYW5kbGVyKF9ldmVudCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghX2V2ZW50LmJ1YmJsZXMpXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAvLyB0YXJnZXQgcGhhc2VcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9ldmVudCwgXCJldmVudFBoYXNlXCIsIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBFdmVudC5BVF9UQVJHRVQgfSk7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXZlbnQsIFwiY3VycmVudFRhcmdldFwiLCB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogdGhpcyB9KTtcclxuICAgICAgbGV0IGxpc3RlbmVyczogRXZlbnRMaXN0ZW5lcltdID0gdGhpcy5saXN0ZW5lcnNbX2V2ZW50LnR5cGVdIHx8IFtdO1xyXG4gICAgICBmb3IgKGxldCBoYW5kbGVyIG9mIGxpc3RlbmVycylcclxuICAgICAgICBoYW5kbGVyKF9ldmVudCk7XHJcblxyXG4gICAgICAvLyBidWJibGUgcGhhc2VcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9ldmVudCwgXCJldmVudFBoYXNlXCIsIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBFdmVudC5CVUJCTElOR19QSEFTRSB9KTtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IGFuY2VzdG9ycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCBhbmNlc3RvcjogTm9kZSA9IGFuY2VzdG9yc1tpXTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V2ZW50LCBcImN1cnJlbnRUYXJnZXRcIiwgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGFuY2VzdG9yIH0pO1xyXG4gICAgICAgIGxldCBsaXN0ZW5lcnM6IEZ1bmN0aW9uW10gPSBhbmNlc3Rvci5saXN0ZW5lcnNbX2V2ZW50LnR5cGVdIHx8IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGhhbmRsZXIgb2YgbGlzdGVuZXJzKVxyXG4gICAgICAgICAgaGFuZGxlcihfZXZlbnQpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cnVlOyAvL1RPRE86IHJldHVybiBhIG1lYW5pbmdmdWwgdmFsdWUsIHNlZSBkb2N1bWVudGF0aW9uIG9mIGRpc3BhdGNoIGV2ZW50XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJyb2FkY2FzdHMgYSBzeW50aGV0aWMgZXZlbnQgdG8gdGhpcyBub2RlIGFuZCBmcm9tIHRoZXJlIHRvIGFsbCBub2RlcyBkZWVwZXIgaW4gdGhlIGhpZXJhcmNoeSxcclxuICAgICAqIGludm9raW5nIG1hdGNoaW5nIGhhbmRsZXJzIG9mIHRoZSBub2RlcyBsaXN0ZW5pbmcgdG8gdGhlIGNhcHR1cmUgcGhhc2UuIFdhdGNoIHBlcmZvcm1hbmNlIHdoZW4gdGhlcmUgYXJlIG1hbnkgbm9kZXMgaW52b2x2ZWRcclxuICAgICAqIEBwYXJhbSBfZXZlbnQgVGhlIGV2ZW50IHRvIGJyb2FkY2FzdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYnJvYWRjYXN0RXZlbnQoX2V2ZW50OiBFdmVudCk6IHZvaWQge1xyXG4gICAgICAvLyBvdmVyd3JpdGUgZXZlbnQgdGFyZ2V0IGFuZCBwaGFzZVxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V2ZW50LCBcImV2ZW50UGhhc2VcIiwgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IEV2ZW50LkNBUFRVUklOR19QSEFTRSB9KTtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9ldmVudCwgXCJ0YXJnZXRcIiwgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHRoaXMgfSk7XHJcbiAgICAgIHRoaXMuYnJvYWRjYXN0RXZlbnRSZWN1cnNpdmUoX2V2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGJyb2FkY2FzdEV2ZW50UmVjdXJzaXZlKF9ldmVudDogRXZlbnQpOiB2b2lkIHtcclxuICAgICAgLy8gY2FwdHVyZSBwaGFzZSBvbmx5XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXZlbnQsIFwiY3VycmVudFRhcmdldFwiLCB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogdGhpcyB9KTtcclxuICAgICAgbGV0IGNhcHR1cmVzOiBGdW5jdGlvbltdID0gdGhpcy5jYXB0dXJlc1tfZXZlbnQudHlwZV0gfHwgW107XHJcbiAgICAgIGZvciAobGV0IGhhbmRsZXIgb2YgY2FwdHVyZXMpXHJcbiAgICAgICAgaGFuZGxlcihfZXZlbnQpO1xyXG4gICAgICAvLyBhcHBlYXJzIHRvIGJlIHNsb3dlciwgYXN0b25pc2hpbmdseS4uLlxyXG4gICAgICAvLyBjYXB0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyOiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgICAvLyAgICAgaGFuZGxlcihfZXZlbnQpO1xyXG4gICAgICAvLyB9KTtcclxuXHJcbiAgICAgIC8vIHNhbWUgZm9yIGNoaWxkcmVuXHJcbiAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcclxuICAgICAgICBjaGlsZC5icm9hZGNhc3RFdmVudFJlY3Vyc2l2ZShfZXZlbnQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyAjZW5kcmVnaW9uXHJcblxyXG4gICAgcHJpdmF0ZSAqIGdldEdyYXBoR2VuZXJhdG9yKCk6IEl0ZXJhYmxlSXRlcmF0b3I8Tm9kZT4ge1xyXG4gICAgICB5aWVsZCB0aGlzO1xyXG4gICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKVxyXG4gICAgICAgIHlpZWxkKiBjaGlsZC5ncmFwaDtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBBIG5vZGUgbWFuYWdlZCBieSBbW1Jlc291cmNlTWFuYWdlcl1dIHRoYXQgZnVuY3Rpb25zIGFzIGEgdGVtcGxhdGUgZm9yIFtbTm9kZVJlc291cmNlSW5zdGFuY2VdXXMgXHJcbiAgICogQGF1dGhvciBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9KaXJrYURlbGxPcm8vRlVER0Uvd2lraS9SZXNvdXJjZVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBOb2RlUmVzb3VyY2UgZXh0ZW5kcyBOb2RlIGltcGxlbWVudHMgU2VyaWFsaXphYmxlUmVzb3VyY2Uge1xyXG4gICAgcHVibGljIGlkUmVzb3VyY2U6IHN0cmluZyA9IHVuZGVmaW5lZDtcclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBBbiBpbnN0YW5jZSBvZiBhIFtbTm9kZVJlc291cmNlXV0uICBcclxuICAgKiBUaGlzIG5vZGUga2VlcHMgYSByZWZlcmVuY2UgdG8gaXRzIHJlc291cmNlIGFuIGNhbiB0aHVzIG9wdGltaXplIHNlcmlhbGl6YXRpb25cclxuICAgKiBAYXV0aG9yIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL0ppcmthRGVsbE9yby9GVURHRS93aWtpL1Jlc291cmNlXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE5vZGVSZXNvdXJjZUluc3RhbmNlIGV4dGVuZHMgTm9kZSB7XHJcbiAgICAvKiogaWQgb2YgdGhlIHJlc291cmNlIHRoYXQgaW5zdGFuY2Ugd2FzIGNyZWF0ZWQgZnJvbSAqL1xyXG4gICAgLy8gVE9ETzogZXhhbWluZSwgaWYgdGhpcyBzaG91bGQgYmUgYSBkaXJlY3QgcmVmZXJlbmNlIHRvIHRoZSBOb2RlUmVzb3VyY2UsIGluc3RlYWQgb2YgdGhlIGlkXHJcbiAgICBwcml2YXRlIGlkU291cmNlOiBzdHJpbmcgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgY29uc3RydWN0b3IoX25vZGVSZXNvdXJjZTogTm9kZVJlc291cmNlKSB7XHJcbiAgICAgIHN1cGVyKFwiTm9kZVJlc291cmNlSW5zdGFuY2VcIik7XHJcbiAgICAgIGlmIChfbm9kZVJlc291cmNlKVxyXG4gICAgICAgIHRoaXMuc2V0KF9ub2RlUmVzb3VyY2UpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVjcmVhdGUgdGhpcyBub2RlIGZyb20gdGhlIFtbTm9kZVJlc291cmNlXV0gcmVmZXJlbmNlZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XHJcbiAgICAgIGxldCByZXNvdXJjZTogTm9kZVJlc291cmNlID0gPE5vZGVSZXNvdXJjZT5SZXNvdXJjZU1hbmFnZXIuZ2V0KHRoaXMuaWRTb3VyY2UpO1xyXG4gICAgICB0aGlzLnNldChyZXNvdXJjZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy9UT0RPOiBvcHRpbWl6ZSB1c2luZyB0aGUgcmVmZXJlbmNlZCBOb2RlUmVzb3VyY2UsIHNlcmlhbGl6ZS9kZXNlcmlhbGl6ZSBvbmx5IHRoZSBkaWZmZXJlbmNlc1xyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5pZFNvdXJjZSA9IHRoaXMuaWRTb3VyY2U7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFNlcmlhbGl6YWJsZSB7XHJcbiAgICAgIHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgdGhpcy5pZFNvdXJjZSA9IF9zZXJpYWxpemF0aW9uLmlkU291cmNlO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGlzIG5vZGUgdG8gYmUgYSByZWNyZWF0aW9uIG9mIHRoZSBbW05vZGVSZXNvdXJjZV1dIGdpdmVuXHJcbiAgICAgKiBAcGFyYW0gX25vZGVSZXNvdXJjZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHNldChfbm9kZVJlc291cmNlOiBOb2RlUmVzb3VyY2UpOiB2b2lkIHtcclxuICAgICAgLy8gVE9ETzogZXhhbWluZSwgaWYgdGhlIHNlcmlhbGl6YXRpb24gc2hvdWxkIGJlIHN0b3JlZCBpbiB0aGUgTm9kZVJlc291cmNlIGZvciBvcHRpbWl6YXRpb25cclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSBTZXJpYWxpemVyLnNlcmlhbGl6ZShfbm9kZVJlc291cmNlKTtcclxuICAgICAgLy9TZXJpYWxpemVyLmRlc2VyaWFsaXplKHNlcmlhbGl6YXRpb24pO1xyXG4gICAgICBmb3IgKGxldCBwYXRoIGluIHNlcmlhbGl6YXRpb24pIHtcclxuICAgICAgICB0aGlzLmRlc2VyaWFsaXplKHNlcmlhbGl6YXRpb25bcGF0aF0pO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuaWRTb3VyY2UgPSBfbm9kZVJlc291cmNlLmlkUmVzb3VyY2U7XHJcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuTk9ERVJFU09VUkNFX0lOU1RBTlRJQVRFRCkpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGNsYXNzIFJheSB7XHJcbiAgICBwdWJsaWMgb3JpZ2luOiBWZWN0b3IzO1xyXG4gICAgcHVibGljIGRpcmVjdGlvbjogVmVjdG9yMztcclxuICAgIHB1YmxpYyBsZW5ndGg6IG51bWJlcjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihfZGlyZWN0aW9uOiBWZWN0b3IzID0gVmVjdG9yMy5aKC0xKSwgX29yaWdpbjogVmVjdG9yMyA9IFZlY3RvcjMuWkVSTygpLCBfbGVuZ3RoOiBudW1iZXIgPSAxKSB7XHJcbiAgICAgIHRoaXMub3JpZ2luID0gX29yaWdpbjtcclxuICAgICAgdGhpcy5kaXJlY3Rpb24gPSBfZGlyZWN0aW9uO1xyXG4gICAgICB0aGlzLmxlbmd0aCA9IF9sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBwb2ludCBvZiBpbnRlcnNlY3Rpb24gb2YgdGhpcyByYXkgd2l0aCBhIHBsYW5lIGRlZmluZWQgYnkgXHJcbiAgICAgKiB0aGUgZ2l2ZW4gcG9pbnQgb2Ygb3JpZ2luIGFuZCB0aGUgcGxhbmVzIG5vcm1hbC4gQWxsIHZhbHVlcyBhbmQgY2FsY3VsYXRpb25zXHJcbiAgICAgKiBtdXN0IGJlIHJlbGF0aXZlIHRvIHRoZSBzYW1lIGNvb3JkaW5hdGUgc3lzdGVtLCBwcmVmZXJhYmx5IHRoZSB3b3JsZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaW50ZXJzZWN0UGxhbmUoX29yaWdpbjogVmVjdG9yMywgX25vcm1hbDogVmVjdG9yMyk6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgZGlmZmVyZW5jZTogVmVjdG9yMyA9IFZlY3RvcjMuRElGRkVSRU5DRShfb3JpZ2luLCB0aGlzLm9yaWdpbik7XHJcbiAgICAgIGxldCBmYWN0b3I6IG51bWJlciA9IFZlY3RvcjMuRE9UKGRpZmZlcmVuY2UsIF9ub3JtYWwpIC8gVmVjdG9yMy5ET1QodGhpcy5kaXJlY3Rpb24sIF9ub3JtYWwpO1xyXG4gICAgICBsZXQgaW50ZXJzZWN0OiBWZWN0b3IzID0gVmVjdG9yMy5TVU0odGhpcy5vcmlnaW4sIFZlY3RvcjMuU0NBTEUodGhpcy5kaXJlY3Rpb24sIGZhY3RvcikpO1xyXG4gICAgICByZXR1cm4gaW50ZXJzZWN0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXREaXN0YW5jZShfdGFyZ2V0OiBWZWN0b3IzKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCBvcmlnaW5Ub1RhcmdldDogVmVjdG9yMyA9IFZlY3RvcjMuRElGRkVSRU5DRShfdGFyZ2V0LCB0aGlzLm9yaWdpbik7XHJcbiAgICAgIGxldCByYXlTZWN0aW9uOiBWZWN0b3IzID0gVmVjdG9yMy5OT1JNQUxJWkFUSU9OKHRoaXMuZGlyZWN0aW9uLCAxKTtcclxuICAgICAgbGV0IHByb2plY3RlZExlbmd0aDogbnVtYmVyID0gVmVjdG9yMy5ET1Qob3JpZ2luVG9UYXJnZXQsIHJheVNlY3Rpb24pO1xyXG4gICAgICByYXlTZWN0aW9uLnNjYWxlKHByb2plY3RlZExlbmd0aCk7XHJcbiAgICAgIHJheVNlY3Rpb24uYWRkKHRoaXMub3JpZ2luKTtcclxuICAgICAgbGV0IGRpc3RhbmNlOiBWZWN0b3IzID0gVmVjdG9yMy5ESUZGRVJFTkNFKF90YXJnZXQsIHJheVNlY3Rpb24pO1xyXG4gICAgICByZXR1cm4gZGlzdGFuY2U7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgICBleHBvcnQgY2xhc3MgUmF5SGl0IHtcclxuICAgICAgICBwdWJsaWMgbm9kZTogTm9kZTtcclxuICAgICAgICBwdWJsaWMgZmFjZTogbnVtYmVyO1xyXG4gICAgICAgIHB1YmxpYyB6QnVmZmVyOiBudW1iZXI7XHJcblxyXG4gICAgICAgIGNvbnN0cnVjdG9yKF9ub2RlOiBOb2RlID0gbnVsbCwgX2ZhY2U6IG51bWJlciA9IDAsIF96QnVmZmVyOiBudW1iZXIgPSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMubm9kZSA9IF9ub2RlO1xyXG4gICAgICAgICAgICB0aGlzLmZhY2UgPSBfZmFjZTtcclxuICAgICAgICAgICAgdGhpcy56QnVmZmVyID0gX3pCdWZmZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IHR5cGUgTWFwTGlnaHRUeXBlVG9MaWdodExpc3QgPSBNYXA8VHlwZU9mTGlnaHQsIENvbXBvbmVudExpZ2h0W10+O1xyXG5cclxuICAvKipcclxuICAgKiBSZW5kZXJlZCB0ZXh0dXJlIGZvciBlYWNoIG5vZGUgZm9yIHBpY2tpbmdcclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIFBpY2tCdWZmZXIge1xyXG4gICAgbm9kZTogTm9kZTtcclxuICAgIHRleHR1cmU6IFdlYkdMVGV4dHVyZTtcclxuICAgIGZyYW1lQnVmZmVyOiBXZWJHTEZyYW1lYnVmZmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIG1haW4gaW50ZXJmYWNlIHRvIHRoZSByZW5kZXIgZW5naW5lLCBoZXJlIFdlYkdMLCB3aGljaCBpcyB1c2VkIG1haW5seSBpbiB0aGUgc3VwZXJjbGFzcyBbW1JlbmRlck9wZXJhdG9yXV1cclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgUmVuZGVyTWFuYWdlciBleHRlbmRzIFJlbmRlck9wZXJhdG9yIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVjdENsaXA6IFJlY3RhbmdsZSA9IG5ldyBSZWN0YW5nbGUoLTEsIDEsIDIsIC0yKTtcclxuICAgIHByaXZhdGUgc3RhdGljIHRpbWVzdGFtcFVwZGF0ZTogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcGlja0J1ZmZlcnM6IFBpY2tCdWZmZXJbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENsZWFyIHRoZSBvZmZzY3JlZW4gcmVuZGVyYnVmZmVyIHdpdGggdGhlIGdpdmVuIFtbQ29sb3JdXVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGNsZWFyKF9jb2xvcjogQ29sb3IgPSBudWxsKTogdm9pZCB7XHJcbiAgICAgIFJlbmRlck1hbmFnZXIuY3JjMy5jbGVhckNvbG9yKF9jb2xvci5yLCBfY29sb3IuZywgX2NvbG9yLmIsIF9jb2xvci5hKTtcclxuICAgICAgUmVuZGVyTWFuYWdlci5jcmMzLmNsZWFyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ09MT1JfQlVGRkVSX0JJVCB8IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuREVQVEhfQlVGRkVSX0JJVCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldCB0aGUgb2Zmc2NyZWVuIGZyYW1lYnVmZmVyIHRvIHRoZSBvcmlnaW5hbCBSZW5kZXJpbmdDb250ZXh0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVzZXRGcmFtZUJ1ZmZlcihfY29sb3I6IENvbG9yID0gbnVsbCk6IHZvaWQge1xyXG4gICAgICBSZW5kZXJNYW5hZ2VyLmNyYzMuYmluZEZyYW1lYnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRlJBTUVCVUZGRVIsIG51bGwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBSYXlDYXN0ICYgUGlja2luZ1xyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyB0aGUgZ3JhcGggZm9yIFJheUNhc3Rpbmcgc3RhcnRpbmcgd2l0aCB0aGUgZ2l2ZW4gW1tOb2RlXV0gdXNpbmcgdGhlIGNhbWVyYSBnaXZlbiBbW0NvbXBvbmVudENhbWVyYV1dLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGRyYXdHcmFwaEZvclJheUNhc3QoX25vZGU6IE5vZGUsIF9jbXBDYW1lcmE6IENvbXBvbmVudENhbWVyYSk6IFBpY2tCdWZmZXJbXSB7IC8vIFRPRE86IHNlZSBpZiB0aGlyZCBwYXJhbWV0ZXIgX3dvcmxkPzogTWF0cml4NHg0IHdvdWxkIGJlIHVzZWZ1bGxcclxuICAgICAgUmVuZGVyTWFuYWdlci5waWNrQnVmZmVycyA9IFtdO1xyXG4gICAgICAvL1RPRE86IGV4YW1pbmUsIHdoeSBzd2l0Y2hpbmcgYmxlbmRGdW5jdGlvbiBpcyBuZWNlc3NhcnkgXHJcbiAgICAgIFJlbmRlck9wZXJhdG9yLmNyYzMuYmxlbmRGdW5jKDEsIDApO1xyXG4gICAgICBSZW5kZXJNYW5hZ2VyLmRyYXdHcmFwaChfbm9kZSwgX2NtcENhbWVyYSwgUmVuZGVyTWFuYWdlci5kcmF3Tm9kZUZvclJheUNhc3QpO1xyXG4gICAgICBSZW5kZXJPcGVyYXRvci5jcmMzLmJsZW5kRnVuYyhXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkRTVF9BTFBIQSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5PTkVfTUlOVVNfRFNUX0FMUEhBKTtcclxuXHJcbiAgICAgIFJlbmRlck1hbmFnZXIucmVzZXRGcmFtZUJ1ZmZlcigpO1xyXG4gICAgICByZXR1cm4gUmVuZGVyTWFuYWdlci5waWNrQnVmZmVycztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJyb3dzZXMgdGhyb3VnaCB0aGUgYnVmZmVycyAocHJldmlvdXNseSBjcmVhdGVkIHdpdGggW1tkcmF3R3JhcGhGb3JSYXlDYXN0XV0pIG9mIHRoZSBzaXplIGdpdmVuXHJcbiAgICAgKiBhbmQgcmV0dXJucyBhbiB1bnNvcnRlZCBsaXN0IG9mIHRoZSB2YWx1ZXMgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLCByZXByZXNlbnRpbmcgbm9kZS1pZHMgYW5kIGRlcHRoIGluZm9ybWF0aW9uIGFzIFtbUmF5SGl0XV1zXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcGlja05vZGVBdChfcG9zOiBWZWN0b3IyLCBfcGlja0J1ZmZlcnM6IFBpY2tCdWZmZXJbXSwgX3JlY3Q6IFJlY3RhbmdsZSk6IFJheUhpdFtdIHtcclxuICAgICAgbGV0IGhpdHM6IFJheUhpdFtdID0gW107XHJcblxyXG4gICAgICBmb3IgKGxldCBwaWNrQnVmZmVyIG9mIF9waWNrQnVmZmVycykge1xyXG4gICAgICAgIFJlbmRlck1hbmFnZXIuY3JjMy5iaW5kRnJhbWVidWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GUkFNRUJVRkZFUiwgcGlja0J1ZmZlci5mcmFtZUJ1ZmZlcik7XHJcbiAgICAgICAgLy8gVE9ETzogaW5zdGVhZCBvZiByZWFkaW5nIGFsbCBkYXRhIGFuZCBhZnRlcndhcmRzIHBpY2sgdGhlIHBpeGVsLCByZWFkIG9ubHkgdGhlIHBpeGVsIVxyXG4gICAgICAgIGxldCBkYXRhOiBVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoX3JlY3Qud2lkdGggKiBfcmVjdC5oZWlnaHQgKiA0KTtcclxuICAgICAgICBSZW5kZXJNYW5hZ2VyLmNyYzMucmVhZFBpeGVscygwLCAwLCBfcmVjdC53aWR0aCwgX3JlY3QuaGVpZ2h0LCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlJHQkEsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5TSUdORURfQllURSwgZGF0YSk7XHJcbiAgICAgICAgbGV0IHBpeGVsOiBudW1iZXIgPSBfcG9zLnggKyBfcmVjdC53aWR0aCAqIF9wb3MueTtcclxuXHJcbiAgICAgICAgLy8gbGV0IHpCdWZmZXI6IG51bWJlciA9IGRhdGFbNCAqIHBpeGVsICsgMV0gKyBkYXRhWzQgKiBwaXhlbCArIDJdIC8gMjU2O1xyXG4gICAgICAgIGxldCB6QnVmZmVyOiBudW1iZXIgPSBkYXRhWzQgKiBwaXhlbCArIDBdO1xyXG4gICAgICAgIGxldCBoaXQ6IFJheUhpdCA9IG5ldyBSYXlIaXQocGlja0J1ZmZlci5ub2RlLCAwLCB6QnVmZmVyKTtcclxuXHJcbiAgICAgICAgaGl0cy5wdXNoKGhpdCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBoaXRzO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIERyYXdpbmdcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1haW4gcmVuZGVyaW5nIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBmcm9tIFtbVmlld3BvcnRdXS5cclxuICAgICAqIERyYXdzIHRoZSBncmFwaCBzdGFydGluZyB3aXRoIHRoZSBnaXZlbiBbW05vZGVdXSB1c2luZyB0aGUgY2FtZXJhIGdpdmVuIFtbQ29tcG9uZW50Q2FtZXJhXV0uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZHJhd0dyYXBoKF9ub2RlOiBOb2RlLCBfY21wQ2FtZXJhOiBDb21wb25lbnRDYW1lcmEsIF9kcmF3Tm9kZTogRnVuY3Rpb24gPSBSZW5kZXJNYW5hZ2VyLmRyYXdOb2RlKTogdm9pZCB7XHJcbiAgICAgIGxldCBtYXRyaXg6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpO1xyXG4gICAgICBpZiAoX25vZGUuZ2V0UGFyZW50KCkpXHJcbiAgICAgICAgbWF0cml4ID0gX25vZGUuZ2V0UGFyZW50KCkubXR4V29ybGQ7XHJcblxyXG4gICAgICBSZW5kZXJNYW5hZ2VyLnNldHVwVHJhbnNmb3JtQW5kTGlnaHRzKF9ub2RlLCBtYXRyaXgpO1xyXG5cclxuICAgICAgUmVuZGVyTWFuYWdlci5kcmF3R3JhcGhSZWN1cnNpdmUoX25vZGUsIF9jbXBDYW1lcmEsIF9kcmF3Tm9kZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWN1cnNpdmx5IGl0ZXJhdGVzIG92ZXIgdGhlIGdyYXBoIGFuZCByZW5kZXJzIGVhY2ggbm9kZSBhbmQgYWxsIHN1Y2Nlc3NvcnMgd2l0aCB0aGUgZ2l2ZW4gcmVuZGVyIGZ1bmN0aW9uXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIGRyYXdHcmFwaFJlY3Vyc2l2ZShfbm9kZTogTm9kZSwgX2NtcENhbWVyYTogQ29tcG9uZW50Q2FtZXJhLCBfZHJhd05vZGU6IEZ1bmN0aW9uID0gUmVuZGVyTWFuYWdlci5kcmF3Tm9kZSk6IHZvaWQge1xyXG4gICAgICAvLyBUT0RPOiBzZWUgaWYgdGhpcmQgcGFyYW1ldGVyIF93b3JsZD86IE1hdHJpeDR4NCB3b3VsZCBiZSB1c2VmdWxsXHJcbiAgICAgIGlmICghX25vZGUuaXNBY3RpdmUpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgbGV0IGZpbmFsVHJhbnNmb3JtOiBNYXRyaXg0eDQ7XHJcblxyXG4gICAgICBsZXQgY21wTWVzaDogQ29tcG9uZW50TWVzaCA9IF9ub2RlLmdldENvbXBvbmVudChDb21wb25lbnRNZXNoKTtcclxuICAgICAgaWYgKGNtcE1lc2gpIC8vIFRPRE86IGNhcmVmdWwgd2hlbiB1c2luZyBwYXJ0aWNsZXN5c3RlbSwgcGl2b3QgbXVzdCBub3QgY2hhbmdlIG5vZGUgcG9zaXRpb25cclxuICAgICAgICBmaW5hbFRyYW5zZm9ybSA9IE1hdHJpeDR4NC5NVUxUSVBMSUNBVElPTihfbm9kZS5tdHhXb3JsZCwgY21wTWVzaC5waXZvdCk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBmaW5hbFRyYW5zZm9ybSA9IF9ub2RlLm10eFdvcmxkOyAvLyBjYXV0aW9uLCBSZW5kZXJNYW5hZ2VyIGlzIGEgcmVmZXJlbmNlLi4uXHJcblxyXG4gICAgICAvLyBtdWx0aXBseSBjYW1lcmEgbWF0cml4XHJcbiAgICAgIGxldCBwcm9qZWN0aW9uOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuTVVMVElQTElDQVRJT04oX2NtcENhbWVyYS5WaWV3UHJvamVjdGlvbk1hdHJpeCwgZmluYWxUcmFuc2Zvcm0pO1xyXG5cclxuICAgICAgLy8gVE9ETzogY3JlYXRlIGRyYXdOb2RlIG1ldGhvZCBmb3IgcGFydGljbGUgc3lzdGVtIHVzaW5nIF9ub2RlLm10eFdvcmxkIGluc3RlYWQgb2YgZmluYWxUcmFuc2Zvcm1cclxuICAgICAgX2RyYXdOb2RlKF9ub2RlLCBmaW5hbFRyYW5zZm9ybSwgcHJvamVjdGlvbik7XHJcbiAgICAgIC8vIFJlbmRlclBhcnRpY2xlcy5kcmF3UGFydGljbGVzKCk7XHJcblxyXG4gICAgICBmb3IgKGxldCBuYW1lIGluIF9ub2RlLmdldENoaWxkcmVuKCkpIHtcclxuICAgICAgICBsZXQgY2hpbGROb2RlOiBOb2RlID0gX25vZGUuZ2V0Q2hpbGRyZW4oKVtuYW1lXTtcclxuICAgICAgICBSZW5kZXJNYW5hZ2VyLmRyYXdHcmFwaFJlY3Vyc2l2ZShjaGlsZE5vZGUsIF9jbXBDYW1lcmEsIF9kcmF3Tm9kZSk7IC8vLCB3b3JsZCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKHByb2plY3Rpb24pO1xyXG4gICAgICBpZiAoZmluYWxUcmFuc2Zvcm0gIT0gX25vZGUubXR4V29ybGQpXHJcbiAgICAgICAgUmVjeWNsZXIuc3RvcmUoZmluYWxUcmFuc2Zvcm0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHN0YW5kYXJkIHJlbmRlciBmdW5jdGlvbiBmb3IgZHJhd2luZyBhIHNpbmdsZSBub2RlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIGRyYXdOb2RlKF9ub2RlOiBOb2RlLCBfZmluYWxUcmFuc2Zvcm06IE1hdHJpeDR4NCwgX3Byb2plY3Rpb246IE1hdHJpeDR4NCwgX2xpZ2h0czogTWFwTGlnaHRUeXBlVG9MaWdodExpc3QpOiB2b2lkIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBsZXQgY21wTWF0ZXJpYWw6IENvbXBvbmVudE1hdGVyaWFsID0gX25vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudE1hdGVyaWFsKTtcclxuICAgICAgICBsZXQgbWVzaDogTWVzaCA9IF9ub2RlLmdldENvbXBvbmVudChDb21wb25lbnRNZXNoKS5tZXNoO1xyXG4gICAgICAgIC8vIFJlbmRlck1hbmFnZXIuc2V0TGlnaHRzSW5TaGFkZXIoc2hhZGVyLCBfbGlnaHRzKTtcclxuICAgICAgICBSZW5kZXJNYW5hZ2VyLmRyYXcobWVzaCwgY21wTWF0ZXJpYWwsIF9maW5hbFRyYW5zZm9ybSwgX3Byb2plY3Rpb24pOyAvLywgX2xpZ2h0cyk7XHJcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xyXG4gICAgICAgIC8vIERlYnVnLmVycm9yKF9lcnJvcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBQaWNraW5nXHJcbiAgICAvKipcclxuICAgICAqIFRoZSByZW5kZXIgZnVuY3Rpb24gZm9yIGRyYXdpbmcgYnVmZmVycyBmb3IgcGlja2luZy4gUmVuZGVycyBlYWNoIG5vZGUgb24gYSBkZWRpY2F0ZWQgYnVmZmVyIHdpdGggaWQgYW5kIGRlcHRoIHZhbHVlcyBpbnN0ZWFkIG9mIGNvbG9yc1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBkcmF3Tm9kZUZvclJheUNhc3QoX25vZGU6IE5vZGUsIF9maW5hbFRyYW5zZm9ybTogTWF0cml4NHg0LCBfcHJvamVjdGlvbjogTWF0cml4NHg0LCBfbGlnaHRzOiBNYXBMaWdodFR5cGVUb0xpZ2h0TGlzdCk6IHZvaWQgeyAvLyBjcmVhdGUgVGV4dHVyZSB0byByZW5kZXIgdG8sIGludC1yZ2JhXHJcbiAgICAgIC8vIFRPRE86IGxvb2sgaW50byBTU0JPcyFcclxuICAgICAgbGV0IHRhcmdldDogV2ViR0xUZXh0dXJlID0gUmVuZGVyTWFuYWdlci5nZXRSYXlDYXN0VGV4dHVyZSgpO1xyXG5cclxuICAgICAgY29uc3QgZnJhbWVidWZmZXI6IFdlYkdMRnJhbWVidWZmZXIgPSBSZW5kZXJNYW5hZ2VyLmNyYzMuY3JlYXRlRnJhbWVidWZmZXIoKTtcclxuICAgICAgLy8gcmVuZGVyIHRvIG91ciB0YXJnZXRUZXh0dXJlIGJ5IGJpbmRpbmcgdGhlIGZyYW1lYnVmZmVyXHJcbiAgICAgIFJlbmRlck1hbmFnZXIuY3JjMy5iaW5kRnJhbWVidWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIpO1xyXG4gICAgICAvLyBhdHRhY2ggdGhlIHRleHR1cmUgYXMgdGhlIGZpcnN0IGNvbG9yIGF0dGFjaG1lbnRcclxuICAgICAgY29uc3QgYXR0YWNobWVudFBvaW50OiBudW1iZXIgPSBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkNPTE9SX0FUVEFDSE1FTlQwO1xyXG4gICAgICBSZW5kZXJNYW5hZ2VyLmNyYzMuZnJhbWVidWZmZXJUZXh0dXJlMkQoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GUkFNRUJVRkZFUiwgYXR0YWNobWVudFBvaW50LCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIHRhcmdldCwgMCk7XHJcblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGxldCBtZXNoOiBNZXNoID0gX25vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudE1lc2gpLm1lc2g7XHJcbiAgICAgICAgU2hhZGVyUmF5Q2FzdC51c2VQcm9ncmFtKCk7XHJcbiAgICAgICAgbGV0IHBpY2tCdWZmZXI6IFBpY2tCdWZmZXIgPSB7IG5vZGU6IF9ub2RlLCB0ZXh0dXJlOiB0YXJnZXQsIGZyYW1lQnVmZmVyOiBmcmFtZWJ1ZmZlciB9O1xyXG4gICAgICAgIFJlbmRlck1hbmFnZXIucGlja0J1ZmZlcnMucHVzaChwaWNrQnVmZmVyKTtcclxuICAgICAgICBtZXNoLnVzZVJlbmRlckJ1ZmZlcnMoU2hhZGVyUmF5Q2FzdCwgX2ZpbmFsVHJhbnNmb3JtLCBfcHJvamVjdGlvbiwgUmVuZGVyTWFuYWdlci5waWNrQnVmZmVycy5sZW5ndGgpO1xyXG5cclxuICAgICAgICBSZW5kZXJPcGVyYXRvci5jcmMzLmRyYXdFbGVtZW50cyhXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRSSUFOR0xFUywgbWVzaC5yZW5kZXJCdWZmZXJzLm5JbmRpY2VzLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOU0lHTkVEX1NIT1JULCAwKTtcclxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XHJcbiAgICAgICAgLy9cclxuICAgICAgfVxyXG4gICAgICAvLyBtYWtlIHRleHR1cmUgYXZhaWxhYmxlIHRvIG9uc2NyZWVuLWRpc3BsYXlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSB0ZXh0dXJlIGJ1ZmZlciB0byBiZSB1c2VzIGFzIHBpY2stYnVmZmVyXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIGdldFJheUNhc3RUZXh0dXJlKCk6IFdlYkdMVGV4dHVyZSB7XHJcbiAgICAgIC8vIGNyZWF0ZSB0byByZW5kZXIgdG9cclxuICAgICAgY29uc3QgdGFyZ2V0VGV4dHVyZVdpZHRoOiBudW1iZXIgPSBSZW5kZXJNYW5hZ2VyLmdldFZpZXdwb3J0UmVjdGFuZ2xlKCkud2lkdGg7XHJcbiAgICAgIGNvbnN0IHRhcmdldFRleHR1cmVIZWlnaHQ6IG51bWJlciA9IFJlbmRlck1hbmFnZXIuZ2V0Vmlld3BvcnRSZWN0YW5nbGUoKS5oZWlnaHQ7XHJcbiAgICAgIGNvbnN0IHRhcmdldFRleHR1cmU6IFdlYkdMVGV4dHVyZSA9IFJlbmRlck1hbmFnZXIuY3JjMy5jcmVhdGVUZXh0dXJlKCk7XHJcbiAgICAgIFJlbmRlck1hbmFnZXIuY3JjMy5iaW5kVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIHRhcmdldFRleHR1cmUpO1xyXG5cclxuICAgICAge1xyXG4gICAgICAgIGNvbnN0IGludGVybmFsRm9ybWF0OiBudW1iZXIgPSBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlJHQkE4O1xyXG4gICAgICAgIGNvbnN0IGZvcm1hdDogbnVtYmVyID0gV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5SR0JBO1xyXG4gICAgICAgIGNvbnN0IHR5cGU6IG51bWJlciA9IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5TSUdORURfQllURTtcclxuICAgICAgICBSZW5kZXJNYW5hZ2VyLmNyYzMudGV4SW1hZ2UyRChcclxuICAgICAgICAgIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgMCwgaW50ZXJuYWxGb3JtYXQsIHRhcmdldFRleHR1cmVXaWR0aCwgdGFyZ2V0VGV4dHVyZUhlaWdodCwgMCwgZm9ybWF0LCB0eXBlLCBudWxsXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gc2V0IHRoZSBmaWx0ZXJpbmcgc28gd2UgZG9uJ3QgbmVlZCBtaXBzXHJcbiAgICAgICAgUmVuZGVyTWFuYWdlci5jcmMzLnRleFBhcmFtZXRlcmkoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfTUlOX0ZJTFRFUiwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5MSU5FQVIpO1xyXG4gICAgICAgIFJlbmRlck1hbmFnZXIuY3JjMy50ZXhQYXJhbWV0ZXJpKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFX1dSQVBfUywgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgICBSZW5kZXJNYW5hZ2VyLmNyYzMudGV4UGFyYW1ldGVyaShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV9XUkFQX1QsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0YXJnZXRUZXh0dXJlO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZm9ybWF0aW9uICYgTGlnaHRzXHJcbiAgICAvKipcclxuICAgICAqIFJlY3Vyc2l2ZWx5IGl0ZXJhdGVzIG92ZXIgdGhlIGdyYXBoIHN0YXJ0aW5nIHdpdGggdGhlIG5vZGUgZ2l2ZW4sIHJlY2FsY3VsYXRlcyBhbGwgd29ybGQgdHJhbnNmb3JtcywgXHJcbiAgICAgKiBjb2xsZWN0cyBhbGwgbGlnaHRzIGFuZCBmZWVkcyBhbGwgc2hhZGVycyB1c2VkIGluIHRoZSBncmFwaCB3aXRoIHRoZXNlIGxpZ2h0c1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBzZXR1cFRyYW5zZm9ybUFuZExpZ2h0cyhfbm9kZTogTm9kZSwgX3dvcmxkOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKSwgX2xpZ2h0czogTWFwTGlnaHRUeXBlVG9MaWdodExpc3QgPSBuZXcgTWFwKCksIF9zaGFkZXJzVXNlZDogKHR5cGVvZiBTaGFkZXIpW10gPSBudWxsKTogdm9pZCB7XHJcbiAgICAgIFJlbmRlck1hbmFnZXIudGltZXN0YW1wVXBkYXRlID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgIFxyXG4gICAgICBsZXQgZmlyc3RMZXZlbDogYm9vbGVhbiA9IChfc2hhZGVyc1VzZWQgPT0gbnVsbCk7XHJcbiAgICAgIGlmIChmaXJzdExldmVsKVxyXG4gICAgICAgIF9zaGFkZXJzVXNlZCA9IFtdO1xyXG5cclxuICAgICAgbGV0IHdvcmxkOiBNYXRyaXg0eDQgPSBfd29ybGQ7XHJcblxyXG4gICAgICBsZXQgY21wVHJhbnNmb3JtOiBDb21wb25lbnRUcmFuc2Zvcm0gPSBfbm9kZS5jbXBUcmFuc2Zvcm07XHJcbiAgICAgIGlmIChjbXBUcmFuc2Zvcm0pXHJcbiAgICAgICAgd29ybGQgPSBNYXRyaXg0eDQuTVVMVElQTElDQVRJT04oX3dvcmxkLCBjbXBUcmFuc2Zvcm0ubG9jYWwpO1xyXG5cclxuICAgICAgX25vZGUubXR4V29ybGQuc2V0KHdvcmxkKTsgLy8gb3ZlcndyaXRlIHJlYWRvbmx5IG10eFdvcmxkIG9mIG5vZGVcclxuICAgICAgX25vZGUudGltZXN0YW1wVXBkYXRlID0gUmVuZGVyTWFuYWdlci50aW1lc3RhbXBVcGRhdGU7XHJcblxyXG4gICAgICBsZXQgY21wTGlnaHRzOiBDb21wb25lbnRMaWdodFtdID0gX25vZGUuZ2V0Q29tcG9uZW50cyhDb21wb25lbnRMaWdodCk7XHJcbiAgICAgIGZvciAobGV0IGNtcExpZ2h0IG9mIGNtcExpZ2h0cykge1xyXG4gICAgICAgIGxldCB0eXBlOiBUeXBlT2ZMaWdodCA9IGNtcExpZ2h0LmxpZ2h0LmdldFR5cGUoKTtcclxuICAgICAgICBsZXQgbGlnaHRzT2ZUeXBlOiBDb21wb25lbnRMaWdodFtdID0gX2xpZ2h0cy5nZXQodHlwZSk7XHJcbiAgICAgICAgaWYgKCFsaWdodHNPZlR5cGUpIHtcclxuICAgICAgICAgIGxpZ2h0c09mVHlwZSA9IFtdO1xyXG4gICAgICAgICAgX2xpZ2h0cy5zZXQodHlwZSwgbGlnaHRzT2ZUeXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGlnaHRzT2ZUeXBlLnB1c2goY21wTGlnaHQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgY21wTWF0ZXJpYWw6IENvbXBvbmVudE1hdGVyaWFsID0gX25vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudE1hdGVyaWFsKTtcclxuICAgICAgaWYgKGNtcE1hdGVyaWFsKSB7XHJcbiAgICAgICAgbGV0IHNoYWRlcjogdHlwZW9mIFNoYWRlciA9IGNtcE1hdGVyaWFsLm1hdGVyaWFsLmdldFNoYWRlcigpO1xyXG4gICAgICAgIGlmIChfc2hhZGVyc1VzZWQuaW5kZXhPZihzaGFkZXIpIDwgMClcclxuICAgICAgICAgIF9zaGFkZXJzVXNlZC5wdXNoKHNoYWRlcik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAobGV0IGNoaWxkIG9mIF9ub2RlLmdldENoaWxkcmVuKCkpIHtcclxuICAgICAgICBSZW5kZXJNYW5hZ2VyLnNldHVwVHJhbnNmb3JtQW5kTGlnaHRzKGNoaWxkLCB3b3JsZCwgX2xpZ2h0cywgX3NoYWRlcnNVc2VkKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGZpcnN0TGV2ZWwpXHJcbiAgICAgICAgZm9yIChsZXQgc2hhZGVyIG9mIF9zaGFkZXJzVXNlZClcclxuICAgICAgICAgIFJlbmRlck1hbmFnZXIuc2V0TGlnaHRzSW5TaGFkZXIoc2hhZGVyLCBfbGlnaHRzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBsaWdodCBkYXRhIGluIHNoYWRlcnNcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgc2V0TGlnaHRzSW5TaGFkZXIoX3NoYWRlcjogdHlwZW9mIFNoYWRlciwgX2xpZ2h0czogTWFwTGlnaHRUeXBlVG9MaWdodExpc3QpOiB2b2lkIHtcclxuICAgICAgX3NoYWRlci51c2VQcm9ncmFtKCk7XHJcbiAgICAgIGxldCB1bmk6IHsgW25hbWU6IHN0cmluZ106IFdlYkdMVW5pZm9ybUxvY2F0aW9uIH0gPSBfc2hhZGVyLnVuaWZvcm1zO1xyXG5cclxuICAgICAgLy8gQW1iaWVudFxyXG4gICAgICBsZXQgYW1iaWVudDogV2ViR0xVbmlmb3JtTG9jYXRpb24gPSB1bmlbXCJ1X2FtYmllbnQuY29sb3JcIl07XHJcbiAgICAgIGlmIChhbWJpZW50KSB7XHJcbiAgICAgICAgbGV0IGNtcExpZ2h0czogQ29tcG9uZW50TGlnaHRbXSA9IF9saWdodHMuZ2V0KExpZ2h0QW1iaWVudCk7XHJcbiAgICAgICAgaWYgKGNtcExpZ2h0cykge1xyXG4gICAgICAgICAgLy8gVE9ETzogYWRkIHVwIGFtYmllbnQgbGlnaHRzIHRvIGEgc2luZ2xlIGNvbG9yXHJcbiAgICAgICAgICBsZXQgcmVzdWx0OiBDb2xvciA9IG5ldyBDb2xvcigwLCAwLCAwLCAxKTtcclxuICAgICAgICAgIGZvciAobGV0IGNtcExpZ2h0IG9mIGNtcExpZ2h0cylcclxuICAgICAgICAgICAgcmVzdWx0LmFkZChjbXBMaWdodC5saWdodC5jb2xvcik7XHJcbiAgICAgICAgICBSZW5kZXJPcGVyYXRvci5jcmMzLnVuaWZvcm00ZnYoYW1iaWVudCwgcmVzdWx0LmdldEFycmF5KCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRGlyZWN0aW9uYWxcclxuICAgICAgbGV0IG5EaXJlY3Rpb25hbDogV2ViR0xVbmlmb3JtTG9jYXRpb24gPSB1bmlbXCJ1X25MaWdodHNEaXJlY3Rpb25hbFwiXTtcclxuICAgICAgaWYgKG5EaXJlY3Rpb25hbCkge1xyXG4gICAgICAgIGxldCBjbXBMaWdodHM6IENvbXBvbmVudExpZ2h0W10gPSBfbGlnaHRzLmdldChMaWdodERpcmVjdGlvbmFsKTtcclxuICAgICAgICBpZiAoY21wTGlnaHRzKSB7XHJcbiAgICAgICAgICBsZXQgbjogbnVtYmVyID0gY21wTGlnaHRzLmxlbmd0aDtcclxuICAgICAgICAgIFJlbmRlck9wZXJhdG9yLmNyYzMudW5pZm9ybTF1aShuRGlyZWN0aW9uYWwsIG4pO1xyXG4gICAgICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgY21wTGlnaHQ6IENvbXBvbmVudExpZ2h0ID0gY21wTGlnaHRzW2ldO1xyXG4gICAgICAgICAgICBSZW5kZXJPcGVyYXRvci5jcmMzLnVuaWZvcm00ZnYodW5pW2B1X2RpcmVjdGlvbmFsWyR7aX1dLmNvbG9yYF0sIGNtcExpZ2h0LmxpZ2h0LmNvbG9yLmdldEFycmF5KCkpO1xyXG4gICAgICAgICAgICBsZXQgZGlyZWN0aW9uOiBWZWN0b3IzID0gVmVjdG9yMy5aKCk7XHJcbiAgICAgICAgICAgIGRpcmVjdGlvbi50cmFuc2Zvcm0oY21wTGlnaHQucGl2b3QsIGZhbHNlKTtcclxuICAgICAgICAgICAgZGlyZWN0aW9uLnRyYW5zZm9ybShjbXBMaWdodC5nZXRDb250YWluZXIoKS5tdHhXb3JsZCk7XHJcbiAgICAgICAgICAgIFJlbmRlck9wZXJhdG9yLmNyYzMudW5pZm9ybTNmdih1bmlbYHVfZGlyZWN0aW9uYWxbJHtpfV0uZGlyZWN0aW9uYF0sIGRpcmVjdGlvbi5nZXQoKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgUmVuZGVyUGFydGljbGVzIGV4dGVuZHMgUmVuZGVyTWFuYWdlciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIGRyYXdQYXJ0aWNsZXMoKTogdm9pZCB7XHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKFJlbmRlclBhcnRpY2xlcy5jcmMzKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCIvLyAvIDxyZWZlcmVuY2UgcGF0aD1cIi4uL0NvYXQvQ29hdC50c1wiLz5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogU3RhdGljIHN1cGVyY2xhc3MgZm9yIHRoZSByZXByZXNlbnRhdGlvbiBvZiBXZWJHbCBzaGFkZXJwcm9ncmFtcy4gXHJcbiAgICogQGF1dGhvcnMgSmFzY2hhIEthcmFnw7ZsLCBIRlUsIDIwMTkgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG5cclxuICAvLyBUT0RPOiBkZWZpbmUgYXR0cmlidXRlL3VuaWZvcm1zIGFzIGxheW91dCBhbmQgdXNlIHRob3NlIGNvbnNpc3RlbnRseSBpbiBzaGFkZXJzXHJcbiAgQFJlbmRlckluamVjdG9yU2hhZGVyLmRlY29yYXRlXHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYWRlciB7XHJcbiAgICAvKiogcmVmZXJzIGJhY2sgdG8gdGhpcyBjbGFzcyBmcm9tIGFueSBzdWJjbGFzcyBlLmcuIGluIG9yZGVyIHRvIGZpbmQgY29tcGF0aWJsZSBvdGhlciByZXNvdXJjZXMqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBiYXNlQ2xhc3M6IHR5cGVvZiBTaGFkZXIgPSBTaGFkZXI7XHJcbiAgICAvKiogbGlzdCBvZiBhbGwgdGhlIHN1YmNsYXNzZXMgZGVyaXZlZCBmcm9tIHRoaXMgY2xhc3MsIGlmIHRoZXkgcmVnaXN0ZXJlZCBwcm9wZXJseSovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IHN1YmNsYXNzZXM6IHR5cGVvZiBTaGFkZXJbXSA9IFtdO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgcHJvZ3JhbTogV2ViR0xQcm9ncmFtO1xyXG4gICAgcHVibGljIHN0YXRpYyBhdHRyaWJ1dGVzOiB7IFtuYW1lOiBzdHJpbmddOiBudW1iZXIgfTtcclxuICAgIHB1YmxpYyBzdGF0aWMgdW5pZm9ybXM6IHsgW25hbWU6IHN0cmluZ106IFdlYkdMVW5pZm9ybUxvY2F0aW9uIH07XHJcblxyXG4gICAgLyoqIFRoZSB0eXBlIG9mIGNvYXQgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIHRoaXMgc2hhZGVyIHRvIGNyZWF0ZSBhIG1hdGVyaWFsICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQgeyByZXR1cm4gbnVsbDsgfVxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRWZXJ0ZXhTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHsgcmV0dXJuIG51bGw7IH1cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHsgcmV0dXJuIG51bGw7IH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGRlbGV0ZVByb2dyYW0odGhpczogdHlwZW9mIFNoYWRlcik6IHZvaWQgey8qIGluamVjdGVkIGJ5IGRlY29yYXRvciAqLyB9XHJcbiAgICBwdWJsaWMgc3RhdGljIHVzZVByb2dyYW0odGhpczogdHlwZW9mIFNoYWRlcik6IHZvaWQgey8qIGluamVjdGVkIGJ5IGRlY29yYXRvciAqLyB9XHJcbiAgICBwdWJsaWMgc3RhdGljIGNyZWF0ZVByb2dyYW0odGhpczogdHlwZW9mIFNoYWRlcik6IHZvaWQgey8qIGluamVjdGVkIGJ5IGRlY29yYXRvciAqLyB9IFxyXG4gICAgXHJcbiAgICBcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVnaXN0ZXJTdWJjbGFzcyhfc3ViY2xhc3M6IHR5cGVvZiBTaGFkZXIpOiBudW1iZXIgeyByZXR1cm4gU2hhZGVyLnN1YmNsYXNzZXMucHVzaChfc3ViY2xhc3MpIC0gMTsgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFNpbmdsZSBjb2xvciBzaGFkaW5nXHJcbiAgICogQGF1dGhvcnMgSmFzY2hhIEthcmFnw7ZsLCBIRlUsIDIwMTkgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIEBSZW5kZXJJbmplY3RvclNoYWRlci5kZWNvcmF0ZVxyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJGbGF0IGV4dGVuZHMgU2hhZGVyIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBTaGFkZXIucmVnaXN0ZXJTdWJjbGFzcyhTaGFkZXJGbGF0KTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQge1xyXG4gICAgICByZXR1cm4gQ29hdENvbG9yZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRWZXJ0ZXhTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIGAjdmVyc2lvbiAzMDAgZXNcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc3RydWN0IExpZ2h0QW1iaWVudCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgY29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBzdHJ1Y3QgTGlnaHREaXJlY3Rpb25hbCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgY29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzMgZGlyZWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVpbnQgTUFYX0xJR0hUU19ESVJFQ1RJT05BTCA9IDEwdTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaW4gdmVjMyBhX3Bvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGluIHZlYzMgYV9ub3JtYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybSBtYXQ0IHVfd29ybGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybSBtYXQ0IHVfcHJvamVjdGlvbjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybSBMaWdodEFtYmllbnQgdV9hbWJpZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHVuaWZvcm0gdWludCB1X25MaWdodHNEaXJlY3Rpb25hbDtcclxuICAgICAgICAgICAgICAgICAgICB1bmlmb3JtIExpZ2h0RGlyZWN0aW9uYWwgdV9kaXJlY3Rpb25hbFtNQVhfTElHSFRTX0RJUkVDVElPTkFMXTtcclxuICAgICAgICAgICAgICAgICAgICBmbGF0IG91dCB2ZWM0IHZfY29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgdm9pZCBtYWluKCkgeyAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHVfcHJvamVjdGlvbiAqIHZlYzQoYV9wb3NpdGlvbiwgMS4wKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMyBub3JtYWwgPSBub3JtYWxpemUobWF0Myh1X3dvcmxkKSAqIGFfbm9ybWFsKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZfY29sb3IgPSB1X2FtYmllbnQuY29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodWludCBpID0gMHU7IGkgPCB1X25MaWdodHNEaXJlY3Rpb25hbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBpbGx1bWluYXRpb24gPSAtZG90KG5vcm1hbCwgdV9kaXJlY3Rpb25hbFtpXS5kaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlsbHVtaW5hdGlvbiA+IDAuMGYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdl9jb2xvciArPSBpbGx1bWluYXRpb24gKiB1X2RpcmVjdGlvbmFsW2ldLmNvbG9yOyAvLyB2ZWM0KDEsMSwxLDEpOyAvLyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2X2NvbG9yLmEgPSAxLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgfWA7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc3RhdGljIGdldEZyYWdtZW50U2hhZGVyU291cmNlKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiBgI3ZlcnNpb24gMzAwIGVzXHJcbiAgICAgICAgICAgICAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHVuaWZvcm0gdmVjNCB1X2NvbG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsYXQgaW4gdmVjNCB2X2NvbG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIG91dCB2ZWM0IGZyYWc7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgdm9pZCBtYWluKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnID0gdV9jb2xvciAqIHZfY29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgfWA7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwiXHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIE1hdGNhcCAoTWF0ZXJpYWwgQ2FwdHVyZSkgc2hhZGluZy4gVGhlIHRleHR1cmUgcHJvdmlkZWQgYnkgdGhlIGNvYXQgaXMgdXNlZCBhcyBhIG1hdGNhcCBtYXRlcmlhbC4gXHJcbiAgICogSW1wbGVtZW50YXRpb24gYmFzZWQgb24gaHR0cHM6Ly93d3cuY2xpY2t0b3JlbGVhc2UuY29tL2Jsb2cvY3JlYXRpbmctc3BoZXJpY2FsLWVudmlyb25tZW50LW1hcHBpbmctc2hhZGVyL1xyXG4gICAqIEBhdXRob3JzIFNpbW9uIFN0b3JsLVNjaHVsa2UsIEhGVSwgMjAxOSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYWRlck1hdENhcCBleHRlbmRzIFNoYWRlciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gU2hhZGVyLnJlZ2lzdGVyU3ViY2xhc3MoU2hhZGVyTWF0Q2FwKTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQge1xyXG4gICAgICByZXR1cm4gQ29hdE1hdENhcDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldFZlcnRleFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gYCN2ZXJzaW9uIDMwMCBlc1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpbiB2ZWMzIGFfcG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgaW4gdmVjMyBhX25vcm1hbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybSBtYXQ0IHVfcHJvamVjdGlvbjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0IHZlYzIgdGV4Y29vcmRzX3Ntb290aDtcclxuICAgICAgICAgICAgICAgICAgICBmbGF0IG91dCB2ZWMyIHRleGNvb3Jkc19mbGF0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2b2lkIG1haW4oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleGNvb3Jkc19zbW9vdGggPSBub3JtYWxpemUobWF0Myh1X3Byb2plY3Rpb24pICogYV9ub3JtYWwpLnh5ICogMC41IC0gMC41O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXhjb29yZHNfZmxhdCA9IHRleGNvb3Jkc19zbW9vdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdV9wcm9qZWN0aW9uICogdmVjNChhX3Bvc2l0aW9uLCAxLjApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1gO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gYCN2ZXJzaW9uIDMwMCBlc1xyXG4gICAgICAgICAgICAgICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIHVuaWZvcm0gdmVjNCB1X3RpbnRfY29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybSBpbnQgc2hhZGVfc21vb3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBpbiB2ZWMyIHRleGNvb3Jkc19zbW9vdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxhdCBpbiB2ZWMyIHRleGNvb3Jkc19mbGF0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBvdXQgdmVjNCBmcmFnO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2b2lkIG1haW4oKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hhZGVfc21vb3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcgPSB1X3RpbnRfY29sb3IgKiB0ZXh0dXJlKHVfdGV4dHVyZSwgdGV4Y29vcmRzX3Ntb290aCkgKiAyLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZyA9IHVfdGludF9jb2xvciAqIHRleHR1cmUodV90ZXh0dXJlLCB0ZXhjb29yZHNfZmxhdCkgKiAyLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9YDtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBSZW5kZXJzIGZvciBSYXljYXN0aW5nXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyUmF5Q2FzdCBleHRlbmRzIFNoYWRlciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIGdldFZlcnRleFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gYCN2ZXJzaW9uIDMwMCBlc1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpbiB2ZWMzIGFfcG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybSBtYXQ0IHVfcHJvamVjdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICB2b2lkIG1haW4oKSB7ICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdV9wcm9qZWN0aW9uICogdmVjNChhX3Bvc2l0aW9uLCAxLjApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1gO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gYCN2ZXJzaW9uIDMwMCBlc1xyXG4gICAgICAgICAgICAgICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG4gICAgICAgICAgICAgICAgICAgIHByZWNpc2lvbiBoaWdocCBpbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybSBpbnQgdV9pZDtcclxuICAgICAgICAgICAgICAgICAgICBvdXQgdmVjNCBmcmFnO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBpZCA9IGZsb2F0KHVfaWQpLyAyNTYuMDtcclxuICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCB1cHBlcmJ5dGUgPSB0cnVuYyhnbF9GcmFnQ29vcmQueiAqIDI1Ni4wKSAvIDI1Ni4wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IGxvd2VyYnl0ZSA9IGZyYWN0KGdsX0ZyYWdDb29yZC56ICogMjU2LjApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGZyYWcgPSB2ZWM0KGdsX0ZyYWdDb29yZC56LCB1cHBlcmJ5dGUsIGxvd2VyYnl0ZSwgMS4wKTtcclxuICAgICAgICAgICAgICAgICAgICB9YDtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBUZXh0dXJlZCBzaGFkaW5nXHJcbiAgICogQGF1dGhvcnMgSmFzY2hhIEthcmFnw7ZsLCBIRlUsIDIwMTkgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJUZXh0dXJlIGV4dGVuZHMgU2hhZGVyIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBTaGFkZXIucmVnaXN0ZXJTdWJjbGFzcyhTaGFkZXJUZXh0dXJlKTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQge1xyXG4gICAgICByZXR1cm4gQ29hdFRleHR1cmVkO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0VmVydGV4U2hhZGVyU291cmNlKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiBgI3ZlcnNpb24gMzAwIGVzXHJcblxyXG4gICAgICAgICAgICAgICAgaW4gdmVjMyBhX3Bvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgaW4gdmVjMiBhX3RleHR1cmVVVnM7XHJcbiAgICAgICAgICAgICAgICB1bmlmb3JtIG1hdDQgdV9wcm9qZWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgdW5pZm9ybSBtYXQzIHVfcGl2b3Q7XHJcbiAgICAgICAgICAgICAgICBvdXQgdmVjMiB2X3RleHR1cmVVVnM7XHJcblxyXG4gICAgICAgICAgICAgICAgdm9pZCBtYWluKCkgeyAgXHJcbiAgICAgICAgICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB1X3Byb2plY3Rpb24gKiB2ZWM0KGFfcG9zaXRpb24sIDEuMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdl90ZXh0dXJlVVZzID0gYV90ZXh0dXJlVVZzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZfdGV4dHVyZVVWcyA9IHZlYzIodV9waXZvdCAqIHZlYzMoYV90ZXh0dXJlVVZzLCAxLjApKS54eTtcclxuICAgICAgICAgICAgICAgIH1gO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gYCN2ZXJzaW9uIDMwMCBlc1xyXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGluIHZlYzIgdl90ZXh0dXJlVVZzO1xyXG4gICAgICAgICAgICAgICAgdW5pZm9ybSB2ZWM0IHVfY29sb3I7XHJcbiAgICAgICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XHJcbiAgICAgICAgICAgICAgICAvLyB1bmlmb3JtIHZlYzQgdV9jb2xvckJhY2tncm91bmQ7IC8vIG1heWJlIGEgbWF0ZXJpYWwgYmFja2dyb3VuZCBjb2xvciBjYW4gc2hpbmUgdGhyb3VnaC4uLiBidXQgd2hlcmUgYW5kIHdpdGggd2hpY2ggaW50ZW5zaXR5P1xyXG4gICAgICAgICAgICAgICAgb3V0IHZlYzQgZnJhZztcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdm9pZCBtYWluKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZlYzQgY29sb3JUZXh0dXJlID0gdGV4dHVyZSh1X3RleHR1cmUsIHZfdGV4dHVyZVVWcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZnJhZyA9IHVfY29sb3IgKiBjb2xvclRleHR1cmU7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9mcmFnID0gdmVjNChjb2xvclRleHR1cmUuciAqIDEuMCwgY29sb3JUZXh0dXJlLmcgKiAwLjQsIGNvbG9yVGV4dHVyZS5iICogMC4xLCBjb2xvclRleHR1cmUuYSAqIDEuNSk7Ly91X2NvbG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZnJhZyA9IGNvbG9yVGV4dHVyZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZy5hIDwgMC4wMSlcclxuICAgICAgICAgICAgICAgICAgICAgIGRpc2NhcmQ7XHJcbiAgICAgICAgICAgIH1gO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFNpbmdsZSBjb2xvciBzaGFkaW5nXHJcbiAgICogQGF1dGhvcnMgSmFzY2hhIEthcmFnw7ZsLCBIRlUsIDIwMTkgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJVbmlDb2xvciBleHRlbmRzIFNoYWRlciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gU2hhZGVyLnJlZ2lzdGVyU3ViY2xhc3MoU2hhZGVyVW5pQ29sb3IpO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0Q29hdCgpOiB0eXBlb2YgQ29hdCB7XHJcbiAgICAgIHJldHVybiBDb2F0Q29sb3JlZDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldFZlcnRleFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gYCN2ZXJzaW9uIDMwMCBlc1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpbiB2ZWMzIGFfcG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybSBtYXQ0IHVfcHJvamVjdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICB2b2lkIG1haW4oKSB7ICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdV9wcm9qZWN0aW9uICogdmVjNChhX3Bvc2l0aW9uLCAxLjApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1gO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gYCN2ZXJzaW9uIDMwMCBlc1xyXG4gICAgICAgICAgICAgICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIHVuaWZvcm0gdmVjNCB1X2NvbG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIG91dCB2ZWM0IGZyYWc7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgdm9pZCBtYWluKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGZyYWcgPSB1X2NvbG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIH1gO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBCYXNlY2xhc3MgZm9yIGRpZmZlcmVudCBraW5kcyBvZiB0ZXh0dXJlcy4gXHJcbiAgICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAgICovXHJcbiAgICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgVGV4dHVyZSBleHRlbmRzIE11dGFibGUge1xyXG4gICAgICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKCk6IHZvaWQgey8qKi8gfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGV4dHVyZSBjcmVhdGVkIGZyb20gYW4gZXhpc3RpbmcgaW1hZ2VcclxuICAgICAqL1xyXG4gICAgZXhwb3J0IGNsYXNzIFRleHR1cmVJbWFnZSBleHRlbmRzIFRleHR1cmUge1xyXG4gICAgICAgIHB1YmxpYyBpbWFnZTogSFRNTEltYWdlRWxlbWVudCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRleHR1cmUgY3JlYXRlZCBmcm9tIGEgY2FudmFzXHJcbiAgICAgKi9cclxuICAgIGV4cG9ydCBjbGFzcyBUZXh0dXJlQ2FudmFzIGV4dGVuZHMgVGV4dHVyZSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRleHR1cmUgY3JlYXRlZCBmcm9tIGEgRlVER0UtU2tldGNoXHJcbiAgICAgKi9cclxuICAgIGV4cG9ydCBjbGFzcyBUZXh0dXJlU2tldGNoIGV4dGVuZHMgVGV4dHVyZUNhbnZhcyB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRleHR1cmUgY3JlYXRlZCBmcm9tIGFuIEhUTUwtcGFnZVxyXG4gICAgICovXHJcbiAgICBleHBvcnQgY2xhc3MgVGV4dHVyZUhUTUwgZXh0ZW5kcyBUZXh0dXJlQ2FudmFzIHtcclxuICAgIH1cclxufSIsIi8vIC88cmVmZXJlbmNlIHBhdGg9XCIuLi9FdmVudC9FdmVudC50c1wiLz5cclxuLy8gLzxyZWZlcmVuY2UgcGF0aD1cIi4uL1RpbWUvVGltZS50c1wiLz5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lcyB0aGUgbW9kZSBhIGxvb3AgcnVucyBpblxyXG4gICAqL1xyXG4gIGV4cG9ydCBlbnVtIExPT1BfTU9ERSB7XHJcbiAgICAvKiogTG9vcCBjeWNsZXMgY29udHJvbGxlZCBieSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICovXHJcbiAgICBGUkFNRV9SRVFVRVNUID0gXCJmcmFtZVJlcXVlc3RcIixcclxuICAgIC8qKiBMb29wIGN5Y2xlcyB3aXRoIHRoZSBnaXZlbiBmcmFtZXJhdGUgaW4gW1tUaW1lXV0uZ2FtZSAqL1xyXG4gICAgVElNRV9HQU1FID0gXCJ0aW1lR2FtZVwiLFxyXG4gICAgLyoqIExvb3AgY3ljbGVzIHdpdGggdGhlIGdpdmVuIGZyYW1lcmF0ZSBpbiByZWFsdGltZSwgaW5kZXBlbmRlbnQgb2YgW1tUaW1lXV0uZ2FtZSAqL1xyXG4gICAgVElNRV9SRUFMID0gXCJ0aW1lUmVhbFwiXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb3JlIGxvb3Agb2YgYSBGdWRnZSBhcHBsaWNhdGlvbi4gSW5pdGlhbGl6ZXMgYXV0b21hdGljYWxseSBhbmQgbXVzdCBiZSBzdGFydGVkIGV4cGxpY2l0bHkuXHJcbiAgICogSXQgdGhlbiBmaXJlcyBbW0VWRU5UXV0uTE9PUFxcX0ZSQU1FIHRvIGFsbCBhZGRlZCBsaXN0ZW5lcnMgYXQgZWFjaCBmcmFtZVxyXG4gICAqIFxyXG4gICAqIEBhdXRob3IgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgTG9vcCBleHRlbmRzIEV2ZW50VGFyZ2V0U3RhdGljIHtcclxuICAgIC8qKiBUaGUgZ2FtZXRpbWUgdGhlIGxvb3Agd2FzIHN0YXJ0ZWQsIG92ZXJ3cml0dGVuIGF0IGVhY2ggc3RhcnQgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgdGltZVN0YXJ0R2FtZTogbnVtYmVyID0gMDtcclxuICAgIC8qKiBUaGUgcmVhbHRpbWUgdGhlIGxvb3Agd2FzIHN0YXJ0ZWQsIG92ZXJ3cml0dGVuIGF0IGVhY2ggc3RhcnQgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgdGltZVN0YXJ0UmVhbDogbnVtYmVyID0gMDtcclxuICAgIC8qKiBUaGUgZ2FtZXRpbWUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCBsb29wIGN5Y2xlICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHRpbWVGcmFtZUdhbWU6IG51bWJlciA9IDA7XHJcbiAgICAvKiogVGhlIHJlYWx0aW1lIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgbG9vcCBjeWNsZSAqL1xyXG4gICAgcHVibGljIHN0YXRpYyB0aW1lRnJhbWVSZWFsOiBudW1iZXIgPSAwO1xyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIHRpbWVMYXN0RnJhbWVHYW1lOiBudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgdGltZUxhc3RGcmFtZVJlYWw6IG51bWJlciA9IDA7XHJcbiAgICBwcml2YXRlIHN0YXRpYyB0aW1lTGFzdEZyYW1lR2FtZUF2ZzogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgc3RhdGljIHRpbWVMYXN0RnJhbWVSZWFsQXZnOiBudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcnVubmluZzogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgbW9kZTogTE9PUF9NT0RFID0gTE9PUF9NT0RFLkZSQU1FX1JFUVVFU1Q7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBpZEludGVydmFsbDogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgc3RhdGljIGlkUmVxdWVzdDogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgc3RhdGljIGZwc0Rlc2lyZWQ6IG51bWJlciA9IDMwO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZnJhbWVzVG9BdmVyYWdlOiBudW1iZXIgPSAzMDtcclxuICAgIHByaXZhdGUgc3RhdGljIHN5bmNXaXRoQW5pbWF0aW9uRnJhbWU6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0cyB0aGUgbG9vcCB3aXRoIHRoZSBnaXZlbiBtb2RlIGFuZCBmcHNcclxuICAgICAqIEBwYXJhbSBfbW9kZSBcclxuICAgICAqIEBwYXJhbSBfZnBzIElzIG9ubHkgYXBwbGljYWJsZSBpbiBUSU1FLW1vZGVzXHJcbiAgICAgKiBAcGFyYW0gX3N5bmNXaXRoQW5pbWF0aW9uRnJhbWUgRXhwZXJpbWVudGFsIGFuZCBvbmx5IGFwcGxpY2FibGUgaW4gVElNRS1tb2Rlcy4gU2hvdWxkIGRlZmVyIHRoZSBsb29wLWN5Y2xlIHVudGlsIHRoZSBuZXh0IHBvc3NpYmxlIGFuaW1hdGlvbiBmcmFtZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzdGFydChfbW9kZTogTE9PUF9NT0RFID0gTE9PUF9NT0RFLkZSQU1FX1JFUVVFU1QsIF9mcHM6IG51bWJlciA9IDYwLCBfc3luY1dpdGhBbmltYXRpb25GcmFtZTogYm9vbGVhbiA9IGZhbHNlKTogdm9pZCB7XHJcbiAgICAgIExvb3Auc3RvcCgpO1xyXG5cclxuICAgICAgTG9vcC50aW1lU3RhcnRHYW1lID0gVGltZS5nYW1lLmdldCgpO1xyXG4gICAgICBMb29wLnRpbWVTdGFydFJlYWwgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgTG9vcC50aW1lTGFzdEZyYW1lR2FtZSA9IExvb3AudGltZVN0YXJ0R2FtZTtcclxuICAgICAgTG9vcC50aW1lTGFzdEZyYW1lUmVhbCA9IExvb3AudGltZVN0YXJ0UmVhbDtcclxuICAgICAgTG9vcC5mcHNEZXNpcmVkID0gKF9tb2RlID09IExPT1BfTU9ERS5GUkFNRV9SRVFVRVNUKSA/IDYwIDogX2ZwcztcclxuICAgICAgTG9vcC5mcmFtZXNUb0F2ZXJhZ2UgPSBMb29wLmZwc0Rlc2lyZWQ7XHJcbiAgICAgIExvb3AudGltZUxhc3RGcmFtZUdhbWVBdmcgPSBMb29wLnRpbWVMYXN0RnJhbWVSZWFsQXZnID0gMTAwMCAvIExvb3AuZnBzRGVzaXJlZDtcclxuICAgICAgTG9vcC5tb2RlID0gX21vZGU7XHJcbiAgICAgIExvb3Auc3luY1dpdGhBbmltYXRpb25GcmFtZSA9IF9zeW5jV2l0aEFuaW1hdGlvbkZyYW1lO1xyXG5cclxuICAgICAgbGV0IGxvZzogc3RyaW5nID0gYExvb3Agc3RhcnRpbmcgaW4gbW9kZSAke0xvb3AubW9kZX1gO1xyXG4gICAgICBpZiAoTG9vcC5tb2RlICE9IExPT1BfTU9ERS5GUkFNRV9SRVFVRVNUKVxyXG4gICAgICAgIGxvZyArPSBgIHdpdGggYXR0ZW1wdGVkICR7X2Zwc30gZnBzYDtcclxuICAgICAgRGVidWcuZnVkZ2UobG9nKTtcclxuXHJcbiAgICAgIHN3aXRjaCAoX21vZGUpIHtcclxuICAgICAgICBjYXNlIExPT1BfTU9ERS5GUkFNRV9SRVFVRVNUOlxyXG4gICAgICAgICAgTG9vcC5sb29wRnJhbWUoKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgTE9PUF9NT0RFLlRJTUVfUkVBTDpcclxuICAgICAgICAgIExvb3AuaWRJbnRlcnZhbGwgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoTG9vcC5sb29wVGltZSwgMTAwMCAvIExvb3AuZnBzRGVzaXJlZCk7XHJcbiAgICAgICAgICBMb29wLmxvb3BUaW1lKCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIExPT1BfTU9ERS5USU1FX0dBTUU6XHJcbiAgICAgICAgICBMb29wLmlkSW50ZXJ2YWxsID0gVGltZS5nYW1lLnNldFRpbWVyKDEwMDAgLyBMb29wLmZwc0Rlc2lyZWQsIDAsIExvb3AubG9vcFRpbWUpO1xyXG4gICAgICAgICAgTG9vcC5sb29wVGltZSgpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBMb29wLnJ1bm5pbmcgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgdGhlIGxvb3BcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzdG9wKCk6IHZvaWQge1xyXG4gICAgICBpZiAoIUxvb3AucnVubmluZylcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBzd2l0Y2ggKExvb3AubW9kZSkge1xyXG4gICAgICAgIGNhc2UgTE9PUF9NT0RFLkZSQU1FX1JFUVVFU1Q6XHJcbiAgICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoTG9vcC5pZFJlcXVlc3QpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBMT09QX01PREUuVElNRV9SRUFMOlxyXG4gICAgICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwoTG9vcC5pZEludGVydmFsbCk7XHJcbiAgICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoTG9vcC5pZFJlcXVlc3QpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBMT09QX01PREUuVElNRV9HQU1FOlxyXG4gICAgICAgICAgVGltZS5nYW1lLmRlbGV0ZVRpbWVyKExvb3AuaWRJbnRlcnZhbGwpO1xyXG4gICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKExvb3AuaWRSZXF1ZXN0KTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgICAgTG9vcC5ydW5uaW5nID0gZmFsc2U7XHJcbiAgICAgIERlYnVnLmZ1ZGdlKFwiTG9vcCBzdG9wcGVkIVwiKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGNvbnRpbnVlKCk6IHZvaWQge1xyXG4gICAgICBpZiAoTG9vcC5ydW5uaW5nKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIExvb3Auc3RhcnQoTG9vcC5tb2RlLCBMb29wLmZwc0Rlc2lyZWQsIExvb3Auc3luY1dpdGhBbmltYXRpb25GcmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRGcHNHYW1lQXZlcmFnZSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gMTAwMCAvIExvb3AudGltZUxhc3RGcmFtZUdhbWVBdmc7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc3RhdGljIGdldEZwc1JlYWxBdmVyYWdlKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiAxMDAwIC8gTG9vcC50aW1lTGFzdEZyYW1lUmVhbEF2ZztcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBsb29wKCk6IHZvaWQge1xyXG4gICAgICBsZXQgdGltZTogbnVtYmVyO1xyXG4gICAgICB0aW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgIExvb3AudGltZUZyYW1lUmVhbCA9IHRpbWUgLSBMb29wLnRpbWVMYXN0RnJhbWVSZWFsO1xyXG4gICAgICBMb29wLnRpbWVMYXN0RnJhbWVSZWFsID0gdGltZTtcclxuXHJcbiAgICAgIHRpbWUgPSBUaW1lLmdhbWUuZ2V0KCk7XHJcbiAgICAgIExvb3AudGltZUZyYW1lR2FtZSA9IHRpbWUgLSBMb29wLnRpbWVMYXN0RnJhbWVHYW1lO1xyXG4gICAgICBMb29wLnRpbWVMYXN0RnJhbWVHYW1lID0gdGltZTtcclxuXHJcbiAgICAgIExvb3AudGltZUxhc3RGcmFtZUdhbWVBdmcgPSAoKExvb3AuZnJhbWVzVG9BdmVyYWdlIC0gMSkgKiBMb29wLnRpbWVMYXN0RnJhbWVHYW1lQXZnICsgTG9vcC50aW1lRnJhbWVHYW1lKSAvIExvb3AuZnJhbWVzVG9BdmVyYWdlO1xyXG4gICAgICBMb29wLnRpbWVMYXN0RnJhbWVSZWFsQXZnID0gKChMb29wLmZyYW1lc1RvQXZlcmFnZSAtIDEpICogTG9vcC50aW1lTGFzdEZyYW1lUmVhbEF2ZyArIExvb3AudGltZUZyYW1lUmVhbCkgLyBMb29wLmZyYW1lc1RvQXZlcmFnZTtcclxuXHJcbiAgICAgIC8vIFRPRE86IGNvbnNpZGVyIExvb3BFdmVudCB3aGljaCBjb252ZXlzIGluZm9ybWF0aW9uIHN1Y2ggYXMgdGltZUVsYXBzZWQgZXRjLi4uXHJcbiAgICAgIGxldCBldmVudDogRXZlbnQgPSBuZXcgRXZlbnQoRVZFTlQuTE9PUF9GUkFNRSk7XHJcbiAgICAgIExvb3AudGFyZ2V0U3RhdGljLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGxvb3BGcmFtZSgpOiB2b2lkIHtcclxuICAgICAgTG9vcC5sb29wKCk7XHJcbiAgICAgIExvb3AuaWRSZXF1ZXN0ID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShMb29wLmxvb3BGcmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgbG9vcFRpbWUoKTogdm9pZCB7XHJcbiAgICAgIGlmIChMb29wLnN5bmNXaXRoQW5pbWF0aW9uRnJhbWUpXHJcbiAgICAgICAgTG9vcC5pZFJlcXVlc3QgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKExvb3AubG9vcCk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBMb29wLmxvb3AoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGludGVyZmFjZSBUaW1lVW5pdHMge1xyXG4gICAgaG91cnM/OiBudW1iZXI7XHJcbiAgICBtaW51dGVzPzogbnVtYmVyO1xyXG4gICAgc2Vjb25kcz86IG51bWJlcjtcclxuICAgIHRlbnRocz86IG51bWJlcjtcclxuICAgIGh1bmRyZWRzPzogbnVtYmVyO1xyXG4gICAgdGhvdXNhbmRzPzogbnVtYmVyO1xyXG4gICAgZnJhY3Rpb24/OiBudW1iZXI7XHJcbiAgICBhc0hvdXJzPzogbnVtYmVyO1xyXG4gICAgYXNNaW51dGVzPzogbnVtYmVyO1xyXG4gICAgYXNTZWNvbmRzPzogbnVtYmVyO1xyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGludGVyZmFjZSBUaW1lcnMgZXh0ZW5kcyBPYmplY3Qge1xyXG4gICAgW2lkOiBudW1iZXJdOiBUaW1lcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIGdlbmVyYXRlIGEgdGltZXN0YW1wIHRoYXQgY29ycmVsYXRlcyB3aXRoIHRoZSB0aW1lIGVsYXBzZWQgc2luY2UgdGhlIHN0YXJ0IG9mIHRoZSBwcm9ncmFtIGJ1dCBhbGxvd3MgZm9yIHJlc2V0dGluZyBhbmQgc2NhbGluZy4gIFxyXG4gICAqIFN1cHBvcnRzIFtbVGltZXJdXXMgc2ltaWxhciB0byB3aW5kb3cuc2V0SW50ZXJ2YWwgYnV0IHdpdGggcmVzcGVjdCB0byB0aGUgc2NhbGVkIHRpbWUuXHJcbiAgICogQWxsIHRpbWUgdmFsdWVzIGFyZSBnaXZlbiBpbiBtaWxsaXNlY29uZHNcclxuICAgKiBcclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBUaW1lIGV4dGVuZHMgRXZlbnRUYXJnZXTGkiB7XHJcbiAgICAvKiogU3RhbmRhcmQgZ2FtZSB0aW1lIHN0YXJ0aW5nIGF1dG9tYXRpY2FsbHkgd2l0aCB0aGUgYXBwbGljYXRpb24gKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgZ2FtZTogVGltZSA9IG5ldyBUaW1lKCk7XHJcbiAgICBwcml2YXRlIHN0YXJ0OiBudW1iZXI7XHJcbiAgICBwcml2YXRlIHNjYWxlOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIG9mZnNldDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBsYXN0Q2FsbFRvRWxhcHNlZDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSB0aW1lcnM6IFRpbWVycyA9IHt9O1xyXG4gICAgcHJpdmF0ZSBpZFRpbWVyTmV4dDogbnVtYmVyID0gMDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5zdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICB0aGlzLnNjYWxlID0gMS4wO1xyXG4gICAgICB0aGlzLm9mZnNldCA9IDAuMDtcclxuICAgICAgdGhpcy5sYXN0Q2FsbFRvRWxhcHNlZCA9IDAuMDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGdhbWUtdGltZS1vYmplY3Qgd2hpY2ggc3RhcnRzIGF1dG9tYXRpY2FsbHkgYW5kIHNlcnZlcyBhcyBiYXNlIGZvciB2YXJpb3VzIGludGVybmFsIG9wZXJhdGlvbnMuIFxyXG4gICAgICovXHJcbiAgICAvLyBwdWJsaWMgc3RhdGljIGdldCBnYW1lKCk6IFRpbWUge1xyXG4gICAgLy8gICByZXR1cm4gVGltZS5nYW1lVGltZTtcclxuICAgIC8vIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldFVuaXRzKF9taWxsaXNlY29uZHM6IG51bWJlcik6IFRpbWVVbml0cyB7XHJcbiAgICAgIGxldCB1bml0czogVGltZVVuaXRzID0ge307XHJcblxyXG4gICAgICB1bml0cy5hc1NlY29uZHMgPSBfbWlsbGlzZWNvbmRzIC8gMTAwMDtcclxuICAgICAgdW5pdHMuYXNNaW51dGVzID0gdW5pdHMuYXNTZWNvbmRzIC8gNjA7XHJcbiAgICAgIHVuaXRzLmFzSG91cnMgPSB1bml0cy5hc01pbnV0ZXMgLyA2MDtcclxuXHJcbiAgICAgIHVuaXRzLmhvdXJzID0gTWF0aC5mbG9vcih1bml0cy5hc0hvdXJzKTtcclxuICAgICAgdW5pdHMubWludXRlcyA9IE1hdGguZmxvb3IodW5pdHMuYXNNaW51dGVzKSAlIDYwO1xyXG4gICAgICB1bml0cy5zZWNvbmRzID0gTWF0aC5mbG9vcih1bml0cy5hc1NlY29uZHMpICUgNjA7XHJcblxyXG4gICAgICB1bml0cy5mcmFjdGlvbiA9IF9taWxsaXNlY29uZHMgJSAxMDAwO1xyXG4gICAgICB1bml0cy50aG91c2FuZHMgPSBfbWlsbGlzZWNvbmRzICUgMTA7XHJcbiAgICAgIHVuaXRzLmh1bmRyZWRzID0gX21pbGxpc2Vjb25kcyAlIDEwMCAtIHVuaXRzLnRob3VzYW5kcztcclxuICAgICAgdW5pdHMudGVudGhzID0gdW5pdHMuZnJhY3Rpb24gLSB1bml0cy5odW5kcmVkcyAtIHVuaXRzLnRob3VzYW5kcztcclxuXHJcbiAgICAgIHJldHVybiB1bml0cztcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gR2V0L1NldCB0aW1lIGFuZCBzY2FsaW5nXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyB0aGUgY3VycmVudCBzY2FsZWQgdGltZXN0YW1wIG9mIHRoaXMgaW5zdGFuY2UgaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0ICsgdGhpcy5zY2FsZSAqIChwZXJmb3JtYW5jZS5ub3coKSAtIHRoaXMuc3RhcnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcmVtYWluaW5nIHRpbWUgdG8gdGhlIGdpdmVuIHBvaW50IG9mIHRpbWVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFJlbWFpbmRlcihfdG86IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiBfdG8gLSB0aGlzLmdldCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogKFJlLSkgU2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoaXMgaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSBfdGltZSBUaGUgdGltZXN0YW1wIHRvIHJlcHJlc2VudCB0aGUgY3VycmVudCB0aW1lIChkZWZhdWx0IDAuMClcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldChfdGltZTogbnVtYmVyID0gMCk6IHZvaWQge1xyXG4gICAgICB0aGlzLm9mZnNldCA9IF90aW1lO1xyXG4gICAgICB0aGlzLnN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgIHRoaXMuZ2V0RWxhcHNlZFNpbmNlUHJldmlvdXNDYWxsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBzY2FsaW5nIG9mIHRoaXMgdGltZSwgYWxsb3dpbmcgZm9yIHNsb3dtb3Rpb24gKDwxKSBvciBmYXN0Zm9yd2FyZCAoPjEpIFxyXG4gICAgICogQHBhcmFtIF9zY2FsZSBUaGUgZGVzaXJlZCBzY2FsaW5nIChkZWZhdWx0IDEuMClcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFNjYWxlKF9zY2FsZTogbnVtYmVyID0gMS4wKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuc2V0KHRoaXMuZ2V0KCkpO1xyXG4gICAgICB0aGlzLnNjYWxlID0gX3NjYWxlO1xyXG4gICAgICAvL1RPRE86IGNhdGNoIHNjYWxlPTBcclxuICAgICAgdGhpcy5yZXNjYWxlQWxsVGltZXJzKCk7XHJcbiAgICAgIHRoaXMuZ2V0RWxhcHNlZFNpbmNlUHJldmlvdXNDYWxsKCk7XHJcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuVElNRV9TQ0FMRUQpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyB0aGUgY3VycmVudCBzY2FsaW5nIG9mIHRoaXMgdGltZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0U2NhbGUoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc2NhbGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIG9mZnNldCBvZiB0aGlzIHRpbWVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldE9mZnNldCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5vZmZzZXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHNjYWxlZCB0aW1lIGluIG1pbGxpc2Vjb25kcyBwYXNzZWQgc2luY2UgdGhlIGxhc3QgY2FsbCB0byB0aGlzIG1ldGhvZFxyXG4gICAgICogQXV0b21hdGljYWxseSByZXNldCBhdCBldmVyeSBjYWxsIHRvIHNldCguLi4pIGFuZCBzZXRTY2FsZSguLi4pXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRFbGFwc2VkU2luY2VQcmV2aW91c0NhbGwoKTogbnVtYmVyIHtcclxuICAgICAgbGV0IGN1cnJlbnQ6IG51bWJlciA9IHRoaXMuZ2V0KCk7XHJcbiAgICAgIGxldCBlbGFwc2VkOiBudW1iZXIgPSBjdXJyZW50IC0gdGhpcy5sYXN0Q2FsbFRvRWxhcHNlZDtcclxuICAgICAgdGhpcy5sYXN0Q2FsbFRvRWxhcHNlZCA9IGN1cnJlbnQ7XHJcbiAgICAgIHJldHVybiBlbGFwc2VkO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG5cclxuICAgIC8vI3JlZ2lvbiBUaW1lcnNcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIFByb21pc2U8dm9pZD4gdG8gYmUgcmVzb2x2ZWQgYWZ0ZXIgdGhlIHRpbWUgZ2l2ZW4uIFRvIGJlIHVzZWQgd2l0aCBhc3luYy9hd2FpdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZGVsYXkoX2xhcHNlOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKF9yZXNvbHZlID0+IHRoaXMuc2V0VGltZXIoX2xhcHNlLCAxLCAoKSA9PiBfcmVzb2x2ZSgpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETzogZXhhbWluZSBpZiB3ZWItd29ya2VycyB3b3VsZCBlbmhhbmNlIHBlcmZvcm1hbmNlIGhlcmUhXHJcbiAgICAvKipcclxuICAgICAqIFN0b3BzIGFuZCBkZWxldGVzIGFsbCBbW1RpbWVyXV1zIGF0dGFjaGVkLiBTaG91bGQgYmUgY2FsbGVkIGJlZm9yZSB0aGlzIFRpbWUtb2JqZWN0IGxlYXZlcyBzY29wZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY2xlYXJBbGxUaW1lcnMoKTogdm9pZCB7XHJcbiAgICAgIGZvciAobGV0IGlkIGluIHRoaXMudGltZXJzKSB7XHJcbiAgICAgICAgdGhpcy5kZWxldGVUaW1lcihOdW1iZXIoaWQpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyBbW1RpbWVyXV0gZm91bmQgdXNpbmcgdGhlIGludGVybmFsIGlkIG9mIHRoZSBjb25uZWN0ZWQgaW50ZXJ2YWwtb2JqZWN0XHJcbiAgICAgKiBAcGFyYW0gX2lkIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZGVsZXRlVGltZXJCeUl0c0ludGVybmFsSWQoX2lkOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgZm9yIChsZXQgaWQgaW4gdGhpcy50aW1lcnMpIHtcclxuICAgICAgICBsZXQgdGltZXI6IFRpbWVyID0gdGhpcy50aW1lcnNbaWRdO1xyXG4gICAgICAgIGlmICh0aW1lci5pZCA9PSBfaWQpIHtcclxuICAgICAgICAgIHRpbWVyLmNsZWFyKCk7XHJcbiAgICAgICAgICBkZWxldGUgdGhpcy50aW1lcnNbaWRdO1xyXG4gICAgICAgICAgLy8gVE9ETzogY2hlY2sgaWYgYW4gZWFybHkgb3V0IGlzIE9LIGhlcmUuLi4gc2hvdWxkIGJlIVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5zdGFsbHMgYSB0aW1lciBhdCB0aGlzIHRpbWUgb2JqZWN0XHJcbiAgICAgKiBAcGFyYW0gX2xhcHNlIFRoZSBvYmplY3QtdGltZSB0byBlbGFwc2UgYmV0d2VlbiB0aGUgY2FsbHMgdG8gX2NhbGxiYWNrXHJcbiAgICAgKiBAcGFyYW0gX2NvdW50IFRoZSBudW1iZXIgb2YgY2FsbHMgZGVzaXJlZCwgMCA9IEluZmluaXRlXHJcbiAgICAgKiBAcGFyYW0gX2hhbmRsZXIgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZWFjaCB0aGUgZ2l2ZW4gbGFwc2UgaGFzIGVsYXBzZWRcclxuICAgICAqIEBwYXJhbSBfYXJndW1lbnRzIEFkZGl0aW9uYWwgcGFyYW1ldGVycyB0byBwYXNzIHRvIGNhbGxiYWNrIGZ1bmN0aW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRUaW1lcihfbGFwc2U6IG51bWJlciwgX2NvdW50OiBudW1iZXIsIF9oYW5kbGVyOiBUaW1lckhhbmRsZXIsIC4uLl9hcmd1bWVudHM6IE9iamVjdFtdKTogbnVtYmVyIHtcclxuICAgICAgbGV0IHRpbWVyOiBUaW1lciA9IG5ldyBUaW1lcih0aGlzLCBfbGFwc2UsIF9jb3VudCwgX2hhbmRsZXIsIF9hcmd1bWVudHMpO1xyXG4gICAgICB0aGlzLnRpbWVyc1srK3RoaXMuaWRUaW1lck5leHRdID0gdGltZXI7XHJcbiAgICAgIHJldHVybiB0aGlzLmlkVGltZXJOZXh0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyB0aGUgdGltZXIgd2l0aCB0aGUgaWQgZ2l2ZW4gYnkgdGhpcyB0aW1lIG9iamVjdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZGVsZXRlVGltZXIoX2lkOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgbGV0IHRpbWVyOiBUaW1lciA9IHRoaXMudGltZXJzW19pZF07XHJcbiAgICAgIGlmICghdGltZXIpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB0aW1lci5jbGVhcigpO1xyXG4gICAgICBkZWxldGUgdGhpcy50aW1lcnNbX2lkXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIHRpbWVyIHdpdGggdGhlIGdpdmVuIGlkIG9yIG51bGwgaWYgbm90IGZvdW5kLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0VGltZXIoX2lkOiBudW1iZXIpOiBUaW1lciB7XHJcbiAgICAgIHJldHVybiB0aGlzLnRpbWVyc1tfaWRdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIGxpc3Qgb2YgdGltZXJzIGN1cnJlbnRseSBpbnN0YWxsZWQgb24gdGhpcyB0aW1lIG9iamVjdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0VGltZXJzKCk6IFRpbWVycyB7XHJcbiAgICAgIGxldCByZXN1bHQ6IFRpbWVycyA9IHt9O1xyXG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihyZXN1bHQsIHRoaXMudGltZXJzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGVyZSBhcmUgW1tUaW1lcnNdXSBpbnN0YWxsZWQgdG8gdGhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaGFzVGltZXJzKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gKE9iamVjdC5rZXlzKHRoaXMudGltZXJzKS5sZW5ndGggPiAwKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlY3JlYXRlcyBbW1RpbWVyXV1zIHdoZW4gc2NhbGluZyBjaGFuZ2VzXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcmVzY2FsZUFsbFRpbWVycygpOiB2b2lkIHtcclxuICAgICAgZm9yIChsZXQgaWQgaW4gdGhpcy50aW1lcnMpIHtcclxuICAgICAgICBsZXQgdGltZXI6IFRpbWVyID0gdGhpcy50aW1lcnNbaWRdO1xyXG4gICAgICAgIHRpbWVyLmNsZWFyKCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLnNjYWxlKVxyXG4gICAgICAgICAgLy8gVGltZSBoYXMgc3RvcHBlZCwgbm8gbmVlZCB0byByZXBsYWNlIGNsZWFyZWQgdGltZXJzXHJcbiAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgdGhpcy50aW1lcnNbaWRdID0gdGltZXIuaW5zdGFsbENvcHkoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICAvLyNlbmRyZWdpb25cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIERlZmluZXMgdGhlIHNpZ25hdHVyZSBvZiBoYW5kbGVyIGZ1bmN0aW9ucyBmb3IgW1tUaW1lckV2ZW50xpJdXXMsIHZlcnkgc2ltaWxhciB0byB1c3VhbCBldmVudCBoYW5kbGVyXHJcbiAgICovXHJcbiAgZXhwb3J0IHR5cGUgVGltZXJIYW5kbGVyID0gKF9ldmVudDogRXZlbnRUaW1lcikgPT4gdm9pZDtcclxuXHJcbiAgLyoqXHJcbiAgICogQSBbW1RpbWVyXV0taW5zdGFuY2UgaW50ZXJuYWxseSB1c2VzIHdpbmRvdy5zZXRJbnRlcnZhbCB0byBjYWxsIGEgZ2l2ZW4gaGFuZGxlciB3aXRoIGEgZ2l2ZW4gZnJlcXVlbmN5IGEgZ2l2ZW4gbnVtYmVyIG9mIHRpbWVzLFxyXG4gICAqIHBhc3NpbmcgYW4gW1tUaW1lckV2ZW50xpJdXS1pbnN0YW5jZSB3aXRoIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYW5kIGdpdmVuIGFyZ3VtZW50cy4gXHJcbiAgICogVGhlIGZyZXF1ZW5jeSBzY2FsZXMgd2l0aCB0aGUgW1tUaW1lXV0taW5zdGFuY2UgdGhlIFtbVGltZXJdXS1pbnN0YW5jZSBpcyBhdHRhY2hlZCB0by5cclxuICAgKiBcclxuICAgKiBAYXV0aG9yIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFRpbWVyIHtcclxuICAgIHB1YmxpYyBhY3RpdmU6IGJvb2xlYW47XHJcbiAgICBwdWJsaWMgY291bnQ6IG51bWJlcjtcclxuICAgIHByaXZhdGUgaGFuZGxlcjogVGltZXJIYW5kbGVyO1xyXG4gICAgcHJpdmF0ZSB0aW1lOiBUaW1lO1xyXG4gICAgcHJpdmF0ZSBlbGFwc2U6IG51bWJlcjtcclxuICAgIHByaXZhdGUgZXZlbnQ6IEV2ZW50VGltZXI7XHJcbiAgICBwcml2YXRlIHRpbWVvdXRSZWFsOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIGlkV2luZG93OiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgW1tUaW1lcl1dIGluc3RhbmNlLlxyXG4gICAgICogQHBhcmFtIF90aW1lIFRoZSBbW1RpbWVdXSBpbnN0YW5jZSwgdGhlIHRpbWVyIGF0dGFjaGVzIHRvXHJcbiAgICAgKiBAcGFyYW0gX2VsYXBzZSBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgdG8gZWxhcHNlLCB0byB0aGUgbmV4dCBjYWxsIG9mIF9oYW5kbGVyLCBtZWFzdXJlZCBpbiBfdGltZVxyXG4gICAgICogQHBhcmFtIF9jb3VudCBUaGUgZGVzaXJlZCBudW1iZXIgb2YgY2FsbHMgdG8gX2hhbmRsZXIsIFRpbWVyIGRlaW5zdGFsbHMgYXV0b21hdGljYWxseSBhZnRlciBsYXN0IGNhbGwuIFBhc3NpbmcgMCBpbnZva2VzIGluZmluaXRlIGNhbGxzXHJcbiAgICAgKiBAcGFyYW0gX2hhbmRsZXIgVGhlIFtbVGltZXJIYW5kbGVyXV0gaW5zdGFuY2UgdG8gY2FsbFxyXG4gICAgICogQHBhcmFtIF9hcmd1bWVudHMgQWRkaXRpb25hbCBhcmd1bWVudHMgdG8gcGFzcyB0byBfaGFuZGxlclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihfdGltZTogVGltZSwgX2VsYXBzZTogbnVtYmVyLCBfY291bnQ6IG51bWJlciwgX2hhbmRsZXI6IFRpbWVySGFuZGxlciwgLi4uX2FyZ3VtZW50czogT2JqZWN0W10pIHtcclxuICAgICAgdGhpcy50aW1lID0gX3RpbWU7XHJcbiAgICAgIHRoaXMuZWxhcHNlID0gX2VsYXBzZTtcclxuICAgICAgdGhpcy5ldmVudCA9IG5ldyBFdmVudFRpbWVyKHRoaXMsIF9hcmd1bWVudHMpO1xyXG4gICAgICB0aGlzLmhhbmRsZXIgPSBfaGFuZGxlcjtcclxuICAgICAgdGhpcy5jb3VudCA9IF9jb3VudDtcclxuXHJcbiAgICAgIGxldCBzY2FsZTogbnVtYmVyID0gTWF0aC5hYnMoX3RpbWUuZ2V0U2NhbGUoKSk7XHJcblxyXG4gICAgICBpZiAoIXNjYWxlKSB7XHJcbiAgICAgICAgLy8gVGltZSBpcyBzdG9wcGVkLCB0aW1lciB3b24ndCBiZSBhY3RpdmVcclxuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy50aW1lb3V0UmVhbCA9IHRoaXMuZWxhcHNlIC8gc2NhbGU7XHJcblxyXG4gICAgICBsZXQgY2FsbGJhY2s6IEZ1bmN0aW9uID0gKCk6IHZvaWQgPT4ge1xyXG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUpXHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICBcclxuICAgICAgICB0aGlzLmV2ZW50Lmxhc3RDYWxsID0gKHRoaXMuY291bnQgPT0gMSk7XHJcbiAgICAgICAgX2hhbmRsZXIodGhpcy5ldmVudCk7XHJcbiAgICAgICAgdGhpcy5ldmVudC5maXJzdENhbGwgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY291bnQgPiAwKVxyXG4gICAgICAgICAgaWYgKC0tdGhpcy5jb3VudCA9PSAwKVxyXG4gICAgICAgICAgICBfdGltZS5kZWxldGVUaW1lckJ5SXRzSW50ZXJuYWxJZCh0aGlzLmlkV2luZG93KTtcclxuXHJcbiAgICAgIH07XHJcblxyXG4gICAgICB0aGlzLmlkV2luZG93ID0gd2luZG93LnNldEludGVydmFsKGNhbGxiYWNrLCB0aGlzLnRpbWVvdXRSZWFsLCBfYXJndW1lbnRzKTtcclxuICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgd2luZG93LWlkIG9mIHRoZSB0aW1lciwgd2hpY2ggd2FzIHJldHVybmVkIGJ5IHNldEludGVydmFsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgaWQoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuaWRXaW5kb3c7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB0aW1lLWludGVydmFsbCBmb3IgY2FsbHMgdG8gdGhlIGhhbmRsZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBsYXBzZSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5lbGFwc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBdHRhY2hlcyBhIGNvcHkgb2YgdGhpcyBhdCBpdHMgY3VycmVudCBzdGF0ZSB0byB0aGUgc2FtZSBbW1RpbWVdXS1pbnN0YW5jZS4gVXNlZCBpbnRlcm5hbGx5IHdoZW4gcmVzY2FsaW5nIFtbVGltZV1dXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpbnN0YWxsQ29weSgpOiBUaW1lciB7XHJcbiAgICAgIHJldHVybiBuZXcgVGltZXIodGhpcy50aW1lLCB0aGlzLmVsYXBzZSwgdGhpcy5jb3VudCwgdGhpcy5oYW5kbGVyLCB0aGlzLmV2ZW50LmFyZ3VtZW50cyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgdGhlIHRpbWVyLCByZW1vdmluZyBpdCBmcm9tIHRoZSBpbnRlcnZhbC10aW1lcnMgaGFuZGxlZCBieSB3aW5kb3dcclxuICAgICAqL1xyXG4gICAgcHVibGljIGNsZWFyKCk6IHZvaWQge1xyXG4gICAgICAvLyBpZiAodGhpcy50eXBlID09IFRJTUVSX1RZUEUuVElNRU9VVCkge1xyXG4gICAgICAvLyAgICAgaWYgKHRoaXMuYWN0aXZlKVxyXG4gICAgICAvLyAgICAgICAgIC8vIHNhdmUgcmVtYWluaW5nIHRpbWUgdG8gdGltZW91dCBhcyBuZXcgdGltZW91dCBmb3IgcmVzdGFydFxyXG4gICAgICAvLyAgICAgICAgIHRoaXMudGltZW91dCA9IHRoaXMudGltZW91dCAqICgxIC0gKHBlcmZvcm1hbmNlLm5vdygpIC0gdGhpcy5zdGFydFRpbWVSZWFsKSAvIHRoaXMudGltZW91dFJlYWwpO1xyXG4gICAgICAvLyAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLmlkKTtcclxuICAgICAgLy8gfVxyXG4gICAgICAvLyBlbHNlXHJcbiAgICAgIC8vIFRPRE86IHJldXNpbmcgdGltZXIgc3RhcnRzIGludGVydmFsIGFuZXcuIFNob3VsZCBiZSByZW1haW5pbmcgaW50ZXJ2YWwgYXMgdGltZW91dCwgdGhlbiBzdGFydGluZyBpbnRlcnZhbCBhbmV3IFxyXG4gICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLmlkV2luZG93KTtcclxuICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAgIGV4cG9ydCBpbnRlcmZhY2UgTWFwRmlsZW5hbWVUb0NvbnRlbnQge1xyXG4gICAgICAgIFtmaWxlbmFtZTogc3RyaW5nXTogc3RyaW5nO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVzIGZpbGUgdHJhbnNmZXIgZnJvbSBhIEZ1ZGdlLUJyb3dzZXJhcHAgdG8gdGhlIGxvY2FsIGZpbGVzeXN0ZW0gd2l0aG91dCBhIGxvY2FsIHNlcnZlci4gIFxyXG4gICAgICogU2F2ZXMgdG8gdGhlIGRvd25sb2FkLXBhdGggZ2l2ZW4gYnkgdGhlIGJyb3dzZXIsIGxvYWRzIGZyb20gdGhlIHBsYXllcidzIGNob2ljZS5cclxuICAgICAqL1xyXG4gICAgZXhwb3J0IGNsYXNzIEZpbGVJb0Jyb3dzZXJMb2NhbCBleHRlbmRzIEV2ZW50VGFyZ2V0U3RhdGljIHtcclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBzZWxlY3RvcjogSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICAvLyBUT0RPOiByZWZhY3RvciB0byBhc3luYyBmdW5jdGlvbiB0byBiZSBoYW5kbGVkIHVzaW5nIHByb21pc2UsIGluc3RlYWQgb2YgdXNpbmcgZXZlbnQgdGFyZ2V0XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBsb2FkKCk6IHZvaWQge1xyXG4gICAgICAgICAgICBGaWxlSW9Ccm93c2VyTG9jYWwuc2VsZWN0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XHJcbiAgICAgICAgICAgIEZpbGVJb0Jyb3dzZXJMb2NhbC5zZWxlY3Rvci50eXBlID0gXCJmaWxlXCI7XHJcbiAgICAgICAgICAgIEZpbGVJb0Jyb3dzZXJMb2NhbC5zZWxlY3Rvci5tdWx0aXBsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIEZpbGVJb0Jyb3dzZXJMb2NhbC5zZWxlY3Rvci5oaWRkZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICBGaWxlSW9Ccm93c2VyTG9jYWwuc2VsZWN0b3IuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBGaWxlSW9Ccm93c2VyTG9jYWwuaGFuZGxlRmlsZVNlbGVjdCk7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoRmlsZUlvQnJvd3NlckxvY2FsLnNlbGVjdG9yKTtcclxuICAgICAgICAgICAgRmlsZUlvQnJvd3NlckxvY2FsLnNlbGVjdG9yLmNsaWNrKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUT0RPOiByZWZhY3RvciB0byBhc3luYyBmdW5jdGlvbiB0byBiZSBoYW5kbGVkIHVzaW5nIHByb21pc2UsIGluc3RlYWQgb2YgdXNpbmcgZXZlbnQgdGFyZ2V0XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBzYXZlKF90b1NhdmU6IE1hcEZpbGVuYW1lVG9Db250ZW50KTogdm9pZCB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGZpbGVuYW1lIGluIF90b1NhdmUpIHtcclxuICAgICAgICAgICAgICAgIGxldCBjb250ZW50OiBzdHJpbmcgPSBfdG9TYXZlW2ZpbGVuYW1lXTtcclxuICAgICAgICAgICAgICAgIGxldCBibG9iOiBCbG9iID0gbmV3IEJsb2IoW2NvbnRlbnRdLCB7IHR5cGU6IFwidGV4dC9wbGFpblwiIH0pO1xyXG4gICAgICAgICAgICAgICAgbGV0IHVybDogc3RyaW5nID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcbiAgICAgICAgICAgICAgICAvLyovIHVzaW5nIGFuY2hvciBlbGVtZW50IGZvciBkb3dubG9hZFxyXG4gICAgICAgICAgICAgICAgbGV0IGRvd25sb2FkZXI6IEhUTUxBbmNob3JFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgZG93bmxvYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xyXG4gICAgICAgICAgICAgICAgZG93bmxvYWRlci5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIHVybCk7XHJcbiAgICAgICAgICAgICAgICBkb3dubG9hZGVyLnNldEF0dHJpYnV0ZShcImRvd25sb2FkXCIsIGZpbGVuYW1lKTtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZG93bmxvYWRlcik7XHJcbiAgICAgICAgICAgICAgICBkb3dubG9hZGVyLmNsaWNrKCk7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRvd25sb2FkZXIpO1xyXG4gICAgICAgICAgICAgICAgd2luZG93LlVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IGV2ZW50OiBDdXN0b21FdmVudCA9IG5ldyBDdXN0b21FdmVudChFVkVOVC5GSUxFX1NBVkVELCB7IGRldGFpbDogeyBtYXBGaWxlbmFtZVRvQ29udGVudDogX3RvU2F2ZSB9IH0pO1xyXG4gICAgICAgICAgICBGaWxlSW9Ccm93c2VyTG9jYWwudGFyZ2V0U3RhdGljLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBhc3luYyBoYW5kbGVGaWxlU2VsZWN0KF9ldmVudDogRXZlbnQpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICAgICAgRGVidWcuZnVkZ2UoXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBoYW5kbGVGaWxlU2VsZWN0XCIpO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKEZpbGVJb0Jyb3dzZXJMb2NhbC5zZWxlY3Rvcik7XHJcbiAgICAgICAgICAgIGxldCBmaWxlTGlzdDogRmlsZUxpc3QgPSAoPEhUTUxJbnB1dEVsZW1lbnQ+X2V2ZW50LnRhcmdldCkuZmlsZXM7XHJcbiAgICAgICAgICAgIERlYnVnLmZ1ZGdlKGZpbGVMaXN0LCBmaWxlTGlzdC5sZW5ndGgpO1xyXG4gICAgICAgICAgICBpZiAoZmlsZUxpc3QubGVuZ3RoID09IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBsZXQgbG9hZGVkOiBNYXBGaWxlbmFtZVRvQ29udGVudCA9IHt9O1xyXG4gICAgICAgICAgICBhd2FpdCBGaWxlSW9Ccm93c2VyTG9jYWwubG9hZEZpbGVzKGZpbGVMaXN0LCBsb2FkZWQpO1xyXG5cclxuICAgICAgICAgICAgbGV0IGV2ZW50OiBDdXN0b21FdmVudCA9IG5ldyBDdXN0b21FdmVudChFVkVOVC5GSUxFX0xPQURFRCwgeyBkZXRhaWw6IHsgbWFwRmlsZW5hbWVUb0NvbnRlbnQ6IGxvYWRlZCB9IH0pO1xyXG4gICAgICAgICAgICBGaWxlSW9Ccm93c2VyTG9jYWwudGFyZ2V0U3RhdGljLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBhc3luYyBsb2FkRmlsZXMoX2ZpbGVMaXN0OiBGaWxlTGlzdCwgX2xvYWRlZDogTWFwRmlsZW5hbWVUb0NvbnRlbnQpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICAgICAgZm9yIChsZXQgZmlsZSBvZiBfZmlsZUxpc3QpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQ6IHN0cmluZyA9IGF3YWl0IG5ldyBSZXNwb25zZShmaWxlKS50ZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBfbG9hZGVkW2ZpbGUubmFtZV0gPSBjb250ZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59ICJdfQ==