"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var FudgeCore;
(function (FudgeCore) {
    /**
     * Base class for the different DebugTargets, mainly for technical purpose of inheritance
     */
    class DebugTarget {
        static mergeArguments(_message, ..._args) {
            let out = _message.toString(); //JSON.stringify(_message);
            for (let arg of _args)
                if (arg instanceof Number)
                    out += ", " + arg.toPrecision(2).toString(); //JSON.stringify(arg, null, 2);
                else
                    out += ", " + arg.toString(); //JSON.stringify(arg, null, 2);
            return out;
        }
    }
    FudgeCore.DebugTarget = DebugTarget;
})(FudgeCore || (FudgeCore = {}));
// <reference path="DebugAlert.ts"/>
var FudgeCore;
// <reference path="DebugAlert.ts"/>
(function (FudgeCore) {
    /**
     * The filters corresponding to debug activities, more to come
     */
    let DEBUG_FILTER;
    (function (DEBUG_FILTER) {
        DEBUG_FILTER[DEBUG_FILTER["NONE"] = 0] = "NONE";
        DEBUG_FILTER[DEBUG_FILTER["INFO"] = 1] = "INFO";
        DEBUG_FILTER[DEBUG_FILTER["LOG"] = 2] = "LOG";
        DEBUG_FILTER[DEBUG_FILTER["WARN"] = 4] = "WARN";
        DEBUG_FILTER[DEBUG_FILTER["ERROR"] = 8] = "ERROR";
        DEBUG_FILTER[DEBUG_FILTER["FUDGE"] = 16] = "FUDGE";
        DEBUG_FILTER[DEBUG_FILTER["CLEAR"] = 256] = "CLEAR";
        DEBUG_FILTER[DEBUG_FILTER["GROUP"] = 257] = "GROUP";
        DEBUG_FILTER[DEBUG_FILTER["GROUPCOLLAPSED"] = 258] = "GROUPCOLLAPSED";
        DEBUG_FILTER[DEBUG_FILTER["GROUPEND"] = 260] = "GROUPEND";
        DEBUG_FILTER[DEBUG_FILTER["SOURCE"] = 512] = "SOURCE";
        DEBUG_FILTER[DEBUG_FILTER["MESSAGES"] = 31] = "MESSAGES";
        DEBUG_FILTER[DEBUG_FILTER["FORMAT"] = 263] = "FORMAT";
        DEBUG_FILTER[DEBUG_FILTER["ALL"] = 287] = "ALL";
    })(DEBUG_FILTER = FudgeCore.DEBUG_FILTER || (FudgeCore.DEBUG_FILTER = {}));
    FudgeCore.DEBUG_SYMBOL = {
        [DEBUG_FILTER.INFO]: "‚úì",
        [DEBUG_FILTER.LOG]: "‚úé",
        [DEBUG_FILTER.WARN]: "‚ö†",
        [DEBUG_FILTER.ERROR]: "‚ùå",
        [DEBUG_FILTER.FUDGE]: "üé≤",
        [DEBUG_FILTER.SOURCE]: "üîó"
    };
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
(function (FudgeCore) {
    /**
     * Routing to the standard-console
     */
    class DebugConsole extends FudgeCore.DebugTarget {
        /**
         * Should be used to display uncritical state information of FUDGE, only visible in browser's verbose mode
         */
        static fudge(_message, ..._args) {
            console.debug(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.FUDGE], _message, ..._args);
        }
        /**
         * Displays an extra line with information about the source of the debug message
         */
        static source(_message, ..._args) {
            console.log(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.SOURCE], _message, ..._args);
        }
    }
    DebugConsole.delegates = {
        [FudgeCore.DEBUG_FILTER.INFO]: console.info,
        [FudgeCore.DEBUG_FILTER.LOG]: console.log,
        [FudgeCore.DEBUG_FILTER.WARN]: console.warn,
        [FudgeCore.DEBUG_FILTER.ERROR]: console.error,
        [FudgeCore.DEBUG_FILTER.FUDGE]: DebugConsole.fudge,
        [FudgeCore.DEBUG_FILTER.CLEAR]: console.clear,
        [FudgeCore.DEBUG_FILTER.GROUP]: console.group,
        [FudgeCore.DEBUG_FILTER.GROUPCOLLAPSED]: console.groupCollapsed,
        [FudgeCore.DEBUG_FILTER.GROUPEND]: console.groupEnd,
        [FudgeCore.DEBUG_FILTER.SOURCE]: DebugConsole.source
    };
    FudgeCore.DebugConsole = DebugConsole;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
/// <reference path="DebugInterfaces.ts"/>
/// <reference path="DebugConsole.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
/// <reference path="DebugInterfaces.ts"/>
/// <reference path="DebugConsole.ts"/>
(function (FudgeCore) {
    /**
     * The Debug-Class offers functions known from the console-object and additions,
     * routing the information to various {@link DebugTarget}s that can be easily defined by the developers and registerd by users
     * Override functions in subclasses of {@link DebugTarget} and register them as their delegates
     */
    class Debug {
        /**
         * De- / Activate a filter for the given DebugTarget.
         */
        static setFilter(_target, _filter) {
            for (let filter in Debug.delegates)
                Debug.delegates[filter].delete(_target);
            for (let filter in FudgeCore.DEBUG_FILTER) {
                let parsed = parseInt(filter);
                if (isNaN(parsed))
                    break;
                if ([FudgeCore.DEBUG_FILTER.MESSAGES, FudgeCore.DEBUG_FILTER.FORMAT, FudgeCore.DEBUG_FILTER.ALL].indexOf(parsed) != -1)
                    // dont delegate combos... 
                    continue;
                if (_filter & parsed)
                    Debug.delegates[parsed].set(_target, _target.delegates[parsed]);
            }
        }
        /**
         * Info(...) displays additional information with low priority
         */
        static info(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.INFO, _message, _args);
        }
        /**
         * Displays information with medium priority
         */
        static log(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.LOG, _message, _args);
        }
        /**
         * Displays information about non-conformities in usage, which is emphasized e.g. by color
         */
        static warn(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.WARN, _message, _args);
        }
        /**
         * Displays critical information about failures, which is emphasized e.g. by color
         */
        static error(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.ERROR, _message, _args);
        }
        /**
         * Displays messages from FUDGE
         */
        static fudge(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.FUDGE, _message, _args);
        }
        /**
         * Clears the output and removes previous messages if possible
         */
        static clear() {
            Debug.delegate(FudgeCore.DEBUG_FILTER.CLEAR, null, null);
        }
        /**
         * Opens a new group for messages
         */
        static group(_name) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.GROUP, _name, null);
        }
        /**
         * Opens a new group for messages that is collapsed at first
         */
        static groupCollapsed(_name) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.GROUPCOLLAPSED, _name, null);
        }
        /**
         * Closes the youngest group
         */
        static groupEnd() {
            Debug.delegate(FudgeCore.DEBUG_FILTER.GROUPEND, null, null);
        }
        /**
         * Log a branch of the node hierarchy
         */
        static branch(_branch) {
            if (_branch.nChildren > 0)
                Debug.group(_branch.name);
            else
                Debug.fudge(_branch.name);
            for (let child of _branch.getChildren())
                Debug.branch(child);
            if (_branch.nChildren > 0)
                Debug.groupEnd();
        }
        /**
         * Displays messages about the source of the debug call
         */
        static source(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.SOURCE, _message, _args);
        }
        /**
         * Lookup all delegates registered to the filter and call them using the given arguments
         */
        static delegate(_filter, _message, _args) {
            if (_filter == FudgeCore.DEBUG_FILTER.LOG || _filter == FudgeCore.DEBUG_FILTER.WARN || _filter == FudgeCore.DEBUG_FILTER.ERROR) {
                if (Debug.delegates[FudgeCore.DEBUG_FILTER.SOURCE])
                    for (let delegate of Debug.delegates[FudgeCore.DEBUG_FILTER.SOURCE].values())
                        if (delegate) {
                            let trace = new Error("Test").stack.split("\n");
                            delegate(trace[3]);
                        }
            }
            let delegates = Debug.delegates[_filter];
            for (let delegate of delegates.values())
                if (delegate)
                    if (_args && _args.length > 0)
                        delegate(_message, ..._args);
                    else
                        delegate(_message);
        }
        /**
         * setup routing to standard console
         */
        static setupConsole() {
            let result = {};
            let filters = [
                FudgeCore.DEBUG_FILTER.INFO, FudgeCore.DEBUG_FILTER.LOG, FudgeCore.DEBUG_FILTER.WARN, FudgeCore.DEBUG_FILTER.ERROR, FudgeCore.DEBUG_FILTER.FUDGE,
                FudgeCore.DEBUG_FILTER.CLEAR, FudgeCore.DEBUG_FILTER.GROUP, FudgeCore.DEBUG_FILTER.GROUPCOLLAPSED, FudgeCore.DEBUG_FILTER.GROUPEND,
                FudgeCore.DEBUG_FILTER.SOURCE
            ];
            for (let filter of filters)
                result[filter] = new Map([[FudgeCore.DebugConsole, FudgeCore.DebugConsole.delegates[filter]]]);
            result[FudgeCore.DEBUG_FILTER.SOURCE].delete(FudgeCore.DebugConsole);
            return result;
        }
    }
    /**
     * For each set filter, this associative array keeps references to the registered delegate functions of the chosen {@link DebugTarget}s
     */
    Debug.delegates = Debug.setupConsole();
    FudgeCore.Debug = Debug;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    // export type EventListener∆í = ((_event: Event∆í) => void) | EventListener | EventListenerObject;
    class EventTarget∆í extends EventTarget {
        addEventListener(_type, _handler, _options) {
            super.addEventListener(_type, _handler, _options);
        }
        removeEventListener(_type, _handler, _options) {
            super.removeEventListener(_type, _handler, _options);
        }
        dispatchEvent(_event) {
            return super.dispatchEvent(_event);
        }
    }
    FudgeCore.EventTarget∆í = EventTarget∆í;
    /**
     * Base class for EventTarget singletons, which are fixed entities in the structure of Fudge, such as the core loop
     */
    class EventTargetStatic extends EventTarget∆í {
        constructor() {
            super();
        }
        static addEventListener(_type, _handler) {
            EventTargetStatic.targetStatic.addEventListener(_type, _handler);
        }
        static removeEventListener(_type, _handler) {
            EventTargetStatic.targetStatic.removeEventListener(_type, _handler);
        }
        static dispatchEvent(_event) {
            EventTargetStatic.targetStatic.dispatchEvent(_event);
            return true;
        }
    }
    EventTargetStatic.targetStatic = new EventTargetStatic();
    FudgeCore.EventTargetStatic = EventTargetStatic;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    // export interface MutatorForComponent extends Mutator { readonly forUserComponent: null; }
    /**
     * Collect applicable attributes of the instance and copies of their values in a Mutator-object
     */
    function getMutatorOfArbitrary(_object) {
        let mutator = {};
        let attributes = Reflect.ownKeys(Reflect.getPrototypeOf(_object));
        for (let attribute of attributes) {
            let value = Reflect.get(_object, attribute);
            if (value instanceof Function)
                continue;
            // if (value instanceof Object && !(value instanceof Mutable))
            //   continue;
            mutator[attribute.toString()] = value;
        }
        return mutator;
    }
    FudgeCore.getMutatorOfArbitrary = getMutatorOfArbitrary;
    /**
     * Base class for all types being mutable using {@link Mutator}-objects, thus providing and using interfaces created at runtime.
     * Mutables provide a {@link Mutator} that is build by collecting all object-properties that are either of a primitive type or again Mutable.
     * Subclasses can either reduce the standard {@link Mutator} built by this base class by deleting properties or implement an individual getMutator-method.
     * The provided properties of the {@link Mutator} must match public properties or getters/setters of the object.
     * Otherwise, they will be ignored if not handled by an override of the mutate-method in the subclass and throw errors in an automatically generated user-interface for the object.
     */
    class Mutable extends FudgeCore.EventTarget∆í {
        /**
         * Decorator allows to attach {@link Mutable} functionality to existing classes.
         */
        // public static decorate(_constructor: Function): void {
        //   Object.defineProperty(_constructor.prototype, "useRenderData", {
        //     value: function getMutator(this: MutableForUserInterface): Mutator {
        //       return getMutatorOfArbitrary(this);
        //     }
        //   });
        // }
        /**
         * Retrieves the type of this mutable subclass as the name of the runtime class
         * @returns The type of the mutable
         */
        get type() {
            return this.constructor.name;
        }
        /**
         * Collect applicable attributes of the instance and copies of their values in a Mutator-object.
         * By default, a mutator cannot be extended, since extensions are not available in the object the mutator belongs to.
         * A mutator may be reduced by the descendants of {@link Mutable} to contain only the properties needed.
         */
        getMutator(_extendable = false) {
            let mutator = {};
            // collect primitive and mutable attributes
            for (let attribute in this) {
                let value = this[attribute];
                if (value instanceof Function)
                    continue;
                if (value instanceof Object && !(value instanceof Mutable) && !(value instanceof FudgeCore.MutableArray) && !(value.hasOwnProperty("idResource")))
                    continue;
                mutator[attribute] = this[attribute];
            }
            if (!_extendable)
                // mutator can be reduced but not extended!
                Object.preventExtensions(mutator);
            // delete unwanted attributes
            this.reduceMutator(mutator);
            // replace references to mutable objects with references to mutators
            for (let attribute in mutator) {
                let value = mutator[attribute];
                if (value instanceof Mutable)
                    mutator[attribute] = value.getMutator();
                if (value instanceof FudgeCore.MutableArray)
                    mutator[attribute] = value.map((_value) => _value.getMutator());
            }
            return mutator;
        }
        /**
         * Collect the attributes of the instance and their values applicable for animation.
         * Basic functionality is identical to {@link getMutator}, returned mutator should then be reduced by the subclassed instance
         */
        getMutatorForAnimation() {
            return this.getMutator();
        }
        /**
         * Collect the attributes of the instance and their values applicable for the user interface.
         * Basic functionality is identical to {@link getMutator}, returned mutator should then be reduced by the subclassed instance
         */
        getMutatorForUserInterface() {
            return this.getMutator();
        }
        /**
         * Collect the attributes of the instance and their values applicable for indiviualization by the component.
         * Basic functionality is identical to {@link getMutator}, returned mutator should then be reduced by the subclassed instance
         */
        // public getMutatorForComponent(): MutatorForComponent {
        //     return <MutatorForComponent>this.getMutator();
        // }
        /**
         * Returns an associative array with the same attributes as the given mutator, but with the corresponding types as string-values
         * Does not recurse into objects!
         */
        getMutatorAttributeTypes(_mutator) {
            let types = {};
            for (let attribute in _mutator) {
                let type = null;
                let value = _mutator[attribute];
                if (_mutator[attribute] != undefined)
                    if (typeof (value) == "object")
                        type = this[attribute].constructor.name;
                    else if (typeof (value) == "function")
                        type = value["name"];
                    else
                        type = _mutator[attribute].constructor.name;
                types[attribute] = type;
            }
            return types;
        }
        /**
         * Updates the values of the given mutator according to the current state of the instance
         * @param _mutator
         */
        updateMutator(_mutator) {
            for (let attribute in _mutator) {
                let value = _mutator[attribute];
                if (value instanceof Mutable)
                    _mutator[attribute] = value.getMutator();
                else
                    _mutator[attribute] = this[attribute];
            }
        }
        /**
         * Updates the attribute values of the instance according to the state of the mutator. Must be protected...!
         * @param _mutator
         */
        async mutate(_mutator) {
            for (let attribute in _mutator) {
                if (!Reflect.has(this, attribute))
                    continue;
                let mutant = Reflect.get(this, attribute);
                let value = _mutator[attribute];
                if (mutant instanceof FudgeCore.MutableArray || mutant instanceof Mutable)
                    await mutant.mutate(value);
                else
                    Reflect.set(this, attribute, value);
            }
            this.dispatchEvent(new Event("mutate" /* MUTATE */));
        }
    }
    FudgeCore.Mutable = Mutable;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Handles the external serialization and deserialization of {@link Serializable} objects. The internal process is handled by the objects themselves.
     * A {@link Serialization} object can be created from a {@link Serializable} object and a JSON-String may be created from that.
     * Vice versa, a JSON-String can be parsed to a {@link Serialization} which can be deserialized to a {@link Serializable} object.
     * ```plaintext
     *  [Serializable] ‚Üí (serialize) ‚Üí [Serialization] ‚Üí (stringify) ‚Üí [String] ‚Üí (save or send)
     *                                        ‚Üì                            ‚Üì                  ‚Üì
     *                [Serializable] ‚Üê (deserialize) ‚Üê [Serialization] ‚Üê (parse) ‚Üê (load) ‚Üê [Medium]
     * ```
     * While the internal serialize/deserialize method1s of the objects care of the selection of information needed to recreate the object and its structure,
     * the {@link Serializer} keeps track of the namespaces and classes in order to recreate {@link Serializable} objects. The general structure of a {@link Serialization} is as follows
     * ```plaintext
     * {
     *      namespaceName.className: {
     *          propertyName: propertyValue,
     *          ...,
     *          propertyNameOfReference: SerializationOfTheReferencedObject,
     *          ...,
     *          constructorNameOfSuperclass: SerializationOfSuperClass
     *      }
     * }
     * ```
     * Since the instance of the superclass is created automatically when an object is created,
     * the SerializationOfSuperClass omits the the namespaceName.className key and consists only of its value.
     * The constructorNameOfSuperclass is given instead as a property name in the serialization of the subclass.
     */
    class Serializer {
        /**
         * Registers a namespace to the {@link Serializer}, to enable automatic instantiation of classes defined within
         * @param _namespace
         */
        static registerNamespace(_namespace) {
            for (let name in Serializer.namespaces)
                if (Serializer.namespaces[name] == _namespace)
                    return name;
            let name = Serializer.findNamespaceIn(_namespace, window);
            if (!name)
                for (let parentName in Serializer.namespaces) {
                    name = Serializer.findNamespaceIn(_namespace, Serializer.namespaces[parentName]);
                    if (name) {
                        name = parentName + "." + name;
                        break;
                    }
                }
            if (!name)
                throw new Error("Namespace not found. Maybe parent namespace hasn't been registered before?");
            Serializer.namespaces[name] = _namespace;
            return name;
        }
        /**
         * Returns a javascript object representing the serializable FUDGE-object given,
         * including attached components, children, superclass-objects all information needed for reconstruction
         * @param _object An object to serialize, implementing the {@link Serializable} interface
         */
        static serialize(_object) {
            let serialization = {};
            // TODO: save the namespace with the constructors name
            // serialization[_object.constructor.name] = _object.serialize();
            let path = this.getFullPath(_object);
            if (!path)
                throw new Error(`Namespace of serializable object of type ${_object.constructor.name} not found. Maybe the namespace hasn't been registered or the class not exported?`);
            serialization[path] = _object.serialize();
            return serialization;
            // return _object.serialize();
        }
        /**
         * Returns a FUDGE-object reconstructed from the information in the {@link Serialization} given,
         * including attached components, children, superclass-objects
         * @param _serialization
         */
        static async deserialize(_serialization) {
            let reconstruct;
            let path;
            try {
                // loop constructed solely to access type-property. Only one expected!
                for (path in _serialization) {
                    // reconstruct = new (<General>Fudge)[typeName];
                    reconstruct = Serializer.reconstruct(path);
                    reconstruct = await reconstruct.deserialize(_serialization[path]);
                    return reconstruct;
                }
            }
            catch (_error) {
                throw new Error(`Deserialization of ${path} failed: ` + _error);
            }
            return null;
        }
        /**
         * Returns an Array of javascript object representing the serializable FUDGE-objects given in the array,
         * including attached components, children, superclass-objects all information needed for reconstruction
         * @param _object An object to serialize, implementing the {@link Serializable} interface
         */
        static serializeArray(_type, _objects) {
            let serializations = [];
            let path = this.getFullPath(new _type());
            if (!path)
                throw new Error(`Namespace of serializable object of type ${_type.name} not found. Maybe the namespace hasn't been registered or the class not exported?`);
            for (let object of _objects)
                serializations.push(object.serialize());
            let serialization = {};
            serialization[path] = serializations;
            return serialization;
        }
        /**
         * Returns an Array of FUDGE-objects reconstructed from the information in the array of {@link Serialization}s given,
         * including attached components, children, superclass-objects
         * @param _serializations
         */
        static async deserializeArray(_serialization) {
            let serializables = [];
            let construct;
            let serializations = [];
            try {
                // loop constructed solely to access type-property. Only one expected!
                for (let path in _serialization) {
                    construct = Serializer.getConstructor(path);
                    serializations = _serialization[path];
                    break;
                }
            }
            catch (_error) {
                throw new Error("Deserialization failed: " + _error);
            }
            for (let serialization of serializations) {
                let serializable = new construct();
                await serializable.deserialize(serialization);
                serializables.push(serializable);
            }
            return serializables;
        }
        //TODO: implement prettifier to make JSON-Stringification of serializations more readable, e.g. placing x, y and z in one line
        static prettify(_json) { return _json; }
        /**
         * Returns a formatted, human readable JSON-String, representing the given {@link Serialization} that may have been created by {@link Serializer}.serialize
         * @param _serialization
         */
        static stringify(_serialization) {
            // adjustments to serialization can be made here before stringification, if desired
            let json = JSON.stringify(_serialization, null, 2);
            let pretty = Serializer.prettify(json);
            return pretty;
        }
        /**
         * Returns a {@link Serialization} created from the given JSON-String. Result may be passed to {@link Serializer.deserialize}
         * @param _json
         */
        static parse(_json) {
            return JSON.parse(_json);
        }
        /**
         * Creates an object of the class defined with the full path including the namespaceName(s) and the className seperated by dots(.)
         * @param _path
         */
        static reconstruct(_path) {
            let constructor = Serializer.getConstructor(_path);
            let reconstruction = new constructor();
            return reconstruction;
        }
        // public static getConstructor<T extends Serializable>(_type: string, _namespace: Object = FudgeCore): new () => T {
        static getConstructor(_path) {
            let typeName = _path.substr(_path.lastIndexOf(".") + 1);
            let namespace = Serializer.getNamespace(_path);
            if (!namespace)
                throw new Error(`Constructor of serializable object of type ${_path} not found. Maybe the namespace hasn't been registered?`);
            return namespace[typeName];
        }
        /**
         * Returns the full path to the class of the object, if found in the registered namespaces
         * @param _object
         */
        static getFullPath(_object) {
            let typeName = _object.constructor.name;
            // Debug.log("Searching namespace of: " + typeName);
            for (let namespaceName in Serializer.namespaces) {
                let found = Serializer.namespaces[namespaceName][typeName];
                if (found && _object instanceof found)
                    return namespaceName + "." + typeName;
            }
            return null;
        }
        /**
         * Returns the namespace-object defined within the full path, if registered
         * @param _path
         */
        static getNamespace(_path) {
            let namespaceName = _path.substr(0, _path.lastIndexOf("."));
            return Serializer.namespaces[namespaceName] || FudgeCore;
        }
        /**
         * Finds the namespace-object in properties of the parent-object (e.g. window), if present
         * @param _namespace
         * @param _parent
         */
        static findNamespaceIn(_namespace, _parent) {
            for (let prop in _parent)
                if (_parent[prop] == _namespace)
                    return prop;
            return null;
        }
    }
    /** In order for the Serializer to create class instances, it needs access to the appropriate namespaces */
    Serializer.namespaces = { "∆í": FudgeCore };
    FudgeCore.Serializer = Serializer;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="../Transfer/Serializer.ts"/>
// / <reference path="../Transfer/Mutable.ts"/>
var FudgeCore;
// / <reference path="../Transfer/Serializer.ts"/>
// / <reference path="../Transfer/Mutable.ts"/>
(function (FudgeCore) {
    /**
     * Superclass for all {@link Component}s that can be attached to {@link Node}s.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2020 | Jascha Karag√∂l, HFU, 2019
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Component
     */
    class Component extends FudgeCore.Mutable {
        constructor() {
            super(...arguments);
            this.#node = null;
            this.singleton = true;
            this.active = true;
            //#endregion
        }
        #node;
        static registerSubclass(_subclass) { return Component.subclasses.push(_subclass) - 1; }
        get isActive() {
            return this.active;
        }
        /**
         * Is true, when only one instance of the component class can be attached to a node
         */
        get isSingleton() {
            return this.singleton;
        }
        /**
         * Retrieves the node, this component is currently attached to
         */
        get node() {
            return this.#node;
        }
        activate(_on) {
            this.active = _on;
            this.dispatchEvent(new Event(_on ? "componentActivate" /* COMPONENT_ACTIVATE */ : "componentDeactivate" /* COMPONENT_DEACTIVATE */));
        }
        /**
         * Tries to attach the component to the given node, removing it from the node it was attached to if applicable
         */
        attachToNode(_container) {
            if (this.#node == _container)
                return;
            let previousContainer = this.#node;
            try {
                if (previousContainer)
                    previousContainer.removeComponent(this);
                this.#node = _container;
                if (this.#node)
                    this.#node.addComponent(this);
            }
            catch (_error) {
                this.#node = previousContainer;
            }
        }
        //#region Transfer
        serialize() {
            let serialization = {
                active: this.active
            };
            return serialization;
        }
        async deserialize(_serialization) {
            this.activate(_serialization.active);
            return this;
        }
        async mutate(_mutator) {
            this.activate(_mutator.active);
            super.mutate(_mutator);
        }
        reduceMutator(_mutator) {
            delete _mutator.singleton;
            delete _mutator.mtxWorld;
        }
    }
    /** refers back to this class from any subclass e.g. in order to find compatible other resources*/
    Component.baseClass = Component;
    /** list of all the subclasses derived from this class, if they registered properly*/
    Component.subclasses = [];
    FudgeCore.Component = Component;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Wraps a regular Javascript Array and offers very limited functionality geared solely towards avoiding garbage colletion.
     */
    class RecycableArray {
        constructor() {
            this.#length = 0;
            this.#array = new Array();
        }
        #length;
        #array;
        // #type: new () => T;
        // //tslint:disable-next-line:no-any
        // constructor(_type: new (...args: any[]) => T) {
        //   this.#type = _type;
        // }
        get length() {
            return this.#length;
        }
        /**
         * Sets the virtual length of the array to zero but keeps the entries beyond.
         */
        reset() {
            this.#length = 0;
        }
        push(_entry) {
            this.#array[this.#length] = _entry;
            this.#length++;
            return this.#length;
        }
        pop() {
            this.#length--;
            return this.#array[this.#length];
        }
        /**
         * Recycles the object following the last in the array and increases the array length
         * It must be assured, that none of the objects in the array is still in any use of any kind!
         */
        // public recycle(): T {
        //   if (this.#length < this.#array.length) {
        //     this.#length++;
        //     return this.#array[this.#length++];
        //   }
        //   this.#array.push(Recycler.get(this.#type));
        //   return this.#array[this.#length++];
        // }
        *[Symbol.iterator]() {
            for (let i = 0; i < this.#length; i++)
                yield this.#array[i];
        }
        getSorted(_sort) {
            let sorted = this.#array.slice(0, this.#length);
            sorted.sort(_sort);
            return sorted;
        }
    }
    FudgeCore.RecycableArray = RecycableArray;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    //Baseclass for {@link RenderInjectorCoat} and {@link RenderInjectorTexture]]
    class RenderInjector {
        static inject(_constructor, _injector) {
            let injection = Reflect.get(_injector, "inject" + _constructor.name);
            if (!injection) {
                FudgeCore.Debug.error("No injection decorator defined for " + _constructor.name);
            }
            Object.defineProperty(_constructor.prototype, "useRenderData", {
                value: injection
            });
        }
    }
    FudgeCore.RenderInjector = RenderInjector;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    //gives WebGL Buffer the data from the {@link Shader}
    class RenderInjectorShader {
        static decorate(_constructor) {
            Object.defineProperty(_constructor, "useProgram", {
                value: RenderInjectorShader.useProgram
            });
            Object.defineProperty(_constructor, "deleteProgram", {
                value: RenderInjectorShader.deleteProgram
            });
            Object.defineProperty(_constructor, "createProgram", {
                value: RenderInjectorShader.createProgram
            });
        }
        static useProgram() {
            if (!this.program)
                this.createProgram();
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            crc3.useProgram(this.program);
        }
        static deleteProgram() {
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            if (this.program) {
                crc3.deleteProgram(this.program);
                delete this.attributes;
                delete this.uniforms;
            }
        }
        static createProgram() {
            FudgeCore.Debug.fudge("Create shader program", this.name);
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            let program = crc3.createProgram();
            try {
                let shdVertex = compileShader(this.getVertexShaderSource(), WebGL2RenderingContext.VERTEX_SHADER);
                let shdFragment = compileShader(this.getFragmentShaderSource(), WebGL2RenderingContext.FRAGMENT_SHADER);
                crc3.attachShader(program, FudgeCore.RenderWebGL.assert(shdVertex));
                crc3.attachShader(program, FudgeCore.RenderWebGL.assert(shdFragment));
                crc3.linkProgram(program);
                let error = FudgeCore.RenderWebGL.assert(crc3.getProgramInfoLog(program));
                if (error !== "") {
                    throw new Error("Error linking Shader: " + error);
                }
                this.program = program;
                this.attributes = detectAttributes();
                this.uniforms = detectUniforms();
            }
            catch (_error) {
                FudgeCore.Debug.error(_error);
                debugger;
            }
            function compileShader(_shaderCode, _shaderType) {
                let webGLShader = crc3.createShader(_shaderType);
                crc3.shaderSource(webGLShader, _shaderCode);
                crc3.compileShader(webGLShader);
                let error = FudgeCore.RenderWebGL.assert(crc3.getShaderInfoLog(webGLShader));
                if (error !== "") {
                    throw new Error("Error compiling shader: " + error);
                }
                // Check for any compilation errors.
                if (!crc3.getShaderParameter(webGLShader, WebGL2RenderingContext.COMPILE_STATUS)) {
                    alert(crc3.getShaderInfoLog(webGLShader));
                    return null;
                }
                return webGLShader;
            }
            function detectAttributes() {
                let detectedAttributes = {};
                let attributeCount = crc3.getProgramParameter(program, WebGL2RenderingContext.ACTIVE_ATTRIBUTES);
                for (let i = 0; i < attributeCount; i++) {
                    let attributeInfo = FudgeCore.RenderWebGL.assert(crc3.getActiveAttrib(program, i));
                    if (!attributeInfo) {
                        break;
                    }
                    detectedAttributes[attributeInfo.name] = crc3.getAttribLocation(program, attributeInfo.name);
                }
                return detectedAttributes;
            }
            function detectUniforms() {
                let detectedUniforms = {};
                let uniformCount = crc3.getProgramParameter(program, WebGL2RenderingContext.ACTIVE_UNIFORMS);
                for (let i = 0; i < uniformCount; i++) {
                    let info = FudgeCore.RenderWebGL.assert(crc3.getActiveUniform(program, i));
                    if (!info) {
                        break;
                    }
                    detectedUniforms[info.name] = FudgeCore.RenderWebGL.assert(crc3.getUniformLocation(program, info.name));
                }
                return detectedUniforms;
            }
        }
    }
    FudgeCore.RenderInjectorShader = RenderInjectorShader;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    //gives WebGL Buffer the data from the {@link Coat}
    class RenderInjectorCoat extends FudgeCore.RenderInjector {
        static decorate(_constructor) {
            FudgeCore.RenderInjector.inject(_constructor, RenderInjectorCoat);
        }
        static injectCoatColored(_shader, _cmpMaterial) {
            let colorUniformLocation = _shader.uniforms["u_vctColor"];
            let color = FudgeCore.Color.MULTIPLY(this.color, _cmpMaterial.clrPrimary);
            FudgeCore.RenderWebGL.getRenderingContext().uniform4fv(colorUniformLocation, color.getArray());
            let shininessUniformLocation = _shader.uniforms["u_fShininess"];
            let shininess = this.shininess;
            FudgeCore.RenderWebGL.getRenderingContext().uniform1f(shininessUniformLocation, shininess);
        }
        static injectCoatTextured(_shader, _cmpMaterial) {
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            Reflect.apply(RenderInjectorCoat.injectCoatColored, this, [_shader, _cmpMaterial]);
            this.texture.useRenderData();
            crc3.uniform1i(_shader.uniforms["u_texture"], 0);
            crc3.uniformMatrix3fv(_shader.uniforms["u_mtxPivot"], false, _cmpMaterial.mtxPivot.get());
        }
    }
    FudgeCore.RenderInjectorCoat = RenderInjectorCoat;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    //gives WebGL Buffer the data from the {@link Mesh]]
    class RenderInjectorMesh {
        static decorate(_constructor) {
            Object.defineProperty(_constructor.prototype, "useRenderBuffers", {
                value: RenderInjectorMesh.useRenderBuffers
            });
            Object.defineProperty(_constructor.prototype, "createRenderBuffers", {
                value: RenderInjectorMesh.createRenderBuffers
            });
            Object.defineProperty(_constructor.prototype, "deleteRenderBuffers", {
                value: RenderInjectorMesh.deleteRenderBuffers
            });
        }
        static createRenderBuffers() {
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            function createBuffer(_type, _array) {
                let buffer = FudgeCore.RenderWebGL.assert(crc3.createBuffer());
                crc3.bindBuffer(_type, buffer);
                crc3.bufferData(_type, _array, WebGL2RenderingContext.STATIC_DRAW);
                return buffer;
            }
            let vertices = createBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.vertices);
            let indices = createBuffer(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, this.indices);
            let normalsVertex = createBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.normalsVertex);
            let textureUVs = createBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.textureUVs);
            let verticesFlat = createBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.verticesFlat);
            let indicesFlat = createBuffer(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, this.indicesFlat);
            let normalsFlat = createBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.normalsFlat);
            let textureUVsFlat = createBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.textureUVsFlat);
            let renderBuffers = {
                //smooth
                vertices: vertices,
                indices: indices,
                textureUVs: textureUVs,
                normalsVertex: normalsVertex,
                // flat
                verticesFlat: verticesFlat,
                indicesFlat: indicesFlat,
                normalsFlat: normalsFlat,
                textureUVsFlat: textureUVsFlat
            };
            this.renderBuffers = renderBuffers;
        }
        static useRenderBuffers(_shader, _mtxMeshToWorld, _mtxMeshToView, _id) {
            if (!this.renderBuffers)
                this.createRenderBuffers();
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            function setBuffer(_name, _buffer) {
                let attribute = _shader.attributes[_name];
                if (attribute == undefined)
                    return;
                crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, _buffer);
                crc3.enableVertexAttribArray(attribute);
                FudgeCore.RenderWebGL.setAttributeStructure(attribute, { size: 3, dataType: WebGL2RenderingContext.FLOAT, normalize: false, stride: 0, offset: 0 });
            }
            let uProjection = _shader.uniforms["u_mtxMeshToView"];
            crc3.uniformMatrix4fv(uProjection, false, _mtxMeshToView.get());
            let uWorld = _shader.uniforms["u_mtxMeshToWorld"];
            if (uWorld) {
                // let mtxWorld: Matrix4x4 = _mtxMeshToWorld.clone;
                // mtxWorld.translation = Vector3.ZERO();
                crc3.uniformMatrix4fv(uWorld, false, _mtxMeshToWorld.get());
            }
            let uNormal = _shader.uniforms["u_mtxNormalMeshToWorld"];
            if (uNormal) {
                let normalMatrix = FudgeCore.Matrix4x4.TRANSPOSE(FudgeCore.Matrix4x4.INVERSION(_mtxMeshToWorld));
                crc3.uniformMatrix4fv(uNormal, false, normalMatrix.get());
            }
            setBuffer("a_vctPosition", this.renderBuffers.vertices);
            setBuffer("a_vctPositionFlat", this.renderBuffers.verticesFlat);
            setBuffer("a_vctNormalFace", this.renderBuffers.normalsFlat);
            setBuffer("a_vctNormalVertex", this.renderBuffers.normalsVertex);
            // feed in texture coordinates if shader accepts a_vctTexture
            let aTextureUVs = _shader.attributes["a_vctTexture"];
            if (aTextureUVs) {
                if (_shader == FudgeCore.ShaderFlatTextured)
                    crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.renderBuffers.textureUVsFlat);
                else
                    crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.renderBuffers.textureUVs);
                crc3.enableVertexAttribArray(aTextureUVs); // enable the buffer
                crc3.vertexAttribPointer(aTextureUVs, 2, WebGL2RenderingContext.FLOAT, false, 0, 0);
            }
            // feed in an id of the node if shader accepts u_id. Used for picking
            let uId = _shader.uniforms["u_id"];
            if (uId)
                FudgeCore.RenderWebGL.getRenderingContext().uniform1i(uId, _id);
            if (_shader == FudgeCore.ShaderFlat || _shader == FudgeCore.ShaderFlatTextured) {
                crc3.bindBuffer(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, this.renderBuffers.indicesFlat);
                return this.indicesFlat.length;
            }
            crc3.bindBuffer(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, this.renderBuffers.indices);
            return this.indices.length;
        }
        static deleteRenderBuffers(_renderBuffers) {
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            if (_renderBuffers) {
                // TODO: cleanup all buffers, flat/normals is missing...
                crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, null);
                crc3.deleteBuffer(_renderBuffers.vertices);
                crc3.deleteBuffer(_renderBuffers.textureUVs);
                crc3.bindBuffer(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, null);
                crc3.deleteBuffer(_renderBuffers.indices);
            }
        }
    }
    FudgeCore.RenderInjectorMesh = RenderInjectorMesh;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Keeps a depot of objects that have been marked for reuse, sorted by type.
     * Using {@link Recycler} reduces load on the carbage collector and thus supports smooth performance
     */
    class Recycler {
        /**
         * Fetches an object of the requested type from the depot, calls its recycle-method and returns it.
         * If the depot for that type is empty it returns a new object of the requested type
         * @param _T The class identifier of the desired object
         */
        static get(_T) {
            let key = _T.name;
            let instances = Recycler.depot[key];
            if (instances && instances.length > 0) {
                let instance = instances.pop();
                instance.recycle();
                return instance;
            }
            else
                return new _T();
        }
        /**
         * Returns a reference to an object of the requested type in the depot, but does not remove it there.
         * If no object of the requested type was in the depot, one is created, stored and borrowed.
         * For short term usage of objects in a local scope, when there will be no other call to Recycler.get or .borrow!
         * @param _T The class identifier of the desired object
         */
        static borrow(_T) {
            let t;
            let key = _T.name;
            let instances = Recycler.depot[key];
            if (!instances || instances.length == 0) {
                t = new _T();
                Recycler.store(t);
                return t;
            }
            let instance = instances[0];
            instance.recycle();
            return instance;
        }
        /**
         * Stores the object in the depot for later recycling. Users are responsible for throwing in objects that are about to loose scope and are not referenced by any other
         * @param _instance
         */
        static store(_instance) {
            let key = _instance.constructor.name;
            //Debug.log(key);
            let instances = Recycler.depot[key] || [];
            instances.push(_instance);
            Recycler.depot[key] = instances;
            // Debug.log(`ObjectManager.depot[${key}]: ${ObjectManager.depot[key].length}`);
            //Debug.log(this.depot);
        }
        /**
         * Emptys the depot of a given type, leaving the objects for the garbage collector. May result in a short stall when many objects were in
         * @param _T
         */
        static dump(_T) {
            let key = _T.name;
            Recycler.depot[key] = [];
        }
        /**
         * Emptys all depots, leaving all objects to the garbage collector. May result in a short stall when many objects were in
         */
        static dumpAll() {
            Recycler.depot = {};
        }
    }
    Recycler.depot = {};
    FudgeCore.Recycler = Recycler;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Stores and manipulates a twodimensional vector comprised of the components x and y
     * ```plaintext
     *            +y
     *             |__ +x
     * ```
     * @authors Lukas Scheuerle, Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Vector2 extends FudgeCore.Mutable {
        constructor(_x = 0, _y = 0) {
            super();
            this.data = new Float32Array([_x, _y]);
        }
        //#region Static
        /**
         * A shorthand for writing `new Vector2(0, 0)`.
         * @returns A new vector with the values (0, 0)
         */
        static ZERO() {
            const vector = FudgeCore.Recycler.get(Vector2);
            vector.set(0, 0);
            return vector;
        }
        /**
         * A shorthand for writing `new Vector2(_scale, _scale)`.
         * @param _scale the scale of the vector. Default: 1
         */
        static ONE(_scale = 1) {
            const vector = FudgeCore.Recycler.get(Vector2);
            vector.set(_scale, _scale);
            return vector;
        }
        /**
         * A shorthand for writing `new Vector2(0, y)`.
         * @param _scale The number to write in the y coordinate. Default: 1
         * @returns A new vector with the values (0, _scale)
         */
        static Y(_scale = 1) {
            const vector = FudgeCore.Recycler.get(Vector2);
            vector.set(0, _scale);
            return vector;
        }
        /**
         * A shorthand for writing `new Vector2(x, 0)`.
         * @param _scale The number to write in the x coordinate. Default: 1
         * @returns A new vector with the values (_scale, 0)
         */
        static X(_scale = 1) {
            const vector = FudgeCore.Recycler.get(Vector2);
            vector.set(_scale, 0);
            return vector;
        }
        static TRANSFORMATION(_vector, _mtxTransform, _includeTranslation = true) {
            let result = FudgeCore.Recycler.get(Vector2);
            let m = _mtxTransform.get();
            let [x, y] = _vector.get();
            result.x = m[0] * x + m[3] * y;
            result.y = m[1] * x + m[4] * y;
            if (_includeTranslation) {
                result.add(_mtxTransform.translation);
            }
            return result;
        }
        /**
         * Normalizes a given vector to the given length without editing the original vector.
         * @param _vector the vector to normalize
         * @param _length the length of the resulting vector. defaults to 1
         * @returns a new vector representing the normalised vector scaled by the given length
         */
        static NORMALIZATION(_vector, _length = 1) {
            let vector = Vector2.ZERO();
            try {
                let [x, y] = _vector.data;
                let factor = _length / Math.hypot(x, y);
                vector.set(_vector.x * factor, _vector.y * factor);
            }
            catch (_error) {
                FudgeCore.Debug.warn(_error);
            }
            return vector;
        }
        /**
         * Returns a new vector representing the given vector scaled by the given scaling factor
         */
        static SCALE(_vector, _scale) {
            let vector = FudgeCore.Recycler.get(Vector2);
            vector.set(_vector.x * _scale, _vector.y * _scale);
            return vector;
        }
        /**
         * Returns the resulting vector attained by addition of all given vectors.
         */
        static SUM(..._vectors) {
            let result = FudgeCore.Recycler.get(Vector2);
            for (let vector of _vectors)
                result.set(result.x + vector.x, result.y + vector.y);
            return result;
        }
        /**
         * Returns the result of the subtraction of two vectors.
         */
        static DIFFERENCE(_minuend, _subtrahend) {
            let vector = FudgeCore.Recycler.get(Vector2);
            vector.set(_minuend.x - _subtrahend.x, _minuend.y - _subtrahend.y);
            return vector;
        }
        /**
         * Computes the dotproduct of 2 vectors.
         */
        static DOT(_a, _b) {
            let scalarProduct = _a.x * _b.x + _a.y * _b.y;
            return scalarProduct;
        }
        /**
         * Calculates the cross product of two Vectors. Due to them being only 2 Dimensional, the result is a single number,
         * which implicitly is on the Z axis. It is also the signed magnitude of the result.
         * @param _a Vector to compute the cross product on
         * @param _b Vector to compute the cross product with
         * @returns A number representing result of the cross product.
         */
        static CROSS(_a, _b) {
            let crossProduct = _a.x * _b.y - _a.y * _b.x;
            return crossProduct;
        }
        /**
         * Calculates the orthogonal vector to the given vector. Rotates counterclockwise by default.
         * ```plaintext
         * ‚Üë => ‚Üê => ‚Üì => ‚Üí => ‚Üë
         * ```
         * @param _vector Vector to get the orthogonal equivalent of
         * @param _clockwise Should the rotation be clockwise instead of the default counterclockwise? default: false
         * @returns A Vector that is orthogonal to and has the same magnitude as the given Vector.
         */
        static ORTHOGONAL(_vector, _clockwise = false) {
            let result = FudgeCore.Recycler.get(Vector2);
            if (_clockwise)
                result.set(_vector.y, -_vector.x);
            else
                result.set(-_vector.y, _vector.x);
            return result;
        }
        /**
         * Creates a cartesian vector from polar coordinates
         */
        static GEO(_angle = 0, _magnitude = 1) {
            let vector = FudgeCore.Recycler.get(Vector2);
            let geo = FudgeCore.Recycler.get(FudgeCore.Geo2);
            geo.set(_angle, _magnitude);
            vector.geo = geo;
            FudgeCore.Recycler.store(geo);
            return vector;
        }
        //#endregion
        //#region Accessors
        get x() {
            return this.data[0];
        }
        get y() {
            return this.data[1];
        }
        set x(_x) {
            this.data[0] = _x;
        }
        set y(_y) {
            this.data[1] = _y;
        }
        /**
         * Returns the length of the vector
         */
        get magnitude() {
            return Math.hypot(...this.data);
        }
        /**
         * Returns the square of the magnitude of the vector without calculating a square root. Faster for simple proximity evaluation.
         */
        get magnitudeSquared() {
            return Vector2.DOT(this, this);
        }
        /**
         * @returns A deep copy of the vector.
         * TODO: rename this clone and create a new method copy, which copies the values from a vector given
         */
        get clone() {
            let clone = FudgeCore.Recycler.get(Vector2);
            clone.data.set(this.data);
            return clone;
        }
        /**
         * Returns a polar representation of this vector
         */
        get geo() {
            let geo = FudgeCore.Recycler.get(FudgeCore.Geo2);
            geo.magnitude = this.magnitude;
            if (geo.magnitude === 0)
                return geo;
            geo.angle = 180 * Math.atan2(this.y / geo.magnitude, this.x / geo.magnitude) / Math.PI;
            return geo;
        }
        /**
         * Adjust the cartesian values of this vector to represent the given as polar coordinates
         */
        set geo(_geo) {
            this.set(_geo.magnitude, 0);
            this.transform(FudgeCore.Matrix3x3.ROTATION(_geo.angle));
        }
        //#endregion
        recycle() {
            this.data.set([0, 0]);
        }
        /**
         * Returns true if the coordinates of this and the given vector are to be considered identical within the given tolerance
         * TODO: examine, if tolerance as criterium for the difference is appropriate with very large coordinate values or if _tolerance should be multiplied by coordinate value
         */
        equals(_compare, _tolerance = Number.EPSILON) {
            if (Math.abs(this.x - _compare.x) > _tolerance)
                return false;
            if (Math.abs(this.y - _compare.y) > _tolerance)
                return false;
            return true;
        }
        /**
         * Adds the given vector to the executing vector, changing the executor.
         * @param _addend The vector to add.
         */
        add(_addend) {
            this.data.set([_addend.x + this.x, _addend.y + this.y]);
        }
        /**
         * Subtracts the given vector from the executing vector, changing the executor.
         * @param _subtrahend The vector to subtract.
         */
        subtract(_subtrahend) {
            this.data.set([this.x - _subtrahend.x, this.y - _subtrahend.y]);
        }
        /**
         * Scales the Vector by the given _scalar.
         */
        scale(_scalar) {
            this.data.set([_scalar * this.x, _scalar * this.y]);
        }
        /**
         * Normalizes this to the given length, 1 by default
         */
        normalize(_length = 1) {
            this.data = Vector2.NORMALIZATION(this, _length).data;
        }
        /**
         * Defines the components of this vector with the given numbers
         */
        set(_x = 0, _y = 0) {
            this.data[0] = _x;
            this.data[1] = _y;
        }
        /**
         * @returns An array of the data of the vector
         */
        get() {
            return new Float32Array(this.data);
        }
        transform(_mtxTransform, _includeTranslation = true) {
            this.data = Vector2.TRANSFORMATION(this, _mtxTransform, _includeTranslation).data;
        }
        /**
         * For each dimension, moves the component to the minimum of this and the given vector
         */
        min(_compare) {
            this.x = Math.min(this.x, _compare.x);
            this.y = Math.min(this.y, _compare.y);
        }
        /**
         * For each dimension, moves the component to the maximum of this and the given vector
         */
        max(_compare) {
            this.x = Math.max(this.x, _compare.x);
            this.y = Math.max(this.y, _compare.y);
        }
        /**
         * Adds a z-component of the given magnitude (default=0) to the vector and returns a new Vector3
         */
        toVector3(_z = 0) {
            return new FudgeCore.Vector3(this.x, this.y, _z);
        }
        toString() {
            let result = `(${this.x.toPrecision(5)}, ${this.y.toPrecision(5)})`;
            return result;
        }
        //#region Transfer
        serialize() {
            let serialization = this.getMutator();
            // serialization.toJSON = () => { return `{ "r": ${this.r}, "g": ${this.g}, "b": ${this.b}, "a": ${this.a}}`; };
            serialization.toJSON = () => { return `[${this.x}, ${this.y}]`; };
            return serialization;
        }
        async deserialize(_serialization) {
            if (typeof (_serialization) == "string") {
                [this.x, this.y] = JSON.parse(_serialization);
            }
            else
                this.mutate(_serialization);
            return this;
        }
        getMutator() {
            let mutator = {
                x: this.data[0], y: this.data[1]
            };
            return mutator;
        }
        reduceMutator(_mutator) { }
    }
    FudgeCore.Vector2 = Vector2;
})(FudgeCore || (FudgeCore = {}));
///<reference path="../Recycle/Recycler.ts"/>
///<reference path="Vector2.ts"/>
var FudgeCore;
///<reference path="../Recycle/Recycler.ts"/>
///<reference path="Vector2.ts"/>
(function (FudgeCore) {
    /**
     * Defines the origin of a rectangle
     */
    let ORIGIN2D;
    (function (ORIGIN2D) {
        ORIGIN2D[ORIGIN2D["TOPLEFT"] = 0] = "TOPLEFT";
        ORIGIN2D[ORIGIN2D["TOPCENTER"] = 1] = "TOPCENTER";
        ORIGIN2D[ORIGIN2D["TOPRIGHT"] = 2] = "TOPRIGHT";
        ORIGIN2D[ORIGIN2D["CENTERLEFT"] = 16] = "CENTERLEFT";
        ORIGIN2D[ORIGIN2D["CENTER"] = 17] = "CENTER";
        ORIGIN2D[ORIGIN2D["CENTERRIGHT"] = 18] = "CENTERRIGHT";
        ORIGIN2D[ORIGIN2D["BOTTOMLEFT"] = 32] = "BOTTOMLEFT";
        ORIGIN2D[ORIGIN2D["BOTTOMCENTER"] = 33] = "BOTTOMCENTER";
        ORIGIN2D[ORIGIN2D["BOTTOMRIGHT"] = 34] = "BOTTOMRIGHT";
    })(ORIGIN2D = FudgeCore.ORIGIN2D || (FudgeCore.ORIGIN2D = {}));
    /**
     * Defines a rectangle with position and size and add comfortable methods to it
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Rectangle extends FudgeCore.Mutable {
        constructor(_x = 0, _y = 0, _width = 1, _height = 1, _origin = ORIGIN2D.TOPLEFT) {
            super();
            this.position = FudgeCore.Recycler.get(FudgeCore.Vector2);
            this.size = FudgeCore.Recycler.get(FudgeCore.Vector2);
            this.setPositionAndSize(_x, _y, _width, _height, _origin);
        }
        /**
         * Returns a new rectangle created with the given parameters
         */
        static GET(_x = 0, _y = 0, _width = 1, _height = 1, _origin = ORIGIN2D.TOPLEFT) {
            let rect = FudgeCore.Recycler.get(Rectangle);
            rect.setPositionAndSize(_x, _y, _width, _height);
            return rect;
        }
        get x() {
            return this.position.x;
        }
        get y() {
            return this.position.y;
        }
        get width() {
            return this.size.x;
        }
        get height() {
            return this.size.y;
        }
        /**
         * Return the leftmost expansion, respecting also negative values of width
         */
        get left() {
            if (this.size.x > 0)
                return this.position.x;
            return (this.position.x + this.size.x);
        }
        /**
         * Return the topmost expansion, respecting also negative values of height
         */
        get top() {
            if (this.size.y > 0)
                return this.position.y;
            return (this.position.y + this.size.y);
        }
        /**
         * Return the rightmost expansion, respecting also negative values of width
         */
        get right() {
            if (this.size.x > 0)
                return (this.position.x + this.size.x);
            return this.position.x;
        }
        /**
         * Return the lowest expansion, respecting also negative values of height
         */
        get bottom() {
            if (this.size.y > 0)
                return (this.position.y + this.size.y);
            return this.position.y;
        }
        set x(_x) {
            this.position.x = _x;
        }
        set y(_y) {
            this.position.y = _y;
        }
        set width(_width) {
            this.size.x = _width;
        }
        set height(_height) {
            this.size.y = _height;
        }
        set left(_value) {
            this.size.x = this.right - _value;
            this.position.x = _value;
        }
        set top(_value) {
            this.size.y = this.bottom - _value;
            this.position.y = _value;
        }
        set right(_value) {
            this.size.x = this.position.x + _value;
        }
        set bottom(_value) {
            this.size.y = this.position.y + _value;
        }
        get clone() {
            return Rectangle.GET(this.x, this.y, this.width, this.height);
        }
        recycle() {
            this.setPositionAndSize();
        }
        copy(_rect) {
            this.setPositionAndSize(_rect.x, _rect.y, _rect.width, _rect.height);
        }
        /**
         * Sets the position and size of the rectangle according to the given parameters
         */
        setPositionAndSize(_x = 0, _y = 0, _width = 1, _height = 1, _origin = ORIGIN2D.TOPLEFT) {
            this.size.set(_width, _height);
            switch (_origin & 0x03) {
                case 0x00:
                    this.position.x = _x;
                    break;
                case 0x01:
                    this.position.x = _x - _width / 2;
                    break;
                case 0x02:
                    this.position.x = _x - _width;
                    break;
            }
            switch (_origin & 0x30) {
                case 0x00:
                    this.position.y = _y;
                    break;
                case 0x10:
                    this.position.y = _y - _height / 2;
                    break;
                case 0x20:
                    this.position.y = _y - _height;
                    break;
            }
        }
        pointToRect(_point, _target) {
            let result = _point.clone;
            result.subtract(this.position);
            result.x *= _target.width / this.width;
            result.y *= _target.height / this.height;
            result.add(_target.position);
            return result;
        }
        /**
         * Returns true if the given point is inside of this rectangle or on the border
         * @param _point
         */
        isInside(_point) {
            return (_point.x >= this.left && _point.x <= this.right && _point.y >= this.top && _point.y <= this.bottom);
        }
        /**
         * Returns true if this rectangle collides with the rectangle given
         * @param _rect
         */
        collides(_rect) {
            if (this.left > _rect.right)
                return false;
            if (this.right < _rect.left)
                return false;
            if (this.top > _rect.bottom)
                return false;
            if (this.bottom < _rect.top)
                return false;
            return true;
        }
        /**
         * Returns the rectangle created by the intersection of this and the given rectangle or null, if they don't collide
         */
        getIntersection(_rect) {
            if (!this.collides(_rect))
                return null;
            let intersection = new Rectangle();
            intersection.x = Math.max(this.left, _rect.left);
            intersection.y = Math.max(this.top, _rect.top);
            intersection.width = Math.min(this.right, _rect.right) - intersection.x;
            intersection.height = Math.min(this.bottom, _rect.bottom) - intersection.y;
            return intersection;
        }
        /**
     * Returns the rectangle created by the intersection of this and the given rectangle or null, if they don't collide
     */
        covers(_rect) {
            if (this.left > _rect.left)
                return false;
            if (this.right < _rect.right)
                return false;
            if (this.top > _rect.top)
                return false;
            if (this.bottom < _rect.bottom)
                return false;
            return true;
        }
        /**
         * Creates a string representation of this rectangle
         */
        toString() {
            let result = `∆í.Rectangle(position:${this.position.toString()}, size:${this.size.toString()}`;
            result += `, left:${this.left.toPrecision(5)}, top:${this.top.toPrecision(5)}, right:${this.right.toPrecision(5)}, bottom:${this.bottom.toPrecision(5)}`;
            return result;
        }
        reduceMutator(_mutator) { }
    }
    FudgeCore.Rectangle = Rectangle;
})(FudgeCore || (FudgeCore = {}));
///<reference path="RenderInjector.ts"/>
///<reference path="RenderInjectorShader.ts"/>
///<reference path="RenderInjectorCoat.ts"/>
///<reference path="RenderInjectorMesh.ts"/>
///<reference path="../Math/Rectangle.ts"/>
var FudgeCore;
///<reference path="RenderInjector.ts"/>
///<reference path="RenderInjectorShader.ts"/>
///<reference path="RenderInjectorCoat.ts"/>
///<reference path="RenderInjectorMesh.ts"/>
///<reference path="../Math/Rectangle.ts"/>
(function (FudgeCore) {
    let BLEND;
    (function (BLEND) {
        BLEND[BLEND["OPAQUE"] = 0] = "OPAQUE";
        BLEND[BLEND["TRANSPARENT"] = 1] = "TRANSPARENT";
        BLEND[BLEND["PARTICLE"] = 2] = "PARTICLE";
    })(BLEND = FudgeCore.BLEND || (FudgeCore.BLEND = {}));
    /**
     * Base class for RenderManager, handling the connection to the rendering system, in this case WebGL.
     * Methods and attributes of this class should not be called directly, only through {@link Render}
     */
    class RenderWebGL extends FudgeCore.EventTargetStatic {
        /**
         * Initializes offscreen-canvas, renderingcontext and hardware viewport. Call once before creating any resources like meshes or shaders
         */
        static initialize(_antialias, _alpha) {
            FudgeCore.fudgeConfig = FudgeCore.fudgeConfig || {};
            let contextAttributes = {
                alpha: (_alpha != undefined) ? _alpha : FudgeCore.fudgeConfig.alpha || false,
                antialias: (_antialias != undefined) ? _antialias : FudgeCore.fudgeConfig.antialias || false,
                premultipliedAlpha: false
            };
            FudgeCore.Debug.fudge("Initialize RenderWebGL", contextAttributes);
            let canvas = document.createElement("canvas");
            let crc3;
            crc3 = RenderWebGL.assert(canvas.getContext("webgl2", contextAttributes), "WebGL-context couldn't be created");
            RenderWebGL.crc3 = crc3;
            // Enable backface- and zBuffer-culling.
            crc3.enable(WebGL2RenderingContext.CULL_FACE);
            crc3.enable(WebGL2RenderingContext.DEPTH_TEST);
            crc3.enable(WebGL2RenderingContext.BLEND);
            crc3.blendEquation(WebGL2RenderingContext.FUNC_ADD);
            RenderWebGL.setBlendMode(BLEND.TRANSPARENT);
            // RenderOperator.crc3.pixelStorei(WebGL2RenderingContext.UNPACK_FLIP_Y_WEBGL, true);
            RenderWebGL.rectRender = RenderWebGL.getCanvasRect();
            return crc3;
        }
        /**
         * Wrapper function to utilize the bufferSpecification interface when passing data to the shader via a buffer.
         * @param _attributeLocation  The location of the attribute on the shader, to which they data will be passed.
         * @param _bufferSpecification  Interface passing datapullspecifications to the buffer.
         */
        static setAttributeStructure(_attributeLocation, _bufferSpecification) {
            RenderWebGL.crc3.vertexAttribPointer(_attributeLocation, _bufferSpecification.size, _bufferSpecification.dataType, _bufferSpecification.normalize, _bufferSpecification.stride, _bufferSpecification.offset);
        }
        /**
        * Checks the first parameter and throws an exception with the WebGL-errorcode if the value is null
        * @param _value  value to check against null
        * @param _message  optional, additional message for the exception
        */
        static assert(_value, _message = "") {
            if (_value === null)
                throw new Error(`Assertion failed. ${_message}, WebGL-Error: ${RenderWebGL.crc3 ? RenderWebGL.crc3.getError() : ""}`);
            return _value;
        }
        /**
         * Return a reference to the offscreen-canvas
         */
        static getCanvas() {
            return RenderWebGL.crc3.canvas; // TODO: enable OffscreenCanvas
        }
        /**
         * Return a reference to the rendering context
         */
        static getRenderingContext() {
            return RenderWebGL.crc3;
        }
        /**
         * Return a rectangle describing the size of the offscreen-canvas. x,y are 0 at all times.
         */
        static getCanvasRect() {
            let canvas = RenderWebGL.crc3.canvas;
            return FudgeCore.Rectangle.GET(0, 0, canvas.width, canvas.height);
        }
        /**
         * Set the size of the offscreen-canvas.
         */
        static setCanvasSize(_width, _height) {
            RenderWebGL.crc3.canvas.width = _width;
            RenderWebGL.crc3.canvas.height = _height;
        }
        /**
         * Set the area on the offscreen-canvas to render the camera image to.
         * @param _rect
         */
        static setRenderRectangle(_rect) {
            RenderWebGL.rectRender.setPositionAndSize(_rect.x, _rect.y, _rect.width, _rect.height);
            RenderWebGL.crc3.viewport(_rect.x, _rect.y, _rect.width, _rect.height);
        }
        /**
         * Clear the offscreen renderbuffer with the given {@link Color}
         */
        static clear(_color = null) {
            RenderWebGL.crc3.clearColor(_color.r, _color.g, _color.b, _color.a);
            RenderWebGL.crc3.clear(WebGL2RenderingContext.COLOR_BUFFER_BIT | WebGL2RenderingContext.DEPTH_BUFFER_BIT);
        }
        /**
         * Reset the offscreen framebuffer to the original RenderingContext
         */
        static resetFrameBuffer(_color = null) {
            RenderWebGL.crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, null);
        }
        /**
         * Retrieve the area on the offscreen-canvas the camera image gets rendered to.
         */
        static getRenderRectangle() {
            return RenderWebGL.rectRender;
        }
        static setDepthTest(_test) {
            if (_test)
                RenderWebGL.crc3.enable(WebGL2RenderingContext.DEPTH_TEST);
            else
                RenderWebGL.crc3.disable(WebGL2RenderingContext.DEPTH_TEST);
        }
        static setBlendMode(_mode) {
            switch (_mode) {
                case BLEND.OPAQUE:
                    RenderWebGL.crc3.blendFunc(WebGL2RenderingContext.ONE, WebGL2RenderingContext.ZERO);
                    break;
                case BLEND.TRANSPARENT:
                    RenderWebGL.crc3.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
                    // RenderWebGL.crc3.blendFunc(WebGL2RenderingContext.DST_ALPHA, WebGL2RenderingContext.ONE_MINUS_DST_ALPHA);
                    break;
                case BLEND.PARTICLE:
                    RenderWebGL.crc3.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.DST_ALPHA);
                    break;
                default:
                    break;
            }
        }
        //#region Picking
        /**
         * Creates a texture buffer to be used as pick-buffer
         */
        static createPickTexture(_size) {
            // create to render to
            const targetTexture = FudgeCore.Render.crc3.createTexture();
            FudgeCore.Render.crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, targetTexture);
            {
                const internalFormat = WebGL2RenderingContext.RGBA32I;
                const format = WebGL2RenderingContext.RGBA_INTEGER;
                const type = WebGL2RenderingContext.INT;
                FudgeCore.Render.pickBuffer = new Int32Array(_size * _size * 4);
                FudgeCore.Render.crc3.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, internalFormat, _size, _size, 0, format, type, FudgeCore.Render.pickBuffer);
                // set the filtering so we don't need mips
                FudgeCore.Render.crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.LINEAR);
                FudgeCore.Render.crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_S, WebGL2RenderingContext.CLAMP_TO_EDGE);
                FudgeCore.Render.crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_T, WebGL2RenderingContext.CLAMP_TO_EDGE);
            }
            const framebuffer = FudgeCore.Render.crc3.createFramebuffer();
            FudgeCore.Render.crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, framebuffer);
            const attachmentPoint = WebGL2RenderingContext.COLOR_ATTACHMENT0;
            FudgeCore.Render.crc3.framebufferTexture2D(WebGL2RenderingContext.FRAMEBUFFER, attachmentPoint, WebGL2RenderingContext.TEXTURE_2D, targetTexture, 0);
            RenderWebGL.sizePick = _size;
            return targetTexture;
        }
        static getPicks(_size, _cmpCamera) {
            // evaluate texture by reading pixels and extract, convert and store the information about each mesh hit
            let data = new Int32Array(_size * _size * 4);
            FudgeCore.Render.crc3.readPixels(0, 0, _size, _size, WebGL2RenderingContext.RGBA_INTEGER, WebGL2RenderingContext.INT, data);
            let mtxViewToWorld = FudgeCore.Matrix4x4.INVERSION(_cmpCamera.mtxWorldToView);
            let picked = [];
            for (let i = 0; i < FudgeCore.Render.∆ípicked.length; i++) {
                let zBuffer = data[4 * i + 0] + data[4 * i + 1] / 256;
                if (zBuffer == 0) // discard misses 
                    continue;
                let pick = FudgeCore.Render.∆ípicked[i];
                pick.zBuffer = convertInt32toFloat32(data, 4 * i + 0) * 2 - 1;
                pick.color = convertInt32toColor(data, 4 * i + 1);
                pick.textureUV = FudgeCore.Recycler.get(FudgeCore.Vector2);
                pick.textureUV.set(convertInt32toFloat32(data, 4 * i + 2), convertInt32toFloat32(data, 4 * i + 3));
                pick.mtxViewToWorld = mtxViewToWorld;
                picked.push(pick);
            }
            return picked;
            function convertInt32toFloat32(_int32Array, _index) {
                let buffer = new ArrayBuffer(4);
                let view = new DataView(buffer);
                view.setInt32(0, _int32Array[_index]);
                return view.getFloat32(0);
            }
            function convertInt32toColor(_int32Array, _index) {
                let buffer = new ArrayBuffer(4);
                let view = new DataView(buffer);
                view.setInt32(0, _int32Array[_index]);
                let color = FudgeCore.Color.CSS(`rgb(${view.getUint8(0)}, ${view.getUint8(1)}, ${view.getUint8(2)})`, view.getUint8(3) / 255);
                return color;
            }
        }
        /**
        * The render function for picking a single node.
        * A cameraprojection with extremely narrow focus is used, so each pixel of the buffer would hold the same information from the node,
        * but the fragment shader renders only 1 pixel for each node into the render buffer, 1st node to 1st pixel, 2nd node to second pixel etc.
        */
        static pick(_node, _mtxMeshToWorld, _mtxWorldToView) {
            try {
                let cmpMaterial = _node.getComponent(FudgeCore.ComponentMaterial);
                let cmpMesh = _node.getComponent(FudgeCore.ComponentMesh);
                let coat = cmpMaterial.material.coat;
                let shader = coat instanceof FudgeCore.CoatTextured ? FudgeCore.ShaderPickTextured : FudgeCore.ShaderPick;
                shader.useProgram();
                coat.useRenderData(shader, cmpMaterial);
                let sizeUniformLocation = shader.uniforms["u_vctSize"];
                RenderWebGL.getRenderingContext().uniform2fv(sizeUniformLocation, [RenderWebGL.sizePick, RenderWebGL.sizePick]);
                let mesh = cmpMesh.mesh;
                let nIndices = mesh.useRenderBuffers(shader, _mtxMeshToWorld, _mtxWorldToView, FudgeCore.Render.∆ípicked.length);
                RenderWebGL.crc3.drawElements(WebGL2RenderingContext.TRIANGLES, nIndices, WebGL2RenderingContext.UNSIGNED_SHORT, 0);
                let pick = new FudgeCore.Pick(_node);
                FudgeCore.Render.∆ípicked.push(pick);
            }
            catch (_error) {
                //
            }
        }
        //#endregion
        //#region Lights
        /**
         * Set light data in shaders
         */
        static setLightsInShader(_shader, _lights) {
            _shader.useProgram();
            let uni = _shader.uniforms;
            // Ambient
            let ambient = uni["u_ambient.vctColor"];
            if (ambient) {
                RenderWebGL.crc3.uniform4fv(ambient, [0, 0, 0, 0]);
                let cmpLights = _lights.get(FudgeCore.LightAmbient);
                if (cmpLights) {
                    // TODO: add up ambient lights to a single color
                    let result = new FudgeCore.Color(0, 0, 0, 1);
                    for (let cmpLight of cmpLights)
                        result.add(cmpLight.light.color);
                    RenderWebGL.crc3.uniform4fv(ambient, result.getArray());
                }
            }
            // Directional
            let nDirectional = uni["u_nLightsDirectional"];
            if (nDirectional) {
                RenderWebGL.crc3.uniform1ui(nDirectional, 0);
                let cmpLights = _lights.get(FudgeCore.LightDirectional);
                if (cmpLights) {
                    let n = cmpLights.length;
                    RenderWebGL.crc3.uniform1ui(nDirectional, n);
                    for (let i = 0; i < n; i++) {
                        let cmpLight = cmpLights[i];
                        RenderWebGL.crc3.uniform4fv(uni[`u_directional[${i}].vctColor`], cmpLight.light.color.getArray());
                        let direction = FudgeCore.Vector3.Z();
                        direction.transform(cmpLight.mtxPivot, false);
                        direction.transform(cmpLight.node.mtxWorld, false);
                        direction.normalize();
                        RenderWebGL.crc3.uniform3fv(uni[`u_directional[${i}].vctDirection`], direction.get());
                    }
                }
            }
        }
        //#endregion
        /**
         * Draw a mesh buffer using the given infos and the complete projection matrix
         */
        static drawMesh(_cmpMesh, cmpMaterial, _cmpCamera) {
            let shader = cmpMaterial.material.getShader();
            let coat = cmpMaterial.material.coat;
            let mtxMeshToView = FudgeCore.Matrix4x4.MULTIPLICATION(_cmpCamera.mtxWorldToView, _cmpMesh.mtxWorld);
            shader.useProgram();
            let nIndices = _cmpMesh.mesh.useRenderBuffers(shader, _cmpMesh.mtxWorld, mtxMeshToView);
            coat.useRenderData(shader, cmpMaterial);
            let uCamera = shader.uniforms["u_vctCamera"];
            if (uCamera)
                RenderWebGL.crc3.uniform3fv(uCamera, _cmpCamera.mtxWorld.translation.get());
            let uWorldToView = shader.uniforms["u_mtxWorldToView"];
            if (uWorldToView)
                RenderWebGL.crc3.uniformMatrix4fv(uWorldToView, false, _cmpCamera.mtxWorldToView.get());
            RenderWebGL.crc3.drawElements(WebGL2RenderingContext.TRIANGLES, nIndices, WebGL2RenderingContext.UNSIGNED_SHORT, 0);
        }
    }
    RenderWebGL.crc3 = RenderWebGL.initialize();
    RenderWebGL.rectRender = RenderWebGL.getCanvasRect();
    FudgeCore.RenderWebGL = RenderWebGL;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    //gives WebGL Buffer the data from the {@link Texture]]
    class RenderInjectorTexture extends FudgeCore.RenderInjector {
        static decorate(_constructor) {
            FudgeCore.RenderInjector.inject(_constructor, RenderInjectorTexture);
        }
        static injectTexture() {
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            if (this.renderData) {
                // buffers exist
                crc3.activeTexture(WebGL2RenderingContext.TEXTURE0);
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, this.renderData["texture0"]);
            }
            else {
                this.renderData = {};
                // TODO: check if all WebGL-Creations are asserted
                const texture = FudgeCore.Render.assert(crc3.createTexture());
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, texture);
                try {
                    crc3.texImage2D(crc3.TEXTURE_2D, 0, crc3.RGBA, crc3.RGBA, crc3.UNSIGNED_BYTE, this.texImageSource);
                    crc3.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.UNSIGNED_BYTE, this.texImageSource);
                }
                catch (_error) {
                    FudgeCore.Debug.error(_error);
                }
                switch (this.mipmap) {
                    case FudgeCore.MIPMAP.CRISP:
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, WebGL2RenderingContext.NEAREST);
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.NEAREST);
                        break;
                    case FudgeCore.MIPMAP.MEDIUM:
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, WebGL2RenderingContext.NEAREST);
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.NEAREST_MIPMAP_LINEAR);
                        crc3.generateMipmap(crc3.TEXTURE_2D);
                        break;
                    case FudgeCore.MIPMAP.BLURRY:
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, WebGL2RenderingContext.LINEAR);
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.LINEAR_MIPMAP_LINEAR);
                        crc3.generateMipmap(crc3.TEXTURE_2D);
                        break;
                }
                this.renderData["texture0"] = texture;
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
                this.useRenderData();
            }
        }
    }
    FudgeCore.RenderInjectorTexture = RenderInjectorTexture;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Represents a node in the scenetree.
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Graph
     */
    class Node extends FudgeCore.EventTarget∆í {
        /**
         * Creates a new node with a name and initializes all attributes
         */
        constructor(_name) {
            super();
            this.mtxWorld = FudgeCore.Matrix4x4.IDENTITY();
            this.timestampUpdate = 0;
            /** The number of nodes of the whole branch including this node and all successors */
            this.nNodesInBranch = 0;
            /** The radius of the bounding sphere in world dimensions enclosing the geometry of this node and all successors in the branch */
            this.radius = 0;
            this.parent = null; // The parent of this node.
            this.children = []; // array of child nodes appended to this node.
            this.components = {};
            // private tags: string[] = []; // Names of tags that are attached to this node. (TODO: As of yet no functionality)
            // private layers: string[] = []; // Names of the layers this node is on. (TODO: As of yet no functionality)
            this.listeners = {};
            this.captures = {};
            this.active = true;
            /**
             * Simply calls {@link addChild}. This reference is here solely because appendChild is the equivalent method in DOM.
             * See and preferably use {@link addChild}
             */
            // tslint:disable-next-line: member-ordering
            this.appendChild = this.addChild;
            this.name = _name;
        }
        #mtxWorldInverseUpdated;
        #mtxWorldInverse;
        get isActive() {
            return this.active;
        }
        /**
         * Shortcut to retrieve this nodes {@link ComponentTransform}
         */
        get cmpTransform() {
            return this.getComponents(FudgeCore.ComponentTransform)[0];
        }
        /**
         * Shortcut to retrieve the local {@link Matrix4x4} attached to this nodes {@link ComponentTransform}
         * Fails if no {@link ComponentTransform} is attached
         */
        get mtxLocal() {
            return this.cmpTransform.mtxLocal;
        }
        get mtxWorldInverse() {
            if (this.#mtxWorldInverseUpdated != this.timestampUpdate)
                this.#mtxWorldInverse = FudgeCore.Matrix4x4.INVERSION(this.mtxWorld);
            this.#mtxWorldInverseUpdated = this.timestampUpdate;
            return this.#mtxWorldInverse;
        }
        /**
         * Returns the number of children attached to this
         */
        get nChildren() {
            return this.children.length;
        }
        /**
         * Generator yielding the node and all decendants in the graph below for iteration
         * Inactive nodes and their descendants can be filtered
         */
        *getIterator(_active = false) {
            if (!_active || this.isActive) {
                yield this;
                for (let child of this.children)
                    yield* child.getIterator(_active);
            }
        }
        [Symbol.iterator]() {
            return this.getIterator();
        }
        activate(_on) {
            this.active = _on;
            // TODO: check if COMPONENT_ACTIVATE/DEACTIVATE is the correct event to dispatch. Shouldn't it be something like NODE_ACTIVATE/DEACTIVATE?
            this.dispatchEvent(new Event(_on ? "nodeActivate" /* NODE_ACTIVATE */ : "nodeDeactivate" /* NODE_DEACTIVATE */, { bubbles: true }));
            this.broadcastEvent(new Event(_on ? "nodeActivate" /* NODE_ACTIVATE */ : "nodeDeactivate" /* NODE_DEACTIVATE */));
        }
        // #region Scenetree
        /**
         * Returns a reference to this nodes parent node
         */
        getParent() {
            return this.parent;
        }
        /**
         * Traces back the ancestors of this node and returns the first
         */
        getAncestor() {
            let ancestor = this;
            while (ancestor.getParent())
                ancestor = ancestor.getParent();
            return ancestor;
        }
        /**
         * Traces the hierarchy upwards to the first ancestor and returns the path through the graph to this node
         */
        getPath() {
            let ancestor = this;
            let path = [this];
            while (ancestor.getParent())
                path.unshift(ancestor = ancestor.getParent());
            return path;
        }
        /**
         * Returns child at the given index in the list of children
         */
        getChild(_index) {
            return this.children[_index];
        }
        /**
         * Returns a clone of the list of children
         */
        getChildren() {
            return this.children.slice(0);
        }
        /**
         * Returns an array of references to childnodes with the supplied name.
         */
        getChildrenByName(_name) {
            let found = [];
            found = this.children.filter((_node) => _node.name == _name);
            return found;
        }
        /**
         * Adds the given reference to a node to the list of children, if not already in
         * @throws Error when trying to add an ancestor of this
         */
        addChild(_child) {
            if (this.children.includes(_child))
                // _node is already a child of this
                return;
            let inAudioGraph = false;
            let graphListened = FudgeCore.AudioManager.default.getGraphListeningTo();
            let ancestor = this;
            while (ancestor) {
                ancestor.timestampUpdate = 0;
                inAudioGraph = inAudioGraph || (ancestor == graphListened);
                if (ancestor == _child)
                    throw (new Error("Cyclic reference prohibited in node hierarchy, ancestors must not be added as children"));
                else
                    ancestor = ancestor.parent;
            }
            let previousParent = _child.parent;
            if (previousParent)
                previousParent.removeChild(_child);
            this.children.push(_child);
            _child.parent = this;
            _child.dispatchEvent(new Event("childAppend" /* CHILD_APPEND */, { bubbles: true }));
            if (inAudioGraph)
                _child.broadcastEvent(new Event("childAppendToAudioGraph" /* CHILD_APPEND */));
        }
        /**
         * Removes the reference to the give node from the list of children
         */
        removeChild(_child) {
            let found = this.findChild(_child);
            if (found < 0)
                return;
            _child.dispatchEvent(new Event("childRemove" /* CHILD_REMOVE */, { bubbles: true }));
            if (this.isDescendantOf(FudgeCore.AudioManager.default.getGraphListeningTo()))
                _child.broadcastEvent(new Event("childRemoveFromAudioGraph" /* CHILD_REMOVE */));
            this.children.splice(found, 1);
            _child.parent = null;
        }
        /**
         * Removes all references in the list of children
         */
        removeAllChildren() {
            while (this.children.length)
                this.removeChild(this.children[0]);
        }
        /**
         * Returns the position of the node in the list of children or -1 if not found
         */
        findChild(_search) {
            return this.children.indexOf(_search);
        }
        /**
         * Replaces a child node with another, preserving the position in the list of children
         */
        replaceChild(_replace, _with) {
            let found = this.findChild(_replace);
            if (found < 0)
                return false;
            let previousParent = _with.getParent();
            if (previousParent)
                previousParent.removeChild(_with);
            _replace.parent = null;
            this.children[found] = _with;
            _with.parent = this;
            _with.dispatchEvent(new Event("childAppend" /* CHILD_APPEND */, { bubbles: true }));
            if (this.isDescendantOf(FudgeCore.AudioManager.default.getGraphListeningTo()))
                _with.broadcastEvent(new Event("childAppendToAudioGraph" /* CHILD_APPEND */));
            return true;
        }
        isUpdated(_timestampUpdate) {
            return (this.timestampUpdate == _timestampUpdate);
        }
        isDescendantOf(_ancestor) {
            let node = this;
            while (node && node != _ancestor)
                node = node.parent;
            return (node != null);
        }
        /**
         * Applies a Mutator from {@link Animation} to all its components and transfers it to its children.
         */
        applyAnimation(_mutator) {
            if (_mutator.components) {
                for (let componentName in _mutator.components) {
                    if (this.components[componentName]) {
                        let mutatorOfComponent = _mutator.components;
                        for (let i in mutatorOfComponent[componentName]) {
                            if (this.components[componentName][+i]) {
                                let componentToMutate = this.components[componentName][+i];
                                let mutatorArray = mutatorOfComponent[componentName];
                                let mutatorWithComponentName = mutatorArray[+i];
                                for (let cname in mutatorWithComponentName) { // trick used to get the only entry in the list
                                    let mutatorToGive = mutatorWithComponentName[cname];
                                    componentToMutate.mutate(mutatorToGive);
                                }
                            }
                        }
                    }
                }
            }
            if (_mutator.children) {
                for (let i = 0; i < _mutator.children.length; i++) {
                    let name = _mutator.children[i]["∆í.Node"].name;
                    let childNodes = this.getChildrenByName(name);
                    for (let childNode of childNodes) {
                        childNode.applyAnimation(_mutator.children[i]["∆í.Node"]);
                    }
                }
            }
        }
        // #endregion
        // #region Components
        /**
         * Returns a list of all components attached to this node, independent of type.
         */
        getAllComponents() {
            let all = [];
            for (let type in this.components) {
                all = all.concat(this.components[type]);
            }
            return all;
        }
        /**
         * Returns a clone of the list of components of the given class attached to this node.
         */
        getComponents(_class) {
            return (this.components[_class.name] || []).slice(0);
        }
        /**
         * Returns the first compontent found of the given class attached this node or null, if list is empty or doesn't exist
         */
        getComponent(_class) {
            let list = this.components[_class.name];
            if (list)
                return list[0];
            return null;
        }
        /**
         * Attach the given component to this node. Identical to {@link addComponent}
         */
        attach(_component) {
            this.addComponent(_component);
        }
        /**
         * Attach the given component to this node
         */
        addComponent(_component) {
            if (_component.node == this)
                return;
            let cmpList = this.components[_component.type];
            if (cmpList === undefined)
                this.components[_component.type] = [_component];
            else if (cmpList.length && _component.isSingleton)
                throw new Error("Component is marked singleton and can't be attached, no more than one allowed");
            else
                cmpList.push(_component);
            _component.attachToNode(this);
            _component.dispatchEvent(new Event("componentAdd" /* COMPONENT_ADD */));
            this.dispatchEventToTargetOnly(new CustomEvent("componentAdd" /* COMPONENT_ADD */, { detail: _component })); // TODO: see if this is be feasable
        }
        /**
         * Detach the given component from this node. Identical to {@link removeComponent}
         */
        detach(_component) {
            this.removeComponent(_component);
        }
        /**
         * Removes the given component from the node, if it was attached, and sets its parent to null.
         */
        removeComponent(_component) {
            try {
                let componentsOfType = this.components[_component.type];
                let foundAt = componentsOfType.indexOf(_component);
                if (foundAt < 0)
                    return;
                _component.dispatchEvent(new Event("componentRemove" /* COMPONENT_REMOVE */));
                this.dispatchEventToTargetOnly(new CustomEvent("componentRemove" /* COMPONENT_REMOVE */, { detail: _component })); // TODO: see if this would be feasable
                componentsOfType.splice(foundAt, 1);
                _component.attachToNode(null);
            }
            catch (_error) {
                throw new Error(`Unable to remove component '${_component}'in node named '${this.name}'`);
            }
        }
        // #endregion
        // #region Serialization
        serialize() {
            let serialization = {
                name: this.name,
                active: this.active
            };
            let components = {};
            for (let type in this.components) {
                components[type] = [];
                for (let component of this.components[type]) {
                    // components[type].push(component.serialize());
                    components[type].push(FudgeCore.Serializer.serialize(component));
                }
            }
            serialization["components"] = components;
            let children = [];
            for (let child of this.children) {
                children.push(FudgeCore.Serializer.serialize(child));
            }
            serialization["children"] = children;
            this.dispatchEvent(new Event("nodeSerialized" /* NODE_SERIALIZED */));
            return serialization;
        }
        async deserialize(_serialization) {
            this.name = _serialization.name;
            // this.parent = is set when the nodes are added
            // deserialize components first so scripts can react to children being appended
            for (let type in _serialization.components) {
                for (let serializedComponent of _serialization.components[type]) {
                    let deserializedComponent = await FudgeCore.Serializer.deserialize(serializedComponent);
                    this.addComponent(deserializedComponent);
                }
            }
            for (let serializedChild of _serialization.children) {
                let deserializedChild = await FudgeCore.Serializer.deserialize(serializedChild);
                this.appendChild(deserializedChild);
            }
            this.dispatchEvent(new Event("nodeDeserialized" /* NODE_DESERIALIZED */));
            for (let component of this.getAllComponents())
                component.dispatchEvent(new Event("nodeDeserialized" /* NODE_DESERIALIZED */));
            this.activate(_serialization.active);
            return this;
        }
        // #endregion
        /**
         * Creates a string as representation of this node and its descendants
         */
        toHierarchyString(_node = null, _level = 0) {
            // TODO: refactor for better readability
            if (!_node)
                _node = this;
            let prefix = "+".repeat(_level);
            let output = prefix + " " + _node.name + " | ";
            for (let type in _node.components)
                output += _node.components[type].length + " " + type.split("Component").pop() + ", ";
            output = output.slice(0, -2) + "</br>";
            for (let child of _node.children) {
                output += this.toHierarchyString(child, _level + 1);
            }
            return output;
        }
        // #region Events
        /**
         * Adds an event listener to the node. The given handler will be called when a matching event is passed to the node.
         * Deviating from the standard EventTarget, here the _handler must be a function and _capture is the only option.
         */
        addEventListener(_type, _handler, _capture = false) {
            let listListeners = _capture ? this.captures : this.listeners;
            if (!listListeners[_type])
                listListeners[_type] = [];
            listListeners[_type].push(_handler);
        }
        /**
         * Removes an event listener from the node. The signature must match the one used with addEventListener
         */
        removeEventListener(_type, _handler, _capture = false) {
            let listenersForType = _capture ? this.captures[_type] : this.listeners[_type];
            if (listenersForType)
                for (let i = listenersForType.length - 1; i >= 0; i--)
                    if (listenersForType[i] == _handler)
                        listenersForType.splice(i, 1);
        }
        /**
         * Dispatches a synthetic event to target. This implementation always returns true (standard: return true only if either event's cancelable attribute value is false or its preventDefault() method was not invoked)
         * The event travels into the hierarchy to this node dispatching the event, invoking matching handlers of the nodes ancestors listening to the capture phase,
         * than the matching handler of the target node in the target phase, and back out of the hierarchy in the bubbling phase, invoking appropriate handlers of the anvestors
         */
        dispatchEvent(_event) {
            let ancestors = [];
            let upcoming = this;
            // overwrite event target
            Object.defineProperty(_event, "target", { writable: true, value: this });
            // TODO: consider using Reflect instead of Object throughout. See also Render and Mutable...
            while (upcoming.parent)
                ancestors.push(upcoming = upcoming.parent);
            // capture phase
            Object.defineProperty(_event, "eventPhase", { writable: true, value: Event.CAPTURING_PHASE });
            for (let i = ancestors.length - 1; i >= 0; i--) {
                let ancestor = ancestors[i];
                Object.defineProperty(_event, "currentTarget", { writable: true, value: ancestor });
                this.callListeners(ancestor.captures[_event.type], _event);
            }
            // target phase
            Object.defineProperty(_event, "eventPhase", { writable: true, value: Event.AT_TARGET });
            Object.defineProperty(_event, "currentTarget", { writable: true, value: this });
            this.callListeners(this.captures[_event.type], _event);
            this.callListeners(this.listeners[_event.type], _event);
            if (!_event.bubbles)
                return true;
            // bubble phase
            Object.defineProperty(_event, "eventPhase", { writable: true, value: Event.BUBBLING_PHASE });
            for (let i = 0; i < ancestors.length; i++) {
                let ancestor = ancestors[i];
                Object.defineProperty(_event, "currentTarget", { writable: true, value: ancestor });
                this.callListeners(ancestor.listeners[_event.type], _event);
            }
            return true; //TODO: return a meaningful value, see documentation of dispatch event
        }
        /**
         * Dispatches a synthetic event to target without travelling through the graph hierarchy neither during capture nor bubbling phase
         */
        dispatchEventToTargetOnly(_event) {
            Object.defineProperty(_event, "eventPhase", { writable: true, value: Event.AT_TARGET });
            Object.defineProperty(_event, "currentTarget", { writable: true, value: this });
            this.callListeners(this.listeners[_event.type], _event); // TODO: examine if this should go to the captures instead of the listeners
            return true;
        }
        /**
         * Broadcasts a synthetic event to this node and from there to all nodes deeper in the hierarchy,
         * invoking matching handlers of the nodes listening to the capture phase. Watch performance when there are many nodes involved
         */
        broadcastEvent(_event) {
            // overwrite event target and phase
            Object.defineProperty(_event, "eventPhase", { writable: true, value: Event.CAPTURING_PHASE });
            Object.defineProperty(_event, "target", { writable: true, value: this });
            this.broadcastEventRecursive(_event);
        }
        broadcastEventRecursive(_event) {
            // capture phase only
            Object.defineProperty(_event, "currentTarget", { writable: true, value: this });
            let captures = this.captures[_event.type] || [];
            for (let handler of captures)
                // @ts-ignore
                handler(_event);
            // appears to be slower, astonishingly...
            // captures.forEach(function (handler: Function): void {
            //     handler(_event);
            // });
            // same for children
            for (let child of this.children) {
                child.broadcastEventRecursive(_event);
            }
        }
        callListeners(_listeners, _event) {
            if (_listeners?.length > 0)
                for (let handler of _listeners)
                    // @ts-ignore
                    handler(_event);
        }
    }
    FudgeCore.Node = Node;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class EventPhysics extends Event {
        /** Creates a new event customized for physics. Holding informations about impulses. Collision point and the body that is colliding */
        constructor(_type, _hitRigidbody, _normalImpulse, _tangentImpulse, _binormalImpulse, _collisionPoint = null, _collisionNormal = null) {
            super(_type);
            this.cmpRigidbody = _hitRigidbody;
            this.normalImpulse = _normalImpulse;
            this.tangentImpulse = _tangentImpulse;
            this.binomalImpulse = _binormalImpulse;
            this.collisionPoint = _collisionPoint;
            this.collisionNormal = _collisionNormal;
        }
    }
    FudgeCore.EventPhysics = EventPhysics;
    /**
    * Groups to place a node in, not every group should collide with every group. Use a Mask in to exclude collisions
    */
    let COLLISION_GROUP;
    (function (COLLISION_GROUP) {
        COLLISION_GROUP[COLLISION_GROUP["DEFAULT"] = 1] = "DEFAULT";
        COLLISION_GROUP[COLLISION_GROUP["GROUP_1"] = 2] = "GROUP_1";
        COLLISION_GROUP[COLLISION_GROUP["GROUP_2"] = 4] = "GROUP_2";
        COLLISION_GROUP[COLLISION_GROUP["GROUP_3"] = 8] = "GROUP_3";
        COLLISION_GROUP[COLLISION_GROUP["GROUP_4"] = 16] = "GROUP_4";
        COLLISION_GROUP[COLLISION_GROUP["GROUP_5"] = 32] = "GROUP_5";
    })(COLLISION_GROUP = FudgeCore.COLLISION_GROUP || (FudgeCore.COLLISION_GROUP = {}));
    /**
    * Defines the type of the rigidbody which determines the way it interacts with the physical and the visual world
    */
    let BODY_TYPE;
    (function (BODY_TYPE) {
        /** The body ignores the hierarchy of the render graph, is completely controlled  by physics and takes its node with it  */
        BODY_TYPE[BODY_TYPE["DYNAMIC"] = 0] = "DYNAMIC";
        /** The body ignores the hierarchy of the render graph, is completely immoveble and keeps its node from moving  */
        BODY_TYPE[BODY_TYPE["STATIC"] = 1] = "STATIC";
        /** The body is controlled by its node and moves with it, while it impacts the physical world e.g. by collisions */
        BODY_TYPE[BODY_TYPE["KINEMATIC"] = 2] = "KINEMATIC"; // = OIMO.RigidBodyType.KINEMATIC
    })(BODY_TYPE = FudgeCore.BODY_TYPE || (FudgeCore.BODY_TYPE = {}));
    /**
    * Different types of collider shapes, with different options in scaling BOX = Vector3(length, height, depth),
    * SPHERE = Vector3(diameter, x, x), CAPSULE = Vector3(diameter, height, x), CYLINDER = Vector3(diameter, height, x),
    * CONE = Vector(diameter, height, x), PYRAMID = Vector3(length, height, depth); x == unused.
    * CONVEX = ComponentMesh needs to be available in the RB Property convexMesh, the points of that component are used to create a collider that matches,
    * the closest possible representation of that form, in form of a hull. Convex is experimental and can produce unexpected behaviour when vertices
    * are too close to one another and the given vertices do not form a in itself closed shape and having a genus of 0 (no holes). Vertices in the ComponentMesh can be scaled differently
    * for texturing/normal or other reasons, so the collider might be off compared to the visual shape, this can be corrected by changing the pivot scale of the ComponentRigidbody.
    */
    let COLLIDER_TYPE;
    (function (COLLIDER_TYPE) {
        COLLIDER_TYPE[COLLIDER_TYPE["CUBE"] = 0] = "CUBE";
        COLLIDER_TYPE[COLLIDER_TYPE["SPHERE"] = 1] = "SPHERE";
        COLLIDER_TYPE[COLLIDER_TYPE["CAPSULE"] = 2] = "CAPSULE";
        COLLIDER_TYPE[COLLIDER_TYPE["CYLINDER"] = 3] = "CYLINDER";
        COLLIDER_TYPE[COLLIDER_TYPE["CONE"] = 4] = "CONE";
        COLLIDER_TYPE[COLLIDER_TYPE["PYRAMID"] = 5] = "PYRAMID";
        COLLIDER_TYPE[COLLIDER_TYPE["CONVEX"] = 6] = "CONVEX";
    })(COLLIDER_TYPE = FudgeCore.COLLIDER_TYPE || (FudgeCore.COLLIDER_TYPE = {}));
    /** Displaying different types of debug information about different physic features. Default = JOINTS_AND_COLLIDER. */
    let PHYSICS_DEBUGMODE;
    (function (PHYSICS_DEBUGMODE) {
        PHYSICS_DEBUGMODE[PHYSICS_DEBUGMODE["NONE"] = 0] = "NONE";
        PHYSICS_DEBUGMODE[PHYSICS_DEBUGMODE["COLLIDERS"] = 1] = "COLLIDERS";
        PHYSICS_DEBUGMODE[PHYSICS_DEBUGMODE["JOINTS_AND_COLLIDER"] = 2] = "JOINTS_AND_COLLIDER";
        PHYSICS_DEBUGMODE[PHYSICS_DEBUGMODE["BOUNDING_BOXES"] = 3] = "BOUNDING_BOXES";
        PHYSICS_DEBUGMODE[PHYSICS_DEBUGMODE["CONTACTS"] = 4] = "CONTACTS";
        PHYSICS_DEBUGMODE[PHYSICS_DEBUGMODE["PHYSIC_OBJECTS_ONLY"] = 5] = "PHYSIC_OBJECTS_ONLY";
    })(PHYSICS_DEBUGMODE = FudgeCore.PHYSICS_DEBUGMODE || (FudgeCore.PHYSICS_DEBUGMODE = {}));
    /** Info about Raycasts shot from the physics system. */
    class RayHitInfo {
        constructor() {
            this.recycle();
        }
        recycle() {
            this.hit = false;
            this.hitDistance = 0;
            this.hitPoint = FudgeCore.Vector3.ZERO();
            this.rigidbodyComponent = null;
            this.hitNormal = FudgeCore.Vector3.ZERO();
            this.rayOrigin = FudgeCore.Vector3.ZERO();
            this.rayEnd = FudgeCore.Vector3.ZERO();
        }
    }
    FudgeCore.RayHitInfo = RayHitInfo;
    /** General settings for the physic simulation and the debug of it. */
    class PhysicsSettings {
        constructor(_defaultCollisionGroup, _defaultCollisionMask) {
            this.defaultCollisionGroup = _defaultCollisionGroup;
            this.defaultCollisionMask = _defaultCollisionMask;
        }
        /** Change if rigidbodies are able to sleep (don't be considered in physical calculations) when their movement is below a threshold. Deactivation is decreasing performance for minor advantage in precision. */
        get disableSleeping() {
            return OIMO.Setting.disableSleeping;
        }
        set disableSleeping(_value) {
            OIMO.Setting.disableSleeping = _value;
        }
        /** Sleeping Threshold for Movement Veloctiy. */
        get sleepingVelocityThreshold() {
            return OIMO.Setting.sleepingVelocityThreshold;
        }
        set sleepingVelocityThreshold(_value) {
            OIMO.Setting.sleepingVelocityThreshold = _value;
        }
        /** Sleeping Threshold for Rotation Velocity. */
        get sleepingAngularVelocityThreshold() {
            return OIMO.Setting.sleepingAngularVelocityThreshold;
        }
        set sleepingAngularVelocityThreshold(_value) {
            OIMO.Setting.sleepingAngularVelocityThreshold = _value;
        }
        /** Threshold how long the Rigidbody must be below/above the threshold to count as sleeping. */
        get sleepingTimeThreshold() {
            return OIMO.Setting.sleepingTimeThreshold;
        }
        set sleepingTimeThreshold(_value) {
            OIMO.Setting.sleepingTimeThreshold = _value;
        }
        /** Error threshold. Default is 0.05. The higher the more likely collisions get detected before actual impact at high speeds but it's visually less accurate. */
        get defaultCollisionMargin() {
            return OIMO.Setting.defaultGJKMargin;
        }
        set defaultCollisionMargin(_thickness) {
            OIMO.Setting.defaultGJKMargin = _thickness;
        }
        /** The default applied friction between two rigidbodies with the default value. How much velocity is slowed down when moving accross this surface. */
        get defaultFriction() {
            return OIMO.Setting.defaultFriction;
        }
        set defaultFriction(_value) {
            OIMO.Setting.defaultFriction = _value;
        }
        /** Bounciness of rigidbodies. How much of the impact is restituted. */
        get defaultRestitution() {
            return OIMO.Setting.defaultRestitution;
        }
        set defaultRestitution(_value) {
            OIMO.Setting.defaultRestitution = _value;
        }
        /** Groups the default rigidbody will collide with. Set it like: (PHYSICS_GROUP.DEFAULT | PHYSICS_GROUP.GROUP_1 | PHYSICS_GROUP.GROUP_2 | PHYSICS_GROUP.GROUP_3)
         * to collide with multiple groups. Default is collision with everything but triggers.
        */
        get defaultCollisionMask() {
            return OIMO.Setting.defaultCollisionMask;
        }
        set defaultCollisionMask(_value) {
            OIMO.Setting.defaultCollisionMask = _value;
        }
        /** The group that this rigidbody belongs to. Default is the DEFAULT Group which means its just a normal Rigidbody not a trigger nor anything special. */
        get defaultCollisionGroup() {
            return OIMO.Setting.defaultCollisionGroup;
        }
        set defaultCollisionGroup(_value) {
            OIMO.Setting.defaultCollisionGroup = _value;
        }
        /** Change the type of joint solver algorithm. Default Iterative == 0, is faster but less stable. Direct == 1, slow but more stable, recommended for complex joint work. Change this setting only at the start of your game. */
        get defaultConstraintSolverType() {
            return OIMO.Setting.defaultJointConstraintSolverType;
        }
        set defaultConstraintSolverType(_value) {
            OIMO.Setting.defaultJointConstraintSolverType = _value;
        }
        /** The correction algorithm used to correct physics calculations. Change this only at the beginning of your game. Each has different approaches, so if you have problems test another
         *  Default 0 = Baumgarte (fast but less correct induces some energy errors), 1 = Split-Impulse (fast and no engery errors, but more inaccurate for joints), 2 = Non-linear Gauss Seidel (slowest but most accurate)*/
        get defaultCorrectionAlgorithm() {
            return OIMO.Setting.defaultJointPositionCorrectionAlgorithm;
        }
        set defaultCorrectionAlgorithm(_value) {
            OIMO.Setting.defaultJointPositionCorrectionAlgorithm = _value;
        }
    }
    FudgeCore.PhysicsSettings = PhysicsSettings;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
       * Acts as the physical representation of a connection between two {@link Node}'s.
       * The type of conncetion is defined by the subclasses like prismatic joint, cylinder joint etc.
       * A Rigidbody on the {@link Node} that this component is added to is needed. Setting the connectedRigidbody and
       * initializing the connection creates a physical connection between them. This differs from a connection through hierarchy
       * in the node structure of fudge. Joints can have different DOF's (Degrees Of Freedom), 1 Axis that can either twist or swing is a degree of freedom.
       * A joint typically consists of a motor that limits movement/rotation or is activly trying to move to a limit. And a spring which defines the rigidity.
       * @author Marko Fehrenbach, HFU 2020
       */
    class Joint extends FudgeCore.Component {
        /** Create a joint connection between the two given RigidbodyComponents. */
        constructor(_bodyAnchor = null, _bodyTied = null) {
            super();
            this.#idBodyAnchor = 0;
            this.#idBodyTied = 0;
            this.#connected = false;
            this.#internalCollision = false;
            this.#breakForce = 0;
            this.#breakTorque = 0;
            // public static readonly iSubclass: number = Component.registerSubclass(ComponentJoint);
            this.singleton = false; //Multiple joints can be attached to one Node
            this.#getMutator = () => {
                let mutator = {
                    nameChildToConnect: this.#nameChildToConnect,
                    internalCollision: this.#internalCollision,
                    breakForce: this.#breakForce,
                    breakTorque: this.#breakTorque
                };
                return mutator;
            };
            this.#mutate = (_mutator) => {
                this.internalCollision = _mutator.internalCollision;
                this.breakForce = _mutator.breakForce;
                this.breakTorque = _mutator.breakTorque;
            };
            this.bodyAnchor = _bodyAnchor;
            this.bodyTied = _bodyTied;
            /*
              Tell the physics that there is a new joint and on the physics start the actual joint is first created. Values can be set but the
              actual constraint ain't existent until the game starts
            */
            this.addEventListener("componentAdd" /* COMPONENT_ADD */, this.dirtyStatus);
            this.addEventListener("componentRemove" /* COMPONENT_REMOVE */, this.removeJoint);
        }
        #idBodyAnchor;
        #idBodyTied;
        #bodyAnchor;
        #bodyTied;
        #connected;
        #anchor;
        #internalCollision;
        #breakForce;
        #breakTorque;
        #nameChildToConnect;
        static registerSubclass(_subclass) { return Joint.subclasses.push(_subclass) - 1; }
        /** Get/Set the first ComponentRigidbody of this connection. It should always be the one that this component is attached too in the sceneTree. */
        get bodyAnchor() {
            return this.#bodyAnchor;
        }
        set bodyAnchor(_cmpRB) {
            this.#idBodyAnchor = _cmpRB != null ? _cmpRB.id : -1;
            this.#bodyAnchor = _cmpRB;
            this.disconnect();
            this.dirtyStatus();
        }
        /** Get/Set the second ComponentRigidbody of this connection. */
        get bodyTied() {
            return this.#bodyTied;
        }
        set bodyTied(_cmpRB) {
            this.#idBodyTied = _cmpRB != null ? _cmpRB.id : -1;
            this.#bodyTied = _cmpRB;
            this.disconnect();
            this.dirtyStatus();
        }
        /**
         * The exact position where the two {@link Node}s are connected. When changed after initialization the joint needs to be reconnected.
         */
        get anchor() {
            return new FudgeCore.Vector3(this.#anchor.x, this.#anchor.y, this.#anchor.z);
        }
        set anchor(_value) {
            this.#anchor = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.disconnect();
            this.dirtyStatus();
        }
        /**
         * The amount of force needed to break the JOINT, while rotating, in Newton. 0 equals unbreakable (default)
        */
        get breakTorque() {
            return this.#breakTorque;
        }
        set breakTorque(_value) {
            this.#breakTorque = _value;
            if (this.joint != null)
                this.joint.setBreakTorque(this.#breakTorque);
        }
        /**
         * The amount of force needed to break the JOINT, in Newton. 0 equals unbreakable (default)
         */
        get breakForce() {
            return this.#breakForce;
        }
        set breakForce(_value) {
            this.#breakForce = _value;
            if (this.joint != null)
                this.joint.setBreakForce(this.#breakForce);
        }
        /**
          * If the two connected RigidBodies collide with eath other. (Default = false)
          * On a welding joint the connected bodies should not be colliding with each other,
          * for best results
         */
        get internalCollision() {
            return this.#internalCollision;
        }
        set internalCollision(_value) {
            this.#internalCollision = _value;
            if (this.joint != null)
                this.joint.setAllowCollision(this.#internalCollision);
        }
        connectChild(_name) {
            this.#nameChildToConnect = _name;
            if (!this.node)
                return;
            let children = this.node.getChildrenByName(_name);
            if (children.length == 1)
                this.connectNode(children.pop());
            else
                FudgeCore.Debug.warn(`${this.constructor.name} at ${this.node.name} fails to connect child with non existent or ambigous name ${_name}`);
        }
        connectNode(_node) {
            if (!_node || !this.node)
                return;
            FudgeCore.Debug.fudge(`${this.constructor.name} connected ${this.node.name} and ${_node.name}`);
            let connectBody = _node.getComponent(FudgeCore.ComponentRigidbody);
            let thisBody = this.node.getComponent(FudgeCore.ComponentRigidbody);
            if (!connectBody || !thisBody) {
                FudgeCore.Debug.warn(`${this.constructor.name} at ${this.node.name} fails due to missing rigidbodies on ${this.node.name} or ${_node.name}`);
                return;
            }
            this.bodyAnchor = thisBody;
            this.bodyTied = connectBody;
        }
        /** Check if connection is dirty, so when either rb is changed disconnect and reconnect. Internally used no user interaction needed. */
        isConnected() {
            return this.#connected;
        }
        /**
         * Initializing and connecting the two rigidbodies with the configured joint properties
         * is automatically called by the physics system. No user interaction needed.
         */
        connect() {
            if (this.#connected == false) {
                if (this.#idBodyAnchor == -1 || this.#idBodyTied == -1) {
                    if (this.#nameChildToConnect)
                        this.connectChild(this.#nameChildToConnect);
                    return;
                }
                this.constructJoint();
                this.#connected = true;
                this.addJoint();
            }
        }
        /**
         * Disconnecting the two rigidbodies and removing them from the physics system,
         * is automatically called by the physics system. No user interaction needed.
         */
        disconnect() {
            if (this.#connected == true) {
                this.removeJoint();
                this.#connected = false;
            }
        }
        /**
         * Returns the original Joint used by the physics engine. Used internally no user interaction needed.
         * Only to be used when functionality that is not added within Fudge is needed.
        */
        getOimoJoint() {
            return this.joint;
        }
        serialize() {
            let serialization = this.#getMutator();
            serialization.anchor = this.anchor.serialize();
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            this.anchor = await new FudgeCore.Vector3().deserialize(_serialization.anchor);
            this.#mutate(_serialization);
            await super.deserialize(_serialization[super.constructor.name]);
            this.connectChild(_serialization.nameChildToConnect);
            return this;
        }
        getMutator() {
            let mutator = super.getMutator(true);
            Object.assign(mutator, this.#getMutator());
            mutator.anchor = this.anchor.getMutator();
            return mutator;
        }
        async mutate(_mutator) {
            this.anchor = new FudgeCore.Vector3(...(Object.values(_mutator.anchor)));
            delete _mutator.anchor;
            this.connectChild(_mutator.nameChildToConnect);
            this.#mutate(_mutator);
            this.deleteFromMutator(_mutator, this.#getMutator());
            super.mutate(_mutator);
        }
        #getMutator;
        #mutate;
        reduceMutator(_mutator) {
            delete _mutator.springDamper;
            delete _mutator.joint;
            delete _mutator.motor;
            super.reduceMutator(_mutator);
        }
        /** Tell the FudgePhysics system that this joint needs to be handled in the next frame. */
        dirtyStatus() {
            FudgeCore.Physics.changeJointStatus(this);
        }
        addJoint() {
            FudgeCore.Physics.addJoint(this);
        }
        removeJoint() {
            FudgeCore.Physics.removeJoint(this);
        }
        constructJoint(..._configParams) {
            let posBodyAnchor = this.bodyAnchor.node.mtxWorld.translation; //Setting the anchor position locally from the first rigidbody
            let worldAnchor = new OIMO.Vec3(posBodyAnchor.x + this.#anchor.x, posBodyAnchor.y + this.#anchor.y, posBodyAnchor.z + this.#anchor.z);
            // @ts-ignore    // unfortunately, method init is not a member of the base class OIMO.JointConfig
            this.config.init(this.#bodyAnchor.getOimoRigidbody(), this.#bodyTied.getOimoRigidbody(), worldAnchor, ..._configParams);
        }
        configureJoint() {
            this.joint.setBreakForce(this.breakForce);
            this.joint.setBreakTorque(this.breakTorque);
            this.joint.setAllowCollision(this.#internalCollision);
        }
        deleteFromMutator(_mutator, _delete) {
            for (let key in _delete)
                delete _mutator[key];
        }
    }
    /** refers back to this class from any subclass e.g. in order to find compatible other resources*/
    Joint.baseClass = Joint;
    /** list of all the subclasses derived from this class, if they registered properly*/
    Joint.subclasses = [];
    FudgeCore.Joint = Joint;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
       * Base class for joints operating with exactly one axis
       * @author Jirka Dell'Oro-Friedl, HFU, 2021
     */
    class JointAxial extends FudgeCore.Joint {
        /** Creating a cylindrical joint between two ComponentRigidbodies moving on one axis and rotating around another bound on a local anchorpoint. */
        constructor(_bodyAnchor = null, _bodyTied = null, _axis = new FudgeCore.Vector3(0, 1, 0), _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied);
            //Internal Variables
            this.#maxMotor = 10;
            this.#minMotor = -10;
            this.#motorSpeed = 0;
            this.#springFrequency = 0;
            this.#springDamping = 0;
            this.#getMutator = () => {
                let mutator = {
                    springDamping: this.#springDamping,
                    springFrequency: this.#springFrequency,
                    maxMotor: this.#maxMotor,
                    minMotor: this.#minMotor,
                    motorSpeed: this.#motorSpeed
                };
                return mutator;
            };
            this.#mutate = (_mutator) => {
                this.springDamping = _mutator.springDamping;
                this.springFrequency = _mutator.springFrequency;
                this.maxMotor = _mutator.maxMotor;
                this.minMotor = _mutator.minMotor;
                this.motorSpeed = _mutator.motorSpeed;
            };
            this.axis = _axis;
            this.anchor = _localAnchor;
            this.minMotor = -10;
            this.maxMotor = 10;
        }
        //Internal Variables
        #maxMotor;
        #minMotor;
        #motorSpeed;
        #axis;
        #springFrequency;
        #springDamping;
        //#region Get/Set transfor of fudge properties to the physics engine
        /**
         * The axis connecting the the two {@link Node}s e.g. Vector3(0,1,0) to have a upward connection.
         *  When changed after initialization the joint needs to be reconnected.
         */
        get axis() {
            return new FudgeCore.Vector3(this.#axis.x, this.#axis.y, this.#axis.z);
        }
        set axis(_value) {
            this.#axis = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.disconnect();
            this.dirtyStatus();
        }
        /**
          * The Upper Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit.
         */
        get maxMotor() {
            return this.#maxMotor;
        }
        set maxMotor(_value) {
            this.#maxMotor = _value;
            try {
                this.joint.getLimitMotor().upperLimit = _value;
            }
            catch (_e) { /* */ }
        }
        /**
          * The Lower Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit.
         */
        get minMotor() {
            return this.#minMotor;
        }
        set minMotor(_value) {
            this.#minMotor = _value;
            try {
                this.joint.getLimitMotor().lowerLimit = _value;
            }
            catch (_e) { /* */ }
        }
        /**
         * The damping of the spring. 1 equals completly damped.
         */
        get springDamping() {
            return this.#springDamping;
        }
        set springDamping(_value) {
            this.#springDamping = _value;
            try {
                this.joint.getSpringDamper().dampingRatio = _value;
            }
            catch (_e) { /* */ }
        }
        /**
          * The target speed of the motor in m/s.
         */
        get motorSpeed() {
            return this.#motorSpeed;
        }
        set motorSpeed(_value) {
            this.#motorSpeed = _value;
            try {
                this.joint.getLimitMotor().motorSpeed = _value;
            }
            catch (_e) { /* */ }
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. The smaller the value the less restrictive is the spring.
        */
        get springFrequency() {
            return this.#springFrequency;
        }
        set springFrequency(_value) {
            this.#springFrequency = _value;
            try {
                this.joint.getSpringDamper().frequency = _value;
            }
            catch (_e) { /* */ }
        }
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = this.#getMutator();
            serialization.axis = this.axis.serialize();
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            this.axis = await new FudgeCore.Vector3().deserialize(_serialization.axis);
            this.#mutate(_serialization);
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        async mutate(_mutator) {
            this.axis = new FudgeCore.Vector3(...(Object.values(_mutator.axis)));
            delete _mutator.axis;
            this.#mutate(_mutator);
            this.deleteFromMutator(_mutator, this.#getMutator());
            super.mutate(_mutator);
        }
        getMutator() {
            let mutator = super.getMutator();
            mutator.axis = this.axis.getMutator();
            Object.assign(mutator, this.#getMutator());
            return mutator;
        }
        #getMutator;
        #mutate;
        //#endregion
        constructJoint() {
            this.springDamper = new OIMO.SpringDamper().setSpring(this.#springFrequency, this.#springDamping);
            super.constructJoint(this.#axis);
        }
    }
    FudgeCore.JointAxial = JointAxial;
})(FudgeCore || (FudgeCore = {}));
/// <reference path="Debug/DebugTarget.ts"/>
/// <reference path="Debug/Debug.ts"/>
/// <reference path="Event/Event.ts"/>
/// <reference path="Serialization/Mutable.ts"/>
/// <reference path="Serialization/Serializer.ts"/> 
/// <reference path="Component/Component.ts"/>
/// <reference path="Recycle/RecycableArray.ts"/>
/// <reference path="Render/RenderWebGL.ts"/>
/// <reference path="Render/RenderInjectorTexture.ts"/>
/// <reference path="Graph/Node.ts"/>
/// <reference path="Physics/HelpersPhysics.ts"/>
/// <reference path="Physics/Joint.ts"/>
/// <reference path="Physics/JointAxial.ts"/>
//global functions
function ifNumber(_check, _default) {
    return typeof _check == "undefined" ? _default : _check;
}
// / <reference path="../Transfer/Mutable.ts"/>
var FudgeCore;
// / <reference path="../Transfer/Mutable.ts"/>
(function (FudgeCore) {
    /**
     * Internally used to differentiate between the various generated structures and events.
     * @author Lukas Scheuerle, HFU, 2019
     */
    let ANIMATION_STRUCTURE_TYPE;
    (function (ANIMATION_STRUCTURE_TYPE) {
        /**Default: forward, continous */
        ANIMATION_STRUCTURE_TYPE[ANIMATION_STRUCTURE_TYPE["NORMAL"] = 0] = "NORMAL";
        /**backward, continous */
        ANIMATION_STRUCTURE_TYPE[ANIMATION_STRUCTURE_TYPE["REVERSE"] = 1] = "REVERSE";
        /**forward, rastered */
        ANIMATION_STRUCTURE_TYPE[ANIMATION_STRUCTURE_TYPE["RASTERED"] = 2] = "RASTERED";
        /**backward, rastered */
        ANIMATION_STRUCTURE_TYPE[ANIMATION_STRUCTURE_TYPE["RASTEREDREVERSE"] = 3] = "RASTEREDREVERSE";
    })(ANIMATION_STRUCTURE_TYPE || (ANIMATION_STRUCTURE_TYPE = {}));
    /**
     * Holds different playmodes the animation uses to play back its animation.
     * @author Lukas Scheuerle, HFU, 2019
     */
    let ANIMATION_PLAYMODE;
    (function (ANIMATION_PLAYMODE) {
        /**Plays animation in a loop: it restarts once it hit the end.*/
        ANIMATION_PLAYMODE[ANIMATION_PLAYMODE["LOOP"] = 0] = "LOOP";
        /**Plays animation once and stops at the last key/frame*/
        ANIMATION_PLAYMODE[ANIMATION_PLAYMODE["PLAYONCE"] = 1] = "PLAYONCE";
        /**Plays animation once and stops on the first key/frame */
        ANIMATION_PLAYMODE[ANIMATION_PLAYMODE["PLAYONCESTOPAFTER"] = 2] = "PLAYONCESTOPAFTER";
        /**Plays animation like LOOP, but backwards.*/
        ANIMATION_PLAYMODE[ANIMATION_PLAYMODE["REVERSELOOP"] = 3] = "REVERSELOOP";
        /**Causes the animation not to play at all. Useful for jumping to various positions in the animation without proceeding in the animation.*/
        ANIMATION_PLAYMODE[ANIMATION_PLAYMODE["STOP"] = 4] = "STOP";
        //TODO: add an INHERIT and a PINGPONG mode
    })(ANIMATION_PLAYMODE = FudgeCore.ANIMATION_PLAYMODE || (FudgeCore.ANIMATION_PLAYMODE = {}));
    let ANIMATION_PLAYBACK;
    (function (ANIMATION_PLAYBACK) {
        //TODO: add an in-depth description of what happens to the animation (and events) depending on the Playback. Use Graphs to explain.
        /**Calculates the state of the animation at the exact position of time. Ignores FPS value of animation.*/
        ANIMATION_PLAYBACK[ANIMATION_PLAYBACK["TIMEBASED_CONTINOUS"] = 0] = "TIMEBASED_CONTINOUS";
        /**Limits the calculation of the state of the animation to the FPS value of the animation. Skips frames if needed.*/
        ANIMATION_PLAYBACK[ANIMATION_PLAYBACK["TIMEBASED_RASTERED_TO_FPS"] = 1] = "TIMEBASED_RASTERED_TO_FPS";
        /** Advances the time each frame according to the FPS value of the animation, ignoring the actual duration of the frames. Doesn't skip any frames.*/
        ANIMATION_PLAYBACK[ANIMATION_PLAYBACK["FRAMEBASED"] = 2] = "FRAMEBASED";
    })(ANIMATION_PLAYBACK = FudgeCore.ANIMATION_PLAYBACK || (FudgeCore.ANIMATION_PLAYBACK = {}));
    /**
     * Animation Class to hold all required Objects that are part of an Animation.
     * Also holds functions to play said Animation.
     * Can be added to a Node and played through {@link ComponentAnimator}.
     * @author Lukas Scheuerle, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2021
     */
    class Animation extends FudgeCore.Mutable {
        constructor(_name, _animStructure = {}, _fps = 60) {
            super();
            this.totalTime = 0;
            this.labels = {};
            this.events = {};
            this.framesPerSecond = 60;
            // processed eventlist and animation strucutres for playback.
            this.eventsProcessed = new Map();
            this.animationStructuresProcessed = new Map();
            this.name = _name;
            this.animationStructure = _animStructure;
            this.animationStructuresProcessed.set(ANIMATION_STRUCTURE_TYPE.NORMAL, _animStructure);
            this.framesPerSecond = _fps;
            this.calculateTotalTime();
            FudgeCore.Project.register(this);
        }
        get getLabels() {
            //TODO: this actually needs testing
            let en = new Enumerator(this.labels);
            return en;
        }
        get fps() {
            return this.framesPerSecond;
        }
        set fps(_fps) {
            this.framesPerSecond = _fps;
            this.eventsProcessed.clear();
            this.animationStructuresProcessed.clear();
        }
        /**
         * Generates a new "Mutator" with the information to apply to the {@link Node} the {@link ComponentAnimator} is attached to with {@link Node.applyAnimation}.
         * @param _time The time at which the animation currently is at
         * @param _direction The direction in which the animation is supposed to be playing back. >0 == forward, 0 == stop, <0 == backwards
         * @param _playback The playbackmode the animation is supposed to be calculated with.
         * @returns a "Mutator" to apply.
         */
        getMutated(_time, _direction, _playback) {
            let m = {};
            let animationStructure;
            if (_playback == ANIMATION_PLAYBACK.TIMEBASED_CONTINOUS)
                animationStructure = _direction < 0 ? ANIMATION_STRUCTURE_TYPE.REVERSE : ANIMATION_STRUCTURE_TYPE.NORMAL;
            else
                animationStructure = _direction < 0 ? ANIMATION_STRUCTURE_TYPE.RASTEREDREVERSE : ANIMATION_STRUCTURE_TYPE.RASTERED;
            m = this.traverseStructureForMutator(this.getProcessedAnimationStructure(animationStructure), _time);
            return m;
        }
        /**
         * Returns a list of the names of the events the {@link ComponentAnimator} needs to fire between _min and _max.
         * @param _min The minimum time (inclusive) to check between
         * @param _max The maximum time (exclusive) to check between
         * @param _playback The playback mode to check in. Has an effect on when the Events are fired.
         * @param _direction The direction the animation is supposed to run in. >0 == forward, 0 == stop, <0 == backwards
         * @returns a list of strings with the names of the custom events to fire.
         */
        getEventsToFire(_min, _max, _playback, _direction) {
            let eventList = [];
            let minSection = Math.floor(_min / this.totalTime);
            let maxSection = Math.floor(_max / this.totalTime);
            _min = _min % this.totalTime;
            _max = _max % this.totalTime;
            while (minSection <= maxSection) {
                let eventTriggers = this.getCorrectEventList(_direction, _playback);
                if (minSection == maxSection) {
                    eventList = eventList.concat(this.checkEventsBetween(eventTriggers, _min, _max));
                }
                else {
                    eventList = eventList.concat(this.checkEventsBetween(eventTriggers, _min, this.totalTime));
                    _min = 0;
                }
                minSection++;
            }
            return eventList;
        }
        /**
         * Adds an Event to the List of events.
         * @param _name The name of the event (needs to be unique per Animation).
         * @param _time The timestamp of the event (in milliseconds).
         */
        setEvent(_name, _time) {
            this.events[_name] = _time;
            this.eventsProcessed.clear();
        }
        /**
         * Removes the event with the given name from the list of events.
         * @param _name name of the event to remove.
         */
        removeEvent(_name) {
            delete this.events[_name];
            this.eventsProcessed.clear();
        }
        /**
         * (Re-)Calculate the total time of the Animation. Calculation-heavy, use only if actually needed.
         */
        calculateTotalTime() {
            this.totalTime = 0;
            this.traverseStructureForTime(this.animationStructure);
        }
        /**
         * Returns the time to use for animation sampling when applying a playmode
         */
        getModalTime(_time, _playmode, _timeStop = _time) {
            switch (_playmode) {
                case ANIMATION_PLAYMODE.STOP:
                    // return this.localTime.getOffset();
                    return _timeStop;
                case ANIMATION_PLAYMODE.PLAYONCE:
                    if (_time >= this.totalTime)
                        return this.totalTime - 0.01; //TODO: this might cause some issues
                case ANIMATION_PLAYMODE.PLAYONCESTOPAFTER:
                    if (_time >= this.totalTime)
                        // TODO: return _timeStop instead?
                        return this.totalTime + 0.01; //TODO: this might cause some issues
            }
            return _time;
        }
        /**
         * Calculates and returns the direction the animation should currently be playing in.
         * @param _time the time at which to calculate the direction
         * @returns 1 if forward, 0 if stop, -1 if backwards
         */
        calculateDirection(_time, _playmode) {
            switch (_playmode) {
                case ANIMATION_PLAYMODE.STOP:
                    return 0;
                // case ANIMATION_PLAYMODE.PINGPONG:
                //   if (Math.floor(_time / this.animation.totalTime) % 2 == 0)
                //     return 1;
                //   else
                //     return -1;
                case ANIMATION_PLAYMODE.REVERSELOOP:
                    return -1;
                case ANIMATION_PLAYMODE.PLAYONCE:
                case ANIMATION_PLAYMODE.PLAYONCESTOPAFTER:
                    if (_time >= this.totalTime) {
                        return 0;
                    }
                default:
                    return 1;
            }
        }
        //#region transfer
        serialize() {
            let s = {
                idResource: this.idResource,
                name: this.name,
                labels: {},
                events: {},
                fps: this.framesPerSecond,
                // sps: this.stepsPerSecond
            };
            for (let name in this.labels) {
                s.labels[name] = this.labels[name];
            }
            for (let name in this.events) {
                s.events[name] = this.events[name];
            }
            s.animationStructure = this.traverseStructureForSerialisation(this.animationStructure);
            return s;
        }
        async deserialize(_serialization) {
            this.idResource = _serialization.idResource;
            this.name = _serialization.name;
            this.framesPerSecond = _serialization.fps;
            // this.stepsPerSecond = _serialization.sps;
            this.labels = {};
            for (let name in _serialization.labels) {
                this.labels[name] = _serialization.labels[name];
            }
            this.events = {};
            for (let name in _serialization.events) {
                this.events[name] = _serialization.events[name];
            }
            this.eventsProcessed = new Map();
            this.animationStructure = await this.traverseStructureForDeserialisation(_serialization.animationStructure);
            this.animationStructuresProcessed = new Map();
            this.calculateTotalTime();
            return this;
        }
        getMutator() {
            return this.serialize();
        }
        reduceMutator(_mutator) {
            delete _mutator.totalTime;
        }
        /**
         * Traverses an AnimationStructure and returns the Serialization of said Structure.
         * @param _structure The Animation Structure at the current level to transform into the Serialization.
         * @returns the filled Serialization.
         */
        traverseStructureForSerialisation(_structure) {
            let newSerialization = {};
            for (let n in _structure) {
                if (_structure[n] instanceof FudgeCore.AnimationSequence) {
                    newSerialization[n] = _structure[n].serialize();
                }
                else {
                    newSerialization[n] = this.traverseStructureForSerialisation(_structure[n]);
                }
            }
            return newSerialization;
        }
        /**
         * Traverses a Serialization to create a new AnimationStructure.
         * @param _serialization The serialization to transfer into an AnimationStructure
         * @returns the newly created AnimationStructure.
         */
        async traverseStructureForDeserialisation(_serialization) {
            let newStructure = {};
            for (let n in _serialization) {
                if (_serialization[n].animationSequence) {
                    let animSeq = new FudgeCore.AnimationSequence();
                    newStructure[n] = await animSeq.deserialize(_serialization[n]);
                }
                else {
                    newStructure[n] = await this.traverseStructureForDeserialisation(_serialization[n]);
                }
            }
            return newStructure;
        }
        //#endregion
        /**
         * Finds the list of events to be used with these settings.
         * @param _direction The direction the animation is playing in.
         * @param _playback The playbackmode the animation is playing in.
         * @returns The correct AnimationEventTrigger Object to use
         */
        getCorrectEventList(_direction, _playback) {
            if (_playback != ANIMATION_PLAYBACK.FRAMEBASED) {
                if (_direction >= 0) {
                    return this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.NORMAL);
                }
                else {
                    return this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.REVERSE);
                }
            }
            else {
                if (_direction >= 0) {
                    return this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.RASTERED);
                }
                else {
                    return this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.RASTEREDREVERSE);
                }
            }
        }
        /**
         * Traverses an AnimationStructure to turn it into the "Mutator" to return to the Component.
         * @param _structure The strcuture to traverse
         * @param _time the point in time to write the animation numbers into.
         * @returns The "Mutator" filled with the correct values at the given time.
         */
        traverseStructureForMutator(_structure, _time) {
            let newMutator = {};
            for (let n in _structure) {
                if (_structure[n] instanceof FudgeCore.AnimationSequence) {
                    newMutator[n] = _structure[n].evaluate(_time);
                }
                else {
                    newMutator[n] = this.traverseStructureForMutator(_structure[n], _time);
                }
            }
            return newMutator;
        }
        /**
         * Traverses the current AnimationStrcuture to find the totalTime of this animation.
         * @param _structure The structure to traverse
         */
        traverseStructureForTime(_structure) {
            for (let n in _structure) {
                if (_structure[n] instanceof FudgeCore.AnimationSequence) {
                    let sequence = _structure[n];
                    if (sequence.length > 0) {
                        let sequenceTime = sequence.getKey(sequence.length - 1).Time;
                        this.totalTime = sequenceTime > this.totalTime ? sequenceTime : this.totalTime;
                    }
                }
                else {
                    this.traverseStructureForTime(_structure[n]);
                }
            }
        }
        /**
         * Ensures the existance of the requested {@link AnimationStrcuture} and returns it.
         * @param _type the type of the structure to get
         * @returns the requested {@link AnimationStructure]]
         */
        getProcessedAnimationStructure(_type) {
            if (!this.animationStructuresProcessed.has(_type)) {
                this.calculateTotalTime();
                let ae = {};
                switch (_type) {
                    case ANIMATION_STRUCTURE_TYPE.NORMAL:
                        ae = this.animationStructure;
                        break;
                    case ANIMATION_STRUCTURE_TYPE.REVERSE:
                        ae = this.traverseStructureForNewStructure(this.animationStructure, this.calculateReverseSequence.bind(this));
                        break;
                    case ANIMATION_STRUCTURE_TYPE.RASTERED:
                        ae = this.traverseStructureForNewStructure(this.animationStructure, this.calculateRasteredSequence.bind(this));
                        break;
                    case ANIMATION_STRUCTURE_TYPE.RASTEREDREVERSE:
                        ae = this.traverseStructureForNewStructure(this.getProcessedAnimationStructure(ANIMATION_STRUCTURE_TYPE.REVERSE), this.calculateRasteredSequence.bind(this));
                        break;
                    default:
                        return {};
                }
                this.animationStructuresProcessed.set(_type, ae);
            }
            return this.animationStructuresProcessed.get(_type);
        }
        /**
         * Ensures the existance of the requested {@link AnimationEventTrigger} and returns it.
         * @param _type The type of AnimationEventTrigger to get
         * @returns the requested {@link AnimationEventTrigger]]
         */
        getProcessedEventTrigger(_type) {
            if (!this.eventsProcessed.has(_type)) {
                this.calculateTotalTime();
                let ev = {};
                switch (_type) {
                    case ANIMATION_STRUCTURE_TYPE.NORMAL:
                        ev = this.events;
                        break;
                    case ANIMATION_STRUCTURE_TYPE.REVERSE:
                        ev = this.calculateReverseEventTriggers(this.events);
                        break;
                    case ANIMATION_STRUCTURE_TYPE.RASTERED:
                        ev = this.calculateRasteredEventTriggers(this.events);
                        break;
                    case ANIMATION_STRUCTURE_TYPE.RASTEREDREVERSE:
                        ev = this.calculateRasteredEventTriggers(this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.REVERSE));
                        break;
                    default:
                        return {};
                }
                this.eventsProcessed.set(_type, ev);
            }
            return this.eventsProcessed.get(_type);
        }
        /**
         * Traverses an existing structure to apply a recalculation function to the AnimationStructure to store in a new Structure.
         * @param _oldStructure The old structure to traverse
         * @param _functionToUse The function to use to recalculated the structure.
         * @returns A new Animation Structure with the recalulated Animation Sequences.
         */
        traverseStructureForNewStructure(_oldStructure, _functionToUse) {
            let newStructure = {};
            for (let n in _oldStructure) {
                if (_oldStructure[n] instanceof FudgeCore.AnimationSequence) {
                    newStructure[n] = _functionToUse(_oldStructure[n]);
                }
                else {
                    newStructure[n] = this.traverseStructureForNewStructure(_oldStructure[n], _functionToUse);
                }
            }
            return newStructure;
        }
        /**
         * Creates a reversed Animation Sequence out of a given Sequence.
         * @param _sequence The sequence to calculate the new sequence out of
         * @returns The reversed Sequence
         */
        calculateReverseSequence(_sequence) {
            let seq = new FudgeCore.AnimationSequence();
            for (let i = 0; i < _sequence.length; i++) {
                let oldKey = _sequence.getKey(i);
                let key = new FudgeCore.AnimationKey(this.totalTime - oldKey.Time, oldKey.Value, oldKey.SlopeOut, oldKey.SlopeIn, oldKey.Constant);
                seq.addKey(key);
            }
            return seq;
        }
        /**
         * Creates a rastered {@link AnimationSequence} out of a given sequence.
         * @param _sequence The sequence to calculate the new sequence out of
         * @returns the rastered sequence.
         */
        calculateRasteredSequence(_sequence) {
            let seq = new FudgeCore.AnimationSequence();
            let frameTime = 1000 / this.framesPerSecond;
            for (let i = 0; i < this.totalTime; i += frameTime) {
                let key = new FudgeCore.AnimationKey(i, _sequence.evaluate(i), 0, 0, true);
                seq.addKey(key);
            }
            return seq;
        }
        /**
         * Creates a new reversed {@link AnimationEventTrigger} object based on the given one.
         * @param _events the event object to calculate the new one out of
         * @returns the reversed event object
         */
        calculateReverseEventTriggers(_events) {
            let ae = {};
            for (let name in _events) {
                ae[name] = this.totalTime - _events[name];
            }
            return ae;
        }
        /**
         * Creates a rastered {@link AnimationEventTrigger} object based on the given one.
         * @param _events the event object to calculate the new one out of
         * @returns the rastered event object
         */
        calculateRasteredEventTriggers(_events) {
            let ae = {};
            let frameTime = 1000 / this.framesPerSecond;
            for (let name in _events) {
                ae[name] = _events[name] - (_events[name] % frameTime);
            }
            return ae;
        }
        /**
         * Checks which events lay between two given times and returns the names of the ones that do.
         * @param _eventTriggers The event object to check the events inside of
         * @param _min the minimum of the range to check between (inclusive)
         * @param _max the maximum of the range to check between (exclusive)
         * @returns an array of the names of the events in the given range.
         */
        checkEventsBetween(_eventTriggers, _min, _max) {
            let eventsToTrigger = [];
            for (let name in _eventTriggers) {
                if (_min <= _eventTriggers[name] && _eventTriggers[name] < _max) {
                    eventsToTrigger.push(name);
                }
            }
            return eventsToTrigger;
        }
    }
    FudgeCore.Animation = Animation;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="../Transfer/Serializer.ts"/>
// / <reference path="../Transfer/Mutable.ts"/>
var FudgeCore;
// / <reference path="../Transfer/Serializer.ts"/>
// / <reference path="../Transfer/Mutable.ts"/>
(function (FudgeCore) {
    /**
     * Calculates the values between {@link AnimationKey}s.
     * Represented internally by a cubic function (`f(x) = ax¬≥ + bx¬≤ + cx + d`).
     * Only needs to be recalculated when the keys change, so at runtime it should only be calculated once.
     * @author Lukas Scheuerle, HFU, 2019
     */
    class AnimationFunction {
        constructor(_keyIn, _keyOut = null) {
            this.a = 0;
            this.b = 0;
            this.c = 0;
            this.d = 0;
            this.keyIn = _keyIn;
            this.keyOut = _keyOut;
            this.calculate();
        }
        /**
         * Calculates the value of the function at the given time.
         * @param _time the point in time at which to evaluate the function in milliseconds. Will be corrected for offset internally.
         * @returns the value at the given time
         */
        evaluate(_time) {
            _time -= this.keyIn.Time;
            let time2 = _time * _time;
            let time3 = time2 * _time;
            return this.a * time3 + this.b * time2 + this.c * _time + this.d;
        }
        set setKeyIn(_keyIn) {
            this.keyIn = _keyIn;
            this.calculate();
        }
        set setKeyOut(_keyOut) {
            this.keyOut = _keyOut;
            this.calculate();
        }
        /**
         * (Re-)Calculates the parameters of the cubic function.
         * See https://math.stackexchange.com/questions/3173469/calculate-cubic-equation-from-two-points-and-two-slopes-variably
         * and https://jirkadelloro.github.io/FUDGE/Documentation/Logs/190410_Notizen_LS
         */
        calculate() {
            if (!this.keyIn) {
                this.d = this.c = this.b = this.a = 0;
                return;
            }
            if (!this.keyOut || this.keyIn.Constant) {
                this.d = this.keyIn.Value;
                this.c = this.b = this.a = 0;
                return;
            }
            let x1 = this.keyOut.Time - this.keyIn.Time;
            this.d = this.keyIn.Value;
            this.c = this.keyIn.SlopeOut;
            this.a = (-x1 * (this.keyIn.SlopeOut + this.keyOut.SlopeIn) - 2 * this.keyIn.Value + 2 * this.keyOut.Value) / -Math.pow(x1, 3);
            this.b = (this.keyOut.SlopeIn - this.keyIn.SlopeOut - 3 * this.a * Math.pow(x1, 2)) / (2 * x1);
        }
    }
    FudgeCore.AnimationFunction = AnimationFunction;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="../Transfer/Serializer.ts"/>
// / <reference path="../Transfer/Mutable.ts"/>
var FudgeCore;
// / <reference path="../Transfer/Serializer.ts"/>
// / <reference path="../Transfer/Mutable.ts"/>
(function (FudgeCore) {
    /**
     * Holds information about set points in time, their accompanying values as well as their slopes.
     * Also holds a reference to the {@link AnimationFunction}s that come in and out of the sides. The {@link AnimationFunction}s are handled by the {@link AnimationSequence}s.
     * Saved inside an {@link AnimationSequence}.
     * @author Lukas Scheuerle, HFU, 2019
     */
    class AnimationKey extends FudgeCore.Mutable {
        constructor(_time = 0, _value = 0, _slopeIn = 0, _slopeOut = 0, _constant = false) {
            super();
            this.constant = false;
            this.slopeIn = 0;
            this.slopeOut = 0;
            this.time = _time;
            this.value = _value;
            this.slopeIn = _slopeIn;
            this.slopeOut = _slopeOut;
            this.constant = _constant;
            this.broken = this.slopeIn != -this.slopeOut;
            this.functionOut = new FudgeCore.AnimationFunction(this, null);
        }
        /**
         * Static comparation function to use in an array sort function to sort the keys by their time.
         * @param _a the animation key to check
         * @param _b the animation key to check against
         * @returns >0 if a>b, 0 if a=b, <0 if a<b
         */
        static compare(_a, _b) {
            return _a.time - _b.time;
        }
        get Time() {
            return this.time;
        }
        set Time(_time) {
            this.time = _time;
            this.functionIn.calculate();
            this.functionOut.calculate();
        }
        get Value() {
            return this.value;
        }
        set Value(_value) {
            this.value = _value;
            this.functionIn.calculate();
            this.functionOut.calculate();
        }
        get Constant() {
            return this.constant;
        }
        set Constant(_constant) {
            this.constant = _constant;
            this.functionIn.calculate();
            this.functionOut.calculate();
        }
        get SlopeIn() {
            return this.slopeIn;
        }
        set SlopeIn(_slope) {
            this.slopeIn = _slope;
            this.functionIn.calculate();
        }
        get SlopeOut() {
            return this.slopeOut;
        }
        set SlopeOut(_slope) {
            this.slopeOut = _slope;
            this.functionOut.calculate();
        }
        //#region transfer
        serialize() {
            let s = {};
            s.time = this.time;
            s.value = this.value;
            s.slopeIn = this.slopeIn;
            s.slopeOut = this.slopeOut;
            s.constant = this.constant;
            return s;
        }
        async deserialize(_serialization) {
            this.time = _serialization.time;
            this.value = _serialization.value;
            this.slopeIn = _serialization.slopeIn;
            this.slopeOut = _serialization.slopeOut;
            this.constant = _serialization.constant;
            this.broken = this.slopeIn != -this.slopeOut;
            return this;
        }
        getMutator() {
            return this.serialize();
        }
        reduceMutator(_mutator) {
            //
        }
    }
    FudgeCore.AnimationKey = AnimationKey;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A sequence of {@link AnimationKey}s that is mapped to an attribute of a {@link Node} or its {@link Component}s inside the {@link Animation}.
     * Provides functions to modify said keys
     * @author Lukas Scheuerle, HFU, 2019
     */
    class AnimationSequence extends FudgeCore.Mutable {
        constructor() {
            super(...arguments);
            this.keys = [];
        }
        get length() {
            return this.keys.length;
        }
        /**
         * Evaluates the sequence at the given point in time.
         * @param _time the point in time at which to evaluate the sequence in milliseconds.
         * @returns the value of the sequence at the given time. 0 if there are no keys.
         */
        evaluate(_time) {
            if (this.keys.length == 0)
                return 0; //TODO: shouldn't return 0 but something indicating no change, like null. probably needs to be changed in Node as well to ignore non-numeric values in the applyAnimation function
            if (this.keys.length == 1 || this.keys[0].Time >= _time)
                return this.keys[0].Value;
            for (let i = 0; i < this.keys.length - 1; i++) {
                if (this.keys[i].Time <= _time && this.keys[i + 1].Time > _time) {
                    return this.keys[i].functionOut.evaluate(_time);
                }
            }
            return this.keys[this.keys.length - 1].Value;
        }
        /**
         * Adds a new key to the sequence.
         * @param _key the key to add
         */
        addKey(_key) {
            this.keys.push(_key);
            this.keys.sort(FudgeCore.AnimationKey.compare);
            this.regenerateFunctions();
        }
        /**
         * Removes a given key from the sequence.
         * @param _key the key to remove
         */
        removeKey(_key) {
            for (let i = 0; i < this.keys.length; i++) {
                if (this.keys[i] == _key) {
                    this.keys.splice(i, 1);
                    this.regenerateFunctions();
                    return;
                }
            }
        }
        /**
         * Removes the Animation Key at the given index from the keys.
         * @param _index the zero-based index at which to remove the key
         * @returns the removed AnimationKey if successful, null otherwise.
         */
        removeKeyAtIndex(_index) {
            if (_index < 0 || _index >= this.keys.length) {
                return null;
            }
            let ak = this.keys[_index];
            this.keys.splice(_index, 1);
            this.regenerateFunctions();
            return ak;
        }
        /**
         * Gets a key from the sequence at the desired index.
         * @param _index the zero-based index at which to get the key
         * @returns the AnimationKey at the index if it exists, null otherwise.
         */
        getKey(_index) {
            if (_index < 0 || _index >= this.keys.length)
                return null;
            return this.keys[_index];
        }
        //#region transfer
        serialize() {
            let s = {
                keys: [],
                animationSequence: true
            };
            for (let i = 0; i < this.keys.length; i++) {
                s.keys[i] = this.keys[i].serialize();
            }
            return s;
        }
        async deserialize(_serialization) {
            for (let i = 0; i < _serialization.keys.length; i++) {
                // this.keys.push(<AnimationKey>Serializer.deserialize(_serialization.keys[i]));
                let k = new FudgeCore.AnimationKey();
                await k.deserialize(_serialization.keys[i]);
                this.keys[i] = k;
            }
            this.regenerateFunctions();
            return this;
        }
        reduceMutator(_mutator) {
            //
        }
        //#endregion
        /**
         * Utility function that (re-)generates all functions in the sequence.
         */
        regenerateFunctions() {
            for (let i = 0; i < this.keys.length; i++) {
                let f = new FudgeCore.AnimationFunction(this.keys[i]);
                this.keys[i].functionOut = f;
                if (i == this.keys.length - 1) {
                    //TODO: check if this is even useful. Maybe update the runcondition to length - 1 instead. Might be redundant if functionIn is removed, see TODO in AnimationKey.
                    f.setKeyOut = this.keys[0];
                    this.keys[0].functionIn = f;
                    break;
                }
                f.setKeyOut = this.keys[i + 1];
                this.keys[i + 1].functionIn = f;
            }
        }
    }
    FudgeCore.AnimationSequence = AnimationSequence;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Extension of AudioBuffer with a load method that creates a buffer in the {@link AudioManager}.default to be used with {@link ComponentAudio}
     * @authors Thomas Dorner, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2020
     */
    class Audio extends FudgeCore.Mutable {
        constructor(_url) {
            super();
            this.name = "Audio";
            this.idResource = undefined;
            this.buffer = undefined;
            this.path = undefined;
            this.url = undefined;
            this.ready = false;
            if (_url) {
                this.load(_url);
                this.name = _url.toString().split("/").pop();
            }
            FudgeCore.Project.register(this);
        }
        get isReady() {
            return this.ready;
        }
        /**
         * Asynchronously loads the audio (mp3) from the given url
         */
        async load(_url) {
            FudgeCore.Debug.fudge("AudioLoad", _url);
            this.url = _url;
            this.ready = false;
            this.path = new URL(this.url.toString(), FudgeCore.Project.baseURL);
            const response = await window.fetch(this.path.toString());
            const arrayBuffer = await response.arrayBuffer();
            let buffer = await FudgeCore.AudioManager.default.decodeAudioData(arrayBuffer);
            this.buffer = buffer;
            this.ready = true;
            this.dispatchEvent(new Event("ready" /* READY */));
        }
        //#region Transfer
        serialize() {
            return {
                url: this.url,
                idResource: this.idResource,
                name: this.name,
                type: this.type
            };
        }
        async deserialize(_serialization) {
            FudgeCore.Project.register(this, _serialization.idResource);
            await this.load(_serialization.url);
            this.name = _serialization.name;
            return this;
        }
        async mutate(_mutator) {
            let url = _mutator.url; // save url for reconstruction after exclusion
            if (_mutator.url != this.url.toString())
                this.load(_mutator.url);
            // except url from mutator for further processing
            delete (_mutator.url);
            super.mutate(_mutator);
            // reconstruct, for mutator may be kept by caller
            Reflect.set(_mutator, "url", url);
        }
        reduceMutator(_mutator) {
            // delete _mutator.idResource; 
            delete _mutator.ready;
        }
    }
    FudgeCore.Audio = Audio;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Extends the standard AudioContext for integration with FUDGE-graphs.
     * Creates a default object at startup to be addressed as AudioManager default.
     * Other objects of this class may be create for special purposes.
     */
    class AudioManager extends AudioContext {
        constructor(contextOptions) {
            super(contextOptions);
            this.graph = null;
            this.cmpListener = null;
            /**
             * Determines FUDGE-graph to listen to. Each {@link ComponentAudio} in the graph will connect to this contexts master gain, all others disconnect.
             */
            this.listenTo = (_graph) => {
                if (this.graph)
                    this.graph.broadcastEvent(new Event("childRemoveFromAudioGraph" /* CHILD_REMOVE */));
                if (!_graph)
                    return;
                this.graph = _graph;
                this.graph.broadcastEvent(new Event("childAppendToAudioGraph" /* CHILD_APPEND */));
            };
            /**
             * Retrieve the FUDGE-graph currently listening to
             */
            this.getGraphListeningTo = () => {
                return this.graph;
            };
            /**
             * Set the {@link ComponentAudioListener} that serves the spatial location and orientation for this contexts listener
             */
            this.listenWith = (_cmpListener) => {
                this.cmpListener = _cmpListener;
            };
            /**
             * Updates the spatial settings of the AudioNodes effected in the current FUDGE-graph
             */
            this.update = () => {
                this.graph.broadcastEvent(new Event("updateAudioGraph" /* UPDATE */));
                if (this.cmpListener)
                    this.cmpListener.update(this.listener);
            };
            this.gain = this.createGain();
            this.gain.connect(this.destination);
        }
        /**
         * Set the master volume
         */
        set volume(_value) {
            this.gain.gain.value = _value;
        }
        /**
         * Get the master volume
         */
        get volume() {
            return this.gain.gain.value;
        }
    }
    /** The default context that may be used throughout the project without the need to create others */
    AudioManager.default = new AudioManager({ latencyHint: "interactive", sampleRate: 44100 });
    FudgeCore.AudioManager = AudioManager;
})(FudgeCore || (FudgeCore = {}));
// namespace FudgeCore {
//     /**
//      * Enumerator for all possible Oscillator Types
//      */
//     type OSCILLATOR_TYPE = "sine" | "square" | "sawtooth" | "triangle" | "custom";
//     /**
//      * Interface to create Custom Oscillator Types.
//      * Start-/Endpoint of a custum curve e.g. sine curve.
//      * Both parameters need to be inbetween -1 and 1.
//      * @param startpoint startpoint of a curve 
//      * @param endpoint Endpoint of a curve 
//      */
//     interface OscillatorWave {
//         startpoint: number;
//         endpoint: number;
//     }
//     /**
//      * Add an {@link AudioFilter} to an {@link Audio]]
//      * @authors Thomas Dorner, HFU, 2019
//      */
//     export class AudioOscillator {
//         public audioOscillator: OscillatorNode; 
//         private frequency: number;
//         private oscillatorType: OSCILLATOR_TYPE;
//         private oscillatorWave: PeriodicWave;
//         private localGain: GainNode;
//         private localGainValue: number;
//         constructor(_audioSettings: AudioSettings, _oscillatorType?: OSCILLATOR_TYPE) {
//             this.audioOscillator = _audioSettings.getAudioContext().createOscillator();
//             this.localGain = _audioSettings.getAudioContext().createGain();
//             this.oscillatorType = _oscillatorType;
//             if (this.oscillatorType != "custom") {
//                 this.audioOscillator.type = this.oscillatorType;
//             }
//             else {
//                 if (!this.oscillatorWave) {
//                     this.audioOscillator.setPeriodicWave(this.oscillatorWave);
//                 }
//                 else {
//                     console.log("Create a Custom Periodic Wave first to use Custom Type");
//                 }
//             }
//         }
//         public setOscillatorType(_oscillatorType: OSCILLATOR_TYPE): void {
//             if (this.oscillatorType != "custom") {
//                 this.audioOscillator.type = this.oscillatorType;
//             }
//             else {
//                 if (!this.oscillatorWave) {
//                     this.audioOscillator.setPeriodicWave(this.oscillatorWave);
//                 }
//             }
//         }
//         public getOscillatorType(): OSCILLATOR_TYPE {
//             return this.oscillatorType;
//         }
//         public createPeriodicWave(_audioSettings: AudioSettings, _real: OscillatorWave, _imag: OscillatorWave): void {
//             let waveReal: Float32Array = new Float32Array(2);
//             waveReal[0] = _real.startpoint;
//             waveReal[1] = _real.endpoint;
//             let waveImag: Float32Array = new Float32Array(2);
//             waveImag[0] = _imag.startpoint;
//             waveImag[1] = _imag.endpoint;
//             this.oscillatorWave = _audioSettings.getAudioContext().createPeriodicWave(waveReal, waveImag);
//         }
//         public setLocalGain(_localGain: GainNode): void {
//             this.localGain = _localGain;
//         }
//         public getLocalGain(): GainNode {
//             return this.localGain;
//         }
//         public setLocalGainValue(_localGainValue: number): void {
//             this.localGainValue = _localGainValue;
//             this.localGain.gain.value = this.localGainValue;
//         }
//         public getLocalGainValue(): number {
//             return this.localGainValue;
//         }
//         public setFrequency(_audioSettings: AudioSettings, _frequency: number): void {
//             this.frequency = _frequency;
//             this.audioOscillator.frequency.setValueAtTime(this.frequency, _audioSettings.getAudioContext().currentTime);
//         }
//         public getFrequency(): number {
//             return this.frequency;
//         }
//         public createSnare(_audioSettings: AudioSettings): void {
//             this.setOscillatorType("triangle");
//             this.setFrequency(_audioSettings, 100);
//             this.setLocalGainValue(0);
//             this.localGain.gain.setValueAtTime(0, _audioSettings.getAudioContext().currentTime);
//             this.localGain.gain.exponentialRampToValueAtTime(0.01, _audioSettings.getAudioContext().currentTime + .1);
//             this.audioOscillator.connect(this.localGain);
//         }
//     }
// }
// / <reference path="../Time/Loop.ts"/>
// / <reference path="../Animation/Animation.ts"/>
var FudgeCore;
// / <reference path="../Time/Loop.ts"/>
// / <reference path="../Animation/Animation.ts"/>
(function (FudgeCore) {
    /**
     * Holds a reference to an {@link Animation} and controls it. Controls playback and playmode as well as speed.
     * @authors Lukas Scheuerle, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2021
     */
    class ComponentAnimator extends FudgeCore.Component {
        constructor(_animation = new FudgeCore.Animation(""), _playmode = FudgeCore.ANIMATION_PLAYMODE.LOOP, _playback = FudgeCore.ANIMATION_PLAYBACK.TIMEBASED_CONTINOUS) {
            super();
            this.scaleWithGameTime = true;
            this.#scale = 1;
            this.#previous = 0;
            //#endregion
            //#region updateAnimation
            /**
             * Updates the Animation.
             * Gets called every time the Loop fires the LOOP_FRAME Event.
             * Uses the built-in time unless a different time is specified.
             * May also be called from updateAnimation().
             */
            this.updateAnimationLoop = (_e, _time) => {
                if (this.animation.totalTime == 0)
                    return [null, 0];
                let time = _time || this.#timeLocal.get();
                if (this.playback == FudgeCore.ANIMATION_PLAYBACK.FRAMEBASED) {
                    time = this.#previous + (1000 / this.animation.fps);
                }
                let direction = this.animation.calculateDirection(time, this.playmode);
                time = this.animation.getModalTime(time, this.playmode, this.#timeLocal.getOffset());
                this.executeEvents(this.animation.getEventsToFire(this.#previous, time, this.playback, direction));
                if (this.#previous != time) {
                    this.#previous = time;
                    time = time % this.animation.totalTime;
                    let mutator = this.animation.getMutated(time, direction, this.playback);
                    if (this.node) {
                        this.node.applyAnimation(mutator);
                    }
                    return [mutator, time];
                }
                return [null, time];
            };
            /**
             * Updates the scale of the animation if the user changes it or if the global game timer changed its scale.
             */
            this.updateScale = () => {
                let newScale = this.#scale;
                if (this.scaleWithGameTime)
                    newScale *= FudgeCore.Time.game.getScale();
                this.#timeLocal.setScale(newScale);
            };
            this.animation = _animation;
            this.playmode = _playmode;
            this.playback = _playback;
            this.#timeLocal = new FudgeCore.Time();
            //TODO: update animation total time when loading a different animation?
            this.animation.calculateTotalTime();
            this.addEventListener("componentRemove" /* COMPONENT_REMOVE */, () => this.activate(false));
            this.addEventListener("componentAdd" /* COMPONENT_ADD */, () => {
                this.node.addEventListener("childRemove" /* CHILD_REMOVE */, () => this.activate(false));
                this.activate(true);
            });
        }
        #scale;
        #timeLocal;
        #previous;
        set scale(_scale) {
            this.#scale = _scale;
            this.updateScale();
        }
        get scale() {
            return this.#scale;
        }
        /**
         * Returns the current sample time of the animation
         */
        get time() {
            return this.#timeLocal.get() % this.animation.totalTime;
        }
        activate(_on) {
            super.activate(_on);
            if (!this.node)
                return;
            if (_on) {
                FudgeCore.Time.game.addEventListener("timeScaled" /* TIME_SCALED */, this.updateScale);
                this.node.addEventListener("renderPrepare" /* RENDER_PREPARE */, this.updateAnimationLoop);
            }
            else {
                FudgeCore.Time.game.addEventListener("timeScaled" /* TIME_SCALED */, this.updateScale);
                this.node.removeEventListener("renderPrepare" /* RENDER_PREPARE */, this.updateAnimationLoop);
            }
        }
        /**
         * Jumps to a certain time in the animation to play from there.
         */
        jumpTo(_time) {
            this.#timeLocal.set(_time);
            this.#previous = _time;
            _time = _time % this.animation.totalTime;
            let mutator = this.animation.getMutated(_time, this.animation.calculateDirection(_time, this.playmode), this.playback);
            this.node.applyAnimation(mutator);
        }
        /**
         * Jumps to a certain label in the animation if defined
         */
        jumpToLabel(_label) {
            let time = this.animation.labels[_label];
            if (time)
                this.jumpTo(time);
        }
        /**
         * Forces an update of the animation from outside. Used in the ViewAnimation. Shouldn't be used during the game.
         * @param _time the (unscaled) time to update the animation with.
         * @returns a Tupel containing the Mutator for Animation and the playmode corrected time.
         */
        updateAnimation(_time) {
            return this.updateAnimationLoop(null, _time);
        }
        //#region transfer
        serialize() {
            let serialization = super.serialize();
            serialization.idAnimation = this.animation.idResource;
            serialization.playmode = this.playmode;
            serialization.playback = this.playback;
            serialization.scale = this.scale;
            serialization.scaleWithGameTime = this.scaleWithGameTime;
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization[super.constructor.name]);
            this.animation = await FudgeCore.Project.getResource(_serialization.idAnimation);
            this.playback = _serialization.playback;
            this.playmode = _serialization.playmode;
            this.scale = _serialization.scale;
            this.scaleWithGameTime = _serialization.scaleWithGameTime;
            return this;
        }
        /**
         * Fires all custom events the Animation should have fired between the last frame and the current frame.
         * @param events a list of names of custom events to fire
         */
        executeEvents(events) {
            for (let i = 0; i < events.length; i++) {
                this.dispatchEvent(new Event(events[i]));
            }
        }
    }
    ComponentAnimator.iSubclass = FudgeCore.Component.registerSubclass(ComponentAnimator);
    FudgeCore.ComponentAnimator = ComponentAnimator;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let AUDIO_PANNER;
    (function (AUDIO_PANNER) {
        AUDIO_PANNER["CONE_INNER_ANGLE"] = "coneInnerAngle";
        AUDIO_PANNER["CONE_OUTER_ANGLE"] = "coneOuterAngle";
        AUDIO_PANNER["CONE_OUTER_GAIN"] = "coneOuterGain";
        AUDIO_PANNER["DISTANCE_MODEL"] = "distanceModel";
        AUDIO_PANNER["MAX_DISTANCE"] = "maxDistance";
        AUDIO_PANNER["PANNING_MODEL"] = "panningModel";
        AUDIO_PANNER["REF_DISTANCE"] = "refDistance";
        AUDIO_PANNER["ROLLOFF_FACTOR"] = "rolloffFactor";
    })(AUDIO_PANNER = FudgeCore.AUDIO_PANNER || (FudgeCore.AUDIO_PANNER = {}));
    let AUDIO_NODE_TYPE;
    (function (AUDIO_NODE_TYPE) {
        AUDIO_NODE_TYPE[AUDIO_NODE_TYPE["SOURCE"] = 0] = "SOURCE";
        AUDIO_NODE_TYPE[AUDIO_NODE_TYPE["PANNER"] = 1] = "PANNER";
        AUDIO_NODE_TYPE[AUDIO_NODE_TYPE["GAIN"] = 2] = "GAIN";
    })(AUDIO_NODE_TYPE = FudgeCore.AUDIO_NODE_TYPE || (FudgeCore.AUDIO_NODE_TYPE = {}));
    /**
     * Builds a minimal audio graph (by default in {@link AudioManager}.default) and synchronizes it with the containing {@link Node}
     * ```plaintext
     * ‚îå AudioManager(.default) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     * ‚îÇ ‚îå ComponentAudio ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îÇ
     * ‚îÇ ‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
     * ‚îÇ ‚îÇ    ‚îÇsource‚îÇ ‚Üí ‚îÇpanner‚îÇ ‚Üí ‚îÇ gain ‚îÇ ‚Üí ‚îÇ gain ‚îÇ ‚îÇ
     * ‚îÇ ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
     * ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ
     * ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     * ```
     * @authors Thomas Dorner, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ComponentAudio extends FudgeCore.Component {
        constructor(_audio = null, _loop = false, _start = false, _audioManager = FudgeCore.AudioManager.default) {
            super();
            /** places and directs the panner relative to the world transform of the {@link Node}  */
            this.mtxPivot = FudgeCore.Matrix4x4.IDENTITY();
            this.singleton = false;
            this.playing = false;
            this.listened = false;
            //#endregion
            this.hndAudioReady = (_event) => {
                FudgeCore.Debug.fudge("Audio start", Reflect.get(_event.target, "url"));
                if (this.playing)
                    this.play(true);
            };
            this.hndAudioEnded = (_event) => {
                // Debug.fudge("Audio ended", Reflect.get(_event.target, "url"));
                this.playing = false;
            };
            /**
             * Automatically connects/disconnects AudioNodes when adding/removing this component to/from a node.
             * Therefore unused AudioNodes may be garbage collected when an unused component is collected
             */
            this.handleAttach = (_event) => {
                // Debug.log(_event);
                if (_event.type == "componentAdd" /* COMPONENT_ADD */) {
                    this.node.addEventListener("childAppendToAudioGraph" /* CHILD_APPEND */, this.handleGraph, true);
                    this.node.addEventListener("childRemoveFromAudioGraph" /* CHILD_REMOVE */, this.handleGraph, true);
                    this.node.addEventListener("updateAudioGraph" /* UPDATE */, this.update, true);
                    this.listened = this.node.isDescendantOf(FudgeCore.AudioManager.default.getGraphListeningTo());
                }
                else {
                    this.node.removeEventListener("childAppendToAudioGraph" /* CHILD_APPEND */, this.handleGraph, true);
                    this.node.removeEventListener("childRemoveFromAudioGraph" /* CHILD_REMOVE */, this.handleGraph, true);
                    this.node.removeEventListener("updateAudioGraph" /* UPDATE */, this.update, true);
                    this.listened = false;
                }
                this.updateConnection();
            };
            /**
             * Automatically connects/disconnects AudioNodes when appending/removing the FUDGE-graph the component is in.
             */
            this.handleGraph = (_event) => {
                // Debug.log(_event);
                this.listened = (_event.type == "childAppendToAudioGraph" /* CHILD_APPEND */);
                this.updateConnection();
            };
            /**
             * Updates the panner node, its position and direction, using the worldmatrix of the container and the pivot of this component.
             */
            this.update = (_event) => {
                let mtxResult = this.mtxPivot;
                if (this.node)
                    mtxResult = FudgeCore.Matrix4x4.MULTIPLICATION(this.node.mtxWorld, this.mtxPivot);
                // Debug.log(mtxResult.toString());
                let position = mtxResult.translation;
                let forward = FudgeCore.Vector3.TRANSFORMATION(FudgeCore.Vector3.Z(1), mtxResult, false);
                this.panner.positionX.value = position.x;
                this.panner.positionY.value = position.y;
                this.panner.positionZ.value = position.z;
                this.panner.orientationX.value = forward.x;
                this.panner.orientationY.value = forward.y;
                this.panner.orientationZ.value = forward.z;
                FudgeCore.Recycler.store(forward);
                // TODO: examine why the following produces erroneous results, see test "Spatial Audio"
                if (this.node)
                    FudgeCore.Recycler.store(mtxResult);
            };
            this.install(_audioManager);
            this.createSource(_audio, _loop);
            this.addEventListener("componentAdd" /* COMPONENT_ADD */, this.handleAttach);
            this.addEventListener("componentRemove" /* COMPONENT_REMOVE */, this.handleAttach);
            if (_start)
                this.play(_start);
        }
        set volume(_value) {
            this.gain.gain.value = _value;
        }
        get volume() {
            return this.gain.gain.value;
        }
        set loop(_on) {
            this.source.loop = _on;
        }
        get loop() {
            return this.source.loop;
        }
        get isPlaying() {
            return this.playing;
        }
        get isAttached() {
            return this.node != null;
        }
        get isListened() {
            return this.listened;
        }
        setAudio(_audio) {
            this.createSource(_audio, this.source.loop);
        }
        getAudio() {
            return this.audio;
        }
        /**
         * Set the property of the panner to the given value. Use to manipulate range and rolloff etc.
         */
        setPanner(_property, _value) {
            Reflect.set(this.panner, _property, _value);
        }
        // TODO: may be used for serialization of AudioNodes
        getMutatorOfNode(_type) {
            let node = this.getAudioNode(_type);
            let mutator = FudgeCore.getMutatorOfArbitrary(node);
            return mutator;
        }
        /**
         * Returns the specified AudioNode of the standard graph for further manipulation
         */
        getAudioNode(_type) {
            switch (_type) {
                case AUDIO_NODE_TYPE.SOURCE: return this.source;
                case AUDIO_NODE_TYPE.PANNER: return this.panner;
                case AUDIO_NODE_TYPE.GAIN: return this.gain;
            }
        }
        /**
         * Start or stop playing the audio
         */
        play(_on) {
            if (_on) {
                if (this.audio.isReady) {
                    this.createSource(this.audio, this.source.loop);
                    this.source.start(0, 0);
                }
                else {
                    this.audio.addEventListener("ready" /* READY */, this.hndAudioReady);
                }
                this.source.addEventListener("ended" /* ENDED */, this.hndAudioEnded);
            }
            else
                try {
                    this.source.stop();
                }
                catch (_error) { /* catch exception when source hasn't been started... */ }
            this.playing = _on;
        }
        /**
         * Inserts AudioNodes between the panner and the local gain of this {@link ComponentAudio}
         * _input and _output may be the same AudioNode, if there is only one to insert,
         * or may have multiple AudioNode between them to create an effect-graph.\
         * Note that {@link ComponentAudio} does not keep track of inserted AudioNodes!
         * ```plaintext
         * ‚îå AudioManager(.default) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         * ‚îÇ ‚îå ComponentAudio ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îÇ
         * ‚îÇ ‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
         * ‚îÇ ‚îÇ    ‚îÇsource‚îÇ ‚Üí ‚îÇpanner‚îÇ ‚Üí ‚îÇ_input‚îÇ ‚Üí ...  ‚Üí ‚îÇ_output‚îÇ ‚Üí ‚îÇ gain ‚îÇ ‚Üí ‚îÇ gain ‚îÇ ‚îÇ
         * ‚îÇ ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
         * ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ
         * ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         * ```
         */
        insertAudioNodes(_input, _output) {
            this.panner.disconnect(0);
            if (!_input && !_output) {
                this.panner.connect(this.gain);
                return;
            }
            this.panner.connect(_input);
            _output.connect(this.gain);
        }
        /**
         * Activate override. Connects or disconnects AudioNodes
         */
        activate(_on) {
            super.activate(_on);
            this.updateConnection();
        }
        /**
         * Connects this components gain-node to the gain node of the AudioManager this component runs on.
         * Only call this method if the component is not attached to a {@link Node} but needs to be heard.
         */
        connect(_on) {
            if (_on)
                this.gain.connect(this.audioManager.gain);
            else
                this.gain.disconnect(this.audioManager.gain);
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.idResource = this.audio.idResource;
            serialization.playing = this.playing;
            serialization.loop = this.loop;
            serialization.volume = this.volume;
            // console.log(this.getMutatorOfNode(AUDIO_NODE_TYPE.PANNER));
            // TODO: serialize panner parameters
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            let audio = await FudgeCore.Project.getResource(_serialization.idResource);
            this.createSource(audio, _serialization.loop);
            this.volume = _serialization.volume;
            this.play(_serialization.playing);
            return this;
        }
        getMutator() {
            let mutator = super.getMutator(true);
            let audio = mutator.audio;
            delete mutator.audio; // just to rearrange in interfaces...
            mutator.loop = this.loop;
            mutator.volume = this.volume;
            mutator.audio = audio; //... so audio comes last
            return mutator;
        }
        async mutate(_mutator) {
            await super.mutate(_mutator);
            this.volume = _mutator.volume;
            this.loop = _mutator.loop;
        }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
            delete _mutator.listened;
        }
        install(_audioManager = FudgeCore.AudioManager.default) {
            let active = this.isActive;
            this.activate(false);
            this.audioManager = _audioManager;
            this.panner = _audioManager.createPanner();
            this.gain = _audioManager.createGain();
            this.panner.connect(this.gain);
            this.gain.connect(_audioManager.gain);
            this.activate(active);
        }
        createSource(_audio, _loop) {
            if (this.source) {
                this.source.disconnect();
                this.source.buffer = null;
            }
            this.source = this.audioManager.createBufferSource();
            this.source.connect(this.panner);
            if (_audio) {
                this.audio = _audio;
                this.source.buffer = _audio.buffer;
            }
            this.source.loop = _loop;
        }
        updateConnection() {
            try {
                this.connect(this.isActive && this.isAttached && this.listened);
            }
            catch (_error) {
                // nop
            }
        }
    }
    ComponentAudio.iSubclass = FudgeCore.Component.registerSubclass(ComponentAudio);
    FudgeCore.ComponentAudio = ComponentAudio;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Serves to set the spatial location and orientation of AudioListeners relative to the
     * world transform of the {@link Node} it is attached to.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ComponentAudioListener extends FudgeCore.Component {
        constructor() {
            super(...arguments);
            this.mtxPivot = FudgeCore.Matrix4x4.IDENTITY();
        }
        /**
         * Updates the position and orientation of the given AudioListener
         */
        update(_listener) {
            let mtxResult = this.mtxPivot;
            if (this.node)
                mtxResult = FudgeCore.Matrix4x4.MULTIPLICATION(this.node.mtxWorld, this.mtxPivot);
            // Debug.log(mtxResult.toString());
            let position = mtxResult.translation;
            let forward = FudgeCore.Vector3.TRANSFORMATION(FudgeCore.Vector3.Z(1), mtxResult, false);
            let up = FudgeCore.Vector3.TRANSFORMATION(FudgeCore.Vector3.Y(), mtxResult, false);
            if (_listener.positionX != undefined) {
                _listener.positionX.value = position.x;
                _listener.positionY.value = position.y;
                _listener.positionZ.value = position.z;
                _listener.forwardX.value = forward.x;
                _listener.forwardY.value = forward.y;
                _listener.forwardZ.value = forward.z;
                _listener.upX.value = up.x;
                _listener.upY.value = up.y;
                _listener.upZ.value = up.z;
            }
            else {
                // Firefox still uses deprecated methods. TODO: delete as soon as possible!
                _listener.setPosition(position.x, position.y, position.z);
                _listener.setOrientation(forward.x, forward.y, forward.z, up.x, up.y, up.z);
            }
            FudgeCore.Recycler.store(forward);
            FudgeCore.Recycler.store(up);
            // Debug.log(mtxResult.translation.toString(), forward.toString(), up.toString());
        }
    }
    ComponentAudioListener.iSubclass = FudgeCore.Component.registerSubclass(ComponentAudioListener);
    FudgeCore.ComponentAudioListener = ComponentAudioListener;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="Component.ts"/>
var FudgeCore;
// / <reference path="Component.ts"/>
(function (FudgeCore) {
    let FIELD_OF_VIEW;
    (function (FIELD_OF_VIEW) {
        FIELD_OF_VIEW[FIELD_OF_VIEW["HORIZONTAL"] = 0] = "HORIZONTAL";
        FIELD_OF_VIEW[FIELD_OF_VIEW["VERTICAL"] = 1] = "VERTICAL";
        FIELD_OF_VIEW[FIELD_OF_VIEW["DIAGONAL"] = 2] = "DIAGONAL";
    })(FIELD_OF_VIEW = FudgeCore.FIELD_OF_VIEW || (FudgeCore.FIELD_OF_VIEW = {}));
    /**
     * Defines identifiers for the various projections a camera can provide.
     * TODO: change back to number enum if strings not needed
     */
    let PROJECTION;
    (function (PROJECTION) {
        PROJECTION["CENTRAL"] = "central";
        PROJECTION["ORTHOGRAPHIC"] = "orthographic";
        PROJECTION["DIMETRIC"] = "dimetric";
        PROJECTION["STEREO"] = "stereo";
    })(PROJECTION = FudgeCore.PROJECTION || (FudgeCore.PROJECTION = {}));
    /**
     * The camera component holds the projection-matrix and other data needed to render a scene from the perspective of the node it is attached to.
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ComponentCamera extends FudgeCore.Component {
        constructor() {
            super(...arguments);
            this.mtxPivot = FudgeCore.Matrix4x4.IDENTITY();
            this.clrBackground = new FudgeCore.Color(0, 0, 0, 1); // The color of the background the camera will render.
            this.projection = PROJECTION.CENTRAL;
            this.mtxProjection = new FudgeCore.Matrix4x4; // The matrix to multiply each scene objects transformation by, to determine where it will be drawn.
            this.fieldOfView = 45; // The camera's sensorangle.
            this.aspectRatio = 1.0;
            this.direction = FIELD_OF_VIEW.DIAGONAL;
            this.near = 1;
            this.far = 2000;
            this.backgroundEnabled = true; // Determines whether or not the background of this camera will be rendered.
            //#endregion
        }
        //private orthographic: boolean = false; // Determines whether the image will be rendered with perspective or orthographic projection.
        #mtxWorldToView;
        // TODO: examine, if background should be an attribute of Camera or Viewport
        get mtxWorld() {
            let mtxCamera = this.mtxPivot.clone;
            try {
                mtxCamera = FudgeCore.Matrix4x4.MULTIPLICATION(this.node.mtxWorld, this.mtxPivot);
            }
            catch (_error) {
                // no container node or no world transformation found -> continue with pivot only
            }
            return mtxCamera;
        }
        /**
         * Returns the multiplication of the worldtransformation of the camera container, the pivot of this camera and the inversion of the projection matrix
         * yielding the worldspace to viewspace matrix
         */
        get mtxWorldToView() {
            if (this.#mtxWorldToView)
                return this.#mtxWorldToView;
            //TODO: optimize, no need to recalculate if neither mtxWorld nor pivot have changed
            let mtxCamera = this.mtxWorld;
            let mtxInversion = FudgeCore.Matrix4x4.INVERSION(mtxCamera);
            this.#mtxWorldToView = FudgeCore.Matrix4x4.MULTIPLICATION(this.mtxProjection, mtxInversion);
            FudgeCore.Recycler.store(mtxCamera);
            FudgeCore.Recycler.store(mtxInversion);
            return this.#mtxWorldToView;
        }
        resetWorldToView() {
            this.#mtxWorldToView = null;
        }
        getProjection() {
            return this.projection;
        }
        getBackgroundEnabled() {
            return this.backgroundEnabled;
        }
        getAspect() {
            return this.aspectRatio;
        }
        getFieldOfView() {
            return this.fieldOfView;
        }
        getDirection() {
            return this.direction;
        }
        getNear() {
            return this.near;
        }
        getFar() {
            return this.far;
        }
        /**
         * Set the camera to perspective projection. The world origin is in the center of the canvaselement.
         * @param _aspect The aspect ratio between width and height of projectionspace.(Default = canvas.clientWidth / canvas.ClientHeight)
         * @param _fieldOfView The field of view in Degrees. (Default = 45)
         * @param _direction The plane on which the fieldOfView-Angle is given
         */
        projectCentral(_aspect = this.aspectRatio, _fieldOfView = this.fieldOfView, _direction = this.direction, _near = 1, _far = 2000) {
            this.aspectRatio = _aspect;
            this.fieldOfView = _fieldOfView;
            this.direction = _direction;
            this.projection = PROJECTION.CENTRAL;
            this.near = _near;
            this.far = _far;
            this.mtxProjection = FudgeCore.Matrix4x4.PROJECTION_CENTRAL(_aspect, this.fieldOfView, _near, _far, this.direction); // TODO: remove magic numbers
        }
        /**
         * Set the camera to orthographic projection. The origin is in the top left corner of the canvas.
         * @param _left The positionvalue of the projectionspace's left border. (Default = 0)
         * @param _right The positionvalue of the projectionspace's right border. (Default = canvas.clientWidth)
         * @param _bottom The positionvalue of the projectionspace's bottom border.(Default = canvas.clientHeight)
         * @param _top The positionvalue of the projectionspace's top border.(Default = 0)
         */
        projectOrthographic(_left = 0, _right = FudgeCore.Render.getCanvas().clientWidth, _bottom = FudgeCore.Render.getCanvas().clientHeight, _top = 0) {
            this.projection = PROJECTION.ORTHOGRAPHIC;
            this.mtxProjection = FudgeCore.Matrix4x4.PROJECTION_ORTHOGRAPHIC(_left, _right, _bottom, _top, 400, -400); // TODO: examine magic numbers!
        }
        /**
         * Return the calculated dimension of a projection surface in the hypothetical distance of 1 to the camera
         */
        getProjectionRectangle() {
            let tanFov = Math.tan(Math.PI * this.fieldOfView / 360); // Half of the angle, to calculate dimension from the center -> right angle
            let tanHorizontal = 0;
            let tanVertical = 0;
            if (this.direction == FIELD_OF_VIEW.DIAGONAL) {
                let aspect = Math.sqrt(this.aspectRatio);
                tanHorizontal = tanFov * aspect;
                tanVertical = tanFov / aspect;
            }
            else if (this.direction == FIELD_OF_VIEW.VERTICAL) {
                tanVertical = tanFov;
                tanHorizontal = tanVertical * this.aspectRatio;
            }
            else { //FOV_DIRECTION.HORIZONTAL
                tanHorizontal = tanFov;
                tanVertical = tanHorizontal / this.aspectRatio;
            }
            return FudgeCore.Rectangle.GET(0, 0, tanHorizontal * 2, tanVertical * 2);
        }
        pointWorldToClip(_pointInWorldSpace) {
            let result;
            let m = this.mtxWorldToView.get();
            let w = m[3] * _pointInWorldSpace.x + m[7] * _pointInWorldSpace.y + m[11] * _pointInWorldSpace.z + m[15];
            result = FudgeCore.Vector3.TRANSFORMATION(_pointInWorldSpace, this.mtxWorldToView);
            result.scale(1 / w);
            return result;
        }
        pointClipToWorld(_pointInClipSpace) {
            let mtxViewToWorld = FudgeCore.Matrix4x4.INVERSION(this.mtxWorldToView);
            let m = mtxViewToWorld.get();
            let rayWorld = FudgeCore.Vector3.TRANSFORMATION(_pointInClipSpace, mtxViewToWorld, true);
            let w = m[3] * _pointInClipSpace.x + m[7] * _pointInClipSpace.y + m[11] * _pointInClipSpace.z + m[15];
            rayWorld.scale(1 / w);
            return rayWorld;
        }
        //#region Transfer
        serialize() {
            let serialization = {
                backgroundColor: this.clrBackground,
                backgroundEnabled: this.backgroundEnabled,
                projection: this.projection,
                fieldOfView: this.fieldOfView,
                direction: this.direction,
                aspect: this.aspectRatio,
                pivot: this.mtxPivot.serialize(),
                [super.constructor.name]: super.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            this.clrBackground = _serialization.backgroundColor;
            this.backgroundEnabled = _serialization.backgroundEnabled;
            this.projection = _serialization.projection;
            this.fieldOfView = _serialization.fieldOfView;
            this.aspectRatio = _serialization.aspect;
            this.direction = _serialization.direction;
            await this.mtxPivot.deserialize(_serialization.pivot);
            await super.deserialize(_serialization[super.constructor.name]);
            switch (this.projection) {
                case PROJECTION.ORTHOGRAPHIC:
                    this.projectOrthographic(); // TODO: serialize and deserialize parameters
                    break;
                case PROJECTION.CENTRAL:
                    this.projectCentral();
                    break;
            }
            return this;
        }
        getMutatorAttributeTypes(_mutator) {
            let types = super.getMutatorAttributeTypes(_mutator);
            if (types.direction)
                types.direction = FIELD_OF_VIEW;
            if (types.projection)
                types.projection = PROJECTION;
            return types;
        }
        async mutate(_mutator) {
            super.mutate(_mutator);
            switch (this.projection) {
                case PROJECTION.CENTRAL:
                    this.projectCentral(this.aspectRatio, this.fieldOfView, this.direction);
                    break;
            }
        }
        reduceMutator(_mutator) {
            delete _mutator.transform;
            super.reduceMutator(_mutator);
        }
    }
    ComponentCamera.iSubclass = FudgeCore.Component.registerSubclass(ComponentCamera);
    FudgeCore.ComponentCamera = ComponentCamera;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Baseclass for different kinds of lights.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Light extends FudgeCore.Mutable {
        constructor(_color = new FudgeCore.Color(1, 1, 1, 1)) {
            super();
            this.color = _color;
        }
        getType() {
            return this.constructor;
        }
        serialize() {
            let serialization = {
                color: this.color.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            await this.color.deserialize(_serialization.color);
            return this;
        }
        reduceMutator() { }
    }
    FudgeCore.Light = Light;
    /**
     * Ambient light, coming from all directions, illuminating everything with its color independent of position and orientation (like a foggy day or in the shades)
     * ```plaintext
     * ~ ~ ~
     *  ~ ~ ~
     * ```
     */
    class LightAmbient extends Light {
        constructor(_color = new FudgeCore.Color(1, 1, 1, 1)) {
            super(_color);
        }
    }
    FudgeCore.LightAmbient = LightAmbient;
    /**
     * Directional light, illuminating everything from a specified direction with its color (like standing in bright sunlight)
     * ```plaintext
     * --->
     * --->
     * --->
     * ```
     */
    class LightDirectional extends Light {
        constructor(_color = new FudgeCore.Color(1, 1, 1, 1)) {
            super(_color);
        }
    }
    FudgeCore.LightDirectional = LightDirectional;
    /**
     * Omnidirectional light emitting from its position, illuminating objects depending on their position and distance with its color (like a colored light bulb)
     * ```plaintext
     *         .\|/.
     *        -- o --
     *         ¬¥/|\`
     * ```
     */
    class LightPoint extends Light {
        constructor() {
            super(...arguments);
            this.range = 10;
        }
    }
    FudgeCore.LightPoint = LightPoint;
    /**
     * Spot light emitting within a specified angle from its position, illuminating objects depending on their position and distance with its color
     * ```plaintext
     *          o
     *         /|\
     *        / | \
     * ```
     */
    class LightSpot extends Light {
    }
    FudgeCore.LightSpot = LightSpot;
})(FudgeCore || (FudgeCore = {}));
///<reference path="../Light/Light.ts"/>
var FudgeCore;
///<reference path="../Light/Light.ts"/>
(function (FudgeCore) {
    /**
     * Defines identifiers for the various types of light this component can provide.
     */
    // export let LIGHT_TYPE: { [type: string]: string } = {
    let LIGHT_TYPE;
    (function (LIGHT_TYPE) {
        LIGHT_TYPE["AMBIENT"] = "LightAmbient";
        LIGHT_TYPE["DIRECTIONAL"] = "LightDirectional";
        LIGHT_TYPE["POINT"] = "LightPoint";
        LIGHT_TYPE["SPOT"] = "LightSpot";
    })(LIGHT_TYPE = FudgeCore.LIGHT_TYPE || (FudgeCore.LIGHT_TYPE = {}));
    /**
      * Attaches a {@link Light} to the node
      * @authors Jirka Dell'Oro-Friedl, HFU, 2019
      */
    class ComponentLight extends FudgeCore.Component {
        constructor(_light = new FudgeCore.LightAmbient()) {
            super();
            // private static constructors: { [type: string]: General } = { [LIGHT_TYPE.AMBIENT]: LightAmbient, [LIGHT_TYPE.DIRECTIONAL]: LightDirectional, [LIGHT_TYPE.POINT]: LightPoint, [LIGHT_TYPE.SPOT]: LightSpot };
            this.mtxPivot = FudgeCore.Matrix4x4.IDENTITY();
            this.light = null;
            this.singleton = false;
            this.light = _light;
        }
        setType(_class) {
            let mtrOld = {};
            if (this.light)
                mtrOld = this.light.getMutator();
            this.light = new _class();
            this.light.mutate(mtrOld);
        }
        serialize() {
            let serialization = {
                pivot: this.mtxPivot.serialize(),
                light: FudgeCore.Serializer.serialize(this.light)
            };
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization[super.constructor.name]);
            await this.mtxPivot.deserialize(_serialization.pivot);
            this.light = await FudgeCore.Serializer.deserialize(_serialization.light);
            return this;
        }
        getMutator() {
            let mutator = super.getMutator(true);
            mutator.type = this.light.getType().name;
            return mutator;
        }
        getMutatorAttributeTypes(_mutator) {
            let types = super.getMutatorAttributeTypes(_mutator);
            if (types.type)
                types.type = LIGHT_TYPE;
            return types;
        }
        async mutate(_mutator) {
            let type = _mutator.type;
            if (type != this.light.constructor.name)
                this.setType(FudgeCore.Serializer.getConstructor(type));
            delete (_mutator.type); // exclude light type from further mutation
            super.mutate(_mutator);
            _mutator.type = type; // reconstruct mutator
        }
    }
    ComponentLight.iSubclass = FudgeCore.Component.registerSubclass(ComponentLight);
    FudgeCore.ComponentLight = ComponentLight;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Attaches a {@link Material} to the node
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019 - 2021
     */
    class ComponentMaterial extends FudgeCore.Component {
        // public mutatorCoat: MutatorForComponent;
        constructor(_material = null) {
            super();
            this.clrPrimary = FudgeCore.Color.CSS("white");
            this.clrSecondary = FudgeCore.Color.CSS("white");
            this.mtxPivot = FudgeCore.Matrix3x3.IDENTITY();
            //** support sorting of objects with transparency when rendering, render objects in the back first */
            this.sortForAlpha = false;
            this.material = _material;
            // this.mutatorCoat = _material.getCoat().getMutatorForComponent();
        }
        //#region Transfer
        serialize() {
            let serialization = {
                sortForAlpha: this.sortForAlpha,
                clrPrimary: this.clrPrimary.serialize(),
                clrSecondary: this.clrSecondary.serialize(),
                pivot: this.mtxPivot.serialize(),
                [super.constructor.name]: super.serialize(),
                idMaterial: this.material.idResource
            };
            return serialization;
        }
        async deserialize(_serialization) {
            this.material = await FudgeCore.Project.getResource(_serialization.idMaterial);
            await this.clrPrimary.deserialize(_serialization.clrPrimary);
            await this.clrSecondary.deserialize(_serialization.clrSecondary);
            this.sortForAlpha = _serialization.sortForAlpha;
            await this.mtxPivot.deserialize(_serialization.pivot);
            await super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
    }
    ComponentMaterial.iSubclass = FudgeCore.Component.registerSubclass(ComponentMaterial);
    FudgeCore.ComponentMaterial = ComponentMaterial;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Attaches a {@link Mesh} to the node
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ComponentMesh extends FudgeCore.Component {
        constructor(_mesh = null) {
            super();
            this.mtxPivot = FudgeCore.Matrix4x4.IDENTITY();
            this.mtxWorld = FudgeCore.Matrix4x4.IDENTITY();
            this.mesh = null;
            this.mesh = _mesh;
        }
        get radius() {
            let scaling = this.mtxWorld.scaling;
            let scale = Math.max(Math.abs(scaling.x), Math.abs(scaling.y), Math.abs(scaling.z));
            return this.mesh.radius * scale;
        }
        // TODO: remove or think if the transformed bounding box is of value or can be made to be
        // public get boundingBox(): Box {
        //   let box: Box = Recycler.get(Box);
        //   box.set(
        //     Vector3.TRANSFORMATION(this.mesh.boundingBox.min, this.mtxWorld, true),
        //     Vector3.TRANSFORMATION(this.mesh.boundingBox.max, this.mtxWorld, true)
        //   );
        //   return box;
        // }
        //#region Transfer
        serialize() {
            let serialization;
            /* at this point of time, serialization as resource and as inline object is possible. TODO: check if inline becomes obsolete */
            let idMesh = this.mesh.idResource;
            if (idMesh)
                serialization = { idMesh: idMesh };
            else
                serialization = { mesh: FudgeCore.Serializer.serialize(this.mesh) };
            serialization.pivot = this.mtxPivot.serialize();
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            let mesh;
            if (_serialization.idMesh)
                mesh = await FudgeCore.Project.getResource(_serialization.idMesh);
            else
                mesh = await FudgeCore.Serializer.deserialize(_serialization.mesh);
            this.mesh = mesh;
            await this.mtxPivot.deserialize(_serialization.pivot);
            await super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        getMutatorForUserInterface() {
            let mutator = this.getMutator();
            // if (!this.mesh)
            //   mutator.mesh = Mesh;
            return mutator;
        }
    }
    ComponentMesh.iSubclass = FudgeCore.Component.registerSubclass(ComponentMesh);
    FudgeCore.ComponentMesh = ComponentMesh;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Base class for scripts the user writes
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Component
     */
    class ComponentScript extends FudgeCore.Component {
        constructor() {
            super();
            this.singleton = false;
        }
        serialize() {
            return this.getMutator();
        }
        async deserialize(_serialization) {
            this.mutate(_serialization);
            return this;
        }
    }
    // registering this doesn't make sense, only its subclasses. Or this component must refer to scripts to be attached to this component
    // TODO: rethink & refactor
    ComponentScript.iSubclass = FudgeCore.Component.registerSubclass(ComponentScript);
    FudgeCore.ComponentScript = ComponentScript;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let BASE;
    (function (BASE) {
        BASE[BASE["SELF"] = 0] = "SELF";
        BASE[BASE["PARENT"] = 1] = "PARENT";
        BASE[BASE["WORLD"] = 2] = "WORLD";
        BASE[BASE["NODE"] = 3] = "NODE";
    })(BASE = FudgeCore.BASE || (FudgeCore.BASE = {}));
    /**
     * Attaches a transform-[[Matrix4x4} to the node, moving, scaling and rotating it in space relative to its parent.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ComponentTransform extends FudgeCore.Component {
        constructor(_mtxInit = FudgeCore.Matrix4x4.IDENTITY()) {
            super();
            this.mtxLocal = _mtxInit;
        }
        //#region Transformations respecting the hierarchy
        /**
         * Adjusts the rotation to point the z-axis directly at the given target point in world space and tilts it to accord with the given up vector,
         * respectively calculating yaw and pitch. If no up vector is given, the previous up-vector is used.
         */
        lookAt(_targetWorld, _up) {
            let container = this.node;
            if (!container && !container.getParent())
                return this.mtxLocal.lookAt(_targetWorld, _up);
            // component is attached to a child node -> transform respecting the hierarchy
            let mtxWorld = container.mtxWorld.clone;
            mtxWorld.lookAt(_targetWorld, _up, true);
            let mtxLocal = FudgeCore.Matrix4x4.RELATIVE(mtxWorld, null, container.getParent().mtxWorldInverse);
            this.mtxLocal = mtxLocal;
        }
        /**
         * Adjusts the rotation to match its y-axis with the given up-vector and facing its z-axis toward the given target at minimal angle,
         * respectively calculating yaw only. If no up vector is given, the previous up-vector is used.
         */
        showTo(_targetWorld, _up) {
            let container = this.node;
            if (!container && !container.getParent())
                return this.mtxLocal.showTo(_targetWorld, _up);
            // component is attached to a child node -> transform respecting the hierarchy
            let mtxWorld = container.mtxWorld.clone;
            mtxWorld.showTo(_targetWorld, _up, true);
            let mtxLocal = FudgeCore.Matrix4x4.RELATIVE(mtxWorld, null, container.getParent().mtxWorldInverse);
            this.mtxLocal = mtxLocal;
        }
        /**
         * recalculates this local matrix to yield the identical world matrix based on the given node.
         * Use rebase before appending the container of this component to another node while preserving its transformation in the world.
         */
        rebase(_node = null) {
            let mtxResult = this.mtxLocal;
            let container = this.node;
            if (container)
                mtxResult = container.mtxWorld;
            if (_node)
                mtxResult = FudgeCore.Matrix4x4.RELATIVE(mtxResult, null, _node.mtxWorldInverse);
            this.mtxLocal = mtxResult;
        }
        /**
         * Applies the given transformation relative to the selected base (SELF, PARENT, WORLD) or a particular other node (NODE)
         */
        transform(_mtxTransform, _base = BASE.SELF, _node = null) {
            switch (_base) {
                case BASE.SELF:
                    this.mtxLocal.multiply(_mtxTransform);
                    break;
                case BASE.PARENT:
                    this.mtxLocal.multiply(_mtxTransform, true);
                    break;
                case BASE.NODE:
                    if (!_node)
                        throw new Error("BASE.NODE requires a node given as base");
                case BASE.WORLD:
                    this.rebase(_node);
                    this.mtxLocal.multiply(_mtxTransform, true);
                    let node = this.node;
                    if (node) {
                        let mtxTemp;
                        if (_base == BASE.NODE) {
                            // fix mtxWorld of container for subsequent rebasing 
                            mtxTemp = FudgeCore.Matrix4x4.MULTIPLICATION(_node.mtxWorld, node.mtxLocal);
                            node.mtxWorld.set(mtxTemp);
                            FudgeCore.Recycler.store(mtxTemp);
                        }
                        let parent = node.getParent();
                        if (parent) {
                            // fix mtxLocal for current parent
                            this.rebase(node.getParent());
                            mtxTemp = FudgeCore.Matrix4x4.MULTIPLICATION(node.getParent().mtxWorld, node.mtxLocal);
                            node.mtxWorld.set(mtxTemp);
                            FudgeCore.Recycler.store(mtxTemp);
                        }
                    }
                    break;
            }
        }
        //#endregion
        //#region Transfer
        serialize() {
            let serialization = {
                local: this.mtxLocal.serialize(),
                [super.constructor.name]: super.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization[super.constructor.name]);
            await this.mtxLocal.deserialize(_serialization.local);
            return this;
        }
        // public mutate(_mutator: Mutator): void {
        //     this.local.mutate(_mutator);
        // }
        // public getMutator(): Mutator { 
        //     return this.local.getMutator();
        // }
        // public getMutatorAttributeTypes(_mutator: Mutator): MutatorAttributeTypes {
        //     let types: MutatorAttributeTypes = this.local.getMutatorAttributeTypes(_mutator);
        //     return types;
        // }
        reduceMutator(_mutator) {
            delete _mutator.world;
            super.reduceMutator(_mutator);
        }
    }
    ComponentTransform.iSubclass = FudgeCore.Component.registerSubclass(ComponentTransform);
    FudgeCore.ComponentTransform = ComponentTransform;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Processes input signals of type number and generates an output signal of the same type using
     * proportional, integral or differential mapping, an amplification factor and a linear dampening/delay
     * ```plaintext
     *          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     *          ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      pass through (Proportional)      ‚îÇ
     *  Input ‚Üí ‚îÇ ‚Üí ‚îÇamplify‚îÇ ‚Üí ‚îÇdelay‚îÇ ‚Üí ‚öü sum up over time (Integral) ‚öû ‚Üí ‚îÇ ‚Üí Output
     *          ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      pass change  (Differential)      ‚îÇ
     *          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     * ```
     */
    class Control extends EventTarget {
        constructor(_name, _factor = 1, _type = 0 /* PROPORTIONAL */, _active = true) {
            super();
            this.rateDispatchOutput = 0;
            this.valuePrevious = 0;
            this.outputBase = 0;
            this.outputTarget = 0;
            this.outputPrevious = 0;
            this.outputTargetPrevious = 0;
            this.factor = 0;
            this.time = FudgeCore.Time.game;
            this.timeValueDelay = 0;
            this.timeOutputTargetSet = 0;
            this.idTimer = undefined;
            this.dispatchOutput = (_eventOrValue) => {
                if (!this.active)
                    return;
                let timer = this.time.getTimer(this.idTimer);
                let output;
                if (typeof (_eventOrValue) == "number")
                    output = _eventOrValue;
                else
                    output = this.calculateOutput();
                let outputChanged = (output != this.outputPrevious);
                if (timer) {
                    timer.active = outputChanged;
                    if (!outputChanged)
                        return;
                }
                this.outputPrevious = output;
                let event = new CustomEvent("output" /* OUTPUT */, {
                    detail: {
                        output: output
                    }
                });
                this.dispatchEvent(event);
            };
            this.factor = _factor;
            this.type = _type;
            this.active = _active;
            this.name = _name;
        }
        /**
         * Set the time-object to be used when calculating the output in {@link CONTROL_TYPE.INTEGRAL}
         */
        setTimebase(_time) {
            this.time = _time;
            this.calculateOutput();
        }
        /**
         * Feed an input value into this control and fire the events {@link EVENT_CONTROL.INPUT} and {@link EVENT_CONTROL.OUTPUT}
         */
        setInput(_input) {
            if (!this.active)
                return;
            this.outputBase = this.calculateOutput();
            this.valuePrevious = this.getValueDelayed();
            this.outputTarget = this.factor * _input;
            this.timeOutputTargetSet = this.time.get();
            if (this.type == 2 /* DIFFERENTIAL */) {
                this.valuePrevious = this.outputTarget - this.outputTargetPrevious;
                this.outputTargetPrevious = this.outputTarget;
                this.outputTarget = 0;
            }
            this.dispatchEvent(new Event("input" /* INPUT */));
            if (this.type == 2 /* DIFFERENTIAL */)
                this.dispatchOutput(this.valuePrevious);
            else
                this.dispatchOutput(null);
        }
        pulse(_input) {
            this.setInput(_input);
            this.setInput(0);
        }
        /**
         * Set the time to take for the internal linear dampening until the final ouput value is reached
         */
        setDelay(_time) {
            this.timeValueDelay = Math.max(0, _time);
        }
        /**
         * Set the number of output-events to dispatch per second.
         * At the default of 0, the control output must be polled and will only actively dispatched once each time input occurs and the output changes.
         */
        setRateDispatchOutput(_rateDispatchOutput = 0) {
            this.rateDispatchOutput = _rateDispatchOutput;
            this.time.deleteTimer(this.idTimer);
            this.idTimer = undefined;
            if (this.rateDispatchOutput)
                this.idTimer = this.time.setTimer(1000 / this.rateDispatchOutput, 0, this.dispatchOutput);
        }
        /**
         * Set the factor to multiply the input value given with {@link setInput} with
         */
        setFactor(_factor) {
            this.factor = _factor;
        }
        /**
         * Get the value from the output of this control
         */
        getOutput() {
            return this.calculateOutput();
        }
        /**
         * Calculates the output of this control
         */
        calculateOutput() {
            let output = 0;
            let value = this.getValueDelayed();
            switch (this.type) {
                case 1 /* INTEGRAL */:
                    let timeCurrent = this.time.get();
                    let timeElapsedSinceInput = timeCurrent - this.timeOutputTargetSet;
                    output = this.outputBase;
                    if (this.timeValueDelay > 0) {
                        if (timeElapsedSinceInput < this.timeValueDelay) {
                            output += 0.5 * (this.valuePrevious + value) * timeElapsedSinceInput;
                            break;
                        }
                        else {
                            output += 0.5 * (this.valuePrevious + value) * this.timeValueDelay;
                            timeElapsedSinceInput -= this.timeValueDelay;
                        }
                    }
                    output += value * timeElapsedSinceInput;
                    // value += 0.5 * (this.inputPrevious - input) * this.timeInputDelay + input * timeElapsedSinceInput;
                    break;
                case 2 /* DIFFERENTIAL */:
                case 0 /* PROPORTIONAL */:
                default:
                    output = value;
                    break;
            }
            return output;
        }
        /**
         * calculates the output considering the time of the delay
         */
        getValueDelayed() {
            if (this.timeValueDelay > 0) {
                let timeElapsedSinceInput = this.time.get() - this.timeOutputTargetSet;
                if (timeElapsedSinceInput < this.timeValueDelay)
                    return this.valuePrevious + (this.outputTarget - this.valuePrevious) * timeElapsedSinceInput / this.timeValueDelay;
            }
            return this.outputTarget;
        }
    }
    FudgeCore.Control = Control;
})(FudgeCore || (FudgeCore = {}));
///<reference path="Control.ts"/>
var FudgeCore;
///<reference path="Control.ts"/>
(function (FudgeCore) {
    /**
     * Handles multiple controls as inputs and creates an output from that.
     * As a subclass of {@link Control}, axis calculates the ouput summing up the inputs and processing the result using its own settings.
     * Dispatches {@link EVENT_CONTROL.OUTPUT} and {@link EVENT_CONTROL.INPUT} when one of the controls dispatches them.
     * ```plaintext
     *           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     *           ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                 ‚îÇ
     *   Input ‚Üí ‚îÇ ‚îÇcontrol‚îÇ\                                ‚îÇ
     *           ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò \                               ‚îÇ
     *           ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  \‚îå‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
     *   Input ‚Üí ‚îÇ ‚îÇcontrol‚îÇ---‚îÇsum‚îÇ ‚Üí ‚îÇinternal control ‚îÇ ‚Üí ‚îÇ ‚Üí Output
     *           ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  /‚îî‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
     *           ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê /                               ‚îÇ
     *   Input ‚Üí ‚îÇ ‚îÇcontrol‚îÇ/                                ‚îÇ
     *           ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                 ‚îÇ
     *           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     * ```
     */
    class Axis extends FudgeCore.Control {
        constructor() {
            super(...arguments);
            this.controls = new Map();
            this.sumPrevious = 0;
            this.hndOutputEvent = (_event) => {
                if (!this.active)
                    return;
                let control = _event.target;
                let event = new CustomEvent("output" /* OUTPUT */, { detail: {
                        control: control,
                        input: _event.detail.output,
                        output: this.getOutput()
                    } });
                this.dispatchEvent(event);
            };
            this.hndInputEvent = (_event) => {
                if (!this.active)
                    return;
                let event = new Event("input" /* INPUT */, _event);
                this.dispatchEvent(event);
            };
        }
        /**
         * Add the control given to the list of controls feeding into this axis
         */
        addControl(_control) {
            this.controls.set(_control.name, _control);
            _control.addEventListener("input" /* INPUT */, this.hndInputEvent);
            _control.addEventListener("output" /* OUTPUT */, this.hndOutputEvent);
        }
        /**
         * Returns the control with the given name
         */
        getControl(_name) {
            return this.controls.get(_name);
        }
        /**
         * Removes the control with the given name
         */
        removeControl(_name) {
            let control = this.getControl(_name);
            if (control) {
                control.removeEventListener("input" /* INPUT */, this.hndInputEvent);
                control.removeEventListener("output" /* OUTPUT */, this.hndOutputEvent);
                this.controls.delete(_name);
            }
        }
        /**
         * Returns the value of this axis after summing up all inputs and processing the sum according to the axis' settings
         */
        getOutput() {
            let sumInput = 0;
            for (let control of this.controls) {
                if (control[1].active)
                    sumInput += control[1].getOutput();
            }
            if (sumInput != this.sumPrevious)
                super.setInput(sumInput);
            this.sumPrevious = sumInput;
            return super.getOutput();
        }
    }
    FudgeCore.Axis = Axis;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Collects the keys pressed on the keyboard and stores their status.
     */
    class Keyboard {
        // private static code_en: Object;
        /**
         * Returns true if one of the given keys is is currently being pressed.
         */
        static isPressedOne(_keys) {
            for (let code of _keys) {
                if (Keyboard.keysPressed[code])
                    return true;
            }
            return false;
        }
        /**
         * Returns true if all of the given keys are currently being pressed
         */
        static isPressedCombo(_keys) {
            for (let code of _keys) {
                if (!Keyboard.keysPressed[code])
                    return false;
            }
            return true;
        }
        /**
         * Returns the value given as _active if one or, when _combo is true, all of the given keys are pressed.
         * Returns the value given as _inactive if not.
         */
        static mapToValue(_active, _inactive, _keys, _combo = false) {
            if (!_combo && Keyboard.isPressedOne(_keys))
                return _active;
            if (Keyboard.isPressedCombo(_keys))
                return _active;
            return _inactive;
        }
        /**
         * Returns a balanced ternary value (either -1, 0 or 1)
         * according to the match of the keys currently being pressed and the lists of keys given
         */
        static mapToTrit(_positive, _negative) {
            return Keyboard.mapToValue(-1, 0, _negative) + Keyboard.mapToValue(1, 0, _positive);
        }
        // public static locale(_keyboard: Object): void {
        //   if (!Keyboard.code_en) {
        //     // save original keyboard codes to be able to switch back later
        //     Keyboard.code_en = {};
        //     Object.assign(Keyboard.code_en, KEYBOARD_CODE);
        //   }
        //   for (let key in _keyboard) {
        //     let value: string = Reflect.get(_keyboard, key);
        //     for (let original in KEYBOARD_CODE)
        //       if (Reflect.get(KEYBOARD_CODE, original) == value)
        //         // remove original key the yields the value
        //         Reflect.deleteProperty(KEYBOARD_CODE, original);
        //     // add new key to yield that value
        //     Reflect.set(KEYBOARD_CODE, key, value);
        //   }
        // }
        static initialize() {
            let store = {};
            document.addEventListener("keydown", Keyboard.hndKeyInteraction);
            document.addEventListener("keyup", Keyboard.hndKeyInteraction);
            return store;
        }
        static hndKeyInteraction(_event) {
            Keyboard.keysPressed[_event.code] = (_event.type == "keydown");
        }
    }
    Keyboard.keysPressed = Keyboard.initialize();
    FudgeCore.Keyboard = Keyboard;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
(function (FudgeCore) {
    /**
     * Routing to the alert box
     */
    class DebugAlert extends FudgeCore.DebugTarget {
        static createDelegate(_headline) {
            let delegate = function (_message, ..._args) {
                let args = _args.map(_arg => _arg.toString());
                let out = _headline + " " + FudgeCore.DebugTarget.mergeArguments(_message, args);
                alert(out);
            };
            return delegate;
        }
    }
    DebugAlert.delegates = {
        [FudgeCore.DEBUG_FILTER.INFO]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.INFO]),
        [FudgeCore.DEBUG_FILTER.LOG]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.LOG]),
        [FudgeCore.DEBUG_FILTER.WARN]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.WARN]),
        [FudgeCore.DEBUG_FILTER.ERROR]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.ERROR]),
        [FudgeCore.DEBUG_FILTER.FUDGE]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.FUDGE]),
        [FudgeCore.DEBUG_FILTER.SOURCE]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.SOURCE])
    };
    FudgeCore.DebugAlert = DebugAlert;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
(function (FudgeCore) {
    /**
     * Routing to a HTMLDialogElement
     */
    class DebugDialog extends FudgeCore.DebugTarget {
    }
    FudgeCore.DebugDialog = DebugDialog;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
(function (FudgeCore) {
    /**
     * Route to an HTMLTextArea, may be obsolete when using HTMLDialogElement
     */
    class DebugTextArea extends FudgeCore.DebugTarget {
        static clear() {
            DebugTextArea.textArea.textContent = "";
            DebugTextArea.groups = [];
        }
        static group(_name) {
            DebugTextArea.print("‚ñº " + _name);
            DebugTextArea.groups.push(_name);
        }
        static groupEnd() {
            DebugTextArea.groups.pop();
        }
        static createDelegate(_headline) {
            let delegate = function (_message, ..._args) {
                DebugTextArea.print(_headline + " " + FudgeCore.DebugTarget.mergeArguments(_message, _args));
            };
            return delegate;
        }
        static getIndentation(_level) {
            let result = "";
            for (let i = 0; i < _level; i++)
                result += "| ";
            return result;
        }
        static print(_text) {
            DebugTextArea.textArea.textContent += DebugTextArea.getIndentation(DebugTextArea.groups.length) + _text + "\n";
            if (DebugTextArea.autoScroll)
                DebugTextArea.textArea.scrollTop = DebugTextArea.textArea.scrollHeight;
        }
    }
    DebugTextArea.textArea = document.createElement("textarea");
    DebugTextArea.autoScroll = true;
    DebugTextArea.delegates = {
        [FudgeCore.DEBUG_FILTER.INFO]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.INFO]),
        [FudgeCore.DEBUG_FILTER.LOG]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.LOG]),
        [FudgeCore.DEBUG_FILTER.WARN]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.WARN]),
        [FudgeCore.DEBUG_FILTER.ERROR]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.ERROR]),
        [FudgeCore.DEBUG_FILTER.FUDGE]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.FUDGE]),
        [FudgeCore.DEBUG_FILTER.CLEAR]: DebugTextArea.clear,
        [FudgeCore.DEBUG_FILTER.GROUP]: DebugTextArea.group,
        [FudgeCore.DEBUG_FILTER.GROUPCOLLAPSED]: DebugTextArea.group,
        [FudgeCore.DEBUG_FILTER.GROUPEND]: DebugTextArea.groupEnd,
        [FudgeCore.DEBUG_FILTER.SOURCE]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.SOURCE])
    };
    DebugTextArea.groups = [];
    FudgeCore.DebugTextArea = DebugTextArea;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * a subclass of DragEvent .A event that represents a drag and drop interaction
     */
    class EventDragDrop extends DragEvent {
        constructor(type, _event) {
            super(type, _event);
            let target = _event.target;
            this.clientRect = target.getClientRects()[0];
            this.pointerX = _event.clientX - this.clientRect.left;
            this.pointerY = _event.clientY - this.clientRect.top;
        }
    }
    FudgeCore.EventDragDrop = EventDragDrop;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * a subclass of KeyboardEvent. EventKeyboard objects describe a user interaction with the keyboard
     * each event describes a single interaction between the user and a key (or combination of a key with modifier keys) on the keyboard.
     */
    class EventKeyboard extends KeyboardEvent {
        constructor(type, _event) {
            super(type, _event);
        }
    }
    FudgeCore.EventKeyboard = EventKeyboard;
    /**
     * The codes sent from a standard english keyboard layout
     */
    let KEYBOARD_CODE;
    (function (KEYBOARD_CODE) {
        KEYBOARD_CODE["A"] = "KeyA";
        KEYBOARD_CODE["B"] = "KeyB";
        KEYBOARD_CODE["C"] = "KeyC";
        KEYBOARD_CODE["D"] = "KeyD";
        KEYBOARD_CODE["E"] = "KeyE";
        KEYBOARD_CODE["F"] = "KeyF";
        KEYBOARD_CODE["G"] = "KeyG";
        KEYBOARD_CODE["H"] = "KeyH";
        KEYBOARD_CODE["I"] = "KeyI";
        KEYBOARD_CODE["J"] = "KeyJ";
        KEYBOARD_CODE["K"] = "KeyK";
        KEYBOARD_CODE["L"] = "KeyL";
        KEYBOARD_CODE["M"] = "KeyM";
        KEYBOARD_CODE["N"] = "KeyN";
        KEYBOARD_CODE["O"] = "KeyO";
        KEYBOARD_CODE["P"] = "KeyP";
        KEYBOARD_CODE["Q"] = "KeyQ";
        KEYBOARD_CODE["R"] = "KeyR";
        KEYBOARD_CODE["S"] = "KeyS";
        KEYBOARD_CODE["T"] = "KeyT";
        KEYBOARD_CODE["U"] = "KeyU";
        KEYBOARD_CODE["V"] = "KeyV";
        KEYBOARD_CODE["W"] = "KeyW";
        KEYBOARD_CODE["X"] = "KeyX";
        KEYBOARD_CODE["Y"] = "KeyY";
        KEYBOARD_CODE["Z"] = "KeyZ";
        KEYBOARD_CODE["ESC"] = "Escape";
        KEYBOARD_CODE["ZERO"] = "Digit0";
        KEYBOARD_CODE["ONE"] = "Digit1";
        KEYBOARD_CODE["TWO"] = "Digit2";
        KEYBOARD_CODE["THREE"] = "Digit3";
        KEYBOARD_CODE["FOUR"] = "Digit4";
        KEYBOARD_CODE["FIVE"] = "Digit5";
        KEYBOARD_CODE["SIX"] = "Digit6";
        KEYBOARD_CODE["SEVEN"] = "Digit7";
        KEYBOARD_CODE["EIGHT"] = "Digit8";
        KEYBOARD_CODE["NINE"] = "Digit9";
        KEYBOARD_CODE["MINUS"] = "Minus";
        KEYBOARD_CODE["EQUAL"] = "Equal";
        KEYBOARD_CODE["BACKSPACE"] = "Backspace";
        KEYBOARD_CODE["TABULATOR"] = "Tab";
        KEYBOARD_CODE["BRACKET_LEFT"] = "BracketLeft";
        KEYBOARD_CODE["BRACKET_RIGHT"] = "BracketRight";
        KEYBOARD_CODE["ENTER"] = "Enter";
        KEYBOARD_CODE["CTRL_LEFT"] = "ControlLeft";
        KEYBOARD_CODE["SEMICOLON"] = "Semicolon";
        KEYBOARD_CODE["QUOTE"] = "Quote";
        KEYBOARD_CODE["BACK_QUOTE"] = "Backquote";
        KEYBOARD_CODE["SHIFT_LEFT"] = "ShiftLeft";
        KEYBOARD_CODE["BACKSLASH"] = "Backslash";
        KEYBOARD_CODE["COMMA"] = "Comma";
        KEYBOARD_CODE["PERIOD"] = "Period";
        KEYBOARD_CODE["SLASH"] = "Slash";
        KEYBOARD_CODE["SHIFT_RIGHT"] = "ShiftRight";
        KEYBOARD_CODE["NUMPAD_MULTIPLY"] = "NumpadMultiply";
        KEYBOARD_CODE["ALT_LEFT"] = "AltLeft";
        KEYBOARD_CODE["SPACE"] = "Space";
        KEYBOARD_CODE["CAPS_LOCK"] = "CapsLock";
        KEYBOARD_CODE["F1"] = "F1";
        KEYBOARD_CODE["F2"] = "F2";
        KEYBOARD_CODE["F3"] = "F3";
        KEYBOARD_CODE["F4"] = "F4";
        KEYBOARD_CODE["F5"] = "F5";
        KEYBOARD_CODE["F6"] = "F6";
        KEYBOARD_CODE["F7"] = "F7";
        KEYBOARD_CODE["F8"] = "F8";
        KEYBOARD_CODE["F9"] = "F9";
        KEYBOARD_CODE["F10"] = "F10";
        KEYBOARD_CODE["PAUSE"] = "Pause";
        KEYBOARD_CODE["SCROLL_LOCK"] = "ScrollLock";
        KEYBOARD_CODE["NUMPAD7"] = "Numpad7";
        KEYBOARD_CODE["NUMPAD8"] = "Numpad8";
        KEYBOARD_CODE["NUMPAD9"] = "Numpad9";
        KEYBOARD_CODE["NUMPAD_SUBTRACT"] = "NumpadSubtract";
        KEYBOARD_CODE["NUMPAD4"] = "Numpad4";
        KEYBOARD_CODE["NUMPAD5"] = "Numpad5";
        KEYBOARD_CODE["NUMPAD6"] = "Numpad6";
        KEYBOARD_CODE["NUMPAD_ADD"] = "NumpadAdd";
        KEYBOARD_CODE["NUMPAD1"] = "Numpad1";
        KEYBOARD_CODE["NUMPAD2"] = "Numpad2";
        KEYBOARD_CODE["NUMPAD3"] = "Numpad3";
        KEYBOARD_CODE["NUMPAD0"] = "Numpad0";
        KEYBOARD_CODE["NUMPAD_DECIMAL"] = "NumpadDecimal";
        KEYBOARD_CODE["PRINT_SCREEN"] = "PrintScreen";
        KEYBOARD_CODE["INTL_BACK_SLASH"] = "IntlBackSlash";
        KEYBOARD_CODE["F11"] = "F11";
        KEYBOARD_CODE["F12"] = "F12";
        KEYBOARD_CODE["NUMPAD_EQUAL"] = "NumpadEqual";
        KEYBOARD_CODE["F13"] = "F13";
        KEYBOARD_CODE["F14"] = "F14";
        KEYBOARD_CODE["F15"] = "F15";
        KEYBOARD_CODE["F16"] = "F16";
        KEYBOARD_CODE["F17"] = "F17";
        KEYBOARD_CODE["F18"] = "F18";
        KEYBOARD_CODE["F19"] = "F19";
        KEYBOARD_CODE["F20"] = "F20";
        KEYBOARD_CODE["F21"] = "F21";
        KEYBOARD_CODE["F22"] = "F22";
        KEYBOARD_CODE["F23"] = "F23";
        KEYBOARD_CODE["F24"] = "F24";
        KEYBOARD_CODE["KANA_MODE"] = "KanaMode";
        KEYBOARD_CODE["LANG2"] = "Lang2";
        KEYBOARD_CODE["LANG1"] = "Lang1";
        KEYBOARD_CODE["INTL_RO"] = "IntlRo";
        KEYBOARD_CODE["CONVERT"] = "Convert";
        KEYBOARD_CODE["NON_CONVERT"] = "NonConvert";
        KEYBOARD_CODE["INTL_YEN"] = "IntlYen";
        KEYBOARD_CODE["NUMPAD_COMMA"] = "NumpadComma";
        KEYBOARD_CODE["UNDO"] = "Undo";
        KEYBOARD_CODE["PASTE"] = "Paste";
        KEYBOARD_CODE["MEDIA_TRACK_PREVIOUS"] = "MediaTrackPrevious";
        KEYBOARD_CODE["CUT"] = "Cut";
        KEYBOARD_CODE["COPY"] = "Copy";
        KEYBOARD_CODE["MEDIA_TRACK_NEXT"] = "MediaTrackNext";
        KEYBOARD_CODE["NUMPAD_ENTER"] = "NumpadEnter";
        KEYBOARD_CODE["CTRL_RIGHT"] = "ControlRight";
        KEYBOARD_CODE["AUDIO_VOLUME_MUTE"] = "AudioVolumeMute";
        KEYBOARD_CODE["LAUNCH_APP2"] = "LaunchApp2";
        KEYBOARD_CODE["MEDIA_PLAY_PAUSE"] = "MediaPlayPause";
        KEYBOARD_CODE["MEDIA_STOP"] = "MediaStop";
        KEYBOARD_CODE["EJECT"] = "Eject";
        KEYBOARD_CODE["AUDIO_VOLUME_DOWN"] = "AudioVolumeDown";
        KEYBOARD_CODE["VOLUME_DOWN"] = "VolumeDown";
        KEYBOARD_CODE["AUDIO_VOLUME_UP"] = "AudioVolumeUp";
        KEYBOARD_CODE["VOLUME_UP"] = "VolumeUp";
        KEYBOARD_CODE["BROWSER_HOME"] = "BrowserHome";
        KEYBOARD_CODE["NUMPAD_DIVIDE"] = "NumpadDivide";
        KEYBOARD_CODE["ALT_RIGHT"] = "AltRight";
        KEYBOARD_CODE["HELP"] = "Help";
        KEYBOARD_CODE["NUM_LOCK"] = "NumLock";
        KEYBOARD_CODE["HOME"] = "Home";
        KEYBOARD_CODE["ARROW_UP"] = "ArrowUp";
        KEYBOARD_CODE["ARROW_RIGHT"] = "ArrowRight";
        KEYBOARD_CODE["ARROW_DOWN"] = "ArrowDown";
        KEYBOARD_CODE["ARROW_LEFT"] = "ArrowLeft";
        KEYBOARD_CODE["END"] = "End";
        KEYBOARD_CODE["PAGE_UP"] = "PageUp";
        KEYBOARD_CODE["PAGE_DOWN"] = "PageDown";
        KEYBOARD_CODE["INSERT"] = "Insert";
        KEYBOARD_CODE["DELETE"] = "Delete";
        KEYBOARD_CODE["META_LEFT"] = "Meta_Left";
        KEYBOARD_CODE["OS_LEFT"] = "OSLeft";
        KEYBOARD_CODE["META_RIGHT"] = "MetaRight";
        KEYBOARD_CODE["OS_RIGHT"] = "OSRight";
        KEYBOARD_CODE["CONTEXT_MENU"] = "ContextMenu";
        KEYBOARD_CODE["POWER"] = "Power";
        KEYBOARD_CODE["BROWSER_SEARCH"] = "BrowserSearch";
        KEYBOARD_CODE["BROWSER_FAVORITES"] = "BrowserFavorites";
        KEYBOARD_CODE["BROWSER_REFRESH"] = "BrowserRefresh";
        KEYBOARD_CODE["BROWSER_STOP"] = "BrowserStop";
        KEYBOARD_CODE["BROWSER_FORWARD"] = "BrowserForward";
        KEYBOARD_CODE["BROWSER_BACK"] = "BrowserBack";
        KEYBOARD_CODE["LAUNCH_APP1"] = "LaunchApp1";
        KEYBOARD_CODE["LAUNCH_MAIL"] = "LaunchMail";
        KEYBOARD_CODE["LAUNCH_MEDIA_PLAYER"] = "LaunchMediaPlayer";
        //mac brings this buttton
        KEYBOARD_CODE["FN"] = "Fn";
        //Linux brings these
        KEYBOARD_CODE["AGAIN"] = "Again";
        KEYBOARD_CODE["PROPS"] = "Props";
        KEYBOARD_CODE["SELECT"] = "Select";
        KEYBOARD_CODE["OPEN"] = "Open";
        KEYBOARD_CODE["FIND"] = "Find";
        KEYBOARD_CODE["WAKE_UP"] = "WakeUp";
        KEYBOARD_CODE["NUMPAD_PARENT_LEFT"] = "NumpadParentLeft";
        KEYBOARD_CODE["NUMPAD_PARENT_RIGHT"] = "NumpadParentRight";
        //android
        KEYBOARD_CODE["SLEEP"] = "Sleep";
    })(KEYBOARD_CODE = FudgeCore.KEYBOARD_CODE || (FudgeCore.KEYBOARD_CODE = {}));
    let KEYBOARD_CODE_DE;
    (function (KEYBOARD_CODE_DE) {
        KEYBOARD_CODE_DE["Z"] = "KeyY";
        KEYBOARD_CODE_DE["Y"] = "KeyZ";
        KEYBOARD_CODE_DE["\u00D6"] = "Semicolon";
        KEYBOARD_CODE_DE["\u00C4"] = "Quote";
        KEYBOARD_CODE_DE["\u00DC"] = "BracketLeft";
        KEYBOARD_CODE_DE["HASH"] = "Backslash";
        KEYBOARD_CODE_DE["PLUS"] = "BracketRight";
        KEYBOARD_CODE_DE["\u00DF"] = "Minus";
        KEYBOARD_CODE_DE["ACUTE"] = "Equal";
        KEYBOARD_CODE_DE["LESS_THAN"] = "IntlBackSlash";
        KEYBOARD_CODE_DE["MINUS"] = "Slash";
    })(KEYBOARD_CODE_DE = FudgeCore.KEYBOARD_CODE_DE || (FudgeCore.KEYBOARD_CODE_DE = {}));
    /*
    Firefox can't make use of those buttons and Combinations:
    SINGELE_BUTTONS:
     Druck,
    COMBINATIONS:
     Shift + F10, Shift + Numpad5,
     CTRL + q, CTRL + F4,
     ALT + F1, ALT + F2, ALT + F3, ALT + F7, ALT + F8, ALT + F10
    Opera won't do good with these Buttons and combinations:
    SINGLE_BUTTONS:
     Float32Array, F11, ALT,
    COMBINATIONS:
     CTRL + q, CTRL + t, CTRL + h, CTRL + g, CTRL + n, CTRL + f
     ALT + F1, ALT + F2, ALT + F4, ALT + F5, ALT + F6, ALT + F7, ALT + F8, ALT + F10
     */
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * a subclass of PointerEvent. The state of a DOM event produced by a pointer such as the geometry of the contact point
     * */
    class EventPointer extends PointerEvent {
        constructor(type, _event) {
            super(type, _event);
            let target = _event.target;
            this.clientRect = target.getClientRects()[0];
            this.pointerX = _event.clientX - this.clientRect.left;
            this.pointerY = _event.clientY - this.clientRect.top;
        }
    }
    FudgeCore.EventPointer = EventPointer;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * An event that represents a call from a Timer
     * */
    class EventTimer {
        constructor(_timer, ..._arguments) {
            this.type = "\u0192lapse" /* CALL */;
            this.firstCall = true;
            this.lastCall = false;
            this.target = _timer;
            this.arguments = _arguments;
            this.firstCall = true;
        }
    }
    FudgeCore.EventTimer = EventTimer;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A supclass of WheelEvent. Events that occur due to the user moving a mouse wheel or similar input device.
     * */
    class EventWheel extends WheelEvent {
        constructor(type, _event) {
            super(type, _event);
        }
    }
    FudgeCore.EventWheel = EventWheel;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A node managed by {@link Project} that functions as a template for {@link GraphInstance}s
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Resource
     */
    class Graph extends FudgeCore.Node {
        constructor() {
            super(...arguments);
            this.idResource = undefined;
            this.type = "Graph";
        }
        serialize() {
            let serialization = super.serialize();
            serialization.idResource = this.idResource;
            serialization.type = this.type;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            FudgeCore.Project.register(this, _serialization.idResource);
            return this;
        }
    }
    FudgeCore.Graph = Graph;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * An instance of a {@link Graph}.
     * This node keeps a reference to its resource an can thus optimize serialization
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Resource
     */
    class GraphInstance extends FudgeCore.Node {
        /**
         * This constructor allone will not create a reconstruction, but only save the id.
         * To create an instance of the graph, call reset on this or set with a graph as parameter.
         * Prefer Project.createGraphInstance(_graph).
         */
        constructor(_graph) {
            super("Graph");
            /** id of the resource that instance was created from */
            // TODO: examine, if this should be a direct reference to the Graph, instead of the id
            this.idSource = undefined;
            if (!_graph)
                return;
            this.idSource = _graph.idResource;
        }
        /**
         * Recreate this node from the {@link Graph} referenced
         */
        async reset() {
            let resource = await FudgeCore.Project.getResource(this.idSource);
            await this.set(resource);
        }
        //TODO: optimize using the referenced Graph, serialize/deserialize only the differences
        serialize() {
            let serialization = super.serialize();
            serialization.idSource = this.idSource;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            this.idSource = _serialization.idSource;
            return this;
        }
        /**
         * Set this node to be a recreation of the {@link Graph} given
         */
        async set(_graph) {
            // TODO: examine, if the serialization should be stored in the Graph for optimization
            let serialization = FudgeCore.Serializer.serialize(_graph);
            //Serializer.deserialize(serialization);
            for (let path in serialization) {
                await this.deserialize(serialization[path]);
                break;
            }
            this.idSource = _graph.idResource;
            this.dispatchEvent(new Event("graphInstantiated" /* GRAPH_INSTANTIATED */));
        }
    }
    FudgeCore.GraphInstance = GraphInstance;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Holds data to feed into a {@link Shader} to describe the surface of {@link Mesh}.
     * {@link Material}s reference {@link Coat} and {@link Shader}.
     * The method useRenderData will be injected by {@link RenderInjector} at runtime, extending the functionality of this class to deal with the renderer.
     */
    class Coat extends FudgeCore.Mutable {
        useRenderData(_shader, _cmpMaterial) { }
        //#region Transfer
        serialize() {
            return {};
        }
        async deserialize(_serialization) {
            return this;
        }
        reduceMutator(_mutator) {
            delete _mutator.renderData;
        }
    }
    FudgeCore.Coat = Coat;
    /**
     * The simplest {@link Coat} providing just a color
     */
    let CoatColored = class CoatColored extends Coat {
        constructor(_color, _shininess) {
            super();
            this.color = _color || new FudgeCore.Color();
            this.shininess = _shininess || 0;
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.color = this.color.serialize();
            serialization.shininess = this.shininess;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            await this.color.deserialize(_serialization.color);
            this.shininess = _serialization.shininess;
            return this;
        }
    };
    CoatColored = __decorate([
        FudgeCore.RenderInjectorCoat.decorate
    ], CoatColored);
    FudgeCore.CoatColored = CoatColored;
    /**
     * A {@link Coat} to be used by the MatCap Shader providing a texture, a tint color (0.5 grey is neutral). Set shadeSmooth to 1 for smooth shading.
     */
    // @RenderInjectorCoat.decorate
    // export class CoatMatCap extends Coat {
    //   public texture: TextureImage = null;
    //   public color: Color = new Color();
    //   public shadeSmooth: number;
    //   constructor(_texture?: TextureImage, _color?: Color, _shadeSmooth?: number) {
    //     super();
    //     this.texture = _texture || new TextureImage();
    //     this.color = _color || new Color();
    //     this.shadeSmooth = _shadeSmooth || 0;
    //   }
    //   //#region Transfer
    //   public serialize(): Serialization {
    //     let serialization: Serialization = super.serialize();
    //     serialization.color = this.color.serialize();
    //     return serialization;
    //   }
    //   public async deserialize(_serialization: Serialization): Promise<Serializable> {
    //     await super.deserialize(_serialization);
    //     await this.color.deserialize(_serialization.color);
    //     return this;
    //   }
    //#endregion
    // }
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A {@link Coat} providing a texture and additional data for texturing
     */
    let CoatTextured = class CoatTextured extends FudgeCore.CoatColored {
        constructor(_color, _texture) {
            super(_color);
            this.texture = null;
            this.texture = _texture || FudgeCore.TextureDefault.texture;
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.idTexture = this.texture.idResource;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            if (_serialization.idTexture)
                this.texture = await FudgeCore.Project.getResource(_serialization.idTexture);
            return this;
        }
    };
    CoatTextured = __decorate([
        FudgeCore.RenderInjectorCoat.decorate
    ], CoatTextured);
    FudgeCore.CoatTextured = CoatTextured;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Defines a color as values in the range of 0 to 1 for the four channels red, green, blue and alpha (for opacity)
     */
    class Color extends FudgeCore.Mutable {
        constructor(_r = 1, _g = 1, _b = 1, _a = 1) {
            super();
            this.setNormRGBA(_r, _g, _b, _a);
        }
        static getHexFromCSSKeyword(_keyword) {
            Color.crc2.fillStyle = _keyword;
            return Color.crc2.fillStyle;
        }
        static CSS(_keyword, _alpha = 1) {
            let hex = Color.getHexFromCSSKeyword(_keyword);
            let color = new Color(parseInt(hex.substr(1, 2), 16) / 255, parseInt(hex.substr(3, 2), 16) / 255, parseInt(hex.substr(5, 2), 16) / 255, _alpha);
            return color;
        }
        static MULTIPLY(_color1, _color2) {
            return new Color(_color1.r * _color2.r, _color1.g * _color2.g, _color1.b * _color2.b, _color1.a * _color2.a);
        }
        setNormRGBA(_r, _g, _b, _a) {
            this.r = Math.min(1, Math.max(0, _r));
            this.g = Math.min(1, Math.max(0, _g));
            this.b = Math.min(1, Math.max(0, _b));
            this.a = Math.min(1, Math.max(0, _a));
        }
        setBytesRGBA(_r, _g, _b, _a) {
            this.setNormRGBA(_r / 255, _g / 255, _b / 255, _a / 255);
        }
        getArray() {
            return new Float32Array([this.r, this.g, this.b, this.a]);
        }
        setArrayNormRGBA(_color) {
            this.setNormRGBA(_color[0], _color[1], _color[2], _color[3]);
        }
        setArrayBytesRGBA(_color) {
            this.setBytesRGBA(_color[0], _color[1], _color[2], _color[3]);
        }
        getArrayBytesRGBA() {
            return new Uint8ClampedArray([this.r * 255, this.g * 255, this.b * 255, this.a * 255]);
        }
        add(_color) {
            this.r += _color.r;
            this.g += _color.g;
            this.b += _color.b;
            this.a += _color.a;
        }
        getCSS() {
            let bytes = this.getArrayBytesRGBA();
            return `RGBA(${bytes[0]}, ${bytes[1]}, ${bytes[2]}, ${bytes[3]})`;
        }
        getHex() {
            let bytes = this.getArrayBytesRGBA();
            let hex = "";
            for (let byte of bytes)
                hex += byte.toString(16).padStart(2, "0");
            return hex;
        }
        setHex(_hex) {
            let bytes = this.getArrayBytesRGBA();
            let channel = 0;
            for (let byte in bytes)
                bytes[byte] = parseInt(_hex.substr(channel++ * 2, 2), 16);
            this.setArrayBytesRGBA(bytes);
        }
        copy(_color) {
            this.r = _color.r;
            this.g = _color.g;
            this.b = _color.b;
            this.a = _color.a;
        }
        toString() {
            return `(r: ${this.r.toFixed(3)}, g: ${this.g.toFixed(3)}, b: ${this.b.toFixed(3)}, a: ${this.a.toFixed(3)})`;
        }
        //#region Transfer
        serialize() {
            let serialization = this.getMutator(true);
            // serialization.toJSON = () => { return `{ "r": ${this.r}, "g": ${this.g}, "b": ${this.b}, "a": ${this.a}}`; };
            serialization.toJSON = () => { return `[${this.r}, ${this.g}, ${this.b}, ${this.a}]`; };
            return serialization;
        }
        async deserialize(_serialization) {
            if (typeof (_serialization) == "string") {
                [this.r, this.g, this.b, this.a] = JSON.parse(_serialization);
            }
            else
                this.mutate(_serialization);
            return this;
        }
        reduceMutator(_mutator) { }
    }
    // crc2 only used for converting colors from strings predefined by CSS
    Color.crc2 = document.createElement("canvas").getContext("2d");
    FudgeCore.Color = Color;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Baseclass for materials. Combines a {@link Shader} with a compatible {@link Coat}
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Material extends FudgeCore.Mutable {
        constructor(_name, _shader, _coat) {
            super();
            this.idResource = undefined;
            this.name = _name;
            this.shaderType = _shader;
            if (_shader) {
                if (_coat)
                    this.coat = _coat;
                else
                    this.coat = this.createCoatMatchingShader();
            }
            FudgeCore.Project.register(this);
        }
        /** The name to call the Material by. */
        #coat;
        /**
         * Returns the currently referenced {@link Coat} instance
         */
        get coat() {
            return this.#coat;
        }
        /**
         * Makes this material reference the given {@link Coat} if it is compatible with the referenced {@link Shader}
         */
        set coat(_coat) {
            if (_coat.constructor != this.shaderType.getCoat())
                if (_coat instanceof this.shaderType.getCoat())
                    FudgeCore.Debug.fudge("Coat is extension of Coat required by shader");
                else
                    throw (new Error("Shader and coat don't match"));
            this.#coat = _coat;
        }
        /**
         * Creates a new {@link Coat} instance that is valid for the {@link Shader} referenced by this material
         */
        createCoatMatchingShader() {
            let coat = new (this.shaderType.getCoat())();
            return coat;
        }
        /**
         * Changes the materials reference to the given {@link Shader}, creates and references a new {@link Coat} instance
         * and mutates the new coat to preserve matching properties.
         * @param _shaderType
         */
        setShader(_shaderType) {
            this.shaderType = _shaderType;
            let coat = this.createCoatMatchingShader();
            coat.mutate(this.#coat.getMutator());
            this.coat = coat;
        }
        /**
         * Returns the {@link Shader} referenced by this material
         */
        getShader() {
            return this.shaderType;
        }
        //#region Transfer
        // TODO: this type of serialization was implemented for implicit Material create. Check if obsolete when only one material class exists and/or materials are stored separately
        serialize() {
            let serialization = {
                name: this.name,
                idResource: this.idResource,
                shader: this.shaderType.name,
                coat: FudgeCore.Serializer.serialize(this.#coat)
            };
            return serialization;
        }
        async deserialize(_serialization) {
            this.name = _serialization.name;
            FudgeCore.Project.register(this, _serialization.idResource);
            this.shaderType = FudgeCore[_serialization.shader];
            let coat = await FudgeCore.Serializer.deserialize(_serialization.coat);
            this.coat = coat;
            return this;
        }
        getMutator() {
            let mutator = super.getMutator(true);
            mutator.coat = this.coat.getMutator();
            return mutator;
        }
        async mutate(_mutator) {
            await super.mutate(_mutator);
            // appearenty, coat already mutates... next line unnecessary and buggy, since url gets stripped
            // await this.coat.mutate(_mutator.coat);
        }
        reduceMutator(_mutator) {
            // delete _mutator.idResource;
        }
    }
    FudgeCore.Material = Material;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Framing describes how to map a rectangle into a given frame
     * and how points in the frame correspond to points in the resulting rectangle and vice versa
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Framing
     */
    class Framing extends FudgeCore.Mutable {
        reduceMutator(_mutator) { }
    }
    FudgeCore.Framing = Framing;
    /**
     * The resulting rectangle has a fixed width and height and display should scale to fit the frame
     * Points are scaled in the same ratio
     */
    class FramingFixed extends Framing {
        constructor(_width = 300, _height = 150) {
            super();
            this.width = 300;
            this.height = 150;
            this.setSize(_width, _height);
        }
        setSize(_width, _height) {
            this.width = _width;
            this.height = _height;
        }
        getPoint(_pointInFrame, _rectFrame) {
            let result = new FudgeCore.Vector2(this.width * (_pointInFrame.x - _rectFrame.x) / _rectFrame.width, this.height * (_pointInFrame.y - _rectFrame.y) / _rectFrame.height);
            return result;
        }
        getPointInverse(_point, _rect) {
            let result = new FudgeCore.Vector2(_point.x * _rect.width / this.width + _rect.x, _point.y * _rect.height / this.height + _rect.y);
            return result;
        }
        getRect(_rectFrame) {
            return FudgeCore.Rectangle.GET(0, 0, this.width, this.height);
        }
    }
    FudgeCore.FramingFixed = FramingFixed;
    /**
     * Width and height of the resulting rectangle are fractions of those of the frame, scaled by normed values normWidth and normHeight.
     * Display should scale to fit the frame and points are scaled in the same ratio
     */
    class FramingScaled extends Framing {
        constructor() {
            super(...arguments);
            this.normWidth = 1.0;
            this.normHeight = 1.0;
        }
        setScale(_normWidth, _normHeight) {
            this.normWidth = _normWidth;
            this.normHeight = _normHeight;
        }
        getPoint(_pointInFrame, _rectFrame) {
            let result = new FudgeCore.Vector2(this.normWidth * (_pointInFrame.x - _rectFrame.x), this.normHeight * (_pointInFrame.y - _rectFrame.y));
            return result;
        }
        getPointInverse(_point, _rect) {
            let result = new FudgeCore.Vector2(_point.x / this.normWidth + _rect.x, _point.y / this.normHeight + _rect.y);
            return result;
        }
        getRect(_rectFrame) {
            return FudgeCore.Rectangle.GET(0, 0, this.normWidth * _rectFrame.width, this.normHeight * _rectFrame.height);
        }
    }
    FudgeCore.FramingScaled = FramingScaled;
    /**
     * The resulting rectangle fits into a margin given as fractions of the size of the frame given by normAnchor
     * plus an absolute padding given by pixelBorder. Display should fit into this.
     */
    class FramingComplex extends Framing {
        constructor() {
            super(...arguments);
            this.margin = { left: 0, top: 0, right: 0, bottom: 0 };
            this.padding = { left: 0, top: 0, right: 0, bottom: 0 };
        }
        getPoint(_pointInFrame, _rectFrame) {
            let result = new FudgeCore.Vector2(_pointInFrame.x - this.padding.left - this.margin.left * _rectFrame.width, _pointInFrame.y - this.padding.top - this.margin.top * _rectFrame.height);
            return result;
        }
        getPointInverse(_point, _rect) {
            let result = new FudgeCore.Vector2(_point.x + this.padding.left + this.margin.left * _rect.width, _point.y + this.padding.top + this.margin.top * _rect.height);
            return result;
        }
        getRect(_rectFrame) {
            if (!_rectFrame)
                return null;
            let minX = _rectFrame.x + this.margin.left * _rectFrame.width + this.padding.left;
            let minY = _rectFrame.y + this.margin.top * _rectFrame.height + this.padding.top;
            let maxX = _rectFrame.x + (1 - this.margin.right) * _rectFrame.width - this.padding.right;
            let maxY = _rectFrame.y + (1 - this.margin.bottom) * _rectFrame.height - this.padding.bottom;
            return FudgeCore.Rectangle.GET(minX, minY, maxX - minX, maxY - minY);
        }
        getMutator() {
            return { margin: this.margin, padding: this.padding };
        }
    }
    FudgeCore.FramingComplex = FramingComplex;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Representation of a vector2 as polar coordinates
     * ```plaintext
     *  ‚Üï- angle (Angle to the x-axis)
     *  -‚Üí Magnitude (Distance from the center)
     * ```
     */
    class Geo2 {
        constructor(_angle = 0, _magnitude = 1) {
            this.magnitude = 0;
            this.angle = 0;
            this.set(_angle, _magnitude);
        }
        /**
         * Set the properties of this instance at once
         */
        set(_angle = 0, _magnitude = 1) {
            this.magnitude = _magnitude;
            this.angle = _angle;
        }
        recycle() {
            this.set();
        }
        /**
         * Returns a pretty string representation
         */
        toString() {
            return `angle: ${this.angle.toPrecision(5)},  magnitude: ${this.magnitude.toPrecision(5)}`;
        }
    }
    FudgeCore.Geo2 = Geo2;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Representation of a vector3 as geographic coordinates as seen on a globe
     * ```plaintext
     * ‚Üê|‚Üí Longitude (Angle to the z-axis)
     *  ‚Üï- Latitude (Angle to the equator)
     *  -‚Üí Magnitude (Distance from the center)
     * ```
     */
    class Geo3 {
        constructor(_longitude = 0, _latitude = 0, _magnitude = 1) {
            this.magnitude = 0;
            this.latitude = 0;
            this.longitude = 0;
            this.set(_longitude, _latitude, _magnitude);
        }
        /**
         * Set the properties of this instance at once
         */
        set(_longitude = 0, _latitude = 0, _magnitude = 1) {
            this.magnitude = _magnitude;
            this.latitude = _latitude;
            this.longitude = _longitude;
        }
        recycle() {
            this.set();
        }
        /**
         * Returns a pretty string representation
         */
        toString() {
            return `longitude: ${this.longitude.toPrecision(5)}, latitude: ${this.latitude.toPrecision(5)}, magnitude: ${this.magnitude.toPrecision(5)}`;
        }
    }
    FudgeCore.Geo3 = Geo3;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    // From http://baagoe.com/en/RandomMusings/javascript/
    // Johannes Baag√∏e <baagoe@baagoe.com>, 2010
    function Mash() {
        let n = 0xefc8249d;
        let mash = function (data) {
            data = data.toString();
            for (let i = 0; i < data.length; i++) {
                n += data.charCodeAt(i);
                let h = 0.02519603282416938 * n;
                n = h >>> 0;
                h -= n;
                h *= n;
                n = h >>> 0;
                h -= n;
                n += h * 0x100000000; // 2^32
            }
            return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
        };
        // mash.version = 'Mash 0.9';
        return mash;
    }
    FudgeCore.Mash = Mash;
    // From http://baagoe.com/en/RandomMusings/javascript/
    function LFIB4() {
        // George Marsaglia's LFIB4,
        //http://groups.google.com/group/sci.crypt/msg/eb4ddde782b17051
        let args = Array.prototype.slice.call(arguments);
        let k0 = 0, k1 = 58, k2 = 119, k3 = 178;
        let s = [];
        let mash = Mash();
        if (args.length === 0) {
            args = [+new Date()];
        }
        for (let j = 0; j < 256; j++) {
            s[j] = mash(" ");
            s[j] -= mash(" ") * 4.76837158203125e-7; // 2^-21
            if (s[j] < 0) {
                s[j] += 1;
            }
        }
        for (let i = 0; i < args.length; i++) {
            for (let j = 0; j < 256; j++) {
                s[j] -= mash(args[i]);
                s[j] -= mash(args[i]) * 4.76837158203125e-7; // 2^-21
                if (s[j] < 0) {
                    s[j] += 1;
                }
            }
        }
        mash = null;
        let random = function () {
            let x;
            k0 = (k0 + 1) & 255;
            k1 = (k1 + 1) & 255;
            k2 = (k2 + 1) & 255;
            k3 = (k3 + 1) & 255;
            x = s[k0] - s[k1];
            if (x < 0) {
                x += 1;
            }
            x -= s[k2];
            if (x < 0) {
                x += 1;
            }
            x -= s[k3];
            if (x < 0) {
                x += 1;
            }
            return s[k0] = x;
        };
        // random.uint32 = function () {
        //   return random() * 0x100000000 >>> 0; // 2^32
        // };
        // random.fract53 = random;
        // random.version = "LFIB4 0.9";
        // random.args = args;
        return random;
    }
    FudgeCore.LFIB4 = LFIB4;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Simple class for 3x3 matrix operations
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2020
     */
    class Matrix3x3 extends FudgeCore.Mutable {
        constructor() {
            super();
            this.data = new Float32Array(9); // The data of the matrix.
            this.mutator = null; // prepared for optimization, keep mutator to reduce redundant calculation and for comparison. Set to null when data changes!
            this.recycle();
            this.resetCache();
        }
        //TODO: figure out what this is used for
        static PROJECTION(_width, _height) {
            let mtxResult = new Matrix3x3;
            mtxResult.data.set([
                2 / _width, 0, 0,
                0, -2 / _height, 0,
                -1, 1, 1
            ]);
            return mtxResult;
        }
        static IDENTITY() {
            const mtxResult = FudgeCore.Recycler.get(Matrix3x3);
            return mtxResult;
        }
        /**
         * Returns a matrix that translates coordinates along the x-, y- and z-axis according to the given {@link Vector2}.
         */
        static TRANSLATION(_translate) {
            const mtxResult = FudgeCore.Recycler.get(Matrix3x3);
            mtxResult.data.set([
                1, 0, 0,
                0, 1, 0,
                _translate.x, _translate.y, 1
            ]);
            return mtxResult;
        }
        /**
         * Returns a matrix that rotates coordinates on the z-axis when multiplied by.
         * @param _angleInDegrees The value of the rotation.
         */
        static ROTATION(_angleInDegrees) {
            const mtxResult = FudgeCore.Recycler.get(Matrix3x3);
            let angleInRadians = _angleInDegrees * Matrix3x3.deg2rad;
            let sin = Math.sin(angleInRadians);
            let cos = Math.cos(angleInRadians);
            mtxResult.data.set([
                cos, sin, 0,
                -sin, cos, 0,
                0, 0, 1
            ]);
            return mtxResult;
        }
        /**
         * Returns a matrix that scales coordinates along the x-, y- and z-axis according to the given {@link Vector2}
         */
        static SCALING(_scalar) {
            const mtxResult = FudgeCore.Recycler.get(Matrix3x3);
            mtxResult.data.set([
                _scalar.x, 0, 0,
                0, _scalar.y, 0,
                0, 0, 1
            ]);
            return mtxResult;
        }
        //#endregion
        static MULTIPLICATION(_mtxLeft, _mtxRight) {
            let a00 = _mtxLeft.data[0 * 3 + 0];
            let a01 = _mtxLeft.data[0 * 3 + 1];
            let a02 = _mtxLeft.data[0 * 3 + 2];
            let a10 = _mtxLeft.data[1 * 3 + 0];
            let a11 = _mtxLeft.data[1 * 3 + 1];
            let a12 = _mtxLeft.data[1 * 3 + 2];
            let a20 = _mtxLeft.data[2 * 3 + 0];
            let a21 = _mtxLeft.data[2 * 3 + 1];
            let a22 = _mtxLeft.data[2 * 3 + 2];
            let b00 = _mtxRight.data[0 * 3 + 0];
            let b01 = _mtxRight.data[0 * 3 + 1];
            let b02 = _mtxRight.data[0 * 3 + 2];
            let b10 = _mtxRight.data[1 * 3 + 0];
            let b11 = _mtxRight.data[1 * 3 + 1];
            let b12 = _mtxRight.data[1 * 3 + 2];
            let b20 = _mtxRight.data[2 * 3 + 0];
            let b21 = _mtxRight.data[2 * 3 + 1];
            let b22 = _mtxRight.data[2 * 3 + 2];
            let mtxResult = new Matrix3x3;
            mtxResult.data.set([
                b00 * a00 + b01 * a10 + b02 * a20,
                b00 * a01 + b01 * a11 + b02 * a21,
                b00 * a02 + b01 * a12 + b02 * a22,
                b10 * a00 + b11 * a10 + b12 * a20,
                b10 * a01 + b11 * a11 + b12 * a21,
                b10 * a02 + b11 * a12 + b12 * a22,
                b20 * a00 + b21 * a10 + b22 * a20,
                b20 * a01 + b21 * a11 + b22 * a21,
                b20 * a02 + b21 * a12 + b22 * a22
            ]);
            return mtxResult;
        }
        /**
         * - get: return a vector representation of the translation {@link Vector2}.
         * **Caution!** Use immediately, since the vector is going to be reused by Recycler. Create a clone to keep longer and manipulate.
         * - set: effect the matrix ignoring its rotation and scaling
         */
        get translation() {
            if (!this.vectors.translation)
                this.vectors.translation = new FudgeCore.Vector2(this.data[6], this.data[7]);
            return this.vectors.translation; // .clone;
        }
        set translation(_translation) {
            this.data.set(_translation.get(), 6);
            // no full cache reset required
            this.vectors.translation = _translation;
            this.mutator = null;
        }
        /**
         * - get: a copy of the calculated rotation {@link Vector2}
         * - set: effect the matrix
         */
        get rotation() {
            if (!this.vectors.rotation)
                this.vectors.rotation = this.getEulerAngle();
            return this.vectors.rotation;
        }
        set rotation(_rotation) {
            this.mutate({ "rotation": _rotation });
            this.resetCache();
        }
        /**
         * - get: return a vector representation of the scale {@link Vector3}.
         * **Caution!** Do not manipulate result, instead create a clone!
         * - set: effect the matrix
         */
        get scaling() {
            if (!this.vectors.scaling)
                this.vectors.scaling = new FudgeCore.Vector2(Math.hypot(this.data[0], this.data[1]), Math.hypot(this.data[3], this.data[4]));
            return this.vectors.scaling; // .clone;
        }
        set scaling(_scaling) {
            this.mutate({ "scaling": _scaling });
            this.resetCache();
        }
        /**
         * Return a copy of this
         */
        get clone() {
            let mtxClone = FudgeCore.Recycler.get(Matrix3x3);
            mtxClone.set(this);
            return mtxClone;
        }
        recycle() {
            this.data = new Float32Array([
                1, 0, 0,
                0, 1, 0,
                0, 0, 1
            ]);
            this.resetCache();
        }
        //#region Translation
        /**
         * Add a translation by the given {@link Vector2} to this matrix
         */
        translate(_by) {
            const mtxResult = Matrix3x3.MULTIPLICATION(this, Matrix3x3.TRANSLATION(_by));
            // TODO: possible optimization, translation may alter mutator instead of deleting it.
            this.set(mtxResult);
            FudgeCore.Recycler.store(mtxResult);
        }
        /**
         * Add a translation along the x-Axis by the given amount to this matrix
         */
        translateX(_x) {
            this.data[6] += _x;
            this.mutator = null;
            this.vectors.translation = null;
        }
        /**
         * Add a translation along the y-Axis by the given amount to this matrix
         */
        translateY(_y) {
            this.data[7] += _y;
            this.mutator = null;
            this.vectors.translation = null;
        }
        //#endregion
        //#region Scaling
        /**
         * Add a scaling by the given {@link Vector2} to this matrix
         */
        scale(_by) {
            const mtxResult = Matrix3x3.MULTIPLICATION(this, Matrix3x3.SCALING(_by));
            this.set(mtxResult);
            FudgeCore.Recycler.store(mtxResult);
        }
        /**
         * Add a scaling along the x-Axis by the given amount to this matrix
         */
        scaleX(_by) {
            let vector = FudgeCore.Recycler.get(FudgeCore.Vector2);
            vector.set(_by, 1);
            this.scale(vector);
            FudgeCore.Recycler.store(vector);
        }
        /**
         * Add a scaling along the y-Axis by the given amount to this matrix
         */
        scaleY(_by) {
            let vector = FudgeCore.Recycler.get(FudgeCore.Vector2);
            vector.set(1, _by);
            this.scale(vector);
            FudgeCore.Recycler.store(vector);
        }
        //#endregion
        //#region Rotation
        /**
         * Adds a rotation around the z-Axis to this matrix
         */
        rotate(_angleInDegrees) {
            const mtxResult = Matrix3x3.MULTIPLICATION(this, Matrix3x3.ROTATION(_angleInDegrees));
            this.set(mtxResult);
            FudgeCore.Recycler.store(mtxResult);
        }
        //#endregion
        //#region Transformation
        /**
         * Multiply this matrix with the given matrix
         */
        multiply(_mtxRight) {
            let mtxResult = Matrix3x3.MULTIPLICATION(this, _mtxRight);
            this.set(mtxResult);
            FudgeCore.Recycler.store(mtxResult);
            this.mutator = null;
        }
        //#endregion
        //#region Transfer
        /**
         * Calculates and returns the euler-angles representing the current rotation of this matrix
         */
        getEulerAngle() {
            let scaling = this.scaling;
            let s0 = this.data[0] / scaling.x;
            let s1 = this.data[1] / scaling.x;
            let s3 = this.data[3] / scaling.y;
            let s4 = this.data[4] / scaling.y;
            let xSkew = Math.atan2(-s3, s4);
            let ySkew = Math.atan2(s0, s1);
            let sy = Math.hypot(s0, s1); // probably 2. param should be this.data[4] / scaling.y
            let rotation;
            if (!(sy > 1e-6))
                rotation = ySkew;
            else
                rotation = xSkew;
            rotation *= 180 / Math.PI;
            return rotation;
        }
        /**
         * Sets the elements of this matrix to the values of the given matrix
         */
        set(_mtxTo) {
            // this.data = _to.get();
            this.data.set(_mtxTo.data);
            this.resetCache();
        }
        toString() {
            return `∆í.Matrix3x3(translation: ${this.translation.toString()}, rotation: ${this.rotation.toString()}, scaling: ${this.scaling.toString()}`;
        }
        /**
         * Return the elements of this matrix as a Float32Array
         */
        get() {
            return new Float32Array(this.data);
        }
        serialize() {
            // this.getMutator();
            let serialization = {
                translation: this.translation.serialize(),
                rotation: this.rotation,
                scaling: this.scaling.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            let mutator = {
                translation: await this.translation.deserialize(_serialization.translation),
                rotation: _serialization.rotation,
                scaling: await this.scaling.deserialize(_serialization.scaling)
            };
            this.mutate(mutator);
            return this;
        }
        getMutator() {
            if (this.mutator)
                return this.mutator;
            let mutator = {
                translation: this.translation.getMutator(),
                rotation: this.rotation,
                scaling: this.scaling.getMutator()
            };
            // cache mutator
            this.mutator = mutator;
            return mutator;
        }
        async mutate(_mutator) {
            let oldTranslation = this.translation;
            let oldRotation = this.rotation;
            let oldScaling = this.scaling;
            let newTranslation = _mutator["translation"];
            let newRotation = _mutator["rotation"];
            let newScaling = _mutator["scaling"];
            let vectors = { translation: oldTranslation, rotation: oldRotation, scaling: oldScaling };
            if (newTranslation) {
                vectors.translation = new FudgeCore.Vector2(newTranslation.x != undefined ? newTranslation.x : oldTranslation.x, newTranslation.y != undefined ? newTranslation.y : oldTranslation.y);
            }
            vectors.rotation = (newRotation == undefined) ? oldRotation : newRotation;
            if (newScaling) {
                vectors.scaling = new FudgeCore.Vector2(newScaling.x != undefined ? newScaling.x : oldScaling.x, newScaling.y != undefined ? newScaling.y : oldScaling.y);
            }
            // TODO: possible performance optimization when only one or two components change, then use old matrix instead of IDENTITY and transform by differences/quotients
            let mtxResult = Matrix3x3.IDENTITY();
            if (vectors.translation)
                mtxResult.translate(vectors.translation);
            if (vectors.rotation) {
                mtxResult.rotate(vectors.rotation);
            }
            if (vectors.scaling)
                mtxResult.scale(vectors.scaling);
            this.set(mtxResult);
            this.vectors = vectors;
        }
        getMutatorAttributeTypes(_mutator) {
            let types = {};
            if (_mutator.translation)
                types.translation = "Vector2";
            if (_mutator.rotation != undefined)
                types.rotation = "number";
            if (_mutator.scaling)
                types.scaling = "Vector2";
            return types;
        }
        reduceMutator(_mutator) { }
        resetCache() {
            this.vectors = { translation: null, rotation: null, scaling: null };
            this.mutator = null;
        }
    }
    Matrix3x3.deg2rad = Math.PI / 180;
    FudgeCore.Matrix3x3 = Matrix3x3;
    //#endregion
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Stores a 4x4 transformation matrix and provides operations for it.
     * ```plaintext
     * [ 0, 1, 2, 3 ] ‚Üê row vector x
     * [ 4, 5, 6, 7 ] ‚Üê row vector y
     * [ 8, 9,10,11 ] ‚Üê row vector z
     * [12,13,14,15 ] ‚Üê translation
     *            ‚Üë  homogeneous column
     * ```
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Matrix4x4 extends FudgeCore.Mutable {
        constructor() {
            super();
            this.#eulerAngles = FudgeCore.Vector3.ZERO();
            this.#vectors = { translation: FudgeCore.Vector3.ZERO(), rotation: FudgeCore.Vector3.ZERO(), scaling: FudgeCore.Vector3.ZERO() };
            this.data = new Float32Array(16); // The data of the matrix.
            this.mutator = null; // prepared for optimization, keep mutator to reduce redundant calculation and for comparison. Set to null when data changes!
            this.recycle();
            this.resetCache();
        }
        #eulerAngles;
        #vectors;
        //#region STATICS
        /**
         * Retrieve a new identity matrix
         */
        static IDENTITY() {
            const mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            return mtxResult;
        }
        /**
         * Constructs a new matrix according to the translation, rotation and scaling {@link Vector3}s given
         */
        static CONSTRUCTION(_vectors) {
            let result = Matrix4x4.IDENTITY();
            result.mutate(_vectors);
            return result;
        }
        /**
         * Computes and returns the product of two passed matrices.
         * @param _mtxLeft The matrix to multiply.
         * @param _mtxRight The matrix to multiply by.
         */
        static MULTIPLICATION(_mtxLeft, _mtxRight) {
            let a = _mtxLeft.data;
            let b = _mtxRight.data;
            // let matrix: Matrix4x4 = new Matrix4x4();
            const mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            let a00 = a[0 * 4 + 0];
            let a01 = a[0 * 4 + 1];
            let a02 = a[0 * 4 + 2];
            let a03 = a[0 * 4 + 3];
            let a10 = a[1 * 4 + 0];
            let a11 = a[1 * 4 + 1];
            let a12 = a[1 * 4 + 2];
            let a13 = a[1 * 4 + 3];
            let a20 = a[2 * 4 + 0];
            let a21 = a[2 * 4 + 1];
            let a22 = a[2 * 4 + 2];
            let a23 = a[2 * 4 + 3];
            let a30 = a[3 * 4 + 0];
            let a31 = a[3 * 4 + 1];
            let a32 = a[3 * 4 + 2];
            let a33 = a[3 * 4 + 3];
            let b00 = b[0 * 4 + 0];
            let b01 = b[0 * 4 + 1];
            let b02 = b[0 * 4 + 2];
            let b03 = b[0 * 4 + 3];
            let b10 = b[1 * 4 + 0];
            let b11 = b[1 * 4 + 1];
            let b12 = b[1 * 4 + 2];
            let b13 = b[1 * 4 + 3];
            let b20 = b[2 * 4 + 0];
            let b21 = b[2 * 4 + 1];
            let b22 = b[2 * 4 + 2];
            let b23 = b[2 * 4 + 3];
            let b30 = b[3 * 4 + 0];
            let b31 = b[3 * 4 + 1];
            let b32 = b[3 * 4 + 2];
            let b33 = b[3 * 4 + 3];
            mtxResult.data.set([
                b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30,
                b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31,
                b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32,
                b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33,
                b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30,
                b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31,
                b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32,
                b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33,
                b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30,
                b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31,
                b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32,
                b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33,
                b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30,
                b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31,
                b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32,
                b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33
            ]);
            return mtxResult;
        }
        /**
         * Computes and returns the transpose of a passed matrix.
         */
        static TRANSPOSE(_mtx) {
            let m = _mtx.data;
            let result = FudgeCore.Recycler.get(Matrix4x4);
            result.data.set([
                m[0], m[4], m[8], m[12],
                m[1], m[5], m[9], m[13],
                m[2], m[6], m[10], m[14],
                m[3], m[7], m[11], m[15]
            ]);
            return result;
        }
        /**
         * Computes and returns the inverse of a passed matrix.
         * @param _mtx The matrix to compute the inverse of.
         */
        static INVERSION(_mtx) {
            let m = _mtx.data;
            let m00 = m[0 * 4 + 0];
            let m01 = m[0 * 4 + 1];
            let m02 = m[0 * 4 + 2];
            let m03 = m[0 * 4 + 3];
            let m10 = m[1 * 4 + 0];
            let m11 = m[1 * 4 + 1];
            let m12 = m[1 * 4 + 2];
            let m13 = m[1 * 4 + 3];
            let m20 = m[2 * 4 + 0];
            let m21 = m[2 * 4 + 1];
            let m22 = m[2 * 4 + 2];
            let m23 = m[2 * 4 + 3];
            let m30 = m[3 * 4 + 0];
            let m31 = m[3 * 4 + 1];
            let m32 = m[3 * 4 + 2];
            let m33 = m[3 * 4 + 3];
            let tmp0 = m22 * m33;
            let tmp1 = m32 * m23;
            let tmp2 = m12 * m33;
            let tmp3 = m32 * m13;
            let tmp4 = m12 * m23;
            let tmp5 = m22 * m13;
            let tmp6 = m02 * m33;
            let tmp7 = m32 * m03;
            let tmp8 = m02 * m23;
            let tmp9 = m22 * m03;
            let tmp10 = m02 * m13;
            let tmp11 = m12 * m03;
            let tmp12 = m20 * m31;
            let tmp13 = m30 * m21;
            let tmp14 = m10 * m31;
            let tmp15 = m30 * m11;
            let tmp16 = m10 * m21;
            let tmp17 = m20 * m11;
            let tmp18 = m00 * m31;
            let tmp19 = m30 * m01;
            let tmp20 = m00 * m21;
            let tmp21 = m20 * m01;
            let tmp22 = m00 * m11;
            let tmp23 = m10 * m01;
            let t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) -
                (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);
            let t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) -
                (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);
            let t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) -
                (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);
            let t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) -
                (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);
            let d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);
            const mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            mtxResult.data.set([
                d * t0,
                d * t1,
                d * t2,
                d * t3,
                d * ((tmp1 * m10 + tmp2 * m20 + tmp5 * m30) - (tmp0 * m10 + tmp3 * m20 + tmp4 * m30)),
                d * ((tmp0 * m00 + tmp7 * m20 + tmp8 * m30) - (tmp1 * m00 + tmp6 * m20 + tmp9 * m30)),
                d * ((tmp3 * m00 + tmp6 * m10 + tmp11 * m30) - (tmp2 * m00 + tmp7 * m10 + tmp10 * m30)),
                d * ((tmp4 * m00 + tmp9 * m10 + tmp10 * m20) - (tmp5 * m00 + tmp8 * m10 + tmp11 * m20)),
                d * ((tmp12 * m13 + tmp15 * m23 + tmp16 * m33) - (tmp13 * m13 + tmp14 * m23 + tmp17 * m33)),
                d * ((tmp13 * m03 + tmp18 * m23 + tmp21 * m33) - (tmp12 * m03 + tmp19 * m23 + tmp20 * m33)),
                d * ((tmp14 * m03 + tmp19 * m13 + tmp22 * m33) - (tmp15 * m03 + tmp18 * m13 + tmp23 * m33)),
                d * ((tmp17 * m03 + tmp20 * m13 + tmp23 * m23) - (tmp16 * m03 + tmp21 * m13 + tmp22 * m23)),
                d * ((tmp14 * m22 + tmp17 * m32 + tmp13 * m12) - (tmp16 * m32 + tmp12 * m12 + tmp15 * m22)),
                d * ((tmp20 * m32 + tmp12 * m02 + tmp19 * m22) - (tmp18 * m22 + tmp21 * m32 + tmp13 * m02)),
                d * ((tmp18 * m12 + tmp23 * m32 + tmp15 * m02) - (tmp22 * m32 + tmp14 * m02 + tmp19 * m12)),
                d * ((tmp22 * m22 + tmp16 * m02 + tmp21 * m12) - (tmp20 * m12 + tmp23 * m22 + tmp17 * m02)) // [15]
            ]);
            return mtxResult;
        }
        /**
         * Computes and returns a matrix with the given translation, its z-axis pointing directly at the given target,
         * and a minimal angle between its y-axis and the given up-{@link Vector3}, respetively calculating yaw and pitch.
         */
        static LOOK_AT(_translation, _target, _up = FudgeCore.Vector3.Y()) {
            const mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            let zAxis = FudgeCore.Vector3.DIFFERENCE(_target, _translation);
            zAxis.normalize();
            let xAxis = FudgeCore.Vector3.NORMALIZATION(FudgeCore.Vector3.CROSS(_up, zAxis));
            let yAxis = FudgeCore.Vector3.NORMALIZATION(FudgeCore.Vector3.CROSS(zAxis, xAxis));
            mtxResult.data.set([
                xAxis.x, xAxis.y, xAxis.z, 0,
                yAxis.x, yAxis.y, yAxis.z, 0,
                zAxis.x, zAxis.y, zAxis.z, 0,
                _translation.x,
                _translation.y,
                _translation.z,
                1
            ]);
            return mtxResult;
        }
        /**
         * Computes and returns a matrix with the given translation, its y-axis matching the given up-{@link Vector3}
         * and its z-axis facing towards the given target at a minimal angle, respetively calculating yaw only.
         */
        static SHOW_TO(_translation, _target, _up = FudgeCore.Vector3.Y()) {
            const mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            let zAxis = FudgeCore.Vector3.DIFFERENCE(_target, _translation);
            zAxis.normalize();
            let xAxis = FudgeCore.Vector3.NORMALIZATION(FudgeCore.Vector3.CROSS(_up, zAxis));
            // let yAxis: Vector3 = Vector3.NORMALIZATION(Vector3.CROSS(zAxis, xAxis));
            zAxis = FudgeCore.Vector3.NORMALIZATION(FudgeCore.Vector3.CROSS(xAxis, _up));
            mtxResult.data.set([
                xAxis.x, xAxis.y, xAxis.z, 0,
                _up.x, _up.y, _up.z, 0,
                zAxis.x, zAxis.y, zAxis.z, 0,
                _translation.x,
                _translation.y,
                _translation.z,
                1
            ]);
            return mtxResult;
        }
        /**
         * Returns a matrix that translates coordinates along the x-, y- and z-axis according to the given {@link Vector3}.
         */
        static TRANSLATION(_translate) {
            const mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            mtxResult.data.set([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                _translate.x, _translate.y, _translate.z, 1
            ]);
            return mtxResult;
        }
        /**
         * Returns a matrix that rotates coordinates on the x-axis when multiplied by.
         */
        static ROTATION_X(_angleInDegrees) {
            const mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            let angleInRadians = _angleInDegrees * Matrix4x4.deg2rad;
            let sin = Math.sin(angleInRadians);
            let cos = Math.cos(angleInRadians);
            mtxResult.data.set([
                1, 0, 0, 0,
                0, cos, sin, 0,
                0, -sin, cos, 0,
                0, 0, 0, 1
            ]);
            return mtxResult;
        }
        /**
         * Returns a matrix that rotates coordinates on the y-axis when multiplied by.
         */
        static ROTATION_Y(_angleInDegrees) {
            let mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            let angleInRadians = _angleInDegrees * Matrix4x4.deg2rad;
            let sin = Math.sin(angleInRadians);
            let cos = Math.cos(angleInRadians);
            mtxResult.data.set([
                cos, 0, -sin, 0,
                0, 1, 0, 0,
                sin, 0, cos, 0,
                0, 0, 0, 1
            ]);
            return mtxResult;
        }
        /**
         * Returns a matrix that rotates coordinates on the z-axis when multiplied by.
         */
        static ROTATION_Z(_angleInDegrees) {
            const mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            let angleInRadians = _angleInDegrees * Matrix4x4.deg2rad;
            let sin = Math.sin(angleInRadians);
            let cos = Math.cos(angleInRadians);
            mtxResult.data.set([
                cos, sin, 0, 0,
                -sin, cos, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]);
            return mtxResult;
        }
        /**
         * Returns a matrix that rotates coordinates when multiplied by, using the angles given.
         * Rotation occurs around the axis in the order Z-Y-X .
         */
        static ROTATION(_eulerAnglesInDegrees) {
            const mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            let anglesInRadians = FudgeCore.Vector3.SCALE(_eulerAnglesInDegrees, Matrix4x4.deg2rad);
            let sinX = Math.sin(anglesInRadians.x);
            let cosX = Math.cos(anglesInRadians.x);
            let sinY = Math.sin(anglesInRadians.y);
            let cosY = Math.cos(anglesInRadians.y);
            let sinZ = Math.sin(anglesInRadians.z);
            let cosZ = Math.cos(anglesInRadians.z);
            mtxResult.data.set([
                /**/ cosZ * cosY, /**/ sinZ * cosY, /**/ -sinY, 0,
                cosZ * sinY * sinX - sinZ * cosX, sinZ * sinY * sinX + cosZ * cosX, /**/ cosY * sinX, 0,
                cosZ * sinY * cosX + sinZ * sinX, sinZ * sinY * cosX - cosZ * sinX, /**/ cosY * cosX, 0,
                0, 0, 0, 1
            ]);
            return mtxResult;
        }
        /**
         * Returns a matrix that scales coordinates along the x-, y- and z-axis according to the given {@link Vector3}
         */
        static SCALING(_scalar) {
            const mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            mtxResult.data.set([
                _scalar.x, 0, 0, 0,
                0, _scalar.y, 0, 0,
                0, 0, _scalar.z, 0,
                0, 0, 0, 1
            ]);
            return mtxResult;
        }
        /**
         * Returns a representation of the given matrix relative to the given base.
         * If known, pass the inverse of the base to avoid unneccesary calculation
         */
        static RELATIVE(_mtx, _mtxBase, _mtxInverse) {
            if (_mtxInverse)
                return Matrix4x4.MULTIPLICATION(_mtxInverse, _mtx);
            let mtxInverse = Matrix4x4.INVERSION(_mtxBase);
            let mtxResult = Matrix4x4.MULTIPLICATION(mtxInverse, _mtx);
            FudgeCore.Recycler.store(mtxInverse);
            return mtxResult;
        }
        //#endregion
        //#region PROJECTIONS
        /**
         * Computes and returns a matrix that applies perspective to an object, if its transform is multiplied by it.
         * @param _aspect The aspect ratio between width and height of projectionspace.(Default = canvas.clientWidth / canvas.ClientHeight)
         * @param _fieldOfViewInDegrees The field of view in Degrees. (Default = 45)
         * @param _near The near clipspace border on the z-axis.
         * @param _far The far clipspace border on the z-axis.
         * @param _direction The plane on which the fieldOfView-Angle is given
         */
        static PROJECTION_CENTRAL(_aspect, _fieldOfViewInDegrees, _near, _far, _direction) {
            //TODO: camera looks down negative z-direction, should be positive
            let fieldOfViewInRadians = _fieldOfViewInDegrees * Matrix4x4.deg2rad;
            let f = Math.tan(0.5 * (Math.PI - fieldOfViewInRadians));
            let rangeInv = 1.0 / (_near - _far);
            const mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            mtxResult.data.set([
                f, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (_near + _far) * rangeInv, -1,
                0, 0, _near * _far * rangeInv * 2, 0
            ]);
            if (_direction == FudgeCore.FIELD_OF_VIEW.DIAGONAL) {
                _aspect = Math.sqrt(_aspect);
                mtxResult.data[0] = f / _aspect;
                mtxResult.data[5] = f * _aspect;
            }
            else if (_direction == FudgeCore.FIELD_OF_VIEW.VERTICAL)
                mtxResult.data[0] = f / _aspect;
            else //FOV_DIRECTION.HORIZONTAL
                mtxResult.data[5] = f * _aspect;
            // HACK: matrix should look in positive z-direction, preferably the matrix should be calculated like that right away
            mtxResult.rotateY(180);
            return mtxResult;
        }
        /**
         * Computes and returns a matrix that applies orthographic projection to an object, if its transform is multiplied by it.
         * @param _left The positionvalue of the projectionspace's left border.
         * @param _right The positionvalue of the projectionspace's right border.
         * @param _bottom The positionvalue of the projectionspace's bottom border.
         * @param _top The positionvalue of the projectionspace's top border.
         * @param _near The positionvalue of the projectionspace's near border.
         * @param _far The positionvalue of the projectionspace's far border
         */
        static PROJECTION_ORTHOGRAPHIC(_left, _right, _bottom, _top, _near = -400, _far = 400) {
            const mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            mtxResult.data.set([
                2 / (_right - _left), 0, 0, 0,
                0, 2 / (_top - _bottom), 0, 0,
                0, 0, 2 / (_near - _far), 0,
                (_left + _right) / (_left - _right),
                (_bottom + _top) / (_bottom - _top),
                (_near + _far) / (_near - _far),
                1
            ]);
            return mtxResult;
        }
        //#endregion
        //#region  Accessors
        /**
         * - get: return a vector representation of the translation {@link Vector3}.
         * **Caution!** Use immediately and readonly, since the vector is going to be reused by Recycler. Create a clone to keep longer and manipulate.
         * - set: effect the matrix ignoring its rotation and scaling
         */
        set translation(_translation) {
            this.data.set(_translation.get(), 12);
            // no full cache reset required
            if (this.vectors.translation)
                this.vectors.translation.set(_translation.x, _translation.y, _translation.z);
            else
                this.vectors.translation = _translation.clone;
            this.mutator = null;
        }
        get translation() {
            if (!this.vectors.translation) {
                this.vectors.translation = this.#vectors.translation;
                this.vectors.translation.set(this.data[12], this.data[13], this.data[14]);
            }
            return this.vectors.translation; // .clone;
        }
        /**
         * - get: return a vector representation of the rotation {@link Vector3}.
         * **Caution!** Use immediately and readonly, since the vector is going to be reused by Recycler. Create a clone to keep longer and manipulate.
         * - set: effect the matrix
         */
        get rotation() {
            if (!this.vectors.rotation)
                this.vectors.rotation = this.getEulerAngles().clone;
            return this.vectors.rotation; //.clone;
        }
        set rotation(_rotation) {
            this.mutate({ "rotation": _rotation });
            this.resetCache();
        }
        /**
         * - get: return a vector representation of the scaling {@link Vector3}.
         * **Caution!** Use immediately and readonly, since the vector is going to be reused by Recycler. Create a clone to keep longer and manipulate.
         * - set: effect the matrix
         */
        get scaling() {
            if (!this.vectors.scaling) {
                this.vectors.scaling = this.#vectors.scaling;
                this.vectors.scaling.set(Math.hypot(this.data[0], this.data[1], this.data[2]), Math.hypot(this.data[4], this.data[5], this.data[6]), Math.hypot(this.data[8], this.data[9], this.data[10]));
            }
            return this.vectors.scaling; // .clone;
        }
        set scaling(_scaling) {
            this.mutate({ "scaling": _scaling });
            this.resetCache();
        }
        /**
         * Return a copy of this
         */
        get clone() {
            let mtxClone = FudgeCore.Recycler.get(Matrix4x4);
            mtxClone.set(this);
            return mtxClone;
        }
        //#endregion
        recycle() {
            this.data.set([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]);
            this.resetCache();
        }
        //#region Rotation
        /**
         * Rotate this matrix by given {@link Vector3} in the order Z, Y, X. Right hand rotation is used, thumb points in axis direction, fingers curling indicate rotation
         * The rotation is appended to already applied transforms, thus multiplied from the right. Set _fromLeft to true to switch and put it in front.
         */
        rotate(_by, _fromLeft = false) {
            // this.rotateZ(_by.z, _fromLeft);
            // this.rotateY(_by.y, _fromLeft);
            // this.rotateX(_by.x, _fromLeft);
            let mtxRotation = Matrix4x4.ROTATION(_by);
            this.multiply(mtxRotation, _fromLeft);
            FudgeCore.Recycler.store(mtxRotation);
        }
        transpose() {
            let matrix = this.data;
            this.data.set([
                matrix[0], matrix[4], matrix[8], matrix[12],
                matrix[1], matrix[5], matrix[9], matrix[13],
                matrix[2], matrix[6], matrix[10], matrix[14],
                matrix[3], matrix[7], matrix[11], matrix[15]
            ]);
            return this;
        }
        inverse() {
            let m = this.data;
            let m00 = m[0 * 4 + 0];
            let m01 = m[0 * 4 + 1];
            let m02 = m[0 * 4 + 2];
            let m03 = m[0 * 4 + 3];
            let m10 = m[1 * 4 + 0];
            let m11 = m[1 * 4 + 1];
            let m12 = m[1 * 4 + 2];
            let m13 = m[1 * 4 + 3];
            let m20 = m[2 * 4 + 0];
            let m21 = m[2 * 4 + 1];
            let m22 = m[2 * 4 + 2];
            let m23 = m[2 * 4 + 3];
            let m30 = m[3 * 4 + 0];
            let m31 = m[3 * 4 + 1];
            let m32 = m[3 * 4 + 2];
            let m33 = m[3 * 4 + 3];
            let tmp0 = m22 * m33;
            let tmp1 = m32 * m23;
            let tmp2 = m12 * m33;
            let tmp3 = m32 * m13;
            let tmp4 = m12 * m23;
            let tmp5 = m22 * m13;
            let tmp6 = m02 * m33;
            let tmp7 = m32 * m03;
            let tmp8 = m02 * m23;
            let tmp9 = m22 * m03;
            let tmp10 = m02 * m13;
            let tmp11 = m12 * m03;
            let tmp12 = m20 * m31;
            let tmp13 = m30 * m21;
            let tmp14 = m10 * m31;
            let tmp15 = m30 * m11;
            let tmp16 = m10 * m21;
            let tmp17 = m20 * m11;
            let tmp18 = m00 * m31;
            let tmp19 = m30 * m01;
            let tmp20 = m00 * m21;
            let tmp21 = m20 * m01;
            let tmp22 = m00 * m11;
            let tmp23 = m10 * m01;
            let t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) -
                (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);
            let t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) -
                (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);
            let t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) -
                (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);
            let t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) -
                (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);
            let d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);
            // let matrix: Matrix4x4 = new Matrix4x4;
            const matrix = FudgeCore.Recycler.get(Matrix4x4);
            matrix.data.set([
                d * t0,
                d * t1,
                d * t2,
                d * t3,
                d * ((tmp1 * m10 + tmp2 * m20 + tmp5 * m30) - (tmp0 * m10 + tmp3 * m20 + tmp4 * m30)),
                d * ((tmp0 * m00 + tmp7 * m20 + tmp8 * m30) - (tmp1 * m00 + tmp6 * m20 + tmp9 * m30)),
                d * ((tmp3 * m00 + tmp6 * m10 + tmp11 * m30) - (tmp2 * m00 + tmp7 * m10 + tmp10 * m30)),
                d * ((tmp4 * m00 + tmp9 * m10 + tmp10 * m20) - (tmp5 * m00 + tmp8 * m10 + tmp11 * m20)),
                d * ((tmp12 * m13 + tmp15 * m23 + tmp16 * m33) - (tmp13 * m13 + tmp14 * m23 + tmp17 * m33)),
                d * ((tmp13 * m03 + tmp18 * m23 + tmp21 * m33) - (tmp12 * m03 + tmp19 * m23 + tmp20 * m33)),
                d * ((tmp14 * m03 + tmp19 * m13 + tmp22 * m33) - (tmp15 * m03 + tmp18 * m13 + tmp23 * m33)),
                d * ((tmp17 * m03 + tmp20 * m13 + tmp23 * m23) - (tmp16 * m03 + tmp21 * m13 + tmp22 * m23)),
                d * ((tmp14 * m22 + tmp17 * m32 + tmp13 * m12) - (tmp16 * m32 + tmp12 * m12 + tmp15 * m22)),
                d * ((tmp20 * m32 + tmp12 * m02 + tmp19 * m22) - (tmp18 * m22 + tmp21 * m32 + tmp13 * m02)),
                d * ((tmp18 * m12 + tmp23 * m32 + tmp15 * m02) - (tmp22 * m32 + tmp14 * m02 + tmp19 * m12)),
                d * ((tmp22 * m22 + tmp16 * m02 + tmp21 * m12) - (tmp20 * m12 + tmp23 * m22 + tmp17 * m02)) // [15]
            ]);
            return matrix;
        }
        /**
         * Adds a rotation around the x-axis to this matrix
         */
        rotateX(_angleInDegrees, _fromLeft = false) {
            let mtxRotation = Matrix4x4.ROTATION_X(_angleInDegrees);
            this.multiply(mtxRotation, _fromLeft);
            FudgeCore.Recycler.store(mtxRotation);
        }
        /**
         * Adds a rotation around the y-axis to this matrix
         */
        rotateY(_angleInDegrees, _fromLeft = false) {
            let mtxRotation = Matrix4x4.ROTATION_Y(_angleInDegrees);
            this.multiply(mtxRotation, _fromLeft);
            FudgeCore.Recycler.store(mtxRotation);
        }
        /**
         * Adds a rotation around the z-axis to this matrix
         */
        rotateZ(_angleInDegrees, _fromLeft = false) {
            let mtxRotation = Matrix4x4.ROTATION_Z(_angleInDegrees);
            this.multiply(mtxRotation, _fromLeft);
            FudgeCore.Recycler.store(mtxRotation);
        }
        /**
         * Adjusts the rotation of this matrix to point the z-axis directly at the given target and tilts it to accord with the given up-{@link Vector3},
         * respectively calculating yaw and pitch. If no up-{@link Vector3} is given, the previous up-{@link Vector3} is used.
         * When _preserveScaling is false, a rotated identity matrix is the result.
         */
        lookAt(_target, _up, _preserveScaling = true) {
            if (!_up)
                _up = this.getY();
            const mtxResult = Matrix4x4.LOOK_AT(this.translation, _target, _up);
            if (_preserveScaling)
                mtxResult.scale(this.scaling);
            this.set(mtxResult);
            FudgeCore.Recycler.store(mtxResult);
        }
        /**
         * Same as {@link Matrix4x4.lookAt}, but optimized and needs testing
         */
        // TODO: testing lookat that really just rotates the matrix rather than creating a new one
        lookAtRotate(_target, _up, _preserveScaling = true) {
            if (!_up)
                _up = this.getY();
            let scaling = this.scaling;
            let difference = FudgeCore.Vector3.DIFFERENCE(_target, this.translation);
            difference.normalize();
            let cos = FudgeCore.Vector3.DOT(FudgeCore.Vector3.NORMALIZATION(this.getZ()), difference);
            let sin = FudgeCore.Vector3.DOT(FudgeCore.Vector3.NORMALIZATION(this.getX()), difference);
            // console.log(sin, cos);
            let mtxRotation = FudgeCore.Recycler.borrow(Matrix4x4);
            mtxRotation.data.set([
                cos, 0, -sin, 0,
                0, 1, 0, 0,
                sin, 0, cos, 0,
                0, 0, 0, 1
            ]);
            this.multiply(mtxRotation, false);
            cos = FudgeCore.Vector3.DOT(FudgeCore.Vector3.NORMALIZATION(this.getZ()), difference);
            sin = -FudgeCore.Vector3.DOT(FudgeCore.Vector3.NORMALIZATION(this.getY()), difference);
            // console.log(sin, cos);
            mtxRotation.data.set([
                1, 0, 0, 0,
                0, cos, sin, 0,
                0, -sin, cos, 0,
                0, 0, 0, 1
            ]);
            this.multiply(mtxRotation, false);
            this.scaling = scaling;
        }
        /**
         * Adjusts the rotation of this matrix to match its y-axis with the given up-{@link Vector3} and facing its z-axis toward the given target at minimal angle,
         * respectively calculating yaw only. If no up-{@link Vector3} is given, the previous up-{@link Vector3} is used.
         * When _preserveScaling is false, a rotated identity matrix is the result.
         */
        showTo(_target, _up, _preserveScaling = true) {
            if (!_up)
                _up = this.getY();
            const mtxResult = Matrix4x4.SHOW_TO(this.translation, _target, _up);
            if (_preserveScaling)
                mtxResult.scale(this.scaling);
            this.set(mtxResult);
            FudgeCore.Recycler.store(mtxResult);
        }
        //#endregion
        //#region Translation
        /**
         * Add a translation by the given {@link Vector3} to this matrix.
         * If _local is true, translation occurs according to the current rotation and scaling of this matrix,
         * according to the parent otherwise.
         */
        translate(_by, _local = true) {
            if (_local) {
                let mtxTranslation = Matrix4x4.TRANSLATION(_by);
                this.multiply(mtxTranslation);
                FudgeCore.Recycler.store(mtxTranslation);
            }
            else {
                this.data[12] += _by.x;
                this.data[13] += _by.y;
                this.data[14] += _by.z;
                this.mutator = null;
                if (this.vectors.translation)
                    FudgeCore.Recycler.store(this.vectors.translation);
                this.vectors.translation = null;
            }
            // const matrix: Matrix4x4 = Matrix4x4.MULTIPLICATION(this, Matrix4x4.TRANSLATION(_by));
            // // TODO: possible optimization, translation may alter mutator instead of deleting it.
            // this.set(matrix);
            // Recycler.store(matrix);
        }
        /**
         * Add a translation along the x-axis by the given amount to this matrix
         */
        translateX(_x, _local = true) {
            let translation = FudgeCore.Vector3.X(_x);
            this.translate(translation, _local);
            FudgeCore.Recycler.store(translation);
        }
        /**
         * Add a translation along the y-axis by the given amount to this matrix
         */
        translateY(_y, _local = true) {
            let translation = FudgeCore.Vector3.Y(_y);
            this.translate(translation, _local);
            FudgeCore.Recycler.store(translation);
        }
        /**
         * Add a translation along the z-axis by the given amount to this matrix
         */
        translateZ(_z, _local = true) {
            let translation = FudgeCore.Vector3.Z(_z);
            this.translate(translation, _local);
            FudgeCore.Recycler.store(translation);
        }
        //#endregion
        //#region Scaling
        /**
         * Add a scaling by the given {@link Vector3} to this matrix
         */
        scale(_by) {
            const mtxResult = Matrix4x4.MULTIPLICATION(this, Matrix4x4.SCALING(_by));
            this.set(mtxResult);
            FudgeCore.Recycler.store(mtxResult);
        }
        /**
         * Add a scaling along the x-axis by the given amount to this matrix
         */
        scaleX(_by) {
            let vector = FudgeCore.Recycler.get(FudgeCore.Vector3);
            vector.set(_by, 1, 1);
            this.scale(vector);
            FudgeCore.Recycler.store(vector);
        }
        /**
         * Add a scaling along the y-axis by the given amount to this matrix
         */
        scaleY(_by) {
            let vector = FudgeCore.Recycler.get(FudgeCore.Vector3);
            vector.set(1, _by, 1);
            this.scale(vector);
            FudgeCore.Recycler.store(vector);
        }
        /**
         * Add a scaling along the z-axis by the given amount to this matrix
         */
        scaleZ(_by) {
            let vector = FudgeCore.Recycler.get(FudgeCore.Vector3);
            vector.set(1, 1, _by);
            this.scale(vector);
            FudgeCore.Recycler.store(vector);
        }
        //#endregion
        //#region Transformation
        /**
         * Multiply this matrix with the given matrix
         */
        multiply(_matrix, _fromLeft = false) {
            const mtxResult = _fromLeft ? Matrix4x4.MULTIPLICATION(_matrix, this) : Matrix4x4.MULTIPLICATION(this, _matrix);
            this.set(mtxResult);
            FudgeCore.Recycler.store(mtxResult);
        }
        //#endregion
        //#region Transfer
        /**
         * Calculates and returns the euler-angles representing the current rotation of this matrix.
         * **Caution!** Use immediately and readonly, since the vector is going to be reused by Recycler. Create a clone to keep longer and manipulate.
         */
        getEulerAngles() {
            let scaling = this.scaling;
            let s0 = this.data[0] / scaling.x;
            let s1 = this.data[1] / scaling.x;
            let s2 = this.data[2] / scaling.x;
            let s6 = this.data[6] / scaling.y;
            let s10 = this.data[10] / scaling.z;
            let sy = Math.hypot(s0, s1); // probably 2. param should be this.data[4] / scaling.y
            let singular = sy < 1e-6; // If
            let x1, y1, z1;
            let x2, y2, z2;
            if (!singular) {
                x1 = Math.atan2(s6, s10);
                y1 = Math.atan2(-s2, sy);
                z1 = Math.atan2(s1, s0);
                x2 = Math.atan2(-s6, -s10);
                y2 = Math.atan2(-s2, -sy);
                z2 = Math.atan2(-s1, -s0);
                if (Math.abs(x2) + Math.abs(y2) + Math.abs(z2) < Math.abs(x1) + Math.abs(y1) + Math.abs(z1)) {
                    x1 = x2;
                    y1 = y2;
                    z1 = z2;
                }
            }
            else {
                x1 = Math.atan2(-this.data[9] / scaling.z, this.data[5] / scaling.y);
                y1 = Math.atan2(-this.data[2] / scaling.x, sy);
                z1 = 0;
            }
            // let rotation: Vector3 = Recycler.borrow(Vector3);
            this.#eulerAngles.set(x1, y1, z1);
            this.#eulerAngles.scale(180 / Math.PI);
            return this.#eulerAngles;
        }
        /**
         * Sets the elements of this matrix to the values of the given matrix
         */
        set(_mtxTo) {
            if (_mtxTo instanceof Float32Array)
                this.data.set(_mtxTo);
            else
                this.data.set(_mtxTo.data);
            this.resetCache();
        }
        toString() {
            return `∆í.Matrix4x4(translation: ${this.translation.toString()}, rotation: ${this.rotation.toString()}, scaling: ${this.scaling.toString()}`;
        }
        /**
         * Return the elements of this matrix as a Float32Array
         */
        get() {
            return new Float32Array(this.data);
        }
        /**
         * Return cardinal x-axis
         */
        getX() {
            let result = FudgeCore.Recycler.get(FudgeCore.Vector3);
            result.set(this.data[0], this.data[1], this.data[2]);
            return result;
        }
        /**
         * Return cardinal y-axis
         */
        getY() {
            let result = FudgeCore.Recycler.get(FudgeCore.Vector3);
            result.set(this.data[4], this.data[5], this.data[6]);
            return result;
        }
        /**
         * Return cardinal z-axis
         */
        getZ() {
            let result = FudgeCore.Recycler.get(FudgeCore.Vector3);
            result.set(this.data[8], this.data[9], this.data[10]);
            return result;
        }
        /**
         * Swaps the two cardinal axis and reverses the third, effectively rotating the transform 180 degrees around one and 90 degrees around a second axis
         */
        swapXY() {
            let temp = [this.data[0], this.data[1], this.data[2]]; // store x-axis
            this.data.set([this.data[4], this.data[5], this.data[6]], 0); // overwrite x-axis with y-axis
            this.data.set(temp, 4); // overwrite Y with temp
            this.data.set([-this.data[8], -this.data[9], -this.data[10]], 8); // reverse z-axis
        }
        /**
         * Swaps the two cardinal axis and reverses the third, effectively rotating the transform 180 degrees around one and 90 degrees around a second axis
         */
        swapXZ() {
            let temp = [this.data[0], this.data[1], this.data[2]]; // store x-axis
            this.data.set([this.data[8], this.data[9], this.data[10]], 0); // overwrite x-axis with z-axis
            this.data.set(temp, 8); // overwrite Z with temp
            this.data.set([-this.data[4], -this.data[5], -this.data[6]], 4); // reverse y-axis
        }
        /**
         * Swaps the two cardinal axis and reverses the third, effectively rotating the transform 180 degrees around one and 90 degrees around a second axis
         */
        swapYZ() {
            let temp = [this.data[4], this.data[5], this.data[6]]; // store y-axis
            this.data.set([this.data[8], this.data[9], this.data[10]], 4); // overwrite y-axis with z-axis
            this.data.set(temp, 8); // overwrite Z with temp
            this.data.set([-this.data[0], -this.data[1], -this.data[2]], 0); // reverse x-axis
        }
        /**
         * Returns the tranlation from this matrix to the target matrix
         */
        getTranslationTo(_mtxTarget) {
            let difference = FudgeCore.Recycler.get(FudgeCore.Vector3);
            difference.set(_mtxTarget.data[12] - this.data[12], _mtxTarget.data[13] - this.data[13], _mtxTarget.data[14] - this.data[14]);
            return difference;
        }
        serialize() {
            // this.getMutator();
            let serialization = {
                translation: this.translation.serialize(),
                rotation: this.rotation.serialize(),
                scaling: this.scaling.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            let mutator = {
                translation: await this.translation.deserialize(_serialization.translation),
                rotation: await this.rotation.deserialize(_serialization.rotation),
                scaling: await this.scaling.deserialize(_serialization.scaling)
            };
            this.mutate(mutator);
            return this;
        }
        getMutator() {
            if (this.mutator)
                return this.mutator;
            let mutator = {
                translation: this.translation.getMutator(),
                rotation: this.rotation.getMutator(),
                scaling: this.scaling.getMutator()
            };
            // cache mutator
            this.mutator = mutator;
            return mutator;
        }
        async mutate(_mutator) {
            let oldTranslation = this.translation;
            let oldRotation = this.rotation;
            let oldScaling = this.scaling;
            let newTranslation = _mutator["translation"];
            let newRotation = _mutator["rotation"];
            let newScaling = _mutator["scaling"];
            let vectors = { translation: oldTranslation, rotation: oldRotation, scaling: oldScaling };
            if (newTranslation) {
                vectors.translation = vectors.translation || this.#vectors.translation;
                vectors.translation.set(newTranslation.x != undefined ? newTranslation.x : oldTranslation.x, newTranslation.y != undefined ? newTranslation.y : oldTranslation.y, newTranslation.z != undefined ? newTranslation.z : oldTranslation.z);
            }
            if (newRotation) {
                vectors.rotation = vectors.rotation || this.#vectors.rotation;
                vectors.rotation.set(newRotation.x != undefined ? newRotation.x : oldRotation.x, newRotation.y != undefined ? newRotation.y : oldRotation.y, newRotation.z != undefined ? newRotation.z : oldRotation.z);
            }
            if (newScaling) {
                vectors.scaling = vectors.scaling || this.#vectors.scaling;
                vectors.scaling.set(newScaling.x != undefined ? newScaling.x : oldScaling.x, newScaling.y != undefined ? newScaling.y : oldScaling.y, newScaling.z != undefined ? newScaling.z : oldScaling.z);
            }
            // TODO: possible performance optimization when only one or two components change, then use old matrix instead of IDENTITY and transform by differences/quotients
            let mtxResult = Matrix4x4.IDENTITY();
            if (vectors.translation)
                mtxResult.translate(vectors.translation);
            if (vectors.rotation) {
                // mtxResult.rotateZ(vectors.rotation.z);
                // mtxResult.rotateY(vectors.rotation.y);
                // mtxResult.rotateX(vectors.rotation.x);
                mtxResult.rotate(vectors.rotation);
            }
            if (vectors.scaling)
                mtxResult.scale(vectors.scaling);
            this.set(mtxResult);
            this.vectors = vectors;
            FudgeCore.Recycler.store(mtxResult);
        }
        getMutatorAttributeTypes(_mutator) {
            let types = {};
            if (_mutator.translation)
                types.translation = "Vector3";
            if (_mutator.rotation)
                types.rotation = "Vector3";
            if (_mutator.scaling)
                types.scaling = "Vector3";
            return types;
        }
        reduceMutator(_mutator) { }
        resetCache() {
            this.vectors = { translation: null, rotation: null, scaling: null };
            this.mutator = null;
        }
    }
    Matrix4x4.deg2rad = Math.PI / 180;
    FudgeCore.Matrix4x4 = Matrix4x4;
    //#endregion
})(FudgeCore || (FudgeCore = {}));
/**
 * Baseclass for Noise2, Noise3 and Noise4
 * @authors Jirka Dell'Oro-Friedl, HFU, 2021
 * This is an adaption of https://www.npmjs.com/package/fast-simplex-noise
 */
var FudgeCore;
/**
 * Baseclass for Noise2, Noise3 and Noise4
 * @authors Jirka Dell'Oro-Friedl, HFU, 2021
 * This is an adaption of https://www.npmjs.com/package/fast-simplex-noise
 */
(function (FudgeCore) {
    class Noise {
        constructor(_random = Math.random) {
            this.perm = new Uint8Array(512);
            this.permMod12 = new Uint8Array(512);
            const p = new Uint8Array(256);
            for (let i = 0; i < 256; i++)
                p[i] = i;
            let n;
            let q;
            for (let i = 255; i > 0; i--) {
                n = Math.floor((i + 1) * _random());
                q = p[i];
                p[i] = p[n];
                p[n] = q;
            }
            for (let i = 0; i < 512; i++) {
                this.perm[i] = p[i & 255];
                this.permMod12[i] = this.perm[i] % 12;
            }
        }
    }
    FudgeCore.Noise = Noise;
})(FudgeCore || (FudgeCore = {}));
///<reference path="./Noise.ts"/>
/**
 * This is an adaption of https://www.npmjs.com/package/fast-simplex-noise
 * done by Jirka Dell'Oro-Friedl, HFU, 2021
 *
 * Based on example code by Stefan Gustavson (stegu@itn.liu.se).
 * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
 * Better rank ordering method by Stefan Gustavson in 2012.
 *
 * This code was placed in the public domain by its original author,
 * Stefan Gustavson. You may use it as you see fit, but
 * attribution is appreciated.
 */
var FudgeCore;
///<reference path="./Noise.ts"/>
/**
 * This is an adaption of https://www.npmjs.com/package/fast-simplex-noise
 * done by Jirka Dell'Oro-Friedl, HFU, 2021
 *
 * Based on example code by Stefan Gustavson (stegu@itn.liu.se).
 * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
 * Better rank ordering method by Stefan Gustavson in 2012.
 *
 * This code was placed in the public domain by its original author,
 * Stefan Gustavson. You may use it as you see fit, but
 * attribution is appreciated.
 */
(function (FudgeCore) {
    class Noise2 extends FudgeCore.Noise {
        constructor(_random = Math.random) {
            super(_random);
            this.#sample = null;
            this.sample = (_x, _y) => {
                return this.#sample(_x, _y);
            };
            this.#sample = (_x, _y) => {
                // Skew the input space to determine which simplex cell we're in
                const s = (_x + _y) * 0.5 * (Math.sqrt(3.0) - 1.0); // Hairy factor for 2D
                const i = Math.floor(_x + s);
                const j = Math.floor(_y + s);
                const t = (i + j) * Noise2.offset;
                const X0 = i - t; // Unskew the cell origin back to (x,y) space
                const Y0 = j - t;
                const x0 = _x - X0; // The x,y distances from the cell origin
                const y0 = _y - Y0;
                // Determine which simplex we are in.
                const i1 = x0 > y0 ? 1 : 0;
                const j1 = x0 > y0 ? 0 : 1;
                // Offset:numbers for corners
                const x1 = x0 - i1 + Noise2.offset;
                const y1 = y0 - j1 + Noise2.offset;
                const x2 = x0 - 1.0 + 2.0 * Noise2.offset;
                const y2 = y0 - 1.0 + 2.0 * Noise2.offset;
                // Work out the hashed gradient indices of the three simplex corners
                const ii = i & 255;
                const jj = j & 255;
                const g0 = Noise2.gradient[this.permMod12[ii + this.perm[jj]]];
                const g1 = Noise2.gradient[this.permMod12[ii + i1 + this.perm[jj + j1]]];
                const g2 = Noise2.gradient[this.permMod12[ii + 1 + this.perm[jj + 1]]];
                // Calculate the contribution from the three corners
                const t0 = 0.5 - x0 * x0 - y0 * y0;
                const n0 = t0 < 0 ? 0.0 : Math.pow(t0, 4) * (g0[0] * x0 + g0[1] * y0);
                const t1 = 0.5 - x1 * x1 - y1 * y1;
                const n1 = t1 < 0 ? 0.0 : Math.pow(t1, 4) * (g1[0] * x1 + g1[1] * y1);
                const t2 = 0.5 - x2 * x2 - y2 * y2;
                const n2 = t2 < 0 ? 0.0 : Math.pow(t2, 4) * (g2[0] * x2 + g2[1] * y2);
                // Add contributions from each corner to get the final noise value.
                // The result is scaled to return values in the interval [-1, 1]
                return 70.14805770653952 * (n0 + n1 + n2);
            };
        }
        #sample;
    }
    Noise2.offset = (3.0 - Math.sqrt(3.0)) / 6.0;
    Noise2.gradient = [[1, 1], [-1, 1], [1, -1], [-1, -1], [1, 0], [-1, 0], [1, 0], [-1, 0], [0, 1], [0, -1], [0, 1], [0, -1]];
    FudgeCore.Noise2 = Noise2;
})(FudgeCore || (FudgeCore = {}));
/**
 * This is an adaption of https://www.npmjs.com/package/fast-simplex-noise
 * done by Jirka Dell'Oro-Friedl, HFU, 2021
 *
 * Based on example code by Stefan Gustavson (stegu@itn.liu.se).
 * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
 * Better rank ordering method by Stefan Gustavson in 2012.
 *
 * This code was placed in the public domain by its original author,
 * Stefan Gustavson. You may use it as you see fit, but
 * attribution is appreciated.
 */
var FudgeCore;
/**
 * This is an adaption of https://www.npmjs.com/package/fast-simplex-noise
 * done by Jirka Dell'Oro-Friedl, HFU, 2021
 *
 * Based on example code by Stefan Gustavson (stegu@itn.liu.se).
 * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
 * Better rank ordering method by Stefan Gustavson in 2012.
 *
 * This code was placed in the public domain by its original author,
 * Stefan Gustavson. You may use it as you see fit, but
 * attribution is appreciated.
 */
(function (FudgeCore) {
    // TODO: Test
    class Noise3 extends FudgeCore.Noise {
        constructor(_random = Math.random) {
            super(_random);
            this.#sample = null;
            this.sample = (_x, _y, _z) => {
                return this.#sample(_x, _y, _z);
            };
            this.#sample = (_x, _y, _z) => {
                // Skew the input space to determine which simplex cell we're in
                const s = (_x + _y + _z) / 3.0; // Very nice and simple skew factor for 3D
                const i = Math.floor(_x + s);
                const j = Math.floor(_y + s);
                const k = Math.floor(_z + s);
                const t = (i + j + k) * Noise3.offset;
                const X0 = i - t; // Unskew the cell origin back to (x,y,z) space
                const Y0 = j - t;
                const Z0 = k - t;
                const x0 = _x - X0; // The x,y,z distances from the cell origin
                const y0 = _y - Y0;
                const z0 = _z - Z0;
                // Deterine which simplex we are in
                let i1, j1, k1 // Offsets for second corner of simplex in (i,j,k) coords
                ;
                let i2, j2, k2 // Offsets for third corner of simplex in (i,j,k) coords
                ;
                if (x0 >= y0) {
                    if (y0 >= z0) {
                        i1 = i2 = j2 = 1;
                        j1 = k1 = k2 = 0;
                    }
                    else if (x0 >= z0) {
                        i1 = i2 = k2 = 1;
                        j1 = k1 = j2 = 0;
                    }
                    else {
                        k1 = i2 = k2 = 1;
                        i1 = j1 = j2 = 0;
                    }
                }
                else {
                    if (y0 < z0) {
                        k1 = j2 = k2 = 1;
                        i1 = j1 = i2 = 0;
                    }
                    else if (x0 < z0) {
                        j1 = j2 = k2 = 1;
                        i1 = k1 = i2 = 0;
                    }
                    else {
                        j1 = i2 = j2 = 1;
                        i1 = k1 = k2 = 0;
                    }
                }
                const x1 = x0 - i1 + Noise3.offset; // Offsets for second corner in (x,y,z) coords
                const y1 = y0 - j1 + Noise3.offset;
                const z1 = z0 - k1 + Noise3.offset;
                const x2 = x0 - i2 + 2.0 * Noise3.offset; // Offsets for third corner in (x,y,z) coords
                const y2 = y0 - j2 + 2.0 * Noise3.offset;
                const z2 = z0 - k2 + 2.0 * Noise3.offset;
                const x3 = x0 - 1.0 + 3.0 * Noise3.offset; // Offsets for last corner in (x,y,z) coords
                const y3 = y0 - 1.0 + 3.0 * Noise3.offset;
                const z3 = z0 - 1.0 + 3.0 * Noise3.offset;
                // Work :numberut the hashed gradient indices of the four simplex corners
                const ii = i & 255;
                const jj = j & 255;
                const kk = k & 255;
                const g0 = Noise3.gradient[this.permMod12[ii + this.perm[jj + this.perm[kk]]]];
                const g1 = Noise3.gradient[this.permMod12[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]]];
                const g2 = Noise3.gradient[this.permMod12[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]]];
                const g3 = Noise3.gradient[this.permMod12[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]]];
                // Calcu:numberate the contribution from the four corners
                const t0 = 0.5 - x0 * x0 - y0 * y0 - z0 * z0;
                const n0 = t0 < 0
                    ? 0.0
                    : Math.pow(t0, 4) * (g0[0] * x0 + g0[1] * y0 + g0[2] * z0);
                const t1 = 0.5 - x1 * x1 - y1 * y1 - z1 * z1;
                const n1 = t1 < 0
                    ? 0.0
                    : Math.pow(t1, 4) * (g1[0] * x1 + g1[1] * y1 + g1[2] * z1);
                const t2 = 0.5 - x2 * x2 - y2 * y2 - z2 * z2;
                const n2 = t2 < 0
                    ? 0.0
                    : Math.pow(t2, 4) * (g2[0] * x2 + g2[1] * y2 + g2[2] * z2);
                const t3 = 0.5 - x3 * x3 - y3 * y3 - z3 * z3;
                const n3 = t3 < 0
                    ? 0.0
                    : Math.pow(t3, 4) * (g3[0] * x3 + g3[1] * y3 + g3[2] * z3);
                // Add contributions from each corner to get the final noise value.
                // The result is scaled to stay just inside [-1,1]
                return 94.68493150681972 * (n0 + n1 + n2 + n3);
            };
        }
        #sample;
    }
    Noise3.offset = 1.0 / 6.0;
    Noise3.gradient = [[1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0], [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1], [0, 1, 1], [0, -1, -1], [0, 1, -1], [0, -1, -1]
    ];
    FudgeCore.Noise3 = Noise3;
})(FudgeCore || (FudgeCore = {}));
/**
 * This is an adaption of https://www.npmjs.com/package/fast-simplex-noise
 * done by Jirka Dell'Oro-Friedl, HFU, 2021
 *
 * Based on example code by Stefan Gustavson (stegu@itn.liu.se).
 * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
 * Better rank ordering method by Stefan Gustavson in 2012.
 *
 * This code was placed in the public domain by its original author,
 * Stefan Gustavson. You may use it as you see fit, but
 * attribution is appreciated.
 */
var FudgeCore;
/**
 * This is an adaption of https://www.npmjs.com/package/fast-simplex-noise
 * done by Jirka Dell'Oro-Friedl, HFU, 2021
 *
 * Based on example code by Stefan Gustavson (stegu@itn.liu.se).
 * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
 * Better rank ordering method by Stefan Gustavson in 2012.
 *
 * This code was placed in the public domain by its original author,
 * Stefan Gustavson. You may use it as you see fit, but
 * attribution is appreciated.
 */
(function (FudgeCore) {
    // TODO: Test
    class Noise4 extends FudgeCore.Noise {
        constructor(_random = Math.random) {
            super(_random);
            this.#sample = null;
            this.sample = (_x, _y, _z, _w) => {
                return this.#sample(_x, _y, _z, _w);
            };
            this.#sample = (x, y, z, w) => {
                // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in
                const s = (x + y + z + w) * (Math.sqrt(5.0) - 1.0) / 4.0; // Factor for 4D skewing
                const i = Math.floor(x + s);
                const j = Math.floor(y + s);
                const k = Math.floor(z + s);
                const l = Math.floor(w + s);
                const t = (i + j + k + l) * Noise4.offset; // Factor for 4D unskewing
                const X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space
                const Y0 = j - t;
                const Z0 = k - t;
                const W0 = l - t;
                const x0 = x - X0; // The x,y,z,w distances from the cell origin
                const y0 = y - Y0;
                const z0 = z - Z0;
                const w0 = w - W0;
                // To find out which of the 24 possible simplices we're in, we need to determine the
                // magnitude ordering of x0, y0, z0 and w0. Six pair-wise comparisons are performed between
                // each possible pair of the four coordinates, and the results are used to rank the numbers.
                let rankx = 0;
                let ranky = 0;
                let rankz = 0;
                let rankw = 0;
                if (x0 > y0)
                    rankx++;
                else
                    ranky++;
                if (x0 > z0)
                    rankx++;
                else
                    rankz++;
                if (x0 > w0)
                    rankx++;
                else
                    rankw++;
                if (y0 > z0)
                    ranky++;
                else
                    rankz++;
                if (y0 > w0)
                    ranky++;
                else
                    rankw++;
                if (z0 > w0)
                    rankz++;
                else
                    rankw++;
                // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.
                // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w
                // impossible. Only the 24 indices which have non-zero entries make any sense.
                // We use a thresholding to set the coordinates in turn from the largest magnitude.
                // Rank 3 denotes the largest coordinate.
                const i1 = rankx >= 3 ? 1 : 0;
                const j1 = ranky >= 3 ? 1 : 0;
                const k1 = rankz >= 3 ? 1 : 0;
                const l1 = rankw >= 3 ? 1 : 0;
                // Rank : 2 denotes the second largest coordinate.
                const i2 = rankx >= 2 ? 1 : 0;
                const j2 = ranky >= 2 ? 1 : 0;
                const k2 = rankz >= 2 ? 1 : 0;
                const l2 = rankw >= 2 ? 1 : 0;
                // Rank : 1 denotes the second smallest coordinate.
                const i3 = rankx >= 1 ? 1 : 0;
                const j3 = ranky >= 1 ? 1 : 0;
                const k3 = rankz >= 1 ? 1 : 0;
                const l3 = rankw >= 1 ? 1 : 0;
                // The fifth corner has all coordinate offsets = 1, so no need to compute that.
                const x1 = x0 - i1 + Noise4.offset; // Offsets for second corner in (x,y,z,w) coords
                const y1 = y0 - j1 + Noise4.offset;
                const z1 = z0 - k1 + Noise4.offset;
                const w1 = w0 - l1 + Noise4.offset;
                const x2 = x0 - i2 + 2.0 * Noise4.offset; // Offsets for third corner in (x,y,z,w) coords
                const y2 = y0 - j2 + 2.0 * Noise4.offset;
                const z2 = z0 - k2 + 2.0 * Noise4.offset;
                const w2 = w0 - l2 + 2.0 * Noise4.offset;
                const x3 = x0 - i3 + 3.0 * Noise4.offset; // Offsets for fourth corner in (x,y,z,w) coords
                const y3 = y0 - j3 + 3.0 * Noise4.offset;
                const z3 = z0 - k3 + 3.0 * Noise4.offset;
                const w3 = w0 - l3 + 3.0 * Noise4.offset;
                const x4 = x0 - 1.0 + 4.0 * Noise4.offset; // Offsets for last corner in (x,y,z,w) coords
                const y4 = y0 - 1.0 + 4.0 * Noise4.offset;
                const z4 = z0 - 1.0 + 4.0 * Noise4.offset;
                const w4 = w0 - 1.0 + 4.0 * Noise4.offset;
                // Work out the hashed gradient indices of the five simplex corners
                const ii = i & 255;
                const jj = j & 255;
                const kk = k & 255;
                const ll = l & 255;
                const g0 = Noise4.gradient[this.perm[ii + this.perm[jj + this.perm[kk + this.perm[ll]]]] %
                    32];
                const g1 = Noise4.gradient[this.perm[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1 + this.perm[ll + l1]]]] % 32];
                const g2 = Noise4.gradient[this.perm[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2 + this.perm[ll + l2]]]] % 32];
                const g3 = Noise4.gradient[this.perm[ii + i3 + this.perm[jj + j3 + this.perm[kk + k3 + this.perm[ll + l3]]]] % 32];
                const g4 = Noise4.gradient[this.perm[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1 + this.perm[ll + 1]]]] % 32];
                // Calculate the contribution from the five corners
                const t0 = 0.5 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
                const n0 = t0 < 0
                    ? 0.0
                    : Math.pow(t0, 4) * (g0[0] * x0 + g0[1] * y0 + g0[2] * z0 + g0[3] * w0);
                const t1 = 0.5 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
                const n1 = t1 < 0
                    ? 0.0
                    : Math.pow(t1, 4) * (g1[0] * x1 + g1[1] * y1 + g1[2] * z1 + g1[3] * w1);
                const t2 = 0.5 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
                const n2 = t2 < 0
                    ? 0.0
                    : Math.pow(t2, 4) * (g2[0] * x2 + g2[1] * y2 + g2[2] * z2 + g2[3] * w2);
                const t3 = 0.5 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
                const n3 = t3 < 0
                    ? 0.0
                    : Math.pow(t3, 4) * (g3[0] * x3 + g3[1] * y3 + g3[2] * z3 + g3[3] * w3);
                const t4 = 0.5 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
                const n4 = t4 < 0
                    ? 0.0
                    : Math.pow(t4, 4) * (g4[0] * x4 + g4[1] * y4 + g4[2] * z4 + g4[3] * w4);
                // Sum up and scale the result to cover the range [-1,1]
                return 72.37855765153665 * (n0 + n1 + n2 + n3 + n4);
            };
        }
        #sample;
    }
    Noise4.offset = (5.0 - Math.sqrt(5.0)) / 20.0;
    Noise4.gradient = [[0, 1, 1, 1], [0, 1, 1, -1], [0, 1, -1, 1], [0, 1, -1, -1], [0, -1, 1, 1], [0, -1, 1, -1], [0, -1, -1, 1], [0, -1, -1, -1], [1, 0, 1, 1], [1, 0, 1, -1], [1, 0, -1, 1], [1, 0, -1, -1], [-1, 0, 1, 1], [-1, 0, 1, -1], [-1, 0, -1, 1], [-1, 0, -1, -1], [1, 1, 0, 1], [1, 1, 0, -1], [1, -1, 0, 1], [1, -1, 0, -1], [-1, 1, 0, 1], [-1, 1, 0, -1], [-1, -1, 0, 1], [-1, -1, 0, -1], [1, 1, 1, 0], [1, 1, -1, 0], [1, -1, 1, 0], [1, -1, -1, 0], [-1, 1, 1, 0], [-1, 1, -1, 0], [-1, -1, 1, 0], [-1, -1, -1, 0]];
    FudgeCore.Noise4 = Noise4;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Class for creating random values, supporting Javascript's Math.random and a deterministig pseudo-random number generator (PRNG)
     * that can be fed with a seed and then returns a reproducable set of random numbers (if the precision of Javascript allows)
     *
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Random {
        /**
         * Create an instance of {@link Random}.
         * If a seed is given, LFIB4 is used as generator, reproducing a series of numbers from that seed.
         * If a function producing values between 0 and 1 is given, it will be used as generator.
         */
        constructor(_seedOrFunction) {
            this.generate = Math.random;
            if (_seedOrFunction instanceof Function)
                this.generate = _seedOrFunction;
            else if (_seedOrFunction == undefined)
                this.generate = Math.random;
            else
                //@ts-ignore
                this.generate = new FudgeCore.LFIB4(_seedOrFunction);
        }
        /**
         * Returns a normed random number, thus in the range of [0, 1[
         */
        getNorm() {
            return this.generate();
        }
        /**
         * Returns a random number in the range of given [_min, _max[
         */
        getRange(_min, _max) {
            return _min + this.generate() * (_max - _min);
        }
        /**
         * Returns a random integer number in the range of given floored [_min, _max[
         */
        getRangeFloored(_min, _max) {
            return Math.floor(this.getRange(_min, _max));
        }
        /**
         * Returns true or false randomly
         */
        getBoolean() {
            return this.generate() < 0.5;
        }
        /**
         * Returns -1 or 1 randomly
         */
        getSign() {
            return this.getBoolean() ? 1 : -1;
        }
        /**
         * Returns a randomly selected index into the given array
         */
        getIndex(_array) {
            if (_array.length > 0)
                return this.getRangeFloored(0, _array.length);
            return -1;
        }
        /**
         * Returns a randomly selected element of the given array
         */
        getElement(_array) {
            if (_array.length > 0)
                return _array[this.getIndex(_array)];
            return null;
        }
        /**
         * Removes a randomly selected element from the given array and returns it
         */
        splice(_array) {
            return _array.splice(this.getIndex(_array), 1)[0];
        }
        /**
         * Returns a randomly selected key from the given Map-instance
         */
        getKey(_map) {
            let keys = Array.from(_map.keys());
            return keys[this.getIndex(keys)];
        }
        /**
         * Returns a randomly selected property name from the given object
         */
        getPropertyName(_object) {
            let keys = Object.getOwnPropertyNames(_object);
            return keys[this.getIndex(keys)];
        }
        /**
         * Returns a randomly selected symbol from the given object, if symbols are used as keys
         */
        getPropertySymbol(_object) {
            let keys = Object.getOwnPropertySymbols(_object);
            return keys[this.getIndex(keys)];
        }
        /**
         * Returns a random three-dimensional vector in the limits of the box defined by the vectors given as [_corner0, _corner1[
         */
        getVector3(_corner0, _corner1) {
            return new FudgeCore.Vector3(this.getRange(_corner0.x, _corner1.x), this.getRange(_corner0.y, _corner1.y), this.getRange(_corner0.z, _corner1.z));
        }
        /**
         * Returns a random two-dimensional vector in the limits of the rectangle defined by the vectors given as [_corner0, _corner1[
         */
        getVector2(_corner0, _corner1) {
            return new FudgeCore.Vector2(this.getRange(_corner0.x, _corner1.x), this.getRange(_corner0.y, _corner1.y));
        }
    }
    Random.default = new Random();
    FudgeCore.Random = Random;
    /**
     * Standard {@link Random}-instance using Math.random().
     */
    FudgeCore.random = new Random();
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Stores and manipulates a threedimensional vector comprised of the components x, y and z
     * ```plaintext
     *            +y
     *             |__ +x
     *            /
     *          +z
     * ```
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019-2022
     */
    class Vector3 extends FudgeCore.Mutable {
        constructor(_x = 0, _y = 0, _z = 0) {
            super();
            this.data = new Float32Array([_x, _y, _z]);
        }
        //#region Static
        /**
         * Creates and returns a vector with the given length pointing in x-direction
         */
        static X(_scale = 1) {
            const vector = FudgeCore.Recycler.get(Vector3);
            vector.set(_scale, 0, 0);
            return vector;
        }
        /**
         * Creates and returns a vector with the given length pointing in y-direction
         */
        static Y(_scale = 1) {
            const vector = FudgeCore.Recycler.get(Vector3);
            vector.set(0, _scale, 0);
            return vector;
        }
        /**
         * Creates and returns a vector with the given length pointing in z-direction
         */
        static Z(_scale = 1) {
            const vector = FudgeCore.Recycler.get(Vector3);
            vector.data.set([0, 0, _scale]);
            return vector;
        }
        /**
         * Creates and returns a vector with the value 0 on each axis
         */
        static ZERO() {
            const vector = FudgeCore.Recycler.get(Vector3);
            vector.set(0, 0, 0);
            return vector;
        }
        /**
         * Creates and returns a vector of the given size on each of the three axis
         */
        static ONE(_scale = 1) {
            const vector = FudgeCore.Recycler.get(Vector3);
            vector.set(_scale, _scale, _scale);
            return vector;
        }
        /**
         * Creates and returns a vector through transformation of the given vector by the given matrix
         */
        static TRANSFORMATION(_vector, _mtxTransform, _includeTranslation = true) {
            let result = FudgeCore.Recycler.get(Vector3);
            let m = _mtxTransform.get();
            let [x, y, z] = _vector.get();
            result.x = m[0] * x + m[4] * y + m[8] * z;
            result.y = m[1] * x + m[5] * y + m[9] * z;
            result.z = m[2] * x + m[6] * y + m[10] * z;
            if (_includeTranslation) {
                result.add(_mtxTransform.translation);
            }
            return result;
        }
        /**
         * Creates and returns a vector which is a copy of the given vector scaled to the given length
         */
        static NORMALIZATION(_vector, _length = 1) {
            let magnitudeSquared = _vector.magnitudeSquared;
            let vector = _vector.clone;
            if (magnitudeSquared == 0)
                throw (new RangeError("Impossible normalization"));
            vector.scale(_length / Math.sqrt(magnitudeSquared));
            return vector;
        }
        /**
         * Returns the resulting vector attained by addition of all given vectors.
         */
        static SUM(..._vectors) {
            let result = FudgeCore.Recycler.get(Vector3);
            for (let vector of _vectors)
                result.set(result.x + vector.x, result.y + vector.y, result.z + vector.z);
            return result;
        }
        /**
         * Returns the result of the subtraction of two vectors.
         */
        static DIFFERENCE(_minuend, _subtrahend) {
            let vector = FudgeCore.Recycler.get(Vector3);
            vector.set(_minuend.x - _subtrahend.x, _minuend.y - _subtrahend.y, _minuend.z - _subtrahend.z);
            return vector;
        }
        /**
         * Returns a new vector representing the given vector scaled by the given scaling factor
         */
        static SCALE(_vector, _scaling) {
            let scaled = FudgeCore.Recycler.get(Vector3);
            scaled.set(_vector.x * _scaling, _vector.y * _scaling, _vector.z * _scaling);
            return scaled;
        }
        /**
         * Computes the crossproduct of 2 vectors.
         */
        static CROSS(_a, _b) {
            let vector = FudgeCore.Recycler.get(Vector3);
            vector.set(_a.y * _b.z - _a.z * _b.y, _a.z * _b.x - _a.x * _b.z, _a.x * _b.y - _a.y * _b.x);
            return vector;
        }
        /**
         * Computes the dotproduct of 2 vectors.
         */
        static DOT(_a, _b) {
            let scalarProduct = _a.x * _b.x + _a.y * _b.y + _a.z * _b.z;
            return scalarProduct;
        }
        /**
         * Calculates and returns the reflection of the incoming vector at the given normal vector. The length of normal should be 1.
         *     __________________
         *           /|\
         * incoming / | \ reflection
         *         /  |  \
         *          normal
         *
         */
        static REFLECTION(_incoming, _normal) {
            let dot = -Vector3.DOT(_incoming, _normal);
            let reflection = Vector3.SUM(_incoming, Vector3.SCALE(_normal, 2 * dot));
            return reflection;
        }
        /**
         * Divides the dividend by the divisor component by component and returns the result
         */
        static RATIO(_dividend, _divisor) {
            let vector = FudgeCore.Recycler.get(Vector3);
            vector.set(_dividend.x / _divisor.x, _dividend.y / _divisor.y, _dividend.z / _divisor.z);
            return vector;
        }
        /**
         * Creates a cartesian vector from geographic coordinates
         */
        static GEO(_longitude = 0, _latitude = 0, _magnitude = 1) {
            let vector = FudgeCore.Recycler.get(Vector3);
            let geo = FudgeCore.Recycler.get(FudgeCore.Geo3);
            geo.set(_longitude, _latitude, _magnitude);
            vector.geo = geo;
            FudgeCore.Recycler.store(geo);
            return vector;
        }
        //#endregion
        //#region Accessors
        // TODO: implement equals-functions
        get x() {
            return this.data[0];
        }
        get y() {
            return this.data[1];
        }
        get z() {
            return this.data[2];
        }
        set x(_x) {
            this.data[0] = _x;
        }
        set y(_y) {
            this.data[1] = _y;
        }
        set z(_z) {
            this.data[2] = _z;
        }
        /**
         * Returns the length of the vector
         */
        get magnitude() {
            return Math.hypot(...this.data);
        }
        /**
         * Returns the square of the magnitude of the vector without calculating a square root. Faster for simple proximity evaluation.
         */
        get magnitudeSquared() {
            return Vector3.DOT(this, this);
        }
        /**
         * Returns a copy of this vector
         * TODO: rename this clone and create a new method copy, which copies the values from a vector given
         */
        get clone() {
            let clone = FudgeCore.Recycler.get(Vector3);
            clone.data.set(this.data);
            return clone;
        }
        /**
         * - get: returns a geographic representation of this vector
         * - set: adjust the cartesian values of this vector to represent the given as geographic coordinates
         */
        set geo(_geo) {
            this.set(0, 0, _geo.magnitude);
            this.transform(FudgeCore.Matrix4x4.ROTATION_X(-_geo.latitude));
            this.transform(FudgeCore.Matrix4x4.ROTATION_Y(_geo.longitude));
        }
        get geo() {
            let geo = FudgeCore.Recycler.get(FudgeCore.Geo3);
            geo.magnitude = this.magnitude;
            if (geo.magnitude === 0)
                return geo;
            geo.longitude = 180 * Math.atan2(this.x / geo.magnitude, this.z / geo.magnitude) / Math.PI;
            geo.latitude = 180 * Math.asin(this.y / geo.magnitude) / Math.PI;
            return geo;
        }
        //#endregion
        recycle() {
            this.data.set([0, 0, 0]);
        }
        /**
         * Returns true if the coordinates of this and the given vector are to be considered identical within the given tolerance
         * TODO: examine, if tolerance as criterium for the difference is appropriate with very large coordinate values or if _tolerance should be multiplied by coordinate value
         */
        equals(_compare, _tolerance = Number.EPSILON) {
            if (Math.abs(this.x - _compare.x) > _tolerance)
                return false;
            if (Math.abs(this.y - _compare.y) > _tolerance)
                return false;
            if (Math.abs(this.z - _compare.z) > _tolerance)
                return false;
            return true;
        }
        /**
         * Returns true if the position described by this is within a cube with the opposite corners 1 and 2
         */
        isInsideCube(_corner1, _corner2) {
            let diagonal = Vector3.DIFFERENCE(_corner2, _corner1);
            let relative = Vector3.DIFFERENCE(this, _corner1);
            let ratio = Vector3.RATIO(relative, diagonal);
            if (ratio.x > 1 || ratio.x < 0)
                return false;
            if (ratio.y > 1 || ratio.y < 0)
                return false;
            if (ratio.z > 1 || ratio.z < 0)
                return false;
            return true;
        }
        /**
         * Returns true if the position described by this is within a sphere with the given center and radius
         */
        isInsideSphere(_center, _radius) {
            let difference = Vector3.DIFFERENCE(this, _center);
            return difference.magnitudeSquared < (_radius * _radius);
        }
        /**
         * Adds the given vector to this
         */
        add(_addend) {
            this.data.set([_addend.x + this.x, _addend.y + this.y, _addend.z + this.z]);
        }
        /**
         * Subtracts the given vector from this
         */
        subtract(_subtrahend) {
            this.data.set([this.x - _subtrahend.x, this.y - _subtrahend.y, this.z - _subtrahend.z]);
        }
        /**
         * Scales this vector by the given scalar
         */
        scale(_scalar) {
            this.data.set([_scalar * this.x, _scalar * this.y, _scalar * this.z]);
        }
        /**
         * Normalizes this to the given length, 1 by default
         */
        normalize(_length = 1) {
            this.data = Vector3.NORMALIZATION(this, _length).data;
        }
        /**
         * Defines the components of this vector with the given numbers
         */
        set(_x = 0, _y = 0, _z = 0) {
            this.data[0] = _x;
            this.data[1] = _y;
            this.data[2] = _z;
        }
        /**
         * Returns this vector as a new Float32Array (copy)
         */
        get() {
            return new Float32Array(this.data);
        }
        /**
         * Transforms this vector by the given matrix, including or exluding the translation.
         * Including is the default, excluding will only rotate and scale this vector.
         */
        transform(_mtxTransform, _includeTranslation = true) {
            let transformed = Vector3.TRANSFORMATION(this, _mtxTransform, _includeTranslation);
            this.data.set(transformed.data);
            FudgeCore.Recycler.store(transformed);
        }
        /**
         * Drops the z-component and returns a Vector2 consisting of the x- and y-components
         */
        toVector2() {
            return new FudgeCore.Vector2(this.x, this.y);
        }
        /**
         * Reflects this vector at a given normal. See {@link Vector3.REFLECTION}
         */
        reflect(_normal) {
            const reflected = Vector3.REFLECTION(this, _normal);
            this.set(reflected.x, reflected.y, reflected.z);
            FudgeCore.Recycler.store(reflected);
        }
        /**
         * Shuffles the components of this vector
         */
        shuffle() {
            let a = Array.from(this.data);
            this.set(FudgeCore.Random.default.splice(a), FudgeCore.Random.default.splice(a), a[0]);
        }
        getDistance(_to) {
            let difference = Vector3.DIFFERENCE(this, _to);
            FudgeCore.Recycler.store(difference);
            return difference.magnitude;
        }
        /**
         * For each dimension, moves the component to the minimum of this and the given vector
         */
        min(_compare) {
            this.x = Math.min(this.x, _compare.x);
            this.y = Math.min(this.y, _compare.y);
            this.z = Math.min(this.z, _compare.z);
        }
        /**
         * For each dimension, moves the component to the maximum of this and the given vector
         */
        max(_compare) {
            this.x = Math.max(this.x, _compare.x);
            this.y = Math.max(this.y, _compare.y);
            this.z = Math.max(this.z, _compare.z);
        }
        /**
         * Returns a formatted string representation of this vector
         */
        toString() {
            let result = `(${this.x.toPrecision(5)}, ${this.y.toPrecision(5)}, ${this.z.toPrecision(5)})`;
            return result;
        }
        /**
         * Uses the standard array.map functionality to perform the given function on all components of this vector
         */
        map(_function) {
            let copy = FudgeCore.Recycler.get(Vector3);
            copy.data = this.data.map(_function);
            return copy;
        }
        //#region Transfer
        serialize() {
            let serialization = this.getMutator();
            // serialization.toJSON = () => { return `{ "r": ${this.r}, "g": ${this.g}, "b": ${this.b}, "a": ${this.a}}`; };
            serialization.toJSON = () => { return `[${this.x}, ${this.y}, ${this.z}]`; };
            return serialization;
        }
        async deserialize(_serialization) {
            if (typeof (_serialization) == "string") {
                [this.x, this.y, this.z] = JSON.parse(_serialization);
            }
            else
                this.mutate(_serialization);
            return this;
        }
        getMutator() {
            let mutator = {
                x: this.data[0], y: this.data[1], z: this.data[2]
            };
            return mutator;
        }
        reduceMutator(_mutator) { }
    }
    FudgeCore.Vector3 = Vector3;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Describes a face of a {@link Mesh} by referencing three {@link Vertices} with their indizes
     * and calculates face normals.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2022
     */
    class Face {
        constructor(_vertices, _index0, _index1, _index2) {
            this.indices = [];
            this.indices = [_index0, _index1, _index2];
            this.vertices = _vertices;
            this.calculateNormals();
        }
        calculateNormals() {
            let trigon = this.indices.map((_index) => this.vertices.position(_index));
            let v1 = FudgeCore.Vector3.DIFFERENCE(trigon[1], trigon[0]);
            let v2 = FudgeCore.Vector3.DIFFERENCE(trigon[2], trigon[0]);
            this.normalUnscaled = FudgeCore.Vector3.CROSS(v1, v2);
            this.normal = FudgeCore.Vector3.NORMALIZATION(this.normalUnscaled);
        }
        getPosition(_index) {
            return this.vertices.position(this.indices[_index]);
        }
        /**
         * must be coplanar
         */
        isInside(_point) {
            let diffs = [];
            for (let index of this.indices) {
                let diff = FudgeCore.Vector3.DIFFERENCE(this.vertices.position(index), _point);
                diffs.push(diff);
            }
            let n0 = FudgeCore.Vector3.CROSS(diffs[1], diffs[0]);
            let n1 = FudgeCore.Vector3.CROSS(diffs[2], diffs[1]);
            let n2 = FudgeCore.Vector3.CROSS(diffs[0], diffs[2]);
            let dot1 = FudgeCore.Vector3.DOT(n0, n1);
            let dot2 = FudgeCore.Vector3.DOT(n0, n2);
            return !(dot1 < 0 || dot2 < 0);
        }
    }
    FudgeCore.Face = Face;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    var Mesh_1;
    /**
     * Abstract base class for all meshes.
     * Meshes provide indexed vertices, the order of indices to create trigons and normals, and texture coordinates
     *
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019/22
     */
    let Mesh = Mesh_1 = class Mesh extends FudgeCore.Mutable {
        constructor(_name = "Mesh") {
            super();
            // TODO: at this time, creating the buffers for flat shading is a brute force algorithm and should be optimized in the different subclasses
            // TODO: rename vertices to verticesSmooth or just cloud, and cloud to vertices
            // 
            this.idResource = undefined;
            this.name = "Mesh";
            // base structure for meshes in FUDGE
            this.cloud = new FudgeCore.Vertices();
            this.faces = [];
            this.name = _name;
            this.clear();
            FudgeCore.Project.register(this);
        }
        static registerSubclass(_subClass) { return Mesh_1.subclasses.push(_subClass) - 1; }
        get type() {
            return this.constructor.name;
        }
        get vertices() {
            return this.∆ívertices || ( // return cache or ...
            // ... flatten all vertex positions from cloud into a typed array
            this.∆ívertices = new Float32Array(this.cloud.flatMap((_vertex, _index) => {
                return [...this.cloud.position(_index).get()];
            })));
        }
        get indices() {
            return this.∆íindices || ( // return cache or ...
            // ... flatten all indices from the faces into a typed array
            this.∆íindices = new Uint16Array(this.faces.flatMap((_face) => [..._face.indices])));
        }
        get normalsVertex() {
            if (this.∆ínormalsVertex == null) {
                // sum up all unscaled normals of faces connected to one vertex...
                this.cloud.forEach(_vertex => _vertex.normal.set(0, 0, 0));
                for (let face of this.faces)
                    for (let index of face.indices) {
                        this.cloud.normal(index).add(face.normalUnscaled);
                    }
                // ... and normalize them
                this.cloud.forEach(_vertex => {
                    // some vertices might be unused and yield a zero-normal...
                    if (_vertex.normal.magnitudeSquared > 0)
                        _vertex.normal.normalize();
                });
                // this.∆ínormalsVertex = new Float32Array(normalsVertex.flatMap((_normal: Vector3) => [..._normal.get()]));
                this.∆ínormalsVertex = new Float32Array(this.cloud.flatMap((_vertex, _index) => {
                    return [...this.cloud.normal(_index).get()];
                }));
            }
            return this.∆ínormalsVertex;
        }
        get textureUVs() {
            return this.∆ítextureUVs || ( // return cache or ...
            // ... flatten all uvs from the clous into a typed array
            this.∆ítextureUVs = new Float32Array(this.cloud.flatMap((_vertex) => [..._vertex.uv.get()])));
        }
        get verticesFlat() {
            return this.∆íverticesFlat || (this.∆íverticesFlat = this.createVerticesFlat());
        }
        get indicesFlat() {
            return this.∆íindicesFlat;
        }
        get normalsFlat() {
            return this.∆ínormalsFlat || (this.∆ínormalsFlat = this.createNormalsFlat());
        }
        get textureUVsFlat() {
            return this.∆ítextureUVsFlat || (this.∆ítextureUVsFlat = this.createTextureUVsFlat());
        }
        get boundingBox() {
            if (this.∆íbox == null)
                this.∆íbox = this.createBoundingBox();
            return this.∆íbox;
        }
        get radius() {
            if (this.∆íradius == null)
                this.∆íradius = this.createRadius();
            return this.∆íradius;
        }
        useRenderBuffers(_shader, _mtxWorld, _mtxProjection, _id) { return 0; /* injected by RenderInjector*/ }
        createRenderBuffers() { }
        deleteRenderBuffers(_shader) { }
        clear() {
            // buffers for smooth shading
            this.∆ívertices = undefined;
            this.∆íindices = undefined;
            this.∆ítextureUVs = undefined;
            this.∆ínormalsVertex = undefined;
            // special buffers for flat shading
            this.∆ínormalsFlat = undefined;
            this.∆íverticesFlat = undefined;
            this.∆íindicesFlat = undefined;
            this.∆ítextureUVsFlat = undefined;
            // 
            this.∆ínormalsFaceUnscaled = undefined;
            this.∆íbox = undefined;
            this.∆íradius = undefined;
            this.renderBuffers = null;
        }
        //#region Transfer
        // Serialize/Deserialize for all meshes that calculate without parameters
        serialize() {
            let serialization = {
                idResource: this.idResource,
                name: this.name,
                type: this.type // store for editor view
            }; // no data needed ...
            return serialization;
        }
        async deserialize(_serialization) {
            FudgeCore.Project.register(this, _serialization.idResource);
            this.name = _serialization.name;
            // type is an accessor and must not be deserialized
            return this;
        }
        reduceMutator(_mutator) {
            // TODO: so much to delete... rather just gather what to mutate
            delete _mutator.∆íbox;
            delete _mutator.∆íradius;
            delete _mutator.∆ívertices;
            delete _mutator.∆íindices;
            delete _mutator.∆ínormalsVertex;
            delete _mutator.∆ínormalsFaceUnscaled;
            delete _mutator.∆ítextureUVs;
            delete _mutator.∆ínormalsFlat;
            delete _mutator.∆íverticesFlat;
            delete _mutator.∆íindicesFlat;
            delete _mutator.∆ítextureUVsFlat;
            delete _mutator.renderBuffers;
        }
        //#endregion
        createVerticesFlat() {
            let positions = [];
            let indices = [];
            let i = 0;
            for (let face of this.faces)
                for (let index of face.indices) {
                    indices.push(i++);
                    positions.push(this.cloud.position(index));
                }
            this.∆íindicesFlat = new Uint16Array(indices);
            return new Float32Array(positions.flatMap(_v => [..._v.get()]));
        }
        createNormalsFlat() {
            let normals = [];
            let zero = FudgeCore.Vector3.ZERO();
            for (let face of this.faces) {
                // store the face normal at the position of the third vertex
                normals.push(zero);
                normals.push(zero);
                normals.push(face.normal);
            }
            this.∆ínormalsFlat = new Float32Array(normals.flatMap(_n => [..._n.get()]));
            return this.∆ínormalsFlat;
        }
        createTextureUVsFlat() {
            let uv = [];
            // create unique vertices for each face, tripling the number
            for (let i = 0; i < this.indices.length; i++) {
                let index = this.indices[i] * 2;
                uv.push(this.textureUVs[index], this.textureUVs[index + 1]);
            }
            return new Float32Array(uv);
        }
        calculateFaceCrossProducts() {
            let crossProducts = [];
            let vertices = [];
            for (let v = 0; v < this.vertices.length; v += 3)
                vertices.push(new FudgeCore.Vector3(this.vertices[v], this.vertices[v + 1], this.vertices[v + 2]));
            for (let i = 0; i < this.indices.length; i += 3) {
                let trigon = [this.indices[i], this.indices[i + 1], this.indices[i + 2]];
                let v0 = FudgeCore.Vector3.DIFFERENCE(vertices[trigon[0]], vertices[trigon[1]]);
                let v1 = FudgeCore.Vector3.DIFFERENCE(vertices[trigon[0]], vertices[trigon[2]]);
                let crossProduct = FudgeCore.Vector3.CROSS(v0, v1);
                let index = trigon[2] * 3;
                crossProducts[index] = crossProduct.x;
                crossProducts[index + 1] = crossProduct.y;
                crossProducts[index + 2] = crossProduct.z;
            }
            return new Float32Array(crossProducts);
        }
        createRadius() {
            //TODO: radius and bounding box could be created on construction of vertex-array
            let radius = 0;
            for (let vertex = 0; vertex < this.vertices.length; vertex += 3) {
                radius = Math.max(radius, Math.hypot(this.vertices[vertex], this.vertices[vertex + 1], this.vertices[vertex + 2]));
            }
            return radius;
        }
        createBoundingBox() {
            let box = FudgeCore.Recycler.get(FudgeCore.Box);
            box.set();
            for (let vertex = 0; vertex < this.vertices.length; vertex += 3) {
                box.min.x = Math.min(this.vertices[vertex], box.min.x);
                box.max.x = Math.max(this.vertices[vertex], box.max.x);
                box.min.y = Math.min(this.vertices[vertex + 1], box.min.y);
                box.max.y = Math.max(this.vertices[vertex + 1], box.max.y);
                box.min.z = Math.min(this.vertices[vertex + 2], box.min.z);
                box.max.z = Math.max(this.vertices[vertex + 2], box.max.z);
            }
            return box;
        }
    };
    /** refers back to this class from any subclass e.g. in order to find compatible other resources*/
    Mesh.baseClass = Mesh_1;
    /** list of all the subclasses derived from this class, if they registered properly*/
    Mesh.subclasses = [];
    Mesh = Mesh_1 = __decorate([
        FudgeCore.RenderInjectorMesh.decorate
    ], Mesh);
    FudgeCore.Mesh = Mesh;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a simple cube with edges of length 1, each face consisting of two trigons
     * ```plaintext
     *       (12) 4____7  (11)
     *       (8) 0/__3/| (10)
     *       (15) ||5_||6 (14)
     *       (9) 1|/_2|/ (13)
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class MeshCube extends FudgeCore.Mesh {
        constructor(_name = "MeshCube") {
            super(_name);
            // this.create();
            this.cloud = new FudgeCore.Vertices(
            // front
            new FudgeCore.Vertex(new FudgeCore.Vector3(-0.5, 0.5, 0.5), new FudgeCore.Vector2(0, 0)), // 0
            new FudgeCore.Vertex(new FudgeCore.Vector3(-0.5, -0.5, 0.5), new FudgeCore.Vector2(0, 1)), // 1
            new FudgeCore.Vertex(new FudgeCore.Vector3(0.5, -0.5, 0.5), new FudgeCore.Vector2(1, 1)), // 2
            new FudgeCore.Vertex(new FudgeCore.Vector3(0.5, 0.5, 0.5), new FudgeCore.Vector2(1, 0)), // 3
            // back
            new FudgeCore.Vertex(new FudgeCore.Vector3(-0.5, 0.5, -0.5), new FudgeCore.Vector2(3, 0)), // 4
            new FudgeCore.Vertex(new FudgeCore.Vector3(-0.5, -0.5, -0.5), new FudgeCore.Vector2(3, 1)), // 5
            new FudgeCore.Vertex(new FudgeCore.Vector3(0.5, -0.5, -0.5), new FudgeCore.Vector2(2, 1)), // 6
            new FudgeCore.Vertex(new FudgeCore.Vector3(0.5, 0.5, -0.5), new FudgeCore.Vector2(2, 0)), // 7
            // references
            new FudgeCore.Vertex(0, new FudgeCore.Vector2(4, 0)), // 8
            new FudgeCore.Vertex(1, new FudgeCore.Vector2(4, 1)), // 9
            new FudgeCore.Vertex(3, new FudgeCore.Vector2(0, 1)), // 10
            new FudgeCore.Vertex(7, new FudgeCore.Vector2(1, 1)), // 11
            new FudgeCore.Vertex(4, new FudgeCore.Vector2(1, 0)), // 12
            new FudgeCore.Vertex(2, new FudgeCore.Vector2(0, 0)), // 13
            new FudgeCore.Vertex(6, new FudgeCore.Vector2(1, 0)), // 14
            new FudgeCore.Vertex(5, new FudgeCore.Vector2(1, 1)) // 15
            );
            this.faces = [
                ...new FudgeCore.Quad(this.cloud, 0, 1, 2, 3).faces,
                ...new FudgeCore.Quad(this.cloud, 7, 6, 5, 4).faces,
                ...new FudgeCore.Quad(this.cloud, 3, 2, 6, 7).faces,
                ...new FudgeCore.Quad(this.cloud, 4, 5, 9, 8).faces,
                ...new FudgeCore.Quad(this.cloud, 0, 10, 11, 12).faces,
                ...new FudgeCore.Quad(this.cloud, 13, 1, 15, 14).faces // bottom
            ];
        }
    }
    MeshCube.iSubclass = FudgeCore.Mesh.registerSubclass(MeshCube);
    FudgeCore.MeshCube = MeshCube;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a flat polygon. All trigons share vertex 0, so careful design is required to create concave polygons.
     * Vertex 0 is also associated with the face normal.
     * ```plaintext
     *             0
     *           1‚ï±|‚ï≤  4 ...
     *            ‚ï≤|_‚ï≤‚ï±
     *            2   3
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021-2022
     */
    class MeshPolygon extends FudgeCore.Mesh {
        constructor(_name = "MeshPolygon", _shape = MeshPolygon.shapeDefault, _fitTexture = true) {
            super(_name);
            this.shape = new FudgeCore.MutableArray();
            this.create(_shape, _fitTexture);
        }
        get minVertices() {
            return 3;
        }
        create(_shape = [], _fitTexture = true) {
            this.shape = FudgeCore.MutableArray.from(_shape.map(_vertex => _vertex.clone));
            this.clear();
            this.fitTexture = _fitTexture;
            if (_shape.length < this.minVertices) {
                FudgeCore.Debug.warn(`At least ${this.minVertices} vertices needed to construct MeshPolygon, default trigon used`);
                this.create(MeshPolygon.shapeDefault, true);
                return;
            }
            let shape = _shape;
            let min = FudgeCore.Vector2.ZERO();
            let max = FudgeCore.Vector2.ZERO();
            this.cloud = new FudgeCore.Vertices();
            for (let vertex of shape) {
                this.cloud.push(new FudgeCore.Vertex(vertex.toVector3()));
                min.x = Math.min(min.x, vertex.x);
                max.x = Math.max(max.x, vertex.x);
                min.y = Math.min(min.y, vertex.y);
                max.y = Math.max(max.y, vertex.y);
            }
            let size = new FudgeCore.Vector2(max.x - min.x, max.y - min.y);
            if (this.fitTexture) {
                for (let i = 0; i < shape.length; i++) {
                    let textureUV = FudgeCore.Vector2.SUM(shape[i], min);
                    this.cloud[i].uv = new FudgeCore.Vector2(textureUV.x / size.x, -textureUV.y / size.y);
                }
            }
            else {
                _shape.forEach((_vertex, i) => this.cloud[i].uv = new FudgeCore.Vector2(_vertex.x, -_vertex.y));
            }
            this.faces = [];
            for (let i = 2; i < this.cloud.length; i++)
                this.faces.push(new FudgeCore.Face(this.cloud, i - 1, i, 0));
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.shape = FudgeCore.Serializer.serializeArray(FudgeCore.Vector2, this.shape);
            serialization.fitTexture = this.fitTexture;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            let vectors = await FudgeCore.Serializer.deserializeArray(_serialization.shape);
            this.create(vectors, _serialization.fitTexture);
            return this;
        }
        async mutate(_mutator) {
            await super.mutate(_mutator);
            this.create(this.shape, _mutator.fitTexture);
            this.dispatchEvent(new Event("mutate" /* MUTATE */));
        }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
        }
    }
    MeshPolygon.iSubclass = FudgeCore.Mesh.registerSubclass(MeshPolygon);
    MeshPolygon.shapeDefault = [
        new FudgeCore.Vector2(-1, -1),
        new FudgeCore.Vector2(1, -1),
        new FudgeCore.Vector2(0, 1)
    ];
    FudgeCore.MeshPolygon = MeshPolygon;
})(FudgeCore || (FudgeCore = {}));
///<reference path="MeshPolygon.ts"/>
var FudgeCore;
///<reference path="MeshPolygon.ts"/>
(function (FudgeCore) {
    /**
     * Generates an extrusion of a polygon by a series of transformations
     * ```plaintext
     *                      ____
     * Polygon         ____‚ï±‚ï≤   ‚ï≤                             y
     * Transform 0  ‚Üí ‚ï± ‚ï≤__‚ï≤_‚ï≤___‚ï≤ ‚Üê Transform 2          z __‚îÇ
     * (base)         ‚ï≤_‚ï±__‚ï± ‚ï±   ‚ï±   (lid)                     ‚ï≤
     *     Transform 1  ‚Üí  ‚ï≤‚ï±___‚ï±                               x
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021-2022
     */
    class MeshExtrusion extends FudgeCore.MeshPolygon {
        // private transforms: MutableArray<Matrix4x4> = new MutableArray(Matrix4x4);
        constructor(_name = "MeshExtrusion", _vertices = FudgeCore.MeshPolygon.shapeDefault, _mtxTransforms = MeshExtrusion.mtxDefaults, _fitTexture = true) {
            super(_name, _vertices, _fitTexture);
            this.mtxTransforms = new FudgeCore.MutableArray();
            this.extrude(_mtxTransforms);
            // console.log("Mutator", this.getMutator());
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.transforms = FudgeCore.Serializer.serializeArray(FudgeCore.Matrix4x4, this.mtxTransforms);
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            let mtxTransforms;
            if (_serialization.transforms)
                mtxTransforms = await FudgeCore.Serializer.deserializeArray(_serialization.transforms);
            this.extrude(mtxTransforms);
            return this;
        }
        async mutate(_mutator) {
            await super.mutate(_mutator);
            this.extrude(this.mtxTransforms);
            this.dispatchEvent(new Event("mutate" /* MUTATE */));
        }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
        }
        //#endregion
        extrude(_mtxTransforms = MeshExtrusion.mtxDefaults) {
            this.mtxTransforms = FudgeCore.MutableArray.from(_mtxTransforms);
            let nTransforms = _mtxTransforms.length;
            let nVerticesShape = this.cloud.length;
            // create new vertex cloud, current cloud holds MeshPolygon
            let vertices = new FudgeCore.Vertices();
            // create base by transformation of polygon with first transform
            let base = this.cloud.map((_v) => new FudgeCore.Vertex(FudgeCore.Vector3.TRANSFORMATION(_v.position, _mtxTransforms[0], true), _v.uv));
            vertices.push(...base);
            // create lid by transformation of polygon with last transform
            let lid = this.cloud.map((_v) => new FudgeCore.Vertex(FudgeCore.Vector3.TRANSFORMATION(_v.position, _mtxTransforms[nTransforms - 1], true), _v.uv));
            vertices.push(...lid);
            // recreate base faces to recalculate normals
            this.faces = this.faces.map((_face) => new FudgeCore.Face(vertices, _face.indices[0], _face.indices[1], _face.indices[2]));
            // create the lid faces using the indices of the base faces, but with an index offset and reverse order of indices
            this.faces.push(...this.faces.map(_face => new FudgeCore.Face(vertices, _face.indices[2] + nVerticesShape, _face.indices[1] + nVerticesShape, _face.indices[0] + nVerticesShape)));
            for (let t = 0; t < nTransforms; t++) {
                let mtxTransform = _mtxTransforms[t];
                let referToClose = vertices.length;
                let wrap = this.cloud.map((_v, _i) => new FudgeCore.Vertex(FudgeCore.Vector3.TRANSFORMATION(_v.position, mtxTransform, true), new FudgeCore.Vector2(_i / nVerticesShape, t / nTransforms)));
                vertices.push(...wrap);
                vertices.push(new FudgeCore.Vertex(referToClose, new FudgeCore.Vector2(1, t / nTransforms)));
                // if (i > 0 && i < nTransforms - 1)
                //   vertices.push(...wrap.map((_vector: Vector3) => _vector.clone)); <- no slicing for flat shading yet...
            }
            // create indizes for wrapper
            for (let t = 0; t < nTransforms - 1; t++)
                for (let i = 0; i < nVerticesShape; i++) {
                    let index = +2 * nVerticesShape // base & lid are offsets 
                        + t * (nVerticesShape + 1) // offset for each transformation
                        + i;
                    let quad = new FudgeCore.Quad(vertices, index, index + nVerticesShape + 1, index + nVerticesShape + 2, index + 1, FudgeCore.QUADSPLIT.AT_0);
                    this.faces.push(...quad.faces);
                }
            this.cloud = vertices;
            return;
        }
    }
    MeshExtrusion.iSubclass = FudgeCore.Mesh.registerSubclass(MeshExtrusion);
    MeshExtrusion.mtxDefaults = [
        FudgeCore.Matrix4x4.TRANSLATION(FudgeCore.Vector3.Z(0.5)),
        FudgeCore.Matrix4x4.TRANSLATION(FudgeCore.Vector3.Z(-0.5))
    ];
    FudgeCore.MeshExtrusion = MeshExtrusion;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /** Allows to create custom meshes from given Data */
    class MeshFromData extends FudgeCore.Mesh {
        constructor(_vertices, _textureUVs, _indices, _faceNormals) {
            super();
            this.verticesToSet = _vertices;
            this.textureUVsToSet = _textureUVs;
            this.indicesToSet = _indices;
            this.faceNormalsToSet = _faceNormals;
        }
        createVertices() {
            return this.verticesToSet;
        }
        createTextureUVs() {
            return this.textureUVsToSet;
        }
        createIndices() {
            return this.indicesToSet;
        }
        createFlatNormals() {
            return this.faceNormalsToSet;
        }
    }
    FudgeCore.MeshFromData = MeshFromData;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**Simple Wavefront OBJ import. Takes a wavefront obj string. To Load from a file url, use the
     * static LOAD Method. Currently only works with triangulated Meshes
     * (activate 'Geomentry ‚Üí Triangulate Faces' in Blenders obj exporter)
     * @todo UVs, Load Materials, Support Quads
     * @authors Simon Storl-Schulke 2021 | Luis Keck, HFU, 2021 | Jirka Dell'Oro-Friedl, HFU, 2021-2022 */
    class MeshObj extends FudgeCore.Mesh {
        // protected verts: number[] = [];
        // protected uvs: number[] = [];
        // protected inds: number[] = [];
        // protected facenormals: number[] = [];
        // protected facecrossproducts: number[] = [];
        constructor(_name, _url) {
            super(_name);
            {
                if (_url) {
                    this.load(_url);
                    if (!_name)
                        _name = _url.toString().split("/").pop();
                }
                if (!_name)
                    _name = "MeshObj";
                this.name = _name;
            }
        }
        /**
             * Asynchronously loads the image from the given url
             */
        async load(_url) {
            this.url = _url;
            let url = new URL(this.url.toString(), FudgeCore.Project.baseURL).toString();
            let data = await (await fetch(url)).text();
            this.parseObj(data);
        }
        /** Splits up the obj string into separate arrays for each datatype */
        parseObj(data) {
            this.clear();
            const lines = data.split("\n");
            let positions = [];
            let uvs = [];
            let faceInfo = [];
            for (let line of lines) {
                line = line.trim();
                if (!line || line.startsWith("#"))
                    continue;
                const parts = line.split(" ");
                parts.shift();
                //Vertex - example: v 0.70 -0.45 -0.52
                if (!line || line.startsWith("v "))
                    positions.push(new FudgeCore.Vector3(...parts.map(x => +x)));
                //Texcoord - example: vt 0.545454 0.472382
                else if (!line || line.startsWith("vt "))
                    uvs.push(new FudgeCore.Vector2(...parts.map(x => +x)));
                /*Face Indices - example: f 1/1/1 2/2/1 3/3/1 -->
                vertex1/texcoord1/normal1 vertex2/texcoord2/normal2 vertex3/texcoord3/normal3*/
                else if (!line || line.startsWith("f "))
                    for (let i = 0; i < 3; i++) {
                        faceInfo.push({
                            iPosition: +parts[i].split("/")[0] - 1,
                            iUV: +parts[i].split("/")[1] - 1,
                            iNormal: +parts[i].split("/")[2] - 1
                        });
                    }
            }
            this.cloud = new FudgeCore.Vertices(...positions.map((_p) => new FudgeCore.Vertex(_p)));
            for (let i = 0; i < faceInfo.length; i += 3) {
                let indices = [];
                for (let v = 0; v < 3; v++) {
                    let info = faceInfo[i + v];
                    let index = info.iPosition;
                    if (this.cloud[index].uv) {
                        index = this.cloud.length;
                        this.cloud.push(new FudgeCore.Vertex(info.iPosition));
                    }
                    this.cloud[index].uv = uvs[info.iUV];
                    indices.push(index);
                }
                this.faces.push(new FudgeCore.Face(this.cloud, indices[0], indices[1], indices[2]));
            }
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.url = this.url;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            this.load(_serialization.url);
            return this;
        }
        async mutate(_mutator) {
            super.mutate(_mutator);
            this.load(_mutator.url);
        }
    }
    MeshObj.iSubclass = FudgeCore.Mesh.registerSubclass(MeshObj);
    FudgeCore.MeshObj = MeshObj;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a simple pyramid with edges at the base of length 1 and a height of 1. The sides consisting of one, the base of two trigons
     * ```plaintext
     *               4
     *              /\`.
     *            3/__\_\ 2
     *           0/____\/1
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class MeshPyramid extends FudgeCore.Mesh {
        constructor(_name = "MeshPyramid") {
            super(_name);
            // this.create();
            this.cloud = new FudgeCore.Vertices(
            // ground vertices
            new FudgeCore.Vertex(new FudgeCore.Vector3(-0.5, 0.0, 0.5), new FudgeCore.Vector2(0, 1)), new FudgeCore.Vertex(new FudgeCore.Vector3(0.5, 0.0, 0.5), new FudgeCore.Vector2(1, 1)), new FudgeCore.Vertex(new FudgeCore.Vector3(0.5, 0.0, -0.5), new FudgeCore.Vector2(1, 0)), new FudgeCore.Vertex(new FudgeCore.Vector3(-0.5, 0.0, -0.5), new FudgeCore.Vector2(0, 0)), 
            // tip (vertex #4)
            new FudgeCore.Vertex(new FudgeCore.Vector3(0.0, 1.0, 0.0), new FudgeCore.Vector2(0.5, 0.5)), 
            // floor again for downside texture
            new FudgeCore.Vertex(0, new FudgeCore.Vector2(0, 0)), new FudgeCore.Vertex(1, new FudgeCore.Vector2(1, 0)), new FudgeCore.Vertex(2, new FudgeCore.Vector2(1, 1)), new FudgeCore.Vertex(3, new FudgeCore.Vector2(0, 1)));
            this.faces = [
                new FudgeCore.Face(this.cloud, 4, 0, 1),
                new FudgeCore.Face(this.cloud, 4, 1, 2),
                new FudgeCore.Face(this.cloud, 4, 2, 3),
                new FudgeCore.Face(this.cloud, 4, 3, 0),
                new FudgeCore.Face(this.cloud, 5 + 0, 5 + 2, 5 + 1),
                new FudgeCore.Face(this.cloud, 5 + 0, 5 + 3, 5 + 2)
            ];
        }
    }
    MeshPyramid.iSubclass = FudgeCore.Mesh.registerSubclass(MeshPyramid);
    FudgeCore.MeshPyramid = MeshPyramid;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a simple quad with edges of length 1, the face consisting of two trigons
     * ```plaintext
     *        0 __ 3
     *         |_\|
     *        1    2
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019-2022
     */
    class MeshQuad extends FudgeCore.MeshPolygon {
        constructor(_name = "MeshQuad") {
            super(_name, MeshQuad.shape);
        }
        // // flat equals smooth
        // public get verticesFlat(): Float32Array { return this.vertices; }
        // public get indicesFlat(): Uint16Array { return this.indices; }
        // public get normalsFlat(): Float32Array { return this.normalsVertex; }
        //#region Transger
        serialize() {
            let serialization = this.getMutator();
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            this.create(MeshQuad.shape, true);
            return this;
        }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
            delete _mutator.shape;
            delete _mutator.fitTexture;
        }
    }
    MeshQuad.iSubclass = FudgeCore.Mesh.registerSubclass(MeshQuad);
    MeshQuad.shape = [
        new FudgeCore.Vector2(-0.5, 0.5), new FudgeCore.Vector2(-0.5, -0.5), new FudgeCore.Vector2(0.5, -0.5), new FudgeCore.Vector2(0.5, 0.5)
    ];
    FudgeCore.MeshQuad = MeshQuad;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Information about the vertical projection of a given position onto the terrain
     */
    class TerrainInfo {
    }
    FudgeCore.TerrainInfo = TerrainInfo;
    /**
     * A terrain spreads out in the x-z-plane, y is the height derived from the heightmap function.
     * The terrain is always 1 in size in all dimensions, fitting into the unit-cube.
     * Resolution determines the number of quads in x and z dimension, scale the factor applied to the x,z-coordinates passed to the heightmap function.
     * Standard function is the simplex noise implemented with FUDGE, but another function can be given.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021-2022 | Simon Storl-Schulke, HFU, 2020 | Moritz Beaugrand, HFU, 2021
     */
    class MeshTerrain extends FudgeCore.Mesh {
        constructor(_name = "MeshTerrain", _resolution = FudgeCore.Vector2.ONE(2), _scaleInput = FudgeCore.Vector2.ONE(), _functionOrSeed = 0) {
            super(_name);
            this.heightMapFunction = null;
            this.create(_resolution, _scaleInput, _functionOrSeed);
        }
        create(_resolution = FudgeCore.Vector2.ONE(2), _scaleInput = FudgeCore.Vector2.ONE(), _functionOrSeed = 0) {
            this.clear();
            this.seed = undefined;
            this.resolution = new FudgeCore.Vector2(Math.round(_resolution.x), Math.round(_resolution.y));
            this.scale = _scaleInput.clone;
            if (_functionOrSeed instanceof Function)
                this.heightMapFunction = _functionOrSeed;
            else if (typeof (_functionOrSeed) == "number") {
                this.seed = _functionOrSeed;
                let prng = new FudgeCore.Random(this.seed);
                this.heightMapFunction = new FudgeCore.Noise2(() => prng.getNorm()).sample; // TODO call PRNG
            }
            else
                this.heightMapFunction = new FudgeCore.Noise2().sample;
            this.cloud = new FudgeCore.Vertices();
            //Iterate over each cell to generate grid of vertices
            for (let z = 0; z <= this.resolution.y; z++) {
                for (let x = 0; x <= this.resolution.x; x++) {
                    let xNorm = x / this.resolution.x;
                    let zNorm = z / this.resolution.y;
                    this.cloud.push(new FudgeCore.Vertex(new FudgeCore.Vector3(xNorm - 0.5, this.heightMapFunction(xNorm * this.scale.x, zNorm * this.scale.y), zNorm - 0.5), new FudgeCore.Vector2(xNorm, zNorm)));
                }
            }
            let quads = [];
            let split = FudgeCore.QUADSPLIT.AT_0;
            for (let z = 0; z < this.resolution.y; z++) {
                for (let x = 0; x < this.resolution.x; x++) {
                    quads.push(new FudgeCore.Quad(this.cloud, (x + 0) + (z + 0) * (this.resolution.x + 1), (x + 0) + (z + 1) * (this.resolution.x + 1), (x + 1) + (z + 1) * (this.resolution.x + 1), (x + 1) + (z + 0) * (this.resolution.x + 1), split));
                    split = (split == FudgeCore.QUADSPLIT.AT_0) ? FudgeCore.QUADSPLIT.AT_1 : FudgeCore.QUADSPLIT.AT_0;
                }
                if (this.resolution.x % 2 == 0) // reverse last split change if x-resolution is even
                    split = (split == FudgeCore.QUADSPLIT.AT_0) ? FudgeCore.QUADSPLIT.AT_1 : FudgeCore.QUADSPLIT.AT_0;
            }
            this.faces = quads.flatMap((quad) => quad.faces);
        }
        /**
         * Returns information about the vertical projection of the given position onto the terrain.
         * Pass the overall world transformation of the terrain if the position is given in world coordinates.
         * If at hand, pass the inverse too to avoid unnecessary calculation.
         */
        getTerrainInfo(_position, _mtxWorld = FudgeCore.Matrix4x4.IDENTITY(), _mtxInverse) {
            if (!_mtxInverse)
                _mtxInverse = FudgeCore.Matrix4x4.INVERSION(_mtxWorld);
            let terrainInfo = new TerrainInfo;
            let posLocal = FudgeCore.Vector3.TRANSFORMATION(_position, _mtxInverse, true);
            let z = Math.floor((posLocal.z + 0.5) * this.resolution.y);
            let x = Math.floor((posLocal.x + 0.5) * this.resolution.x);
            if (z < 0 || z > this.resolution.y - 1 || x < 0 || x > this.resolution.x - 1)
                return null;
            let index = (z * this.resolution.x + x) * 2;
            let face = this.faces[index];
            let ray = new FudgeCore.Ray(FudgeCore.Vector3.Y(), posLocal);
            let point = ray.intersectFacePlane(face);
            if (!face.isInside(point)) {
                index++;
                face = this.faces[index];
                point = ray.intersectFacePlane(face);
            }
            terrainInfo.index = index;
            terrainInfo.positionFace = point;
            terrainInfo.position = FudgeCore.Vector3.TRANSFORMATION(point, _mtxWorld, true);
            terrainInfo.normal = FudgeCore.Vector3.TRANSFORMATION(face.normal, FudgeCore.Matrix4x4.TRANSPOSE(_mtxInverse), false);
            terrainInfo.distance = _position.y - terrainInfo.position.y;
            return terrainInfo;
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.seed = this.seed;
            serialization.scale = this.scale.serialize();
            serialization.resolution = this.resolution.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            await this.resolution.deserialize(_serialization.resolution);
            await this.scale.deserialize(_serialization.scale);
            this.seed = _serialization.seed;
            this.create(this.resolution, this.scale, this.seed);
            return this;
        }
        async mutate(_mutator) {
            super.mutate(_mutator);
            this.create(new FudgeCore.Vector2(_mutator.resolution.x, _mutator.resolution.y), new FudgeCore.Vector2(_mutator.scale.x, _mutator.scale.y), _mutator.seed);
        }
    }
    MeshTerrain.iSubclass = FudgeCore.Mesh.registerSubclass(MeshTerrain);
    FudgeCore.MeshTerrain = MeshTerrain;
})(FudgeCore || (FudgeCore = {}));
///<reference path="MeshTerrain.ts"/>
var FudgeCore;
///<reference path="MeshTerrain.ts"/>
(function (FudgeCore) {
    /**
     * Generates a planar Grid and applies a Heightmap-Function to it.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021 | Moritz Beaugrand, HFU, 2020
     */
    class MeshRelief extends FudgeCore.MeshTerrain {
        constructor(_name = "MeshRelief", _texture = null) {
            super(_name, FudgeCore.Vector2.ONE(2), undefined, (_x, _z) => 0);
            this.texture = null;
            this.setTexture(_texture);
        }
        static createHeightMapFunction(_texture) {
            let array = MeshRelief.textureToClampedArray(_texture);
            let heightMapFunction = (_x, _z) => {
                let pixel = Math.round(_z * _texture.image.width + _x);
                return array[pixel * 4] / 255;
            };
            return heightMapFunction;
        }
        static textureToClampedArray(_texture) {
            let canvas = document.createElement("canvas");
            canvas.width = _texture.image.width;
            canvas.height = _texture.image.height;
            let crc = canvas.getContext("2d");
            crc.imageSmoothingEnabled = false;
            crc.drawImage(_texture.image, 0, 0);
            return crc.getImageData(0, 0, _texture.image.width, _texture.image.height).data;
        }
        setTexture(_texture = null) {
            if (!_texture)
                return;
            this.texture = _texture;
            let resolution = _texture ? new FudgeCore.Vector2(_texture.image.width - 1, _texture.image.height - 1) : undefined;
            super.create(resolution, resolution, MeshRelief.createHeightMapFunction(_texture));
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            delete serialization.seed;
            delete serialization.scale;
            delete serialization.resolution;
            if (this.texture)
                serialization.idTexture = this.texture.idResource;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            if (_serialization.idTexture) {
                this.texture = await FudgeCore.Project.getResource(_serialization.idTexture);
                this.setTexture(this.texture);
            }
            return this;
        }
        async mutate(_mutator) {
            this.setTexture(_mutator.texture);
        }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
            delete _mutator.seed;
            delete _mutator.scale;
            delete _mutator.resolution;
        }
    }
    MeshRelief.iSubclass = FudgeCore.Mesh.registerSubclass(MeshRelief);
    FudgeCore.MeshRelief = MeshRelief;
})(FudgeCore || (FudgeCore = {}));
// /<reference path="MeshPolygon.ts"/>
var FudgeCore;
// /<reference path="MeshPolygon.ts"/>
(function (FudgeCore) {
    /**
     * Generates a rotation of a polygon around the y-axis
     * ```plaintext
     *                     y
     *                  _  ‚Üë 0_1
     *                 ‚îÇ   ‚îÇ‚Üíx ‚îÇ2
     *                  ‚ï≤  ‚îÇ  ‚ï±3
     *                  ‚ï±  ‚îÇ  ‚ï≤
     *                 ‚ï±___‚îÇ___‚ï≤4
     *                      5
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021-2022
     */
    class MeshRotation extends FudgeCore.Mesh {
        constructor(_name = "MeshRotation", _shape = MeshRotation.verticesDefault, _longitudes = 3) {
            super(_name);
            this.shape = new FudgeCore.MutableArray();
            this.rotate(_shape, _longitudes);
            // console.log("Mutator", this.getMutator());
        }
        get minVertices() {
            return 2;
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.shape = FudgeCore.Serializer.serializeArray(FudgeCore.Vector2, this.shape);
            serialization.longitudes = this.longitudes;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            let shape = await FudgeCore.Serializer.deserializeArray(_serialization.shape);
            this.longitudes = _serialization.longitudes;
            this.rotate(shape, this.longitudes);
            return this;
        }
        async mutate(_mutator) {
            await super.mutate(_mutator);
            this.rotate(this.shape, this.longitudes);
            this.dispatchEvent(new Event("mutate" /* MUTATE */));
        }
        //#endregion
        rotate(_shape, _longitudes) {
            this.clear();
            this.shape = FudgeCore.MutableArray.from(_shape.map(_vertex => _vertex.clone));
            this.longitudes = Math.round(_longitudes);
            let angle = 360 / this.longitudes;
            let mtxRotate = FudgeCore.Matrix4x4.ROTATION_Y(angle);
            // copy original polygon as Vector3 array
            let polygon = [];
            let distances = [0];
            let total = 0;
            for (let i = 0; i < this.shape.length; i++) {
                polygon.push(this.shape[i].toVector3());
                if (i > 0) {
                    let distance = FudgeCore.Vector2.DIFFERENCE(this.shape[i], this.shape[i - 1]).magnitude;
                    total += distance;
                    distances.push(total);
                }
            }
            distances.forEach((entry, index) => { distances[index] = entry / total; });
            let nVerticesPolygon = polygon.length;
            let cloud = new FudgeCore.Vertices();
            for (let longitude = 0; longitude <= this.longitudes; longitude++) {
                for (let i = 0; i < nVerticesPolygon; i++) {
                    let uv = new FudgeCore.Vector2(longitude / this.longitudes, distances[i]);
                    // TODO: last sector should only be references to the first meridian
                    if (longitude == this.longitudes)
                        cloud.push(new FudgeCore.Vertex(i, uv));
                    else {
                        if (longitude > 0 && this.shape[i].x == 0) // use a single vertex when it's on the rotation axis
                            cloud.push(new FudgeCore.Vertex(i, uv));
                        else
                            cloud.push(new FudgeCore.Vertex(polygon[i].clone, uv));
                    }
                }
                polygon.forEach((_vector) => _vector.transform(mtxRotate));
            }
            // copy indices to new index array
            let faces = [];
            for (let longitude = 0; longitude < this.longitudes; longitude++) {
                for (let latitude = 0; latitude < nVerticesPolygon - 1; latitude++) {
                    let start = longitude * nVerticesPolygon + latitude;
                    let quad = new FudgeCore.Quad(cloud, start + 1, start + 1 + nVerticesPolygon, start + nVerticesPolygon, start);
                    faces.push(...quad.faces);
                    // TODO: catch invalid faces right here...
                }
            }
            this.cloud = cloud;
            this.faces = faces;
        }
    }
    MeshRotation.iSubclass = FudgeCore.Mesh.registerSubclass(MeshRotation);
    MeshRotation.verticesDefault = [
        new FudgeCore.Vector2(0.5, 0.5),
        new FudgeCore.Vector2(0.5, -0.5)
    ];
    FudgeCore.MeshRotation = MeshRotation;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a UV Sphere with a given number of sectors and stacks (clamped at 128*128)
     * Implementation based on http://www.songho.ca/opengl/gl_sphere.html
     * @authors Simon Storl-Schulke, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2020
     */
    class MeshSphere extends FudgeCore.MeshRotation {
        constructor(_name = "MeshSphere", _longitudes = 8, _latitudes = 8) {
            super(_name);
            this.create(_longitudes, _latitudes);
        }
        create(_longitudes = 3, _latitudes = 2) {
            this.clear();
            //Clamp resolution to prevent performance issues
            this.longitudes = Math.min(Math.round(_longitudes), 128);
            this.latitudes = Math.min(Math.round(_latitudes), 128);
            if (_longitudes < 3 || _latitudes < 2) {
                FudgeCore.Debug.warn("UV Sphere must have at least 3 longitudes and 2 latitudes to form a 3-dimensional shape.");
                this.longitudes = Math.max(3, _longitudes);
                this.latitudes = Math.max(2, _latitudes);
            }
            let shape = [];
            let step = Math.PI / this.latitudes;
            for (let i = 0; i <= this.latitudes; ++i) {
                let angle = Math.PI / 2 - i * step;
                let x = Math.cos(angle);
                let y = Math.sin(angle);
                shape.push(new FudgeCore.Vector2(x / 2, y / 2));
            }
            // place first and last vertex exactly on rotation axis
            shape[0].x = 0;
            shape[shape.length - 1].x = 0;
            super.rotate(shape, _longitudes);
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.latitudes = this.latitudes;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            this.create(_serialization.longitudes, _serialization.latitudes);
            return this;
        }
        async mutate(_mutator) {
            super.mutate(_mutator);
            this.create(_mutator.longitudes, _mutator.latitudes);
        }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
            delete _mutator.shape;
        }
    }
    MeshSphere.iSubclass = FudgeCore.Mesh.registerSubclass(MeshSphere);
    FudgeCore.MeshSphere = MeshSphere;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate two quads placed back to back, the one facing in negative Z-direction is textured reversed
     * ```plaintext
     *        0 __ 3
     *         |__|
     *        1    2
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2020
     */
    class MeshSprite extends FudgeCore.Mesh {
        constructor(_name = "MeshSprite") {
            super(_name);
            this.cloud = new FudgeCore.Vertices(new FudgeCore.Vertex(new FudgeCore.Vector3(-0.5, 0.5, 0), new FudgeCore.Vector2(0, 0)), new FudgeCore.Vertex(new FudgeCore.Vector3(-0.5, -0.5, 0), new FudgeCore.Vector2(0, 1)), new FudgeCore.Vertex(new FudgeCore.Vector3(0.5, -0.5, 0), new FudgeCore.Vector2(1, 1)), new FudgeCore.Vertex(new FudgeCore.Vector3(0.5, 0.5, 0), new FudgeCore.Vector2(1, 0)));
            this.faces = [
                new FudgeCore.Face(this.cloud, 1, 2, 0),
                new FudgeCore.Face(this.cloud, 2, 3, 0),
                new FudgeCore.Face(this.cloud, 0, 3, 1),
                new FudgeCore.Face(this.cloud, 3, 2, 1)
            ];
            console.log(this.normalsVertex);
        }
        // flat is standard here
        get verticesFlat() { return super.vertices; }
        get indicesFlat() { return super.indices; }
    }
    MeshSprite.iSubclass = FudgeCore.Mesh.registerSubclass(MeshSprite);
    FudgeCore.MeshSprite = MeshSprite;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a Torus with a given thickness and the number of major- and minor segments
     * @authors Simon Storl-Schulke, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2020
     */
    class MeshTorus extends FudgeCore.MeshRotation {
        constructor(_name = "MeshTorus", _size = 0.25, _longitudes = 8, _latitudes = 6) {
            super(_name, MeshTorus.getShape(_size, Math.max(3, _latitudes)), _longitudes);
            this.size = 0.25;
            this.latitudes = 12;
            this.size = _size;
            this.longitudes = _longitudes;
            this.latitudes = Math.max(3, _latitudes);
        }
        static getShape(_size, _latitudes) {
            let shape = [];
            let radius = _size / 2;
            let center = new FudgeCore.Vector2(0.25 + radius, 0);
            for (let latitude = 0; latitude <= _latitudes; latitude++) {
                let angle = 2 * Math.PI * latitude / _latitudes;
                shape.push(FudgeCore.Vector2.SUM(center, new FudgeCore.Vector2(radius * -Math.cos(angle), radius * Math.sin(angle))));
            }
            return shape;
        }
        create(_size = 0.25, _longitudes = 8, _latitudes = 6) {
            this.size = _size;
            this.latitudes = Math.max(3, _latitudes);
            super.rotate(MeshTorus.getShape(_size, _latitudes), _longitudes);
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.latitudes = this.latitudes;
            serialization.size = this.size;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            this.create(_serialization.size, _serialization.longitudes, _serialization.latitudes);
            return this;
        }
        async mutate(_mutator) {
            super.mutate(_mutator);
            this.create(_mutator.size, _mutator.longitudes, _mutator.latitudes);
        }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
            delete _mutator.shape;
        }
    }
    MeshTorus.iSubclass = FudgeCore.Mesh.registerSubclass(MeshTorus);
    FudgeCore.MeshTorus = MeshTorus;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let QUADSPLIT;
    (function (QUADSPLIT) {
        QUADSPLIT[QUADSPLIT["PLANAR"] = 0] = "PLANAR";
        QUADSPLIT[QUADSPLIT["AT_0"] = 1] = "AT_0";
        QUADSPLIT[QUADSPLIT["AT_1"] = 2] = "AT_1";
    })(QUADSPLIT = FudgeCore.QUADSPLIT || (FudgeCore.QUADSPLIT = {}));
    /**
     * A surface created with four vertices which immediately creates none, one or two {@link Face}s depending on vertices at identical positions.
     * ```plaintext
     * QUADSPLIT:  PLANAR                  AT_0                     AT_1
     *             0 _ 3                   0 _ 3                    0 _ 3
     *              |\|                     |\|                      |/|
     *             1 ‚Äæ 2                   1 ‚Äæ 2                    1 ‚Äæ 2
     *  shared last vertex 2      last vertices 2 + 3      last vertices 3 + 0
     *
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2022
     */
    class Quad {
        constructor(_vertices, _index0, _index1, _index2, _index3, _split = QUADSPLIT.PLANAR) {
            this.faces = [];
            this.#split = _split;
            try {
                if (_split != QUADSPLIT.AT_1)
                    this.faces.push(new FudgeCore.Face(_vertices, _index0, _index1, _index2));
                else
                    this.faces.push(new FudgeCore.Face(_vertices, _index1, _index2, _index3));
            }
            catch (_e) {
                FudgeCore.Debug.fudge("Face excluded", _e.message);
            }
            try {
                if (_split == QUADSPLIT.PLANAR)
                    this.faces.push(new FudgeCore.Face(_vertices, _index3, _index0, _index2));
                else if (_split == QUADSPLIT.AT_0)
                    this.faces.push(new FudgeCore.Face(_vertices, _index0, _index2, _index3));
                else
                    this.faces.push(new FudgeCore.Face(_vertices, _index1, _index3, _index0));
            }
            catch (_e) {
                FudgeCore.Debug.fudge("Face excluded", _e.message);
            }
        }
        #split;
        get split() {
            return this.#split;
        }
    }
    FudgeCore.Quad = Quad;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class Vertex {
        /**
         * Represents a vertex of a mesh with extended information such as the uv coordinates and the vertex normal.
         * It may refer to another vertex via an index into some array, in which case the position and the normal are stored there.
         * This way, vertex position and normal is a 1:1 association, vertex to texture coordinates a 1:n association.
       * @authors Jirka Dell'Oro-Friedl, HFU, 2022
         */
        constructor(_positionOrIndex, _uv = null, _normal = FudgeCore.Vector3.ZERO()) {
            if (_positionOrIndex instanceof FudgeCore.Vector3)
                this.position = _positionOrIndex;
            else
                this.referTo = _positionOrIndex;
            this.uv = _uv;
            this.normal = _normal;
        }
    }
    FudgeCore.Vertex = Vertex;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Array with extended functionality to serve as a {@link Vertex}-cloud.
     * Accessors yield position or normal also for vertices referencing other vertices
     * @authors Jirka Dell'Oro-Friedl, HFU, 2022
     */
    class Vertices extends Array {
        // TODO: this class may become more powerful by hiding the array and add more service methods like calculating bounding box, radius etc.
        // see if a proxy of the array interfacing [] would do a good job
        /**
         * returns the position associated with the vertex addressed, resolving references between vertices
         */
        position(_index) {
            let vertex = this[_index];
            return (vertex.referTo == undefined) ? vertex.position : this[vertex.referTo].position;
        }
        /**
         * returns the normal associated with the vertex addressed, resolving references between vertices
         */
        normal(_index) {
            let vertex = this[_index];
            return (vertex.referTo == undefined) ? vertex.normal : this[vertex.referTo].normal;
        }
        /**
         * returns the uv-coordinates associated with the vertex addressed
         */
        uv(_index) {
            return this[_index].uv;
        }
    }
    FudgeCore.Vertices = Vertices;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Defines automatic adjustment of the collider
     */
    let BODY_INIT;
    (function (BODY_INIT) {
        /** Collider uses the pivot of the mesh for initilialization */
        BODY_INIT[BODY_INIT["TO_MESH"] = 0] = "TO_MESH";
        /** Collider uses the transform of the node for initilialization */
        BODY_INIT[BODY_INIT["TO_NODE"] = 1] = "TO_NODE";
        /** Collider uses its own pivot for initilialization */
        BODY_INIT[BODY_INIT["TO_PIVOT"] = 2] = "TO_PIVOT";
    })(BODY_INIT = FudgeCore.BODY_INIT || (FudgeCore.BODY_INIT = {}));
    /**
       * Acts as the physical representation of the {@link Node} it's attached to.
       * It's the connection between the Fudge rendered world and the Physics world.
       * For the physics to correctly get the transformations rotations need to be applied with from left = true.
       * Or rotations need to happen before scaling.
       * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
       */
    class ComponentRigidbody extends FudgeCore.Component {
        // #physics: Physics; //TODO: keep a pointer to the physics instance used by this component
        /** Creating a new rigidbody with a weight in kg, a physics type (default = dynamic), a collider type what physical form has the collider, to what group does it belong, is there a transform Matrix that should be used, and is the collider defined as a group of points that represent a convex mesh. */
        constructor(_mass = 1, _type = FudgeCore.BODY_TYPE.DYNAMIC, _colliderType = FudgeCore.COLLIDER_TYPE.CUBE, _group = FudgeCore.Physics.settings.defaultCollisionGroup, _mtxTransform = null, _convexMesh = null) {
            super();
            /** Transformation of the collider relative to the node's transform. Once set mostly remains constant.
             * If altered, {@link isInitialized} must be reset to false to recreate the collider in the next {@link Render.prepare}
             */
            this.mtxPivot = FudgeCore.Matrix4x4.IDENTITY();
            /**
             * Vertices that build a convex mesh (form that is in itself closed). Needs to set in the construction of the rb if none of the standard colliders is used.
             * Untested and not yet fully supported by serialization and mutation.
             */
            this.convexMesh = null;
            /** Collisions with rigidbodies happening to this body, can be used to build a custom onCollisionStay functionality. */
            this.collisions = new Array();
            /** Triggers that are currently triggering this body */
            this.triggerings = new Array();
            /**
             * Automatic adjustment of the pivot when {@link Render.prepare} is called according to {@link BODY_INIT}
             */
            this.initialization = BODY_INIT.TO_PIVOT;
            /** Marks if collider was initialized. Reset to false to initialize again e.g. after manipulation of mtxPivot */
            this.isInitialized = false;
            /** ID to reference this specific ComponentRigidbody */
            this.#id = 0;
            this.#collisionGroup = FudgeCore.COLLISION_GROUP.DEFAULT;
            this.#typeCollider = FudgeCore.COLLIDER_TYPE.CUBE;
            this.#rigidbodyInfo = new OIMO.RigidBodyConfig();
            this.#typeBody = FudgeCore.BODY_TYPE.DYNAMIC;
            this.#massData = new OIMO.MassData();
            this.#dampingLinear = 0.1;
            this.#dampingAngular = 0.1;
            this.#effectRotation = FudgeCore.Vector3.ONE();
            this.#effectGravity = 1;
            this.#isTrigger = false;
            this.#mtxPivotUnscaled = FudgeCore.Matrix4x4.IDENTITY();
            this.#mtxPivotInverse = FudgeCore.Matrix4x4.IDENTITY();
            //#endregion
            // Activate the functions of this component as response to events
            this.hndEvent = (_event) => {
                switch (_event.type) {
                    case "componentAdd" /* COMPONENT_ADD */:
                        // this.addEventListener(EVENT.COMPONENT_ACTIVATE, this.addRigidbodyToWorld);
                        this.addEventListener("componentDeactivate" /* COMPONENT_DEACTIVATE */, this.removeRigidbodyFromWorld);
                        // this.node.addEventListener(EVENT.NODE_ACTIVATE, this.addRigidbodyToWorld, true); // use capture to react to broadcast!
                        this.node.addEventListener("nodeDeactivate" /* NODE_DEACTIVATE */, this.removeRigidbodyFromWorld, true);
                        break;
                    case "componentRemove" /* COMPONENT_REMOVE */:
                        // this.removeEventListener(EVENT.COMPONENT_ADD, this.addRigidbodyToWorld);
                        this.removeEventListener("componentRemove" /* COMPONENT_REMOVE */, this.removeRigidbodyFromWorld);
                        // this.node.removeEventListener(EVENT.NODE_ACTIVATE, this.addRigidbodyToWorld, true); // use capture to react to broadcast!
                        this.node.removeEventListener("nodeDeactivate" /* NODE_DEACTIVATE */, this.removeRigidbodyFromWorld, true);
                        this.removeRigidbodyFromWorld();
                        break;
                    // case EVENT.NODE_DESERIALIZED:
                    //   // if deserialized the node is now fully reconstructed and access to all its components and children is possible
                    //   this.node.addEventListener(EVENT.NODE_ACTIVATE, this.addRigidbodyToWorld);
                    //   this.node.addEventListener(EVENT.NODE_DEACTIVATE, this.removeRigidbodyFromWorld);
                    //   break;
                }
            };
            /** Adding this ComponentRigidbody to the Physiscs.world giving the oimoPhysics system the information needed */
            this.addRigidbodyToWorld = () => {
                if (!this.#rigidbody._world)
                    FudgeCore.Physics.addRigidbody(this);
            };
            /** Removing this ComponentRigidbody from the Physiscs.world taking the informations from the oimoPhysics system */
            this.removeRigidbodyFromWorld = () => {
                FudgeCore.Physics.removeRigidbody(this);
                this.isInitialized = false;
            };
            this.create(_mass, _type, _colliderType, _group, _mtxTransform, _convexMesh);
            this.addEventListener("componentAdd" /* COMPONENT_ADD */, this.hndEvent);
            this.addEventListener("componentRemove" /* COMPONENT_REMOVE */, this.hndEvent);
            // this.addEventListener(EVENT.NODE_DESERIALIZED, this.hndEvent);
        }
        /** ID to reference this specific ComponentRigidbody */
        #id;
        //Private informations - Mostly OimoPhysics variables that should not be exposed to the Fudge User and manipulated by them
        #collider;
        #colliderInfo;
        #collisionGroup;
        #typeCollider;
        #rigidbody;
        #rigidbodyInfo;
        #typeBody;
        #massData;
        #restitution;
        #friction;
        #dampingLinear;
        #dampingAngular;
        #effectRotation;
        #effectGravity;
        #isTrigger;
        #mtxPivotUnscaled;
        #mtxPivotInverse;
        #callbacks; //Callback Methods when within the oimoSystem a event is happening
        //#region Accessors
        get id() {
            return this.#id;
        }
        /** Used for calculation of the geometrical relationship of node and collider by {@link Render}*/
        get mtxPivotInverse() {
            return this.#mtxPivotInverse;
        }
        /** Used for calculation of the geometrical relationship of node and collider by {@link Render}*/
        get mtxPivotUnscaled() {
            return this.#mtxPivotUnscaled;
        }
        /** Retrieve the body type. See {@link BODY_TYPE} */
        get typeBody() {
            return this.#typeBody;
        }
        /** Set the body type. See {@link BODY_TYPE} */
        set typeBody(_value) {
            this.#typeBody = _value;
            this.#rigidbody.setType(ComponentRigidbody.mapBodyType[this.#typeBody]);
            this.#rigidbody.setMassData(this.#massData); //have to reset mass after changing the type, since Oimo is handling mass internally wrong when switching types
        }
        /** The shape that represents the {@link Node} in the physical world. Default is a Cube. */
        get typeCollider() {
            return this.#typeCollider;
        }
        set typeCollider(_value) {
            if (_value != this.#typeCollider && this.#rigidbody != null) {
                this.#typeCollider = _value;
                this.initialize();
            }
        }
        /** The collision group this {@link Node} belongs to it's the default group normally which means it physically collides with every group besides trigger. */
        get collisionGroup() {
            return this.#collisionGroup;
        }
        set collisionGroup(_value) {
            this.#collisionGroup = _value;
            if (this.#rigidbody != null)
                this.#rigidbody.getShapeList().setCollisionGroup(this.#collisionGroup);
        }
        /** Marking the Body as a trigger therefore not influencing the collision system but only sending triggerEvents */
        get isTrigger() {
            return this.#isTrigger;
        }
        set isTrigger(_value) {
            this.#isTrigger = _value;
            if (this.getOimoRigidbody() != null) {
                this.getOimoRigidbody()._isTrigger = this.#isTrigger;
            }
        }
        /**
         * Returns the physical weight of the {@link Node}
         */
        get mass() {
            return this.#rigidbody.getMass();
        }
        /**
         * Setting the physical weight of the {@link Node} in kg
         */
        set mass(_value) {
            this.#massData.mass = _value;
            if (this.node != null)
                if (this.#rigidbody != null)
                    this.#rigidbody.setMassData(this.#massData);
        }
        /** Drag of linear movement. A Body does slow down even on a surface without friction. */
        get dampTranslation() {
            return this.#rigidbody.getLinearDamping();
        }
        set dampTranslation(_value) {
            this.#dampingLinear = _value;
            this.#rigidbody.setLinearDamping(_value);
        }
        /** Drag of rotation. */
        get dampRotation() {
            return this.#rigidbody.getAngularDamping();
        }
        set dampRotation(_value) {
            this.#dampingAngular = _value;
            this.#rigidbody.setAngularDamping(_value);
        }
        /** The factor this rigidbody reacts rotations that happen in the physical world. 0 to lock rotation this axis. */
        get effectRotation() {
            return this.#effectRotation;
        }
        set effectRotation(_effect) {
            this.#effectRotation = _effect;
            this.#rigidbody.setRotationFactor(new OIMO.Vec3(this.#effectRotation.x, this.#effectRotation.y, this.#effectRotation.z));
        }
        /** The factor this rigidbody reacts to world gravity. Default = 1 e.g. 1*9.81 m/s. */
        get effectGravity() {
            return this.#effectGravity;
        }
        set effectGravity(_effect) {
            this.#effectGravity = _effect;
            if (this.#rigidbody != null)
                this.#rigidbody.setGravityScale(this.#effectGravity);
        }
        /**
         * Get the friction of the rigidbody, which is the factor of sliding resistance of this rigidbody on surfaces
         */
        get friction() {
            return this.#friction;
        }
        /**
         * Set the friction of the rigidbody, which is the factor of  sliding resistance of this rigidbody on surfaces
         */
        set friction(_friction) {
            this.#friction = _friction;
            if (this.#rigidbody.getShapeList() != null)
                this.#rigidbody.getShapeList().setFriction(this.#friction);
        }
        /**
         * Get the restitution of the rigidbody, which is the factor of bounciness of this rigidbody on surfaces
         */
        get restitution() {
            return this.#restitution;
        }
        /**
         * Set the restitution of the rigidbody, which is the factor of bounciness of this rigidbody on surfaces
         */
        set restitution(_restitution) {
            this.#restitution = _restitution;
            if (this.#rigidbody.getShapeList() != null)
                this.#rigidbody.getShapeList().setRestitution(this.#restitution);
        }
        //#region Transformation
        /**
         * Returns the rigidbody in the form the physics engine is using it, should not be used unless a functionality
         * is not provided through the FUDGE Integration.
         */
        getOimoRigidbody() {
            return this.#rigidbody;
        }
        /** Rotating the rigidbody therefore changing it's rotation over time directly in physics. This way physics is changing instead of transform.
         *  But you are able to incremental changing it instead of a direct rotation.  Although it's always prefered to use forces in physics.
         */
        rotateBody(_rotationChange) {
            this.#rigidbody.rotateXyz(new OIMO.Vec3(_rotationChange.x * Math.PI / 180, _rotationChange.y * Math.PI / 180, _rotationChange.z * Math.PI / 180));
        }
        /** Translating the rigidbody therefore changing it's place over time directly in physics. This way physics is changing instead of transform.
         *  But you are able to incrementally changing it instead of a direct position. Although it's always prefered to use forces in physics.
         */
        translateBody(_translationChange) {
            this.#rigidbody.translate(new OIMO.Vec3(_translationChange.x, _translationChange.y, _translationChange.z));
        }
        /**
         * Get the current POSITION of the {@link Node} in the physical space
         */
        getPosition() {
            let tmpPos = this.#rigidbody.getPosition();
            return new FudgeCore.Vector3(tmpPos.x, tmpPos.y, tmpPos.z);
        }
        /**
         * Sets the current POSITION of the {@link Node} in the physical space
         */
        setPosition(_value) {
            this.#rigidbody.setPosition(new OIMO.Vec3(_value.x, _value.y, _value.z));
        }
        /**
         * Get the current ROTATION of the {@link Node} in the physical space. Note this range from -pi to pi, so -90 to 90.
         */
        getRotation() {
            let orientation = this.#rigidbody.getOrientation();
            let tmpQuat = new FudgeCore.Quaternion(orientation.x, orientation.y, orientation.z, orientation.w);
            return tmpQuat.toDegrees();
        }
        /**
         * Sets the current ROTATION of the {@link Node} in the physical space, in degree.
         */
        setRotation(_value) {
            let quat = new OIMO.Quat();
            let mtxRot = FudgeCore.Matrix4x4.IDENTITY();
            mtxRot.rotate(new FudgeCore.Vector3(_value.x, _value.y, _value.z));
            let array = mtxRot.get();
            let rot = new OIMO.Mat3(array[0], array[4], array[8], array[1], array[5], array[9], array[2], array[6], array[10]);
            quat.fromMat3(rot);
            // quat.normalize();
            this.#rigidbody.setOrientation(quat);
        }
        /** Get the current SCALING in the physical space. */
        getScaling() {
            let scaling = this.node.mtxWorld.scaling.clone;
            scaling.x *= this.mtxPivot.scaling.x;
            scaling.y *= this.mtxPivot.scaling.y;
            scaling.z *= this.mtxPivot.scaling.z;
            return scaling;
        }
        /** Scaling requires the collider to be completely recreated anew */
        setScaling(_value) {
            // let scaling: Vector3 = _value.clone;   
            this.createCollider(new OIMO.Vec3(_value.x / 2, _value.y / 2, _value.z / 2), this.#typeCollider); //recreate the collider
            this.#collider = new OIMO.Shape(this.#colliderInfo);
            let oldCollider = this.#rigidbody.getShapeList();
            this.#rigidbody.addShape(this.#collider); //add new collider, before removing the old, so the rb is never active with 0 colliders
            this.#rigidbody.removeShape(oldCollider); //remove the old collider
            this.#collider.userData = this; //reset the extra information so that this collider knows to which Fudge Component it's connected
            this.#collider.setCollisionGroup(this.collisionGroup);
            this.#collider.setCollisionMask(this.collisionMask);
            this.#collider.setRestitution(this.#restitution);
            this.#collider.setFriction(this.#friction);
            this.#collider.setContactCallback(this.#callbacks);
        }
        /**
         * Initializes the rigidbody according to its initialization setting to match the mesh, the node or its own pivot matrix
         */
        initialize() {
            if (!this.node) // delay initialization until this rigidbody is attached to a node
                return;
            switch (this.initialization) {
                case BODY_INIT.TO_NODE:
                    this.mtxPivot = FudgeCore.Matrix4x4.IDENTITY();
                    break;
                case BODY_INIT.TO_MESH:
                    let cmpMesh = this.node.getComponent(FudgeCore.ComponentMesh);
                    if (cmpMesh)
                        this.mtxPivot = cmpMesh.mtxPivot.clone;
                    break;
                case BODY_INIT.TO_PIVOT:
                    break;
            }
            let mtxWorld = FudgeCore.Matrix4x4.MULTIPLICATION(this.node.mtxWorld, this.mtxPivot);
            let position = mtxWorld.translation; //Adding the offsets from the pivot
            let rotation = mtxWorld.getEulerAngles();
            let scaling = mtxWorld.scaling;
            //scaling requires collider to be recreated
            this.setScaling(scaling);
            this.#rigidbody.setMassData(this.#massData);
            this.setPosition(position); //set the actual new rotation/position for this Rb again since it's now updated
            this.setRotation(rotation);
            this.#mtxPivotUnscaled = FudgeCore.Matrix4x4.CONSTRUCTION({ translation: this.mtxPivot.translation, rotation: this.mtxPivot.rotation, scaling: FudgeCore.Vector3.ONE() });
            this.#mtxPivotInverse = FudgeCore.Matrix4x4.INVERSION(this.#mtxPivotUnscaled);
            this.addRigidbodyToWorld();
            this.isInitialized = true;
        }
        //#endregion
        //#region Velocity and Forces
        /**
        * Get the current VELOCITY of the {@link Node}
        */
        getVelocity() {
            let velocity = this.#rigidbody.getLinearVelocity();
            return new FudgeCore.Vector3(velocity.x, velocity.y, velocity.z);
        }
        /**
         * Sets the current VELOCITY of the {@link Node}
         */
        setVelocity(_value) {
            let velocity = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.#rigidbody.setLinearVelocity(velocity);
        }
        /**
         * Get the current ANGULAR - VELOCITY of the {@link Node}
         */
        getAngularVelocity() {
            let velocity = this.#rigidbody.getAngularVelocity();
            return new FudgeCore.Vector3(velocity.x, velocity.y, velocity.z);
        }
        /**
         * Sets the current ANGULAR - VELOCITY of the {@link Node}
         */
        setAngularVelocity(_value) {
            let velocity = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.#rigidbody.setAngularVelocity(velocity);
        }
        /**
        * Applies a continous FORCE at the center of the RIGIDBODY in the three dimensions. Considering the rigidbody's MASS.
        * The force is measured in newton, 1kg needs about 10 Newton to fight against gravity.
        */
        applyForce(_force) {
            this.#rigidbody.applyForceToCenter(new OIMO.Vec3(_force.x, _force.y, _force.z));
        }
        /**
        * Applies a continous FORCE at a specific point in the world to the RIGIDBODY in the three dimensions. Considering the rigidbody's MASS
        */
        applyForceAtPoint(_force, _worldPoint) {
            this.#rigidbody.applyForce(new OIMO.Vec3(_force.x, _force.y, _force.z), new OIMO.Vec3(_worldPoint.x, _worldPoint.y, _worldPoint.z));
        }
        /**
        * Applies a continous ROTATIONAL FORCE (Torque) to the RIGIDBODY in the three dimensions. Considering the rigidbody's MASS
        */
        applyTorque(_rotationalForce) {
            this.#rigidbody.applyTorque(new OIMO.Vec3(_rotationalForce.x, _rotationalForce.y, _rotationalForce.z));
        }
        /**
        * Applies a instant FORCE at a point/rigidbodycenter to the RIGIDBODY in the three dimensions. Considering the rigidbod's MASS
        * Influencing the angular speed and the linear speed.
        */
        applyImpulseAtPoint(_impulse, _worldPoint = null) {
            _worldPoint = _worldPoint != null ? _worldPoint : this.getPosition();
            this.#rigidbody.applyImpulse(new OIMO.Vec3(_impulse.x, _impulse.y, _impulse.z), new OIMO.Vec3(_worldPoint.x, _worldPoint.y, _worldPoint.z));
        }
        /**
        * Applies a instant FORCE to the RIGIDBODY in the three dimensions. Considering the rigidbody's MASS
        * Only influencing it's speed not rotation.
        */
        applyLinearImpulse(_impulse) {
            this.#rigidbody.applyLinearImpulse(new OIMO.Vec3(_impulse.x, _impulse.y, _impulse.z));
        }
        /**
       * Applies a instant ROTATIONAL-FORCE to the RIGIDBODY in the three dimensions. Considering the rigidbody's MASS
       * Only influencing it's rotation.
       */
        applyAngularImpulse(_rotationalImpulse) {
            this.#rigidbody.applyAngularImpulse(new OIMO.Vec3(_rotationalImpulse.x, _rotationalImpulse.y, _rotationalImpulse.z));
        }
        /**
       * Changing the VELOCITY of the RIGIDBODY. Only influencing the linear speed not angular
       */
        addVelocity(_value) {
            this.#rigidbody.addLinearVelocity(new OIMO.Vec3(_value.x, _value.y, _value.z));
        }
        /**
       * Changing the VELOCITY of the RIGIDBODY. Only influencing the angular speed not the linear
       */
        addAngularVelocity(_value) {
            this.#rigidbody.addAngularVelocity(new OIMO.Vec3(_value.x, _value.y, _value.z));
        }
        /** Stops the rigidbody from sleeping when movement is too minimal. Decreasing performance, for rarely more precise physics results */
        deactivateAutoSleep() {
            this.#rigidbody.setAutoSleep(false);
        }
        activateAutoSleep() {
            this.#rigidbody.setAutoSleep(true);
        }
        //#endregion
        //#region Collision
        /**
         * Checking for Collision with other Colliders and dispatches a custom event with information about the collider.
         * Automatically called in the RenderManager, no interaction needed.
         */
        checkCollisionEvents() {
            if (!this.isInitialized) // check collisions only if intialization completed
                return;
            let list = this.#rigidbody.getContactLinkList(); //all physical contacts between colliding bodies on this rb
            let objHit; //collision consisting of 2 bodies, so Hit1/2
            let objHit2;
            let event; //The event that will be send and the informations added to it
            let normalImpulse = 0;
            let binormalImpulse = 0;
            let tangentImpulse = 0;
            let colPoint;
            //ADD NEW Collision - That just happened
            for (let i = 0; i < this.#rigidbody.getNumContactLinks(); i++) {
                let collisionManifold = list.getContact().getManifold(); //Manifold = Additional informations about the contact
                objHit = list.getContact().getShape1().userData; //Userdata is used to transfer the ∆í.ComponentRigidbody, it's an empty OimoPhysics Variable
                //Only register the collision on the actual touch, not on "shadowCollide", to register in the moment of impulse calculation
                if (!objHit.isInitialized)
                    continue;
                if (objHit == null || list.getContact().isTouching() == false) // only act if the collision is actual touching, so right at the moment when a impulse is happening, not when shapes overlap
                    return;
                objHit2 = list.getContact().getShape2().userData;
                if (!objHit2.isInitialized)
                    continue;
                if (objHit2 == null || list.getContact().isTouching() == false)
                    return;
                let points = collisionManifold.getPoints(); //All points in the collision where the two bodies are touching, used to calculate the full impact
                let normal = collisionManifold.getNormal();
                if (objHit.getOimoRigidbody() != this.getOimoRigidbody() && this.collisions.indexOf(objHit) == -1) { //Fire, if the hit object is not the Body itself but another and it's not already fired.
                    let colPos = this.collisionCenterPoint(points, collisionManifold.getNumPoints()); //THE point of collision is the first touching point (EXTENSION: could be the center of all touching points combined)
                    colPoint = new FudgeCore.Vector3(colPos.x, colPos.y, colPos.z);
                    points.forEach((value) => {
                        normalImpulse += value.getNormalImpulse();
                        binormalImpulse += value.getBinormalImpulse();
                        tangentImpulse += value.getTangentImpulse();
                    });
                    this.collisions.push(objHit); //Tell the object that the event for this object does not need to be fired again
                    event = new FudgeCore.EventPhysics("ColliderEnteredCollision" /* COLLISION_ENTER */, objHit, normalImpulse, tangentImpulse, binormalImpulse, colPoint, new FudgeCore.Vector3(normal.x, normal.y, normal.z)); //Building the actual event, with what object did collide and informations about it
                    this.dispatchEvent(event); //Sending the given event
                }
                if (objHit2 != this && this.collisions.indexOf(objHit2) == -1) { //Same as the above but for the case the SECOND hit object is not the body itself
                    let colPos = this.collisionCenterPoint(points, collisionManifold.getNumPoints());
                    colPoint = new FudgeCore.Vector3(colPos.x, colPos.y, colPos.z);
                    points.forEach((value) => {
                        normalImpulse += value.getNormalImpulse();
                        binormalImpulse += value.getBinormalImpulse();
                        tangentImpulse += value.getTangentImpulse();
                    });
                    this.collisions.push(objHit2);
                    event = new FudgeCore.EventPhysics("ColliderEnteredCollision" /* COLLISION_ENTER */, objHit2, normalImpulse, tangentImpulse, binormalImpulse, colPoint, new FudgeCore.Vector3(normal.x, normal.y, normal.z));
                    this.dispatchEvent(event);
                }
                list = list.getNext(); //Start the same routine with the next collision in the list
            }
            //REMOVE OLD Collisions - That do not happen anymore
            this.collisions.forEach((value) => {
                let isColliding = false;
                list = this.#rigidbody.getContactLinkList();
                for (let i = 0; i < this.#rigidbody.getNumContactLinks(); i++) {
                    objHit = list.getContact().getShape1().userData;
                    objHit2 = list.getContact().getShape2().userData;
                    if (value == objHit || value == objHit2) { //If the given object in the collisions list is still one of the objHit the collision is not CollisionEXIT
                        isColliding = true;
                    }
                    list = list.getNext();
                }
                if (isColliding == false) { //The collision is exiting but was in the collision list, then EXIT Event needs to be fired
                    let index = this.collisions.indexOf(value); //Find object in the array
                    this.collisions.splice(index); //remove it from the array
                    event = new FudgeCore.EventPhysics("ColliderLeftCollision" /* COLLISION_EXIT */, value, 0, 0, 0);
                    this.dispatchEvent(event);
                }
            });
        }
        /**
         * Sends a ray through this specific body ignoring the rest of the world and checks if this body was hit by the ray,
         * returning info about the hit. Provides the same functionality and information a regular raycast does but the ray is only testing against this specific body.
         */
        raycastThisBody(_origin, _direction, _length, _debugDraw = false) {
            let hitInfo = new FudgeCore.RayHitInfo();
            let geometry = this.#rigidbody.getShapeList().getGeometry();
            let transform = this.#rigidbody.getTransform();
            let scaledDirection = _direction.clone;
            scaledDirection.scale(_length);
            let endpoint = FudgeCore.Vector3.SUM(scaledDirection, _origin.clone);
            let oimoRay = new OIMO.RayCastHit();
            let hit = geometry.rayCast(new OIMO.Vec3(_origin.x, _origin.y, _origin.z), new OIMO.Vec3(endpoint.x, endpoint.y, endpoint.z), transform, oimoRay); //the actual OimoPhysics Raycast
            if (hit) { //If hit return a bunch of informations about the hit
                hitInfo.hit = true;
                hitInfo.hitPoint = new FudgeCore.Vector3(oimoRay.position.x, oimoRay.position.y, oimoRay.position.z);
                hitInfo.hitNormal = new FudgeCore.Vector3(oimoRay.normal.x, oimoRay.normal.y, oimoRay.normal.z);
                let dx = _origin.x - hitInfo.hitPoint.x; //calculate hit distance
                let dy = _origin.y - hitInfo.hitPoint.y;
                let dz = _origin.z - hitInfo.hitPoint.z;
                hitInfo.hitDistance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                hitInfo.rigidbodyComponent = this;
                hitInfo.rayOrigin = _origin;
                hitInfo.rayEnd = endpoint;
            }
            else { //Only tell the origin, and the hit point is the end of the ray.
                hitInfo.rayOrigin = _origin;
                hitInfo.hitPoint = new FudgeCore.Vector3(endpoint.x, endpoint.y, endpoint.z);
            }
            if (_debugDraw) {
                FudgeCore.Physics.debugDraw.debugRay(hitInfo.rayOrigin, hitInfo.hitPoint, new FudgeCore.Color(0, 1, 0, 1));
            }
            return hitInfo;
        }
        //#endregion
        //#region Saving/Loading - Some properties might be missing, e.g. convexMesh (Float32Array)
        serialize() {
            let serialization = this.getMutator();
            delete serialization.mtxPivot;
            delete serialization.active;
            serialization.typeBody = FudgeCore.BODY_TYPE[this.#typeBody];
            serialization.typeCollider = FudgeCore.COLLIDER_TYPE[this.#typeCollider];
            serialization.initialization = BODY_INIT[this.initialization];
            serialization.id = this.#id;
            serialization.pivot = this.mtxPivot.serialize();
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            super.deserialize(_serialization[super.constructor.name]);
            this.mtxPivot.deserialize(_serialization.pivot);
            this.#id = _serialization.id;
            this.mass = ifNumber(_serialization.mass, this.mass);
            this.dampTranslation = ifNumber(_serialization.dampTranslation, this.dampTranslation);
            this.dampRotation = ifNumber(_serialization.dampRotation, this.dampRotation);
            this.collisionGroup = ifNumber(_serialization.collisionGroup, this.collisionGroup);
            this.effectRotation = _serialization.effectRotation || this.effectRotation;
            this.effectGravity = ifNumber(_serialization.effectGravity, this.effectGravity);
            this.friction = ifNumber(_serialization.friction, this.friction);
            this.restitution = ifNumber(_serialization.restitution, this.restitution);
            this.isTrigger = _serialization.isTrigger || this.isTrigger;
            this.initialization = _serialization.initialization;
            this.initialization = BODY_INIT[_serialization.initialization];
            this.typeBody = FudgeCore.BODY_TYPE[_serialization.typeBody];
            this.typeCollider = FudgeCore.COLLIDER_TYPE[_serialization.typeCollider];
            // this.create(this.mass, this.#typeBody, this.#typeCollider, this.collisionGroup, null, this.convexMesh);
            return this;
        }
        /** Change properties by an associative array */
        async mutate(_mutator) {
            super.mutate(_mutator);
            let callIfExist = (_key, _setter) => {
                if (_mutator[_key])
                    _setter(_mutator[_key]);
            };
            callIfExist("friction", (_value) => this.friction = _value);
            callIfExist("restitution", (_value) => this.restitution = _value);
            callIfExist("mass", (_value) => this.mass = _value);
            callIfExist("dampTranslation", (_value) => this.dampTranslation = _value);
            callIfExist("dampRotation", (_value) => this.dampRotation = _value);
            callIfExist("effectGravity", (_value) => this.effectGravity = _value);
            callIfExist("collisionGroup", (_value) => this.collisionGroup = _value);
            callIfExist("typeBody", (_value) => this.typeBody = parseInt(_value));
            callIfExist("typeCollider", (_value) => this.typeCollider = parseInt(_value));
            this.dispatchEvent(new Event("mutate" /* MUTATE */));
        }
        getMutator() {
            let mutator = super.getMutator(true);
            mutator.friction = this.friction;
            mutator.restitution = this.restitution;
            mutator.mass = this.mass;
            mutator.dampTranslation = this.dampTranslation;
            mutator.dampRotation = this.dampRotation;
            mutator.effectGravity = this.effectGravity;
            mutator.typeBody = this.#typeBody;
            mutator.typeCollider = this.#typeCollider;
            mutator.isTrigger = this.#isTrigger;
            // Object.preventExtensions(mutator);
            return mutator;
        }
        getMutatorAttributeTypes(_mutator) {
            let types = super.getMutatorAttributeTypes(_mutator);
            if (types.typeBody)
                types.typeBody = FudgeCore.BODY_TYPE;
            if (types.typeCollider)
                types.typeCollider = FudgeCore.COLLIDER_TYPE;
            if (types.initialization)
                types.initialization = BODY_INIT;
            return types;
        }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
            delete _mutator.convexMesh; //Convex Mesh can't be shown in the editor because float32Array is not a viable mutator
            delete _mutator.collisionMask;
            delete _mutator.isInitialized;
        }
        //#endregion
        //#region Creation
        create(_mass = 1, _type = FudgeCore.BODY_TYPE.DYNAMIC, _colliderType = FudgeCore.COLLIDER_TYPE.CUBE, _group = FudgeCore.Physics.settings.defaultCollisionGroup, _mtxTransform = null, _convexMesh = null) {
            //Setting up all incoming values to be internal values
            this.convexMesh = _convexMesh;
            this.#typeBody = _type;
            this.#collisionGroup = _group;
            this.#typeCollider = _colliderType;
            this.mass = _mass;
            this.#restitution = FudgeCore.Physics.settings.defaultRestitution;
            this.#friction = FudgeCore.Physics.settings.defaultFriction;
            this.collisionMask = FudgeCore.Physics.settings.defaultCollisionMask;
            //Create the actual rigidbody in the OimoPhysics Space
            this.createRigidbody(_mass, _type, this.#typeCollider, _mtxTransform, this.#collisionGroup);
            this.#id = FudgeCore.Physics.distributeBodyID();
            // Event Callbacks directly from OIMO Physics
            this.#callbacks = new OIMO.ContactCallback(); //fehm
            this.#callbacks.beginTriggerContact = this.triggerEnter;
            this.#callbacks.endTriggerContact = this.triggerExit;
        }
        /** Creates the actual OimoPhysics Rigidbody out of informations the Fudge Component has. */
        createRigidbody(_mass, _type, _colliderType, _mtxTransform, _collisionGroup = FudgeCore.COLLISION_GROUP.DEFAULT) {
            let oimoType; //Need the conversion from simple enum to number because if enum is defined as Oimo.RigidyBodyType you have to include Oimo to use FUDGE at all
            switch (_type) {
                case FudgeCore.BODY_TYPE.DYNAMIC:
                    oimoType = OIMO.RigidBodyType.DYNAMIC;
                    break;
                case FudgeCore.BODY_TYPE.STATIC:
                    oimoType = OIMO.RigidBodyType.STATIC;
                    break;
                case FudgeCore.BODY_TYPE.KINEMATIC:
                    oimoType = OIMO.RigidBodyType.KINEMATIC;
                    break;
                default:
                    oimoType = OIMO.RigidBodyType.DYNAMIC;
                    break;
            }
            // remove all previous shapes from world. Necessary?
            // while (this.#rigidbody && this.#rigidbody.getShapeList() != null)
            //   this.#rigidbody.removeShape(this.#rigidbody.getShapeList());
            let tmpTransform = _mtxTransform == null ? super.node != null ? super.node.mtxWorld : FudgeCore.Matrix4x4.IDENTITY() : _mtxTransform; //Get transform informations from the world, since physics does not care about hierarchy
            //Convert informations from Fudge to OimoPhysics and creating a collider with it, while also adding a pivot to derivate from the transform informations if needed
            let scale = new OIMO.Vec3((tmpTransform.scaling.x * this.mtxPivot.scaling.x) / 2, (tmpTransform.scaling.y * this.mtxPivot.scaling.y) / 2, (tmpTransform.scaling.z * this.mtxPivot.scaling.z) / 2);
            let position = new OIMO.Vec3(tmpTransform.translation.x + this.mtxPivot.translation.x, tmpTransform.translation.y + this.mtxPivot.translation.y, tmpTransform.translation.z + this.mtxPivot.translation.z);
            let rotation = new OIMO.Vec3(tmpTransform.rotation.x + this.mtxPivot.rotation.x, tmpTransform.rotation.y + this.mtxPivot.rotation.y, tmpTransform.rotation.z + this.mtxPivot.rotation.z);
            this.createCollider(scale, _colliderType);
            //Setting informations about mass, position/rotation and physical reaction type
            this.#massData.mass = _mass; //_type != PHYSICS_TYPE.STATIC ? _mass : 0; //If a object is static it acts as if it has no mass
            this.#rigidbodyInfo.type = oimoType;
            this.#rigidbodyInfo.position = position;
            this.#rigidbodyInfo.rotation.fromEulerXyz(new OIMO.Vec3(rotation.x, rotation.y, rotation.z)); //Convert eulerAngles in degree to the internally used quaternions
            //Creating the actual rigidbody and it's collider
            this.#rigidbody = new OIMO.RigidBody(this.#rigidbodyInfo);
            this.#collider = new OIMO.Shape(this.#colliderInfo);
            //Filling the additional settings and informations the rigidbody needs. Who is colliding, how is the collision handled (damping, influence factors)
            this.#collider.userData = this;
            this.#collider.setCollisionGroup(_collisionGroup);
            this.#collider.setCollisionMask(this.collisionMask);
            this.#rigidbody.addShape(this.#collider);
            this.#rigidbody.setMassData(this.#massData);
            this.#rigidbody.getShapeList().setRestitution(this.#restitution);
            this.#rigidbody.getShapeList().setFriction(this.#friction);
            this.#rigidbody.getShapeList().setContactCallback(this.#callbacks);
            this.#rigidbody.setLinearDamping(this.#dampingLinear);
            this.#rigidbody.setAngularDamping(this.#dampingAngular);
            this.#rigidbody.setGravityScale(this.#effectGravity);
            this.#rigidbody.setRotationFactor(new OIMO.Vec3(this.#effectRotation.x, this.#effectRotation.y, this.#effectRotation.z));
        }
        /** Creates a collider a shape that represents the object in the physical world.  */
        createCollider(_scale, _colliderType) {
            let shapeConf = new OIMO.ShapeConfig(); //Collider with geometry and infos like friction/restitution and more
            let geometry;
            if (this.typeCollider != _colliderType) //If the collider type was changed set the internal one new, else don't so there is not infinite set calls
                this.typeCollider = _colliderType;
            switch (_colliderType) { //Create a different OimoPhysics geometry based on the given type. That is only the mathematical shape of the collider
                case FudgeCore.COLLIDER_TYPE.CUBE:
                    geometry = new OIMO.BoxGeometry(_scale);
                    break;
                case FudgeCore.COLLIDER_TYPE.SPHERE:
                    geometry = new OIMO.SphereGeometry(_scale.x);
                    break;
                case FudgeCore.COLLIDER_TYPE.CAPSULE:
                    geometry = new OIMO.CapsuleGeometry(_scale.x, _scale.y);
                    break;
                case FudgeCore.COLLIDER_TYPE.CYLINDER:
                    geometry = new OIMO.CylinderGeometry(_scale.x, _scale.y);
                    break;
                case FudgeCore.COLLIDER_TYPE.CONE:
                    geometry = new OIMO.ConeGeometry(_scale.x, _scale.y);
                    break;
                case FudgeCore.COLLIDER_TYPE.PYRAMID:
                    geometry = this.createConvexGeometryCollider(this.createPyramidVertices(), _scale);
                    break;
                case FudgeCore.COLLIDER_TYPE.CONVEX:
                    geometry = this.createConvexGeometryCollider(this.convexMesh, _scale);
                    break;
            }
            shapeConf.geometry = geometry;
            this.#colliderInfo = shapeConf; //the configuration informations that are used to add an actual collider to the rigidbody in createRigidbody
        }
        /** Creating a shape that represents a in itself closed form, out of the given vertices. */
        createConvexGeometryCollider(_vertices, _scale) {
            let verticesAsVec3 = new Array(); //Convert Fudge Vector3 to OimoVec3
            for (let i = 0; i < _vertices.length; i += 3) { //3 Values for one point
                verticesAsVec3.push(new OIMO.Vec3(_vertices[i] * _scale.x, _vertices[i + 1] * _scale.y, _vertices[i + 2] * _scale.z));
            }
            return new OIMO.ConvexHullGeometry(verticesAsVec3); //Tell OimoPhysics to create a hull that involves all points but close it of. A convex shape can not have a hole in it.
        }
        /** Internal implementation of vertices that construct a pyramid. The vertices of the implemented pyramid mesh can be used too. But they are halfed and double sided, so it's more performant to use this. */
        createPyramidVertices() {
            let vertices = new Float32Array([
                /*0*/ -1, 0, 1, /*1*/ 1, 0, 1, /*2*/ 1, 0, -1, /*3*/ -1, 0, -1,
                /*4*/ 0, 2, 0
            ]);
            return vertices;
        }
        //#region private EVENT functions
        //Calculating the center of a collision as a singular point - in case there is more than one point - by getting the geometrical center of all colliding points
        collisionCenterPoint(_colPoints, _numPoints) {
            let center;
            let totalPoints = 0;
            let totalX = 0;
            let totalY = 0;
            let totalZ = 0;
            _colPoints.forEach((value) => {
                if (totalPoints < _numPoints) {
                    totalPoints++;
                    totalX += value.getPosition2().x;
                    totalY += value.getPosition2().y;
                    totalZ += value.getPosition2().z;
                }
            });
            center = new OIMO.Vec3(totalX / _numPoints, totalY / _numPoints, totalZ / _numPoints);
            return center;
        }
        //#endregion
        /**
        * Trigger EnteringEvent Callback, automatically called by OIMO Physics within their calculations.
        * Since the event does not know which body is the trigger iniator, the event can be listened to
        * on either the trigger or the triggered. (This is only possible with the Fudge OIMO Fork!)
        */
        triggerEnter(contact) {
            let objHit; //collision consisting of 2 bodies, so Hit1/2
            let objHit2;
            let event; //The event that will be send and the informations added to it
            let colPoint;
            //ADD NEW Triggering - That just happened
            let collisionManifold = contact.getManifold(); //Manifold = Additional informations about the contact
            objHit = contact.getShape1().userData; //Userdata is used to transfer the ∆í.ComponentRigidbody, it's an empty OimoPhysics Variable
            //Only register the collision on the actual touch, not on "shadowCollide", to register in the moment of impulse calculation
            if (objHit == null || contact.isTouching() == false) // only act if the collision is actual touching, so right at the moment when a impulse is happening, not when shapes overlap
                return;
            objHit2 = contact.getShape2().userData;
            if (objHit2 == null || contact.isTouching() == false)
                return;
            let points = collisionManifold.getPoints(); //All points in the collision where the two bodies are touching, used to calculate the full impact
            let normal = collisionManifold.getNormal();
            if (objHit2.triggerings.indexOf(objHit) == -1) { //Fire, if the hit object is not the Body itself but another and it's not already fired.
                let colPos = objHit2.collisionCenterPoint(points, collisionManifold.getNumPoints()); //THE point of collision is the first touching point (EXTENSION: could be the center of all touching points combined)
                colPoint = new FudgeCore.Vector3(colPos.x, colPos.y, colPos.z);
                // Impulses are 0 since, there are no forces/impulses at work, else this would not be a trigger, but a collision
                objHit2.triggerings.push(objHit); //Tell the object that the event for this object does not need to be fired again
                event = new FudgeCore.EventPhysics("TriggerEnteredCollision" /* TRIGGER_ENTER */, objHit, 0, 0, 0, colPoint, new FudgeCore.Vector3(normal.x, normal.y, normal.z)); //Building the actual event, with what object did collide and informations about it
                objHit2.dispatchEvent(event); //Sending the given event
            }
            if (objHit.triggerings.indexOf(objHit2) == -1) { //Same as the above but for the case the SECOND hit object is not the body itself
                let colPos = objHit.collisionCenterPoint(points, collisionManifold.getNumPoints());
                colPoint = new FudgeCore.Vector3(colPos.x, colPos.y, colPos.z);
                // Impulses are 0 since, there are no forces/impulses at work, else this would not be a trigger, but a collision,
                // also the event is handled before the actual solving impulse step in OIMO
                objHit.triggerings.push(objHit2);
                event = new FudgeCore.EventPhysics("TriggerEnteredCollision" /* TRIGGER_ENTER */, objHit2, 0, 0, 0, colPoint, new FudgeCore.Vector3(normal.x, normal.y, normal.z));
                objHit.dispatchEvent(event);
            }
        }
        /**
        * Trigger LeavingEvent Callback, automatically called by OIMO Physics within their calculations.
        * Since the event does not know which body is the trigger iniator, the event can be listened to
        * on either the trigger or the triggered. (This is only possible with the Fudge OIMO Fork!)
        */
        triggerExit(contact) {
            //REMOVE OLD Triggering Body
            let objHit; //collision consisting of 2 bodies, so Hit1/2
            let objHit2;
            let event; //The event that will be send and the informations added to it
            objHit = contact.getShape1().userData;
            objHit2 = contact.getShape2().userData;
            // Remove both bodies in both cases, of self and other
            let index = objHit.triggerings.indexOf(objHit2); //Find object in the array
            if (index != -1) {
                objHit.triggerings.splice(index); //remove it from the array
                event = new FudgeCore.EventPhysics("TriggerLeftCollision" /* TRIGGER_EXIT */, objHit2, 0, 0, 0);
                objHit.dispatchEvent(event);
            }
            index = objHit2.triggerings.indexOf(objHit); //Find object in the array
            if (index != -1) {
                objHit2.triggerings.splice(index); //remove it from the array
                event = new FudgeCore.EventPhysics("TriggerLeftCollision" /* TRIGGER_EXIT */, objHit, 0, 0, 0);
                objHit2.dispatchEvent(event);
            }
        }
    }
    ComponentRigidbody.iSubclass = FudgeCore.Component.registerSubclass(ComponentRigidbody);
    ComponentRigidbody.mapBodyType = (typeof OIMO == "undefined") ?
        {
            [FudgeCore.BODY_TYPE.DYNAMIC]: 0, [FudgeCore.BODY_TYPE.STATIC]: 1, [FudgeCore.BODY_TYPE.KINEMATIC]: 2
        } : {
        [FudgeCore.BODY_TYPE.DYNAMIC]: OIMO.RigidBodyType.DYNAMIC, [FudgeCore.BODY_TYPE.STATIC]: OIMO.RigidBodyType.STATIC, [FudgeCore.BODY_TYPE.KINEMATIC]: OIMO.RigidBodyType.KINEMATIC
    };
    FudgeCore.ComponentRigidbody = ComponentRigidbody;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /** Internal class for holding data about physics debug vertices.*/
    class PhysicsDebugVertexBuffer {
        /** Setup the rendering context for this buffer and create the actual buffer for this context. */
        constructor(_renderingContext) {
            this.numVertices = 0;
            this.gl = _renderingContext;
            this.buffer = this.gl.createBuffer();
        }
        /** Fill the bound buffer with data. Used at buffer initialization */
        setData(array) {
            if (this.attribs == null)
                throw "set attributes first";
            this.numVertices = array.length / (this.stride / 4);
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
            this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(array), this.gl.DYNAMIC_DRAW);
            //not necessary an in webgl2 anymore to rebind the same last buffer (which is achieved by giving a null buffer), after buffer is changed. Removed it on all other occasions
            // this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null); 
        }
        /** Set Shader Attributes informations by getting their position in the shader, setting the offset, stride and size. For later use in the binding process */
        setAttribs(attribs) {
            this.attribs = attribs;
            this.offsets = [];
            this.stride = 0;
            let n = attribs.length;
            for (let i = 0; i < n; i++) {
                this.offsets.push(this.stride);
                this.stride += attribs[i].float32Count * Float32Array.BYTES_PER_ELEMENT; // 32bit float Bytes are a constant of 4
            }
        }
        /** Get the position of the attribute in the shader */
        loadAttribIndices(_program) {
            this.indices = _program.getAttribIndices(this.attribs);
        }
        /** Enable a attribute in a shader for this context, */
        bindAttribs() {
            if (this.indices == null)
                throw "indices are not loaded";
            let n = this.attribs.length;
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer); //making the buffer of this class the current buffer
            for (let i = 0; i < n; i++) {
                this.gl.enableVertexAttribArray(this.indices[i]); //enable the Attribute
                this.gl.vertexAttribPointer(this.indices[i], this.attribs[i].float32Count, this.gl.FLOAT, false, this.stride, this.offsets[i]); //creates a pointer and structure for this attribute
            }
        }
    }
    FudgeCore.PhysicsDebugVertexBuffer = PhysicsDebugVertexBuffer;
    /** Internal class for holding data about PhysicsDebugVertexBuffers */
    class PhysicsDebugIndexBuffer {
        /** Setup the rendering context for this buffer and create the actual buffer for this context. */
        constructor(_renderingContext) {
            this.gl = _renderingContext;
            this.buffer = this.gl.createBuffer();
        }
        /** Fill the bound buffer with data amount. Used at buffer initialization */
        setData(array) {
            this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.buffer);
            this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Int16Array(array), this.gl.DYNAMIC_DRAW);
            this.count = array.length;
        }
        /** The actual DrawCall for physicsDebugDraw Buffers. This is where the information from the debug is actually drawn. */
        draw(_mode = this.gl.TRIANGLES, _count = -1) {
            this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.buffer);
            this.gl.drawElements(_mode, _count >= 0 ? _count : this.count, this.gl.UNSIGNED_SHORT, 0);
        }
    }
    FudgeCore.PhysicsDebugIndexBuffer = PhysicsDebugIndexBuffer;
    /** Internal class for managing data about webGL Attributes */
    class PhysicsDebugVertexAttribute {
        constructor(_float32Count, _name) {
            this.name = _name;
            this.float32Count = _float32Count;
        }
    }
    FudgeCore.PhysicsDebugVertexAttribute = PhysicsDebugVertexAttribute;
    /** Internal class for Shaders used only by the physics debugDraw */
    class PhysicsDebugShader {
        /** Introduce the Fudge Rendering Context to this class, creating a program and vertex/fragment shader in this context */
        constructor(_renderingContext) {
            this.gl = _renderingContext;
            this.program = this.gl.createProgram();
            this.vertexShader = this.gl.createShader(this.gl.VERTEX_SHADER);
            this.fragmentShader = this.gl.createShader(this.gl.FRAGMENT_SHADER);
        }
        /** Take glsl shaders as strings and compile them, attaching the compiled shaders to a program thats used by this rendering context. */
        compile(vertexSource, fragmentSource) {
            this.uniformLocationMap = new Map();
            this.compileShader(this.vertexShader, vertexSource);
            this.compileShader(this.fragmentShader, fragmentSource);
            this.gl.attachShader(this.program, this.vertexShader);
            this.gl.attachShader(this.program, this.fragmentShader);
            this.gl.linkProgram(this.program);
            if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) { //make sure the linking worked, so the program is valid, and shaders are working
                FudgeCore.Debug.log(this.gl.getProgramInfoLog(this.program));
            }
            this.gl.validateProgram(this.program);
            if (!this.gl.getProgramParameter(this.program, this.gl.VALIDATE_STATUS)) {
                console.error("ERROR validating program!", this.gl.getProgramInfoLog(this.program));
                return;
            }
        }
        /** Get index of a attribute in a shader in this program */
        getAttribIndex(_name) {
            return this.gl.getAttribLocation(this.program, _name);
        }
        /** Get the location of a uniform in a shader in this program */
        getUniformLocation(_name) {
            if (this.uniformLocationMap.has(_name))
                return this.uniformLocationMap.get(_name);
            let location = this.gl.getUniformLocation(this.program, _name);
            this.uniformLocationMap.set(_name, location);
            return location;
        }
        /** Get all indices for every attribute in the shaders of this program */
        getAttribIndices(_attribs) {
            let indices = [];
            _attribs.forEach(value => {
                indices.push(this.getAttribIndex(value.name));
            });
            return indices;
        }
        /** Tell the Fudge Rendering Context to use this program to draw. */
        use() {
            this.gl.useProgram(this.program);
        }
        /** Compile a shader out of a string and validate it. */
        compileShader(shader, source) {
            this.gl.shaderSource(shader, source);
            this.gl.compileShader(shader);
            if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                FudgeCore.Debug.log(this.gl.getShaderInfoLog(shader));
            }
        }
    }
    FudgeCore.PhysicsDebugShader = PhysicsDebugShader;
    /** Internal Class used to draw debugInformations about the physics simulation onto the renderContext. No user interaction needed.
     * @author Marko Fehrenbach, HFU 2020 //Based on OimoPhysics Haxe DebugDrawDemo
     */
    class PhysicsDebugDraw extends FudgeCore.RenderWebGL {
        /** Creating the debug for physics in Fudge. Tell it to draw only wireframe objects, since Fudge is handling rendering of the objects besides physics.
         * Override OimoPhysics Functions with own rendering. Initialize buffers and connect them with the context for later use. */
        constructor() {
            super();
            this.style = new OIMO.DebugDrawStyle();
            this.oimoDebugDraw = new OIMO.DebugDraw();
            this.oimoDebugDraw.wireframe = true; //Triangle Rendering is handled by FUDGE so, only the physics lines/points need to be rendered, although triangle is still implemented
            this.gl = FudgeCore.RenderWebGL.crc3;
            this.initializeOverride();
            this.shader = new PhysicsDebugShader(this.gl);
            this.shader.compile(this.vertexShaderSource(), this.fragmentShaderSource());
            this.initializeBuffers();
        }
        /** Receive the current DebugMode from the physics settings and set the OimoPhysics.DebugDraw booleans to show only certain informations.
         * Needed since some debug informations exclude others, and can't be drawn at the same time, by OimoPhysics. And for users it provides more readability
         * to debug only what they need and is commonly debugged.
         */
        setDebugMode(_mode = FudgeCore.PHYSICS_DEBUGMODE.NONE) {
            // tslint:disable-next-line
            let draw = { drawAabbs: false, drawBases: false, drawBvh: false, drawContactBases: false, drawContacts: false, drawJointLimits: false, drawJoints: false, drawPairs: false, drawShapes: false };
            switch (_mode) {
                case FudgeCore.PHYSICS_DEBUGMODE.COLLIDERS: //Colliders and Bases
                    draw.drawBases = draw.drawShapes = true;
                    break;
                case FudgeCore.PHYSICS_DEBUGMODE.JOINTS_AND_COLLIDER: //Colliders and joints
                    draw.drawJoints = draw.drawJointLimits = draw.drawShapes = true;
                    break;
                case FudgeCore.PHYSICS_DEBUGMODE.PHYSIC_OBJECTS_ONLY: //Physics Objects only, shows same as Collider / Joints but also hiding every other fudge object
                    draw.drawBases = draw.drawJointLimits = draw.drawJoints = draw.drawShapes = true;
                    break;
                case FudgeCore.PHYSICS_DEBUGMODE.CONTACTS: //Contacts
                    draw.drawBases = draw.drawContactBases = draw.drawContacts = draw.drawPairs = draw.drawShapes = true;
                    break;
                case FudgeCore.PHYSICS_DEBUGMODE.BOUNDING_BOXES: //Bounding Box / Broadphase Bvh / Bases
                    draw.drawAabbs = draw.drawBases = draw.drawBvh = true;
                    break;
            }
            Object.assign(this.oimoDebugDraw, draw);
        }
        /** Creating the empty render buffers. Defining the attributes used in shaders.
         * Needs to create empty buffers to already have them ready to draw later on, linking is only possible with existing buffers. */
        initializeBuffers() {
            let attribs = [
                new PhysicsDebugVertexAttribute(3, "aPosition"),
                new PhysicsDebugVertexAttribute(3, "aNormal"),
                new PhysicsDebugVertexAttribute(3, "aColor")
            ];
            this.pointVBO = new PhysicsDebugVertexBuffer(this.gl);
            this.pointIBO = new PhysicsDebugIndexBuffer(this.gl);
            this.pointVBO.setAttribs(attribs);
            this.pointVBO.loadAttribIndices(this.shader);
            this.lineVBO = new PhysicsDebugVertexBuffer(this.gl);
            this.lineIBO = new PhysicsDebugIndexBuffer(this.gl);
            this.lineVBO.setAttribs(attribs);
            this.lineVBO.loadAttribIndices(this.shader);
            this.triVBO = new PhysicsDebugVertexBuffer(this.gl);
            this.triIBO = new PhysicsDebugIndexBuffer(this.gl);
            this.triVBO.setAttribs(attribs);
            this.triVBO.loadAttribIndices(this.shader);
            this.clearBuffers();
        }
        /** Before OimoPhysics.world is filling the debug. Make sure the buffers are reset. Also receiving the debugMode from settings and updating the current projection for the vertexShader. */
        clearBuffers() {
            this.gl.lineWidth(2.0); //Does not affect anything because lineWidth is currently only supported by Microsoft Edge and Fudge is optimized for Chrome
            this.pointData = []; //Resetting the data to be filled again
            this.lineData = [];
            this.triData = [];
            this.numPointData = 0; //Resetting the amount of data calls
            this.numLineData = 0;
            this.numTriData = 0;
        }
        /** After OimoPhysics.world filled the debug. Rendering calls. Setting this program to be used by the Fudge rendering context. And draw each updated buffer and resetting them. */
        drawBuffers() {
            this.shader.use();
            let projection = FudgeCore.Physics.mainCam.mtxWorldToView.get();
            this.gl.uniformMatrix4fv(this.shader.getUniformLocation("u_mtxMeshToView"), false, projection);
            if (this.numPointData > 0) {
                this.pointIboData = []; //Buffer size matching to whats needed
                for (let i = 0; i < this.numPointData; i++) {
                    this.pointIboData.push(i);
                }
                this.pointIBO.setData(this.pointIboData); //Set Index buffer to correct size
                this.pointVBO.setData(this.pointData); //Set Vertex Buffer to current Data
                this.pointVBO.bindAttribs();
                this.pointIBO.draw(this.gl.POINTS, this.numPointData); //The actual draw call for each index in ibo
                this.numPointData = 0;
            }
            if (this.numLineData > 0) {
                this.lineIboData = [];
                for (let i = 0; i < this.numLineData; i++) {
                    this.lineIboData.push(i * 2);
                    this.lineIboData.push(i * 2 + 1);
                }
                this.lineIBO.setData(this.lineIboData);
                this.lineVBO.setData(this.lineData);
                this.lineVBO.bindAttribs();
                this.lineIBO.draw(this.gl.LINES, this.numLineData * 2);
                this.numLineData = 0;
            }
            if (this.numTriData > 0) {
                this.triIboData = [];
                for (let i = 0; i < this.numTriData; i++) {
                    this.triIboData.push(i * 3);
                    this.triIboData.push(i * 3 + 1);
                    this.triIboData.push(i * 3 + 2);
                }
                this.triIBO.setData(this.triIboData);
                this.triVBO.setData(this.triData);
                this.triVBO.bindAttribs();
                this.triIBO.draw(this.gl.TRIANGLES, this.numTriData * 3);
                this.numTriData = 0;
            }
        }
        /** Drawing the ray into the debugDraw Call. By using the overwritten line rendering functions and drawing a point (pointSize defined in the shader) at the end of the ray. */
        debugRay(_origin, _end, _color) {
            this.oimoDebugDraw.line(new OIMO.Vec3(_origin.x, _origin.y, _origin.z), new OIMO.Vec3(_end.x, _end.y, _end.z), new OIMO.Vec3(_color.r, _color.g, _color.b));
            this.oimoDebugDraw.point(new OIMO.Vec3(_end.x, _end.y, _end.z), new OIMO.Vec3(_color.r, _color.g, _color.b));
        }
        /** Overriding the existing functions from OimoPhysics.DebugDraw without actually inherit from the class, to avoid compiler problems.
         * Overriding them to receive debugInformations in the format the physic engine provides them but handling the rendering in the fudge context. */
        initializeOverride() {
            //Override point/line/triangle functions of OimoPhysics which are used to draw wireframes of objects, lines of raycasts or triangles when the objects are rendered by the physics not FUDGE (unused)
            OIMO.DebugDraw.prototype.point = function (_v, _color) {
                let debugWrapper = FudgeCore.Physics.debugDraw; //Get the custom physics debug class to have access to the data.
                if (FudgeCore.Physics.mainCam != null) { //only act when there is a camera that is rendering
                    let data = debugWrapper.pointData; //get the already written buffer informations
                    data.push(_v.x, _v.y, _v.z); //Coordinates of the point
                    data.push(0, 0, 0); //Point Normals - Empty since it's not a polygon
                    data.push(_color.x, _color.y, _color.z); //Color of the point
                    debugWrapper.numPointData++;
                }
            };
            OIMO.DebugDraw.prototype.line = function (_v1, _v2, _color) {
                let debugWrapper = FudgeCore.Physics.debugDraw;
                if (FudgeCore.Physics.mainCam != null) {
                    let data = debugWrapper.lineData;
                    data.push(_v1.x, _v1.y, _v1.z); //Point 1 Coordinates
                    data.push(0, 0, 0); //P1 Normals - Empty since it's not a polygon
                    data.push(_color.x, _color.y, _color.z); //P1 Color
                    data.push(_v2.x, _v2.y, _v2.z); //Point 2 Coordinates
                    data.push(0, 0, 0);
                    data.push(_color.x, _color.y, _color.z);
                    debugWrapper.numLineData++;
                }
            };
            OIMO.DebugDraw.prototype.triangle = function (_v1, _v2, _v3, _n1, _n2, _n3, _color) {
                let debugWrapper = FudgeCore.Physics.debugDraw;
                if (FudgeCore.Physics.mainCam != null) {
                    let data = debugWrapper.triData;
                    data.push(_v1.x, _v1.y, _v1.z);
                    data.push(_n1.x, _n1.y, _n1.z);
                    data.push(_color.x, _color.y, _color.z);
                    data.push(_v2.x, _v2.y, _v2.z);
                    data.push(_n2.x, _n2.y, _n2.z);
                    data.push(_color.x, _color.y, _color.z);
                    data.push(_v3.x, _v3.y, _v3.z);
                    data.push(_n3.x, _n3.y, _n3.z);
                    data.push(_color.x, _color.y, _color.z);
                    debugWrapper.numTriData++;
                }
            };
        }
        /** The source code (string) of the in physicsDebug used very simple vertexShader.
         *  Handling the projection (which includes, view/world[is always identity in this case]/projection in Fudge). Increasing the size of single points drawn.
         *  And transfer position color to the fragmentShader. */
        vertexShaderSource() {
            return `
			precision mediump float;
			attribute vec3 aPosition;
			attribute vec3 aColor;
			attribute vec3 aNormal;
			varying vec3 vPosition;
			varying vec3 vNormal;
			varying vec3 vColor;
			uniform mat4 u_mtxMeshToView;

			void main() {
				vPosition = aPosition;
				vColor = aColor;
				vNormal = aNormal;
				gl_Position = u_mtxMeshToView * vec4(aPosition,1.0);
				gl_PointSize = 6.0;
			}`;
        }
        /** The source code (string) of the in physicsDebug used super simple fragmentShader. Unlit - only colorizing the drawn pixels, normals/position are given to make it expandable */
        fragmentShaderSource() {
            return `
      precision mediump float;
			varying vec3 vPosition;
			varying vec3 vNormal;
			varying vec3 vColor;

			void main() {
				gl_FragColor = vec4(vColor, 1.0);
			}`;
        }
    }
    FudgeCore.PhysicsDebugDraw = PhysicsDebugDraw;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A physical connection between two bodies with a defined axe of translation and rotation. Two Degrees of Freedom in the defined axis.
     * Two RigidBodies need to be defined to use it. A motor can be defined for rotation and translation, along with spring settings.
     *
     * ```plaintext
     *          JointHolder - bodyAnchor
     *                    ‚îå‚îÄ‚îÄ‚îÄ‚îê
     *                    ‚îÇ   ‚îÇ
     *           <‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> tied body, sliding on axis = 1st degree of freedom
     *                    ‚îÇ   ‚îÇ        rotating around axis = 2nd degree of freedom
     *                    ‚îî‚îÄ‚îÄ‚îÄ‚îò
     * ```
     * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
     */
    class JointCylindrical extends FudgeCore.JointAxial {
        /** Creating a cylindrical joint between two ComponentRigidbodies moving on one axis and rotating around another bound on a local anchorpoint. */
        constructor(_bodyAnchor = null, _bodyTied = null, _axis = new FudgeCore.Vector3(0, 1, 0), _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied, _axis, _localAnchor);
            this.#springDampingRotation = 0;
            this.#springFrequencyRotation = 0;
            this.#motorForce = 0;
            this.#maxRotor = 360;
            this.#minRotor = 0;
            this.#rotorTorque = 0;
            this.#rotorSpeed = 0;
            this.config = new OIMO.CylindricalJointConfig();
            this.#getMutator = () => {
                let mutator = {
                    motorForce: this.motorForce,
                    springDampingRotation: this.springDampingRotation,
                    springFrequencyRotation: this.springFrequencyRotation,
                    maxRotor: this.maxRotor,
                    minRotor: this.minRotor,
                    rotorTorque: this.rotorTorque,
                    rotorSpeed: this.rotorSpeed
                };
                return mutator;
            };
            this.#mutate = (_mutator) => {
                this.motorForce = _mutator.motorForce;
                this.rotorTorque = _mutator.rotorTorque;
                this.rotorSpeed = _mutator.rotorSpeed;
                this.maxRotor = _mutator.maxRotor;
                this.minRotor = _mutator.minRotor;
                this.springDampingRotation = _mutator.springDampingRotation;
                this.springFrequencyRotation = _mutator.springFrequencyRotation;
                this.springFrequency = _mutator.springFrequency;
            };
        }
        #springDampingRotation;
        #springFrequencyRotation;
        #motorForce;
        #maxRotor;
        #minRotor;
        #rotorTorque;
        #rotorSpeed;
        #rotor;
        #rotorSpringDamper;
        //#region Get/Set transfor of fudge properties to the physics engine
        /**
         * The damping of the spring. 1 equals completly damped.
         */
        set springDamping(_value) {
            super.springDamping = _value;
            if (this.joint != null)
                this.joint.getTranslationalSpringDamper().dampingRatio = _value;
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. The smaller the value the less restrictive is the spring.
        */
        set springFrequency(_value) {
            super.springFrequency = _value;
            if (this.joint != null)
                this.joint.getTranslationalSpringDamper().frequency = _value;
        }
        /**
        * The damping of the spring. 1 equals completly damped. Influencing TORQUE / ROTATION
        */
        get springDampingRotation() {
            return this.#springDampingRotation;
        }
        set springDampingRotation(_value) {
            this.#springDampingRotation = _value;
            if (this.joint != null)
                this.joint.getRotationalSpringDamper().dampingRatio = _value;
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. Influencing TORQUE / ROTATION
        */
        get springFrequencyRotation() {
            return this.#springFrequencyRotation;
        }
        set springFrequencyRotation(_value) {
            this.#springFrequencyRotation = _value;
            if (this.joint != null)
                this.joint.getRotationalSpringDamper().frequency = _value;
        }
        /**
          * The Upper Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis-Angle measured in Degree.
         */
        get maxRotor() {
            return this.#maxRotor;
        }
        set maxRotor(_value) {
            this.#maxRotor = _value;
            if (this.joint != null)
                this.joint.getRotationalLimitMotor().upperLimit = _value * Math.PI / 180;
        }
        /**
          * The Lower Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis Angle measured in Degree.
         */
        get minRotor() {
            return this.#minRotor;
        }
        set minRotor(_value) {
            this.#minRotor = _value;
            if (this.joint != null)
                this.joint.getRotationalLimitMotor().lowerLimit = _value * Math.PI / 180;
        }
        /**
          * The target rotational speed of the motor in m/s.
         */
        get rotorSpeed() {
            return this.#rotorSpeed;
        }
        set rotorSpeed(_value) {
            this.#rotorSpeed = _value;
            if (this.joint != null)
                this.joint.getRotationalLimitMotor().motorSpeed = _value;
        }
        /**
          * The maximum motor torque in Newton. force <= 0 equals disabled.
         */
        get rotorTorque() {
            return this.#rotorTorque;
        }
        set rotorTorque(_value) {
            this.#rotorTorque = _value;
            if (this.joint != null)
                this.joint.getRotationalLimitMotor().motorTorque = _value;
        }
        /**
          * The Upper Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit.
         */
        set maxMotor(_value) {
            super.maxMotor = _value;
            if (this.joint != null)
                this.joint.getTranslationalLimitMotor().upperLimit = _value;
        }
        /**
          * The Lower Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit.
         */
        set minMotor(_value) {
            super.minMotor = _value;
            if (this.joint != null)
                this.joint.getTranslationalLimitMotor().lowerLimit = _value;
        }
        set motorSpeed(_value) {
            super.motorSpeed = _value;
            if (this.joint != null)
                this.joint.getTranslationalLimitMotor().motorSpeed = _value;
        }
        /**
          * The maximum motor force in Newton. force <= 0 equals disabled.
         */
        get motorForce() {
            return this.#motorForce;
        }
        set motorForce(_value) {
            this.#motorForce = _value;
            if (this.joint != null)
                this.joint.getTranslationalLimitMotor().motorForce = _value;
        }
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = this.#getMutator();
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            this.#mutate(_serialization);
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        async mutate(_mutator) {
            this.#mutate(_mutator);
            this.deleteFromMutator(_mutator, this.#getMutator());
            super.mutate(_mutator);
        }
        getMutator() {
            let mutator = super.getMutator();
            Object.assign(mutator, this.#getMutator());
            return mutator;
        }
        #getMutator;
        #mutate;
        //#endregion
        constructJoint() {
            this.#rotorSpringDamper = new OIMO.SpringDamper().setSpring(this.springFrequencyRotation, this.springDampingRotation);
            this.motor = new OIMO.TranslationalLimitMotor().setLimits(super.minMotor, super.maxMotor);
            this.motor.setMotor(super.motorSpeed, this.motorForce);
            this.#rotor = new OIMO.RotationalLimitMotor().setLimits(this.minRotor * Math.PI / 180, this.maxRotor * Math.PI / 180);
            this.#rotor.setMotor(this.rotorSpeed, this.rotorTorque);
            this.config = new OIMO.CylindricalJointConfig();
            super.constructJoint();
            this.config.translationalSpringDamper = this.springDamper;
            this.config.translationalLimitMotor = this.motor;
            this.config.rotationalLimitMotor = this.#rotor;
            this.config.rotationalSpringDamper = this.#rotorSpringDamper;
            this.joint = new OIMO.CylindricalJoint(this.config);
            this.configureJoint();
        }
    }
    JointCylindrical.iSubclass = FudgeCore.Joint.registerSubclass(JointCylindrical);
    FudgeCore.JointCylindrical = JointCylindrical;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
       * A physical connection between two bodies with a defined axe movement.
       * Used to create a sliding joint along one axis. Two RigidBodies need to be defined to use it.
       * A motor can be defined to move the connected along the defined axis. Great to construct standard springs or physical sliders.
       *
       * ```plaintext
       *          JointHolder - bodyAnchor
       *                    ‚îå‚îÄ‚îÄ‚îÄ‚îê
       *                    ‚îÇ   ‚îÇ
       *           <‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> tied body, sliding on one Axis, 1 Degree of Freedom
       *                    ‚îÇ   ‚îÇ
       *                    ‚îî‚îÄ‚îÄ‚îÄ‚îò
       * ```
       * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
       */
    class JointPrismatic extends FudgeCore.JointAxial {
        //Internally used variables - Joint Properties that are used even when no actual joint is currently existend
        /** Creating a prismatic joint between two ComponentRigidbodies only moving on one axis bound on a local anchorpoint. */
        constructor(_bodyAnchor = null, _bodyTied = null, _axis = new FudgeCore.Vector3(0, 1, 0), _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied, _axis, _localAnchor);
            this.#motorForce = 0;
            this.config = new OIMO.PrismaticJointConfig();
            this.maxMotor = 10;
            this.minMotor = -10;
        }
        #motorForce;
        //#region Get/Set transfor of fudge properties to the physics engine
        /**
          * The maximum motor force in Newton. force <= 0 equals disabled. This is the force that the motor is using to hold the position, or reach it if a motorSpeed is defined.
         */
        get motorForce() {
            return this.#motorForce;
        }
        set motorForce(_value) {
            this.#motorForce = _value;
            if (this.joint != null)
                this.joint.getLimitMotor().motorForce = _value;
        }
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = {
                motorForce: this.motorForce,
                [super.constructor.name]: super.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            this.motorForce = _serialization.motorForce;
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        getMutator() {
            let mutator = super.getMutator();
            mutator.motorForce = this.motorForce;
            return mutator;
        }
        async mutate(_mutator) {
            this.motorForce = _mutator.motorForce;
            delete _mutator.motorForce;
            super.mutate(_mutator);
        }
        //#endregion
        /** Actual creation of a joint in the OimoPhysics system */
        constructJoint() {
            this.motor = new OIMO.TranslationalLimitMotor().setLimits(this.minMotor, this.maxMotor); //Create motor settings, to hold positions, set constraint min/max
            this.motor.setMotor(this.motorSpeed, this.motorForce);
            this.config = new OIMO.PrismaticJointConfig(); //Create a specific config for this joint type that is calculating the local axis for both bodies
            super.constructJoint();
            this.config.springDamper = this.springDamper; //Telling the config to use the motor/spring of the Fudge Component
            this.config.limitMotor = this.motor;
            this.joint = new OIMO.PrismaticJoint(this.config);
            this.configureJoint();
        }
    }
    JointPrismatic.iSubclass = FudgeCore.Joint.registerSubclass(JointPrismatic);
    FudgeCore.JointPrismatic = JointPrismatic;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
      * A physical connection between two bodies, designed to simulate behaviour within a real body. It has two axis, a swing and twist axis, and also the perpendicular axis,
      * similar to a Spherical joint, but more restrictive in it's angles and only two degrees of freedom. Two RigidBodies need to be defined to use it. Mostly used to create humanlike joints that behave like a
      * lifeless body.
      * ```plaintext
      *
      *                      anchor - it can twist on one axis and swing on another
      *                            ‚îÇ
      *         z            ‚îå‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îê
      *         ‚Üë            ‚îÇ   ‚îÇ ‚Üì ‚îÇ   ‚îÇ        e.g. z = TwistAxis, it can rotate in-itself around this axis
      *    -x ‚Üê‚îÄ‚îº‚îÄ‚Üí x        ‚îÇ   ‚îÇ x ‚îÇ   ‚îÇ        e.g. x = SwingAxis, it can rotate anchored around the base on this axis
      *         ‚Üì            ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ
      *        -z            ‚îî‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îò         e.g. you can twist the leg in-itself to a certain degree,
      *                                                     but also rotate it forward/backward/left/right to a certain degree
      *                bodyAnchor          bodyTied
      *              (e.g. pelvis)         (e.g. upper-leg)
      *
      * ```
      * Twist equals a rotation around a point without moving on an axis.
      * Swing equals a rotation on a point with a moving local axis.
       * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
      */
    class JointRagdoll extends FudgeCore.Joint {
        constructor(_bodyAnchor = null, _bodyTied = null, _axisFirst = new FudgeCore.Vector3(1, 0, 0), _axisSecond = new FudgeCore.Vector3(0, 0, 1), _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied);
            this.#springDampingTwist = 0;
            this.#springFrequencyTwist = 0;
            this.#springDampingSwing = 0;
            this.#springFrequencySwing = 0;
            this.#maxMotorTwist = 360;
            this.#minMotorTwist = 0;
            this.#motorTorqueTwist = 0;
            this.#motorSpeedTwist = 0;
            this.#maxAngleFirst = 0;
            this.#maxAngleSecond = 0;
            this.config = new OIMO.RagdollJointConfig();
            this.#getMutator = () => {
                let mutator = {
                    maxAngleFirst: this.#maxAngleFirst,
                    maxAngleSecond: this.#maxAngleSecond,
                    springDampingTwist: this.springDampingTwist,
                    springFrequencyTwist: this.springFrequencyTwist,
                    springDampingSwing: this.springDampingSwing,
                    springFrequencySwing: this.springFrequencySwing,
                    maxMotorTwist: this.#maxMotorTwist,
                    minMotorTwist: this.#minMotorTwist,
                    motorSpeedTwist: this.motorSpeedTwist,
                    motorTorqueTwist: this.motorTorqueTwist
                };
                return mutator;
            };
            this.#mutate = (_mutator) => {
                this.#maxAngleFirst = _mutator.maxAngleFirst;
                this.#maxAngleSecond = _mutator.maxAngleSecond;
                this.springDampingTwist = _mutator.springDampingTwist;
                this.springFrequencyTwist = _mutator.springFrequencyTwist;
                this.springDampingSwing = _mutator.springDampingSwing;
                this.springFrequencySwing = _mutator.springFrequencySwing;
                this.maxMotorTwist = _mutator.maxMotorTwist;
                this.minMotorTwist = _mutator.minMotorTwist;
                this.motorSpeedTwist = _mutator.motorSpeedTwist;
                this.motorTorqueTwist = _mutator.motorTorqueTwist;
            };
            this.axisFirst = _axisFirst;
            this.axisSecond = _axisSecond;
            this.anchor = _localAnchor;
        }
        #springDampingTwist;
        #springFrequencyTwist;
        #springDampingSwing;
        #springFrequencySwing;
        #maxMotorTwist;
        #minMotorTwist;
        #motorTorqueTwist;
        #motorSpeedTwist;
        #motorTwist;
        #springDamperTwist;
        #springDamperSwing;
        #axisFirst;
        #axisSecond;
        #maxAngleFirst;
        #maxAngleSecond;
        //#region Get/Set transfor of fudge properties to the physics engine
        /**
         * The axis connecting the the two {@link Node}s e.g. Vector3(0,1,0) to have a upward connection.
         *  When changed after initialization the joint needs to be reconnected.
         */
        get axisFirst() {
            return new FudgeCore.Vector3(this.#axisFirst.x, this.#axisFirst.y, this.#axisFirst.z);
        }
        set axisFirst(_value) {
            this.#axisFirst = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.disconnect();
            this.dirtyStatus();
        }
        /**
        * The axis connecting the the two {@link Node}s e.g. Vector3(0,1,0) to have a upward connection.
        *  When changed after initialization the joint needs to be reconnected.
        */
        get axisSecond() {
            return new FudgeCore.Vector3(this.#axisSecond.x, this.#axisSecond.y, this.#axisSecond.z);
        }
        set axisSecond(_value) {
            this.#axisSecond = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.disconnect();
            this.dirtyStatus();
        }
        /**
         * The maximum angle of rotation along the first axis. Value needs to be positive. Changes do rebuild the joint
         */
        get maxAngleFirstAxis() {
            return this.#maxAngleFirst * 180 / Math.PI;
        }
        set maxAngleFirstAxis(_value) {
            this.#maxAngleFirst = _value * Math.PI / 180;
            this.disconnect();
            this.dirtyStatus();
        }
        /**
         * The maximum angle of rotation along the second axis. Value needs to be positive. Changes do rebuild the joint
         */
        get maxAngleSecondAxis() {
            return this.#maxAngleSecond * 180 / Math.PI;
        }
        set maxAngleSecondAxis(_value) {
            this.#maxAngleSecond = _value * Math.PI / 180;
            this.disconnect();
            this.dirtyStatus();
        }
        /**
         * The damping of the spring. 1 equals completly damped.
         */
        get springDampingTwist() {
            return this.#springDampingTwist;
        }
        set springDampingTwist(_value) {
            this.#springDampingTwist = _value;
            if (this.joint != null)
                this.joint.getTwistSpringDamper().dampingRatio = _value;
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. The smaller the value the less restrictive is the spring.
        */
        get springFrequencyTwist() {
            return this.#springFrequencyTwist;
        }
        set springFrequencyTwist(_value) {
            this.#springFrequencyTwist = _value;
            if (this.joint != null)
                this.joint.getTwistSpringDamper().frequency = _value;
        }
        /**
         * The damping of the spring. 1 equals completly damped.
         */
        get springDampingSwing() {
            return this.#springDampingSwing;
        }
        set springDampingSwing(_value) {
            this.#springDampingSwing = _value;
            if (this.joint != null)
                this.joint.getSwingSpringDamper().dampingRatio = _value;
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. The smaller the value the less restrictive is the spring.
        */
        get springFrequencySwing() {
            return this.#springFrequencySwing;
        }
        set springFrequencySwing(_value) {
            this.#springFrequencySwing = _value;
            if (this.joint != null)
                this.joint.getSwingSpringDamper().frequency = _value;
        }
        /**
          * The Upper Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis-Angle measured in Degree.
         */
        get maxMotorTwist() {
            return this.#maxMotorTwist * 180 / Math.PI;
        }
        set maxMotorTwist(_value) {
            _value *= Math.PI / 180;
            this.#maxMotorTwist = _value;
            if (this.joint != null)
                this.joint.getTwistLimitMotor().upperLimit = _value;
        }
        /**
         * The Lower Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis Angle measured in Degree.
         */
        get minMotorTwist() {
            return this.#minMotorTwist * 180 / Math.PI;
        }
        set minMotorTwist(_value) {
            _value *= Math.PI / 180;
            this.#minMotorTwist = _value;
            if (this.joint != null)
                this.joint.getTwistLimitMotor().lowerLimit = _value;
        }
        /**
          * The target rotational speed of the motor in m/s.
         */
        get motorSpeedTwist() {
            return this.#motorSpeedTwist;
        }
        set motorSpeedTwist(_value) {
            this.#motorSpeedTwist = _value;
            if (this.joint != null)
                this.joint.getTwistLimitMotor().motorSpeed = _value;
        }
        /**
          * The maximum motor torque in Newton. force <= 0 equals disabled.
         */
        get motorTorqueTwist() {
            return this.#motorTorqueTwist;
        }
        set motorTorqueTwist(_value) {
            this.#motorTorqueTwist = _value;
            if (this.joint != null)
                this.joint.getTwistLimitMotor().motorTorque = _value;
        }
        /**
          * If the two connected RigidBodies collide with eath other. (Default = false)
         */
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = this.#getMutator();
            serialization.axisFirst = this.axisFirst.serialize();
            serialization.axisSecond = this.axisSecond.serialize();
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            await this.axisFirst.deserialize(_serialization.axisFirst);
            await this.axisSecond.deserialize(_serialization.axisSecond);
            this.#mutate(_serialization);
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        async mutate(_mutator) {
            this.axisFirst = new FudgeCore.Vector3(...(Object.values(_mutator.axisFirst)));
            this.axisSecond = new FudgeCore.Vector3(...(Object.values(_mutator.axisSecond)));
            delete _mutator.axisFirst;
            delete _mutator.axisSecond;
            this.#mutate(_mutator);
            this.deleteFromMutator(_mutator, this.#getMutator());
            super.mutate(_mutator);
        }
        getMutator() {
            let mutator = super.getMutator();
            Object.assign(mutator, this.#getMutator());
            mutator.axisFirst = this.axisFirst.getMutator();
            mutator.axisSecond = this.axisSecond.getMutator();
            return mutator;
        }
        #getMutator;
        #mutate;
        //#endregion
        constructJoint() {
            this.#springDamperTwist = new OIMO.SpringDamper().setSpring(this.springFrequencyTwist, this.springDampingTwist);
            this.#springDamperSwing = new OIMO.SpringDamper().setSpring(this.springFrequencySwing, this.springDampingSwing);
            this.#motorTwist = new OIMO.RotationalLimitMotor().setLimits(this.minMotorTwist, this.maxMotorTwist);
            this.#motorTwist.setMotor(this.motorSpeedTwist, this.motorTorqueTwist);
            this.config = new OIMO.RagdollJointConfig();
            super.constructJoint(this.axisFirst, this.axisSecond);
            this.config.swingSpringDamper = this.#springDamperSwing;
            this.config.twistSpringDamper = this.#springDamperTwist;
            this.config.twistLimitMotor = this.#motorTwist;
            this.config.maxSwingAngle1 = this.#maxAngleFirst;
            this.config.maxSwingAngle2 = this.#maxAngleSecond;
            this.joint = new OIMO.RagdollJoint(this.config);
            super.configureJoint();
        }
    }
    JointRagdoll.iSubclass = FudgeCore.Joint.registerSubclass(JointRagdoll);
    FudgeCore.JointRagdoll = JointRagdoll;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
       * A physical connection between two bodies with a defined axe of rotation. Also known as HINGE joint.
       * Two RigidBodies need to be defined to use it. A motor can be defined to rotate the connected along the defined axis.
       *
       * ```plaintext
       *                  rotation axis, 1st Degree of freedom
       *                    ‚Üë
       *               ‚îå‚îÄ‚îÄ‚îÄ‚îê‚îÇ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê
       *               ‚îÇ   ‚îÇ‚îÇ‚îÇ    ‚îÇ
       *               ‚îÇ   ‚îÇ‚îÇ‚îÇ    ‚îÇ
       *               ‚îÇ   ‚îÇ‚îÇ‚îÇ    ‚îÇ
       *               ‚îî‚îÄ‚îÄ‚îÄ‚îò‚îÇ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       *                    ‚îÇ
       *      bodyAnchor         bodyTied
       *   (e.g. Doorhinge)       (e.g. Door)
       * ```
       * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
       */
    class JointRevolute extends FudgeCore.JointAxial {
        constructor(_bodyAnchor = null, _bodyTied = null, _axis = new FudgeCore.Vector3(0, 1, 0), _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied, _axis, _localAnchor);
            this.#motorTorque = 0;
            this.config = new OIMO.RevoluteJointConfig();
            this.maxMotor = 360;
            this.minMotor = 0;
        }
        #motorTorque;
        #rotor;
        /**
          * The Upper Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis-Angle measured in Degree.
         */
        set maxMotor(_value) {
            super.maxMotor = _value;
            _value *= Math.PI / 180;
            if (this.joint)
                this.joint.getLimitMotor().upperLimit = _value;
        }
        /**
          * The Lower Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis Angle measured in Degree.
         */
        set minMotor(_value) {
            super.minMotor = _value;
            if (this.joint)
                this.joint.getLimitMotor().lowerLimit = _value * Math.PI / 180;
        }
        /**
          * The maximum motor force in Newton. force <= 0 equals disabled.
         */
        get motorTorque() {
            return this.#motorTorque;
        }
        set motorTorque(_value) {
            this.#motorTorque = _value;
            if (this.joint != null)
                this.joint.getLimitMotor().motorTorque = _value;
        }
        /**
          * If the two connected RigidBodies collide with eath other. (Default = false)
         */
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = {
                motorTorque: this.motorTorque,
                [super.constructor.name]: super.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            this.motorTorque = _serialization.motorTorque;
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        getMutator() {
            let mutator = super.getMutator();
            mutator.motorTorque = this.motorTorque;
            return mutator;
        }
        async mutate(_mutator) {
            this.motorTorque = _mutator.motorTorque;
            delete _mutator.motorTorque;
            super.mutate(_mutator);
        }
        //#endregion
        constructJoint() {
            this.#rotor = new OIMO.RotationalLimitMotor().setLimits(super.minMotor * Math.PI / 180, super.maxMotor * Math.PI / 180);
            this.#rotor.setMotor(this.motorSpeed, this.motorTorque);
            this.config = new OIMO.RevoluteJointConfig();
            super.constructJoint();
            this.config.springDamper = this.springDamper;
            this.config.limitMotor = this.#rotor;
            this.joint = new OIMO.RevoluteJoint(this.config);
            this.configureJoint();
        }
    }
    JointRevolute.iSubclass = FudgeCore.Joint.registerSubclass(JointRevolute);
    FudgeCore.JointRevolute = JointRevolute;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
       * A physical connection between two bodies with three Degrees of Freedom, also known as ball and socket joint. Two bodies connected at their anchor but free to rotate.
       * Used for things like the connection of bones in the human shoulder (if simplified, else better use JointRagdoll). Two RigidBodies need to be defined to use it. Only spring settings can be defined.
       * 3 Degrees are swing horizontal, swing vertical and twist.
       *
       * ```plaintext
       *              JointHolder
       *         z      bodyAnchor (e.g. Human-Shoulder)
       *      y  ‚Üë
       *        \|          ‚îÄ‚îÄ‚îÄ(‚óè‚îÄ‚îÄ‚îÄ
       *  -x <---|---> x           bodyTied
       *         |\                (e.g. Upper-Arm)
       *         ‚Üì -y
       *        -z
       * ```
       * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
       */
    class JointSpherical extends FudgeCore.Joint {
        constructor(_bodyAnchor = null, _bodyTied = null, _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied);
            this.#springDamping = 0;
            this.#springFrequency = 0;
            this.config = new OIMO.SphericalJointConfig();
            this.anchor = new FudgeCore.Vector3(_localAnchor.x, _localAnchor.y, _localAnchor.z);
        }
        #springDamping;
        #springFrequency;
        #springDamper;
        //#region Get/Set transfor of fudge properties to the physics engine
        /**
         * The damping of the spring. 1 equals completly damped.
         */
        get springDamping() {
            return this.#springDamping;
        }
        set springDamping(_value) {
            this.#springDamping = _value;
            if (this.joint != null)
                this.joint.getSpringDamper().dampingRatio = _value;
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. The smaller the value the less restrictive is the spring.
        */
        get springFrequency() {
            return this.#springFrequency;
        }
        set springFrequency(_value) {
            this.#springFrequency = _value;
            if (this.joint != null)
                this.joint.getSpringDamper().frequency = _value;
        }
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = {
                springDamping: this.springDamping,
                springFrequency: this.springFrequency,
                [super.constructor.name]: super.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            this.springDamping = _serialization.springDamping;
            this.springFrequency = _serialization.springFrequency;
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        getMutator() {
            let mutator = super.getMutator();
            mutator.springDamping = this.springDamping;
            mutator.springFrequency = this.springFrequency;
            return mutator;
        }
        async mutate(_mutator) {
            this.springDamping = _mutator.springDamping;
            this.springFrequency = _mutator.springFrequency;
            delete _mutator.springDamping;
            delete _mutator.springFrequency;
            super.mutate(_mutator);
        }
        //#endregion
        constructJoint() {
            this.#springDamper = new OIMO.SpringDamper().setSpring(this.springFrequency, this.springDamping);
            this.config = new OIMO.SphericalJointConfig();
            super.constructJoint();
            this.config.springDamper = this.#springDamper;
            this.joint = new OIMO.SphericalJoint(this.config);
            super.configureJoint();
        }
    }
    JointSpherical.iSubclass = FudgeCore.Joint.registerSubclass(JointSpherical);
    FudgeCore.JointSpherical = JointSpherical;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
       * A physical connection between two bodies with two defined axis (normally e.g. (0,0,1) and rotation(1,0,0)), they share the same anchor and have free rotation, but transfer the twist.
       * In reality used in cars to transfer the more stable stationary force on the velocity axis to the bumping, damped moving wheel. Two RigidBodies need to be defined to use it.
       * The two motors can be defined for the two rotation axis, along with springs.
       * ```plaintext
       *
       *                      anchor - twist is transfered between bodies
       *         z                   |
       *         ‚Üë            -----  |  ------------
       *         |           |     | ‚Üì |            |
       *  -x <---|---> x     |     | x |            |           e.g. wheel can still turn up/down,
       *         |           |     |   |            |           left right but transfering it's rotation on to the wheel-axis.
       *         ‚Üì            -----     ------------
       *        -z
       *                 attachedRB          connectedRB
       *                (e.g. wheel)       (e.g. wheel-axis)
       * ```
     * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
       */
    class JointUniversal extends FudgeCore.Joint {
        constructor(_bodyAnchor = null, _bodyTied = null, _axisFirst = new FudgeCore.Vector3(1, 0, 0), _axisSecond = new FudgeCore.Vector3(0, 0, 1), _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied);
            this.#springDampingFirst = 0;
            this.#springFrequencyFirst = 0;
            this.#springDampingSecond = 0;
            this.#springFrequencySecond = 0;
            this.#maxRotorFirst = 360;
            this.#minRotorFirst = 0;
            this.#rotorTorqueFirst = 0;
            this.#rotorSpeedFirst = 0;
            this.#maxRotorSecond = 360;
            this.#minRotorSecond = 0;
            this.#rotorTorqueSecond = 0;
            this.#rotorSpeedSecond = 0;
            this.config = new OIMO.UniversalJointConfig();
            this.#getMutator = () => {
                let mutator = {
                    springDampingFirst: this.#springDampingFirst,
                    springFrequencyFirst: this.#springFrequencyFirst,
                    springDampingSecond: this.#springDampingSecond,
                    springFrequencySecond: this.#springFrequencySecond,
                    maxRotorFirst: this.#maxRotorFirst,
                    minRotorFirst: this.#minRotorFirst,
                    rotorSpeedFirst: this.#rotorSpeedFirst,
                    rotorTorqueFirst: this.#rotorTorqueFirst,
                    maxRotorSecond: this.#maxRotorSecond,
                    minRotorSecond: this.#minRotorSecond,
                    rotorSpeedSecond: this.#rotorSpeedSecond,
                    rotorTorqueSecond: this.#rotorTorqueSecond
                };
                return mutator;
            };
            this.#mutate = (_mutator) => {
                this.springDampingFirst = _mutator.springDampingFirst;
                this.springFrequencyFirst = _mutator.springFrequencyFirst;
                this.springDampingSecond = _mutator.springDampingSecond;
                this.springFrequencySecond = _mutator.springFrequencySecond;
                this.maxRotorFirst = _mutator.maxRotorFirst;
                this.minRotorFirst = _mutator.minRotorFirst;
                this.rotorSpeedFirst = _mutator.rotorSpeedFirst;
                this.rotorTorqueFirst = _mutator.rotorTorqueFirst;
                this.maxRotorSecond = _mutator.maxRotorSecond;
                this.minRotorSecond = _mutator.minRotorSecond;
                this.rotorSpeedSecond = _mutator.rotorSpeedSecond;
                this.rotorTorqueSecond = _mutator.rotorTorqueSecond;
            };
            this.axisFirst = _axisFirst;
            this.axisSecond = _axisSecond;
            this.anchor = _localAnchor;
        }
        #springDampingFirst;
        #springFrequencyFirst;
        #springDampingSecond;
        #springFrequencySecond;
        #maxRotorFirst;
        #minRotorFirst;
        #rotorTorqueFirst;
        #rotorSpeedFirst;
        #maxRotorSecond;
        #minRotorSecond;
        #rotorTorqueSecond;
        #rotorSpeedSecond;
        #motorFirst;
        #motorSecond;
        #axisSpringDamperFirst;
        #axisSpringDamperSecond;
        #axisFirst;
        #axisSecond;
        //#region Get/Set transfor of fudge properties to the physics engine
        /**
         * The axis connecting the the two {@link Node}s e.g. Vector3(0,1,0) to have a upward connection.
         *  When changed after initialization the joint needs to be reconnected.
         */
        get axisFirst() {
            return new FudgeCore.Vector3(this.#axisFirst.x, this.#axisFirst.y, this.#axisFirst.z);
        }
        set axisFirst(_value) {
            this.#axisFirst = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.disconnect();
            this.dirtyStatus();
        }
        /**
        * The axis connecting the the two {@link Node}s e.g. Vector3(0,1,0) to have a upward connection.
        *  When changed after initialization the joint needs to be reconnected.
        */
        get axisSecond() {
            return new FudgeCore.Vector3(this.#axisSecond.x, this.#axisSecond.y, this.#axisSecond.z);
        }
        set axisSecond(_value) {
            this.#axisSecond = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.disconnect();
            this.dirtyStatus();
        }
        /**
         * The damping of the spring. 1 equals completly damped.
         */
        get springDampingFirst() {
            return this.#springDampingFirst;
        }
        set springDampingFirst(_value) {
            this.#springDampingFirst = _value;
            if (this.joint != null)
                this.joint.getSpringDamper1().dampingRatio = _value;
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. The smaller the value the less restrictive is the spring.
        */
        get springFrequencyFirst() {
            return this.#springFrequencyFirst;
        }
        set springFrequencyFirst(_value) {
            this.#springFrequencyFirst = _value;
            if (this.joint != null)
                this.joint.getSpringDamper1().frequency = _value;
        }
        /**
         * The damping of the spring. 1 equals completly damped.
         */
        get springDampingSecond() {
            return this.#springDampingSecond;
        }
        set springDampingSecond(_value) {
            this.#springDampingSecond = _value;
            if (this.joint != null)
                this.joint.getSpringDamper2().dampingRatio = _value;
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. The smaller the value the less restrictive is the spring.
        */
        get springFrequencySecond() {
            return this.#springFrequencySecond;
        }
        set springFrequencySecond(_value) {
            this.#springFrequencySecond = _value;
            if (this.joint != null)
                this.joint.getSpringDamper2().frequency = _value;
        }
        /**
          * The Upper Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis-Angle measured in Degree.
         */
        get maxRotorFirst() {
            return this.#maxRotorFirst;
        }
        set maxRotorFirst(_value) {
            this.#maxRotorFirst = _value;
            if (this.joint != null)
                this.joint.getLimitMotor1().upperLimit = _value * Math.PI / 180;
        }
        /**
          * The Lower Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis Angle measured in Degree.
         */
        get minRotorFirst() {
            return this.#minRotorFirst;
        }
        set minRotorFirst(_value) {
            this.#minRotorFirst = _value;
            if (this.joint != null)
                this.joint.getLimitMotor1().lowerLimit = _value * Math.PI / 180;
        }
        /**
          * The target rotational speed of the motor in m/s.
         */
        get rotorSpeedFirst() {
            return this.#rotorSpeedFirst;
        }
        set rotorSpeedFirst(_value) {
            this.#rotorSpeedFirst = _value;
            if (this.joint != null)
                this.joint.getLimitMotor1().motorSpeed = _value;
        }
        /**
          * The maximum motor torque in Newton. force <= 0 equals disabled.
         */
        get rotorTorqueFirst() {
            return this.#rotorTorqueFirst;
        }
        set rotorTorqueFirst(_value) {
            this.#rotorTorqueFirst = _value;
            if (this.joint != null)
                this.joint.getLimitMotor1().motorTorque = _value;
        }
        /**
        * The Upper Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis-Angle measured in Degree.
       */
        get maxRotorSecond() {
            return this.#maxRotorSecond;
        }
        set maxRotorSecond(_value) {
            this.#maxRotorSecond = _value;
            if (this.joint != null)
                this.joint.getLimitMotor2().upperLimit = _value * Math.PI / 180;
        }
        /**
          * The Lower Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis Angle measured in Degree.
         */
        get minRotorSecond() {
            return this.#minRotorSecond;
        }
        set minRotorSecond(_value) {
            this.#minRotorSecond = _value;
            if (this.joint != null)
                this.joint.getLimitMotor2().lowerLimit = _value * Math.PI / 180;
        }
        /**
          * The target rotational speed of the motor in m/s.
         */
        get rotorSpeedSecond() {
            return this.#rotorSpeedSecond;
        }
        set rotorSpeedSecond(_value) {
            this.#rotorSpeedSecond = _value;
            if (this.joint != null)
                this.joint.getLimitMotor2().motorSpeed = _value;
        }
        /**
          * The maximum motor torque in Newton. force <= 0 equals disabled.
         */
        get rotorTorqueSecond() {
            return this.#rotorTorqueSecond;
        }
        set rotorTorqueSecond(_value) {
            this.#rotorTorqueSecond = _value;
            if (this.joint != null)
                this.joint.getLimitMotor2().motorTorque = _value;
        }
        /**
          * If the two connected RigidBodies collide with eath other. (Default = false)
         */
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = this.#getMutator();
            serialization.firstAxis = this.axisFirst.serialize();
            serialization.secondAxis = this.axisSecond.serialize();
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            this.axisFirst = await new FudgeCore.Vector3().deserialize(_serialization.axisFirst);
            this.axisSecond = await new FudgeCore.Vector3().deserialize(_serialization.axisSecond);
            this.#mutate(_serialization);
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        async mutate(_mutator) {
            this.axisFirst = new FudgeCore.Vector3(...(Object.values(_mutator.axisFirst)));
            this.axisSecond = new FudgeCore.Vector3(...(Object.values(_mutator.axisSecond)));
            delete _mutator.axisFirst;
            delete _mutator.axisSecond;
            this.#mutate(_mutator);
            this.deleteFromMutator(_mutator, this.#getMutator());
            super.mutate(_mutator);
        }
        getMutator() {
            let mutator = super.getMutator();
            Object.assign(mutator, this.#getMutator());
            mutator.axisFirst = this.axisFirst.getMutator();
            mutator.axisSecond = this.axisSecond.getMutator();
            return mutator;
        }
        #getMutator;
        #mutate;
        //#endregion
        constructJoint() {
            this.#axisSpringDamperFirst = new OIMO.SpringDamper().setSpring(this.#springFrequencyFirst, this.#springDampingFirst);
            this.#axisSpringDamperSecond = new OIMO.SpringDamper().setSpring(this.#springFrequencySecond, this.#springDampingSecond);
            this.#motorFirst = new OIMO.RotationalLimitMotor().setLimits(this.#minRotorFirst * Math.PI / 180, this.#maxRotorFirst * Math.PI / 180);
            this.#motorFirst.setMotor(this.#rotorSpeedFirst, this.#rotorTorqueFirst);
            this.#motorSecond = new OIMO.RotationalLimitMotor().setLimits(this.#minRotorFirst * Math.PI / 180, this.#maxRotorFirst * Math.PI / 180);
            this.#motorSecond.setMotor(this.#rotorSpeedFirst, this.#rotorTorqueFirst);
            this.config = new OIMO.UniversalJointConfig();
            super.constructJoint(this.#axisFirst, this.#axisSecond);
            this.config.limitMotor1 = this.#motorFirst;
            this.config.limitMotor2 = this.#motorSecond;
            this.config.springDamper1 = this.#axisSpringDamperFirst;
            this.config.springDamper2 = this.#axisSpringDamperSecond;
            this.joint = new OIMO.UniversalJoint(this.config);
            super.configureJoint();
        }
    }
    JointUniversal.iSubclass = FudgeCore.Joint.registerSubclass(JointUniversal);
    FudgeCore.JointUniversal = JointUniversal;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
       * A physical connection between two bodies with no movement.
       * Best way to simulate convex objects like a chair seat connected to chair legs.
       * The actual anchor point does not matter that much, only in very specific edge cases.
       * Because welding means they simply do not disconnect. (unless you add Breakability)
     * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
       */
    class JointWelding extends FudgeCore.Joint {
        constructor(_bodyAnchor = null, _bodyTied = null, _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied);
            this.config = new OIMO.GenericJointConfig();
            this.anchor = new FudgeCore.Vector3(_localAnchor.x, _localAnchor.y, _localAnchor.z);
        }
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = {
                [super.constructor.name]: super.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        //#endregion
        constructJoint() {
            this.config = new OIMO.GenericJointConfig();
            super.constructJoint(new OIMO.Mat3(), new OIMO.Mat3());
            this.joint = new OIMO.GenericJoint(this.config);
            this.joint.setAllowCollision(this.internalCollision);
        }
    }
    JointWelding.iSubclass = FudgeCore.Joint.registerSubclass(JointWelding);
    FudgeCore.JointWelding = JointWelding;
})(FudgeCore || (FudgeCore = {}));
///<reference path="../../../Physics/OIMOPhysics.d.ts"/>
var FudgeCore;
///<reference path="../../../Physics/OIMOPhysics.d.ts"/>
(function (FudgeCore) {
    /**
      * Manages the OIMO physics engine for FUDGE. Multiple instances may be created, one is active at a time.
      * All methods are static and use the currently active instance. At startup, a default instance is created and become the active instance
      * Attaching a {@link ComponentRigidbody} to a {@link Node} places a physics collider in the physics instance active at that time.
      * @author Marko Fehrenbach, HFU 2020
      */
    class Physics {
        constructor() {
            this.bodyList = new Array();
            this.jointList = new Array();
            if (typeof OIMO == "undefined") { // Check if OIMO Namespace was loaded, else do not use any physics. Check is needed to ensure FUDGE can be used without Physics
                FudgeCore.Debug.error("OIMO physics engine not connected!");
                return null;
            }
            this.oimoWorld = new OIMO.World();
            this.#debugDraw = new FudgeCore.PhysicsDebugDraw(); //Create a Fudge Physics debugging handling object
            this.oimoWorld.setDebugDraw(this.#debugDraw.oimoDebugDraw); //Tell OimoPhysics where to debug to and how it will be handled
        }
        /** The rendering of physical debug informations. Used internally no interaction needed.*/
        #debugDraw;
        /** The camera/viewport the physics are debugged to. Used internally no interaction needed. */
        #mainCam;
        /**
         * Define the currently active Physics instance
         */
        static set activeInstance(_physics) {
            Physics.∆íactive = _physics;
        }
        static get debugDraw() {
            return Physics.∆íactive.#debugDraw;
        }
        static get mainCam() {
            return Physics.∆íactive.#mainCam;
        }
        /**
        * Cast a RAY into the physical world from a origin point in a certain direction. Receiving informations about the hit object and the
        * hit point. Do not specify a _group to raycast the whole world, else only bodies within the specific group can be hit.
        */
        static raycast(_origin, _direction, _length = 1, _debugDraw = false, _group = FudgeCore.COLLISION_GROUP.DEFAULT) {
            let hitInfo = new FudgeCore.RayHitInfo();
            let ray = new OIMO.RayCastClosest();
            let begin = new OIMO.Vec3(_origin.x, _origin.y, _origin.z);
            let end = this.getRayEndPoint(begin, new FudgeCore.Vector3(_direction.x, _direction.y, _direction.z), _length);
            ray.clear();
            if (_group == FudgeCore.COLLISION_GROUP.DEFAULT) { //Case 1: Raycasting the whole world, normal mode
                Physics.∆íactive.oimoWorld.rayCast(begin, end, ray);
            }
            else { //Case2: Raycasting on each body in a specific group
                let allHits = new Array();
                Physics.∆íactive.bodyList.forEach(function (value) {
                    if (value.collisionGroup == _group) {
                        hitInfo = value.raycastThisBody(_origin, _direction, _length);
                        if (hitInfo.hit == true) { //Every hit is could potentially be the closest
                            allHits.push(hitInfo);
                        }
                    }
                });
                allHits.forEach(function (value) {
                    if (value.hitDistance < hitInfo.hitDistance || hitInfo.hit == false) {
                        hitInfo = value;
                    }
                });
            }
            if (ray.hit) { //Fill in informations on the hit
                hitInfo.hit = true;
                hitInfo.hitPoint = new FudgeCore.Vector3(ray.position.x, ray.position.y, ray.position.z);
                hitInfo.hitNormal = new FudgeCore.Vector3(ray.normal.x, ray.normal.y, ray.normal.z);
                hitInfo.hitDistance = this.getRayDistance(_origin, hitInfo.hitPoint);
                hitInfo.rigidbodyComponent = ray.shape.userData;
                hitInfo.rayEnd = new FudgeCore.Vector3(end.x, end.y, end.z);
                hitInfo.rayOrigin = _origin;
            }
            else {
                hitInfo.rayOrigin = _origin;
                hitInfo.hitPoint = new FudgeCore.Vector3(end.x, end.y, end.z);
            }
            if (_debugDraw) { //Handle debugging
                Physics.∆íactive.#debugDraw.debugRay(hitInfo.rayOrigin, hitInfo.hitPoint, new FudgeCore.Color(0, 1, 0, 1));
            }
            return hitInfo;
        }
        /**
        * Simulates the physical world. _deltaTime is the amount of time between physical steps, default is 60 frames per second ~17ms.
        * A frame timing can't be smaller than 1/30 of a second, or else it will be set to 30 frames, to have more consistent frame calculations.
        */
        static simulate(_deltaTime = 1 / 60) {
            if (Physics.∆íactive.jointList.length > 0)
                Physics.connectJoints(); //Connect joints if anything has happened between the last call to any of the two paired rigidbodies
            if (FudgeCore.Time.game.getScale() != 0) { //If time is stopped do not simulate to avoid misbehaviour
                _deltaTime = _deltaTime > 1 / 30 ? 1 / 30 : _deltaTime; //If instead of a fixed rate the game framerate is used, make sure irregular timings are fixed to 30fps
                Physics.∆íactive.oimoWorld.step(_deltaTime * FudgeCore.Time.game.getScale()); //Update the simulation by the given deltaTime and the Fudge internal TimeScale
            }
        }
        /**
         * Draw information about the currently active instance using the {@link ComponentCamera} given
         */
        static draw(_cmpCamera, _mode) {
            Physics.∆íactive.#debugDraw.setDebugMode(_mode);
            Physics.∆íactive.#mainCam = _cmpCamera;
            Physics.∆íactive.oimoWorld.debugDraw(); //Filling the physics world debug informations into the debug rendering handler
            Physics.∆íactive.#debugDraw.drawBuffers();
            Physics.∆íactive.#debugDraw.clearBuffers(); //Updates info about the current projection, resetting the points/lines/triangles that need to be drawn from debug
        }
        /**
          * Adjusts the transforms of the {@link ComponentRigidbody}s in the given branch to match their nodes or meshes
          */
        static adjustTransforms(_branch, _toMesh = false) {
            FudgeCore.Render.prepare(_branch, { ignorePhysics: true });
            for (let node of FudgeCore.Render.nodesPhysics)
                node.getComponent(FudgeCore.ComponentRigidbody).initialize();
        }
        /**
        * Get the applied gravitational force of the active instance. Default earth gravity = 9.81 m/s
        */
        static getGravity() {
            let tmpVec = Physics.∆íactive.oimoWorld.getGravity();
            return new FudgeCore.Vector3(tmpVec.x, tmpVec.y, tmpVec.z);
        }
        /**
        * Set the applied gravitational force of the active instance. Default earth gravity = 9.81 m/s
        */
        static setGravity(_value) {
            let tmpVec = new OIMO.Vec3(_value.x, _value.y, _value.z);
            Physics.∆íactive.oimoWorld.setGravity(tmpVec);
        }
        /**
        * Add a new OIMO Rigidbody to the active instance, happens automatically when adding a FUDGE Rigidbody Component.
        */
        static addRigidbody(_cmpRB) {
            Physics.∆íactive.bodyList.push(_cmpRB);
            Physics.∆íactive.oimoWorld.addRigidBody(_cmpRB.getOimoRigidbody());
        }
        /**
        * Remove the OIMO Rigidbody to the active instance, happens automatically when removing a FUDGE Rigidbody Component
        */
        static removeRigidbody(_cmpRB) {
            // TODO: two lists are being managed, info might deviate. Cleanup!
            let oimoRigidBody = _cmpRB.getOimoRigidbody();
            if (oimoRigidBody._world)
                oimoRigidBody._world.removeRigidBody(oimoRigidBody);
            // what if the rigidbodys oimo-world does not belong to the active instance?
            let id = Physics.∆íactive.bodyList.indexOf(_cmpRB);
            Physics.∆íactive.bodyList.splice(id, 1);
        }
        /**
        * Add a new OIMO Joint/Constraint to the active instance, happens automatically when adding a FUDGE Joint Component
        */
        static addJoint(_cmpJoint) {
            Physics.∆íactive.oimoWorld.addJoint(_cmpJoint.getOimoJoint());
        }
        /**
        * Called internally to inform the physics system that a joint has a change of core properties and needs to be recreated.
        */
        static changeJointStatus(_cmpJoint) {
            if (Physics.∆íactive.jointList.indexOf(_cmpJoint) < 0)
                Physics.∆íactive.jointList.push(_cmpJoint);
        }
        /**
          * Remove the OIMO Joint/Constraint to the active instance, happens automatically when removing a FUDGE Joint Component
          */
        static removeJoint(_cmpJoint) {
            Physics.∆íactive.oimoWorld.removeJoint(_cmpJoint.getOimoJoint());
        }
        /** Returns all the ComponentRigidbodies that are known to the active instance. */
        static getBodyList() {
            return Physics.∆íactive.bodyList;
        }
        /** Giving a ComponentRigidbody a specific identification number so it can be referenced in the loading process. And removed rb's can receive a new id. */
        static distributeBodyID() {
            let freeId = 0;
            let free = false;
            Physics.∆íactive.bodyList.forEach((_value) => {
                if (_value.id != freeId) {
                    free = true;
                }
                else {
                    free = false;
                }
                if (!free) {
                    freeId++;
                }
            });
            return freeId;
        }
        /**
         * Connect all joints that are not connected yet. Used internally no user interaction needed. This functionality is called and needed to make sure joints connect/disconnect
         * if any of the two paired ComponentRigidbodies change.
         */
        static connectJoints() {
            // let jointsToConnect: ComponentJoint[] = new Array(); //Copy original Array because removing/readding in the connecting process
            // this.jointList.forEach(function (value: ComponentJoint): void {
            //   jointsToConnect.push(value);
            // });
            // this.jointList.splice(0, this.jointList.length);
            let jointsToConnect = Physics.∆íactive.jointList;
            Physics.∆íactive.jointList = [];
            jointsToConnect.forEach((_joint) => {
                if (_joint.isConnected() == false) {
                    _joint.connect();
                }
            });
        }
        /** Remove all oimo joints and rigidbodies, so that they can be reused in another world  */
        static cleanup() {
            let oimoWorld = Physics.∆íactive.oimoWorld;
            if (oimoWorld != null) {
                //Resetting the world so a new world can be created, fix for re-opening a project in editor, making sure there are no old things calculated
                let jointsWorld = oimoWorld.getNumJoints();
                let bodiesWorld = oimoWorld.getNumRigidBodies();
                for (let body of Physics.∆íactive.bodyList)
                    body.isInitialized = false;
                Physics.∆íactive.jointList = new Array(); // TODO: see if it would be smarter, do use these arrays. Definitely more intuitive...
                for (let i = 0; i < jointsWorld; i++) {
                    oimoWorld.removeJoint(Physics.∆íactive.oimoWorld.getJointList());
                }
                for (let i = 0; i < bodiesWorld; i++) {
                    let oimoBody = oimoWorld.getRigidBodyList();
                    oimoWorld.removeRigidBody(oimoBody);
                }
            }
        }
        // /** Returns the actual used world of the OIMO physics engine. No user interaction needed.*/
        // private static getOimoWorld(): OIMO.World {
        //   return Physics.#activePhysics.oimoWorld;
        // }
        // /** Returns the ComponentRigidbody with the given id. Used internally to reconnect joints on loading in the editor. */
        // private static getBodyByID(_id: number): ComponentRigidbody {
        //   let body: ComponentRigidbody = null;
        //   Physics.#activePhysics.bodyList.forEach((value: ComponentRigidbody): void => {
        //     if (value.id == _id) {
        //       body = value;
        //     }
        //   });
        //   return body;
        // }
        /** Internal function to calculate the endpoint of mathematical ray. By adding the multiplied direction to the origin.
           * Used because OimoPhysics defines ray by start/end. But GameEngines commonly use origin/direction.
           */
        static getRayEndPoint(start, direction, length) {
            let origin = FudgeCore.Recycler.get(FudgeCore.Vector3);
            origin.set(start.x, start.y, start.z);
            let scaledDirection = direction.clone;
            scaledDirection.scale(length);
            let endpoint = FudgeCore.Vector3.SUM(scaledDirection, origin);
            FudgeCore.Recycler.store(scaledDirection);
            FudgeCore.Recycler.store(endpoint);
            FudgeCore.Recycler.store(origin);
            return new OIMO.Vec3(endpoint.x, endpoint.y, endpoint.z);
        }
        /** Internal function to get the distance in which a ray hit by subtracting points from each other and get the square root of the squared product of each component. */
        static getRayDistance(origin, hitPoint) {
            let dx = origin.x - hitPoint.x;
            let dy = origin.y - hitPoint.y;
            let dz = origin.z - hitPoint.z;
            return Math.sqrt(dx * dx + dy * dy + dz * dz);
        }
    }
    /** The SETTINGS that apply to the physical world. Ranging from things like sleeping, collisionShapeThickness and others */
    Physics.settings = new FudgeCore.PhysicsSettings(FudgeCore.COLLISION_GROUP.DEFAULT, (FudgeCore.COLLISION_GROUP.DEFAULT | FudgeCore.COLLISION_GROUP.GROUP_1 | FudgeCore.COLLISION_GROUP.GROUP_2 | FudgeCore.COLLISION_GROUP.GROUP_3 | FudgeCore.COLLISION_GROUP.GROUP_4));
    Physics.∆íactive = new Physics();
    FudgeCore.Physics = Physics;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
      * Storing and manipulating rotations in the form of quaternions.
      * Constructed out of the 4 components x,y,z,w. Commonly used to calculate rotations in physics engines.
      * Class mostly used internally to bridge the in FUDGE commonly used angles in degree to OimoPhysics quaternion system.
      * @authors Marko Fehrenbach, HFU, 2020
      */
    class Quaternion extends FudgeCore.Mutable {
        constructor(_x = 0, _y = 0, _z = 0, _w = 0) {
            super();
            this.x = _x;
            this.y = _y;
            this.z = _z;
            this.w = _w;
        }
        /** Get/Set the X component of the Quaternion. Real Part */
        get X() {
            return this.x;
        }
        set X(_x) {
            this.x = _x;
        }
        /** Get/Set the Y component of the Quaternion. Real Part */
        get Y() {
            return this.y;
        }
        set Y(_y) {
            this.y = _y;
        }
        /** Get/Set the Z component of the Quaternion. Real Part */
        get Z() {
            return this.z;
        }
        set Z(_z) {
            this.z = _z;
        }
        /** Get/Set the Y component of the Quaternion. Imaginary Part */
        get W() {
            return this.w;
        }
        set W(_w) {
            this.w = _w;
        }
        /**
         * Create quaternion from vector3 angles in degree
         */
        setFromVector3(rollX, pitchY, yawZ) {
            let cy = Math.cos(yawZ * 0.5);
            let sy = Math.sin(yawZ * 0.5);
            let cp = Math.cos(pitchY * 0.5);
            let sp = Math.sin(pitchY * 0.5);
            let cr = Math.cos(rollX * 0.5);
            let sr = Math.sin(rollX * 0.5);
            this.w = cr * cp * cy + sr * sp * sy;
            this.x = sr * cp * cy - cr * sp * sy;
            this.y = cr * sp * cy + sr * cp * sy;
            this.z = cr * cp * sy - sr * sp * cy;
        }
        /**
         * Returns the euler angles in radians as Vector3 from this quaternion.
         */
        toEulerangles() {
            let angles = new FudgeCore.Vector3();
            // roll (x-axis rotation)
            let sinrcosp = 2 * (this.w * this.x + this.y * this.z);
            let cosrcosp = 1 - 2 * (this.x * this.x + this.y * this.y);
            angles.x = Math.atan2(sinrcosp, cosrcosp);
            // pitch (y-axis rotation)
            let sinp = 2 * (this.w * this.y - this.z * this.x);
            if (Math.abs(sinp) >= 1)
                angles.y = this.copysign(Math.PI / 2, sinp); // use 90 degrees if out of range
            else
                angles.y = Math.asin(sinp);
            // yaw (z-axis rotation)
            let sinycosp = 2 * (this.w * this.z + this.x * this.y);
            let cosycosp = 1 - 2 * (this.y * this.y + this.z * this.z);
            angles.z = Math.atan2(sinycosp, cosycosp);
            return angles;
        }
        /**
         * Return angles in degrees as vector3 from this. quaterion
         */
        toDegrees() {
            let angles = this.toEulerangles();
            angles.x = angles.x * (180 / Math.PI);
            angles.y = angles.y * (180 / Math.PI);
            angles.z = angles.z * (180 / Math.PI);
            return angles;
        }
        getMutator() {
            let mutator = {
                x: this.x, y: this.y, z: this.z, w: this.w
            };
            return mutator;
        }
        reduceMutator(_mutator) { }
        /** Copying the sign of a to b */
        copysign(a, b) {
            return b < 0 ? -Math.abs(a) : Math.abs(a);
        }
    }
    FudgeCore.Quaternion = Quaternion;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Defines a threedimensional box by two corner-points, one with minimal values and one with maximum values
     */
    class Box {
        constructor(_min = FudgeCore.Vector3.ONE(Infinity), _max = FudgeCore.Vector3.ONE(-Infinity)) {
            this.set(_min, _max);
        }
        /**
         * Define the corners of this box, standard values are Infinity for min, and -Infinity for max,
         * creating an impossible inverted box that can not contain any points
         */
        set(_min = FudgeCore.Vector3.ONE(Infinity), _max = FudgeCore.Vector3.ONE(-Infinity)) {
            this.min = _min;
            this.max = _max;
        }
        /**
         * Expand the box if necessary to include the given point
         */
        expand(_include) {
            this.min.min(_include);
            this.max.max(_include);
        }
        recycle() {
            this.min.set(Infinity, Infinity, Infinity);
            this.max.set(-Infinity, -Infinity, -Infinity);
        }
    }
    FudgeCore.Box = Box;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Stores information provided by {@link Render}-picking e.g. using {@link Picker} and provides methods for further calculation of positions and normals etc.
     *
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021
     */
    class Pick {
        constructor(_node) {
            this.node = _node;
        }
        #mtxViewToWorld;
        #posWorld;
        #posMesh;
        /**
         * Accessor to calculate and store world position of intersection of {@link Ray} and {@link Mesh} only when used.
         */
        get posWorld() {
            if (this.#posWorld)
                return this.#posWorld;
            let pointInClipSpace = FudgeCore.Vector3.Z(this.zBuffer);
            let m = this.#mtxViewToWorld.get();
            let result = FudgeCore.Vector3.TRANSFORMATION(pointInClipSpace, this.#mtxViewToWorld, true);
            let w = m[3] * pointInClipSpace.x + m[7] * pointInClipSpace.y + m[11] * pointInClipSpace.z + m[15];
            result.scale(1 / w);
            this.#posWorld = result;
            return result;
        }
        /**
         * Accessor to calculate and store position in mesh-space of intersection of {@link Ray} and {@link Mesh} only when used.
         */
        get posMesh() {
            if (this.#posMesh)
                return this.#posMesh;
            let mtxWorldToMesh = FudgeCore.Matrix4x4.INVERSION(this.node.getComponent(FudgeCore.ComponentMesh).mtxWorld);
            let posMesh = FudgeCore.Vector3.TRANSFORMATION(this.posWorld, mtxWorldToMesh);
            this.#posMesh = posMesh;
            return posMesh;
        }
        /**
         * Accessor to calculate and store the face normal in world-space at the point of intersection of {@link Ray} and {@link Mesh} only when used.
         */
        get normal() {
            let cmpMesh = this.node.getComponent(FudgeCore.ComponentMesh);
            let mesh = cmpMesh.mesh;
            let normal = FudgeCore.Vector3.ZERO();
            let vertex = FudgeCore.Vector3.ZERO();
            let minDistance = Infinity;
            let result;
            for (let i = 2; i < mesh.indices.length; i += 3) {
                let iVertex = mesh.indices[i];
                let [x, y, z] = mesh.vertices.subarray(iVertex * 3, (iVertex + 1) * 3);
                vertex.set(x, y, z);
                [x, y, z] = mesh.normalsFlat.subarray(iVertex * 3, (iVertex + 1) * 3);
                normal.set(x, y, z);
                let difference = FudgeCore.Vector3.DIFFERENCE(this.posMesh, vertex);
                let distance = Math.abs(FudgeCore.Vector3.DOT(normal, difference));
                if (distance < minDistance) {
                    result = normal.clone;
                    minDistance = distance;
                }
            }
            result.transform(cmpMesh.mtxWorld, false);
            result.normalize();
            return result;
        }
        /**
         * Called solely by the renderer to enable calculation of the world coordinates of this {@link Pick}
         */
        set mtxViewToWorld(_mtxViewToWorld) {
            this.#mtxViewToWorld = _mtxViewToWorld;
        }
    }
    FudgeCore.Pick = Pick;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Provides static methods for picking using {@link Render}
     *
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021
     */
    class Picker {
        /**
         * Takes a ray plus min and max values for the near and far planes to construct the picker-camera,
         * then renders the pick-texture and returns an unsorted {@link Pick}-array with information about the hits of the ray.
         */
        static pickRay(_branch, _ray, _min, _max) {
            let cmpCameraPick = new FudgeCore.ComponentCamera();
            cmpCameraPick.mtxPivot.translation = _ray.origin;
            cmpCameraPick.mtxPivot.lookAt(_ray.direction);
            cmpCameraPick.projectCentral(1, 0.001, FudgeCore.FIELD_OF_VIEW.DIAGONAL, _min, _max);
            let picks = FudgeCore.Render.pickBranch(_branch, cmpCameraPick);
            return picks;
        }
        /**
         * Takes a camera and a point on its virtual normed projection plane (distance 1) to construct the picker-camera,
         * then renders the pick-texture and returns an unsorted {@link Pick}-array with information about the hits of the ray.
         */
        static pickCamera(_branch, _cmpCamera, _posProjection) {
            let ray = new FudgeCore.Ray(new FudgeCore.Vector3(-_posProjection.x, _posProjection.y, 1));
            let length = ray.direction.magnitude;
            if (_cmpCamera.node) {
                let mtxCamera = FudgeCore.Matrix4x4.MULTIPLICATION(_cmpCamera.node.mtxWorld, _cmpCamera.mtxPivot);
                ray.transform(mtxCamera);
                FudgeCore.Recycler.store(mtxCamera);
            }
            else
                ray.transform(_cmpCamera.mtxPivot);
            let picks = Picker.pickRay(_branch, ray, length * _cmpCamera.getNear(), length * _cmpCamera.getFar());
            return picks;
        }
        /**
         * Takes the camera of the given viewport and a point the client surface to construct the picker-camera,
         * then renders the pick-texture and returns an unsorted {@link Pick}-array with information about the hits of the ray.
         */
        static pickViewport(_viewport, _posClient) {
            let posProjection = _viewport.pointClientToProjection(_posClient);
            let picks = Picker.pickCamera(_viewport.getBranch(), _viewport.camera, posProjection);
            return picks;
        }
    }
    FudgeCore.Picker = Picker;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Defined by an origin and a direction of type {@link Pick}, rays are used to calculate picking and intersections
     *
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021
     */
    class Ray {
        constructor(_direction = FudgeCore.Vector3.Z(1), _origin = FudgeCore.Vector3.ZERO(), _length = 1) {
            this.origin = _origin;
            this.direction = _direction;
            this.length = _length;
        }
        /**
         * Returns the point of intersection of this ray with a plane defined by
         * the given point of origin and the planes normal. All values and calculations
         * must be relative to the same coordinate system, preferably the world
         */
        intersectPlane(_origin, _normal) {
            let difference = FudgeCore.Vector3.DIFFERENCE(_origin, this.origin);
            let factor = FudgeCore.Vector3.DOT(difference, _normal) / FudgeCore.Vector3.DOT(this.direction, _normal);
            let intersect = FudgeCore.Vector3.SUM(this.origin, FudgeCore.Vector3.SCALE(this.direction, factor));
            return intersect;
        }
        /**
         * Returns the point of intersection of this ray with a plane defined by the face.
         * All values and calculations must be relative to the same coordinate system, preferably the world
         */
        intersectFacePlane(_face) {
            return this.intersectPlane(_face.getPosition(0), _face.normal);
        }
        /**
         * Returns the shortest distance from the ray to the given target point.
         * All values and calculations must be relative to the same coordinate system, preferably the world.
         */
        getDistance(_target) {
            let originToTarget = FudgeCore.Vector3.DIFFERENCE(_target, this.origin);
            let raySection = FudgeCore.Vector3.NORMALIZATION(this.direction, 1);
            let projectedLength = FudgeCore.Vector3.DOT(originToTarget, raySection);
            raySection.scale(projectedLength);
            raySection.add(this.origin);
            let distance = FudgeCore.Vector3.DIFFERENCE(_target, raySection);
            return distance;
        }
        /**
         * Transform the ray by the given matrix
         */
        transform(_mtxTransform) {
            this.direction.transform(_mtxTransform);
            this.origin.transform(_mtxTransform);
        }
        /**
         * Returns a readable string representation of this ray
         */
        toString() {
            return `origin: ${this.origin.toString()}, direction: ${this.direction.toString()}, length: ${this.length.toPrecision(5)}`;
        }
    }
    FudgeCore.Ray = Ray;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * The main interface to the render engine, here WebGL (see superclass {@link RenderWebGL} and the RenderInjectors
     */
    class Render extends FudgeCore.RenderWebGL {
        // TODO: research if picking should be optimized using radius picking to filter
        //#region Prepare
        /**
         * Recursively iterates over the branch starting with the node given, recalculates all world transforms,
         * collects all lights and feeds all shaders used in the graph with these lights. Sorts nodes for different
         * render passes.
         */
        static prepare(_branch, _options = {}, _mtxWorld = FudgeCore.Matrix4x4.IDENTITY(), _lights = new Map(), _shadersUsed = null) {
            let firstLevel = (_shadersUsed == null);
            if (firstLevel) {
                _shadersUsed = [];
                Render.timestampUpdate = performance.now();
                Render.nodesSimple.reset();
                Render.nodesAlpha.reset();
                Render.nodesPhysics.reset();
                Render.dispatchEvent(new Event("renderPrepareStart" /* RENDER_PREPARE_START */));
            }
            if (!_branch.isActive)
                return; // don't add branch to render list if not active
            _branch.nNodesInBranch = 1;
            _branch.radius = 0;
            _branch.dispatchEventToTargetOnly(new Event("renderPrepare" /* RENDER_PREPARE */));
            _branch.timestampUpdate = Render.timestampUpdate;
            if (_branch.cmpTransform && _branch.cmpTransform.isActive) {
                let mtxWorldBranch = FudgeCore.Matrix4x4.MULTIPLICATION(_mtxWorld, _branch.cmpTransform.mtxLocal);
                _branch.mtxWorld.set(mtxWorldBranch);
                FudgeCore.Recycler.store(mtxWorldBranch);
            }
            else
                _branch.mtxWorld.set(_mtxWorld); // overwrite readonly mtxWorld of the current node
            let cmpRigidbody = _branch.getComponent(FudgeCore.ComponentRigidbody);
            if (cmpRigidbody && cmpRigidbody.isActive) { //TODO: support de-/activation throughout
                Render.nodesPhysics.push(_branch); // add this node to physics list
                if (!_options?.ignorePhysics)
                    this.transformByPhysics(_branch, cmpRigidbody);
            }
            let cmpLights = _branch.getComponents(FudgeCore.ComponentLight);
            for (let cmpLight of cmpLights) {
                if (!cmpLight.isActive)
                    continue;
                let type = cmpLight.light.getType();
                let lightsOfType = _lights.get(type);
                if (!lightsOfType) {
                    lightsOfType = [];
                    _lights.set(type, lightsOfType);
                }
                lightsOfType.push(cmpLight);
            }
            let cmpMesh = _branch.getComponent(FudgeCore.ComponentMesh);
            let cmpMaterial = _branch.getComponent(FudgeCore.ComponentMaterial);
            if (cmpMesh && cmpMesh.isActive && cmpMaterial && cmpMaterial.isActive) {
                // TODO: careful when using particlesystem, pivot must not change node position
                let mtxWorldMesh = FudgeCore.Matrix4x4.MULTIPLICATION(_branch.mtxWorld, cmpMesh.mtxPivot);
                cmpMesh.mtxWorld.set(mtxWorldMesh);
                FudgeCore.Recycler.store(mtxWorldMesh); // TODO: examine, why recycling this causes meshes to be misplaced...
                let shader = cmpMaterial.material.getShader();
                if (_shadersUsed.indexOf(shader) < 0)
                    _shadersUsed.push(shader);
                _branch.radius = cmpMesh.radius;
                if (cmpMaterial.sortForAlpha)
                    Render.nodesAlpha.push(_branch); // add this node to render list
                else
                    Render.nodesSimple.push(_branch); // add this node to render list
            }
            for (let child of _branch.getChildren()) {
                Render.prepare(child, _options, _branch.mtxWorld, _lights, _shadersUsed);
                _branch.nNodesInBranch += child.nNodesInBranch;
                let cmpMeshChild = child.getComponent(FudgeCore.ComponentMesh);
                let position = cmpMeshChild ? cmpMeshChild.mtxWorld.translation : child.mtxWorld.translation;
                position = position.clone;
                _branch.radius = Math.max(_branch.radius, position.getDistance(_branch.mtxWorld.translation) + child.radius);
                FudgeCore.Recycler.store(position);
            }
            if (firstLevel) {
                Render.dispatchEvent(new Event("renderPrepareEnd" /* RENDER_PREPARE_END */));
                for (let shader of _shadersUsed)
                    Render.setLightsInShader(shader, _lights);
            }
            //Calculate Physics based on all previous calculations    
            // Render.setupPhysicalTransform(_branch);
        }
        //#endregion
        //#region Picking
        /**
         * Used with a {@link Picker}-camera, this method renders one pixel with picking information
         * for each node in the line of sight and return that as an unsorted {@link Pick}-array
         */
        static pickBranch(_branch, _cmpCamera) {
            Render.∆ípicked = [];
            let size = Math.ceil(Math.sqrt(_branch.nNodesInBranch));
            Render.createPickTexture(size);
            Render.setBlendMode(FudgeCore.BLEND.OPAQUE);
            for (let node of _branch.getIterator(true)) {
                let cmpMesh = node.getComponent(FudgeCore.ComponentMesh);
                let cmpMaterial = node.getComponent(FudgeCore.ComponentMaterial);
                if (cmpMesh && cmpMesh.isActive && cmpMaterial && cmpMaterial.isActive) {
                    let mtxMeshToView = FudgeCore.Matrix4x4.MULTIPLICATION(_cmpCamera.mtxWorldToView, cmpMesh.mtxWorld);
                    Render.pick(node, node.mtxWorld, mtxMeshToView);
                    // RenderParticles.drawParticles();
                    FudgeCore.Recycler.store(mtxMeshToView);
                }
            }
            Render.setBlendMode(FudgeCore.BLEND.TRANSPARENT);
            let picks = Render.getPicks(size, _cmpCamera);
            Render.resetFrameBuffer();
            return picks;
        }
        //#endregion
        //#region Drawing
        static draw(_cmpCamera) {
            _cmpCamera.resetWorldToView();
            Render.drawList(_cmpCamera, this.nodesSimple);
            Render.drawListAlpha(_cmpCamera);
        }
        static drawListAlpha(_cmpCamera) {
            function sort(_a, _b) {
                return (Reflect.get(_a, "zCamera") < Reflect.get(_b, "zCamera")) ? 1 : -1;
            }
            for (let node of Render.nodesAlpha)
                Reflect.set(node, "zCamera", _cmpCamera.pointWorldToClip(node.getComponent(FudgeCore.ComponentMesh).mtxWorld.translation).z);
            let sorted = Render.nodesAlpha.getSorted(sort);
            Render.drawList(_cmpCamera, sorted);
        }
        static drawList(_cmpCamera, _list) {
            for (let node of _list) {
                let cmpMesh = node.getComponent(FudgeCore.ComponentMesh);
                let cmpMaterial = node.getComponent(FudgeCore.ComponentMaterial);
                Render.drawMesh(cmpMesh, cmpMaterial, _cmpCamera);
            }
        }
        //#region Physics
        static transformByPhysics(_node, _cmpRigidbody) {
            if (!_cmpRigidbody.isInitialized) // || Project.mode == MODE.EDITOR)
                _cmpRigidbody.initialize();
            if (!FudgeCore.Physics.getBodyList().length)
                return;
            if (!_node.mtxLocal) {
                throw (new Error("ComponentRigidbody requires ComponentTransform at the same Node"));
            }
            _cmpRigidbody.checkCollisionEvents();
            if (_cmpRigidbody.typeBody == FudgeCore.BODY_TYPE.KINEMATIC || FudgeCore.Project.mode == FudgeCore.MODE.EDITOR) { //Case of Kinematic Rigidbody
                let mtxPivotWorld = FudgeCore.Matrix4x4.MULTIPLICATION(_node.mtxWorld, _cmpRigidbody.mtxPivotUnscaled);
                _cmpRigidbody.setPosition(mtxPivotWorld.translation);
                _cmpRigidbody.setRotation(mtxPivotWorld.rotation);
                FudgeCore.Recycler.store(mtxPivotWorld);
                return;
            }
            let mtxWorld = FudgeCore.Matrix4x4.CONSTRUCTION({ translation: _cmpRigidbody.getPosition(), rotation: _cmpRigidbody.getRotation(), scaling: null });
            mtxWorld.multiply(_cmpRigidbody.mtxPivotInverse);
            _node.mtxWorld.translation = mtxWorld.translation;
            _node.mtxWorld.rotation = mtxWorld.rotation;
            let mtxLocal = _node.getParent() ? FudgeCore.Matrix4x4.RELATIVE(_node.mtxWorld, _node.getParent().mtxWorld) : _node.mtxWorld;
            _node.mtxLocal.set(mtxLocal);
            FudgeCore.Recycler.store(mtxWorld);
            FudgeCore.Recycler.store(mtxLocal);
        }
    }
    Render.rectClip = new FudgeCore.Rectangle(-1, 1, 2, -2);
    Render.nodesPhysics = new FudgeCore.RecycableArray();
    Render.nodesSimple = new FudgeCore.RecycableArray();
    Render.nodesAlpha = new FudgeCore.RecycableArray();
    FudgeCore.Render = Render;
    //#endregion
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class RenderParticles extends FudgeCore.Render {
        static drawParticles() {
            // console.log(RenderParticles.crc3);
        }
    }
    FudgeCore.RenderParticles = RenderParticles;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Controls the rendering of a branch, using the given {@link ComponentCamera},
     * and the propagation of the rendered image from the offscreen renderbuffer to the target canvas
     * through a series of {@link Framing} objects. The stages involved are in order of rendering
     * {@link Render}.viewport -> {@link Viewport}.source -> {@link Viewport}.destination -> DOM-Canvas -> Client(CSS)
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Viewport extends FudgeCore.EventTarget∆í {
        constructor() {
            super(...arguments);
            this.name = "Viewport"; // The name to call this viewport by.
            this.camera = null; // The camera representing the view parameters to render the branch.
            // TODO: verify if client to canvas should be in Viewport or somewhere else (Window, Container?)
            // Multiple viewports using the same canvas shouldn't differ here...
            // different framing methods can be used, this is the default
            this.frameClientToCanvas = new FudgeCore.FramingScaled();
            this.frameCanvasToDestination = new FudgeCore.FramingComplex();
            this.frameDestinationToSource = new FudgeCore.FramingScaled();
            this.frameSourceToRender = new FudgeCore.FramingScaled();
            this.adjustingFrames = true;
            this.adjustingCamera = true;
            this.physicsDebugMode = FudgeCore.PHYSICS_DEBUGMODE.NONE;
            this.#branch = null; // The to render with all its descendants.
            this.#crc2 = null;
            this.#canvas = null;
            /**
             * Handle drag-drop events and dispatch to viewport as FUDGE-Event
             */
            this.hndDragDropEvent = (_event) => {
                let _dragevent = _event;
                switch (_dragevent.type) {
                    case "dragover":
                    case "drop":
                        _dragevent.preventDefault();
                        _dragevent.dataTransfer.effectAllowed = "none";
                        break;
                    case "dragstart":
                        // just dummy data,  valid data should be set in handler registered by the user
                        _dragevent.dataTransfer.setData("text", "Hallo");
                        // TODO: check if there is a better solution to hide the ghost image of the draggable object
                        _dragevent.dataTransfer.setDragImage(new Image(), 0, 0);
                        break;
                }
                let event = new FudgeCore.EventDragDrop("∆í" + _event.type, _dragevent);
                this.addCanvasPosition(event);
                this.dispatchEvent(event);
            };
            /**
             * Handle pointer events and dispatch to viewport as FUDGE-Event
             */
            this.hndPointerEvent = (_event) => {
                let event = new FudgeCore.EventPointer("∆í" + _event.type, _event);
                this.addCanvasPosition(event);
                this.dispatchEvent(event);
            };
            /**
             * Handle keyboard events and dispatch to viewport as FUDGE-Event, if the viewport has the focus
             */
            this.hndKeyboardEvent = (_event) => {
                if (!this.hasFocus)
                    return;
                let event = new FudgeCore.EventKeyboard("∆í" + _event.type, _event);
                this.dispatchEvent(event);
            };
            /**
             * Handle wheel event and dispatch to viewport as FUDGE-Event
             */
            this.hndWheelEvent = (_event) => {
                let event = new FudgeCore.EventWheel("∆í" + _event.type, _event);
                this.dispatchEvent(event);
            };
            // #endregion
        }
        #branch; // The to render with all its descendants.
        #crc2;
        #canvas;
        //#endregion
        // #region Events (passing from canvas to viewport and from there into branch)
        /**
         * Returns true if this viewport currently has focus and thus receives keyboard events
         */
        get hasFocus() {
            return (Viewport.focus == this);
        }
        /**
         * Connects the viewport to the given canvas to render the given branch to using the given camera-component, and names the viewport as given.
         */
        initialize(_name, _branch, _camera, _canvas) {
            this.name = _name;
            this.camera = _camera;
            this.#canvas = _canvas;
            this.#crc2 = _canvas.getContext("2d");
            this.rectSource = FudgeCore.Render.getCanvasRect();
            this.rectDestination = this.getClientRectangle();
            this.setBranch(_branch);
        }
        /**
         * Retrieve the destination canvas
         */
        getCanvas() {
            return this.#canvas;
        }
        /**
         * Retrieve the 2D-context attached to the destination canvas
         */
        getContext() {
            return this.#crc2;
        }
        /**
         * Retrieve the size of the destination canvas as a rectangle, x and y are always 0
         */
        getCanvasRectangle() {
            return FudgeCore.Rectangle.GET(0, 0, this.#canvas.width, this.#canvas.height);
        }
        /**
         * Retrieve the client rectangle the canvas is displayed and fit in, x and y are always 0
         */
        getClientRectangle() {
            // FUDGE doesn't care about where the client rect is, only about the size matters.
            // return Rectangle.GET(this.canvas.offsetLeft, this.canvas.offsetTop, this.canvas.clientWidth, this.canvas.clientHeight);
            return FudgeCore.Rectangle.GET(0, 0, this.#canvas.clientWidth, this.#canvas.clientHeight);
        }
        /**
         * Set the branch to be drawn in the viewport.
         */
        setBranch(_branch) {
            // TODO: figure out what the event handling was created for. Doesn't have another effect than information on the console (deactivated)
            if (this.#branch) {
                this.#branch.removeEventListener("componentAdd" /* COMPONENT_ADD */, this.hndComponentEvent);
                this.#branch.removeEventListener("componentRemove" /* COMPONENT_REMOVE */, this.hndComponentEvent);
            }
            this.#branch = _branch;
            if (this.#branch) {
                this.#branch.addEventListener("componentAdd" /* COMPONENT_ADD */, this.hndComponentEvent);
                this.#branch.addEventListener("componentRemove" /* COMPONENT_REMOVE */, this.hndComponentEvent);
            }
        }
        /**
         * Retrieve the branch this viewport renders
         */
        getBranch() {
            return this.#branch;
        }
        /**
         * Logs this viewports scenegraph to the console.
         * TODO: remove this method, since it's implemented in Debug
         */
        showSceneGraph() {
            FudgeCore.Debug.branch(this.#branch);
        }
        // #region Drawing
        /**
         * Draw this viewport displaying its branch. By default, the transforms in the branch are recalculated first.
         * Pass `false` if calculation was already done for this frame
         */
        draw(_calculateTransforms = true) {
            if (!this.#branch)
                return;
            FudgeCore.Render.resetFrameBuffer();
            if (!this.camera.isActive)
                return;
            if (this.adjustingFrames)
                this.adjustFrames();
            if (this.adjustingCamera)
                this.adjustCamera();
            if (_calculateTransforms)
                this.calculateTransforms();
            FudgeCore.Render.clear(this.camera.clrBackground);
            if (this.physicsDebugMode != FudgeCore.PHYSICS_DEBUGMODE.PHYSIC_OBJECTS_ONLY)
                FudgeCore.Render.draw(this.camera);
            if (this.physicsDebugMode != FudgeCore.PHYSICS_DEBUGMODE.NONE) {
                FudgeCore.Physics.draw(this.camera, this.physicsDebugMode);
            }
            this.#crc2.imageSmoothingEnabled = false;
            this.#crc2.drawImage(FudgeCore.Render.getCanvas(), this.rectSource.x, this.rectSource.y, this.rectSource.width, this.rectSource.height, this.rectDestination.x, this.rectDestination.y, this.rectDestination.width, this.rectDestination.height);
        }
        /**
         * Calculate the cascade of transforms in this branch and store the results as mtxWorld in the {@link Node}s and {@link ComponentMesh}es
         */
        calculateTransforms() {
            let mtxRoot = FudgeCore.Matrix4x4.IDENTITY();
            if (this.#branch.getParent())
                mtxRoot = this.#branch.getParent().mtxWorld;
            FudgeCore.Render.prepare(this.#branch, null, mtxRoot);
        }
        /**
         * Adjust all frames involved in the rendering process from the display area in the client up to the renderer canvas
         */
        adjustFrames() {
            // get the rectangle of the canvas area as displayed (consider css)
            let rectClient = this.getClientRectangle();
            // adjust the canvas size according to the given framing applied to client
            let rectCanvas = this.frameClientToCanvas.getRect(rectClient);
            this.#canvas.width = rectCanvas.width;
            this.#canvas.height = rectCanvas.height;
            let rectTemp;
            // adjust the destination area on the target-canvas to render to by applying the framing to canvas
            rectTemp = this.frameCanvasToDestination.getRect(rectCanvas);
            this.rectDestination.copy(rectTemp);
            FudgeCore.Recycler.store(rectTemp);
            // adjust the area on the source-canvas to render from by applying the framing to destination area
            rectTemp = this.frameDestinationToSource.getRect(this.rectDestination);
            this.rectSource.copy(rectTemp);
            FudgeCore.Recycler.store(rectTemp);
            // having an offset source does make sense only when multiple viewports display parts of the same rendering. For now: shift it to 0,0
            this.rectSource.x = this.rectSource.y = 0;
            // still, a partial image of the rendering may be retrieved by moving and resizing the render viewport. For now, it's always adjusted to the current viewport
            let rectRender = this.frameSourceToRender.getRect(this.rectSource);
            FudgeCore.Render.setRenderRectangle(rectRender);
            // no more transformation after this for now, offscreen canvas and render-viewport have the same size
            FudgeCore.Render.setCanvasSize(rectRender.width, rectRender.height);
            FudgeCore.Recycler.store(rectClient);
            FudgeCore.Recycler.store(rectCanvas);
            FudgeCore.Recycler.store(rectRender);
        }
        /**
         * Adjust the camera parameters to fit the rendering into the render vieport
         */
        adjustCamera() {
            let rect = FudgeCore.Render.getRenderRectangle();
            this.camera.projectCentral(rect.width / rect.height, this.camera.getFieldOfView(), this.camera.getDirection(), this.camera.getNear(), this.camera.getFar());
        }
        // #endregion
        //#region Points
        /**
         * Returns a {@link Ray} in world coordinates from this camera through the point given in client space
         */
        getRayFromClient(_point) {
            let posProjection = this.pointClientToProjection(_point);
            let ray = new FudgeCore.Ray(new FudgeCore.Vector3(-posProjection.x, posProjection.y, 1));
            // ray.direction.scale(camera.distance);
            ray.origin.transform(this.camera.mtxPivot);
            ray.direction.transform(this.camera.mtxPivot, false);
            let cameraNode = this.camera.node;
            if (cameraNode) {
                ray.origin.transform(cameraNode.mtxWorld);
                ray.direction.transform(cameraNode.mtxWorld, false);
            }
            return ray;
        }
        /**
         * Returns a point on the client rectangle matching the projection of the given point in world space
         */
        pointWorldToClient(_position) {
            let projection = this.camera.pointWorldToClip(_position);
            let posClient = this.pointClipToClient(projection.toVector2());
            return posClient;
        }
        /**
         * Returns a point on the source-rectangle matching the given point on the client rectangle
         */
        pointClientToSource(_client) {
            let result = this.frameClientToCanvas.getPoint(_client, this.getClientRectangle());
            result = this.frameCanvasToDestination.getPoint(result, this.getCanvasRectangle());
            result = this.frameDestinationToSource.getPoint(result, this.rectSource);
            //TODO: when Source, Render and RenderViewport deviate, continue transformation 
            return result;
        }
        /**
         * Returns a point on the render-rectangle matching the given point on the source rectangle
         */
        pointSourceToRender(_source) {
            let projectionRectangle = this.camera.getProjectionRectangle();
            let point = this.frameSourceToRender.getPoint(_source, projectionRectangle);
            // console.log(projectionRectangle.toString());
            return point;
        }
        /**
         * Returns a point on the render-rectangle matching the given point on the client rectangle
         */
        pointClientToRender(_client) {
            let point = this.pointClientToSource(_client);
            point = this.pointSourceToRender(point);
            //TODO: when Render and RenderViewport deviate, continue transformation 
            return point;
        }
        /**
         * Returns a point on a projection surface in the hypothetical distance of 1 to the camera
         * matching the given point on the client rectangle
         * TODO: examine, if this should be a camera-method. Current implementation is for central-projection
         */
        pointClientToProjection(_client) {
            let posRender = this.pointClientToRender(_client);
            let rectRender = this.frameSourceToRender.getRect(this.rectSource);
            let rectProjection = this.camera.getProjectionRectangle();
            let posProjection = new FudgeCore.Vector2(rectProjection.width * posRender.x / rectRender.width, rectProjection.height * posRender.y / rectRender.height);
            posProjection.subtract(new FudgeCore.Vector2(rectProjection.width / 2, rectProjection.height / 2));
            posProjection.y *= -1;
            return posProjection;
        }
        /**
         * Returns a point in the client rectangle matching the given point in normed clipspace rectangle,
         * which stretches from -1 to 1 in both dimensions, y pointing up
         */
        pointClipToClient(_normed) {
            // let rectClient: Rectangle = this.getClientRectangle();
            // let result: Vector2 = Vector2.ONE(0.5);
            // result.x *= (_normed.x + 1) * rectClient.width;
            // result.y *= (1 - _normed.y) * rectClient.height;
            // result.add(rectClient.position);
            //TODO: check if rectDestination can safely (and more perfomant) be used instead getClientRectangle
            let pointClient = FudgeCore.Render.rectClip.pointToRect(_normed, this.rectDestination);
            return pointClient;
        }
        /**
         * Returns a point in the client rectangle matching the given point in normed clipspace rectangle,
         * which stretches from -1 to 1 in both dimensions, y pointing up
         */
        pointClipToCanvas(_normed) {
            let pointCanvas = FudgeCore.Render.rectClip.pointToRect(_normed, this.getCanvasRectangle());
            return pointCanvas;
        }
        /**
         * Returns a point in the browser page matching the given point of the viewport
         */
        pointClientToScreen(_client) {
            let screen = new FudgeCore.Vector2(this.#canvas.offsetLeft + _client.x, this.#canvas.offsetTop + _client.y);
            return screen;
        }
        /**
         * Switch the viewports focus on or off. Only one viewport in one FUDGE instance can have the focus, thus receiving keyboard events.
         * So a viewport currently having the focus will lose it, when another one receives it. The viewports fire {@link Event∆í}s accordingly.
         * // TODO: examine, if this can be achieved by regular DOM-Focus and tabindex=0
         */
        setFocus(_on) {
            if (_on) {
                if (Viewport.focus == this)
                    return;
                if (Viewport.focus)
                    Viewport.focus.dispatchEvent(new Event("focusout" /* FOCUS_OUT */));
                Viewport.focus = this;
                this.dispatchEvent(new Event("focusin" /* FOCUS_IN */));
            }
            else {
                if (Viewport.focus != this)
                    return;
                this.dispatchEvent(new Event("focusout" /* FOCUS_OUT */));
                Viewport.focus = null;
            }
        }
        /**
         * De- / Activates the given pointer event to be propagated into the viewport as FUDGE-Event
         */
        activatePointerEvent(_type, _on) {
            this.activateEvent(this.#canvas, _type, this.hndPointerEvent, _on);
        }
        /**
         * De- / Activates the given keyboard event to be propagated into the viewport as FUDGE-Event
         */
        activateKeyboardEvent(_type, _on) {
            this.activateEvent(this.#canvas.ownerDocument, _type, this.hndKeyboardEvent, _on);
        }
        /**
         * De- / Activates the given drag-drop event to be propagated into the viewport as FUDGE-Event
         */
        activateDragDropEvent(_type, _on) {
            if (_type == "\u0192dragstart" /* START */)
                this.#canvas.draggable = _on;
            this.activateEvent(this.#canvas, _type, this.hndDragDropEvent, _on);
        }
        /**
         * De- / Activates the wheel event to be propagated into the viewport as FUDGE-Event
         */
        activateWheelEvent(_type, _on) {
            this.activateEvent(this.#canvas, _type, this.hndWheelEvent, _on);
        }
        /**
         * Add position of the pointer mapped to canvas-coordinates as canvasX, canvasY to the event
         */
        addCanvasPosition(event) {
            event.canvasX = this.#canvas.width * event.pointerX / event.clientRect.width;
            event.canvasY = this.#canvas.height * event.pointerY / event.clientRect.height;
        }
        activateEvent(_target, _type, _handler, _on) {
            _type = _type.slice(1); // chip the ∆ílorin
            if (_on)
                _target.addEventListener(_type, _handler);
            else
                _target.removeEventListener(_type, _handler);
        }
        hndComponentEvent(_event) {
            // TODO: find out what the idea was here...
            // Debug.fudge(_event);
        }
    }
    FudgeCore.Viewport = Viewport;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Handles file transfer from a Fudge-Browserapp to the local filesystem without a local server.
     * Saves to the download-path given by the browser, loads from the player's choice.
     */
    class FileIoBrowserLocal extends FudgeCore.EventTargetStatic {
        // TODO: refactor to async function to be handled using promise, instead of using event target
        static async load(_multiple = false) {
            FileIoBrowserLocal.selector = document.createElement("input");
            FileIoBrowserLocal.selector.type = "file";
            FileIoBrowserLocal.selector.multiple = _multiple;
            FileIoBrowserLocal.selector.hidden = true;
            FileIoBrowserLocal.selector.addEventListener("change", FileIoBrowserLocal.handleFileSelect);
            document.body.appendChild(FileIoBrowserLocal.selector);
            return new Promise(_resolve => {
                function hndLoaded(_event) {
                    FileIoBrowserLocal.removeEventListener("fileLoaded" /* FILE_LOADED */, hndLoaded);
                    _resolve(_event.detail.mapFilenameToContent);
                }
                FileIoBrowserLocal.addEventListener("fileLoaded" /* FILE_LOADED */, hndLoaded);
                FileIoBrowserLocal.selector.click();
            });
        }
        // TODO: refactor to async function to be handled using promise, instead of using event target
        static save(_toSave, _type = "text/plain") {
            for (let filename in _toSave) {
                let content = _toSave[filename];
                let blob = new Blob([content], { type: _type });
                let url = window.URL.createObjectURL(blob);
                //*/ using anchor element for download
                let downloader;
                downloader = document.createElement("a");
                downloader.setAttribute("href", url);
                downloader.setAttribute("download", filename);
                document.body.appendChild(downloader);
                downloader.click();
                document.body.removeChild(downloader);
                window.URL.revokeObjectURL(url);
            }
            return new Promise(_resolve => {
                _resolve(_toSave);
                // function hndSaved(_event: Event): void {
                //   FileIoBrowserLocal.removeEventListener(EVENT.FILE_SAVED, hndSaved);
                //   _resolve((<CustomEvent>_event).detail);
                // }
                // FileIoBrowserLocal.addEventListener(EVENT.FILE_SAVED, hndSaved);
                // let event: CustomEvent = new CustomEvent(EVENT.FILE_SAVED, { detail: { mapFilenameToContent: _toSave } });
                // FileIoBrowserLocal.targetStatic.dispatchEvent(event);
            });
        }
        static async handleFileSelect(_event) {
            FudgeCore.Debug.fudge("-------------------------------- handleFileSelect");
            document.body.removeChild(FileIoBrowserLocal.selector);
            let fileList = _event.target.files;
            FudgeCore.Debug.fudge(fileList, fileList.length);
            if (fileList.length == 0)
                return;
            let loaded = {};
            await FileIoBrowserLocal.loadFiles(fileList, loaded);
            let event = new CustomEvent("fileLoaded" /* FILE_LOADED */, { detail: { mapFilenameToContent: loaded } });
            FileIoBrowserLocal.targetStatic.dispatchEvent(event);
        }
        static async loadFiles(_fileList, _loaded) {
            for (let file of _fileList) {
                const content = await new Response(file).text();
                _loaded[file.name] = content;
            }
        }
    }
    FudgeCore.FileIoBrowserLocal = FileIoBrowserLocal;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Mutable array of {@link Mutable}s. The {@link Mutator}s of the entries are included as array in the {@link Mutator}
     * @author Jirka Dell'Oro-Friedl, HFU, 2021
     */
    class MutableArray extends Array {
        rearrange(_sequence) {
            let length = this.length;
            for (let index of _sequence) {
                let original = this[index];
                // TODO: optimize, copy only double entries
                //@ts-ignore
                let copy = new original.constructor();
                copy.mutate(original.getMutator());
                this.push(copy);
            }
            this.splice(0, length);
        }
        getMutatorAttributeTypes(_mutator) {
            let types = {};
            for (let entry in this)
                types[entry] = this[entry].constructor.name;
            return types;
        }
        getMutator() {
            return this.map((_value) => _value.getMutator());
        }
        getMutatorForUserInterface() {
            return this.getMutator();
        }
        async mutate(_mutator) {
            for (let entry in this)
                await this[entry].mutate(_mutator[entry]);
        }
        /**
         * Updates the values of the given mutator according to the current state of the instance
         */
        updateMutator(_mutator) {
            for (let entry in this) {
                let mutatorValue = _mutator[entry];
                if (!mutatorValue)
                    continue;
                if (this[entry] instanceof FudgeCore.Mutable)
                    _mutator[entry] = this[entry].getMutator();
                else
                    _mutator[entry] = this[entry];
            }
        }
    }
    FudgeCore.MutableArray = MutableArray;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let MODE;
    (function (MODE) {
        MODE[MODE["EDITOR"] = 0] = "EDITOR";
        MODE[MODE["RUNTIME"] = 1] = "RUNTIME";
    })(MODE = FudgeCore.MODE || (FudgeCore.MODE = {}));
    /**
     * Static class handling the resources used with the current FUDGE-instance.
     * Keeps a list of the resources and generates ids to retrieve them.
     * Resources are objects referenced multiple times but supposed to be stored only once
     */
    class Project {
        /**
         * Registers the resource and generates an id for it by default.
         * If the resource already has an id, thus having been registered, its deleted from the list and registered anew.
         * It's possible to pass an id, but should not be done except by the Serializer.
         */
        static register(_resource, _idResource) {
            if (_resource.idResource)
                if (_resource.idResource == _idResource)
                    return;
                else
                    this.deregister(_resource);
            _resource.idResource = _idResource || Project.generateId(_resource);
            Project.resources[_resource.idResource] = _resource;
        }
        static deregister(_resource) {
            delete (Project.resources[_resource.idResource]);
            delete (Project.serialization[_resource.idResource]);
        }
        static clear() {
            Project.resources = {};
            Project.serialization = {};
            Project.scriptNamespaces = {};
        }
        // <T extends Component>(_class: new () => T): T[] {
        //   return <T[]>(this.components[_class.name] || []).slice(0);
        // }
        static getResourcesOfType(_type) {
            let found = {};
            for (let resourceId in Project.resources) {
                let resource = Project.resources[resourceId];
                if (resource instanceof _type)
                    found[resourceId] = resource;
            }
            return found;
        }
        /**
         * Generate a user readable and unique id using the type of the resource, the date and random numbers
         * @param _resource
         */
        static generateId(_resource) {
            // TODO: build id and integrate info from resource, not just date
            let idResource;
            do
                idResource = _resource.constructor.name + "|" + new Date().toISOString() + "|" + Math.random().toPrecision(5).substr(2, 5);
            while (Project.resources[idResource]);
            return idResource;
        }
        /**
         * Tests, if an object is a {@link SerializableResource}
         * @param _object The object to examine
         */
        static isResource(_object) {
            return (Reflect.has(_object, "idResource"));
        }
        /**
         * Retrieves the resource stored with the given id
         */
        static async getResource(_idResource) {
            let resource = Project.resources[_idResource];
            if (!resource) {
                let serialization = Project.serialization[_idResource];
                if (!serialization) {
                    FudgeCore.Debug.error("Resource not found", _idResource);
                    return null;
                }
                resource = await Project.deserializeResource(serialization);
            }
            return resource;
        }
        /**
         * Creates and registers a resource from a {@link Node}, copying the complete graph starting with it
         * @param _node A node to create the resource from
         * @param _replaceWithInstance if true (default), the node used as origin is replaced by a {@link GraphInstance} of the {@link Graph} created
         */
        static async registerAsGraph(_node, _replaceWithInstance = true) {
            let serialization = _node.serialize();
            let graph = new FudgeCore.Graph(_node.name);
            await graph.deserialize(serialization);
            Project.register(graph);
            if (_replaceWithInstance && _node.getParent()) {
                let instance = await Project.createGraphInstance(graph);
                _node.getParent().replaceChild(_node, instance);
            }
            return graph;
        }
        static async createGraphInstance(_graph) {
            let instance = new FudgeCore.GraphInstance(); // TODO: cleanup since creation moved here
            await instance.set(_graph);
            return instance;
        }
        static registerScriptNamespace(_namespace) {
            let name = FudgeCore.Serializer.registerNamespace(_namespace);
            if (!Project.scriptNamespaces[name])
                Project.scriptNamespaces[name] = _namespace;
        }
        static getComponentScripts() {
            let compoments = {};
            for (let namespace in Project.scriptNamespaces) {
                compoments[namespace] = [];
                for (let name in Project.scriptNamespaces[namespace]) {
                    let script = Reflect.get(Project.scriptNamespaces[namespace], name);
                    // is script a subclass of ComponentScript? instanceof doesn't work, since no instance is created
                    // let superclass: Object = script;
                    // while (superclass) {
                    //   superclass = Reflect.getPrototypeOf(superclass);
                    //   if (superclass == ComponentScript) {
                    //     scripts.push(script);
                    //     break;
                    //   }
                    // }
                    // Using Object.create doesn't call the constructor, but instanceof can be used. More elegant than the loop above, though maybe not as performant. 
                    let o = Object.create(script);
                    if (o.prototype instanceof FudgeCore.ComponentScript)
                        compoments[namespace].push(script);
                }
            }
            return compoments;
        }
        static async loadScript(_url) {
            let script = document.createElement("script");
            script.type = "text/javascript";
            // script.type = "module";
            script.async = false;
            // script.addEventListener("load", handleLoadedScript)
            let head = document.head;
            head.appendChild(script);
            FudgeCore.Debug.log("Loading: ", _url);
            return new Promise((resolve, reject) => {
                script.addEventListener("load", () => resolve());
                script.addEventListener("error", () => {
                    FudgeCore.Debug.error("Loading script", _url);
                    reject();
                });
                script.src = _url.toString();
            });
        }
        static async loadResources(_url) {
            const response = await fetch(_url);
            const resourceFileContent = await response.text();
            let serialization = FudgeCore.Serializer.parse(resourceFileContent);
            let reconstruction = await Project.deserialize(serialization);
            return reconstruction;
        }
        static async loadResourcesFromHTML() {
            const head = document.head;
            let links = head.querySelectorAll("link[type=resources]");
            for (let link of links) {
                let url = link.getAttribute("src");
                await Project.loadResources(url);
            }
        }
        /**
         * Serialize all resources
         */
        static serialize() {
            let serialization = {};
            for (let idResource in Project.resources) {
                let resource = Project.resources[idResource];
                if (idResource != resource.idResource)
                    FudgeCore.Debug.error("Resource-id mismatch", resource);
                serialization[idResource] = FudgeCore.Serializer.serialize(resource);
            }
            return serialization;
        }
        /**
         * Create resources from a serialization, deleting all resources previously registered
         * @param _serialization
         */
        static async deserialize(_serialization) {
            Project.serialization = _serialization;
            Project.resources = {};
            for (let idResource in _serialization) {
                let serialization = _serialization[idResource];
                let resource = await Project.deserializeResource(serialization);
                if (resource)
                    Project.resources[idResource] = resource;
            }
            return Project.resources;
        }
        static async deserializeResource(_serialization) {
            return FudgeCore.Serializer.deserialize(_serialization);
        }
    }
    Project.resources = {};
    Project.serialization = {};
    Project.scriptNamespaces = {};
    Project.baseURL = new URL(location.toString());
    Project.mode = MODE.RUNTIME;
    FudgeCore.Project = Project;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="../Coat/Coat.ts"/>
var FudgeCore;
// / <reference path="../Coat/Coat.ts"/>
(function (FudgeCore) {
    /**
     * Static superclass for the representation of WebGl shaderprograms.
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    var Shader_1;
    // TODO: define attribute/uniforms as layout and use those consistently in shaders
    let Shader = Shader_1 = class Shader {
        /** The type of coat that can be used with this shader to create a material */
        static getCoat() { return FudgeCore.CoatColored; }
        static getVertexShaderSource() { return this.vertexShaderSource; }
        static getFragmentShaderSource() { return this.fragmentShaderSource; }
        static deleteProgram() { }
        static useProgram() { }
        static createProgram() { }
        static registerSubclass(_subclass) { return Shader_1.subclasses.push(_subclass) - 1; }
    };
    /** refers back to this class from any subclass e.g. in order to find compatible other resources*/
    Shader.baseClass = Shader_1;
    /** list of all the subclasses derived from this class, if they registered properly*/
    Shader.subclasses = [];
    Shader = Shader_1 = __decorate([
        FudgeCore.RenderInjectorShader.decorate
    ], Shader);
    FudgeCore.Shader = Shader;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /** Code generated by CompileShaders.mjs using the information in CompileShaders.json */
    class ShaderFlat extends FudgeCore.Shader {
        static getCoat() { return FudgeCore.CoatColored; }
        static getVertexShaderSource() {
            return `#version 300 es
#define LIGHT
#define FLAT
#define CAMERA

/**
* Universal Shader as base for many others. Controlled by compiler directives
* @authors 2021, Luis Keck, HFU, 2021 | Jirka Dell'Oro-Friedl, HFU, 2021
*/

  // MINIMAL (no define needed): buffers for transformation
uniform mat4 u_mtxMeshToView;

  // FLAT: offer buffers for face normals and their transformation
  #if defined(FLAT)
in vec3 a_vctPositionFlat;
in vec3 a_vctNormalFace;
uniform mat4 u_mtxNormalMeshToWorld;
flat out vec4 v_vctColor;
  #else
  // regular if not FLAT
in vec3 a_vctPosition;
out vec4 v_vctColor;
  #endif

  // LIGHT: offer buffers for lighting vertices with different light types
  #if defined(LIGHT)
struct LightAmbient {
  vec4 vctColor;
};
struct LightDirectional {
  vec4 vctColor;
  vec3 vctDirection;
};

const uint MAX_LIGHTS_DIRECTIONAL = 100u;

uniform LightAmbient u_ambient;
uniform uint u_nLightsDirectional;
uniform LightDirectional u_directional[MAX_LIGHTS_DIRECTIONAL];
  #endif 

  // TEXTURE: offer buffers for UVs and pivot matrix
  #if defined(TEXTURE)
uniform mat3 u_mtxPivot;
in vec2 a_vctTexture;
out vec2 v_vctTexture;
  #endif

  #if defined(MATCAP) // MatCap-shader generates texture coordinates from surface normals
out vec2 v_vctTexture;
  #endif

  // GOURAUD: offer buffers for vertex normals, their transformation and the shininess
  #if defined(GOURAUD)||defined(MATCAP)
in vec3 a_vctNormalVertex;
uniform mat4 u_mtxNormalMeshToWorld;
  #endif

  // CAMERA: offer buffer and functionality for specular reflection depending on the camera-position
  #if defined(CAMERA)
uniform float u_fShininess;
uniform mat4 u_mtxMeshToWorld;
uniform mat4 u_mtxWorldToView;
uniform vec3 u_vctCamera;

float calculateReflection(vec3 _vctLight, vec3 _vctView, vec3 _vctNormal, float _fShininess) {
  if(_fShininess <= 0.0)
    return 0.0;
  vec3 vctReflection = normalize(reflect(-_vctLight, _vctNormal));
  float fScpecular = dot(vctReflection, _vctView);
  return pow(max(fScpecular, 0.0), _fShininess * 10.0) * _fShininess;
  // return max(spec_dot, 0.0) * shininess;
}
  #endif

void main() {
  vec4 vctPosition;

    #if defined(FLAT)
    // FLAT: use the special vertex and normal buffers for flat shading
  vctPosition = vec4(a_vctPositionFlat, 1.0);
  vec3 vctNormal = normalize(mat3(u_mtxNormalMeshToWorld) * a_vctNormalFace);
  v_vctColor = u_ambient.vctColor;
    #else 
  vctPosition = vec4(a_vctPosition, 1.0);
    #endif

    // use the regular vertex buffer
  gl_Position = u_mtxMeshToView * vctPosition;

    // GOURAUD: use the vertex normals
    #if defined(GOURAUD)
  v_vctColor = u_ambient.vctColor;
  vec3 vctNormal = normalize(mat3(u_mtxNormalMeshToWorld) * a_vctNormalVertex);
    #endif

    #if defined(CAMERA)
  // view vector needed
  // vec4 posWorld4 = u_mtxMeshToWorld * vctPosition;
  // vec3 vctView = normalize(posWorld4.xyz/posWorld4.w - u_vctCamera);
  vec3 vctView = normalize(vec3(u_mtxMeshToWorld * vctPosition) - u_vctCamera);
    #endif

    #if defined(LIGHT)
  // calculate the directional lighting effect
  for(uint i = 0u; i < u_nLightsDirectional; i++) {
    float fIllumination = -dot(vctNormal, u_directional[i].vctDirection);
    if(fIllumination > 0.0f) {
      v_vctColor += fIllumination * u_directional[i].vctColor;
        #if defined(CAMERA)
      float fReflection = calculateReflection(u_directional[i].vctDirection, vctView, vctNormal, u_fShininess);
      v_vctColor += fReflection * u_directional[i].vctColor;
        #endif
    }
  }
    #endif

    // TEXTURE: transform UVs
    #if defined(TEXTURE)
  v_vctTexture = vec2(u_mtxPivot * vec3(a_vctTexture, 1.0)).xy;
    #endif

    #if defined(MATCAP)
  vec3 vctNormal = normalize(mat3(u_mtxNormalMeshToWorld) * a_vctNormalVertex);
  vctNormal = mat3(u_mtxWorldToView) * vctNormal;
  v_vctTexture = 0.5 * vctNormal.xy / length(vctNormal) + 0.5;
  v_vctTexture.y *= -1.0;
    #endif

    // always full opacity for now...
  v_vctColor.a = 1.0;
}
`;
        }
        static getFragmentShaderSource() {
            return `#version 300 es
#define LIGHT
#define FLAT
#define CAMERA

/**
* Universal Shader as base for many others. Controlled by compiler directives
* @authors Jirka Dell'Oro-Friedl, HFU, 2021
*/

precision mediump float;

  // MINIMAL (no define needed): include base color
uniform vec4 u_vctColor;

  // FLAT: input vertex colors flat, so the third of a triangle determines the color
  #if defined(FLAT) 
flat in vec4 v_vctColor;
  // LIGHT: input vertex colors for each vertex for interpolation over the face
  #elif defined(LIGHT)
in vec4 v_vctColor;
  #endif

  // TEXTURE: input UVs and texture
  #if defined(TEXTURE) || defined(MATCAP)
in vec2 v_vctTexture;
uniform sampler2D u_texture;
  #endif

out vec4 vctFrag;

void main() {
    // MINIMAL: set the base color
  vctFrag = u_vctColor;

    // VERTEX: multiply with vertex color
    #if defined(FLAT) || defined(LIGHT)
  vctFrag *= v_vctColor;
    #endif

    // TEXTURE: multiply with texel color
    #if defined(TEXTURE) || defined(MATCAP)
  vec4 vctColorTexture = texture(u_texture, v_vctTexture);
  vctFrag *= vctColorTexture;
    #endif

    // discard pixel alltogether when transparent: don't show in Z-Buffer
  if(vctFrag.a < 0.01)
    discard;
}
`;
        }
    }
    ShaderFlat.iSubclass = FudgeCore.Shader.registerSubclass(ShaderFlat);
    FudgeCore.ShaderFlat = ShaderFlat;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /** Code generated by CompileShaders.mjs using the information in CompileShaders.json */
    class ShaderFlatTextured extends FudgeCore.Shader {
        static getCoat() { return FudgeCore.CoatTextured; }
        static getVertexShaderSource() {
            return `#version 300 es
#define LIGHT
#define FLAT
#define TEXTURE
#define CAMERA

/**
* Universal Shader as base for many others. Controlled by compiler directives
* @authors 2021, Luis Keck, HFU, 2021 | Jirka Dell'Oro-Friedl, HFU, 2021
*/

  // MINIMAL (no define needed): buffers for transformation
uniform mat4 u_mtxMeshToView;

  // FLAT: offer buffers for face normals and their transformation
  #if defined(FLAT)
in vec3 a_vctPositionFlat;
in vec3 a_vctNormalFace;
uniform mat4 u_mtxNormalMeshToWorld;
flat out vec4 v_vctColor;
  #else
  // regular if not FLAT
in vec3 a_vctPosition;
out vec4 v_vctColor;
  #endif

  // LIGHT: offer buffers for lighting vertices with different light types
  #if defined(LIGHT)
struct LightAmbient {
  vec4 vctColor;
};
struct LightDirectional {
  vec4 vctColor;
  vec3 vctDirection;
};

const uint MAX_LIGHTS_DIRECTIONAL = 100u;

uniform LightAmbient u_ambient;
uniform uint u_nLightsDirectional;
uniform LightDirectional u_directional[MAX_LIGHTS_DIRECTIONAL];
  #endif 

  // TEXTURE: offer buffers for UVs and pivot matrix
  #if defined(TEXTURE)
uniform mat3 u_mtxPivot;
in vec2 a_vctTexture;
out vec2 v_vctTexture;
  #endif

  #if defined(MATCAP) // MatCap-shader generates texture coordinates from surface normals
out vec2 v_vctTexture;
  #endif

  // GOURAUD: offer buffers for vertex normals, their transformation and the shininess
  #if defined(GOURAUD)||defined(MATCAP)
in vec3 a_vctNormalVertex;
uniform mat4 u_mtxNormalMeshToWorld;
  #endif

  // CAMERA: offer buffer and functionality for specular reflection depending on the camera-position
  #if defined(CAMERA)
uniform float u_fShininess;
uniform mat4 u_mtxMeshToWorld;
uniform mat4 u_mtxWorldToView;
uniform vec3 u_vctCamera;

float calculateReflection(vec3 _vctLight, vec3 _vctView, vec3 _vctNormal, float _fShininess) {
  if(_fShininess <= 0.0)
    return 0.0;
  vec3 vctReflection = normalize(reflect(-_vctLight, _vctNormal));
  float fScpecular = dot(vctReflection, _vctView);
  return pow(max(fScpecular, 0.0), _fShininess * 10.0) * _fShininess;
  // return max(spec_dot, 0.0) * shininess;
}
  #endif

void main() {
  vec4 vctPosition;

    #if defined(FLAT)
    // FLAT: use the special vertex and normal buffers for flat shading
  vctPosition = vec4(a_vctPositionFlat, 1.0);
  vec3 vctNormal = normalize(mat3(u_mtxNormalMeshToWorld) * a_vctNormalFace);
  v_vctColor = u_ambient.vctColor;
    #else 
  vctPosition = vec4(a_vctPosition, 1.0);
    #endif

    // use the regular vertex buffer
  gl_Position = u_mtxMeshToView * vctPosition;

    // GOURAUD: use the vertex normals
    #if defined(GOURAUD)
  v_vctColor = u_ambient.vctColor;
  vec3 vctNormal = normalize(mat3(u_mtxNormalMeshToWorld) * a_vctNormalVertex);
    #endif

    #if defined(CAMERA)
  // view vector needed
  // vec4 posWorld4 = u_mtxMeshToWorld * vctPosition;
  // vec3 vctView = normalize(posWorld4.xyz/posWorld4.w - u_vctCamera);
  vec3 vctView = normalize(vec3(u_mtxMeshToWorld * vctPosition) - u_vctCamera);
    #endif

    #if defined(LIGHT)
  // calculate the directional lighting effect
  for(uint i = 0u; i < u_nLightsDirectional; i++) {
    float fIllumination = -dot(vctNormal, u_directional[i].vctDirection);
    if(fIllumination > 0.0f) {
      v_vctColor += fIllumination * u_directional[i].vctColor;
        #if defined(CAMERA)
      float fReflection = calculateReflection(u_directional[i].vctDirection, vctView, vctNormal, u_fShininess);
      v_vctColor += fReflection * u_directional[i].vctColor;
        #endif
    }
  }
    #endif

    // TEXTURE: transform UVs
    #if defined(TEXTURE)
  v_vctTexture = vec2(u_mtxPivot * vec3(a_vctTexture, 1.0)).xy;
    #endif

    #if defined(MATCAP)
  vec3 vctNormal = normalize(mat3(u_mtxNormalMeshToWorld) * a_vctNormalVertex);
  vctNormal = mat3(u_mtxWorldToView) * vctNormal;
  v_vctTexture = 0.5 * vctNormal.xy / length(vctNormal) + 0.5;
  v_vctTexture.y *= -1.0;
    #endif

    // always full opacity for now...
  v_vctColor.a = 1.0;
}
`;
        }
        static getFragmentShaderSource() {
            return `#version 300 es
#define LIGHT
#define FLAT
#define TEXTURE
#define CAMERA

/**
* Universal Shader as base for many others. Controlled by compiler directives
* @authors Jirka Dell'Oro-Friedl, HFU, 2021
*/

precision mediump float;

  // MINIMAL (no define needed): include base color
uniform vec4 u_vctColor;

  // FLAT: input vertex colors flat, so the third of a triangle determines the color
  #if defined(FLAT) 
flat in vec4 v_vctColor;
  // LIGHT: input vertex colors for each vertex for interpolation over the face
  #elif defined(LIGHT)
in vec4 v_vctColor;
  #endif

  // TEXTURE: input UVs and texture
  #if defined(TEXTURE) || defined(MATCAP)
in vec2 v_vctTexture;
uniform sampler2D u_texture;
  #endif

out vec4 vctFrag;

void main() {
    // MINIMAL: set the base color
  vctFrag = u_vctColor;

    // VERTEX: multiply with vertex color
    #if defined(FLAT) || defined(LIGHT)
  vctFrag *= v_vctColor;
    #endif

    // TEXTURE: multiply with texel color
    #if defined(TEXTURE) || defined(MATCAP)
  vec4 vctColorTexture = texture(u_texture, v_vctTexture);
  vctFrag *= vctColorTexture;
    #endif

    // discard pixel alltogether when transparent: don't show in Z-Buffer
  if(vctFrag.a < 0.01)
    discard;
}
`;
        }
    }
    ShaderFlatTextured.iSubclass = FudgeCore.Shader.registerSubclass(ShaderFlatTextured);
    FudgeCore.ShaderFlatTextured = ShaderFlatTextured;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /** Code generated by CompileShaders.mjs using the information in CompileShaders.json */
    class ShaderGouraud extends FudgeCore.Shader {
        static getCoat() { return FudgeCore.CoatColored; }
        static getVertexShaderSource() {
            return `#version 300 es
#define LIGHT
#define GOURAUD
#define CAMERA

/**
* Universal Shader as base for many others. Controlled by compiler directives
* @authors 2021, Luis Keck, HFU, 2021 | Jirka Dell'Oro-Friedl, HFU, 2021
*/

  // MINIMAL (no define needed): buffers for transformation
uniform mat4 u_mtxMeshToView;

  // FLAT: offer buffers for face normals and their transformation
  #if defined(FLAT)
in vec3 a_vctPositionFlat;
in vec3 a_vctNormalFace;
uniform mat4 u_mtxNormalMeshToWorld;
flat out vec4 v_vctColor;
  #else
  // regular if not FLAT
in vec3 a_vctPosition;
out vec4 v_vctColor;
  #endif

  // LIGHT: offer buffers for lighting vertices with different light types
  #if defined(LIGHT)
struct LightAmbient {
  vec4 vctColor;
};
struct LightDirectional {
  vec4 vctColor;
  vec3 vctDirection;
};

const uint MAX_LIGHTS_DIRECTIONAL = 100u;

uniform LightAmbient u_ambient;
uniform uint u_nLightsDirectional;
uniform LightDirectional u_directional[MAX_LIGHTS_DIRECTIONAL];
  #endif 

  // TEXTURE: offer buffers for UVs and pivot matrix
  #if defined(TEXTURE)
uniform mat3 u_mtxPivot;
in vec2 a_vctTexture;
out vec2 v_vctTexture;
  #endif

  #if defined(MATCAP) // MatCap-shader generates texture coordinates from surface normals
out vec2 v_vctTexture;
  #endif

  // GOURAUD: offer buffers for vertex normals, their transformation and the shininess
  #if defined(GOURAUD)||defined(MATCAP)
in vec3 a_vctNormalVertex;
uniform mat4 u_mtxNormalMeshToWorld;
  #endif

  // CAMERA: offer buffer and functionality for specular reflection depending on the camera-position
  #if defined(CAMERA)
uniform float u_fShininess;
uniform mat4 u_mtxMeshToWorld;
uniform mat4 u_mtxWorldToView;
uniform vec3 u_vctCamera;

float calculateReflection(vec3 _vctLight, vec3 _vctView, vec3 _vctNormal, float _fShininess) {
  if(_fShininess <= 0.0)
    return 0.0;
  vec3 vctReflection = normalize(reflect(-_vctLight, _vctNormal));
  float fScpecular = dot(vctReflection, _vctView);
  return pow(max(fScpecular, 0.0), _fShininess * 10.0) * _fShininess;
  // return max(spec_dot, 0.0) * shininess;
}
  #endif

void main() {
  vec4 vctPosition;

    #if defined(FLAT)
    // FLAT: use the special vertex and normal buffers for flat shading
  vctPosition = vec4(a_vctPositionFlat, 1.0);
  vec3 vctNormal = normalize(mat3(u_mtxNormalMeshToWorld) * a_vctNormalFace);
  v_vctColor = u_ambient.vctColor;
    #else 
  vctPosition = vec4(a_vctPosition, 1.0);
    #endif

    // use the regular vertex buffer
  gl_Position = u_mtxMeshToView * vctPosition;

    // GOURAUD: use the vertex normals
    #if defined(GOURAUD)
  v_vctColor = u_ambient.vctColor;
  vec3 vctNormal = normalize(mat3(u_mtxNormalMeshToWorld) * a_vctNormalVertex);
    #endif

    #if defined(CAMERA)
  // view vector needed
  // vec4 posWorld4 = u_mtxMeshToWorld * vctPosition;
  // vec3 vctView = normalize(posWorld4.xyz/posWorld4.w - u_vctCamera);
  vec3 vctView = normalize(vec3(u_mtxMeshToWorld * vctPosition) - u_vctCamera);
    #endif

    #if defined(LIGHT)
  // calculate the directional lighting effect
  for(uint i = 0u; i < u_nLightsDirectional; i++) {
    float fIllumination = -dot(vctNormal, u_directional[i].vctDirection);
    if(fIllumination > 0.0f) {
      v_vctColor += fIllumination * u_directional[i].vctColor;
        #if defined(CAMERA)
      float fReflection = calculateReflection(u_directional[i].vctDirection, vctView, vctNormal, u_fShininess);
      v_vctColor += fReflection * u_directional[i].vctColor;
        #endif
    }
  }
    #endif

    // TEXTURE: transform UVs
    #if defined(TEXTURE)
  v_vctTexture = vec2(u_mtxPivot * vec3(a_vctTexture, 1.0)).xy;
    #endif

    #if defined(MATCAP)
  vec3 vctNormal = normalize(mat3(u_mtxNormalMeshToWorld) * a_vctNormalVertex);
  vctNormal = mat3(u_mtxWorldToView) * vctNormal;
  v_vctTexture = 0.5 * vctNormal.xy / length(vctNormal) + 0.5;
  v_vctTexture.y *= -1.0;
    #endif

    // always full opacity for now...
  v_vctColor.a = 1.0;
}
`;
        }
        static getFragmentShaderSource() {
            return `#version 300 es
#define LIGHT
#define GOURAUD
#define CAMERA

/**
* Universal Shader as base for many others. Controlled by compiler directives
* @authors Jirka Dell'Oro-Friedl, HFU, 2021
*/

precision mediump float;

  // MINIMAL (no define needed): include base color
uniform vec4 u_vctColor;

  // FLAT: input vertex colors flat, so the third of a triangle determines the color
  #if defined(FLAT) 
flat in vec4 v_vctColor;
  // LIGHT: input vertex colors for each vertex for interpolation over the face
  #elif defined(LIGHT)
in vec4 v_vctColor;
  #endif

  // TEXTURE: input UVs and texture
  #if defined(TEXTURE) || defined(MATCAP)
in vec2 v_vctTexture;
uniform sampler2D u_texture;
  #endif

out vec4 vctFrag;

void main() {
    // MINIMAL: set the base color
  vctFrag = u_vctColor;

    // VERTEX: multiply with vertex color
    #if defined(FLAT) || defined(LIGHT)
  vctFrag *= v_vctColor;
    #endif

    // TEXTURE: multiply with texel color
    #if defined(TEXTURE) || defined(MATCAP)
  vec4 vctColorTexture = texture(u_texture, v_vctTexture);
  vctFrag *= vctColorTexture;
    #endif

    // discard pixel alltogether when transparent: don't show in Z-Buffer
  if(vctFrag.a < 0.01)
    discard;
}
`;
        }
    }
    ShaderGouraud.iSubclass = FudgeCore.Shader.registerSubclass(ShaderGouraud);
    FudgeCore.ShaderGouraud = ShaderGouraud;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /** Code generated by CompileShaders.mjs using the information in CompileShaders.json */
    class ShaderGouraudTextured extends FudgeCore.Shader {
        static getCoat() { return FudgeCore.CoatTextured; }
        static getVertexShaderSource() {
            return `#version 300 es
#define LIGHT
#define GOURAUD
#define TEXTURE
#define CAMERA

/**
* Universal Shader as base for many others. Controlled by compiler directives
* @authors 2021, Luis Keck, HFU, 2021 | Jirka Dell'Oro-Friedl, HFU, 2021
*/

  // MINIMAL (no define needed): buffers for transformation
uniform mat4 u_mtxMeshToView;

  // FLAT: offer buffers for face normals and their transformation
  #if defined(FLAT)
in vec3 a_vctPositionFlat;
in vec3 a_vctNormalFace;
uniform mat4 u_mtxNormalMeshToWorld;
flat out vec4 v_vctColor;
  #else
  // regular if not FLAT
in vec3 a_vctPosition;
out vec4 v_vctColor;
  #endif

  // LIGHT: offer buffers for lighting vertices with different light types
  #if defined(LIGHT)
struct LightAmbient {
  vec4 vctColor;
};
struct LightDirectional {
  vec4 vctColor;
  vec3 vctDirection;
};

const uint MAX_LIGHTS_DIRECTIONAL = 100u;

uniform LightAmbient u_ambient;
uniform uint u_nLightsDirectional;
uniform LightDirectional u_directional[MAX_LIGHTS_DIRECTIONAL];
  #endif 

  // TEXTURE: offer buffers for UVs and pivot matrix
  #if defined(TEXTURE)
uniform mat3 u_mtxPivot;
in vec2 a_vctTexture;
out vec2 v_vctTexture;
  #endif

  #if defined(MATCAP) // MatCap-shader generates texture coordinates from surface normals
out vec2 v_vctTexture;
  #endif

  // GOURAUD: offer buffers for vertex normals, their transformation and the shininess
  #if defined(GOURAUD)||defined(MATCAP)
in vec3 a_vctNormalVertex;
uniform mat4 u_mtxNormalMeshToWorld;
  #endif

  // CAMERA: offer buffer and functionality for specular reflection depending on the camera-position
  #if defined(CAMERA)
uniform float u_fShininess;
uniform mat4 u_mtxMeshToWorld;
uniform mat4 u_mtxWorldToView;
uniform vec3 u_vctCamera;

float calculateReflection(vec3 _vctLight, vec3 _vctView, vec3 _vctNormal, float _fShininess) {
  if(_fShininess <= 0.0)
    return 0.0;
  vec3 vctReflection = normalize(reflect(-_vctLight, _vctNormal));
  float fScpecular = dot(vctReflection, _vctView);
  return pow(max(fScpecular, 0.0), _fShininess * 10.0) * _fShininess;
  // return max(spec_dot, 0.0) * shininess;
}
  #endif

void main() {
  vec4 vctPosition;

    #if defined(FLAT)
    // FLAT: use the special vertex and normal buffers for flat shading
  vctPosition = vec4(a_vctPositionFlat, 1.0);
  vec3 vctNormal = normalize(mat3(u_mtxNormalMeshToWorld) * a_vctNormalFace);
  v_vctColor = u_ambient.vctColor;
    #else 
  vctPosition = vec4(a_vctPosition, 1.0);
    #endif

    // use the regular vertex buffer
  gl_Position = u_mtxMeshToView * vctPosition;

    // GOURAUD: use the vertex normals
    #if defined(GOURAUD)
  v_vctColor = u_ambient.vctColor;
  vec3 vctNormal = normalize(mat3(u_mtxNormalMeshToWorld) * a_vctNormalVertex);
    #endif

    #if defined(CAMERA)
  // view vector needed
  // vec4 posWorld4 = u_mtxMeshToWorld * vctPosition;
  // vec3 vctView = normalize(posWorld4.xyz/posWorld4.w - u_vctCamera);
  vec3 vctView = normalize(vec3(u_mtxMeshToWorld * vctPosition) - u_vctCamera);
    #endif

    #if defined(LIGHT)
  // calculate the directional lighting effect
  for(uint i = 0u; i < u_nLightsDirectional; i++) {
    float fIllumination = -dot(vctNormal, u_directional[i].vctDirection);
    if(fIllumination > 0.0f) {
      v_vctColor += fIllumination * u_directional[i].vctColor;
        #if defined(CAMERA)
      float fReflection = calculateReflection(u_directional[i].vctDirection, vctView, vctNormal, u_fShininess);
      v_vctColor += fReflection * u_directional[i].vctColor;
        #endif
    }
  }
    #endif

    // TEXTURE: transform UVs
    #if defined(TEXTURE)
  v_vctTexture = vec2(u_mtxPivot * vec3(a_vctTexture, 1.0)).xy;
    #endif

    #if defined(MATCAP)
  vec3 vctNormal = normalize(mat3(u_mtxNormalMeshToWorld) * a_vctNormalVertex);
  vctNormal = mat3(u_mtxWorldToView) * vctNormal;
  v_vctTexture = 0.5 * vctNormal.xy / length(vctNormal) + 0.5;
  v_vctTexture.y *= -1.0;
    #endif

    // always full opacity for now...
  v_vctColor.a = 1.0;
}
`;
        }
        static getFragmentShaderSource() {
            return `#version 300 es
#define LIGHT
#define GOURAUD
#define TEXTURE
#define CAMERA

/**
* Universal Shader as base for many others. Controlled by compiler directives
* @authors Jirka Dell'Oro-Friedl, HFU, 2021
*/

precision mediump float;

  // MINIMAL (no define needed): include base color
uniform vec4 u_vctColor;

  // FLAT: input vertex colors flat, so the third of a triangle determines the color
  #if defined(FLAT) 
flat in vec4 v_vctColor;
  // LIGHT: input vertex colors for each vertex for interpolation over the face
  #elif defined(LIGHT)
in vec4 v_vctColor;
  #endif

  // TEXTURE: input UVs and texture
  #if defined(TEXTURE) || defined(MATCAP)
in vec2 v_vctTexture;
uniform sampler2D u_texture;
  #endif

out vec4 vctFrag;

void main() {
    // MINIMAL: set the base color
  vctFrag = u_vctColor;

    // VERTEX: multiply with vertex color
    #if defined(FLAT) || defined(LIGHT)
  vctFrag *= v_vctColor;
    #endif

    // TEXTURE: multiply with texel color
    #if defined(TEXTURE) || defined(MATCAP)
  vec4 vctColorTexture = texture(u_texture, v_vctTexture);
  vctFrag *= vctColorTexture;
    #endif

    // discard pixel alltogether when transparent: don't show in Z-Buffer
  if(vctFrag.a < 0.01)
    discard;
}
`;
        }
    }
    ShaderGouraudTextured.iSubclass = FudgeCore.Shader.registerSubclass(ShaderGouraudTextured);
    FudgeCore.ShaderGouraudTextured = ShaderGouraudTextured;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /** Code generated by CompileShaders.mjs using the information in CompileShaders.json */
    class ShaderLit extends FudgeCore.Shader {
        static getCoat() { return FudgeCore.CoatColored; }
        static getVertexShaderSource() {
            return `#version 300 es
/**
* Universal Shader as base for many others. Controlled by compiler directives
* @authors 2021, Luis Keck, HFU, 2021 | Jirka Dell'Oro-Friedl, HFU, 2021
*/

  // MINIMAL (no define needed): buffers for transformation
uniform mat4 u_mtxMeshToView;

  // FLAT: offer buffers for face normals and their transformation
  #if defined(FLAT)
in vec3 a_vctPositionFlat;
in vec3 a_vctNormalFace;
uniform mat4 u_mtxNormalMeshToWorld;
flat out vec4 v_vctColor;
  #else
  // regular if not FLAT
in vec3 a_vctPosition;
out vec4 v_vctColor;
  #endif

  // LIGHT: offer buffers for lighting vertices with different light types
  #if defined(LIGHT)
struct LightAmbient {
  vec4 vctColor;
};
struct LightDirectional {
  vec4 vctColor;
  vec3 vctDirection;
};

const uint MAX_LIGHTS_DIRECTIONAL = 100u;

uniform LightAmbient u_ambient;
uniform uint u_nLightsDirectional;
uniform LightDirectional u_directional[MAX_LIGHTS_DIRECTIONAL];
  #endif 

  // TEXTURE: offer buffers for UVs and pivot matrix
  #if defined(TEXTURE)
uniform mat3 u_mtxPivot;
in vec2 a_vctTexture;
out vec2 v_vctTexture;
  #endif

  #if defined(MATCAP) // MatCap-shader generates texture coordinates from surface normals
out vec2 v_vctTexture;
  #endif

  // GOURAUD: offer buffers for vertex normals, their transformation and the shininess
  #if defined(GOURAUD)||defined(MATCAP)
in vec3 a_vctNormalVertex;
uniform mat4 u_mtxNormalMeshToWorld;
  #endif

  // CAMERA: offer buffer and functionality for specular reflection depending on the camera-position
  #if defined(CAMERA)
uniform float u_fShininess;
uniform mat4 u_mtxMeshToWorld;
uniform mat4 u_mtxWorldToView;
uniform vec3 u_vctCamera;

float calculateReflection(vec3 _vctLight, vec3 _vctView, vec3 _vctNormal, float _fShininess) {
  if(_fShininess <= 0.0)
    return 0.0;
  vec3 vctReflection = normalize(reflect(-_vctLight, _vctNormal));
  float fScpecular = dot(vctReflection, _vctView);
  return pow(max(fScpecular, 0.0), _fShininess * 10.0) * _fShininess;
  // return max(spec_dot, 0.0) * shininess;
}
  #endif

void main() {
  vec4 vctPosition;

    #if defined(FLAT)
    // FLAT: use the special vertex and normal buffers for flat shading
  vctPosition = vec4(a_vctPositionFlat, 1.0);
  vec3 vctNormal = normalize(mat3(u_mtxNormalMeshToWorld) * a_vctNormalFace);
  v_vctColor = u_ambient.vctColor;
    #else 
  vctPosition = vec4(a_vctPosition, 1.0);
    #endif

    // use the regular vertex buffer
  gl_Position = u_mtxMeshToView * vctPosition;

    // GOURAUD: use the vertex normals
    #if defined(GOURAUD)
  v_vctColor = u_ambient.vctColor;
  vec3 vctNormal = normalize(mat3(u_mtxNormalMeshToWorld) * a_vctNormalVertex);
    #endif

    #if defined(CAMERA)
  // view vector needed
  // vec4 posWorld4 = u_mtxMeshToWorld * vctPosition;
  // vec3 vctView = normalize(posWorld4.xyz/posWorld4.w - u_vctCamera);
  vec3 vctView = normalize(vec3(u_mtxMeshToWorld * vctPosition) - u_vctCamera);
    #endif

    #if defined(LIGHT)
  // calculate the directional lighting effect
  for(uint i = 0u; i < u_nLightsDirectional; i++) {
    float fIllumination = -dot(vctNormal, u_directional[i].vctDirection);
    if(fIllumination > 0.0f) {
      v_vctColor += fIllumination * u_directional[i].vctColor;
        #if defined(CAMERA)
      float fReflection = calculateReflection(u_directional[i].vctDirection, vctView, vctNormal, u_fShininess);
      v_vctColor += fReflection * u_directional[i].vctColor;
        #endif
    }
  }
    #endif

    // TEXTURE: transform UVs
    #if defined(TEXTURE)
  v_vctTexture = vec2(u_mtxPivot * vec3(a_vctTexture, 1.0)).xy;
    #endif

    #if defined(MATCAP)
  vec3 vctNormal = normalize(mat3(u_mtxNormalMeshToWorld) * a_vctNormalVertex);
  vctNormal = mat3(u_mtxWorldToView) * vctNormal;
  v_vctTexture = 0.5 * vctNormal.xy / length(vctNormal) + 0.5;
  v_vctTexture.y *= -1.0;
    #endif

    // always full opacity for now...
  v_vctColor.a = 1.0;
}
`;
        }
        static getFragmentShaderSource() {
            return `#version 300 es
/**
* Universal Shader as base for many others. Controlled by compiler directives
* @authors Jirka Dell'Oro-Friedl, HFU, 2021
*/

precision mediump float;

  // MINIMAL (no define needed): include base color
uniform vec4 u_vctColor;

  // FLAT: input vertex colors flat, so the third of a triangle determines the color
  #if defined(FLAT) 
flat in vec4 v_vctColor;
  // LIGHT: input vertex colors for each vertex for interpolation over the face
  #elif defined(LIGHT)
in vec4 v_vctColor;
  #endif

  // TEXTURE: input UVs and texture
  #if defined(TEXTURE) || defined(MATCAP)
in vec2 v_vctTexture;
uniform sampler2D u_texture;
  #endif

out vec4 vctFrag;

void main() {
    // MINIMAL: set the base color
  vctFrag = u_vctColor;

    // VERTEX: multiply with vertex color
    #if defined(FLAT) || defined(LIGHT)
  vctFrag *= v_vctColor;
    #endif

    // TEXTURE: multiply with texel color
    #if defined(TEXTURE) || defined(MATCAP)
  vec4 vctColorTexture = texture(u_texture, v_vctTexture);
  vctFrag *= vctColorTexture;
    #endif

    // discard pixel alltogether when transparent: don't show in Z-Buffer
  if(vctFrag.a < 0.01)
    discard;
}
`;
        }
    }
    ShaderLit.iSubclass = FudgeCore.Shader.registerSubclass(ShaderLit);
    FudgeCore.ShaderLit = ShaderLit;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /** Code generated by CompileShaders.mjs using the information in CompileShaders.json */
    class ShaderLitTextured extends FudgeCore.Shader {
        static getCoat() { return FudgeCore.CoatTextured; }
        static getVertexShaderSource() {
            return `#version 300 es
#define TEXTURE

/**
* Universal Shader as base for many others. Controlled by compiler directives
* @authors 2021, Luis Keck, HFU, 2021 | Jirka Dell'Oro-Friedl, HFU, 2021
*/

  // MINIMAL (no define needed): buffers for transformation
uniform mat4 u_mtxMeshToView;

  // FLAT: offer buffers for face normals and their transformation
  #if defined(FLAT)
in vec3 a_vctPositionFlat;
in vec3 a_vctNormalFace;
uniform mat4 u_mtxNormalMeshToWorld;
flat out vec4 v_vctColor;
  #else
  // regular if not FLAT
in vec3 a_vctPosition;
out vec4 v_vctColor;
  #endif

  // LIGHT: offer buffers for lighting vertices with different light types
  #if defined(LIGHT)
struct LightAmbient {
  vec4 vctColor;
};
struct LightDirectional {
  vec4 vctColor;
  vec3 vctDirection;
};

const uint MAX_LIGHTS_DIRECTIONAL = 100u;

uniform LightAmbient u_ambient;
uniform uint u_nLightsDirectional;
uniform LightDirectional u_directional[MAX_LIGHTS_DIRECTIONAL];
  #endif 

  // TEXTURE: offer buffers for UVs and pivot matrix
  #if defined(TEXTURE)
uniform mat3 u_mtxPivot;
in vec2 a_vctTexture;
out vec2 v_vctTexture;
  #endif

  #if defined(MATCAP) // MatCap-shader generates texture coordinates from surface normals
out vec2 v_vctTexture;
  #endif

  // GOURAUD: offer buffers for vertex normals, their transformation and the shininess
  #if defined(GOURAUD)||defined(MATCAP)
in vec3 a_vctNormalVertex;
uniform mat4 u_mtxNormalMeshToWorld;
  #endif

  // CAMERA: offer buffer and functionality for specular reflection depending on the camera-position
  #if defined(CAMERA)
uniform float u_fShininess;
uniform mat4 u_mtxMeshToWorld;
uniform mat4 u_mtxWorldToView;
uniform vec3 u_vctCamera;

float calculateReflection(vec3 _vctLight, vec3 _vctView, vec3 _vctNormal, float _fShininess) {
  if(_fShininess <= 0.0)
    return 0.0;
  vec3 vctReflection = normalize(reflect(-_vctLight, _vctNormal));
  float fScpecular = dot(vctReflection, _vctView);
  return pow(max(fScpecular, 0.0), _fShininess * 10.0) * _fShininess;
  // return max(spec_dot, 0.0) * shininess;
}
  #endif

void main() {
  vec4 vctPosition;

    #if defined(FLAT)
    // FLAT: use the special vertex and normal buffers for flat shading
  vctPosition = vec4(a_vctPositionFlat, 1.0);
  vec3 vctNormal = normalize(mat3(u_mtxNormalMeshToWorld) * a_vctNormalFace);
  v_vctColor = u_ambient.vctColor;
    #else 
  vctPosition = vec4(a_vctPosition, 1.0);
    #endif

    // use the regular vertex buffer
  gl_Position = u_mtxMeshToView * vctPosition;

    // GOURAUD: use the vertex normals
    #if defined(GOURAUD)
  v_vctColor = u_ambient.vctColor;
  vec3 vctNormal = normalize(mat3(u_mtxNormalMeshToWorld) * a_vctNormalVertex);
    #endif

    #if defined(CAMERA)
  // view vector needed
  // vec4 posWorld4 = u_mtxMeshToWorld * vctPosition;
  // vec3 vctView = normalize(posWorld4.xyz/posWorld4.w - u_vctCamera);
  vec3 vctView = normalize(vec3(u_mtxMeshToWorld * vctPosition) - u_vctCamera);
    #endif

    #if defined(LIGHT)
  // calculate the directional lighting effect
  for(uint i = 0u; i < u_nLightsDirectional; i++) {
    float fIllumination = -dot(vctNormal, u_directional[i].vctDirection);
    if(fIllumination > 0.0f) {
      v_vctColor += fIllumination * u_directional[i].vctColor;
        #if defined(CAMERA)
      float fReflection = calculateReflection(u_directional[i].vctDirection, vctView, vctNormal, u_fShininess);
      v_vctColor += fReflection * u_directional[i].vctColor;
        #endif
    }
  }
    #endif

    // TEXTURE: transform UVs
    #if defined(TEXTURE)
  v_vctTexture = vec2(u_mtxPivot * vec3(a_vctTexture, 1.0)).xy;
    #endif

    #if defined(MATCAP)
  vec3 vctNormal = normalize(mat3(u_mtxNormalMeshToWorld) * a_vctNormalVertex);
  vctNormal = mat3(u_mtxWorldToView) * vctNormal;
  v_vctTexture = 0.5 * vctNormal.xy / length(vctNormal) + 0.5;
  v_vctTexture.y *= -1.0;
    #endif

    // always full opacity for now...
  v_vctColor.a = 1.0;
}
`;
        }
        static getFragmentShaderSource() {
            return `#version 300 es
#define TEXTURE

/**
* Universal Shader as base for many others. Controlled by compiler directives
* @authors Jirka Dell'Oro-Friedl, HFU, 2021
*/

precision mediump float;

  // MINIMAL (no define needed): include base color
uniform vec4 u_vctColor;

  // FLAT: input vertex colors flat, so the third of a triangle determines the color
  #if defined(FLAT) 
flat in vec4 v_vctColor;
  // LIGHT: input vertex colors for each vertex for interpolation over the face
  #elif defined(LIGHT)
in vec4 v_vctColor;
  #endif

  // TEXTURE: input UVs and texture
  #if defined(TEXTURE) || defined(MATCAP)
in vec2 v_vctTexture;
uniform sampler2D u_texture;
  #endif

out vec4 vctFrag;

void main() {
    // MINIMAL: set the base color
  vctFrag = u_vctColor;

    // VERTEX: multiply with vertex color
    #if defined(FLAT) || defined(LIGHT)
  vctFrag *= v_vctColor;
    #endif

    // TEXTURE: multiply with texel color
    #if defined(TEXTURE) || defined(MATCAP)
  vec4 vctColorTexture = texture(u_texture, v_vctTexture);
  vctFrag *= vctColorTexture;
    #endif

    // discard pixel alltogether when transparent: don't show in Z-Buffer
  if(vctFrag.a < 0.01)
    discard;
}
`;
        }
    }
    ShaderLitTextured.iSubclass = FudgeCore.Shader.registerSubclass(ShaderLitTextured);
    FudgeCore.ShaderLitTextured = ShaderLitTextured;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /** Code generated by CompileShaders.mjs using the information in CompileShaders.json */
    class ShaderMatCap extends FudgeCore.Shader {
        static getCoat() { return FudgeCore.CoatTextured; }
        static getVertexShaderSource() {
            return `#version 300 es
#define CAMERA
#define MATCAP

/**
* Universal Shader as base for many others. Controlled by compiler directives
* @authors 2021, Luis Keck, HFU, 2021 | Jirka Dell'Oro-Friedl, HFU, 2021
*/

  // MINIMAL (no define needed): buffers for transformation
uniform mat4 u_mtxMeshToView;

  // FLAT: offer buffers for face normals and their transformation
  #if defined(FLAT)
in vec3 a_vctPositionFlat;
in vec3 a_vctNormalFace;
uniform mat4 u_mtxNormalMeshToWorld;
flat out vec4 v_vctColor;
  #else
  // regular if not FLAT
in vec3 a_vctPosition;
out vec4 v_vctColor;
  #endif

  // LIGHT: offer buffers for lighting vertices with different light types
  #if defined(LIGHT)
struct LightAmbient {
  vec4 vctColor;
};
struct LightDirectional {
  vec4 vctColor;
  vec3 vctDirection;
};

const uint MAX_LIGHTS_DIRECTIONAL = 100u;

uniform LightAmbient u_ambient;
uniform uint u_nLightsDirectional;
uniform LightDirectional u_directional[MAX_LIGHTS_DIRECTIONAL];
  #endif 

  // TEXTURE: offer buffers for UVs and pivot matrix
  #if defined(TEXTURE)
uniform mat3 u_mtxPivot;
in vec2 a_vctTexture;
out vec2 v_vctTexture;
  #endif

  #if defined(MATCAP) // MatCap-shader generates texture coordinates from surface normals
out vec2 v_vctTexture;
  #endif

  // GOURAUD: offer buffers for vertex normals, their transformation and the shininess
  #if defined(GOURAUD)||defined(MATCAP)
in vec3 a_vctNormalVertex;
uniform mat4 u_mtxNormalMeshToWorld;
  #endif

  // CAMERA: offer buffer and functionality for specular reflection depending on the camera-position
  #if defined(CAMERA)
uniform float u_fShininess;
uniform mat4 u_mtxMeshToWorld;
uniform mat4 u_mtxWorldToView;
uniform vec3 u_vctCamera;

float calculateReflection(vec3 _vctLight, vec3 _vctView, vec3 _vctNormal, float _fShininess) {
  if(_fShininess <= 0.0)
    return 0.0;
  vec3 vctReflection = normalize(reflect(-_vctLight, _vctNormal));
  float fScpecular = dot(vctReflection, _vctView);
  return pow(max(fScpecular, 0.0), _fShininess * 10.0) * _fShininess;
  // return max(spec_dot, 0.0) * shininess;
}
  #endif

void main() {
  vec4 vctPosition;

    #if defined(FLAT)
    // FLAT: use the special vertex and normal buffers for flat shading
  vctPosition = vec4(a_vctPositionFlat, 1.0);
  vec3 vctNormal = normalize(mat3(u_mtxNormalMeshToWorld) * a_vctNormalFace);
  v_vctColor = u_ambient.vctColor;
    #else 
  vctPosition = vec4(a_vctPosition, 1.0);
    #endif

    // use the regular vertex buffer
  gl_Position = u_mtxMeshToView * vctPosition;

    // GOURAUD: use the vertex normals
    #if defined(GOURAUD)
  v_vctColor = u_ambient.vctColor;
  vec3 vctNormal = normalize(mat3(u_mtxNormalMeshToWorld) * a_vctNormalVertex);
    #endif

    #if defined(CAMERA)
  // view vector needed
  // vec4 posWorld4 = u_mtxMeshToWorld * vctPosition;
  // vec3 vctView = normalize(posWorld4.xyz/posWorld4.w - u_vctCamera);
  vec3 vctView = normalize(vec3(u_mtxMeshToWorld * vctPosition) - u_vctCamera);
    #endif

    #if defined(LIGHT)
  // calculate the directional lighting effect
  for(uint i = 0u; i < u_nLightsDirectional; i++) {
    float fIllumination = -dot(vctNormal, u_directional[i].vctDirection);
    if(fIllumination > 0.0f) {
      v_vctColor += fIllumination * u_directional[i].vctColor;
        #if defined(CAMERA)
      float fReflection = calculateReflection(u_directional[i].vctDirection, vctView, vctNormal, u_fShininess);
      v_vctColor += fReflection * u_directional[i].vctColor;
        #endif
    }
  }
    #endif

    // TEXTURE: transform UVs
    #if defined(TEXTURE)
  v_vctTexture = vec2(u_mtxPivot * vec3(a_vctTexture, 1.0)).xy;
    #endif

    #if defined(MATCAP)
  vec3 vctNormal = normalize(mat3(u_mtxNormalMeshToWorld) * a_vctNormalVertex);
  vctNormal = mat3(u_mtxWorldToView) * vctNormal;
  v_vctTexture = 0.5 * vctNormal.xy / length(vctNormal) + 0.5;
  v_vctTexture.y *= -1.0;
    #endif

    // always full opacity for now...
  v_vctColor.a = 1.0;
}
`;
        }
        static getFragmentShaderSource() {
            return `#version 300 es
#define CAMERA
#define MATCAP

/**
* Universal Shader as base for many others. Controlled by compiler directives
* @authors Jirka Dell'Oro-Friedl, HFU, 2021
*/

precision mediump float;

  // MINIMAL (no define needed): include base color
uniform vec4 u_vctColor;

  // FLAT: input vertex colors flat, so the third of a triangle determines the color
  #if defined(FLAT) 
flat in vec4 v_vctColor;
  // LIGHT: input vertex colors for each vertex for interpolation over the face
  #elif defined(LIGHT)
in vec4 v_vctColor;
  #endif

  // TEXTURE: input UVs and texture
  #if defined(TEXTURE) || defined(MATCAP)
in vec2 v_vctTexture;
uniform sampler2D u_texture;
  #endif

out vec4 vctFrag;

void main() {
    // MINIMAL: set the base color
  vctFrag = u_vctColor;

    // VERTEX: multiply with vertex color
    #if defined(FLAT) || defined(LIGHT)
  vctFrag *= v_vctColor;
    #endif

    // TEXTURE: multiply with texel color
    #if defined(TEXTURE) || defined(MATCAP)
  vec4 vctColorTexture = texture(u_texture, v_vctTexture);
  vctFrag *= vctColorTexture;
    #endif

    // discard pixel alltogether when transparent: don't show in Z-Buffer
  if(vctFrag.a < 0.01)
    discard;
}
`;
        }
    }
    ShaderMatCap.iSubclass = FudgeCore.Shader.registerSubclass(ShaderMatCap);
    FudgeCore.ShaderMatCap = ShaderMatCap;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /** Code generated by CompileShaders.mjs using the information in CompileShaders.json */
    class ShaderPhong extends FudgeCore.Shader {
        static getCoat() { return FudgeCore.CoatColored; }
        static getVertexShaderSource() {
            return `#version 300 es
/**
* Phong shading
* Implementation based on https://www.gsn-lib.org/docs/nodes/ShaderPluginNode.php
* @authors Luis Keck, HFU, 2021
*/
precision highp float;

in vec3 a_vctPosition;
in vec3 a_vctNormalVertex;
uniform mat4 u_mtxMeshToWorld;
uniform mat4 u_mtxMeshToView;
uniform mat4 u_mtxNormalMeshToWorld;

out vec3 f_normal;
out vec3 v_position;

void main() {
  f_normal = vec3(u_mtxNormalMeshToWorld * vec4(a_vctNormalVertex, 0.0));
  vec4 v_position4 = u_mtxMeshToWorld * vec4(a_vctPosition, 1.0);
  v_position = vec3(v_position4) / v_position4.w;
  gl_Position = u_mtxMeshToView * vec4(a_vctPosition, 1.0);
}
        
`;
        }
        static getFragmentShaderSource() {
            return `#version 300 es
/**
* Phong shading
* Implementation based on https://www.gsn-lib.org/docs/nodes/ShaderPluginNode.php
* @authors Luis Keck, HFU, 2021
*/
precision highp float;

struct LightAmbient {
    vec4 color;
};
struct LightDirectional {
    vec4 color;
    vec3 direction;
};

const uint MAX_LIGHTS_DIRECTIONAL = 100u;
uniform LightAmbient u_ambient;
uniform uint u_nLightsDirectional;
uniform LightDirectional u_directional[MAX_LIGHTS_DIRECTIONAL];

in vec3 f_normal;
in vec3 v_position;
uniform vec4 u_vctColor;
uniform float u_fShininess;
out vec4 vctFrag;

vec3 calculateReflection(vec3 light_dir, vec3 view_dir, vec3 normal, float shininess) {
    vec3 color = vec3(1);
    vec3 R = reflect(-light_dir, normal);
    float spec_dot = max(dot(R, view_dir), 0.0);
    color += pow(spec_dot, shininess);
    return color;
}

void main() {
    vctFrag = u_ambient.color;
    for(uint i = 0u; i < u_nLightsDirectional; i++) {
        vec3 light_dir = normalize(-u_directional[i].direction);
        vec3 view_dir = normalize(v_position);
        vec3 N = normalize(f_normal);

        float illuminance = dot(light_dir, N);
        if(illuminance > 0.0) {
            vec3 reflection = calculateReflection(light_dir, view_dir, N, u_fShininess);
            vctFrag += vec4(reflection, 1.0) * illuminance * u_directional[i].color;
        }
    }
    vctFrag *= u_vctColor;
    vctFrag.a = 1.0;
}       
`;
        }
    }
    ShaderPhong.iSubclass = FudgeCore.Shader.registerSubclass(ShaderPhong);
    FudgeCore.ShaderPhong = ShaderPhong;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /** Code generated by CompileShaders.mjs using the information in CompileShaders.json */
    class ShaderPick extends FudgeCore.Shader {
        static getVertexShaderSource() {
            return `#version 300 es
/**
* Renders for Raycasting
* @authors Jirka Dell'Oro-Friedl, HFU, 2019
*/
in vec3 a_vctPosition;       
uniform mat4 u_mtxMeshToView;

void main() {   
    gl_Position = u_mtxMeshToView * vec4(a_vctPosition, 1.0);
}
`;
        }
        static getFragmentShaderSource() {
            return `#version 300 es
/**
* Renders for Raycasting
* @authors Jirka Dell'Oro-Friedl, HFU, 2019
*/
precision mediump float;
precision highp int;

uniform int u_id;
uniform vec2 u_vctSize;
uniform vec4 u_vctColor;
out ivec4 vctFrag;

void main() {
    float id = float(u_id); 
    float pixel = trunc(gl_FragCoord.x) + u_vctSize.x * trunc(gl_FragCoord.y);

    if (pixel != id)
      discard;

    uint icolor = uint(u_vctColor.r * 255.0) << 24 | uint(u_vctColor.g * 255.0) << 16 | uint(u_vctColor.b * 255.0) << 8 | uint(u_vctColor.a * 255.0);
                
    vctFrag = ivec4(floatBitsToInt(gl_FragCoord.z), icolor, 0, 0);
}
`;
        }
    }
    FudgeCore.ShaderPick = ShaderPick;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /** Code generated by CompileShaders.mjs using the information in CompileShaders.json */
    class ShaderPickTextured extends FudgeCore.Shader {
        static getVertexShaderSource() {
            return `#version 300 es
/**
* Renders for Raycasting
* @authors Jirka Dell'Oro-Friedl, HFU, 2019
*/
in vec3 a_vctPosition;       
in vec2 a_vctTexture;
uniform mat4 u_mtxMeshToView;
uniform mat3 u_mtxPivot;

out vec2 v_vctTexture;

void main() {   
    gl_Position = u_mtxMeshToView * vec4(a_vctPosition, 1.0);
    v_vctTexture = vec2(u_mtxPivot * vec3(a_vctTexture, 1.0)).xy;
}
`;
        }
        static getFragmentShaderSource() {
            return `#version 300 es
/**
* Renders for Raycasting
* @authors Jirka Dell'Oro-Friedl, HFU, 2019
*/
precision mediump float;
precision highp int;

uniform int u_id;
uniform vec2 u_vctSize;
in vec2 v_vctTexture;
uniform vec4 u_vctColor;
uniform sampler2D u_texture;

out ivec4 vctFrag;

void main() {
    float id = float(u_id); 
    float pixel = trunc(gl_FragCoord.x) + u_vctSize.x * trunc(gl_FragCoord.y);

    if (pixel != id)
      discard;
    
    vec4 vctColor = u_vctColor * texture(u_texture, v_vctTexture);
    uint icolor = uint(vctColor.r * 255.0) << 24 | uint(vctColor.g * 255.0) << 16 | uint(vctColor.b * 255.0) << 8 | uint(vctColor.a * 255.0);
  
  vctFrag = ivec4(floatBitsToInt(gl_FragCoord.z), icolor, floatBitsToInt(v_vctTexture.x), floatBitsToInt(v_vctTexture.y));
}
`;
        }
    }
    FudgeCore.ShaderPickTextured = ShaderPickTextured;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let MIPMAP;
    (function (MIPMAP) {
        MIPMAP[MIPMAP["CRISP"] = 0] = "CRISP";
        MIPMAP[MIPMAP["MEDIUM"] = 1] = "MEDIUM";
        MIPMAP[MIPMAP["BLURRY"] = 2] = "BLURRY";
    })(MIPMAP = FudgeCore.MIPMAP || (FudgeCore.MIPMAP = {}));
    /**
     * Baseclass for different kinds of textures.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    let Texture = class Texture extends FudgeCore.Mutable {
        constructor(_name = "Texture") {
            super();
            this.idResource = undefined;
            this.mipmap = MIPMAP.CRISP;
            this.name = _name;
        }
        useRenderData() { }
        refresh() {
            this.renderData = null;
        }
        //#region Transfer
        serialize() {
            let serialization = {
                idResource: this.idResource,
                name: this.name,
                mipmap: MIPMAP[this.mipmap]
            };
            return serialization;
        }
        async deserialize(_serialization) {
            FudgeCore.Project.register(this, _serialization.idResource);
            this.name = _serialization.name;
            this.mipmap = MIPMAP[_serialization.mipmap];
            return this;
        }
        getMutatorAttributeTypes(_mutator) {
            let types = super.getMutatorAttributeTypes(_mutator);
            if (types.mipmap)
                types.mipmap = MIPMAP;
            return types;
        }
        reduceMutator(_mutator) {
            delete _mutator.idResource;
        }
    };
    Texture = __decorate([
        FudgeCore.RenderInjectorTexture.decorate
    ], Texture);
    FudgeCore.Texture = Texture;
    /**
     * Texture created from an existing image
     */
    class TextureImage extends Texture {
        constructor(_url) {
            super();
            this.image = null;
            if (_url) {
                this.load(_url);
                this.name = _url.toString().split("/").pop();
            }
            FudgeCore.Project.register(this);
        }
        get texImageSource() {
            return this.image;
        }
        /**
         * Asynchronously loads the image from the given url
         */
        async load(_url) {
            this.url = _url;
            this.image = new Image();
            // const response: Response = await window.fetch(this.url);
            // const blob: Blob = await response.blob();
            // let objectURL: string = URL.createObjectURL(blob);
            // this.image.src = objectURL;
            return new Promise((resolve, reject) => {
                this.image.addEventListener("load", () => {
                    this.renderData = null; // refresh render data on next draw call
                    resolve();
                });
                this.image.addEventListener("error", () => reject());
                this.image.src = new URL(this.url.toString(), FudgeCore.Project.baseURL).toString();
            });
        }
        //#region Transfer
        serialize() {
            return {
                url: this.url,
                type: this.type,
                [super.constructor.name]: super.serialize()
            };
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization[super.constructor.name]);
            await this.load(_serialization.url);
            // this.type is an accessor of Mutable doesn't need to be deserialized
            return this;
        }
        async mutate(_mutator) {
            if (_mutator.url != this.url.toString())
                await this.load(_mutator.url);
            // except url from mutator for further processing
            delete (_mutator.url);
            super.mutate(_mutator);
            // TODO: examine necessity to reconstruct, if mutator is kept by caller
            // _mutator.url = this.url; 
        }
    }
    FudgeCore.TextureImage = TextureImage;
    /**
     * Texture created from a canvas
     */
    class TextureBase64 extends Texture {
        constructor(_name, _base64, _mipmap = MIPMAP.CRISP) {
            super(_name);
            this.image = new Image();
            this.image.src = _base64;
            this.mipmap = _mipmap;
        }
        get texImageSource() {
            return this.image;
        }
    }
    FudgeCore.TextureBase64 = TextureBase64;
    class TextureCanvas extends Texture {
        constructor(_name, _crc2) {
            super(_name);
            this.crc2 = _crc2;
        }
        get texImageSource() {
            return this.crc2.canvas;
        }
    }
    FudgeCore.TextureCanvas = TextureCanvas;
    /**
     * Texture created from a FUDGE-Sketch
     */
    class TextureSketch extends TextureCanvas {
        get texImageSource() {
            return null;
        }
    }
    FudgeCore.TextureSketch = TextureSketch;
    /**
     * Texture created from an HTML-page
     */
    class TextureHTML extends TextureCanvas {
        get texImageSource() {
            return null;
        }
    }
    FudgeCore.TextureHTML = TextureHTML;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class TextureDefault extends FudgeCore.TextureBase64 {
        static get() {
            return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZAAAAGQCAYAAACAvzbMAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAADWLSURBVHhe7d0HnFTlvf/xH9uXZYGl9yrSRJpEUexYsJIba8Re498WNcZEb+41epOIsWs0Niyxm2g0duwaewO7oqJCAGnSt7H/8304B4dldpk5Z3b3zO7nzeu85pwzM8vMs7PPb35PO61qPBZjrVq18vfiKebFR/lFRPlFQ/lFE/fyy/FvAQBICwEEABAKAQQAEAp9IBHRhhoN5RcN5RdNSyg//YzCwkJr3bq1O169erXbMoEAEhF/wNFQftFQftE09/LLzc21Ll262E9+8hMbP368VVdX2+uvv27Tp093QSTq+yeARMQfcDSUXzSUXzTNtfxycnKspKTEBg0aZEceeaQdeuihtmLFCvvss89s3rx59vjjj9vDDz8cOROJHECqqqps9uzZtmzZMlu5cqVLldq1a2d9+/Z1+1HxAYyG8ouG8ouG8osmTPnl5+db9+7dbffdd7dTTz3V1cXvvvuuvfzyyy4DkVWrVtmNN95oS5YsccdhhQ4g5eXl9uyzz9qMGTNszZo1/tkfKQIq+u29995WWlrqn00fH8BoKL9oKL9oKL9o0ik/PbZNmza2xRZb2HHHHWeTJ0+2hQsX2pNPPmmLFy/2H7XOf/7zH7v11ltdPR5FqACyYMECu+eee1KKXmvXrrX99tvPRo8e7YJKuvgARkP5RROUnz67+iKUl5dnlZWVtnz58li8dj5/0TSn8lOT1b777msXXHCBde7c2V577TV78803k77Hb7/91u644w6rqKjwz4STdgBRtqHUJ4hoChCffPKJffXVV649rX379jZgwAC3BZQuTZo0ybbbbjuXXqWDD2A0lF80Qfl17NjRjjnmGOvUqZN988039sADD7gvUk39+vn8RdOcyq9r1642depU23rrre3RRx91X3JEdbSasIqLi23YsGHuXKYCSNopgXrvg+Ch/o/77rvPvVi9+J///Od29NFH29ChQ90LDGj4mNIlBZm4/8LQssycOdM1xb766qtJm2JF2UfPnj3t17/+tU2YMMF23XVXO/bYY11QQfM1f/58u+mmm1zfgfp44071sV6zPstB8FA9rC/8Tz31lOsXybS0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";
        }
    }
    TextureDefault.texture = new TextureDefault("TextureDefault", TextureDefault.get(), FudgeCore.MIPMAP.MEDIUM);
    FudgeCore.TextureDefault = TextureDefault;
})(FudgeCore || (FudgeCore = {}));
// /<reference path="../Event/Event.ts"/>
// /<reference path="../Time/Time.ts"/>
var FudgeCore;
// /<reference path="../Event/Event.ts"/>
// /<reference path="../Time/Time.ts"/>
(function (FudgeCore) {
    /**
     * Determines the mode a loop runs in
     */
    let LOOP_MODE;
    (function (LOOP_MODE) {
        /** Loop cycles controlled by window.requestAnimationFrame */
        LOOP_MODE["FRAME_REQUEST"] = "frameRequest";
        /** Loop cycles with the given framerate in {@link Time.game} */
        LOOP_MODE["TIME_GAME"] = "timeGame";
        /** Loop cycles with the given framerate in realtime, independent of {@link Time.game} */
        LOOP_MODE["TIME_REAL"] = "timeReal";
    })(LOOP_MODE = FudgeCore.LOOP_MODE || (FudgeCore.LOOP_MODE = {}));
    /**
     * Core loop of a Fudge application. Initializes automatically and must be started explicitly.
     * It then fires {@link EVENT.LOOP_FRAME} to all added listeners at each frame
     *
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Loop extends FudgeCore.EventTargetStatic {
        /** The gametime the loop was started, overwritten at each start */
        static get timeStartGame() { return Loop.∆íTimeStartGame; }
        /** The realtime the loop was started, overwritten at each start */
        static get timeStartReal() { return Loop.∆íTimeStartReal; }
        /** The gametime elapsed since the last loop cycle */
        static get timeFrameGame() { return Loop.∆íTimeFrameGame; }
        /** The realtime elapsed since the last loop cycle */
        static get timeFrameReal() { return Loop.∆íTimeFrameReal; }
        /** The gametime the last loop cycle started*/
        static get timeFrameStartGame() { return Loop.∆íTimeFrameStartGame; }
        /** The realtime the last loop cycle started*/
        static get timeFrameStartReal() { return Loop.∆íTimeFrameStartReal; }
        /** The average number of frames per second in gametime */
        static get fpsGameAverage() { return 1000 / Loop.∆íTimeLastFrameGameAvg; }
        /** The average number of frames per second in realtime */
        static get fpsRealAverage() { return 1000 / Loop.∆íTimeLastFrameRealAvg; }
        /** The number of frames triggered so far */
        static get frames() { return Loop.∆íFrames; }
        /**
         * Starts the loop with the given mode and fps.
         * The default for _mode is FRAME_REQUEST, see {@link LOOP_MODE}, hooking the loop to the browser's animation frame.
         * Is only applicable in TIME-modes.
         * _syncWithAnimationFrame is experimental and only applicable in TIME-modes, deferring the loop-cycle until the next possible animation frame.
         */
        static start(_mode = LOOP_MODE.FRAME_REQUEST, _fps = 60, _syncWithAnimationFrame = false) {
            Loop.stop();
            Loop.∆íTimeStartGame = FudgeCore.Time.game.get();
            Loop.∆íTimeStartReal = performance.now();
            Loop.∆íTimeFrameStartGame = Loop.∆íTimeStartGame;
            Loop.∆íTimeFrameStartReal = Loop.∆íTimeStartReal;
            Loop.fpsDesired = (_mode == LOOP_MODE.FRAME_REQUEST) ? 60 : _fps;
            Loop.framesToAverage = Loop.fpsDesired;
            Loop.∆íTimeLastFrameGameAvg = Loop.∆íTimeLastFrameRealAvg = 1000 / Loop.fpsDesired;
            Loop.mode = _mode;
            Loop.syncWithAnimationFrame = _syncWithAnimationFrame;
            let log = `Loop starting in mode ${Loop.mode}`;
            if (Loop.mode != LOOP_MODE.FRAME_REQUEST)
                log += ` with attempted ${_fps} fps`;
            FudgeCore.Debug.fudge(log);
            switch (_mode) {
                case LOOP_MODE.FRAME_REQUEST:
                    Loop.loopFrame();
                    break;
                case LOOP_MODE.TIME_REAL:
                    Loop.idIntervall = window.setInterval(Loop.loopTime, 1000 / Loop.fpsDesired);
                    Loop.loopTime();
                    break;
                case LOOP_MODE.TIME_GAME:
                    Loop.idIntervall = FudgeCore.Time.game.setTimer(1000 / Loop.fpsDesired, 0, Loop.loopTime);
                    Loop.loopTime();
                    break;
                default:
                    break;
            }
            Loop.running = true;
        }
        /**
         * Stops the loop
         */
        static stop() {
            if (!Loop.running)
                return;
            switch (Loop.mode) {
                case LOOP_MODE.FRAME_REQUEST:
                    window.cancelAnimationFrame(Loop.idRequest);
                    break;
                case LOOP_MODE.TIME_REAL:
                    window.clearInterval(Loop.idIntervall);
                    window.cancelAnimationFrame(Loop.idRequest);
                    break;
                case LOOP_MODE.TIME_GAME:
                    FudgeCore.Time.game.deleteTimer(Loop.idIntervall);
                    window.cancelAnimationFrame(Loop.idRequest);
                    break;
                default:
                    break;
            }
            Loop.running = false;
            FudgeCore.Debug.fudge("Loop stopped!");
        }
        static continue() {
            if (Loop.running)
                return;
            Loop.start(Loop.mode, Loop.fpsDesired, Loop.syncWithAnimationFrame);
        }
        static loop() {
            let time;
            time = performance.now();
            Loop.∆íTimeFrameReal = time - Loop.∆íTimeFrameStartReal;
            Loop.∆íTimeFrameStartReal = time;
            time = FudgeCore.Time.game.get();
            Loop.∆íTimeFrameGame = time - Loop.∆íTimeFrameStartGame;
            Loop.∆íTimeFrameStartGame = time;
            Loop.∆íTimeLastFrameGameAvg = ((Loop.framesToAverage - 1) * Loop.∆íTimeLastFrameGameAvg + Loop.∆íTimeFrameGame) / Loop.framesToAverage;
            Loop.∆íTimeLastFrameRealAvg = ((Loop.framesToAverage - 1) * Loop.∆íTimeLastFrameRealAvg + Loop.∆íTimeFrameReal) / Loop.framesToAverage;
            // TODO: consider LoopEvent which conveys information such as timeElapsed etc...
            Loop.∆íFrames++;
            let event = new Event("loopFrame" /* LOOP_FRAME */);
            Loop.targetStatic.dispatchEvent(event);
        }
        static loopFrame() {
            Loop.loop();
            Loop.idRequest = window.requestAnimationFrame(Loop.loopFrame);
        }
        static loopTime() {
            if (Loop.syncWithAnimationFrame)
                Loop.idRequest = window.requestAnimationFrame(Loop.loop);
            else
                Loop.loop();
        }
    }
    Loop.∆íTimeStartGame = 0;
    Loop.∆íTimeStartReal = 0;
    Loop.∆íTimeFrameGame = 0;
    Loop.∆íTimeFrameReal = 0;
    Loop.∆íTimeFrameStartGame = 0;
    Loop.∆íTimeFrameStartReal = 0;
    Loop.∆íTimeLastFrameGameAvg = 0;
    Loop.∆íTimeLastFrameRealAvg = 0;
    Loop.∆íFrames = 0;
    Loop.running = false;
    Loop.mode = LOOP_MODE.FRAME_REQUEST;
    Loop.idIntervall = 0;
    Loop.idRequest = 0;
    Loop.fpsDesired = 30;
    Loop.framesToAverage = 30;
    Loop.syncWithAnimationFrame = false;
    FudgeCore.Loop = Loop;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Instances of this class generate a timestamp that correlates with the time elapsed since the start of the program but allows for resetting and scaling.
     * Supports {@link Timer}s similar to window.setInterval but with respect to the scaled time.
     * All time values are given in milliseconds
     *
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Time extends FudgeCore.EventTarget∆í {
        constructor() {
            super();
            this.timers = {};
            this.idTimerAddedLast = 0;
            this.start = performance.now();
            this.scale = 1.0;
            this.offset = 0.0;
            this.lastCallToElapsed = 0.0;
        }
        /**
         * Returns the game-time-object which starts automatically and serves as base for various internal operations.
         */
        // public static get game(): Time {
        //   return Time.gameTime;
        // }
        static getUnits(_milliseconds) {
            let units = {};
            units.asSeconds = _milliseconds / 1000;
            units.asMinutes = units.asSeconds / 60;
            units.asHours = units.asMinutes / 60;
            units.hours = Math.floor(units.asHours);
            units.minutes = Math.floor(units.asMinutes) % 60;
            units.seconds = Math.floor(units.asSeconds) % 60;
            units.fraction = _milliseconds % 1000;
            units.thousands = _milliseconds % 10;
            units.hundreds = _milliseconds % 100 - units.thousands;
            units.tenths = units.fraction - units.hundreds - units.thousands;
            return units;
        }
        //#region Get/Set time and scaling
        /**
         * Retrieves the current scaled timestamp of this instance in milliseconds
         */
        get() {
            return this.offset + this.scale * (performance.now() - this.start);
        }
        /**
         * Returns the remaining time to the given point of time
         */
        getRemainder(_to) {
            return _to - this.get();
        }
        /**
         * (Re-) Sets the timestamp of this instance
         * @param _time The timestamp to represent the current time (default 0.0)
         */
        set(_time = 0) {
            this.offset = _time;
            this.start = performance.now();
            this.getElapsedSincePreviousCall();
        }
        /**
         * Sets the scaling of this time, allowing for slowmotion (<1) or fastforward (>1)
         * @param _scale The desired scaling (default 1.0)
         */
        setScale(_scale = 1.0) {
            this.set(this.get());
            this.scale = _scale;
            //TODO: catch scale=0
            this.rescaleAllTimers();
            this.getElapsedSincePreviousCall();
            this.dispatchEvent(new Event("timeScaled" /* TIME_SCALED */));
        }
        /**
         * Retrieves the current scaling of this time
         */
        getScale() {
            return this.scale;
        }
        /**
         * Retrieves the offset of this time
         */
        getOffset() {
            return this.offset;
        }
        /**
         * Retrieves the scaled time in milliseconds passed since the last call to this method
         * Automatically reset at every call to set(...) and setScale(...)
         */
        getElapsedSincePreviousCall() {
            let current = this.get();
            let elapsed = current - this.lastCallToElapsed;
            this.lastCallToElapsed = current;
            return elapsed;
        }
        //#endregion
        //#region Timers
        /**
         * Returns a Promise<void> to be resolved after the time given. To be used with async/await
         */
        delay(_lapse) {
            return new Promise(_resolve => this.setTimer(_lapse, 1, () => _resolve()));
        }
        // TODO: examine if web-workers would enhance performance here!
        /**
         * Stops and deletes all {@link Timer}s attached. Should be called before this Time-object leaves scope
         */
        clearAllTimers() {
            for (let id in this.timers) {
                this.deleteTimer(Number(id));
            }
        }
        /**
         * Deletes {@link Timer} found using the internal id of the connected interval-object
         * @param _id
         */
        deleteTimerByItsInternalId(_id) {
            for (let id in this.timers) {
                let timer = this.timers[id];
                if (timer.id == _id) {
                    timer.clear();
                    delete this.timers[id];
                    // TODO: check if an early out is OK here... should be!
                }
            }
        }
        /**
         * Installs a timer at this time object
         * @param _lapse The object-time to elapse between the calls to _callback
         * @param _count The number of calls desired, 0 = Infinite
         * @param _handler The function to call each the given lapse has elapsed
         * @param _arguments Additional parameters to pass to callback function
         */
        setTimer(_lapse, _count, _handler, ..._arguments) {
            // tslint:disable-next-line: no-unused-expression
            new FudgeCore.Timer(this, _lapse, _count, _handler, _arguments);
            //this.addTimer(timer);
            return this.idTimerAddedLast;
        }
        /**
         * This method is called internally by {@link Time} and {@link Timer} and must not be called otherwise
         */
        addTimer(_timer) {
            this.timers[++this.idTimerAddedLast] = _timer;
            return this.idTimerAddedLast;
        }
        /**
         * Deletes the timer with the id given by this time object
         */
        deleteTimer(_id) {
            let timer = this.timers[_id];
            if (!timer)
                return;
            timer.clear();
            delete this.timers[_id];
        }
        /**
         * Returns a reference to the timer with the given id or null if not found.
         */
        getTimer(_id) {
            return this.timers[_id];
        }
        /**
         * Returns a copy of the list of timers currently installed on this time object
         */
        getTimers() {
            let result = {};
            return Object.assign(result, this.timers);
        }
        /**
         * Returns true if there are {@link Timers} installed to this
         */
        hasTimers() {
            return (Object.keys(this.timers).length > 0);
        }
        /**
         * Recreates {@link Timer}s when scaling changes
         */
        rescaleAllTimers() {
            for (let id in this.timers) {
                let timer = this.timers[id];
                timer.clear();
                delete this.timers[id];
                if (!this.scale)
                    // Time has stopped, no need to replace cleared timers
                    continue;
                /* this.timers[id] =  */
                timer = timer.installCopy(); // the timer is automatically added to this time instance
                delete this.timers[this.idTimerAddedLast]; // remove the copy again ...
                this.timers[id] = timer; // ... and place it at the id of the original
            }
        }
    }
    /** Standard game time starting automatically with the application */
    Time.game = new Time();
    FudgeCore.Time = Time;
    //#endregion
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A {@link Timer}-instance internally uses window.setInterval to call a given handler with a given frequency a given number of times,
     * passing an {@link EventTimer}-instance with additional information and given arguments.
     * The frequency scales with the {@link Time}-instance the {@link Timer}-instance is attached to.
     *
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Timer {
        /**
         * Creates a {@link Timer} instance.
         * @param _time The {@link Time} instance, the timer attaches to
         * @param _elapse The time in milliseconds to elapse, to the next call of _handler, measured in _time
         * @param _count The desired number of calls to _handler, Timer deinstalls automatically after last call. Passing 0 invokes infinite calls
         * @param _handler The {@link TimerHandler} instance to call
         * @param _arguments Additional arguments to pass to _handler
         *
         * TODO: for proper handling and deletion, use Time.setTimer instead of instantiating timers yourself.
         */
        constructor(_time, _elapse, _count, _handler, ..._arguments) {
            this.time = _time;
            this.elapse = _elapse;
            this.event = new FudgeCore.EventTimer(this, _arguments);
            this.handler = _handler;
            this.count = _count;
            let scale = Math.abs(_time.getScale());
            if (!scale) {
                // Time is stopped, timer won't be active
                this.active = false;
                return;
            }
            this.timeoutReal = this.elapse / scale;
            let callback = () => {
                if (!this.active)
                    return;
                this.event.count = this.count;
                this.event.lastCall = (this.count == 1);
                _handler(this.event);
                this.event.firstCall = false;
                if (this.count > 0)
                    if (--this.count == 0)
                        _time.deleteTimerByItsInternalId(this.idWindow);
            };
            this.idWindow = window.setInterval(callback, this.timeoutReal, _arguments);
            this.active = true;
            _time.addTimer(this);
        }
        /**
         * Returns the window-id of the timer, which was returned by setInterval
         */
        get id() {
            return this.idWindow;
        }
        /**
         * Returns the time-intervall for calls to the handler
         */
        get lapse() {
            return this.elapse;
        }
        /**
         * Attaches a copy of this at its current state to the same {@link Time}-instance. Used internally when rescaling {@link Time}
         */
        installCopy() {
            return new Timer(this.time, this.elapse, this.count, this.handler, this.event.arguments);
        }
        /**
         * Clears the timer, removing it from the interval-timers handled by window
         */
        clear() {
            // if (this.type == TIMER_TYPE.TIMEOUT) {
            //     if (this.active)
            //         // save remaining time to timeout as new timeout for restart
            //         this.timeout = this.timeout * (1 - (performance.now() - this.startTimeReal) / this.timeoutReal);
            //     window.clearTimeout(this.id);
            // }
            // else
            // TODO: reusing timer starts interval anew. Should be remaining interval as timeout, then starting interval anew 
            window.clearInterval(this.idWindow);
            this.active = false;
        }
    }
    FudgeCore.Timer = Timer;
})(FudgeCore || (FudgeCore = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRnVkZ2VDb3JlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vU291cmNlL0RlYnVnL0RlYnVnVGFyZ2V0LnRzIiwiLi4vU291cmNlL0RlYnVnL0RlYnVnSW50ZXJmYWNlcy50cyIsIi4uL1NvdXJjZS9EZWJ1Zy9EZWJ1Z0NvbnNvbGUudHMiLCIuLi9Tb3VyY2UvRGVidWcvRGVidWcudHMiLCIuLi9Tb3VyY2UvRXZlbnQvRXZlbnQudHMiLCIuLi9Tb3VyY2UvU2VyaWFsaXphdGlvbi9NdXRhYmxlLnRzIiwiLi4vU291cmNlL1NlcmlhbGl6YXRpb24vU2VyaWFsaXplci50cyIsIi4uL1NvdXJjZS9Db21wb25lbnQvQ29tcG9uZW50LnRzIiwiLi4vU291cmNlL1JlY3ljbGUvUmVjeWNhYmxlQXJyYXkudHMiLCIuLi9Tb3VyY2UvUmVuZGVyL1JlbmRlckluamVjdG9yLnRzIiwiLi4vU291cmNlL1JlbmRlci9SZW5kZXJJbmplY3RvclNoYWRlci50cyIsIi4uL1NvdXJjZS9SZW5kZXIvUmVuZGVySW5qZWN0b3JDb2F0LnRzIiwiLi4vU291cmNlL1JlbmRlci9SZW5kZXJJbmplY3Rvck1lc2gudHMiLCIuLi9Tb3VyY2UvUmVjeWNsZS9SZWN5Y2xlci50cyIsIi4uL1NvdXJjZS9NYXRoL1ZlY3RvcjIudHMiLCIuLi9Tb3VyY2UvTWF0aC9SZWN0YW5nbGUudHMiLCIuLi9Tb3VyY2UvUmVuZGVyL1JlbmRlcldlYkdMLnRzIiwiLi4vU291cmNlL1JlbmRlci9SZW5kZXJJbmplY3RvclRleHR1cmUudHMiLCIuLi9Tb3VyY2UvR3JhcGgvTm9kZS50cyIsIi4uL1NvdXJjZS9QaHlzaWNzL0hlbHBlcnNQaHlzaWNzLnRzIiwiLi4vU291cmNlL1BoeXNpY3MvSm9pbnQudHMiLCIuLi9Tb3VyY2UvUGh5c2ljcy9Kb2ludEF4aWFsLnRzIiwiLi4vU291cmNlL1JlZmVyZW5jZXMudHMiLCIuLi9Tb3VyY2UvQW5pbWF0aW9uL0FuaW1hdGlvbi50cyIsIi4uL1NvdXJjZS9BbmltYXRpb24vQW5pbWF0aW9uRnVuY3Rpb24udHMiLCIuLi9Tb3VyY2UvQW5pbWF0aW9uL0FuaW1hdGlvbktleS50cyIsIi4uL1NvdXJjZS9BbmltYXRpb24vQW5pbWF0aW9uU2VxdWVuY2UudHMiLCIuLi9Tb3VyY2UvQXVkaW8vQXVkaW8udHMiLCIuLi9Tb3VyY2UvQXVkaW8vQXVkaW9NYW5hZ2VyLnRzIiwiLi4vU291cmNlL0F1ZGlvL0F1ZGlvT3NjaWxsYXRvci50cyIsIi4uL1NvdXJjZS9Db21wb25lbnQvQ29tcG9uZW50QW5pbWF0b3IudHMiLCIuLi9Tb3VyY2UvQ29tcG9uZW50L0NvbXBvbmVudEF1ZGlvLnRzIiwiLi4vU291cmNlL0NvbXBvbmVudC9Db21wb25lbnRBdWRpb0xpc3RlbmVyLnRzIiwiLi4vU291cmNlL0NvbXBvbmVudC9Db21wb25lbnRDYW1lcmEudHMiLCIuLi9Tb3VyY2UvTGlnaHQvTGlnaHQudHMiLCIuLi9Tb3VyY2UvQ29tcG9uZW50L0NvbXBvbmVudExpZ2h0LnRzIiwiLi4vU291cmNlL0NvbXBvbmVudC9Db21wb25lbnRNYXRlcmlhbC50cyIsIi4uL1NvdXJjZS9Db21wb25lbnQvQ29tcG9uZW50TWVzaC50cyIsIi4uL1NvdXJjZS9Db21wb25lbnQvQ29tcG9uZW50U2NyaXB0LnRzIiwiLi4vU291cmNlL0NvbXBvbmVudC9Db21wb25lbnRUcmFuc2Zvcm0udHMiLCIuLi9Tb3VyY2UvQ29udHJvbC9Db250cm9sLnRzIiwiLi4vU291cmNlL0NvbnRyb2wvQXhpcy50cyIsIi4uL1NvdXJjZS9Db250cm9sL0tleWJvYXJkLnRzIiwiLi4vU291cmNlL0RlYnVnL0RlYnVnQWxlcnQudHMiLCIuLi9Tb3VyY2UvRGVidWcvRGVidWdEaWFsb2cudHMiLCIuLi9Tb3VyY2UvRGVidWcvRGVidWdUZXh0QXJlYS50cyIsIi4uL1NvdXJjZS9FdmVudC9FdmVudEF1ZGlvLnRzIiwiLi4vU291cmNlL0V2ZW50L0V2ZW50RHJhZ0Ryb3AudHMiLCIuLi9Tb3VyY2UvRXZlbnQvRXZlbnRLZXlib2FyZC50cyIsIi4uL1NvdXJjZS9FdmVudC9FdmVudFBvaW50ZXIudHMiLCIuLi9Tb3VyY2UvRXZlbnQvRXZlbnRUaW1lci50cyIsIi4uL1NvdXJjZS9FdmVudC9FdmVudFdoZWVsLnRzIiwiLi4vU291cmNlL0dyYXBoL0dyYXBoLnRzIiwiLi4vU291cmNlL0dyYXBoL0dyYXBoSW5zdGFuY2UudHMiLCIuLi9Tb3VyY2UvTWF0ZXJpYWwvQ29hdC50cyIsIi4uL1NvdXJjZS9NYXRlcmlhbC9Db2F0VGV4dHVyZWQudHMiLCIuLi9Tb3VyY2UvTWF0ZXJpYWwvQ29sb3IudHMiLCIuLi9Tb3VyY2UvTWF0ZXJpYWwvTWF0ZXJpYWwudHMiLCIuLi9Tb3VyY2UvTWF0aC9GcmFtaW5nLnRzIiwiLi4vU291cmNlL01hdGgvR2VvMi50cyIsIi4uL1NvdXJjZS9NYXRoL0dlbzMudHMiLCIuLi9Tb3VyY2UvTWF0aC9MRklCNC50cyIsIi4uL1NvdXJjZS9NYXRoL01hdHJpeDN4My50cyIsIi4uL1NvdXJjZS9NYXRoL01hdHJpeDR4NC50cyIsIi4uL1NvdXJjZS9NYXRoL05vaXNlLnRzIiwiLi4vU291cmNlL01hdGgvTm9pc2UyLnRzIiwiLi4vU291cmNlL01hdGgvTm9pc2UzLnRzIiwiLi4vU291cmNlL01hdGgvTm9pc2U0LnRzIiwiLi4vU291cmNlL01hdGgvUmFuZG9tLnRzIiwiLi4vU291cmNlL01hdGgvVmVjdG9yMy50cyIsIi4uL1NvdXJjZS9NZXNoL0ZhY2UudHMiLCIuLi9Tb3VyY2UvTWVzaC9NZXNoLnRzIiwiLi4vU291cmNlL01lc2gvTWVzaEN1YmUudHMiLCIuLi9Tb3VyY2UvTWVzaC9NZXNoUG9seWdvbi50cyIsIi4uL1NvdXJjZS9NZXNoL01lc2hFeHRydXNpb24udHMiLCIuLi9Tb3VyY2UvTWVzaC9NZXNoRnJvbURhdGEudHMiLCIuLi9Tb3VyY2UvTWVzaC9NZXNoT2JqLnRzIiwiLi4vU291cmNlL01lc2gvTWVzaFB5cmFtaWQudHMiLCIuLi9Tb3VyY2UvTWVzaC9NZXNoUXVhZC50cyIsIi4uL1NvdXJjZS9NZXNoL01lc2hUZXJyYWluLnRzIiwiLi4vU291cmNlL01lc2gvTWVzaFJlbGllZi50cyIsIi4uL1NvdXJjZS9NZXNoL01lc2hSb3RhdGlvbi50cyIsIi4uL1NvdXJjZS9NZXNoL01lc2hTcGhlcmUudHMiLCIuLi9Tb3VyY2UvTWVzaC9NZXNoU3ByaXRlLnRzIiwiLi4vU291cmNlL01lc2gvTWVzaFRvcnVzLnRzIiwiLi4vU291cmNlL01lc2gvUXVhZC50cyIsIi4uL1NvdXJjZS9NZXNoL1ZlcnRleC50cyIsIi4uL1NvdXJjZS9NZXNoL1ZlcnRpY2VzLnRzIiwiLi4vU291cmNlL1BoeXNpY3MvQ29tcG9uZW50UmlnaWRib2R5LnRzIiwiLi4vU291cmNlL1BoeXNpY3MvRGVidWdQaHlzaWNzRHJhdy50cyIsIi4uL1NvdXJjZS9QaHlzaWNzL0pvaW50Q3lsaW5kcmljYWwudHMiLCIuLi9Tb3VyY2UvUGh5c2ljcy9Kb2ludFByaXNtYXRpYy50cyIsIi4uL1NvdXJjZS9QaHlzaWNzL0pvaW50UmFnZG9sbC50cyIsIi4uL1NvdXJjZS9QaHlzaWNzL0pvaW50UmV2b2x1dGUudHMiLCIuLi9Tb3VyY2UvUGh5c2ljcy9Kb2ludFNwaGVyaWNhbC50cyIsIi4uL1NvdXJjZS9QaHlzaWNzL0pvaW50VW5pdmVyc2FsLnRzIiwiLi4vU291cmNlL1BoeXNpY3MvSm9pbnRXZWxkaW5nLnRzIiwiLi4vU291cmNlL1BoeXNpY3MvUGh5c2ljcy50cyIsIi4uL1NvdXJjZS9QaHlzaWNzL1F1YXRlcm5pb24udHMiLCIuLi9Tb3VyY2UvUmF5L0JveC50cyIsIi4uL1NvdXJjZS9SYXkvUGljay50cyIsIi4uL1NvdXJjZS9SYXkvUGlja2VyLnRzIiwiLi4vU291cmNlL1JheS9SYXkudHMiLCIuLi9Tb3VyY2UvUmVuZGVyL1JlbmRlci50cyIsIi4uL1NvdXJjZS9SZW5kZXIvUmVuZGVyUGFydGljbGVzLnRzIiwiLi4vU291cmNlL1JlbmRlci9WaWV3cG9ydC50cyIsIi4uL1NvdXJjZS9TZXJpYWxpemF0aW9uL0ZpbGVJb0Jyb3dzZXJMb2NhbC50cyIsIi4uL1NvdXJjZS9TZXJpYWxpemF0aW9uL011dGFibGVBcnJheS50cyIsIi4uL1NvdXJjZS9TZXJpYWxpemF0aW9uL1Byb2plY3QudHMiLCIuLi9Tb3VyY2UvU2hhZGVyL1NoYWRlci50cyIsIi4uL1NvdXJjZS9TaGFkZXIvQnVpbGQvU2hhZGVyRmxhdC50cyIsIi4uL1NvdXJjZS9TaGFkZXIvQnVpbGQvU2hhZGVyRmxhdFRleHR1cmVkLnRzIiwiLi4vU291cmNlL1NoYWRlci9CdWlsZC9TaGFkZXJHb3VyYXVkLnRzIiwiLi4vU291cmNlL1NoYWRlci9CdWlsZC9TaGFkZXJHb3VyYXVkVGV4dHVyZWQudHMiLCIuLi9Tb3VyY2UvU2hhZGVyL0J1aWxkL1NoYWRlckxpdC50cyIsIi4uL1NvdXJjZS9TaGFkZXIvQnVpbGQvU2hhZGVyTGl0VGV4dHVyZWQudHMiLCIuLi9Tb3VyY2UvU2hhZGVyL0J1aWxkL1NoYWRlck1hdENhcC50cyIsIi4uL1NvdXJjZS9TaGFkZXIvQnVpbGQvU2hhZGVyUGhvbmcudHMiLCIuLi9Tb3VyY2UvU2hhZGVyL0J1aWxkL1NoYWRlclBpY2sudHMiLCIuLi9Tb3VyY2UvU2hhZGVyL0J1aWxkL1NoYWRlclBpY2tUZXh0dXJlZC50cyIsIi4uL1NvdXJjZS9UZXh0dXJlL1RleHR1cmUudHMiLCIuLi9Tb3VyY2UvVGV4dHVyZS9UZXh0dXJlRGVmYXVsdC50cyIsIi4uL1NvdXJjZS9UaW1lL0xvb3AudHMiLCIuLi9Tb3VyY2UvVGltZS9UaW1lLnRzIiwiLi4vU291cmNlL1RpbWUvVGltZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLElBQVUsU0FBUyxDQWdCbEI7QUFoQkQsV0FBVSxTQUFTO0lBQ2pCOztPQUVHO0lBQ0gsTUFBc0IsV0FBVztRQUV4QixNQUFNLENBQUMsY0FBYyxDQUFDLFFBQWdCLEVBQUUsR0FBRyxLQUFlO1lBQy9ELElBQUksR0FBRyxHQUFXLFFBQVEsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLDJCQUEyQjtZQUNs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QzNDLElBQUksR0FBRyxHQUFXLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUMzQyxJQUFJLEdBQUcsR0FBVyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDM0MsSUFBSSxHQUFHLEdBQVcsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQzNDLElBQUksR0FBRyxHQUFXLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUM1QyxJQUFJLEdBQUcsR0FBVyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDNUMsSUFBSSxHQUFHLEdBQVcsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQzVDLElBQUksR0FBRyxHQUFXLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUM1QyxJQUFJLEdBQUcsR0FBVyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDNUMsSUFBSSxHQUFHLEdBQVcsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQzVDLElBQUksR0FBRyxHQUFXLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUM1QyxJQUFJLEdBQUcsR0FBVyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDNUMsSUFBSSxHQUFHLEdBQVcsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMs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Q0FBQyxRQUFtQixFQUFFLFNBQW9CO1lBQ3BFLElBQUksQ0FBQyxHQUFpQixRQUFRLENBQUMsSUFBSSxDQUFDO1lBQ3BDLElBQUksQ0FBQyxHQUFpQixTQUFTLENBQUMsSUFBSSxDQUFDO1lBQ3JDLDJDQUEyQztZQUMzQyxNQUFNLFNBQVMsR0FBYyxVQUFBLFFBQVEsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDckQsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQ2hCO2dCQUNFLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2dCQUM3QyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztnQkFDN0MsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7Z0JBQzdDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2dCQUM3QyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztnQkFDN0MsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7Z0JBQzdDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2dCQUM3QyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztnQkFDN0MsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7Z0JBQzdDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2dCQUM3QyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztnQkFDN0MsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7Z0JBQzdDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2dCQUM3QyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztnQkFDN0MsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7Z0JBQzdDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2FBQzlDLENBQUMsQ0FBQztZQUNMLE9BQU8sU0FBUyxDQUFDO1FBQ25CLENBQUM7UUFFRDs7V0FFRztRQUNJLE1BQU0sQ0FBQyxTQUFTLENBQUMsSUFBZTtZQUNyQyxJQUFJLENBQUMsR0FBaUIsSUFBSSxDQUFDLElBQUksQ0FBQztZQUNoQyxJQUFJLE1BQU0sR0FBYyxVQUFBLFFBQVEsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDaEQsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUM7Z0JBQ2QsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQztnQkFDdkIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQztnQkFDdkIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQztnQkFDeEIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQzthQUN6QixDQUFDLENBQUM7WUFDSCxPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO1FBRUQ7OztXQUdHO1FBQ0ksTUFBTSxDQUFDLFNBQVMsQ0FBQyxJQUFlO1lBQ3JDLElBQUksQ0FBQyxHQUFpQixJQUFJLENBQUMsSUFBSSxDQUFDO1lBQ2hDLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksSUFBSSxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDN0IsSUFBSSxJQUFJLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM3QixJQUFJLElBQUksR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzdCLElBQUksSUFBSSxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDN0IsSUFBSSxJQUFJLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM3QixJQUFJLElBQUksR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzdCLElBQUksSUFBSSxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDN0IsSUFBSSxJQUFJLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM3QixJQUFJLElBQUksR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzdCLElBQUksSUFBSSxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDN0IsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzlCLElBQUksS0FBSyxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDOUIsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzlCLElBQUksS0FBSyxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDOUIsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzlCLElBQUksS0FBSyxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDOUIsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzlCLElBQUksS0FBSyxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDOUIsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBRTlCLElBQUksRUFBRSxHQUFXLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLENBQUM7Z0JBQ3JELENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQztZQUV6QyxJQUFJLEVBQUUsR0FBVyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDO2dCQUNyRCxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUM7WUFDekMsSUFBSSxFQUFFLEdBQVcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQztnQkFDdEQsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO1lBQzFDLElBQUksRUFBRSxHQUFXLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUM7Z0JBQ3RELENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsQ0FBQztZQUUxQyxJQUFJLENBQUMsR0FBVyxHQUFHLEdBQUcsQ0FBQyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxDQUFDLENBQUM7WUFFbEUsTUFBTSxTQUFTLEdBQWMsVUFBQSxRQUFRLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQ3JELFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDO2dCQUNqQixDQUFDLEdBQUcsRUFBRTtnQkFDTixDQUFDLEdBQUcsRUFBRTtnQkFDTixDQUFDLEdBQUcsRUFBRTtnQkFDTixDQUFDLEdBQUcsRUFBRTtnQkFDTixDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUNyRixDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUNyRixDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUN2RixDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUN2RixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUMzRixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUMzRixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUMzRixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUMzRixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUMzRixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxH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Q0FBQyxJQUFJLENBQUM7WUFDaEMsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxJQUFJLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM3QixJQUFJLElBQUksR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzdCLElBQUksSUFBSSxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDN0IsSUFBSSxJQUFJLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM3QixJQUFJLElBQUksR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzdCLElBQUksSUFBSSxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDN0IsSUFBSSxJQUFJLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM3QixJQUFJLElBQUksR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzdCLElBQUksSUFBSSxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDN0IsSUFBSSxJQUFJLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM3QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzlCLElBQUksS0FBSyxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDOUIsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzlCLElBQUksS0FBSyxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDOUIsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzlCLElBQUksS0FBSyxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDOUIsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzlCLElBQUksS0FBSyxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDOUIsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzlCLElBQUksS0FBSyxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFFOUIsSUFBSSxFQUFFLEdBQVcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsQ0FBQztnQkFDckQsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDO1lBRXpDLElBQUksRUFBRSxHQUFXLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLENBQUM7Z0JBQ3JELENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQztZQUN6QyxJQUFJLEVBQUUsR0FBVyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDO2dCQUN0RCxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLENBQUM7WUFDMUMsSUFBSSxFQUFFLEdBQVcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQztnQkFDdEQsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO1lBRTFDLElBQUksQ0FBQyxHQUFXLEdBQUcsR0FBRyxDQUFDLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLENBQUMsQ0FBQztZQUVsRSx5Q0FBeUM7WUFDekMsTUFBTSxNQUFNLEdBQWMsVUFBQSxRQUFRLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQ2xELE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDO2dCQUNkLENBQUMsR0FBRyxFQUFFO2dCQUNOLENBQUMsR0FBRyxFQUFFO2dCQUNOLENBQUMsR0FBRyxFQUFFO2dCQUNOLENBQUMsR0FBRyxFQUFFO2dCQUNOLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUM7Z0JBQ3JGLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUM7Z0JBQ3JGLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLENBQUM7Z0JBQ3ZGLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLENBQUM7Z0JBQ3ZGLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLENBQUM7Z0JBQzNGLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLENBQUM7Z0JBQzNGLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLENBQUM7Z0JBQzNGLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLENBQUM7Z0JBQzNGLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLENBQUM7Z0JBQzNGLENBQUMsR0FBRyxDQUFD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Q0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUN0QyxNQUFNLEVBQUUsR0FBVyxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFFdEMsK0VBQStFO2dCQUMvRSxNQUFNLEVBQUUsR0FBVyxFQUFFLEdBQUcsRUFBRSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxnREFBZ0Q7Z0JBQzVGLE1BQU0sRUFBRSxHQUFXLEVBQUUsR0FBRyxFQUFFLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQztnQkFDM0MsTUFBTSxFQUFFLEdBQVcsRUFBRSxHQUFHLEVBQUUsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO2dCQUMzQyxNQUFNLEVBQUUsR0FBVyxFQUFFLEdBQUcsRUFBRSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7Z0JBQzNDLE1BQU0sRUFBRSxHQUFXLEVBQUUsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQywrQ0FBK0M7Z0JBQ2pHLE1BQU0sRUFBRSxHQUFXLEVBQUUsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7Z0JBQ2pELE1BQU0sRUFBRSxHQUFXLEVBQUUsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7Z0JBQ2pELE1BQU0sRUFBRSxHQUFXLEVBQUUsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7Z0JBQ2pELE1BQU0sRUFBRSxHQUFXLEVBQUUsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxnREFBZ0Q7Z0JBQ2xHLE1BQU0sRUFBRSxHQUFXLEVBQUUsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7Z0JBQ2pELE1BQU0sRUFBRSxHQUFXLEVBQUUsR0FBRyxFQUFFLEdBQUcsR0FBRyxH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QUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7Z0JBQzFFLE1BQU0sRUFBRSxHQUFXLEdBQUcsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDO2dCQUMvRCxNQUFNLEVBQUUsR0FBVyxFQUFFLEdBQUcsQ0FBQztvQkFDdkIsQ0FBQyxDQUFDLEdBQUc7b0JBQ0wsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO2dCQUMxRSxNQUFNLEVBQUUsR0FBVyxHQUFHLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQztnQkFDL0QsTUFBTSxFQUFFLEdBQVcsRUFBRSxHQUFHLENBQUM7b0JBQ3ZCLENBQUMsQ0FBQyxHQUFHO29CQUNMLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztnQkFFMUUsd0RBQXdEO2dCQUN4RCxPQUFPLGlCQUFpQixHQUFHLENBQUMsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO1lBQ3RELENBQUMsQ0FBQztRQUNKLENBQUM7UUF2SUQsT0FBTyxDQUFvRTs7SUFGNUQsYUFBTSxHQUFXLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7SUFDL0MsZUFBUSxHQUFlLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FB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RUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLElBQUksVUFBQSxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSTtZQUNqRSxJQUFJLFVBQUEsTUFBTSxDQUFDLElBQUksVUFBQSxPQUFPLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLElBQUksVUFBQSxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSTtZQUNoRSxhQUFhO1lBQ2IsSUFBSSxVQUFBLE1BQU0sQ0FBQyxDQUFDLEVBQUUsSUFBSSxVQUFBLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJO1lBQ3RDLElBQUksVUFBQSxNQUFNLENBQUMsQ0FBQyxFQUFFLElBQUksVUFBQSxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSTtZQUN0QyxJQUFJLFVBQUEsTUFBTSxDQUFDLENBQUMsRUFBRSxJQUFJLFVBQUEsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUs7WUFDdkMsSUFBSSxVQUFBLE1BQU0sQ0FBQyxDQUFDLEVBQUUsSUFBSSxVQUFBLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLO1lBQ3ZDLElBQUksVUFBQSxNQUFNLENBQUMsQ0FBQyxFQUFFLElBQUksVUFBQSxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSztZQUN2QyxJQUFJLFVBQUEsTUFBTSxDQUFDLENBQUMsRUFBRSxJQUFJLFVBQUEsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUs7WUFDdkMsSUFBSSxVQUFBLE1BQU0sQ0FBQyxDQUFDLEVBQUUsSUFBSSxVQUFBLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLO1lBQ3ZDLElBQUksVUFBQSxNQUFNLENBQUMsQ0FBQyxF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QUFJLEtBQUssR0FBYyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUM3TSxJQUFJLFFBQVEsR0FBYyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLFdBQVcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsQ0FBQyxFQUFFLFlBQVksQ0FBQyxXQUFXLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLENBQUMsRUFBRSxZQUFZLENBQUMsV0FBVyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN0TixJQUFJLFFBQVEsR0FBYyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNwTSxJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssRUFBRSxhQUFhLENBQUMsQ0FBQztZQUMxQywrRUFBK0U7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QUVHO1FBQ0gsSUFBVyxFQUFFO1lBQ1gsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDO1FBQ3ZCLENBQUM7UUFFRDs7V0FFRztRQUNILElBQVcsS0FBSztZQUNkLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUNyQixDQUFDO1FBRUQ7O1dBRUc7UUFDSSxXQUFXO1lBQ2hCLE9BQU8sSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQzNGLENBQUM7UUFFRDs7V0FFRztRQUNJLEtBQUs7WUFDVix5Q0FBeUM7WUFDekMsdUJBQXVCO1lBQ3ZCLHVFQUF1RTtZQUN2RSwyR0FBMkc7WUFDM0csb0NBQW9DO1lBQ3BDLElBQUk7WUFDSixPQUFPO1lBQ1Asa0hBQWtIO1lBQ2xILE1BQU0sQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ3BDLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO1FBQ3RCLENBQUM7S0FDRjtJQTdGWSxlQUFLLFFBNkZqQixDQUFBO0FBQ0gsQ0FBQyxFQTNHUyxTQUFTLEtBQVQsU0FBUyxRQTJHbEIiLCJzb3VyY2VzQ29udGVudCI6WyJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBCYXNlIGNsYXNzIGZvciB0aGUgZGlmZmVyZW50IERlYnVnVGFyZ2V0cywgbWFpbmx5IGZvciB0ZWNobmljYWwgcHVycG9zZSBvZiBpbmhlcml0YW5jZVxyXG4gICAqL1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBEZWJ1Z1RhcmdldCB7XHJcbiAgICBwdWJsaWMgZGVsZWdhdGVzOiBNYXBEZWJ1Z0ZpbHRlclRvRGVsZWdhdGU7XHJcbiAgICBwdWJsaWMgc3RhdGljIG1lcmdlQXJndW1lbnRzKF9tZXNzYWdlOiBPYmplY3QsIC4uLl9hcmdzOiBPYmplY3RbXSk6IHN0cmluZyB7XHJcbiAgICAgIGxldCBvdXQ6IHN0cmluZyA9IF9tZXNzYWdlLnRvU3RyaW5nKCk7IC8vSlNPTi5zdHJpbmdpZnkoX21lc3NhZ2UpO1xyXG4gICAgICBmb3IgKGxldCBhcmcgb2YgX2FyZ3MpXHJcbiAgICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIE51bWJlcilcclxuICAgICAgICAgIG91dCArPSBcIiwgXCIgKyBhcmcudG9QcmVjaXNpb24oMikudG9TdHJpbmcoKTsgLy9KU09OLnN0cmluZ2lmeShhcmcsIG51bGwsIDIpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIG91dCArPSBcIiwgXCIgKyBhcmcudG9TdHJpbmcoKTsgLy9KU09OLnN0cmluZ2lmeShhcmcsIG51bGwsIDIpO1xyXG4gICAgICByZXR1cm4gb3V0O1xyXG4gICAgfVxyXG4gIH1cclxufSIsIi8vIDxyZWZlcmVuY2UgcGF0aD1cIkRlYnVnQWxlcnQudHNcIi8+XHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFRoZSBmaWx0ZXJzIGNvcnJlc3BvbmRpbmcgdG8gZGVidWcgYWN0aXZpdGllcywgbW9yZSB0byBjb21lXHJcbiAgICovXHJcbiAgZXhwb3J0IGVudW0gREVCVUdfRklMVEVSIHtcclxuICAgIE5PTkUgPSAweDAwLFxyXG4gICAgSU5GTyA9IDB4MDEsXHJcbiAgICBMT0cgPSAweDAyLFxyXG4gICAgV0FSTiA9IDB4MDQsXHJcbiAgICBFUlJPUiA9IDB4MDgsXHJcbiAgICBGVURHRSA9IDB4MTAsXHJcbiAgICBDTEVBUiA9IDB4MTAwLFxyXG4gICAgR1JPVVAgPSAweDEwMSxcclxuICAgIEdST1VQQ09MTEFQU0VEID0gMHgxMDIsXHJcbiAgICBHUk9VUEVORCA9IDB4MTA0LFxyXG4gICAgU09VUkNFID0gMHgyMDAsXHJcbiAgICBNRVNTQUdFUyA9IElORk8gfCBMT0cgfCBXQVJOIHwgRVJST1IgfCBGVURHRSxcclxuICAgIEZPUk1BVCA9IENMRUFSIHwgR1JPVVAgfCBHUk9VUENPTExBUFNFRCB8IEdST1VQRU5ELFxyXG4gICAgQUxMID0gTUVTU0FHRVMgfCBGT1JNQVRcclxuICB9XHJcblxyXG4gIGV4cG9ydCBjb25zdCBERUJVR19TWU1CT0w6IHsgW2ZpbHRlcjogbnVtYmVyXTogc3RyaW5nOyB9ID0ge1xyXG4gICAgW0RFQlVHX0ZJTFRFUi5JTkZPXTogXCLinJNcIixcclxuICAgIFtERUJVR19GSUxURVIuTE9HXTogXCLinI5cIixcclxuICAgIFtERUJVR19GSUxURVIuV0FSTl06IFwi4pqgXCIsXHJcbiAgICBbREVCVUdfRklMVEVSLkVSUk9SXTogXCLinYxcIixcclxuICAgIFtERUJVR19GSUxURVIuRlVER0VdOiBcIvCfjrJcIixcclxuICAgIFtERUJVR19GSUxURVIuU09VUkNFXTogXCLwn5SXXCJcclxuICB9O1xyXG5cclxuICBleHBvcnQgdHlwZSBNYXBEZWJ1Z1RhcmdldFRvRGVsZWdhdGUgPSBNYXA8RGVidWdUYXJnZXQsIEZ1bmN0aW9uPjtcclxuICBleHBvcnQgaW50ZXJmYWNlIE1hcERlYnVnRmlsdGVyVG9EZWxlZ2F0ZSB7IFtmaWx0ZXI6IG51bWJlcl06IEZ1bmN0aW9uOyB9XHJcbn0iLCIvLyAvIDxyZWZlcmVuY2UgcGF0aD1cIkRlYnVnVGFyZ2V0LnRzXCIvPlxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBSb3V0aW5nIHRvIHRoZSBzdGFuZGFyZC1jb25zb2xlXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIERlYnVnQ29uc29sZSBleHRlbmRzIERlYnVnVGFyZ2V0IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgZGVsZWdhdGVzOiBNYXBEZWJ1Z0ZpbHRlclRvRGVsZWdhdGUgPSB7XHJcbiAgICAgIFtERUJVR19GSUxURVIuSU5GT106IGNvbnNvbGUuaW5mbyxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5MT0ddOiBjb25zb2xlLmxvZyxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5XQVJOXTogY29uc29sZS53YXJuLFxyXG4gICAgICBbREVCVUdfRklMVEVSLkVSUk9SXTogY29uc29sZS5lcnJvcixcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5GVURHRV06IERlYnVnQ29uc29sZS5mdWRnZSxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5DTEVBUl06IGNvbnNvbGUuY2xlYXIsXHJcbiAgICAgIFtERUJVR19GSUxURVIuR1JPVVBdOiBjb25zb2xlLmdyb3VwLFxyXG4gICAgICBbREVCVUdfRklMVEVSLkdST1VQQ09MTEFQU0VEXTogY29uc29sZS5ncm91cENvbGxhcHNlZCxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5HUk9VUEVORF06IGNvbnNvbGUuZ3JvdXBFbmQsXHJcbiAgICAgIFtERUJVR19GSUxURVIuU09VUkNFXTogRGVidWdDb25zb2xlLnNvdXJjZVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNob3VsZCBiZSB1c2VkIHRvIGRpc3BsYXkgdW5jcml0aWNhbCBzdGF0ZSBpbmZvcm1hdGlvbiBvZiBGVURHRSwgb25seSB2aXNpYmxlIGluIGJyb3dzZXIncyB2ZXJib3NlIG1vZGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBmdWRnZShfbWVzc2FnZTogT2JqZWN0LCAuLi5fYXJnczogT2JqZWN0W10pOiB2b2lkIHtcclxuICAgICAgY29uc29sZS5kZWJ1ZyhERUJVR19TWU1CT0xbREVCVUdfRklMVEVSLkZVREdFXSwgX21lc3NhZ2UsIC4uLl9hcmdzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERpc3BsYXlzIGFuIGV4dHJhIGxpbmUgd2l0aCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgc291cmNlIG9mIHRoZSBkZWJ1ZyBtZXNzYWdlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc291cmNlKF9tZXNzYWdlOiBPYmplY3QsIC4uLl9hcmdzOiBPYmplY3RbXSk6IHZvaWQge1xyXG4gICAgICBjb25zb2xlLmxvZyhERUJVR19TWU1CT0xbREVCVUdfRklMVEVSLlNPVVJDRV0sIF9tZXNzYWdlLCAuLi5fYXJncyk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwiLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCJEZWJ1Z1RhcmdldC50c1wiLz5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkRlYnVnSW50ZXJmYWNlcy50c1wiLz5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkRlYnVnQ29uc29sZS50c1wiLz5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogVGhlIERlYnVnLUNsYXNzIG9mZmVycyBmdW5jdGlvbnMga25vd24gZnJvbSB0aGUgY29uc29sZS1vYmplY3QgYW5kIGFkZGl0aW9ucywgXHJcbiAgICogcm91dGluZyB0aGUgaW5mb3JtYXRpb24gdG8gdmFyaW91cyB7QGxpbmsgRGVidWdUYXJnZXR9cyB0aGF0IGNhbiBiZSBlYXNpbHkgZGVmaW5lZCBieSB0aGUgZGV2ZWxvcGVycyBhbmQgcmVnaXN0ZXJkIGJ5IHVzZXJzXHJcbiAgICogT3ZlcnJpZGUgZnVuY3Rpb25zIGluIHN1YmNsYXNzZXMgb2Yge0BsaW5rIERlYnVnVGFyZ2V0fSBhbmQgcmVnaXN0ZXIgdGhlbSBhcyB0aGVpciBkZWxlZ2F0ZXNcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgRGVidWcge1xyXG4gICAgLyoqXHJcbiAgICAgKiBGb3IgZWFjaCBzZXQgZmlsdGVyLCB0aGlzIGFzc29jaWF0aXZlIGFycmF5IGtlZXBzIHJlZmVyZW5jZXMgdG8gdGhlIHJlZ2lzdGVyZWQgZGVsZWdhdGUgZnVuY3Rpb25zIG9mIHRoZSBjaG9zZW4ge0BsaW5rIERlYnVnVGFyZ2V0fXNcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZGVsZWdhdGVzOiB7IFtmaWx0ZXI6IG51bWJlcl06IE1hcERlYnVnVGFyZ2V0VG9EZWxlZ2F0ZSB9ID0gRGVidWcuc2V0dXBDb25zb2xlKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZS0gLyBBY3RpdmF0ZSBhIGZpbHRlciBmb3IgdGhlIGdpdmVuIERlYnVnVGFyZ2V0LiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzZXRGaWx0ZXIoX3RhcmdldDogRGVidWdUYXJnZXQsIF9maWx0ZXI6IERFQlVHX0ZJTFRFUik6IHZvaWQge1xyXG4gICAgICBmb3IgKGxldCBmaWx0ZXIgaW4gRGVidWcuZGVsZWdhdGVzKVxyXG4gICAgICAgIERlYnVnLmRlbGVnYXRlc1tmaWx0ZXJdLmRlbGV0ZShfdGFyZ2V0KTtcclxuXHJcbiAgICAgIGZvciAobGV0IGZpbHRlciBpbiBERUJVR19GSUxURVIpIHtcclxuICAgICAgICBsZXQgcGFyc2VkOiBudW1iZXIgPSBwYXJzZUludChmaWx0ZXIpO1xyXG4gICAgICAgIGlmIChpc05hTihwYXJzZWQpKVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgaWYgKFtERUJVR19GSUxURVIuTUVTU0FHRVMsIERFQlVHX0ZJTFRFUi5GT1JNQVQsIERFQlVHX0ZJTFRFUi5BTExdLmluZGV4T2YocGFyc2VkKSAhPSAtMSlcclxuICAgICAgICAgIC8vIGRvbnQgZGVsZWdhdGUgY29tYm9zLi4uIFxyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgaWYgKF9maWx0ZXIgJiBwYXJzZWQpXHJcbiAgICAgICAgICBEZWJ1Zy5kZWxlZ2F0ZXNbcGFyc2VkXS5zZXQoX3RhcmdldCwgX3RhcmdldC5kZWxlZ2F0ZXNbcGFyc2VkXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluZm8oLi4uKSBkaXNwbGF5cyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHdpdGggbG93IHByaW9yaXR5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgaW5mbyhfbWVzc2FnZTogdW5rbm93biwgLi4uX2FyZ3M6IHVua25vd25bXSk6IHZvaWQge1xyXG4gICAgICBEZWJ1Zy5kZWxlZ2F0ZShERUJVR19GSUxURVIuSU5GTywgX21lc3NhZ2UsIF9hcmdzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGlzcGxheXMgaW5mb3JtYXRpb24gd2l0aCBtZWRpdW0gcHJpb3JpdHlcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBsb2coX21lc3NhZ2U6IHVua25vd24sIC4uLl9hcmdzOiB1bmtub3duW10pOiB2b2lkIHtcclxuICAgICAgRGVidWcuZGVsZWdhdGUoREVCVUdfRklMVEVSLkxPRywgX21lc3NhZ2UsIF9hcmdzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGlzcGxheXMgaW5mb3JtYXRpb24gYWJvdXQgbm9uLWNvbmZvcm1pdGllcyBpbiB1c2FnZSwgd2hpY2ggaXMgZW1waGFzaXplZCBlLmcuIGJ5IGNvbG9yXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgd2FybihfbWVzc2FnZTogdW5rbm93biwgLi4uX2FyZ3M6IHVua25vd25bXSk6IHZvaWQge1xyXG4gICAgICBEZWJ1Zy5kZWxlZ2F0ZShERUJVR19GSUxURVIuV0FSTiwgX21lc3NhZ2UsIF9hcmdzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGlzcGxheXMgY3JpdGljYWwgaW5mb3JtYXRpb24gYWJvdXQgZmFpbHVyZXMsIHdoaWNoIGlzIGVtcGhhc2l6ZWQgZS5nLiBieSBjb2xvclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGVycm9yKF9tZXNzYWdlOiB1bmtub3duLCAuLi5fYXJnczogdW5rbm93bltdKTogdm9pZCB7XHJcbiAgICAgIERlYnVnLmRlbGVnYXRlKERFQlVHX0ZJTFRFUi5FUlJPUiwgX21lc3NhZ2UsIF9hcmdzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGlzcGxheXMgbWVzc2FnZXMgZnJvbSBGVURHRVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGZ1ZGdlKF9tZXNzYWdlOiB1bmtub3duLCAuLi5fYXJnczogdW5rbm93bltdKTogdm9pZCB7XHJcbiAgICAgIERlYnVnLmRlbGVnYXRlKERFQlVHX0ZJTFRFUi5GVURHRSwgX21lc3NhZ2UsIF9hcmdzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIHRoZSBvdXRwdXQgYW5kIHJlbW92ZXMgcHJldmlvdXMgbWVzc2FnZXMgaWYgcG9zc2libGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBjbGVhcigpOiB2b2lkIHtcclxuICAgICAgRGVidWcuZGVsZWdhdGUoREVCVUdfRklMVEVSLkNMRUFSLCBudWxsLCBudWxsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3BlbnMgYSBuZXcgZ3JvdXAgZm9yIG1lc3NhZ2VzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ3JvdXAoX25hbWU6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICBEZWJ1Zy5kZWxlZ2F0ZShERUJVR19GSUxURVIuR1JPVVAsIF9uYW1lLCBudWxsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3BlbnMgYSBuZXcgZ3JvdXAgZm9yIG1lc3NhZ2VzIHRoYXQgaXMgY29sbGFwc2VkIGF0IGZpcnN0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ3JvdXBDb2xsYXBzZWQoX25hbWU6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICBEZWJ1Zy5kZWxlZ2F0ZShERUJVR19GSUxURVIuR1JPVVBDT0xMQVBTRUQsIF9uYW1lLCBudWxsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2xvc2VzIHRoZSB5b3VuZ2VzdCBncm91cFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdyb3VwRW5kKCk6IHZvaWQge1xyXG4gICAgICBEZWJ1Zy5kZWxlZ2F0ZShERUJVR19GSUxURVIuR1JPVVBFTkQsIG51bGwsIG51bGwpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2cgYSBicmFuY2ggb2YgdGhlIG5vZGUgaGllcmFyY2h5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgYnJhbmNoKF9icmFuY2g6IE5vZGUpOiB2b2lkIHtcclxuICAgICAgaWYgKF9icmFuY2gubkNoaWxkcmVuID4gMClcclxuICAgICAgICBEZWJ1Zy5ncm91cChfYnJhbmNoLm5hbWUpO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgRGVidWcuZnVkZ2UoX2JyYW5jaC5uYW1lKTtcclxuXHJcbiAgICAgIGZvciAobGV0IGNoaWxkIG9mIF9icmFuY2guZ2V0Q2hpbGRyZW4oKSkgRGVidWcuYnJhbmNoKGNoaWxkKTtcclxuXHJcbiAgICAgIGlmIChfYnJhbmNoLm5DaGlsZHJlbiA+IDApXHJcbiAgICAgICAgRGVidWcuZ3JvdXBFbmQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERpc3BsYXlzIG1lc3NhZ2VzIGFib3V0IHRoZSBzb3VyY2Ugb2YgdGhlIGRlYnVnIGNhbGxcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzb3VyY2UoX21lc3NhZ2U6IHVua25vd24sIC4uLl9hcmdzOiB1bmtub3duW10pOiB2b2lkIHtcclxuICAgICAgRGVidWcuZGVsZWdhdGUoREVCVUdfRklMVEVSLlNPVVJDRSwgX21lc3NhZ2UsIF9hcmdzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvb2t1cCBhbGwgZGVsZWdhdGVzIHJlZ2lzdGVyZWQgdG8gdGhlIGZpbHRlciBhbmQgY2FsbCB0aGVtIHVzaW5nIHRoZSBnaXZlbiBhcmd1bWVudHNcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZGVsZWdhdGUoX2ZpbHRlcjogREVCVUdfRklMVEVSLCBfbWVzc2FnZTogdW5rbm93biwgX2FyZ3M6IHVua25vd25bXSk6IHZvaWQge1xyXG4gICAgICBpZiAoX2ZpbHRlciA9PSBERUJVR19GSUxURVIuTE9HIHx8IF9maWx0ZXIgPT0gREVCVUdfRklMVEVSLldBUk4gfHwgX2ZpbHRlciA9PSBERUJVR19GSUxURVIuRVJST1IpIHtcclxuICAgICAgICBpZiAoRGVidWcuZGVsZWdhdGVzW0RFQlVHX0ZJTFRFUi5TT1VSQ0VdKVxyXG4gICAgICAgICAgZm9yIChsZXQgZGVsZWdhdGUgb2YgRGVidWcuZGVsZWdhdGVzW0RFQlVHX0ZJTFRFUi5TT1VSQ0VdLnZhbHVlcygpKVxyXG4gICAgICAgICAgICBpZiAoZGVsZWdhdGUpIHtcclxuICAgICAgICAgICAgICBsZXQgdHJhY2U6IHN0cmluZ1tdID0gbmV3IEVycm9yKFwiVGVzdFwiKS5zdGFjay5zcGxpdChcIlxcblwiKTtcclxuICAgICAgICAgICAgICBkZWxlZ2F0ZSh0cmFjZVszXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBsZXQgZGVsZWdhdGVzOiBNYXBEZWJ1Z1RhcmdldFRvRGVsZWdhdGUgPSBEZWJ1Zy5kZWxlZ2F0ZXNbX2ZpbHRlcl07XHJcbiAgICAgIGZvciAobGV0IGRlbGVnYXRlIG9mIGRlbGVnYXRlcy52YWx1ZXMoKSlcclxuICAgICAgICBpZiAoZGVsZWdhdGUpXHJcbiAgICAgICAgICBpZiAoX2FyZ3MgJiYgX2FyZ3MubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgZGVsZWdhdGUoX21lc3NhZ2UsIC4uLl9hcmdzKTtcclxuICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgZGVsZWdhdGUoX21lc3NhZ2UpO1xyXG5cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogc2V0dXAgcm91dGluZyB0byBzdGFuZGFyZCBjb25zb2xlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIHNldHVwQ29uc29sZSgpOiB7fSB7XHJcbiAgICAgIGxldCByZXN1bHQ6IHsgW2ZpbHRlcjogbnVtYmVyXTogTWFwRGVidWdUYXJnZXRUb0RlbGVnYXRlIH0gPSB7fTtcclxuICAgICAgbGV0IGZpbHRlcnM6IERFQlVHX0ZJTFRFUltdID0gW1xyXG4gICAgICAgIERFQlVHX0ZJTFRFUi5JTkZPLCBERUJVR19GSUxURVIuTE9HLCBERUJVR19GSUxURVIuV0FSTiwgREVCVUdfRklMVEVSLkVSUk9SLCBERUJVR19GSUxURVIuRlVER0UsXHJcbiAgICAgICAgREVCVUdfRklMVEVSLkNMRUFSLCBERUJVR19GSUxURVIuR1JPVVAsIERFQlVHX0ZJTFRFUi5HUk9VUENPTExBUFNFRCwgREVCVUdfRklMVEVSLkdST1VQRU5ELFxyXG4gICAgICAgIERFQlVHX0ZJTFRFUi5TT1VSQ0VcclxuICAgICAgXTtcclxuXHJcbiAgICAgIGZvciAobGV0IGZpbHRlciBvZiBmaWx0ZXJzKVxyXG4gICAgICAgIHJlc3VsdFtmaWx0ZXJdID0gbmV3IE1hcChbW0RlYnVnQ29uc29sZSwgRGVidWdDb25zb2xlLmRlbGVnYXRlc1tmaWx0ZXJdXV0pO1xyXG5cclxuICAgICAgcmVzdWx0W0RFQlVHX0ZJTFRFUi5TT1VSQ0VdLmRlbGV0ZShEZWJ1Z0NvbnNvbGUpO1xyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgaW50ZXJmYWNlIE1hcEV2ZW50VHlwZVRvTGlzdGVuZXIge1xyXG4gICAgW2V2ZW50VHlwZTogc3RyaW5nXTogRXZlbnRMaXN0ZW5lcsaSW107XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUeXBlcyBvZiBldmVudHMgc3BlY2lmaWMgdG8gRnVkZ2UsIGluIGFkZGl0aW9uIHRvIHRoZSBzdGFuZGFyZCBET00vQnJvd3Nlci1UeXBlcyBhbmQgY3VzdG9tIHN0cmluZ3NcclxuICAgKi9cclxuXHJcbiAgZXhwb3J0IGNvbnN0IGVudW0gRVZFTlQge1xyXG4gICAgLyoqIGRpc3BhdGNoZWQgdG8gdGFyZ2V0cyByZWdpc3RlcmVkIGF0IHtAbGluayBMb29wfSwgd2hlbiByZXF1ZXN0ZWQgYW5pbWF0aW9uIGZyYW1lIHN0YXJ0cyAqL1xyXG4gICAgTE9PUF9GUkFNRSA9IFwibG9vcEZyYW1lXCIsXHJcbiAgICAvKiogZGlzcGF0Y2hlZCB0byBhIHtAbGluayBDb21wb25lbnR9IHdoZW4gaXRzIGJlaW5nIGFkZGVkIHRvIGEge0BsaW5rIE5vZGV9ICovXHJcbiAgICBDT01QT05FTlRfQUREID0gXCJjb21wb25lbnRBZGRcIixcclxuICAgIC8qKiBkaXNwYXRjaGVkIHRvIGEge0BsaW5rIENvbXBvbmVudH0gd2hlbiBpdHMgYmVpbmcgcmVtb3ZlZCBmcm9tIGEge0BsaW5rIE5vZGV9ICovXHJcbiAgICBDT01QT05FTlRfUkVNT1ZFID0gXCJjb21wb25lbnRSZW1vdmVcIixcclxuICAgIC8qKiBkaXNwYXRjaGVkIHRvIGEge0BsaW5rIENvbXBvbmVudH0gd2hlbiBpdHMgYmVpbmcgYWN0aXZhdGVkICovXHJcbiAgICBDT01QT05FTlRfQUNUSVZBVEUgPSBcImNvbXBvbmVudEFjdGl2YXRlXCIsXHJcbiAgICAvKiogZGlzcGF0Y2hlZCB0byBhIHtAbGluayBDb21wb25lbnR9IHdoZW4gaXRzIGJlaW5nIGRlYWN0aXZhdGVkICovXHJcbiAgICBDT01QT05FTlRfREVBQ1RJVkFURSA9IFwiY29tcG9uZW50RGVhY3RpdmF0ZVwiLFxyXG4gICAgLyoqIGRpc3BhdGNoZWQgdG8gYSB7QGxpbmsgTm9kZX0sIGl0J3Mgc3VjY2Vzc29ycyBhbmQgYW5jZXN0b3JzIHdoZW4gaXRzIGJlaW5nIGFjdGl2YXRlZCAqL1xyXG4gICAgTk9ERV9BQ1RJVkFURSA9IFwibm9kZUFjdGl2YXRlXCIsXHJcbiAgICAvKiogZGlzcGF0Y2hlZCB0byBhIHtAbGluayBOb2RlfSwgaXQncyBzdWNjZXNzb3JzIGFuZCBhbmNlc3RvcnMgd2hlbiBpdHMgYmVpbmcgZGVhY3RpdmF0ZWQgKi9cclxuICAgIE5PREVfREVBQ1RJVkFURSA9IFwibm9kZURlYWN0aXZhdGVcIixcclxuICAgIC8qKiBkaXNwYXRjaGVkIHRvIGEgY2hpbGQge0BsaW5rIE5vZGV9IGFuZCBpdHMgYW5jZXN0b3JzIGFmdGVyIGl0IHdhcyBhcHBlbmRlZCB0byBhIHBhcmVudCAqL1xyXG4gICAgQ0hJTERfQVBQRU5EID0gXCJjaGlsZEFwcGVuZFwiLFxyXG4gICAgLyoqIGRpc3BhdGNoZWQgdG8gYSBjaGlsZCB7QGxpbmsgTm9kZX0gYW5kIGl0cyBhbmNlc3RvcnMganVzdCBiZWZvcmUgaXRzIGJlaW5nIHJlbW92ZWQgZnJvbSBpdHMgcGFyZW50ICovXHJcbiAgICBDSElMRF9SRU1PVkUgPSBcImNoaWxkUmVtb3ZlXCIsXHJcbiAgICAvKiogZGlzcGF0Y2hlZCB0byBhIHtAbGluayBNdXRhYmxlfSB3aGVuIGl0cyBiZWluZyBtdXRhdGVkICovXHJcbiAgICBNVVRBVEUgPSBcIm11dGF0ZVwiLFxyXG4gICAgLyoqIGRpc3BhdGNoZWQgdG8ge0BsaW5rIFZpZXdwb3J0fSB3aGVuIGl0IGdldHMgdGhlIGZvY3VzIHRvIHJlY2VpdmUga2V5Ym9hcmQgaW5wdXQgKi9cclxuICAgIEZPQ1VTX0lOID0gXCJmb2N1c2luXCIsXHJcbiAgICAvKiogZGlzcGF0Y2hlZCB0byB7QGxpbmsgVmlld3BvcnR9IHdoZW4gaXQgbG9zZXMgdGhlIGZvY3VzIHRvIHJlY2VpdmUga2V5Ym9hcmQgaW5wdXQgKi9cclxuICAgIEZPQ1VTX09VVCA9IFwiZm9jdXNvdXRcIixcclxuICAgIC8qKiBkaXNwYXRjaGVkIHRvIHtAbGluayBOb2RlfSB3aGVuIGl0J3MgZG9uZSBzZXJpYWxpemluZyAqL1xyXG4gICAgTk9ERV9TRVJJQUxJWkVEID0gXCJub2RlU2VyaWFsaXplZFwiLFxyXG4gICAgLyoqIGRpc3BhdGNoZWQgdG8ge0BsaW5rIE5vZGV9IHdoZW4gaXQncyBkb25lIGRlc2VyaWFsaXppbmcsIHNvIGFsbCBjb21wb25lbnRzLCBjaGlsZHJlbiBhbmQgYXR0cmlidXRlcyBhcmUgYXZhaWxhYmxlICovXHJcbiAgICBOT0RFX0RFU0VSSUFMSVpFRCA9IFwibm9kZURlc2VyaWFsaXplZFwiLFxyXG4gICAgLyoqIGRpc3BhdGNoZWQgdG8ge0BsaW5rIEdyYXBoSW5zdGFuY2V9IHdoZW4gaXQncyBjb250ZW50IGlzIHNldCBhY2NvcmRpbmcgdG8gYSBzZXJpYWxpemF0aW9uIG9mIGEge0BsaW5rIEdyYXBofSAgKi9cclxuICAgIEdSQVBIX0lOU1RBTlRJQVRFRCA9IFwiZ3JhcGhJbnN0YW50aWF0ZWRcIixcclxuICAgIC8qKiBkaXNwYXRjaGVkIHRvIHtAbGluayBUaW1lfSB3aGVuIGl0J3Mgc2NhbGluZyBjaGFuZ2VkICAqL1xyXG4gICAgVElNRV9TQ0FMRUQgPSBcInRpbWVTY2FsZWRcIixcclxuICAgIC8qKiBkaXNwYXRjaGVkIHRvIHtAbGluayBGaWxlSW9Ccm93c2VyTG9jYWx9IHdoZW4gYSBsaXN0IG9mIGZpbGVzIGhhcyBiZWVuIGxvYWRlZCAgKi9cclxuICAgIEZJTEVfTE9BREVEID0gXCJmaWxlTG9hZGVkXCIsXHJcbiAgICAvKiogZGlzcGF0Y2hlZCB0byB7QGxpbmsgRmlsZUlvQnJvd3NlckxvY2FsfSB3aGVuIGEgbGlzdCBvZiBmaWxlcyBoYXMgYmVlbiBzYXZlZCAqL1xyXG4gICAgRklMRV9TQVZFRCA9IFwiZmlsZVNhdmVkXCIsXHJcbiAgICAvKiogZGlzcGF0Y2hlZCB0byB7QGxpbmsgTm9kZX0gd2hlbiByZWNhbGN1bGF0aW5nIHRyYW5zZm9ybXMgZm9yIHJlbmRlciAqL1xyXG4gICAgUkVOREVSX1BSRVBBUkUgPSBcInJlbmRlclByZXBhcmVcIixcclxuICAgIFJFTkRFUl9QUkVQQVJFX1NUQVJUID0gXCJyZW5kZXJQcmVwYXJlU3RhcnRcIixcclxuICAgIFJFTkRFUl9QUkVQQVJFX0VORCA9IFwicmVuZGVyUHJlcGFyZUVuZFwiXHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gZXhwb3J0IHR5cGUgRXZlbnTGkiA9IEV2ZW50UG9pbnRlciB8IEV2ZW50RHJhZ0Ryb3AgfCBFdmVudFdoZWVsIHwgRXZlbnRLZXlib2FyZCB8IEV2ZW50IHwgRXZlbnRQaHlzaWNzO1xyXG5cclxuICBleHBvcnQgdHlwZSBFdmVudExpc3RlbmVyxpIgPVxyXG4gICAgKChfZXZlbnQ6IEV2ZW50UG9pbnRlcikgPT4gdm9pZCkgfFxyXG4gICAgKChfZXZlbnQ6IEV2ZW50RHJhZ0Ryb3ApID0+IHZvaWQpIHxcclxuICAgICgoX2V2ZW50OiBFdmVudFdoZWVsKSA9PiB2b2lkKSB8XHJcbiAgICAoKF9ldmVudDogRXZlbnRLZXlib2FyZCkgPT4gdm9pZCkgfFxyXG4gICAgKChfZXZlbnQ6IEV2ZW50xpIpID0+IHZvaWQpIHxcclxuICAgICgoX2V2ZW50OiBFdmVudFBoeXNpY3MpID0+IHZvaWQpIHxcclxuICAgICgoX2V2ZW50OiBDdXN0b21FdmVudCkgPT4gdm9pZCkgfFxyXG4gICAgRXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdDtcclxuXHJcbiAgZXhwb3J0IHR5cGUgRXZlbnTGkiA9IEV2ZW50UG9pbnRlciB8IEV2ZW50RHJhZ0Ryb3AgfCBFdmVudFdoZWVsIHwgRXZlbnRLZXlib2FyZCB8IEV2ZW50IHwgRXZlbnRQaHlzaWNzIHwgQ3VzdG9tRXZlbnQ7XHJcbiAgLy8gZXhwb3J0IHR5cGUgRXZlbnRMaXN0ZW5lcsaSID0gKChfZXZlbnQ6IEV2ZW50xpIpID0+IHZvaWQpIHwgRXZlbnRMaXN0ZW5lciB8IEV2ZW50TGlzdGVuZXJPYmplY3Q7XHJcblxyXG4gIGV4cG9ydCBjbGFzcyBFdmVudFRhcmdldMaSIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xyXG4gICAgYWRkRXZlbnRMaXN0ZW5lcihfdHlwZTogc3RyaW5nLCBfaGFuZGxlcjogRXZlbnRMaXN0ZW5lcsaSLCBfb3B0aW9ucz86IGJvb2xlYW4gfCBBZGRFdmVudExpc3RlbmVyT3B0aW9ucyk6IHZvaWQge1xyXG4gICAgICBzdXBlci5hZGRFdmVudExpc3RlbmVyKF90eXBlLCA8RXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdD5faGFuZGxlciwgX29wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihfdHlwZTogc3RyaW5nLCBfaGFuZGxlcjogRXZlbnRMaXN0ZW5lcsaSLCBfb3B0aW9ucz86IGJvb2xlYW4gfCBBZGRFdmVudExpc3RlbmVyT3B0aW9ucyk6IHZvaWQge1xyXG4gICAgICBzdXBlci5yZW1vdmVFdmVudExpc3RlbmVyKF90eXBlLCA8RXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdD5faGFuZGxlciwgX29wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIGRpc3BhdGNoRXZlbnQoX2V2ZW50OiBFdmVudMaSKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiBzdXBlci5kaXNwYXRjaEV2ZW50KF9ldmVudCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBCYXNlIGNsYXNzIGZvciBFdmVudFRhcmdldCBzaW5nbGV0b25zLCB3aGljaCBhcmUgZml4ZWQgZW50aXRpZXMgaW4gdGhlIHN0cnVjdHVyZSBvZiBGdWRnZSwgc3VjaCBhcyB0aGUgY29yZSBsb29wIFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBFdmVudFRhcmdldFN0YXRpYyBleHRlbmRzIEV2ZW50VGFyZ2V0xpIge1xyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyB0YXJnZXRTdGF0aWM6IEV2ZW50VGFyZ2V0U3RhdGljID0gbmV3IEV2ZW50VGFyZ2V0U3RhdGljKCk7XHJcblxyXG4gICAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgYWRkRXZlbnRMaXN0ZW5lcihfdHlwZTogc3RyaW5nLCBfaGFuZGxlcjogRXZlbnRMaXN0ZW5lcik6IHZvaWQge1xyXG4gICAgICBFdmVudFRhcmdldFN0YXRpYy50YXJnZXRTdGF0aWMuYWRkRXZlbnRMaXN0ZW5lcihfdHlwZSwgX2hhbmRsZXIpO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHN0YXRpYyByZW1vdmVFdmVudExpc3RlbmVyKF90eXBlOiBzdHJpbmcsIF9oYW5kbGVyOiBFdmVudExpc3RlbmVyKTogdm9pZCB7XHJcbiAgICAgIEV2ZW50VGFyZ2V0U3RhdGljLnRhcmdldFN0YXRpYy5yZW1vdmVFdmVudExpc3RlbmVyKF90eXBlLCBfaGFuZGxlcik7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc3RhdGljIGRpc3BhdGNoRXZlbnQoX2V2ZW50OiBFdmVudCk6IGJvb2xlYW4ge1xyXG4gICAgICBFdmVudFRhcmdldFN0YXRpYy50YXJnZXRTdGF0aWMuZGlzcGF0Y2hFdmVudChfZXZlbnQpO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBJbnRlcmZhY2UgZGVzY3JpYmluZyB0aGUgZGF0YXR5cGVzIG9mIHRoZSBhdHRyaWJ1dGVzIGEgbXV0YXRvciBhcyBzdHJpbmdzIFxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgTXV0YXRvckF0dHJpYnV0ZVR5cGVzIHtcclxuICAgIFthdHRyaWJ1dGU6IHN0cmluZ106IHN0cmluZyB8IE9iamVjdDtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogSW50ZXJmYWNlIGRlc2NyaWJpbmcgYSBtdXRhdG9yLCB3aGljaCBpcyBhbiBhc3NvY2lhdGl2ZSBhcnJheSB3aXRoIG5hbWVzIG9mIGF0dHJpYnV0ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgdmFsdWVzXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBNdXRhdG9yIHtcclxuICAgIFthdHRyaWJ1dGU6IHN0cmluZ106IEdlbmVyYWw7XHJcbiAgfVxyXG5cclxuICAvKlxyXG4gICAqIEludGVyZmFjZXMgZGVkaWNhdGVkIGZvciBlYWNoIHB1cnBvc2UuIEV4dHJhIGF0dHJpYnV0ZSBuZWNlc3NhcnkgZm9yIGNvbXBpbGV0aW1lIHR5cGUgY2hlY2tpbmcsIG5vdCBleGlzdGVudCBhdCBydW50aW1lXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBNdXRhdG9yRm9yQW5pbWF0aW9uIGV4dGVuZHMgTXV0YXRvciB7IHJlYWRvbmx5IGZvckFuaW1hdGlvbjogbnVsbDsgfVxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgTXV0YXRvckZvclVzZXJJbnRlcmZhY2UgZXh0ZW5kcyBNdXRhdG9yIHsgcmVhZG9ubHkgZm9yVXNlckludGVyZmFjZTogbnVsbDsgfVxyXG4gIC8vIGV4cG9ydCBpbnRlcmZhY2UgTXV0YXRvckZvckNvbXBvbmVudCBleHRlbmRzIE11dGF0b3IgeyByZWFkb25seSBmb3JVc2VyQ29tcG9uZW50OiBudWxsOyB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbGxlY3QgYXBwbGljYWJsZSBhdHRyaWJ1dGVzIG9mIHRoZSBpbnN0YW5jZSBhbmQgY29waWVzIG9mIHRoZWlyIHZhbHVlcyBpbiBhIE11dGF0b3Itb2JqZWN0XHJcbiAgICovXHJcbiAgZXhwb3J0IGZ1bmN0aW9uIGdldE11dGF0b3JPZkFyYml0cmFyeShfb2JqZWN0OiBPYmplY3QpOiBNdXRhdG9yIHtcclxuICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0ge307XHJcbiAgICBsZXQgYXR0cmlidXRlczogKHN0cmluZyB8IG51bWJlciB8IHN5bWJvbClbXSA9IFJlZmxlY3Qub3duS2V5cyhSZWZsZWN0LmdldFByb3RvdHlwZU9mKF9vYmplY3QpKTtcclxuICAgIGZvciAobGV0IGF0dHJpYnV0ZSBvZiBhdHRyaWJ1dGVzKSB7XHJcbiAgICAgIGxldCB2YWx1ZTogT2JqZWN0ID0gUmVmbGVjdC5nZXQoX29iamVjdCwgYXR0cmlidXRlKTtcclxuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pXHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIC8vIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdCAmJiAhKHZhbHVlIGluc3RhbmNlb2YgTXV0YWJsZSkpXHJcbiAgICAgIC8vICAgY29udGludWU7XHJcbiAgICAgIG11dGF0b3JbYXR0cmlidXRlLnRvU3RyaW5nKCldID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbXV0YXRvcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEJhc2UgY2xhc3MgZm9yIGFsbCB0eXBlcyBiZWluZyBtdXRhYmxlIHVzaW5nIHtAbGluayBNdXRhdG9yfS1vYmplY3RzLCB0aHVzIHByb3ZpZGluZyBhbmQgdXNpbmcgaW50ZXJmYWNlcyBjcmVhdGVkIGF0IHJ1bnRpbWUuICBcclxuICAgKiBNdXRhYmxlcyBwcm92aWRlIGEge0BsaW5rIE11dGF0b3J9IHRoYXQgaXMgYnVpbGQgYnkgY29sbGVjdGluZyBhbGwgb2JqZWN0LXByb3BlcnRpZXMgdGhhdCBhcmUgZWl0aGVyIG9mIGEgcHJpbWl0aXZlIHR5cGUgb3IgYWdhaW4gTXV0YWJsZS5cclxuICAgKiBTdWJjbGFzc2VzIGNhbiBlaXRoZXIgcmVkdWNlIHRoZSBzdGFuZGFyZCB7QGxpbmsgTXV0YXRvcn0gYnVpbHQgYnkgdGhpcyBiYXNlIGNsYXNzIGJ5IGRlbGV0aW5nIHByb3BlcnRpZXMgb3IgaW1wbGVtZW50IGFuIGluZGl2aWR1YWwgZ2V0TXV0YXRvci1tZXRob2QuXHJcbiAgICogVGhlIHByb3ZpZGVkIHByb3BlcnRpZXMgb2YgdGhlIHtAbGluayBNdXRhdG9yfSBtdXN0IG1hdGNoIHB1YmxpYyBwcm9wZXJ0aWVzIG9yIGdldHRlcnMvc2V0dGVycyBvZiB0aGUgb2JqZWN0LlxyXG4gICAqIE90aGVyd2lzZSwgdGhleSB3aWxsIGJlIGlnbm9yZWQgaWYgbm90IGhhbmRsZWQgYnkgYW4gb3ZlcnJpZGUgb2YgdGhlIG11dGF0ZS1tZXRob2QgaW4gdGhlIHN1YmNsYXNzIGFuZCB0aHJvdyBlcnJvcnMgaW4gYW4gYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgdXNlci1pbnRlcmZhY2UgZm9yIHRoZSBvYmplY3QuXHJcbiAgICovXHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIE11dGFibGUgZXh0ZW5kcyBFdmVudFRhcmdldMaSIHtcclxuICAgIC8qKlxyXG4gICAgICogRGVjb3JhdG9yIGFsbG93cyB0byBhdHRhY2gge0BsaW5rIE11dGFibGV9IGZ1bmN0aW9uYWxpdHkgdG8gZXhpc3RpbmcgY2xhc3Nlcy4gXHJcbiAgICAgKi9cclxuICAgIC8vIHB1YmxpYyBzdGF0aWMgZGVjb3JhdGUoX2NvbnN0cnVjdG9yOiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgLy8gICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2NvbnN0cnVjdG9yLnByb3RvdHlwZSwgXCJ1c2VSZW5kZXJEYXRhXCIsIHtcclxuICAgIC8vICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TXV0YXRvcih0aGlzOiBNdXRhYmxlRm9yVXNlckludGVyZmFjZSk6IE11dGF0b3Ige1xyXG4gICAgLy8gICAgICAgcmV0dXJuIGdldE11dGF0b3JPZkFyYml0cmFyeSh0aGlzKTtcclxuICAgIC8vICAgICB9XHJcbiAgICAvLyAgIH0pO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIHRoZSB0eXBlIG9mIHRoaXMgbXV0YWJsZSBzdWJjbGFzcyBhcyB0aGUgbmFtZSBvZiB0aGUgcnVudGltZSBjbGFzc1xyXG4gICAgICogQHJldHVybnMgVGhlIHR5cGUgb2YgdGhlIG11dGFibGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCB0eXBlKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbGxlY3QgYXBwbGljYWJsZSBhdHRyaWJ1dGVzIG9mIHRoZSBpbnN0YW5jZSBhbmQgY29waWVzIG9mIHRoZWlyIHZhbHVlcyBpbiBhIE11dGF0b3Itb2JqZWN0LlxyXG4gICAgICogQnkgZGVmYXVsdCwgYSBtdXRhdG9yIGNhbm5vdCBiZSBleHRlbmRlZCwgc2luY2UgZXh0ZW5zaW9ucyBhcmUgbm90IGF2YWlsYWJsZSBpbiB0aGUgb2JqZWN0IHRoZSBtdXRhdG9yIGJlbG9uZ3MgdG8uXHJcbiAgICAgKiBBIG11dGF0b3IgbWF5IGJlIHJlZHVjZWQgYnkgdGhlIGRlc2NlbmRhbnRzIG9mIHtAbGluayBNdXRhYmxlfSB0byBjb250YWluIG9ubHkgdGhlIHByb3BlcnRpZXMgbmVlZGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvcihfZXh0ZW5kYWJsZTogYm9vbGVhbiA9IGZhbHNlKTogTXV0YXRvciB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0ge307XHJcblxyXG4gICAgICAvLyBjb2xsZWN0IHByaW1pdGl2ZSBhbmQgbXV0YWJsZSBhdHRyaWJ1dGVzXHJcbiAgICAgIGZvciAobGV0IGF0dHJpYnV0ZSBpbiB0aGlzKSB7XHJcbiAgICAgICAgbGV0IHZhbHVlOiBPYmplY3QgPSB0aGlzW2F0dHJpYnV0ZV07XHJcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pXHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBPYmplY3QgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIE11dGFibGUpICYmICEodmFsdWUgaW5zdGFuY2VvZiBNdXRhYmxlQXJyYXkpICYmICEodmFsdWUuaGFzT3duUHJvcGVydHkoXCJpZFJlc291cmNlXCIpKSlcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIG11dGF0b3JbYXR0cmlidXRlXSA9IHRoaXNbYXR0cmlidXRlXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFfZXh0ZW5kYWJsZSlcclxuICAgICAgICAvLyBtdXRhdG9yIGNhbiBiZSByZWR1Y2VkIGJ1dCBub3QgZXh0ZW5kZWQhXHJcbiAgICAgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKG11dGF0b3IpO1xyXG4gICAgICAvLyBkZWxldGUgdW53YW50ZWQgYXR0cmlidXRlc1xyXG4gICAgICB0aGlzLnJlZHVjZU11dGF0b3IobXV0YXRvcik7XHJcblxyXG4gICAgICAvLyByZXBsYWNlIHJlZmVyZW5jZXMgdG8gbXV0YWJsZSBvYmplY3RzIHdpdGggcmVmZXJlbmNlcyB0byBtdXRhdG9yc1xyXG4gICAgICBmb3IgKGxldCBhdHRyaWJ1dGUgaW4gbXV0YXRvcikge1xyXG4gICAgICAgIGxldCB2YWx1ZTogT2JqZWN0ID0gbXV0YXRvclthdHRyaWJ1dGVdO1xyXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE11dGFibGUpXHJcbiAgICAgICAgICBtdXRhdG9yW2F0dHJpYnV0ZV0gPSB2YWx1ZS5nZXRNdXRhdG9yKCk7XHJcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTXV0YWJsZUFycmF5KVxyXG4gICAgICAgICAgbXV0YXRvclthdHRyaWJ1dGVdID0gdmFsdWUubWFwKChfdmFsdWUpID0+IF92YWx1ZS5nZXRNdXRhdG9yKCkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbGxlY3QgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIGluc3RhbmNlIGFuZCB0aGVpciB2YWx1ZXMgYXBwbGljYWJsZSBmb3IgYW5pbWF0aW9uLlxyXG4gICAgICogQmFzaWMgZnVuY3Rpb25hbGl0eSBpcyBpZGVudGljYWwgdG8ge0BsaW5rIGdldE11dGF0b3J9LCByZXR1cm5lZCBtdXRhdG9yIHNob3VsZCB0aGVuIGJlIHJlZHVjZWQgYnkgdGhlIHN1YmNsYXNzZWQgaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldE11dGF0b3JGb3JBbmltYXRpb24oKTogTXV0YXRvckZvckFuaW1hdGlvbiB7XHJcbiAgICAgIHJldHVybiA8TXV0YXRvckZvckFuaW1hdGlvbj50aGlzLmdldE11dGF0b3IoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29sbGVjdCB0aGUgYXR0cmlidXRlcyBvZiB0aGUgaW5zdGFuY2UgYW5kIHRoZWlyIHZhbHVlcyBhcHBsaWNhYmxlIGZvciB0aGUgdXNlciBpbnRlcmZhY2UuXHJcbiAgICAgKiBCYXNpYyBmdW5jdGlvbmFsaXR5IGlzIGlkZW50aWNhbCB0byB7QGxpbmsgZ2V0TXV0YXRvcn0sIHJldHVybmVkIG11dGF0b3Igc2hvdWxkIHRoZW4gYmUgcmVkdWNlZCBieSB0aGUgc3ViY2xhc3NlZCBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvckZvclVzZXJJbnRlcmZhY2UoKTogTXV0YXRvckZvclVzZXJJbnRlcmZhY2Uge1xyXG4gICAgICByZXR1cm4gPE11dGF0b3JGb3JVc2VySW50ZXJmYWNlPnRoaXMuZ2V0TXV0YXRvcigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb2xsZWN0IHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBpbnN0YW5jZSBhbmQgdGhlaXIgdmFsdWVzIGFwcGxpY2FibGUgZm9yIGluZGl2aXVhbGl6YXRpb24gYnkgdGhlIGNvbXBvbmVudC5cclxuICAgICAqIEJhc2ljIGZ1bmN0aW9uYWxpdHkgaXMgaWRlbnRpY2FsIHRvIHtAbGluayBnZXRNdXRhdG9yfSwgcmV0dXJuZWQgbXV0YXRvciBzaG91bGQgdGhlbiBiZSByZWR1Y2VkIGJ5IHRoZSBzdWJjbGFzc2VkIGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIC8vIHB1YmxpYyBnZXRNdXRhdG9yRm9yQ29tcG9uZW50KCk6IE11dGF0b3JGb3JDb21wb25lbnQge1xyXG4gICAgLy8gICAgIHJldHVybiA8TXV0YXRvckZvckNvbXBvbmVudD50aGlzLmdldE11dGF0b3IoKTtcclxuICAgIC8vIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBhc3NvY2lhdGl2ZSBhcnJheSB3aXRoIHRoZSBzYW1lIGF0dHJpYnV0ZXMgYXMgdGhlIGdpdmVuIG11dGF0b3IsIGJ1dCB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIHR5cGVzIGFzIHN0cmluZy12YWx1ZXNcclxuICAgICAqIERvZXMgbm90IHJlY3Vyc2UgaW50byBvYmplY3RzIVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvckF0dHJpYnV0ZVR5cGVzKF9tdXRhdG9yOiBNdXRhdG9yKTogTXV0YXRvckF0dHJpYnV0ZVR5cGVzIHtcclxuICAgICAgbGV0IHR5cGVzOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMgPSB7fTtcclxuICAgICAgZm9yIChsZXQgYXR0cmlidXRlIGluIF9tdXRhdG9yKSB7XHJcbiAgICAgICAgbGV0IHR5cGU6IHN0cmluZyA9IG51bGw7XHJcbiAgICAgICAgbGV0IHZhbHVlOiBudW1iZXIgfCBib29sZWFuIHwgc3RyaW5nIHwgb2JqZWN0ID0gX211dGF0b3JbYXR0cmlidXRlXTtcclxuICAgICAgICBpZiAoX211dGF0b3JbYXR0cmlidXRlXSAhPSB1bmRlZmluZWQpXHJcbiAgICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT0gXCJvYmplY3RcIilcclxuICAgICAgICAgICAgdHlwZSA9ICg8R2VuZXJhbD50aGlzKVthdHRyaWJ1dGVdLmNvbnN0cnVjdG9yLm5hbWU7XHJcbiAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgKHZhbHVlKSA9PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgICAgIHR5cGUgPSB2YWx1ZVtcIm5hbWVcIl07XHJcbiAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHR5cGUgPSBfbXV0YXRvclthdHRyaWJ1dGVdLmNvbnN0cnVjdG9yLm5hbWU7XHJcbiAgICAgICAgdHlwZXNbYXR0cmlidXRlXSA9IHR5cGU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHR5cGVzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSB2YWx1ZXMgb2YgdGhlIGdpdmVuIG11dGF0b3IgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIF9tdXRhdG9yIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdXBkYXRlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICBmb3IgKGxldCBhdHRyaWJ1dGUgaW4gX211dGF0b3IpIHtcclxuICAgICAgICBsZXQgdmFsdWU6IE9iamVjdCA9IF9tdXRhdG9yW2F0dHJpYnV0ZV07XHJcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTXV0YWJsZSlcclxuICAgICAgICAgIF9tdXRhdG9yW2F0dHJpYnV0ZV0gPSB2YWx1ZS5nZXRNdXRhdG9yKCk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgX211dGF0b3JbYXR0cmlidXRlXSA9ICg8R2VuZXJhbD50aGlzKVthdHRyaWJ1dGVdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIGF0dHJpYnV0ZSB2YWx1ZXMgb2YgdGhlIGluc3RhbmNlIGFjY29yZGluZyB0byB0aGUgc3RhdGUgb2YgdGhlIG11dGF0b3IuIE11c3QgYmUgcHJvdGVjdGVkLi4uIVxyXG4gICAgICogQHBhcmFtIF9tdXRhdG9yXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgZm9yIChsZXQgYXR0cmlidXRlIGluIF9tdXRhdG9yKSB7XHJcbiAgICAgICAgaWYgKCFSZWZsZWN0Lmhhcyh0aGlzLCBhdHRyaWJ1dGUpKVxyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgbGV0IG11dGFudDogT2JqZWN0ID0gUmVmbGVjdC5nZXQodGhpcywgYXR0cmlidXRlKTtcclxuICAgICAgICBsZXQgdmFsdWU6IE11dGF0b3IgPSA8TXV0YXRvcj5fbXV0YXRvclthdHRyaWJ1dGVdO1xyXG4gICAgICAgIGlmIChtdXRhbnQgaW5zdGFuY2VvZiBNdXRhYmxlQXJyYXkgfHwgbXV0YW50IGluc3RhbmNlb2YgTXV0YWJsZSlcclxuICAgICAgICAgIGF3YWl0IG11dGFudC5tdXRhdGUodmFsdWUpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIFJlZmxlY3Quc2V0KHRoaXMsIGF0dHJpYnV0ZSwgdmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuTVVUQVRFKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlZHVjZXMgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIGdlbmVyYWwgbXV0YXRvciBhY2NvcmRpbmcgdG8gZGVzaXJlZCBvcHRpb25zIGZvciBtdXRhdGlvbi4gVG8gYmUgaW1wbGVtZW50ZWQgaW4gc3ViY2xhc3Nlc1xyXG4gICAgICogQHBhcmFtIF9tdXRhdG9yIFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQ7XHJcbiAgfVxyXG59XHJcbiIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tYW55XHJcbiAgZXhwb3J0IHR5cGUgR2VuZXJhbCA9IGFueTtcclxuXHJcbiAgZXhwb3J0IGludGVyZmFjZSBTZXJpYWxpemF0aW9uIHtcclxuICAgIFt0eXBlOiBzdHJpbmddOiBHZW5lcmFsO1xyXG4gIH1cclxuICBleHBvcnQgaW50ZXJmYWNlIFNlcmlhbGl6YWJsZSB7XHJcbiAgICBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbjtcclxuICAgIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+O1xyXG4gIH1cclxuXHJcbiAgaW50ZXJmYWNlIE5hbWVzcGFjZVJlZ2lzdGVyIHtcclxuICAgIFtuYW1lOiBzdHJpbmddOiBPYmplY3Q7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBIYW5kbGVzIHRoZSBleHRlcm5hbCBzZXJpYWxpemF0aW9uIGFuZCBkZXNlcmlhbGl6YXRpb24gb2Yge0BsaW5rIFNlcmlhbGl6YWJsZX0gb2JqZWN0cy4gVGhlIGludGVybmFsIHByb2Nlc3MgaXMgaGFuZGxlZCBieSB0aGUgb2JqZWN0cyB0aGVtc2VsdmVzLiAgXHJcbiAgICogQSB7QGxpbmsgU2VyaWFsaXphdGlvbn0gb2JqZWN0IGNhbiBiZSBjcmVhdGVkIGZyb20gYSB7QGxpbmsgU2VyaWFsaXphYmxlfSBvYmplY3QgYW5kIGEgSlNPTi1TdHJpbmcgbWF5IGJlIGNyZWF0ZWQgZnJvbSB0aGF0LiAgXHJcbiAgICogVmljZSB2ZXJzYSwgYSBKU09OLVN0cmluZyBjYW4gYmUgcGFyc2VkIHRvIGEge0BsaW5rIFNlcmlhbGl6YXRpb259IHdoaWNoIGNhbiBiZSBkZXNlcmlhbGl6ZWQgdG8gYSB7QGxpbmsgU2VyaWFsaXphYmxlfSBvYmplY3QuXHJcbiAgICogYGBgcGxhaW50ZXh0XHJcbiAgICogIFtTZXJpYWxpemFibGVdIOKGkiAoc2VyaWFsaXplKSDihpIgW1NlcmlhbGl6YXRpb25dIOKGkiAoc3RyaW5naWZ5KSDihpIgW1N0cmluZ10g4oaSIChzYXZlIG9yIHNlbmQpXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4oaTICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKGkyAgICAgICAgICAgICAgICAgIOKGkyAgICAgICAgIFxyXG4gICAqICAgICAgICAgICAgICAgIFtTZXJpYWxpemFibGVdIOKGkCAoZGVzZXJpYWxpemUpIOKGkCBbU2VyaWFsaXphdGlvbl0g4oaQIChwYXJzZSkg4oaQIChsb2FkKSDihpAgW01lZGl1bV1cclxuICAgKiBgYGAgICAgICBcclxuICAgKiBXaGlsZSB0aGUgaW50ZXJuYWwgc2VyaWFsaXplL2Rlc2VyaWFsaXplIG1ldGhvZDFzIG9mIHRoZSBvYmplY3RzIGNhcmUgb2YgdGhlIHNlbGVjdGlvbiBvZiBpbmZvcm1hdGlvbiBuZWVkZWQgdG8gcmVjcmVhdGUgdGhlIG9iamVjdCBhbmQgaXRzIHN0cnVjdHVyZSwgIFxyXG4gICAqIHRoZSB7QGxpbmsgU2VyaWFsaXplcn0ga2VlcHMgdHJhY2sgb2YgdGhlIG5hbWVzcGFjZXMgYW5kIGNsYXNzZXMgaW4gb3JkZXIgdG8gcmVjcmVhdGUge0BsaW5rIFNlcmlhbGl6YWJsZX0gb2JqZWN0cy4gVGhlIGdlbmVyYWwgc3RydWN0dXJlIG9mIGEge0BsaW5rIFNlcmlhbGl6YXRpb259IGlzIGFzIGZvbGxvd3MgIFxyXG4gICAqIGBgYHBsYWludGV4dFxyXG4gICAqIHtcclxuICAgKiAgICAgIG5hbWVzcGFjZU5hbWUuY2xhc3NOYW1lOiB7XHJcbiAgICogICAgICAgICAgcHJvcGVydHlOYW1lOiBwcm9wZXJ0eVZhbHVlLFxyXG4gICAqICAgICAgICAgIC4uLixcclxuICAgKiAgICAgICAgICBwcm9wZXJ0eU5hbWVPZlJlZmVyZW5jZTogU2VyaWFsaXphdGlvbk9mVGhlUmVmZXJlbmNlZE9iamVjdCxcclxuICAgKiAgICAgICAgICAuLi4sXHJcbiAgICogICAgICAgICAgY29uc3RydWN0b3JOYW1lT2ZTdXBlcmNsYXNzOiBTZXJpYWxpemF0aW9uT2ZTdXBlckNsYXNzXHJcbiAgICogICAgICB9XHJcbiAgICogfVxyXG4gICAqIGBgYFxyXG4gICAqIFNpbmNlIHRoZSBpbnN0YW5jZSBvZiB0aGUgc3VwZXJjbGFzcyBpcyBjcmVhdGVkIGF1dG9tYXRpY2FsbHkgd2hlbiBhbiBvYmplY3QgaXMgY3JlYXRlZCwgXHJcbiAgICogdGhlIFNlcmlhbGl6YXRpb25PZlN1cGVyQ2xhc3Mgb21pdHMgdGhlIHRoZSBuYW1lc3BhY2VOYW1lLmNsYXNzTmFtZSBrZXkgYW5kIGNvbnNpc3RzIG9ubHkgb2YgaXRzIHZhbHVlLiBcclxuICAgKiBUaGUgY29uc3RydWN0b3JOYW1lT2ZTdXBlcmNsYXNzIGlzIGdpdmVuIGluc3RlYWQgYXMgYSBwcm9wZXJ0eSBuYW1lIGluIHRoZSBzZXJpYWxpemF0aW9uIG9mIHRoZSBzdWJjbGFzcy5cclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgU2VyaWFsaXplciB7XHJcbiAgICAvKiogSW4gb3JkZXIgZm9yIHRoZSBTZXJpYWxpemVyIHRvIGNyZWF0ZSBjbGFzcyBpbnN0YW5jZXMsIGl0IG5lZWRzIGFjY2VzcyB0byB0aGUgYXBwcm9wcmlhdGUgbmFtZXNwYWNlcyAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgbmFtZXNwYWNlczogTmFtZXNwYWNlUmVnaXN0ZXIgPSB7IFwixpJcIjogRnVkZ2VDb3JlIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcnMgYSBuYW1lc3BhY2UgdG8gdGhlIHtAbGluayBTZXJpYWxpemVyfSwgdG8gZW5hYmxlIGF1dG9tYXRpYyBpbnN0YW50aWF0aW9uIG9mIGNsYXNzZXMgZGVmaW5lZCB3aXRoaW5cclxuICAgICAqIEBwYXJhbSBfbmFtZXNwYWNlIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlZ2lzdGVyTmFtZXNwYWNlKF9uYW1lc3BhY2U6IE9iamVjdCk6IHN0cmluZyB7XHJcbiAgICAgIGZvciAobGV0IG5hbWUgaW4gU2VyaWFsaXplci5uYW1lc3BhY2VzKVxyXG4gICAgICAgIGlmIChTZXJpYWxpemVyLm5hbWVzcGFjZXNbbmFtZV0gPT0gX25hbWVzcGFjZSlcclxuICAgICAgICAgIHJldHVybiBuYW1lO1xyXG5cclxuICAgICAgbGV0IG5hbWU6IHN0cmluZyA9IFNlcmlhbGl6ZXIuZmluZE5hbWVzcGFjZUluKF9uYW1lc3BhY2UsIHdpbmRvdyk7XHJcbiAgICAgIGlmICghbmFtZSlcclxuICAgICAgICBmb3IgKGxldCBwYXJlbnROYW1lIGluIFNlcmlhbGl6ZXIubmFtZXNwYWNlcykge1xyXG4gICAgICAgICAgbmFtZSA9IFNlcmlhbGl6ZXIuZmluZE5hbWVzcGFjZUluKF9uYW1lc3BhY2UsIFNlcmlhbGl6ZXIubmFtZXNwYWNlc1twYXJlbnROYW1lXSk7XHJcbiAgICAgICAgICBpZiAobmFtZSkge1xyXG4gICAgICAgICAgICBuYW1lID0gcGFyZW50TmFtZSArIFwiLlwiICsgbmFtZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFuYW1lKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5hbWVzcGFjZSBub3QgZm91bmQuIE1heWJlIHBhcmVudCBuYW1lc3BhY2UgaGFzbid0IGJlZW4gcmVnaXN0ZXJlZCBiZWZvcmU/XCIpO1xyXG5cclxuICAgICAgU2VyaWFsaXplci5uYW1lc3BhY2VzW25hbWVdID0gX25hbWVzcGFjZTtcclxuICAgICAgcmV0dXJuIG5hbWU7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGphdmFzY3JpcHQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgc2VyaWFsaXphYmxlIEZVREdFLW9iamVjdCBnaXZlbixcclxuICAgICAqIGluY2x1ZGluZyBhdHRhY2hlZCBjb21wb25lbnRzLCBjaGlsZHJlbiwgc3VwZXJjbGFzcy1vYmplY3RzIGFsbCBpbmZvcm1hdGlvbiBuZWVkZWQgZm9yIHJlY29uc3RydWN0aW9uXHJcbiAgICAgKiBAcGFyYW0gX29iamVjdCBBbiBvYmplY3QgdG8gc2VyaWFsaXplLCBpbXBsZW1lbnRpbmcgdGhlIHtAbGluayBTZXJpYWxpemFibGV9IGludGVyZmFjZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHNlcmlhbGl6ZShfb2JqZWN0OiBTZXJpYWxpemFibGUpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7fTtcclxuICAgICAgLy8gVE9ETzogc2F2ZSB0aGUgbmFtZXNwYWNlIHdpdGggdGhlIGNvbnN0cnVjdG9ycyBuYW1lXHJcbiAgICAgIC8vIHNlcmlhbGl6YXRpb25bX29iamVjdC5jb25zdHJ1Y3Rvci5uYW1lXSA9IF9vYmplY3Quc2VyaWFsaXplKCk7XHJcbiAgICAgIGxldCBwYXRoOiBzdHJpbmcgPSB0aGlzLmdldEZ1bGxQYXRoKF9vYmplY3QpO1xyXG4gICAgICBpZiAoIXBhdGgpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOYW1lc3BhY2Ugb2Ygc2VyaWFsaXphYmxlIG9iamVjdCBvZiB0eXBlICR7X29iamVjdC5jb25zdHJ1Y3Rvci5uYW1lfSBub3QgZm91bmQuIE1heWJlIHRoZSBuYW1lc3BhY2UgaGFzbid0IGJlZW4gcmVnaXN0ZXJlZCBvciB0aGUgY2xhc3Mgbm90IGV4cG9ydGVkP2ApO1xyXG4gICAgICBzZXJpYWxpemF0aW9uW3BhdGhdID0gX29iamVjdC5zZXJpYWxpemUoKTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICAgIC8vIHJldHVybiBfb2JqZWN0LnNlcmlhbGl6ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIEZVREdFLW9iamVjdCByZWNvbnN0cnVjdGVkIGZyb20gdGhlIGluZm9ybWF0aW9uIGluIHRoZSB7QGxpbmsgU2VyaWFsaXphdGlvbn0gZ2l2ZW4sXHJcbiAgICAgKiBpbmNsdWRpbmcgYXR0YWNoZWQgY29tcG9uZW50cywgY2hpbGRyZW4sIHN1cGVyY2xhc3Mtb2JqZWN0c1xyXG4gICAgICogQHBhcmFtIF9zZXJpYWxpemF0aW9uIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgbGV0IHJlY29uc3RydWN0OiBTZXJpYWxpemFibGU7XHJcbiAgICAgIGxldCBwYXRoOiBzdHJpbmc7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgLy8gbG9vcCBjb25zdHJ1Y3RlZCBzb2xlbHkgdG8gYWNjZXNzIHR5cGUtcHJvcGVydHkuIE9ubHkgb25lIGV4cGVjdGVkIVxyXG4gICAgICAgIGZvciAocGF0aCBpbiBfc2VyaWFsaXphdGlvbikge1xyXG4gICAgICAgICAgLy8gcmVjb25zdHJ1Y3QgPSBuZXcgKDxHZW5lcmFsPkZ1ZGdlKVt0eXBlTmFtZV07XHJcbiAgICAgICAgICByZWNvbnN0cnVjdCA9IFNlcmlhbGl6ZXIucmVjb25zdHJ1Y3QocGF0aCk7XHJcbiAgICAgICAgICByZWNvbnN0cnVjdCA9IGF3YWl0IHJlY29uc3RydWN0LmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uW3BhdGhdKTtcclxuICAgICAgICAgIHJldHVybiByZWNvbnN0cnVjdDtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRGVzZXJpYWxpemF0aW9uIG9mICR7cGF0aH0gZmFpbGVkOiBgICsgX2Vycm9yKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gQXJyYXkgb2YgamF2YXNjcmlwdCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzZXJpYWxpemFibGUgRlVER0Utb2JqZWN0cyBnaXZlbiBpbiB0aGUgYXJyYXksXHJcbiAgICAgKiBpbmNsdWRpbmcgYXR0YWNoZWQgY29tcG9uZW50cywgY2hpbGRyZW4sIHN1cGVyY2xhc3Mtb2JqZWN0cyBhbGwgaW5mb3JtYXRpb24gbmVlZGVkIGZvciByZWNvbnN0cnVjdGlvblxyXG4gICAgICogQHBhcmFtIF9vYmplY3QgQW4gb2JqZWN0IHRvIHNlcmlhbGl6ZSwgaW1wbGVtZW50aW5nIHRoZSB7QGxpbmsgU2VyaWFsaXphYmxlfSBpbnRlcmZhY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzZXJpYWxpemVBcnJheTxUIGV4dGVuZHMgU2VyaWFsaXphYmxlPihfdHlwZTogbmV3ICgpID0+IFQsIF9vYmplY3RzOiBTZXJpYWxpemFibGVbXSk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbnM6IFNlcmlhbGl6YXRpb25bXSA9IFtdO1xyXG4gICAgICBsZXQgcGF0aDogc3RyaW5nID0gdGhpcy5nZXRGdWxsUGF0aChuZXcgX3R5cGUoKSk7XHJcbiAgICAgIGlmICghcGF0aClcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5hbWVzcGFjZSBvZiBzZXJpYWxpemFibGUgb2JqZWN0IG9mIHR5cGUgJHtfdHlwZS5uYW1lfSBub3QgZm91bmQuIE1heWJlIHRoZSBuYW1lc3BhY2UgaGFzbid0IGJlZW4gcmVnaXN0ZXJlZCBvciB0aGUgY2xhc3Mgbm90IGV4cG9ydGVkP2ApO1xyXG4gICAgICBcclxuICAgICAgZm9yIChsZXQgb2JqZWN0IG9mIF9vYmplY3RzKVxyXG4gICAgICAgIHNlcmlhbGl6YXRpb25zLnB1c2gob2JqZWN0LnNlcmlhbGl6ZSgpKTtcclxuXHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge307XHJcbiAgICAgIHNlcmlhbGl6YXRpb25bcGF0aF0gPSBzZXJpYWxpemF0aW9ucztcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIEFycmF5IG9mIEZVREdFLW9iamVjdHMgcmVjb25zdHJ1Y3RlZCBmcm9tIHRoZSBpbmZvcm1hdGlvbiBpbiB0aGUgYXJyYXkgb2Yge0BsaW5rIFNlcmlhbGl6YXRpb259cyBnaXZlbixcclxuICAgICAqIGluY2x1ZGluZyBhdHRhY2hlZCBjb21wb25lbnRzLCBjaGlsZHJlbiwgc3VwZXJjbGFzcy1vYmplY3RzXHJcbiAgICAgKiBAcGFyYW0gX3NlcmlhbGl6YXRpb25zIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplQXJyYXkoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZVtdPiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemFibGVzOiBTZXJpYWxpemFibGVbXSA9IFtdO1xyXG4gICAgICBsZXQgY29uc3RydWN0OiBuZXcgKCkgPT4gU2VyaWFsaXphYmxlO1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbnM6IFNlcmlhbGl6YXRpb25bXSA9IFtdO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIC8vIGxvb3AgY29uc3RydWN0ZWQgc29sZWx5IHRvIGFjY2VzcyB0eXBlLXByb3BlcnR5LiBPbmx5IG9uZSBleHBlY3RlZCFcclxuICAgICAgICBmb3IgKGxldCBwYXRoIGluIF9zZXJpYWxpemF0aW9uKSB7XHJcbiAgICAgICAgICBjb25zdHJ1Y3QgPSBTZXJpYWxpemVyLmdldENvbnN0cnVjdG9yKHBhdGgpO1xyXG4gICAgICAgICAgc2VyaWFsaXphdGlvbnMgPSBfc2VyaWFsaXphdGlvbltwYXRoXTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVzZXJpYWxpemF0aW9uIGZhaWxlZDogXCIgKyBfZXJyb3IpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKGxldCBzZXJpYWxpemF0aW9uIG9mIHNlcmlhbGl6YXRpb25zKSB7XHJcbiAgICAgICAgbGV0IHNlcmlhbGl6YWJsZTogU2VyaWFsaXphYmxlID0gbmV3IGNvbnN0cnVjdCgpO1xyXG4gICAgICAgIGF3YWl0IHNlcmlhbGl6YWJsZS5kZXNlcmlhbGl6ZShzZXJpYWxpemF0aW9uKTtcclxuICAgICAgICBzZXJpYWxpemFibGVzLnB1c2goc2VyaWFsaXphYmxlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YWJsZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy9UT0RPOiBpbXBsZW1lbnQgcHJldHRpZmllciB0byBtYWtlIEpTT04tU3RyaW5naWZpY2F0aW9uIG9mIHNlcmlhbGl6YXRpb25zIG1vcmUgcmVhZGFibGUsIGUuZy4gcGxhY2luZyB4LCB5IGFuZCB6IGluIG9uZSBsaW5lXHJcbiAgICBwdWJsaWMgc3RhdGljIHByZXR0aWZ5KF9qc29uOiBzdHJpbmcpOiBzdHJpbmcgeyByZXR1cm4gX2pzb247IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBmb3JtYXR0ZWQsIGh1bWFuIHJlYWRhYmxlIEpTT04tU3RyaW5nLCByZXByZXNlbnRpbmcgdGhlIGdpdmVuIHtAbGluayBTZXJpYWxpemF0aW9ufSB0aGF0IG1heSBoYXZlIGJlZW4gY3JlYXRlZCBieSB7QGxpbmsgU2VyaWFsaXplcn0uc2VyaWFsaXplXHJcbiAgICAgKiBAcGFyYW0gX3NlcmlhbGl6YXRpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzdHJpbmdpZnkoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBzdHJpbmcge1xyXG4gICAgICAvLyBhZGp1c3RtZW50cyB0byBzZXJpYWxpemF0aW9uIGNhbiBiZSBtYWRlIGhlcmUgYmVmb3JlIHN0cmluZ2lmaWNhdGlvbiwgaWYgZGVzaXJlZFxyXG4gICAgICBsZXQganNvbjogc3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoX3NlcmlhbGl6YXRpb24sIG51bGwsIDIpO1xyXG4gICAgICBsZXQgcHJldHR5OiBzdHJpbmcgPSBTZXJpYWxpemVyLnByZXR0aWZ5KGpzb24pO1xyXG4gICAgICByZXR1cm4gcHJldHR5O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHtAbGluayBTZXJpYWxpemF0aW9ufSBjcmVhdGVkIGZyb20gdGhlIGdpdmVuIEpTT04tU3RyaW5nLiBSZXN1bHQgbWF5IGJlIHBhc3NlZCB0byB7QGxpbmsgU2VyaWFsaXplci5kZXNlcmlhbGl6ZX1cclxuICAgICAqIEBwYXJhbSBfanNvbiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBwYXJzZShfanNvbjogc3RyaW5nKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKF9qc29uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IG9mIHRoZSBjbGFzcyBkZWZpbmVkIHdpdGggdGhlIGZ1bGwgcGF0aCBpbmNsdWRpbmcgdGhlIG5hbWVzcGFjZU5hbWUocykgYW5kIHRoZSBjbGFzc05hbWUgc2VwZXJhdGVkIGJ5IGRvdHMoLikgXHJcbiAgICAgKiBAcGFyYW0gX3BhdGggXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVjb25zdHJ1Y3QoX3BhdGg6IHN0cmluZyk6IFNlcmlhbGl6YWJsZSB7XHJcbiAgICAgIGxldCBjb25zdHJ1Y3RvcjogbmV3ICgpID0+IFNlcmlhbGl6YWJsZSA9IFNlcmlhbGl6ZXIuZ2V0Q29uc3RydWN0b3IoX3BhdGgpO1xyXG4gICAgICBsZXQgcmVjb25zdHJ1Y3Rpb246IFNlcmlhbGl6YWJsZSA9IG5ldyBjb25zdHJ1Y3RvcigpO1xyXG4gICAgICByZXR1cm4gcmVjb25zdHJ1Y3Rpb247XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcHVibGljIHN0YXRpYyBnZXRDb25zdHJ1Y3RvcjxUIGV4dGVuZHMgU2VyaWFsaXphYmxlPihfdHlwZTogc3RyaW5nLCBfbmFtZXNwYWNlOiBPYmplY3QgPSBGdWRnZUNvcmUpOiBuZXcgKCkgPT4gVCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENvbnN0cnVjdG9yPFQgZXh0ZW5kcyBTZXJpYWxpemFibGU+KF9wYXRoOiBzdHJpbmcpOiBuZXcgKCkgPT4gVCB7XHJcbiAgICAgIGxldCB0eXBlTmFtZTogc3RyaW5nID0gX3BhdGguc3Vic3RyKF9wYXRoLmxhc3RJbmRleE9mKFwiLlwiKSArIDEpO1xyXG4gICAgICBsZXQgbmFtZXNwYWNlOiBPYmplY3QgPSBTZXJpYWxpemVyLmdldE5hbWVzcGFjZShfcGF0aCk7XHJcbiAgICAgIGlmICghbmFtZXNwYWNlKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29uc3RydWN0b3Igb2Ygc2VyaWFsaXphYmxlIG9iamVjdCBvZiB0eXBlICR7X3BhdGh9IG5vdCBmb3VuZC4gTWF5YmUgdGhlIG5hbWVzcGFjZSBoYXNuJ3QgYmVlbiByZWdpc3RlcmVkP2ApO1xyXG4gICAgICByZXR1cm4gKDxHZW5lcmFsPm5hbWVzcGFjZSlbdHlwZU5hbWVdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZnVsbCBwYXRoIHRvIHRoZSBjbGFzcyBvZiB0aGUgb2JqZWN0LCBpZiBmb3VuZCBpbiB0aGUgcmVnaXN0ZXJlZCBuYW1lc3BhY2VzXHJcbiAgICAgKiBAcGFyYW0gX29iamVjdCBcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0RnVsbFBhdGgoX29iamVjdDogU2VyaWFsaXphYmxlKTogc3RyaW5nIHtcclxuICAgICAgbGV0IHR5cGVOYW1lOiBzdHJpbmcgPSBfb2JqZWN0LmNvbnN0cnVjdG9yLm5hbWU7XHJcbiAgICAgIC8vIERlYnVnLmxvZyhcIlNlYXJjaGluZyBuYW1lc3BhY2Ugb2Y6IFwiICsgdHlwZU5hbWUpO1xyXG4gICAgICBmb3IgKGxldCBuYW1lc3BhY2VOYW1lIGluIFNlcmlhbGl6ZXIubmFtZXNwYWNlcykge1xyXG4gICAgICAgIGxldCBmb3VuZDogR2VuZXJhbCA9ICg8R2VuZXJhbD5TZXJpYWxpemVyLm5hbWVzcGFjZXMpW25hbWVzcGFjZU5hbWVdW3R5cGVOYW1lXTtcclxuICAgICAgICBpZiAoZm91bmQgJiYgX29iamVjdCBpbnN0YW5jZW9mIGZvdW5kKVxyXG4gICAgICAgICAgcmV0dXJuIG5hbWVzcGFjZU5hbWUgKyBcIi5cIiArIHR5cGVOYW1lO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbmFtZXNwYWNlLW9iamVjdCBkZWZpbmVkIHdpdGhpbiB0aGUgZnVsbCBwYXRoLCBpZiByZWdpc3RlcmVkXHJcbiAgICAgKiBAcGFyYW0gX3BhdGhcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0TmFtZXNwYWNlKF9wYXRoOiBzdHJpbmcpOiBPYmplY3Qge1xyXG4gICAgICBsZXQgbmFtZXNwYWNlTmFtZTogc3RyaW5nID0gX3BhdGguc3Vic3RyKDAsIF9wYXRoLmxhc3RJbmRleE9mKFwiLlwiKSk7XHJcbiAgICAgIHJldHVybiBTZXJpYWxpemVyLm5hbWVzcGFjZXNbbmFtZXNwYWNlTmFtZV0gfHwgRnVkZ2VDb3JlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmluZHMgdGhlIG5hbWVzcGFjZS1vYmplY3QgaW4gcHJvcGVydGllcyBvZiB0aGUgcGFyZW50LW9iamVjdCAoZS5nLiB3aW5kb3cpLCBpZiBwcmVzZW50XHJcbiAgICAgKiBAcGFyYW0gX25hbWVzcGFjZSBcclxuICAgICAqIEBwYXJhbSBfcGFyZW50IFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBmaW5kTmFtZXNwYWNlSW4oX25hbWVzcGFjZTogT2JqZWN0LCBfcGFyZW50OiBPYmplY3QpOiBzdHJpbmcge1xyXG4gICAgICBmb3IgKGxldCBwcm9wIGluIF9wYXJlbnQpXHJcbiAgICAgICAgaWYgKCg8R2VuZXJhbD5fcGFyZW50KVtwcm9wXSA9PSBfbmFtZXNwYWNlKVxyXG4gICAgICAgICAgcmV0dXJuIHByb3A7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vVHJhbnNmZXIvU2VyaWFsaXplci50c1wiLz5cclxuLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9UcmFuc2Zlci9NdXRhYmxlLnRzXCIvPlxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKiogXHJcbiAgICogU3VwZXJjbGFzcyBmb3IgYWxsIHtAbGluayBDb21wb25lbnR9cyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byB7QGxpbmsgTm9kZX1zLlxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIwIHwgSmFzY2hhIEthcmFnw7ZsLCBIRlUsIDIwMTkgIFxyXG4gICAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9KaXJrYURlbGxPcm8vRlVER0Uvd2lraS9Db21wb25lbnRcclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgQ29tcG9uZW50IGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZSB7XHJcbiAgICAvKiogc3ViY2xhc3NlcyBnZXQgYSBpU3ViY2xhc3MgbnVtYmVyIGZvciBpZGVudGlmaWNhdGlvbiAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlcjtcclxuICAgIC8qKiByZWZlcnMgYmFjayB0byB0aGlzIGNsYXNzIGZyb20gYW55IHN1YmNsYXNzIGUuZy4gaW4gb3JkZXIgdG8gZmluZCBjb21wYXRpYmxlIG90aGVyIHJlc291cmNlcyovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGJhc2VDbGFzczogdHlwZW9mIENvbXBvbmVudCA9IENvbXBvbmVudDtcclxuICAgIC8qKiBsaXN0IG9mIGFsbCB0aGUgc3ViY2xhc3NlcyBkZXJpdmVkIGZyb20gdGhpcyBjbGFzcywgaWYgdGhleSByZWdpc3RlcmVkIHByb3Blcmx5Ki9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgc3ViY2xhc3NlczogdHlwZW9mIENvbXBvbmVudFtdID0gW107XHJcbiAgICBcclxuICAgICNub2RlOiBOb2RlIHwgbnVsbCA9IG51bGw7XHJcbiAgICBwcm90ZWN0ZWQgc2luZ2xldG9uOiBib29sZWFuID0gdHJ1ZTtcclxuICAgIHByb3RlY3RlZCBhY3RpdmU6IGJvb2xlYW4gPSB0cnVlO1xyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVnaXN0ZXJTdWJjbGFzcyhfc3ViY2xhc3M6IHR5cGVvZiBDb21wb25lbnQpOiBudW1iZXIgeyByZXR1cm4gQ29tcG9uZW50LnN1YmNsYXNzZXMucHVzaChfc3ViY2xhc3MpIC0gMTsgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgaXNBY3RpdmUoKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLmFjdGl2ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIElzIHRydWUsIHdoZW4gb25seSBvbmUgaW5zdGFuY2Ugb2YgdGhlIGNvbXBvbmVudCBjbGFzcyBjYW4gYmUgYXR0YWNoZWQgdG8gYSBub2RlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgaXNTaW5nbGV0b24oKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNpbmdsZXRvbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyB0aGUgbm9kZSwgdGhpcyBjb21wb25lbnQgaXMgY3VycmVudGx5IGF0dGFjaGVkIHRvXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgbm9kZSgpOiBOb2RlIHwgbnVsbCB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNub2RlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhY3RpdmF0ZShfb246IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgdGhpcy5hY3RpdmUgPSBfb247XHJcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoX29uID8gRVZFTlQuQ09NUE9ORU5UX0FDVElWQVRFIDogRVZFTlQuQ09NUE9ORU5UX0RFQUNUSVZBVEUpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyaWVzIHRvIGF0dGFjaCB0aGUgY29tcG9uZW50IHRvIHRoZSBnaXZlbiBub2RlLCByZW1vdmluZyBpdCBmcm9tIHRoZSBub2RlIGl0IHdhcyBhdHRhY2hlZCB0byBpZiBhcHBsaWNhYmxlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhdHRhY2hUb05vZGUoX2NvbnRhaW5lcjogTm9kZSB8IG51bGwpOiB2b2lkIHtcclxuICAgICAgaWYgKHRoaXMuI25vZGUgPT0gX2NvbnRhaW5lcilcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIGxldCBwcmV2aW91c0NvbnRhaW5lcjogTm9kZSA9IHRoaXMuI25vZGU7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKHByZXZpb3VzQ29udGFpbmVyKVxyXG4gICAgICAgICAgcHJldmlvdXNDb250YWluZXIucmVtb3ZlQ29tcG9uZW50KHRoaXMpO1xyXG4gICAgICAgIHRoaXMuI25vZGUgPSBfY29udGFpbmVyO1xyXG4gICAgICAgIGlmICh0aGlzLiNub2RlKVxyXG4gICAgICAgICAgdGhpcy4jbm9kZS5hZGRDb21wb25lbnQodGhpcyk7XHJcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xyXG4gICAgICAgIHRoaXMuI25vZGUgPSBwcmV2aW91c0NvbnRhaW5lcjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge1xyXG4gICAgICAgIGFjdGl2ZTogdGhpcy5hY3RpdmVcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICB0aGlzLmFjdGl2YXRlKF9zZXJpYWxpemF0aW9uLmFjdGl2ZSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgdGhpcy5hY3RpdmF0ZShfbXV0YXRvci5hY3RpdmUpO1xyXG4gICAgICBzdXBlci5tdXRhdGUoX211dGF0b3IpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5zaW5nbGV0b247XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5tdHhXb3JsZDtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFdyYXBzIGEgcmVndWxhciBKYXZhc2NyaXB0IEFycmF5IGFuZCBvZmZlcnMgdmVyeSBsaW1pdGVkIGZ1bmN0aW9uYWxpdHkgZ2VhcmVkIHNvbGVseSB0b3dhcmRzIGF2b2lkaW5nIGdhcmJhZ2UgY29sbGV0aW9uLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBSZWN5Y2FibGVBcnJheTxUPiB7XHJcbiAgICAjbGVuZ3RoOiBudW1iZXIgPSAwO1xyXG4gICAgI2FycmF5OiBBcnJheTxUPiA9IG5ldyBBcnJheTxUPigpO1xyXG4gICAgLy8gI3R5cGU6IG5ldyAoKSA9PiBUO1xyXG5cclxuICAgIC8vIC8vdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxyXG4gICAgLy8gY29uc3RydWN0b3IoX3R5cGU6IG5ldyAoLi4uYXJnczogYW55W10pID0+IFQpIHtcclxuICAgIC8vICAgdGhpcy4jdHlwZSA9IF90eXBlO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgbGVuZ3RoKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNsZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSB2aXJ0dWFsIGxlbmd0aCBvZiB0aGUgYXJyYXkgdG8gemVybyBidXQga2VlcHMgdGhlIGVudHJpZXMgYmV5b25kLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuI2xlbmd0aCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHB1c2goX2VudHJ5OiBUKTogbnVtYmVyIHtcclxuICAgICAgdGhpcy4jYXJyYXlbdGhpcy4jbGVuZ3RoXSA9IF9lbnRyeTtcclxuICAgICAgdGhpcy4jbGVuZ3RoKys7XHJcbiAgICAgIHJldHVybiB0aGlzLiNsZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHBvcCgpOiBUIHtcclxuICAgICAgdGhpcy4jbGVuZ3RoLS07XHJcbiAgICAgIHJldHVybiB0aGlzLiNhcnJheVt0aGlzLiNsZW5ndGhdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVjeWNsZXMgdGhlIG9iamVjdCBmb2xsb3dpbmcgdGhlIGxhc3QgaW4gdGhlIGFycmF5IGFuZCBpbmNyZWFzZXMgdGhlIGFycmF5IGxlbmd0aFxyXG4gICAgICogSXQgbXVzdCBiZSBhc3N1cmVkLCB0aGF0IG5vbmUgb2YgdGhlIG9iamVjdHMgaW4gdGhlIGFycmF5IGlzIHN0aWxsIGluIGFueSB1c2Ugb2YgYW55IGtpbmQhXHJcbiAgICAgKi9cclxuICAgIC8vIHB1YmxpYyByZWN5Y2xlKCk6IFQge1xyXG4gICAgLy8gICBpZiAodGhpcy4jbGVuZ3RoIDwgdGhpcy4jYXJyYXkubGVuZ3RoKSB7XHJcbiAgICAvLyAgICAgdGhpcy4jbGVuZ3RoKys7XHJcbiAgICAvLyAgICAgcmV0dXJuIHRoaXMuI2FycmF5W3RoaXMuI2xlbmd0aCsrXTtcclxuICAgIC8vICAgfVxyXG4gICAgLy8gICB0aGlzLiNhcnJheS5wdXNoKFJlY3ljbGVyLmdldCh0aGlzLiN0eXBlKSk7XHJcbiAgICAvLyAgIHJldHVybiB0aGlzLiNhcnJheVt0aGlzLiNsZW5ndGgrK107XHJcbiAgICAvLyB9XHJcblxyXG4gICAgcHVibGljICpbU3ltYm9sLml0ZXJhdG9yXSgpOiBJdGVyYWJsZUl0ZXJhdG9yPFQ+IHtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMuI2xlbmd0aDsgaSsrKVxyXG4gICAgICAgIHlpZWxkIHRoaXMuI2FycmF5W2ldO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRTb3J0ZWQoX3NvcnQ6IChhOiBULCBiOiBUKSA9PiBudW1iZXIpOiBUW10ge1xyXG4gICAgICBsZXQgc29ydGVkOiBUW10gPSB0aGlzLiNhcnJheS5zbGljZSgwLCB0aGlzLiNsZW5ndGgpO1xyXG4gICAgICBzb3J0ZWQuc29ydChfc29ydCk7XHJcbiAgICAgIHJldHVybiBzb3J0ZWQ7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLy9CYXNlY2xhc3MgZm9yIHtAbGluayBSZW5kZXJJbmplY3RvckNvYXR9IGFuZCB7QGxpbmsgUmVuZGVySW5qZWN0b3JUZXh0dXJlXV1cclxuICBleHBvcnQgY2xhc3MgUmVuZGVySW5qZWN0b3Ige1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgaW5qZWN0KF9jb25zdHJ1Y3RvcjogRnVuY3Rpb24sIF9pbmplY3RvcjogdHlwZW9mIFJlbmRlckluamVjdG9yKTogdm9pZCB7XHJcbiAgICAgIGxldCBpbmplY3Rpb246IEZ1bmN0aW9uID0gUmVmbGVjdC5nZXQoX2luamVjdG9yLCBcImluamVjdFwiICsgX2NvbnN0cnVjdG9yLm5hbWUpO1xyXG4gICAgICBpZiAoIWluamVjdGlvbikge1xyXG4gICAgICAgIERlYnVnLmVycm9yKFwiTm8gaW5qZWN0aW9uIGRlY29yYXRvciBkZWZpbmVkIGZvciBcIiArIF9jb25zdHJ1Y3Rvci5uYW1lKTtcclxuICAgICAgfVxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2NvbnN0cnVjdG9yLnByb3RvdHlwZSwgXCJ1c2VSZW5kZXJEYXRhXCIsIHtcclxuICAgICAgICB2YWx1ZTogaW5qZWN0aW9uXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8vZ2l2ZXMgV2ViR0wgQnVmZmVyIHRoZSBkYXRhIGZyb20gdGhlIHtAbGluayBTaGFkZXJ9XHJcbiAgZXhwb3J0IGNsYXNzIFJlbmRlckluamVjdG9yU2hhZGVyIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgZGVjb3JhdGUoX2NvbnN0cnVjdG9yOiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2NvbnN0cnVjdG9yLCBcInVzZVByb2dyYW1cIiwge1xyXG4gICAgICAgIHZhbHVlOiBSZW5kZXJJbmplY3RvclNoYWRlci51c2VQcm9ncmFtXHJcbiAgICAgIH0pO1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2NvbnN0cnVjdG9yLCBcImRlbGV0ZVByb2dyYW1cIiwge1xyXG4gICAgICAgIHZhbHVlOiBSZW5kZXJJbmplY3RvclNoYWRlci5kZWxldGVQcm9ncmFtXHJcbiAgICAgIH0pO1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2NvbnN0cnVjdG9yLCBcImNyZWF0ZVByb2dyYW1cIiwge1xyXG4gICAgICAgIHZhbHVlOiBSZW5kZXJJbmplY3RvclNoYWRlci5jcmVhdGVQcm9ncmFtXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgdXNlUHJvZ3JhbSh0aGlzOiB0eXBlb2YgU2hhZGVyKTogdm9pZCB7XHJcbiAgICAgIGlmICghdGhpcy5wcm9ncmFtKVxyXG4gICAgICAgIHRoaXMuY3JlYXRlUHJvZ3JhbSgpO1xyXG4gICAgICBsZXQgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcclxuICAgICAgY3JjMy51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBkZWxldGVQcm9ncmFtKHRoaXM6IHR5cGVvZiBTaGFkZXIpOiB2b2lkIHtcclxuICAgICAgbGV0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcbiAgICAgIGlmICh0aGlzLnByb2dyYW0pIHtcclxuICAgICAgICBjcmMzLmRlbGV0ZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcclxuICAgICAgICBkZWxldGUgdGhpcy5hdHRyaWJ1dGVzO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLnVuaWZvcm1zO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBjcmVhdGVQcm9ncmFtKHRoaXM6IHR5cGVvZiBTaGFkZXIpOiB2b2lkIHtcclxuICAgICAgRGVidWcuZnVkZ2UoXCJDcmVhdGUgc2hhZGVyIHByb2dyYW1cIiwgdGhpcy5uYW1lKTtcclxuICAgICAgbGV0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcbiAgICAgIGxldCBwcm9ncmFtOiBXZWJHTFByb2dyYW0gPSBjcmMzLmNyZWF0ZVByb2dyYW0oKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBsZXQgc2hkVmVydGV4OiBXZWJHTFNoYWRlciA9IGNvbXBpbGVTaGFkZXIodGhpcy5nZXRWZXJ0ZXhTaGFkZXJTb3VyY2UoKSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5WRVJURVhfU0hBREVSKTtcclxuICAgICAgICBsZXQgc2hkRnJhZ21lbnQ6IFdlYkdMU2hhZGVyID0gY29tcGlsZVNoYWRlcih0aGlzLmdldEZyYWdtZW50U2hhZGVyU291cmNlKCksIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRlJBR01FTlRfU0hBREVSKTtcclxuICAgICAgICBjcmMzLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBSZW5kZXJXZWJHTC5hc3NlcnQ8V2ViR0xTaGFkZXI+KHNoZFZlcnRleCkpO1xyXG4gICAgICAgIGNyYzMuYXR0YWNoU2hhZGVyKHByb2dyYW0sIFJlbmRlcldlYkdMLmFzc2VydDxXZWJHTFNoYWRlcj4oc2hkRnJhZ21lbnQpKTtcclxuICAgICAgICBjcmMzLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xyXG4gICAgICAgIGxldCBlcnJvcjogc3RyaW5nID0gUmVuZGVyV2ViR0wuYXNzZXJ0PHN0cmluZz4oY3JjMy5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSk7XHJcbiAgICAgICAgaWYgKGVycm9yICE9PSBcIlwiKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBsaW5raW5nIFNoYWRlcjogXCIgKyBlcnJvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xyXG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IGRldGVjdEF0dHJpYnV0ZXMoKTtcclxuICAgICAgICB0aGlzLnVuaWZvcm1zID0gZGV0ZWN0VW5pZm9ybXMoKTtcclxuXHJcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xyXG4gICAgICAgIERlYnVnLmVycm9yKF9lcnJvcik7XHJcbiAgICAgICAgZGVidWdnZXI7XHJcbiAgICAgIH1cclxuXHJcblxyXG4gICAgICBmdW5jdGlvbiBjb21waWxlU2hhZGVyKF9zaGFkZXJDb2RlOiBzdHJpbmcsIF9zaGFkZXJUeXBlOiBHTGVudW0pOiBXZWJHTFNoYWRlciB8IG51bGwge1xyXG4gICAgICAgIGxldCB3ZWJHTFNoYWRlcjogV2ViR0xTaGFkZXIgPSBjcmMzLmNyZWF0ZVNoYWRlcihfc2hhZGVyVHlwZSk7XHJcbiAgICAgICAgY3JjMy5zaGFkZXJTb3VyY2Uod2ViR0xTaGFkZXIsIF9zaGFkZXJDb2RlKTtcclxuICAgICAgICBjcmMzLmNvbXBpbGVTaGFkZXIod2ViR0xTaGFkZXIpO1xyXG4gICAgICAgIGxldCBlcnJvcjogc3RyaW5nID0gUmVuZGVyV2ViR0wuYXNzZXJ0PHN0cmluZz4oY3JjMy5nZXRTaGFkZXJJbmZvTG9nKHdlYkdMU2hhZGVyKSk7XHJcbiAgICAgICAgaWYgKGVycm9yICE9PSBcIlwiKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBjb21waWxpbmcgc2hhZGVyOiBcIiArIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGFueSBjb21waWxhdGlvbiBlcnJvcnMuXHJcbiAgICAgICAgaWYgKCFjcmMzLmdldFNoYWRlclBhcmFtZXRlcih3ZWJHTFNoYWRlciwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5DT01QSUxFX1NUQVRVUykpIHtcclxuICAgICAgICAgIGFsZXJ0KGNyYzMuZ2V0U2hhZGVySW5mb0xvZyh3ZWJHTFNoYWRlcikpO1xyXG4gICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB3ZWJHTFNoYWRlcjtcclxuICAgICAgfVxyXG4gICAgICBmdW5jdGlvbiBkZXRlY3RBdHRyaWJ1dGVzKCk6IHsgW25hbWU6IHN0cmluZ106IG51bWJlciB9IHtcclxuICAgICAgICBsZXQgZGV0ZWN0ZWRBdHRyaWJ1dGVzOiB7IFtuYW1lOiBzdHJpbmddOiBudW1iZXIgfSA9IHt9O1xyXG4gICAgICAgIGxldCBhdHRyaWJ1dGVDb3VudDogbnVtYmVyID0gY3JjMy5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQUNUSVZFX0FUVFJJQlVURVMpO1xyXG4gICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBhdHRyaWJ1dGVDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICBsZXQgYXR0cmlidXRlSW5mbzogV2ViR0xBY3RpdmVJbmZvID0gUmVuZGVyV2ViR0wuYXNzZXJ0PFdlYkdMQWN0aXZlSW5mbz4oY3JjMy5nZXRBY3RpdmVBdHRyaWIocHJvZ3JhbSwgaSkpO1xyXG4gICAgICAgICAgaWYgKCFhdHRyaWJ1dGVJbmZvKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZGV0ZWN0ZWRBdHRyaWJ1dGVzW2F0dHJpYnV0ZUluZm8ubmFtZV0gPSBjcmMzLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIGF0dHJpYnV0ZUluZm8ubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZXRlY3RlZEF0dHJpYnV0ZXM7XHJcbiAgICAgIH1cclxuICAgICAgZnVuY3Rpb24gZGV0ZWN0VW5pZm9ybXMoKTogeyBbbmFtZTogc3RyaW5nXTogV2ViR0xVbmlmb3JtTG9jYXRpb24gfSB7XHJcbiAgICAgICAgbGV0IGRldGVjdGVkVW5pZm9ybXM6IHsgW25hbWU6IHN0cmluZ106IFdlYkdMVW5pZm9ybUxvY2F0aW9uIH0gPSB7fTtcclxuICAgICAgICBsZXQgdW5pZm9ybUNvdW50OiBudW1iZXIgPSBjcmMzLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BQ1RJVkVfVU5JRk9STVMpO1xyXG4gICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB1bmlmb3JtQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgbGV0IGluZm86IFdlYkdMQWN0aXZlSW5mbyA9IFJlbmRlcldlYkdMLmFzc2VydDxXZWJHTEFjdGl2ZUluZm8+KGNyYzMuZ2V0QWN0aXZlVW5pZm9ybShwcm9ncmFtLCBpKSk7XHJcbiAgICAgICAgICBpZiAoIWluZm8pIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBkZXRlY3RlZFVuaWZvcm1zW2luZm8ubmFtZV0gPSBSZW5kZXJXZWJHTC5hc3NlcnQ8V2ViR0xVbmlmb3JtTG9jYXRpb24+KGNyYzMuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIGluZm8ubmFtZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGV0ZWN0ZWRVbmlmb3JtcztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIFxyXG4gIC8vZ2l2ZXMgV2ViR0wgQnVmZmVyIHRoZSBkYXRhIGZyb20gdGhlIHtAbGluayBDb2F0fVxyXG4gIGV4cG9ydCBjbGFzcyBSZW5kZXJJbmplY3RvckNvYXQgZXh0ZW5kcyBSZW5kZXJJbmplY3RvciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIGRlY29yYXRlKF9jb25zdHJ1Y3RvcjogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgUmVuZGVySW5qZWN0b3IuaW5qZWN0KF9jb25zdHJ1Y3RvciwgUmVuZGVySW5qZWN0b3JDb2F0KTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGluamVjdENvYXRDb2xvcmVkKHRoaXM6IENvYXQsIF9zaGFkZXI6IHR5cGVvZiBTaGFkZXIsIF9jbXBNYXRlcmlhbDogQ29tcG9uZW50TWF0ZXJpYWwpOiB2b2lkIHtcclxuICAgICAgbGV0IGNvbG9yVW5pZm9ybUxvY2F0aW9uOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiA9IF9zaGFkZXIudW5pZm9ybXNbXCJ1X3ZjdENvbG9yXCJdO1xyXG4gICAgICBsZXQgY29sb3I6IENvbG9yID0gQ29sb3IuTVVMVElQTFkoKDxDb2F0Q29sb3JlZD50aGlzKS5jb2xvciwgX2NtcE1hdGVyaWFsLmNsclByaW1hcnkpO1xyXG4gICAgICBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCkudW5pZm9ybTRmdihjb2xvclVuaWZvcm1Mb2NhdGlvbiwgY29sb3IuZ2V0QXJyYXkoKSk7XHJcblxyXG4gICAgICBsZXQgc2hpbmluZXNzVW5pZm9ybUxvY2F0aW9uOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiA9IF9zaGFkZXIudW5pZm9ybXNbXCJ1X2ZTaGluaW5lc3NcIl07XHJcbiAgICAgIGxldCBzaGluaW5lc3M6IG51bWJlciA9ICg8Q29hdENvbG9yZWQ+dGhpcykuc2hpbmluZXNzO1xyXG4gICAgICBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCkudW5pZm9ybTFmKHNoaW5pbmVzc1VuaWZvcm1Mb2NhdGlvbiwgc2hpbmluZXNzKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGluamVjdENvYXRUZXh0dXJlZCh0aGlzOiBDb2F0LCBfc2hhZGVyOiB0eXBlb2YgU2hhZGVyLCBfY21wTWF0ZXJpYWw6IENvbXBvbmVudE1hdGVyaWFsKTogdm9pZCB7XHJcbiAgICAgIGxldCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG4gICAgICBSZWZsZWN0LmFwcGx5KFJlbmRlckluamVjdG9yQ29hdC5pbmplY3RDb2F0Q29sb3JlZCwgdGhpcywgW19zaGFkZXIsIF9jbXBNYXRlcmlhbF0pO1xyXG5cclxuICAgICAgKDxDb2F0VGV4dHVyZWQ+dGhpcykudGV4dHVyZS51c2VSZW5kZXJEYXRhKCk7XHJcbiAgICAgIGNyYzMudW5pZm9ybTFpKF9zaGFkZXIudW5pZm9ybXNbXCJ1X3RleHR1cmVcIl0sIDApO1xyXG4gICAgICBjcmMzLnVuaWZvcm1NYXRyaXgzZnYoX3NoYWRlci51bmlmb3Jtc1tcInVfbXR4UGl2b3RcIl0sIGZhbHNlLCBfY21wTWF0ZXJpYWwubXR4UGl2b3QuZ2V0KCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHByb3RlY3RlZCBzdGF0aWMgaW5qZWN0Q29hdE1hdENhcCh0aGlzOiBDb2F0LCBfc2hhZGVyOiB0eXBlb2YgU2hhZGVyLCBfY21wTWF0ZXJpYWw6IENvbXBvbmVudE1hdGVyaWFsKTogdm9pZCB7XHJcbiAgICAvLyAgIGxldCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG5cclxuICAgIC8vICAgbGV0IGNvbG9yVW5pZm9ybUxvY2F0aW9uOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiA9IF9zaGFkZXIudW5pZm9ybXNbXCJ1X3RpbnRfY29sb3JcIl07XHJcbiAgICAvLyAgIGxldCB7IHIsIGcsIGIsIGEgfSA9ICg8Q29hdE1hdENhcD50aGlzKS5jb2xvcjtcclxuICAgIC8vICAgbGV0IHRpbnRDb2xvckFycmF5OiBGbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KFtyLCBnLCBiLCBhXSk7XHJcbiAgICAvLyAgIGNyYzMudW5pZm9ybTRmdihjb2xvclVuaWZvcm1Mb2NhdGlvbiwgdGludENvbG9yQXJyYXkpO1xyXG5cclxuICAgIC8vICAgbGV0IGZsb2F0VW5pZm9ybUxvY2F0aW9uOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiA9IF9zaGFkZXIudW5pZm9ybXNbXCJzaGFkZV9zbW9vdGhcIl07XHJcbiAgICAvLyAgIGxldCBzaGFkZVNtb290aDogbnVtYmVyID0gKDxDb2F0TWF0Q2FwPnRoaXMpLnNoYWRlU21vb3RoO1xyXG4gICAgLy8gICBjcmMzLnVuaWZvcm0xaShmbG9hdFVuaWZvcm1Mb2NhdGlvbiwgc2hhZGVTbW9vdGgpO1xyXG5cclxuICAgIC8vICAgaWYgKHRoaXMucmVuZGVyRGF0YSkge1xyXG4gICAgLy8gICAgIC8vIGJ1ZmZlcnMgZXhpc3RcclxuICAgIC8vICAgICBjcmMzLmFjdGl2ZVRleHR1cmUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFMCk7XHJcbiAgICAvLyAgICAgY3JjMy5iaW5kVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIHRoaXMucmVuZGVyRGF0YVtcInRleHR1cmUwXCJdKTtcclxuICAgIC8vICAgICBjcmMzLnVuaWZvcm0xaShfc2hhZGVyLnVuaWZvcm1zW1widV90ZXh0dXJlXCJdLCAwKTtcclxuICAgIC8vICAgfVxyXG4gICAgLy8gICBlbHNlIHtcclxuICAgIC8vICAgICB0aGlzLnJlbmRlckRhdGEgPSB7fTtcclxuICAgIC8vICAgICAvLyBUT0RPOiBjaGVjayBpZiBhbGwgV2ViR0wtQ3JlYXRpb25zIGFyZSBhc3NlcnRlZFxyXG4gICAgLy8gICAgIGNvbnN0IHRleHR1cmU6IFdlYkdMVGV4dHVyZSA9IFJlbmRlci5hc3NlcnQ8V2ViR0xUZXh0dXJlPihjcmMzLmNyZWF0ZVRleHR1cmUoKSk7XHJcbiAgICAvLyAgICAgY3JjMy5iaW5kVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIHRleHR1cmUpO1xyXG5cclxuICAgIC8vICAgICB0cnkge1xyXG4gICAgLy8gICAgICAgY3JjMy50ZXhJbWFnZTJEKGNyYzMuVEVYVFVSRV8yRCwgMCwgY3JjMy5SR0JBLCBjcmMzLlJHQkEsIGNyYzMuVU5TSUdORURfQllURSwgKDxDb2F0TWF0Q2FwPnRoaXMpLnRleHR1cmUuaW1hZ2UpO1xyXG4gICAgLy8gICAgICAgY3JjMy50ZXhJbWFnZTJEKFxyXG4gICAgLy8gICAgICAgICBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIDAsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuUkdCQSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5SR0JBLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOU0lHTkVEX0JZVEUsXHJcbiAgICAvLyAgICAgICAgICg8Q29hdE1hdENhcD50aGlzKS50ZXh0dXJlLmltYWdlXHJcbiAgICAvLyAgICAgICApO1xyXG4gICAgLy8gICAgIH0gY2F0Y2ggKF9lcnJvcikge1xyXG4gICAgLy8gICAgICAgRGVidWcuZXJyb3IoX2Vycm9yKTtcclxuICAgIC8vICAgICB9XHJcbiAgICAvLyAgICAgY3JjMy50ZXhQYXJhbWV0ZXJpKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFX01BR19GSUxURVIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTkVBUkVTVCk7XHJcbiAgICAvLyAgICAgY3JjMy50ZXhQYXJhbWV0ZXJpKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFX01JTl9GSUxURVIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTkVBUkVTVCk7XHJcbiAgICAvLyAgICAgY3JjMy5nZW5lcmF0ZU1pcG1hcChjcmMzLlRFWFRVUkVfMkQpO1xyXG4gICAgLy8gICAgIHRoaXMucmVuZGVyRGF0YVtcInRleHR1cmUwXCJdID0gdGV4dHVyZTtcclxuXHJcbiAgICAvLyAgICAgY3JjMy5iaW5kVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIG51bGwpO1xyXG4gICAgLy8gICAgIHRoaXMudXNlUmVuZGVyRGF0YShfc2hhZGVyLCBfY21wTWF0ZXJpYWwpO1xyXG4gICAgLy8gICB9XHJcbiAgICAvLyB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGludGVyZmFjZSBSZW5kZXJCdWZmZXJzIHtcclxuICAgIC8vIHJlZ3VsYXIvc21vb3RoIHNoYWRpbmdcclxuICAgIHZlcnRpY2VzOiBXZWJHTEJ1ZmZlcjtcclxuICAgIGluZGljZXM6IFdlYkdMQnVmZmVyO1xyXG4gICAgdGV4dHVyZVVWczogV2ViR0xCdWZmZXI7XHJcbiAgICBub3JtYWxzVmVydGV4OiBXZWJHTEJ1ZmZlcjtcclxuICAgIC8vIGZvciBmbGF0IHNoYWRpbmcgIFRPRE86IG1heSBjcmVhdGUgYW5vdGhlciBSZW5kZXJCdWZmZXIgZm9yIGZsYXRcclxuICAgIHZlcnRpY2VzRmxhdDogV2ViR0xCdWZmZXI7XHJcbiAgICBpbmRpY2VzRmxhdDogV2ViR0xCdWZmZXI7XHJcbiAgICBub3JtYWxzRmxhdDogV2ViR0xCdWZmZXI7XHJcbiAgICB0ZXh0dXJlVVZzRmxhdDogV2ViR0xCdWZmZXI7XHJcbiAgfVxyXG4gIC8vZ2l2ZXMgV2ViR0wgQnVmZmVyIHRoZSBkYXRhIGZyb20gdGhlIHtAbGluayBNZXNoXV1cclxuICBleHBvcnQgY2xhc3MgUmVuZGVySW5qZWN0b3JNZXNoIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgZGVjb3JhdGUoX2NvbnN0cnVjdG9yOiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2NvbnN0cnVjdG9yLnByb3RvdHlwZSwgXCJ1c2VSZW5kZXJCdWZmZXJzXCIsIHtcclxuICAgICAgICB2YWx1ZTogUmVuZGVySW5qZWN0b3JNZXNoLnVzZVJlbmRlckJ1ZmZlcnNcclxuICAgICAgfSk7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfY29uc3RydWN0b3IucHJvdG90eXBlLCBcImNyZWF0ZVJlbmRlckJ1ZmZlcnNcIiwge1xyXG4gICAgICAgIHZhbHVlOiBSZW5kZXJJbmplY3Rvck1lc2guY3JlYXRlUmVuZGVyQnVmZmVyc1xyXG4gICAgICB9KTtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIFwiZGVsZXRlUmVuZGVyQnVmZmVyc1wiLCB7XHJcbiAgICAgICAgdmFsdWU6IFJlbmRlckluamVjdG9yTWVzaC5kZWxldGVSZW5kZXJCdWZmZXJzXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgY3JlYXRlUmVuZGVyQnVmZmVycyh0aGlzOiBNZXNoKTogdm9pZCB7XHJcbiAgICAgIGxldCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG5cclxuICAgICAgZnVuY3Rpb24gY3JlYXRlQnVmZmVyKF90eXBlOiBHTGVudW0sIF9hcnJheTogRmxvYXQzMkFycmF5IHwgVWludDE2QXJyYXkpOiBXZWJHTEJ1ZmZlciB7XHJcbiAgICAgICAgbGV0IGJ1ZmZlcjogV2ViR0xCdWZmZXIgPSBSZW5kZXJXZWJHTC5hc3NlcnQ8V2ViR0xCdWZmZXI+KGNyYzMuY3JlYXRlQnVmZmVyKCkpO1xyXG4gICAgICAgIGNyYzMuYmluZEJ1ZmZlcihfdHlwZSwgYnVmZmVyKTtcclxuICAgICAgICBjcmMzLmJ1ZmZlckRhdGEoX3R5cGUsIF9hcnJheSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5TVEFUSUNfRFJBVyk7XHJcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IHZlcnRpY2VzOiBXZWJHTEJ1ZmZlciA9IGNyZWF0ZUJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgdGhpcy52ZXJ0aWNlcyk7XHJcbiAgICAgIGxldCBpbmRpY2VzOiBXZWJHTEJ1ZmZlciA9IGNyZWF0ZUJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmluZGljZXMpO1xyXG4gICAgICBsZXQgbm9ybWFsc1ZlcnRleDogV2ViR0xCdWZmZXIgPSBjcmVhdGVCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BUlJBWV9CVUZGRVIsIHRoaXMubm9ybWFsc1ZlcnRleCk7XHJcbiAgICAgIGxldCB0ZXh0dXJlVVZzOiBXZWJHTEJ1ZmZlciA9IGNyZWF0ZUJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgdGhpcy50ZXh0dXJlVVZzKTtcclxuICAgICAgbGV0IHZlcnRpY2VzRmxhdDogV2ViR0xCdWZmZXIgPSBjcmVhdGVCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BUlJBWV9CVUZGRVIsIHRoaXMudmVydGljZXNGbGF0KTtcclxuICAgICAgbGV0IGluZGljZXNGbGF0OiBXZWJHTEJ1ZmZlciA9IGNyZWF0ZUJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmluZGljZXNGbGF0KTtcclxuICAgICAgbGV0IG5vcm1hbHNGbGF0OiBXZWJHTEJ1ZmZlciA9IGNyZWF0ZUJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgdGhpcy5ub3JtYWxzRmxhdCk7XHJcbiAgICAgIGxldCB0ZXh0dXJlVVZzRmxhdDogV2ViR0xCdWZmZXIgPSBjcmVhdGVCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BUlJBWV9CVUZGRVIsIHRoaXMudGV4dHVyZVVWc0ZsYXQpO1xyXG5cclxuXHJcbiAgICAgIGxldCByZW5kZXJCdWZmZXJzOiBSZW5kZXJCdWZmZXJzID0ge1xyXG4gICAgICAgIC8vc21vb3RoXHJcbiAgICAgICAgdmVydGljZXM6IHZlcnRpY2VzLFxyXG4gICAgICAgIGluZGljZXM6IGluZGljZXMsXHJcbiAgICAgICAgdGV4dHVyZVVWczogdGV4dHVyZVVWcyxcclxuICAgICAgICBub3JtYWxzVmVydGV4OiBub3JtYWxzVmVydGV4LFxyXG4gICAgICAgIC8vIGZsYXRcclxuICAgICAgICB2ZXJ0aWNlc0ZsYXQ6IHZlcnRpY2VzRmxhdCxcclxuICAgICAgICBpbmRpY2VzRmxhdDogaW5kaWNlc0ZsYXQsXHJcbiAgICAgICAgbm9ybWFsc0ZsYXQ6IG5vcm1hbHNGbGF0LFxyXG4gICAgICAgIHRleHR1cmVVVnNGbGF0OiB0ZXh0dXJlVVZzRmxhdFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgdGhpcy5yZW5kZXJCdWZmZXJzID0gcmVuZGVyQnVmZmVycztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHVzZVJlbmRlckJ1ZmZlcnModGhpczogTWVzaCwgX3NoYWRlcjogdHlwZW9mIFNoYWRlciwgX210eE1lc2hUb1dvcmxkOiBNYXRyaXg0eDQsIF9tdHhNZXNoVG9WaWV3OiBNYXRyaXg0eDQsIF9pZD86IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgIGlmICghdGhpcy5yZW5kZXJCdWZmZXJzKVxyXG4gICAgICAgIHRoaXMuY3JlYXRlUmVuZGVyQnVmZmVycygpO1xyXG4gICAgICBsZXQgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIHNldEJ1ZmZlcihfbmFtZTogc3RyaW5nLCBfYnVmZmVyOiBXZWJHTEJ1ZmZlcik6IHZvaWQge1xyXG4gICAgICAgIGxldCBhdHRyaWJ1dGU6IG51bWJlciA9IF9zaGFkZXIuYXR0cmlidXRlc1tfbmFtZV07XHJcbiAgICAgICAgaWYgKGF0dHJpYnV0ZSA9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY3JjMy5iaW5kQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQVJSQVlfQlVGRkVSLCBfYnVmZmVyKTtcclxuICAgICAgICBjcmMzLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGF0dHJpYnV0ZSk7XHJcbiAgICAgICAgUmVuZGVyV2ViR0wuc2V0QXR0cmlidXRlU3RydWN0dXJlKFxyXG4gICAgICAgICAgYXR0cmlidXRlLFxyXG4gICAgICAgICAgeyBzaXplOiAzLCBkYXRhVHlwZTogV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GTE9BVCwgbm9ybWFsaXplOiBmYWxzZSwgc3RyaWRlOiAwLCBvZmZzZXQ6IDAgfVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCB1UHJvamVjdGlvbjogV2ViR0xVbmlmb3JtTG9jYXRpb24gPSBfc2hhZGVyLnVuaWZvcm1zW1widV9tdHhNZXNoVG9WaWV3XCJdO1xyXG4gICAgICBjcmMzLnVuaWZvcm1NYXRyaXg0ZnYodVByb2plY3Rpb24sIGZhbHNlLCBfbXR4TWVzaFRvVmlldy5nZXQoKSk7XHJcblxyXG4gICAgICBsZXQgdVdvcmxkOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiA9IF9zaGFkZXIudW5pZm9ybXNbXCJ1X210eE1lc2hUb1dvcmxkXCJdO1xyXG4gICAgICBpZiAodVdvcmxkKSB7XHJcbiAgICAgICAgLy8gbGV0IG10eFdvcmxkOiBNYXRyaXg0eDQgPSBfbXR4TWVzaFRvV29ybGQuY2xvbmU7XHJcbiAgICAgICAgLy8gbXR4V29ybGQudHJhbnNsYXRpb24gPSBWZWN0b3IzLlpFUk8oKTtcclxuICAgICAgICBjcmMzLnVuaWZvcm1NYXRyaXg0ZnYodVdvcmxkLCBmYWxzZSwgX210eE1lc2hUb1dvcmxkLmdldCgpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IHVOb3JtYWw6IFdlYkdMVW5pZm9ybUxvY2F0aW9uID0gX3NoYWRlci51bmlmb3Jtc1tcInVfbXR4Tm9ybWFsTWVzaFRvV29ybGRcIl07XHJcbiAgICAgIGlmICh1Tm9ybWFsKSB7XHJcbiAgICAgICAgbGV0IG5vcm1hbE1hdHJpeDogTWF0cml4NHg0ID0gTWF0cml4NHg0LlRSQU5TUE9TRShNYXRyaXg0eDQuSU5WRVJTSU9OKF9tdHhNZXNoVG9Xb3JsZCkpO1xyXG4gICAgICAgIGNyYzMudW5pZm9ybU1hdHJpeDRmdih1Tm9ybWFsLCBmYWxzZSwgbm9ybWFsTWF0cml4LmdldCgpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc2V0QnVmZmVyKFwiYV92Y3RQb3NpdGlvblwiLCB0aGlzLnJlbmRlckJ1ZmZlcnMudmVydGljZXMpO1xyXG4gICAgICBzZXRCdWZmZXIoXCJhX3ZjdFBvc2l0aW9uRmxhdFwiLCB0aGlzLnJlbmRlckJ1ZmZlcnMudmVydGljZXNGbGF0KTtcclxuICAgICAgc2V0QnVmZmVyKFwiYV92Y3ROb3JtYWxGYWNlXCIsIHRoaXMucmVuZGVyQnVmZmVycy5ub3JtYWxzRmxhdCk7XHJcbiAgICAgIHNldEJ1ZmZlcihcImFfdmN0Tm9ybWFsVmVydGV4XCIsIHRoaXMucmVuZGVyQnVmZmVycy5ub3JtYWxzVmVydGV4KTtcclxuXHJcblxyXG4gICAgICAvLyBmZWVkIGluIHRleHR1cmUgY29vcmRpbmF0ZXMgaWYgc2hhZGVyIGFjY2VwdHMgYV92Y3RUZXh0dXJlXHJcbiAgICAgIGxldCBhVGV4dHVyZVVWczogbnVtYmVyID0gX3NoYWRlci5hdHRyaWJ1dGVzW1wiYV92Y3RUZXh0dXJlXCJdO1xyXG4gICAgICBpZiAoYVRleHR1cmVVVnMpIHtcclxuICAgICAgICBpZiAoX3NoYWRlciA9PSBTaGFkZXJGbGF0VGV4dHVyZWQpXHJcbiAgICAgICAgICBjcmMzLmJpbmRCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BUlJBWV9CVUZGRVIsIHRoaXMucmVuZGVyQnVmZmVycy50ZXh0dXJlVVZzRmxhdCk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgY3JjMy5iaW5kQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQVJSQVlfQlVGRkVSLCB0aGlzLnJlbmRlckJ1ZmZlcnMudGV4dHVyZVVWcyk7XHJcbiAgICAgICAgY3JjMy5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhVGV4dHVyZVVWcyk7IC8vIGVuYWJsZSB0aGUgYnVmZmVyXHJcbiAgICAgICAgY3JjMy52ZXJ0ZXhBdHRyaWJQb2ludGVyKGFUZXh0dXJlVVZzLCAyLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZMT0FULCBmYWxzZSwgMCwgMCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGZlZWQgaW4gYW4gaWQgb2YgdGhlIG5vZGUgaWYgc2hhZGVyIGFjY2VwdHMgdV9pZC4gVXNlZCBmb3IgcGlja2luZ1xyXG4gICAgICBsZXQgdUlkOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiA9IF9zaGFkZXIudW5pZm9ybXNbXCJ1X2lkXCJdO1xyXG4gICAgICBpZiAodUlkKVxyXG4gICAgICAgIFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKS51bmlmb3JtMWkodUlkLCBfaWQpO1xyXG5cclxuICAgICAgaWYgKF9zaGFkZXIgPT0gU2hhZGVyRmxhdCB8fCBfc2hhZGVyID09IFNoYWRlckZsYXRUZXh0dXJlZCkge1xyXG4gICAgICAgIGNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLnJlbmRlckJ1ZmZlcnMuaW5kaWNlc0ZsYXQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluZGljZXNGbGF0Lmxlbmd0aDtcclxuICAgICAgfVxyXG5cclxuICAgICAgY3JjMy5iaW5kQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMucmVuZGVyQnVmZmVycy5pbmRpY2VzKTtcclxuICAgICAgcmV0dXJuIHRoaXMuaW5kaWNlcy5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBkZWxldGVSZW5kZXJCdWZmZXJzKF9yZW5kZXJCdWZmZXJzOiBSZW5kZXJCdWZmZXJzKTogdm9pZCB7XHJcbiAgICAgIGxldCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG4gICAgICBpZiAoX3JlbmRlckJ1ZmZlcnMpIHtcclxuICAgICAgICAvLyBUT0RPOiBjbGVhbnVwIGFsbCBidWZmZXJzLCBmbGF0L25vcm1hbHMgaXMgbWlzc2luZy4uLlxyXG4gICAgICAgIGNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgbnVsbCk7XHJcbiAgICAgICAgY3JjMy5kZWxldGVCdWZmZXIoX3JlbmRlckJ1ZmZlcnMudmVydGljZXMpO1xyXG4gICAgICAgIGNyYzMuZGVsZXRlQnVmZmVyKF9yZW5kZXJCdWZmZXJzLnRleHR1cmVVVnMpO1xyXG4gICAgICAgIGNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBudWxsKTtcclxuICAgICAgICBjcmMzLmRlbGV0ZUJ1ZmZlcihfcmVuZGVyQnVmZmVycy5pbmRpY2VzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgUmVjeWNhYmxlIHtcclxuICAgIHJlY3ljbGUoKTogdm9pZDtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogS2VlcHMgYSBkZXBvdCBvZiBvYmplY3RzIHRoYXQgaGF2ZSBiZWVuIG1hcmtlZCBmb3IgcmV1c2UsIHNvcnRlZCBieSB0eXBlLiAgXHJcbiAgICogVXNpbmcge0BsaW5rIFJlY3ljbGVyfSByZWR1Y2VzIGxvYWQgb24gdGhlIGNhcmJhZ2UgY29sbGVjdG9yIGFuZCB0aHVzIHN1cHBvcnRzIHNtb290aCBwZXJmb3JtYW5jZVxyXG4gICAqL1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBSZWN5Y2xlciB7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBkZXBvdDogeyBbdHlwZTogc3RyaW5nXTogT2JqZWN0W10gfSA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmV0Y2hlcyBhbiBvYmplY3Qgb2YgdGhlIHJlcXVlc3RlZCB0eXBlIGZyb20gdGhlIGRlcG90LCBjYWxscyBpdHMgcmVjeWNsZS1tZXRob2QgYW5kIHJldHVybnMgaXQuXHJcbiAgICAgKiBJZiB0aGUgZGVwb3QgZm9yIHRoYXQgdHlwZSBpcyBlbXB0eSBpdCByZXR1cm5zIGEgbmV3IG9iamVjdCBvZiB0aGUgcmVxdWVzdGVkIHR5cGVcclxuICAgICAqIEBwYXJhbSBfVCBUaGUgY2xhc3MgaWRlbnRpZmllciBvZiB0aGUgZGVzaXJlZCBvYmplY3RcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXQ8VCBleHRlbmRzIFJlY3ljYWJsZT4oX1Q6IG5ldyAoKSA9PiBUKTogVCB7XHJcbiAgICAgIGxldCBrZXk6IHN0cmluZyA9IF9ULm5hbWU7XHJcbiAgICAgIGxldCBpbnN0YW5jZXM6IE9iamVjdFtdID0gUmVjeWNsZXIuZGVwb3Rba2V5XTtcclxuICAgICAgaWYgKGluc3RhbmNlcyAmJiBpbnN0YW5jZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGxldCBpbnN0YW5jZTogVCA9IDxUPmluc3RhbmNlcy5wb3AoKTtcclxuICAgICAgICBpbnN0YW5jZS5yZWN5Y2xlKCk7XHJcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2VcclxuICAgICAgICByZXR1cm4gbmV3IF9UKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIGFuIG9iamVjdCBvZiB0aGUgcmVxdWVzdGVkIHR5cGUgaW4gdGhlIGRlcG90LCBidXQgZG9lcyBub3QgcmVtb3ZlIGl0IHRoZXJlLiBcclxuICAgICAqIElmIG5vIG9iamVjdCBvZiB0aGUgcmVxdWVzdGVkIHR5cGUgd2FzIGluIHRoZSBkZXBvdCwgb25lIGlzIGNyZWF0ZWQsIHN0b3JlZCBhbmQgYm9ycm93ZWQuXHJcbiAgICAgKiBGb3Igc2hvcnQgdGVybSB1c2FnZSBvZiBvYmplY3RzIGluIGEgbG9jYWwgc2NvcGUsIHdoZW4gdGhlcmUgd2lsbCBiZSBubyBvdGhlciBjYWxsIHRvIFJlY3ljbGVyLmdldCBvciAuYm9ycm93IVxyXG4gICAgICogQHBhcmFtIF9UIFRoZSBjbGFzcyBpZGVudGlmaWVyIG9mIHRoZSBkZXNpcmVkIG9iamVjdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGJvcnJvdzxUIGV4dGVuZHMgUmVjeWNhYmxlPihfVDogbmV3ICgpID0+IFQpOiBUIHtcclxuICAgICAgbGV0IHQ6IFQ7XHJcbiAgICAgIGxldCBrZXk6IHN0cmluZyA9IF9ULm5hbWU7XHJcbiAgICAgIGxldCBpbnN0YW5jZXM6IE9iamVjdFtdID0gUmVjeWNsZXIuZGVwb3Rba2V5XTtcclxuICAgICAgaWYgKCFpbnN0YW5jZXMgfHwgaW5zdGFuY2VzLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgdCA9IG5ldyBfVCgpO1xyXG4gICAgICAgIFJlY3ljbGVyLnN0b3JlKHQpO1xyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgICB9XHJcbiAgICAgIGxldCBpbnN0YW5jZTogVCA9IDxUPmluc3RhbmNlc1swXTtcclxuICAgICAgaW5zdGFuY2UucmVjeWNsZSgpO1xyXG4gICAgICByZXR1cm4gaW5zdGFuY2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9yZXMgdGhlIG9iamVjdCBpbiB0aGUgZGVwb3QgZm9yIGxhdGVyIHJlY3ljbGluZy4gVXNlcnMgYXJlIHJlc3BvbnNpYmxlIGZvciB0aHJvd2luZyBpbiBvYmplY3RzIHRoYXQgYXJlIGFib3V0IHRvIGxvb3NlIHNjb3BlIGFuZCBhcmUgbm90IHJlZmVyZW5jZWQgYnkgYW55IG90aGVyXHJcbiAgICAgKiBAcGFyYW0gX2luc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc3RvcmUoX2luc3RhbmNlOiBPYmplY3QpOiB2b2lkIHtcclxuICAgICAgbGV0IGtleTogc3RyaW5nID0gX2luc3RhbmNlLmNvbnN0cnVjdG9yLm5hbWU7XHJcbiAgICAgIC8vRGVidWcubG9nKGtleSk7XHJcbiAgICAgIGxldCBpbnN0YW5jZXM6IE9iamVjdFtdID0gUmVjeWNsZXIuZGVwb3Rba2V5XSB8fCBbXTtcclxuICAgICAgaW5zdGFuY2VzLnB1c2goX2luc3RhbmNlKTtcclxuICAgICAgUmVjeWNsZXIuZGVwb3Rba2V5XSA9IGluc3RhbmNlcztcclxuICAgICAgLy8gRGVidWcubG9nKGBPYmplY3RNYW5hZ2VyLmRlcG90WyR7a2V5fV06ICR7T2JqZWN0TWFuYWdlci5kZXBvdFtrZXldLmxlbmd0aH1gKTtcclxuICAgICAgLy9EZWJ1Zy5sb2codGhpcy5kZXBvdCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbXB0eXMgdGhlIGRlcG90IG9mIGEgZ2l2ZW4gdHlwZSwgbGVhdmluZyB0aGUgb2JqZWN0cyBmb3IgdGhlIGdhcmJhZ2UgY29sbGVjdG9yLiBNYXkgcmVzdWx0IGluIGEgc2hvcnQgc3RhbGwgd2hlbiBtYW55IG9iamVjdHMgd2VyZSBpblxyXG4gICAgICogQHBhcmFtIF9UXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZHVtcDxUPihfVDogbmV3ICgpID0+IFQpOiB2b2lkIHtcclxuICAgICAgbGV0IGtleTogc3RyaW5nID0gX1QubmFtZTtcclxuICAgICAgUmVjeWNsZXIuZGVwb3Rba2V5XSA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRW1wdHlzIGFsbCBkZXBvdHMsIGxlYXZpbmcgYWxsIG9iamVjdHMgdG8gdGhlIGdhcmJhZ2UgY29sbGVjdG9yLiBNYXkgcmVzdWx0IGluIGEgc2hvcnQgc3RhbGwgd2hlbiBtYW55IG9iamVjdHMgd2VyZSBpblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGR1bXBBbGwoKTogdm9pZCB7XHJcbiAgICAgIFJlY3ljbGVyLmRlcG90ID0ge307XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogU3RvcmVzIGFuZCBtYW5pcHVsYXRlcyBhIHR3b2RpbWVuc2lvbmFsIHZlY3RvciBjb21wcmlzZWQgb2YgdGhlIGNvbXBvbmVudHMgeCBhbmQgeVxyXG4gICAqIGBgYHBsYWludGV4dFxyXG4gICAqICAgICAgICAgICAgK3lcclxuICAgKiAgICAgICAgICAgICB8X18gK3hcclxuICAgKiBgYGBcclxuICAgKiBAYXV0aG9ycyBMdWthcyBTY2hldWVybGUsIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFZlY3RvcjIgZXh0ZW5kcyBNdXRhYmxlIGltcGxlbWVudHMgUmVjeWNhYmxlIHtcclxuICAgIHByaXZhdGUgZGF0YTogRmxvYXQzMkFycmF5O1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfeDogbnVtYmVyID0gMCwgX3k6IG51bWJlciA9IDApIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShbX3gsIF95XSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFN0YXRpY1xyXG4gICAgLyoqIFxyXG4gICAgICogQSBzaG9ydGhhbmQgZm9yIHdyaXRpbmcgYG5ldyBWZWN0b3IyKDAsIDApYC5cclxuICAgICAqIEByZXR1cm5zIEEgbmV3IHZlY3RvciB3aXRoIHRoZSB2YWx1ZXMgKDAsIDApXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgWkVSTygpOiBWZWN0b3IyIHtcclxuICAgICAgY29uc3QgdmVjdG9yOiBWZWN0b3IyID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjIpO1xyXG4gICAgICB2ZWN0b3Iuc2V0KDAsIDApO1xyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEEgc2hvcnRoYW5kIGZvciB3cml0aW5nIGBuZXcgVmVjdG9yMihfc2NhbGUsIF9zY2FsZSlgLlxyXG4gICAgICogQHBhcmFtIF9zY2FsZSB0aGUgc2NhbGUgb2YgdGhlIHZlY3Rvci4gRGVmYXVsdDogMVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIE9ORShfc2NhbGU6IG51bWJlciA9IDEpOiBWZWN0b3IyIHtcclxuICAgICAgY29uc3QgdmVjdG9yOiBWZWN0b3IyID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjIpO1xyXG4gICAgICB2ZWN0b3Iuc2V0KF9zY2FsZSwgX3NjYWxlKTtcclxuICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBBIHNob3J0aGFuZCBmb3Igd3JpdGluZyBgbmV3IFZlY3RvcjIoMCwgeSlgLlxyXG4gICAgICogQHBhcmFtIF9zY2FsZSBUaGUgbnVtYmVyIHRvIHdyaXRlIGluIHRoZSB5IGNvb3JkaW5hdGUuIERlZmF1bHQ6IDFcclxuICAgICAqIEByZXR1cm5zIEEgbmV3IHZlY3RvciB3aXRoIHRoZSB2YWx1ZXMgKDAsIF9zY2FsZSlcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBZKF9zY2FsZTogbnVtYmVyID0gMSk6IFZlY3RvcjIge1xyXG4gICAgICBjb25zdCB2ZWN0b3I6IFZlY3RvcjIgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMik7XHJcbiAgICAgIHZlY3Rvci5zZXQoMCwgX3NjYWxlKTtcclxuICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBBIHNob3J0aGFuZCBmb3Igd3JpdGluZyBgbmV3IFZlY3RvcjIoeCwgMClgLlxyXG4gICAgICogQHBhcmFtIF9zY2FsZSBUaGUgbnVtYmVyIHRvIHdyaXRlIGluIHRoZSB4IGNvb3JkaW5hdGUuIERlZmF1bHQ6IDFcclxuICAgICAqIEByZXR1cm5zIEEgbmV3IHZlY3RvciB3aXRoIHRoZSB2YWx1ZXMgKF9zY2FsZSwgMClcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBYKF9zY2FsZTogbnVtYmVyID0gMSk6IFZlY3RvcjIge1xyXG4gICAgICBjb25zdCB2ZWN0b3I6IFZlY3RvcjIgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMik7XHJcbiAgICAgIHZlY3Rvci5zZXQoX3NjYWxlLCAwKTtcclxuICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIFRSQU5TRk9STUFUSU9OKF92ZWN0b3I6IFZlY3RvcjIsIF9tdHhUcmFuc2Zvcm06IE1hdHJpeDN4MywgX2luY2x1ZGVUcmFuc2xhdGlvbjogYm9vbGVhbiA9IHRydWUpOiBWZWN0b3IyIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMiA9IFJlY3ljbGVyLmdldChWZWN0b3IyKTtcclxuICAgICAgbGV0IG06IEZsb2F0MzJBcnJheSA9IF9tdHhUcmFuc2Zvcm0uZ2V0KCk7XHJcbiAgICAgIGxldCBbeCwgeV0gPSBfdmVjdG9yLmdldCgpO1xyXG4gICAgICByZXN1bHQueCA9IG1bMF0gKiB4ICsgbVszXSAqIHk7XHJcbiAgICAgIHJlc3VsdC55ID0gbVsxXSAqIHggKyBtWzRdICogeTtcclxuXHJcbiAgICAgIGlmIChfaW5jbHVkZVRyYW5zbGF0aW9uKSB7XHJcbiAgICAgICAgcmVzdWx0LmFkZChfbXR4VHJhbnNmb3JtLnRyYW5zbGF0aW9uKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE5vcm1hbGl6ZXMgYSBnaXZlbiB2ZWN0b3IgdG8gdGhlIGdpdmVuIGxlbmd0aCB3aXRob3V0IGVkaXRpbmcgdGhlIG9yaWdpbmFsIHZlY3Rvci5cclxuICAgICAqIEBwYXJhbSBfdmVjdG9yIHRoZSB2ZWN0b3IgdG8gbm9ybWFsaXplXHJcbiAgICAgKiBAcGFyYW0gX2xlbmd0aCB0aGUgbGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBkZWZhdWx0cyB0byAxXHJcbiAgICAgKiBAcmV0dXJucyBhIG5ldyB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBub3JtYWxpc2VkIHZlY3RvciBzY2FsZWQgYnkgdGhlIGdpdmVuIGxlbmd0aFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIE5PUk1BTElaQVRJT04oX3ZlY3RvcjogVmVjdG9yMiwgX2xlbmd0aDogbnVtYmVyID0gMSk6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgdmVjdG9yOiBWZWN0b3IyID0gVmVjdG9yMi5aRVJPKCk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgbGV0IFt4LCB5XSA9IF92ZWN0b3IuZGF0YTtcclxuICAgICAgICBsZXQgZmFjdG9yOiBudW1iZXIgPSBfbGVuZ3RoIC8gTWF0aC5oeXBvdCh4LCB5KTtcclxuICAgICAgICB2ZWN0b3Iuc2V0KF92ZWN0b3IueCAqIGZhY3RvciwgX3ZlY3Rvci55ICogZmFjdG9yKTtcclxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XHJcbiAgICAgICAgRGVidWcud2FybihfZXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB2ZWN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGdpdmVuIHZlY3RvciBzY2FsZWQgYnkgdGhlIGdpdmVuIHNjYWxpbmcgZmFjdG9yXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgU0NBTEUoX3ZlY3RvcjogVmVjdG9yMiwgX3NjYWxlOiBudW1iZXIpOiBWZWN0b3IyIHtcclxuICAgICAgbGV0IHZlY3RvcjogVmVjdG9yMiA9IFJlY3ljbGVyLmdldChWZWN0b3IyKTtcclxuICAgICAgdmVjdG9yLnNldChfdmVjdG9yLnggKiBfc2NhbGUsIF92ZWN0b3IueSAqIF9zY2FsZSk7XHJcbiAgICAgIHJldHVybiB2ZWN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSByZXN1bHRpbmcgdmVjdG9yIGF0dGFpbmVkIGJ5IGFkZGl0aW9uIG9mIGFsbCBnaXZlbiB2ZWN0b3JzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFNVTSguLi5fdmVjdG9yczogVmVjdG9yMltdKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjIgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMik7XHJcbiAgICAgIGZvciAobGV0IHZlY3RvciBvZiBfdmVjdG9ycylcclxuICAgICAgICByZXN1bHQuc2V0KHJlc3VsdC54ICsgdmVjdG9yLngsIHJlc3VsdC55ICsgdmVjdG9yLnkpO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSBzdWJ0cmFjdGlvbiBvZiB0d28gdmVjdG9ycy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBESUZGRVJFTkNFKF9taW51ZW5kOiBWZWN0b3IyLCBfc3VidHJhaGVuZDogVmVjdG9yMik6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgdmVjdG9yOiBWZWN0b3IyID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjIpO1xyXG4gICAgICB2ZWN0b3Iuc2V0KF9taW51ZW5kLnggLSBfc3VidHJhaGVuZC54LCBfbWludWVuZC55IC0gX3N1YnRyYWhlbmQueSk7XHJcbiAgICAgIHJldHVybiB2ZWN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyB0aGUgZG90cHJvZHVjdCBvZiAyIHZlY3RvcnMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgRE9UKF9hOiBWZWN0b3IyLCBfYjogVmVjdG9yMik6IG51bWJlciB7XHJcbiAgICAgIGxldCBzY2FsYXJQcm9kdWN0OiBudW1iZXIgPSBfYS54ICogX2IueCArIF9hLnkgKiBfYi55O1xyXG4gICAgICByZXR1cm4gc2NhbGFyUHJvZHVjdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIFZlY3RvcnMuIER1ZSB0byB0aGVtIGJlaW5nIG9ubHkgMiBEaW1lbnNpb25hbCwgdGhlIHJlc3VsdCBpcyBhIHNpbmdsZSBudW1iZXIsXHJcbiAgICAgKiB3aGljaCBpbXBsaWNpdGx5IGlzIG9uIHRoZSBaIGF4aXMuIEl0IGlzIGFsc28gdGhlIHNpZ25lZCBtYWduaXR1ZGUgb2YgdGhlIHJlc3VsdC5cclxuICAgICAqIEBwYXJhbSBfYSBWZWN0b3IgdG8gY29tcHV0ZSB0aGUgY3Jvc3MgcHJvZHVjdCBvblxyXG4gICAgICogQHBhcmFtIF9iIFZlY3RvciB0byBjb21wdXRlIHRoZSBjcm9zcyBwcm9kdWN0IHdpdGhcclxuICAgICAqIEByZXR1cm5zIEEgbnVtYmVyIHJlcHJlc2VudGluZyByZXN1bHQgb2YgdGhlIGNyb3NzIHByb2R1Y3QuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgQ1JPU1MoX2E6IFZlY3RvcjIsIF9iOiBWZWN0b3IyKTogbnVtYmVyIHtcclxuICAgICAgbGV0IGNyb3NzUHJvZHVjdDogbnVtYmVyID0gX2EueCAqIF9iLnkgLSBfYS55ICogX2IueDtcclxuICAgICAgcmV0dXJuIGNyb3NzUHJvZHVjdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIG9ydGhvZ29uYWwgdmVjdG9yIHRvIHRoZSBnaXZlbiB2ZWN0b3IuIFJvdGF0ZXMgY291bnRlcmNsb2Nrd2lzZSBieSBkZWZhdWx0LlxyXG4gICAgICogYGBgcGxhaW50ZXh0XHJcbiAgICAgKiDihpEgPT4g4oaQID0+IOKGkyA9PiDihpIgPT4g4oaRXHJcbiAgICAgKiBgYGBcclxuICAgICAqIEBwYXJhbSBfdmVjdG9yIFZlY3RvciB0byBnZXQgdGhlIG9ydGhvZ29uYWwgZXF1aXZhbGVudCBvZlxyXG4gICAgICogQHBhcmFtIF9jbG9ja3dpc2UgU2hvdWxkIHRoZSByb3RhdGlvbiBiZSBjbG9ja3dpc2UgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBjb3VudGVyY2xvY2t3aXNlPyBkZWZhdWx0OiBmYWxzZVxyXG4gICAgICogQHJldHVybnMgQSBWZWN0b3IgdGhhdCBpcyBvcnRob2dvbmFsIHRvIGFuZCBoYXMgdGhlIHNhbWUgbWFnbml0dWRlIGFzIHRoZSBnaXZlbiBWZWN0b3IuICBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBPUlRIT0dPTkFMKF92ZWN0b3I6IFZlY3RvcjIsIF9jbG9ja3dpc2U6IGJvb2xlYW4gPSBmYWxzZSk6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IyID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjIpO1xyXG4gICAgICBpZiAoX2Nsb2Nrd2lzZSlcclxuICAgICAgICByZXN1bHQuc2V0KF92ZWN0b3IueSwgLV92ZWN0b3IueCk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICByZXN1bHQuc2V0KC1fdmVjdG9yLnksIF92ZWN0b3IueCk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgY2FydGVzaWFuIHZlY3RvciBmcm9tIHBvbGFyIGNvb3JkaW5hdGVzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgR0VPKF9hbmdsZTogbnVtYmVyID0gMCwgX21hZ25pdHVkZTogbnVtYmVyID0gMSk6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgdmVjdG9yOiBWZWN0b3IyID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjIpO1xyXG4gICAgICBsZXQgZ2VvOiBHZW8yID0gUmVjeWNsZXIuZ2V0KEdlbzIpO1xyXG4gICAgICBnZW8uc2V0KF9hbmdsZSwgX21hZ25pdHVkZSk7XHJcbiAgICAgIHZlY3Rvci5nZW8gPSBnZW87XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKGdlbyk7XHJcbiAgICAgIHJldHVybiB2ZWN0b3I7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gQWNjZXNzb3JzXHJcbiAgICBnZXQgeCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5kYXRhWzBdO1xyXG4gICAgfVxyXG4gICAgZ2V0IHkoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZGF0YVsxXTtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgeChfeDogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuZGF0YVswXSA9IF94O1xyXG4gICAgfVxyXG4gICAgc2V0IHkoX3k6IG51bWJlcikge1xyXG4gICAgICB0aGlzLmRhdGFbMV0gPSBfeTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIGdldCBtYWduaXR1ZGUoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIE1hdGguaHlwb3QoLi4udGhpcy5kYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHNxdWFyZSBvZiB0aGUgbWFnbml0dWRlIG9mIHRoZSB2ZWN0b3Igd2l0aG91dCBjYWxjdWxhdGluZyBhIHNxdWFyZSByb290LiBGYXN0ZXIgZm9yIHNpbXBsZSBwcm94aW1pdHkgZXZhbHVhdGlvbi5cclxuICAgICAqL1xyXG4gICAgZ2V0IG1hZ25pdHVkZVNxdWFyZWQoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIFZlY3RvcjIuRE9UKHRoaXMsIHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgQSBkZWVwIGNvcHkgb2YgdGhlIHZlY3Rvci5cclxuICAgICAqIFRPRE86IHJlbmFtZSB0aGlzIGNsb25lIGFuZCBjcmVhdGUgYSBuZXcgbWV0aG9kIGNvcHksIHdoaWNoIGNvcGllcyB0aGUgdmFsdWVzIGZyb20gYSB2ZWN0b3IgZ2l2ZW4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgY2xvbmUoKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCBjbG9uZTogVmVjdG9yMiA9IFJlY3ljbGVyLmdldChWZWN0b3IyKTtcclxuICAgICAgY2xvbmUuZGF0YS5zZXQodGhpcy5kYXRhKTtcclxuICAgICAgcmV0dXJuIGNsb25lO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHBvbGFyIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgZ2VvKCk6IEdlbzIge1xyXG4gICAgICBsZXQgZ2VvOiBHZW8yID0gUmVjeWNsZXIuZ2V0KEdlbzIpO1xyXG4gICAgICBnZW8ubWFnbml0dWRlID0gdGhpcy5tYWduaXR1ZGU7XHJcblxyXG4gICAgICBpZiAoZ2VvLm1hZ25pdHVkZSA9PT0gMClcclxuICAgICAgICByZXR1cm4gZ2VvO1xyXG5cclxuICAgICAgZ2VvLmFuZ2xlID0gMTgwICogTWF0aC5hdGFuMih0aGlzLnkgLyBnZW8ubWFnbml0dWRlLCB0aGlzLnggLyBnZW8ubWFnbml0dWRlKSAvIE1hdGguUEk7XHJcbiAgICAgIHJldHVybiBnZW87XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGp1c3QgdGhlIGNhcnRlc2lhbiB2YWx1ZXMgb2YgdGhpcyB2ZWN0b3IgdG8gcmVwcmVzZW50IHRoZSBnaXZlbiBhcyBwb2xhciBjb29yZGluYXRlc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0IGdlbyhfZ2VvOiBHZW8yKSB7XHJcbiAgICAgIHRoaXMuc2V0KF9nZW8ubWFnbml0dWRlLCAwKTtcclxuICAgICAgdGhpcy50cmFuc2Zvcm0oTWF0cml4M3gzLlJPVEFUSU9OKF9nZW8uYW5nbGUpKTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gICAgXHJcbiAgICBwdWJsaWMgcmVjeWNsZSgpOiB2b2lkIHtcclxuICAgICAgdGhpcy5kYXRhLnNldChbMCwgMF0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjb29yZGluYXRlcyBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gdmVjdG9yIGFyZSB0byBiZSBjb25zaWRlcmVkIGlkZW50aWNhbCB3aXRoaW4gdGhlIGdpdmVuIHRvbGVyYW5jZVxyXG4gICAgICogVE9ETzogZXhhbWluZSwgaWYgdG9sZXJhbmNlIGFzIGNyaXRlcml1bSBmb3IgdGhlIGRpZmZlcmVuY2UgaXMgYXBwcm9wcmlhdGUgd2l0aCB2ZXJ5IGxhcmdlIGNvb3JkaW5hdGUgdmFsdWVzIG9yIGlmIF90b2xlcmFuY2Ugc2hvdWxkIGJlIG11bHRpcGxpZWQgYnkgY29vcmRpbmF0ZSB2YWx1ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZXF1YWxzKF9jb21wYXJlOiBWZWN0b3IyLCBfdG9sZXJhbmNlOiBudW1iZXIgPSBOdW1iZXIuRVBTSUxPTik6IGJvb2xlYW4ge1xyXG4gICAgICBpZiAoTWF0aC5hYnModGhpcy54IC0gX2NvbXBhcmUueCkgPiBfdG9sZXJhbmNlKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmIChNYXRoLmFicyh0aGlzLnkgLSBfY29tcGFyZS55KSA+IF90b2xlcmFuY2UpIHJldHVybiBmYWxzZTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHRoZSBnaXZlbiB2ZWN0b3IgdG8gdGhlIGV4ZWN1dGluZyB2ZWN0b3IsIGNoYW5naW5nIHRoZSBleGVjdXRvci5cclxuICAgICAqIEBwYXJhbSBfYWRkZW5kIFRoZSB2ZWN0b3IgdG8gYWRkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWRkKF9hZGRlbmQ6IFZlY3RvcjIpOiB2b2lkIHtcclxuICAgICAgdGhpcy5kYXRhLnNldChbX2FkZGVuZC54ICsgdGhpcy54LCBfYWRkZW5kLnkgKyB0aGlzLnldKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN1YnRyYWN0cyB0aGUgZ2l2ZW4gdmVjdG9yIGZyb20gdGhlIGV4ZWN1dGluZyB2ZWN0b3IsIGNoYW5naW5nIHRoZSBleGVjdXRvci5cclxuICAgICAqIEBwYXJhbSBfc3VidHJhaGVuZCBUaGUgdmVjdG9yIHRvIHN1YnRyYWN0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3VidHJhY3QoX3N1YnRyYWhlbmQ6IFZlY3RvcjIpOiB2b2lkIHtcclxuICAgICAgdGhpcy5kYXRhLnNldChbdGhpcy54IC0gX3N1YnRyYWhlbmQueCwgdGhpcy55IC0gX3N1YnRyYWhlbmQueV0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2NhbGVzIHRoZSBWZWN0b3IgYnkgdGhlIGdpdmVuIF9zY2FsYXIuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzY2FsZShfc2NhbGFyOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy5kYXRhLnNldChbX3NjYWxhciAqIHRoaXMueCwgX3NjYWxhciAqIHRoaXMueV0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTm9ybWFsaXplcyB0aGlzIHRvIHRoZSBnaXZlbiBsZW5ndGgsIDEgYnkgZGVmYXVsdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbm9ybWFsaXplKF9sZW5ndGg6IG51bWJlciA9IDEpOiB2b2lkIHtcclxuICAgICAgdGhpcy5kYXRhID0gVmVjdG9yMi5OT1JNQUxJWkFUSU9OKHRoaXMsIF9sZW5ndGgpLmRhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIHRoZSBjb21wb25lbnRzIG9mIHRoaXMgdmVjdG9yIHdpdGggdGhlIGdpdmVuIG51bWJlcnNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldChfeDogbnVtYmVyID0gMCwgX3k6IG51bWJlciA9IDApOiB2b2lkIHtcclxuICAgICAgdGhpcy5kYXRhWzBdID0gX3g7XHJcbiAgICAgIHRoaXMuZGF0YVsxXSA9IF95O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgdGhlIGRhdGEgb2YgdGhlIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0KCk6IEZsb2F0MzJBcnJheSB7XHJcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KHRoaXMuZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHRyYW5zZm9ybShfbXR4VHJhbnNmb3JtOiBNYXRyaXgzeDMsIF9pbmNsdWRlVHJhbnNsYXRpb246IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuZGF0YSA9IFZlY3RvcjIuVFJBTlNGT1JNQVRJT04odGhpcywgX210eFRyYW5zZm9ybSwgX2luY2x1ZGVUcmFuc2xhdGlvbikuZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZvciBlYWNoIGRpbWVuc2lvbiwgbW92ZXMgdGhlIGNvbXBvbmVudCB0byB0aGUgbWluaW11bSBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBtaW4oX2NvbXBhcmU6IFZlY3RvcjMpOiB2b2lkIHtcclxuICAgICAgdGhpcy54ID0gTWF0aC5taW4odGhpcy54LCBfY29tcGFyZS54KTtcclxuICAgICAgdGhpcy55ID0gTWF0aC5taW4odGhpcy55LCBfY29tcGFyZS55KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRm9yIGVhY2ggZGltZW5zaW9uLCBtb3ZlcyB0aGUgY29tcG9uZW50IHRvIHRoZSBtYXhpbXVtIG9mIHRoaXMgYW5kIHRoZSBnaXZlbiB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgcHVibGljIG1heChfY29tcGFyZTogVmVjdG9yMyk6IHZvaWQge1xyXG4gICAgICB0aGlzLnggPSBNYXRoLm1heCh0aGlzLngsIF9jb21wYXJlLngpO1xyXG4gICAgICB0aGlzLnkgPSBNYXRoLm1heCh0aGlzLnksIF9jb21wYXJlLnkpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSB6LWNvbXBvbmVudCBvZiB0aGUgZ2l2ZW4gbWFnbml0dWRlIChkZWZhdWx0PTApIHRvIHRoZSB2ZWN0b3IgYW5kIHJldHVybnMgYSBuZXcgVmVjdG9yM1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdG9WZWN0b3IzKF96OiBudW1iZXIgPSAwKTogVmVjdG9yMyB7XHJcbiAgICAgIHJldHVybiBuZXcgVmVjdG9yMyh0aGlzLngsIHRoaXMueSwgX3opO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG4gICAgICBsZXQgcmVzdWx0OiBzdHJpbmcgPSBgKCR7dGhpcy54LnRvUHJlY2lzaW9uKDUpfSwgJHt0aGlzLnkudG9QcmVjaXNpb24oNSl9KWA7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHRoaXMuZ2V0TXV0YXRvcigpO1xyXG4gICAgICAvLyBzZXJpYWxpemF0aW9uLnRvSlNPTiA9ICgpID0+IHsgcmV0dXJuIGB7IFwiclwiOiAke3RoaXMucn0sIFwiZ1wiOiAke3RoaXMuZ30sIFwiYlwiOiAke3RoaXMuYn0sIFwiYVwiOiAke3RoaXMuYX19YDsgfTtcclxuICAgICAgc2VyaWFsaXphdGlvbi50b0pTT04gPSAoKSA9PiB7IHJldHVybiBgWyR7dGhpcy54fSwgJHt0aGlzLnl9XWA7IH07XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8VmVjdG9yMj4ge1xyXG4gICAgICBpZiAodHlwZW9mIChfc2VyaWFsaXphdGlvbikgPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIFt0aGlzLngsIHRoaXMueV0gPSBKU09OLnBhcnNlKDxzdHJpbmc+PHVua25vd24+X3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2VcclxuICAgICAgICB0aGlzLm11dGF0ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHtcclxuICAgICAgICB4OiB0aGlzLmRhdGFbMF0sIHk6IHRoaXMuZGF0YVsxXVxyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7LyoqICovIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gIH1cclxufSIsIi8vLzxyZWZlcmVuY2UgcGF0aD1cIi4uL1JlY3ljbGUvUmVjeWNsZXIudHNcIi8+XHJcbi8vLzxyZWZlcmVuY2UgcGF0aD1cIlZlY3RvcjIudHNcIi8+XHJcblxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBEZWZpbmVzIHRoZSBvcmlnaW4gb2YgYSByZWN0YW5nbGVcclxuICAgKi9cclxuICBleHBvcnQgZW51bSBPUklHSU4yRCB7XHJcbiAgICBUT1BMRUZUID0gMHgwMCxcclxuICAgIFRPUENFTlRFUiA9IDB4MDEsXHJcbiAgICBUT1BSSUdIVCA9IDB4MDIsXHJcbiAgICBDRU5URVJMRUZUID0gMHgxMCxcclxuICAgIENFTlRFUiA9IDB4MTEsXHJcbiAgICBDRU5URVJSSUdIVCA9IDB4MTIsXHJcbiAgICBCT1RUT01MRUZUID0gMHgyMCxcclxuICAgIEJPVFRPTUNFTlRFUiA9IDB4MjEsXHJcbiAgICBCT1RUT01SSUdIVCA9IDB4MjJcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlZmluZXMgYSByZWN0YW5nbGUgd2l0aCBwb3NpdGlvbiBhbmQgc2l6ZSBhbmQgYWRkIGNvbWZvcnRhYmxlIG1ldGhvZHMgdG8gaXRcclxuICAgKiBAYXV0aG9yIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFJlY3RhbmdsZSBleHRlbmRzIE11dGFibGUgaW1wbGVtZW50cyBSZWN5Y2FibGUge1xyXG4gICAgcHVibGljIHBvc2l0aW9uOiBWZWN0b3IyID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjIpO1xyXG4gICAgcHVibGljIHNpemU6IFZlY3RvcjIgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMik7XHJcblxyXG4gICAgY29uc3RydWN0b3IoX3g6IG51bWJlciA9IDAsIF95OiBudW1iZXIgPSAwLCBfd2lkdGg6IG51bWJlciA9IDEsIF9oZWlnaHQ6IG51bWJlciA9IDEsIF9vcmlnaW46IE9SSUdJTjJEID0gT1JJR0lOMkQuVE9QTEVGVCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLnNldFBvc2l0aW9uQW5kU2l6ZShfeCwgX3ksIF93aWR0aCwgX2hlaWdodCwgX29yaWdpbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHJlY3RhbmdsZSBjcmVhdGVkIHdpdGggdGhlIGdpdmVuIHBhcmFtZXRlcnNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBHRVQoX3g6IG51bWJlciA9IDAsIF95OiBudW1iZXIgPSAwLCBfd2lkdGg6IG51bWJlciA9IDEsIF9oZWlnaHQ6IG51bWJlciA9IDEsIF9vcmlnaW46IE9SSUdJTjJEID0gT1JJR0lOMkQuVE9QTEVGVCk6IFJlY3RhbmdsZSB7XHJcbiAgICAgIGxldCByZWN0OiBSZWN0YW5nbGUgPSBSZWN5Y2xlci5nZXQoUmVjdGFuZ2xlKTtcclxuICAgICAgcmVjdC5zZXRQb3NpdGlvbkFuZFNpemUoX3gsIF95LCBfd2lkdGgsIF9oZWlnaHQpO1xyXG4gICAgICByZXR1cm4gcmVjdDtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgeCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi54O1xyXG4gICAgfVxyXG4gICAgZ2V0IHkoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24ueTtcclxuICAgIH1cclxuICAgIGdldCB3aWR0aCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5zaXplLng7XHJcbiAgICB9XHJcbiAgICBnZXQgaGVpZ2h0KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNpemUueTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgbGVmdG1vc3QgZXhwYW5zaW9uLCByZXNwZWN0aW5nIGFsc28gbmVnYXRpdmUgdmFsdWVzIG9mIHdpZHRoXHJcbiAgICAgKi9cclxuICAgIGdldCBsZWZ0KCk6IG51bWJlciB7XHJcbiAgICAgIGlmICh0aGlzLnNpemUueCA+IDApXHJcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24ueDtcclxuICAgICAgcmV0dXJuICh0aGlzLnBvc2l0aW9uLnggKyB0aGlzLnNpemUueCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgdG9wbW9zdCBleHBhbnNpb24sIHJlc3BlY3RpbmcgYWxzbyBuZWdhdGl2ZSB2YWx1ZXMgb2YgaGVpZ2h0XHJcbiAgICAgKi9cclxuICAgIGdldCB0b3AoKTogbnVtYmVyIHtcclxuICAgICAgaWYgKHRoaXMuc2l6ZS55ID4gMClcclxuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi55O1xyXG4gICAgICByZXR1cm4gKHRoaXMucG9zaXRpb24ueSArIHRoaXMuc2l6ZS55KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSByaWdodG1vc3QgZXhwYW5zaW9uLCByZXNwZWN0aW5nIGFsc28gbmVnYXRpdmUgdmFsdWVzIG9mIHdpZHRoXHJcbiAgICAgKi9cclxuICAgIGdldCByaWdodCgpOiBudW1iZXIge1xyXG4gICAgICBpZiAodGhpcy5zaXplLnggPiAwKVxyXG4gICAgICAgIHJldHVybiAodGhpcy5wb3NpdGlvbi54ICsgdGhpcy5zaXplLngpO1xyXG4gICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi54O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIGxvd2VzdCBleHBhbnNpb24sIHJlc3BlY3RpbmcgYWxzbyBuZWdhdGl2ZSB2YWx1ZXMgb2YgaGVpZ2h0XHJcbiAgICAgKi9cclxuICAgIGdldCBib3R0b20oKTogbnVtYmVyIHtcclxuICAgICAgaWYgKHRoaXMuc2l6ZS55ID4gMClcclxuICAgICAgICByZXR1cm4gKHRoaXMucG9zaXRpb24ueSArIHRoaXMuc2l6ZS55KTtcclxuICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24ueTtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgeChfeDogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMucG9zaXRpb24ueCA9IF94O1xyXG4gICAgfVxyXG4gICAgc2V0IHkoX3k6IG51bWJlcikge1xyXG4gICAgICB0aGlzLnBvc2l0aW9uLnkgPSBfeTtcclxuICAgIH1cclxuICAgIHNldCB3aWR0aChfd2lkdGg6IG51bWJlcikge1xyXG4gICAgICB0aGlzLnNpemUueCA9IF93aWR0aDtcclxuICAgIH1cclxuICAgIHNldCBoZWlnaHQoX2hlaWdodDogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuc2l6ZS55ID0gX2hlaWdodDtcclxuICAgIH1cclxuICAgIHNldCBsZWZ0KF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuc2l6ZS54ID0gdGhpcy5yaWdodCAtIF92YWx1ZTtcclxuICAgICAgdGhpcy5wb3NpdGlvbi54ID0gX3ZhbHVlO1xyXG4gICAgfVxyXG4gICAgc2V0IHRvcChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLnNpemUueSA9IHRoaXMuYm90dG9tIC0gX3ZhbHVlO1xyXG4gICAgICB0aGlzLnBvc2l0aW9uLnkgPSBfdmFsdWU7XHJcbiAgICB9XHJcbiAgICBzZXQgcmlnaHQoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5zaXplLnggPSB0aGlzLnBvc2l0aW9uLnggKyBfdmFsdWU7XHJcbiAgICB9XHJcbiAgICBzZXQgYm90dG9tKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuc2l6ZS55ID0gdGhpcy5wb3NpdGlvbi55ICsgX3ZhbHVlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBwdWJsaWMgZ2V0IGNsb25lKCk6IFJlY3RhbmdsZSB7XHJcbiAgICAgIHJldHVybiBSZWN0YW5nbGUuR0VUKHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlY3ljbGUoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuc2V0UG9zaXRpb25BbmRTaXplKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGNvcHkoX3JlY3Q6IFJlY3RhbmdsZSk6IHZvaWQge1xyXG4gICAgICB0aGlzLnNldFBvc2l0aW9uQW5kU2l6ZShfcmVjdC54LCBfcmVjdC55LCBfcmVjdC53aWR0aCwgX3JlY3QuaGVpZ2h0KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHBvc2l0aW9uIGFuZCBzaXplIG9mIHRoZSByZWN0YW5nbGUgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBwYXJhbWV0ZXJzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRQb3NpdGlvbkFuZFNpemUoX3g6IG51bWJlciA9IDAsIF95OiBudW1iZXIgPSAwLCBfd2lkdGg6IG51bWJlciA9IDEsIF9oZWlnaHQ6IG51bWJlciA9IDEsIF9vcmlnaW46IE9SSUdJTjJEID0gT1JJR0lOMkQuVE9QTEVGVCk6IHZvaWQge1xyXG4gICAgICB0aGlzLnNpemUuc2V0KF93aWR0aCwgX2hlaWdodCk7XHJcbiAgICAgIHN3aXRjaCAoX29yaWdpbiAmIDB4MDMpIHtcclxuICAgICAgICBjYXNlIDB4MDA6IHRoaXMucG9zaXRpb24ueCA9IF94OyBicmVhaztcclxuICAgICAgICBjYXNlIDB4MDE6IHRoaXMucG9zaXRpb24ueCA9IF94IC0gX3dpZHRoIC8gMjsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAweDAyOiB0aGlzLnBvc2l0aW9uLnggPSBfeCAtIF93aWR0aDsgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgc3dpdGNoIChfb3JpZ2luICYgMHgzMCkge1xyXG4gICAgICAgIGNhc2UgMHgwMDogdGhpcy5wb3NpdGlvbi55ID0gX3k7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMHgxMDogdGhpcy5wb3NpdGlvbi55ID0gX3kgLSBfaGVpZ2h0IC8gMjsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAweDIwOiB0aGlzLnBvc2l0aW9uLnkgPSBfeSAtIF9oZWlnaHQ7IGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHBvaW50VG9SZWN0KF9wb2ludDogVmVjdG9yMiwgX3RhcmdldDogUmVjdGFuZ2xlKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjIgPSBfcG9pbnQuY2xvbmU7XHJcbiAgICAgIHJlc3VsdC5zdWJ0cmFjdCh0aGlzLnBvc2l0aW9uKTtcclxuICAgICAgcmVzdWx0LnggKj0gX3RhcmdldC53aWR0aCAvIHRoaXMud2lkdGg7XHJcbiAgICAgIHJlc3VsdC55ICo9IF90YXJnZXQuaGVpZ2h0IC8gdGhpcy5oZWlnaHQ7XHJcbiAgICAgIHJlc3VsdC5hZGQoX3RhcmdldC5wb3NpdGlvbik7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHBvaW50IGlzIGluc2lkZSBvZiB0aGlzIHJlY3RhbmdsZSBvciBvbiB0aGUgYm9yZGVyXHJcbiAgICAgKiBAcGFyYW0gX3BvaW50XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpc0luc2lkZShfcG9pbnQ6IFZlY3RvcjIpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIChfcG9pbnQueCA+PSB0aGlzLmxlZnQgJiYgX3BvaW50LnggPD0gdGhpcy5yaWdodCAmJiBfcG9pbnQueSA+PSB0aGlzLnRvcCAmJiBfcG9pbnQueSA8PSB0aGlzLmJvdHRvbSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyByZWN0YW5nbGUgY29sbGlkZXMgd2l0aCB0aGUgcmVjdGFuZ2xlIGdpdmVuXHJcbiAgICAgKiBAcGFyYW0gX3JlY3QgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjb2xsaWRlcyhfcmVjdDogUmVjdGFuZ2xlKTogYm9vbGVhbiB7XHJcbiAgICAgIGlmICh0aGlzLmxlZnQgPiBfcmVjdC5yaWdodCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAodGhpcy5yaWdodCA8IF9yZWN0LmxlZnQpIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKHRoaXMudG9wID4gX3JlY3QuYm90dG9tKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmICh0aGlzLmJvdHRvbSA8IF9yZWN0LnRvcCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHJlY3RhbmdsZSBjcmVhdGVkIGJ5IHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhpcyBhbmQgdGhlIGdpdmVuIHJlY3RhbmdsZSBvciBudWxsLCBpZiB0aGV5IGRvbid0IGNvbGxpZGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEludGVyc2VjdGlvbihfcmVjdDogUmVjdGFuZ2xlKTogUmVjdGFuZ2xlIHtcclxuICAgICAgaWYgKCF0aGlzLmNvbGxpZGVzKF9yZWN0KSlcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgIGxldCBpbnRlcnNlY3Rpb246IFJlY3RhbmdsZSA9IG5ldyBSZWN0YW5nbGUoKTtcclxuICAgICAgaW50ZXJzZWN0aW9uLnggPSBNYXRoLm1heCh0aGlzLmxlZnQsIF9yZWN0LmxlZnQpO1xyXG4gICAgICBpbnRlcnNlY3Rpb24ueSA9IE1hdGgubWF4KHRoaXMudG9wLCBfcmVjdC50b3ApO1xyXG4gICAgICBpbnRlcnNlY3Rpb24ud2lkdGggPSBNYXRoLm1pbih0aGlzLnJpZ2h0LCBfcmVjdC5yaWdodCkgLSBpbnRlcnNlY3Rpb24ueDtcclxuICAgICAgaW50ZXJzZWN0aW9uLmhlaWdodCA9IE1hdGgubWluKHRoaXMuYm90dG9tLCBfcmVjdC5ib3R0b20pIC0gaW50ZXJzZWN0aW9uLnk7XHJcblxyXG4gICAgICByZXR1cm4gaW50ZXJzZWN0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gKiBSZXR1cm5zIHRoZSByZWN0YW5nbGUgY3JlYXRlZCBieSB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoaXMgYW5kIHRoZSBnaXZlbiByZWN0YW5nbGUgb3IgbnVsbCwgaWYgdGhleSBkb24ndCBjb2xsaWRlXHJcbiAqL1xyXG4gICAgcHVibGljIGNvdmVycyhfcmVjdDogUmVjdGFuZ2xlKTogYm9vbGVhbiB7XHJcbiAgICAgIGlmICh0aGlzLmxlZnQgPiBfcmVjdC5sZWZ0KSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmICh0aGlzLnJpZ2h0IDwgX3JlY3QucmlnaHQpIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKHRoaXMudG9wID4gX3JlY3QudG9wKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmICh0aGlzLmJvdHRvbSA8IF9yZWN0LmJvdHRvbSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyByZWN0YW5nbGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgIGxldCByZXN1bHQ6IHN0cmluZyA9IGDGki5SZWN0YW5nbGUocG9zaXRpb246JHt0aGlzLnBvc2l0aW9uLnRvU3RyaW5nKCl9LCBzaXplOiR7dGhpcy5zaXplLnRvU3RyaW5nKCl9YDtcclxuICAgICAgcmVzdWx0ICs9IGAsIGxlZnQ6JHt0aGlzLmxlZnQudG9QcmVjaXNpb24oNSl9LCB0b3A6JHt0aGlzLnRvcC50b1ByZWNpc2lvbig1KX0sIHJpZ2h0OiR7dGhpcy5yaWdodC50b1ByZWNpc2lvbig1KX0sIGJvdHRvbToke3RoaXMuYm90dG9tLnRvUHJlY2lzaW9uKDUpfWA7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHsvKiAqLyB9XHJcbiAgfVxyXG59IiwiLy8vPHJlZmVyZW5jZSBwYXRoPVwiUmVuZGVySW5qZWN0b3IudHNcIi8+XHJcbi8vLzxyZWZlcmVuY2UgcGF0aD1cIlJlbmRlckluamVjdG9yU2hhZGVyLnRzXCIvPlxyXG4vLy88cmVmZXJlbmNlIHBhdGg9XCJSZW5kZXJJbmplY3RvckNvYXQudHNcIi8+XHJcbi8vLzxyZWZlcmVuY2UgcGF0aD1cIlJlbmRlckluamVjdG9yTWVzaC50c1wiLz5cclxuLy8vPHJlZmVyZW5jZSBwYXRoPVwiLi4vTWF0aC9SZWN0YW5nbGUudHNcIi8+XHJcblxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgZGVjbGFyZSBsZXQgZnVkZ2VDb25maWc6IEdlbmVyYWw7XHJcblxyXG4gIGV4cG9ydCB0eXBlIFJlbmRlclRleHR1cmUgPSBXZWJHTFRleHR1cmU7XHJcblxyXG4gIGV4cG9ydCBlbnVtIEJMRU5EIHtcclxuICAgIE9QQVFVRSwgVFJBTlNQQVJFTlQsIFBBUlRJQ0xFXHJcbiAgfVxyXG5cclxuICBleHBvcnQgaW50ZXJmYWNlIEJ1ZmZlclNwZWNpZmljYXRpb24ge1xyXG4gICAgc2l6ZTogbnVtYmVyOyAgIC8vIFRoZSBzaXplIG9mIHRoZSBkYXRhc2FtcGxlLlxyXG4gICAgZGF0YVR5cGU6IG51bWJlcjsgLy8gVGhlIGRhdGF0eXBlIG9mIHRoZSBzYW1wbGUgKGUuZy4gZ2wuRkxPQVQsIGdsLkJZVEUsIGV0Yy4pXHJcbiAgICBub3JtYWxpemU6IGJvb2xlYW47IC8vIEZsYWcgdG8gbm9ybWFsaXplIHRoZSBkYXRhLlxyXG4gICAgc3RyaWRlOiBudW1iZXI7IC8vIE51bWJlciBvZiBpbmRpY2VzIHRoYXQgd2lsbCBiZSBza2lwcGVkIGVhY2ggaXRlcmF0aW9uLlxyXG4gICAgb2Zmc2V0OiBudW1iZXI7IC8vIEluZGV4IG9mIHRoZSBlbGVtZW50IHRvIGJlZ2luIHdpdGguXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBCYXNlIGNsYXNzIGZvciBSZW5kZXJNYW5hZ2VyLCBoYW5kbGluZyB0aGUgY29ubmVjdGlvbiB0byB0aGUgcmVuZGVyaW5nIHN5c3RlbSwgaW4gdGhpcyBjYXNlIFdlYkdMLlxyXG4gICAqIE1ldGhvZHMgYW5kIGF0dHJpYnV0ZXMgb2YgdGhpcyBjbGFzcyBzaG91bGQgbm90IGJlIGNhbGxlZCBkaXJlY3RseSwgb25seSB0aHJvdWdoIHtAbGluayBSZW5kZXJ9XHJcbiAgICovXHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFJlbmRlcldlYkdMIGV4dGVuZHMgRXZlbnRUYXJnZXRTdGF0aWMge1xyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyV2ViR0wuaW5pdGlhbGl6ZSgpO1xyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyDGknBpY2tlZDogUGlja1tdO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVjdFJlbmRlcjogUmVjdGFuZ2xlID0gUmVuZGVyV2ViR0wuZ2V0Q2FudmFzUmVjdCgpO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgc2l6ZVBpY2s6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemVzIG9mZnNjcmVlbi1jYW52YXMsIHJlbmRlcmluZ2NvbnRleHQgYW5kIGhhcmR3YXJlIHZpZXdwb3J0LiBDYWxsIG9uY2UgYmVmb3JlIGNyZWF0aW5nIGFueSByZXNvdXJjZXMgbGlrZSBtZXNoZXMgb3Igc2hhZGVyc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGluaXRpYWxpemUoX2FudGlhbGlhcz86IGJvb2xlYW4sIF9hbHBoYT86IGJvb2xlYW4pOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0IHtcclxuICAgICAgZnVkZ2VDb25maWcgPSBmdWRnZUNvbmZpZyB8fCB7fTtcclxuICAgICAgbGV0IGNvbnRleHRBdHRyaWJ1dGVzOiBXZWJHTENvbnRleHRBdHRyaWJ1dGVzID0ge1xyXG4gICAgICAgIGFscGhhOiAoX2FscGhhICE9IHVuZGVmaW5lZCkgPyBfYWxwaGEgOiBmdWRnZUNvbmZpZy5hbHBoYSB8fCBmYWxzZSxcclxuICAgICAgICBhbnRpYWxpYXM6IChfYW50aWFsaWFzICE9IHVuZGVmaW5lZCkgPyBfYW50aWFsaWFzIDogZnVkZ2VDb25maWcuYW50aWFsaWFzIHx8IGZhbHNlLFxyXG4gICAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogZmFsc2VcclxuICAgICAgfTtcclxuICAgICAgRGVidWcuZnVkZ2UoXCJJbml0aWFsaXplIFJlbmRlcldlYkdMXCIsIGNvbnRleHRBdHRyaWJ1dGVzKTtcclxuICAgICAgbGV0IGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xyXG4gICAgICBsZXQgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dDtcclxuICAgICAgY3JjMyA9IFJlbmRlcldlYkdMLmFzc2VydDxXZWJHTDJSZW5kZXJpbmdDb250ZXh0PihcclxuICAgICAgICBjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsMlwiLCBjb250ZXh0QXR0cmlidXRlcyksXHJcbiAgICAgICAgXCJXZWJHTC1jb250ZXh0IGNvdWxkbid0IGJlIGNyZWF0ZWRcIlxyXG4gICAgICApO1xyXG4gICAgICBSZW5kZXJXZWJHTC5jcmMzID0gY3JjMztcclxuICAgICAgLy8gRW5hYmxlIGJhY2tmYWNlLSBhbmQgekJ1ZmZlci1jdWxsaW5nLlxyXG4gICAgICBjcmMzLmVuYWJsZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkNVTExfRkFDRSk7XHJcbiAgICAgIGNyYzMuZW5hYmxlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuREVQVEhfVEVTVCk7XHJcbiAgICAgIGNyYzMuZW5hYmxlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQkxFTkQpO1xyXG4gICAgICBjcmMzLmJsZW5kRXF1YXRpb24oV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GVU5DX0FERCk7XHJcbiAgICAgIFJlbmRlcldlYkdMLnNldEJsZW5kTW9kZShCTEVORC5UUkFOU1BBUkVOVCk7XHJcbiAgICAgIC8vIFJlbmRlck9wZXJhdG9yLmNyYzMucGl4ZWxTdG9yZWkoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0cnVlKTtcclxuICAgICAgUmVuZGVyV2ViR0wucmVjdFJlbmRlciA9IFJlbmRlcldlYkdMLmdldENhbnZhc1JlY3QoKTtcclxuICAgICAgcmV0dXJuIGNyYzM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogV3JhcHBlciBmdW5jdGlvbiB0byB1dGlsaXplIHRoZSBidWZmZXJTcGVjaWZpY2F0aW9uIGludGVyZmFjZSB3aGVuIHBhc3NpbmcgZGF0YSB0byB0aGUgc2hhZGVyIHZpYSBhIGJ1ZmZlci5cclxuICAgICAqIEBwYXJhbSBfYXR0cmlidXRlTG9jYXRpb24gIFRoZSBsb2NhdGlvbiBvZiB0aGUgYXR0cmlidXRlIG9uIHRoZSBzaGFkZXIsIHRvIHdoaWNoIHRoZXkgZGF0YSB3aWxsIGJlIHBhc3NlZC5cclxuICAgICAqIEBwYXJhbSBfYnVmZmVyU3BlY2lmaWNhdGlvbiAgSW50ZXJmYWNlIHBhc3NpbmcgZGF0YXB1bGxzcGVjaWZpY2F0aW9ucyB0byB0aGUgYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHNldEF0dHJpYnV0ZVN0cnVjdHVyZShfYXR0cmlidXRlTG9jYXRpb246IG51bWJlciwgX2J1ZmZlclNwZWNpZmljYXRpb246IEJ1ZmZlclNwZWNpZmljYXRpb24pOiB2b2lkIHtcclxuICAgICAgUmVuZGVyV2ViR0wuY3JjMy52ZXJ0ZXhBdHRyaWJQb2ludGVyKF9hdHRyaWJ1dGVMb2NhdGlvbiwgX2J1ZmZlclNwZWNpZmljYXRpb24uc2l6ZSwgX2J1ZmZlclNwZWNpZmljYXRpb24uZGF0YVR5cGUsIF9idWZmZXJTcGVjaWZpY2F0aW9uLm5vcm1hbGl6ZSwgX2J1ZmZlclNwZWNpZmljYXRpb24uc3RyaWRlLCBfYnVmZmVyU3BlY2lmaWNhdGlvbi5vZmZzZXQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBDaGVja3MgdGhlIGZpcnN0IHBhcmFtZXRlciBhbmQgdGhyb3dzIGFuIGV4Y2VwdGlvbiB3aXRoIHRoZSBXZWJHTC1lcnJvcmNvZGUgaWYgdGhlIHZhbHVlIGlzIG51bGxcclxuICAgICogQHBhcmFtIF92YWx1ZSAgdmFsdWUgdG8gY2hlY2sgYWdhaW5zdCBudWxsXHJcbiAgICAqIEBwYXJhbSBfbWVzc2FnZSAgb3B0aW9uYWwsIGFkZGl0aW9uYWwgbWVzc2FnZSBmb3IgdGhlIGV4Y2VwdGlvblxyXG4gICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgYXNzZXJ0PFQ+KF92YWx1ZTogVCB8IG51bGwsIF9tZXNzYWdlOiBzdHJpbmcgPSBcIlwiKTogVCB7XHJcbiAgICAgIGlmIChfdmFsdWUgPT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBc3NlcnRpb24gZmFpbGVkLiAke19tZXNzYWdlfSwgV2ViR0wtRXJyb3I6ICR7UmVuZGVyV2ViR0wuY3JjMyA/IFJlbmRlcldlYkdMLmNyYzMuZ2V0RXJyb3IoKSA6IFwiXCJ9YCk7XHJcbiAgICAgIHJldHVybiBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYSByZWZlcmVuY2UgdG8gdGhlIG9mZnNjcmVlbi1jYW52YXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXRDYW52YXMoKTogSFRNTENhbnZhc0VsZW1lbnQge1xyXG4gICAgICByZXR1cm4gPEhUTUxDYW52YXNFbGVtZW50PlJlbmRlcldlYkdMLmNyYzMuY2FudmFzOyAvLyBUT0RPOiBlbmFibGUgT2Zmc2NyZWVuQ2FudmFzXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYSByZWZlcmVuY2UgdG8gdGhlIHJlbmRlcmluZyBjb250ZXh0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0UmVuZGVyaW5nQ29udGV4dCgpOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0IHtcclxuICAgICAgcmV0dXJuIFJlbmRlcldlYkdMLmNyYzM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYSByZWN0YW5nbGUgZGVzY3JpYmluZyB0aGUgc2l6ZSBvZiB0aGUgb2Zmc2NyZWVuLWNhbnZhcy4geCx5IGFyZSAwIGF0IGFsbCB0aW1lcy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXRDYW52YXNSZWN0KCk6IFJlY3RhbmdsZSB7XHJcbiAgICAgIGxldCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50ID0gPEhUTUxDYW52YXNFbGVtZW50PlJlbmRlcldlYkdMLmNyYzMuY2FudmFzO1xyXG4gICAgICByZXR1cm4gUmVjdGFuZ2xlLkdFVCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBzaXplIG9mIHRoZSBvZmZzY3JlZW4tY2FudmFzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHNldENhbnZhc1NpemUoX3dpZHRoOiBudW1iZXIsIF9oZWlnaHQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICBSZW5kZXJXZWJHTC5jcmMzLmNhbnZhcy53aWR0aCA9IF93aWR0aDtcclxuICAgICAgUmVuZGVyV2ViR0wuY3JjMy5jYW52YXMuaGVpZ2h0ID0gX2hlaWdodDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgYXJlYSBvbiB0aGUgb2Zmc2NyZWVuLWNhbnZhcyB0byByZW5kZXIgdGhlIGNhbWVyYSBpbWFnZSB0by5cclxuICAgICAqIEBwYXJhbSBfcmVjdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHNldFJlbmRlclJlY3RhbmdsZShfcmVjdDogUmVjdGFuZ2xlKTogdm9pZCB7XHJcbiAgICAgIFJlbmRlcldlYkdMLnJlY3RSZW5kZXIuc2V0UG9zaXRpb25BbmRTaXplKF9yZWN0LngsIF9yZWN0LnksIF9yZWN0LndpZHRoLCBfcmVjdC5oZWlnaHQpO1xyXG4gICAgICBSZW5kZXJXZWJHTC5jcmMzLnZpZXdwb3J0KF9yZWN0LngsIF9yZWN0LnksIF9yZWN0LndpZHRoLCBfcmVjdC5oZWlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXIgdGhlIG9mZnNjcmVlbiByZW5kZXJidWZmZXIgd2l0aCB0aGUgZ2l2ZW4ge0BsaW5rIENvbG9yfVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGNsZWFyKF9jb2xvcjogQ29sb3IgPSBudWxsKTogdm9pZCB7XHJcbiAgICAgIFJlbmRlcldlYkdMLmNyYzMuY2xlYXJDb2xvcihfY29sb3IuciwgX2NvbG9yLmcsIF9jb2xvci5iLCBfY29sb3IuYSk7XHJcbiAgICAgIFJlbmRlcldlYkdMLmNyYzMuY2xlYXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5DT0xPUl9CVUZGRVJfQklUIHwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ERVBUSF9CVUZGRVJfQklUKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0IHRoZSBvZmZzY3JlZW4gZnJhbWVidWZmZXIgdG8gdGhlIG9yaWdpbmFsIFJlbmRlcmluZ0NvbnRleHRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZXNldEZyYW1lQnVmZmVyKF9jb2xvcjogQ29sb3IgPSBudWxsKTogdm9pZCB7XHJcbiAgICAgIFJlbmRlcldlYkdMLmNyYzMuYmluZEZyYW1lYnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRlJBTUVCVUZGRVIsIG51bGwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmUgdGhlIGFyZWEgb24gdGhlIG9mZnNjcmVlbi1jYW52YXMgdGhlIGNhbWVyYSBpbWFnZSBnZXRzIHJlbmRlcmVkIHRvLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldFJlbmRlclJlY3RhbmdsZSgpOiBSZWN0YW5nbGUge1xyXG4gICAgICByZXR1cm4gUmVuZGVyV2ViR0wucmVjdFJlbmRlcjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIHNldERlcHRoVGVzdChfdGVzdDogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICBpZiAoX3Rlc3QpXHJcbiAgICAgICAgUmVuZGVyV2ViR0wuY3JjMy5lbmFibGUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ERVBUSF9URVNUKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIFJlbmRlcldlYkdMLmNyYzMuZGlzYWJsZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkRFUFRIX1RFU1QpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgc2V0QmxlbmRNb2RlKF9tb2RlOiBCTEVORCk6IHZvaWQge1xyXG4gICAgICBzd2l0Y2ggKF9tb2RlKSB7XHJcbiAgICAgICAgY2FzZSBCTEVORC5PUEFRVUU6XHJcbiAgICAgICAgICBSZW5kZXJXZWJHTC5jcmMzLmJsZW5kRnVuYyhXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk9ORSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5aRVJPKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQkxFTkQuVFJBTlNQQVJFTlQ6XHJcbiAgICAgICAgICBSZW5kZXJXZWJHTC5jcmMzLmJsZW5kRnVuYyhXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlNSQ19BTFBIQSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcclxuICAgICAgICAgIC8vIFJlbmRlcldlYkdMLmNyYzMuYmxlbmRGdW5jKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRFNUX0FMUEhBLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk9ORV9NSU5VU19EU1RfQUxQSEEpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBCTEVORC5QQVJUSUNMRTpcclxuICAgICAgICAgIFJlbmRlcldlYkdMLmNyYzMuYmxlbmRGdW5jKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuU1JDX0FMUEhBLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkRTVF9BTFBIQSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gUGlja2luZ1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgdGV4dHVyZSBidWZmZXIgdG8gYmUgdXNlZCBhcyBwaWNrLWJ1ZmZlclxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGNyZWF0ZVBpY2tUZXh0dXJlKF9zaXplOiBudW1iZXIpOiBSZW5kZXJUZXh0dXJlIHtcclxuICAgICAgLy8gY3JlYXRlIHRvIHJlbmRlciB0b1xyXG4gICAgICBjb25zdCB0YXJnZXRUZXh0dXJlOiBSZW5kZXJUZXh0dXJlID0gUmVuZGVyLmNyYzMuY3JlYXRlVGV4dHVyZSgpO1xyXG4gICAgICBSZW5kZXIuY3JjMy5iaW5kVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIHRhcmdldFRleHR1cmUpO1xyXG5cclxuICAgICAge1xyXG4gICAgICAgIGNvbnN0IGludGVybmFsRm9ybWF0OiBudW1iZXIgPSBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlJHQkEzMkk7XHJcbiAgICAgICAgY29uc3QgZm9ybWF0OiBudW1iZXIgPSBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlJHQkFfSU5URUdFUjtcclxuICAgICAgICBjb25zdCB0eXBlOiBudW1iZXIgPSBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LklOVDtcclxuICAgICAgICBSZW5kZXIucGlja0J1ZmZlciA9IG5ldyBJbnQzMkFycmF5KF9zaXplICogX3NpemUgKiA0KTtcclxuICAgICAgICBSZW5kZXIuY3JjMy50ZXhJbWFnZTJEKFxyXG4gICAgICAgICAgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCAwLCBpbnRlcm5hbEZvcm1hdCwgX3NpemUsIF9zaXplLCAwLCBmb3JtYXQsIHR5cGUsIFJlbmRlci5waWNrQnVmZmVyXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gc2V0IHRoZSBmaWx0ZXJpbmcgc28gd2UgZG9uJ3QgbmVlZCBtaXBzXHJcbiAgICAgICAgUmVuZGVyLmNyYzMudGV4UGFyYW1ldGVyaShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV9NSU5fRklMVEVSLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkxJTkVBUik7XHJcbiAgICAgICAgUmVuZGVyLmNyYzMudGV4UGFyYW1ldGVyaShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV9XUkFQX1MsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgICAgUmVuZGVyLmNyYzMudGV4UGFyYW1ldGVyaShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV9XUkFQX1QsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGZyYW1lYnVmZmVyOiBXZWJHTEZyYW1lYnVmZmVyID0gUmVuZGVyLmNyYzMuY3JlYXRlRnJhbWVidWZmZXIoKTtcclxuICAgICAgUmVuZGVyLmNyYzMuYmluZEZyYW1lYnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyKTtcclxuICAgICAgY29uc3QgYXR0YWNobWVudFBvaW50OiBudW1iZXIgPSBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkNPTE9SX0FUVEFDSE1FTlQwO1xyXG4gICAgICBSZW5kZXIuY3JjMy5mcmFtZWJ1ZmZlclRleHR1cmUyRChXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZSQU1FQlVGRkVSLCBhdHRhY2htZW50UG9pbnQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgdGFyZ2V0VGV4dHVyZSwgMCk7XHJcblxyXG4gICAgICBSZW5kZXJXZWJHTC5zaXplUGljayA9IF9zaXplO1xyXG4gICAgICByZXR1cm4gdGFyZ2V0VGV4dHVyZTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGdldFBpY2tzKF9zaXplOiBudW1iZXIsIF9jbXBDYW1lcmE6IENvbXBvbmVudENhbWVyYSk6IFBpY2tbXSB7XHJcbiAgICAgIC8vIGV2YWx1YXRlIHRleHR1cmUgYnkgcmVhZGluZyBwaXhlbHMgYW5kIGV4dHJhY3QsIGNvbnZlcnQgYW5kIHN0b3JlIHRoZSBpbmZvcm1hdGlvbiBhYm91dCBlYWNoIG1lc2ggaGl0XHJcbiAgICAgIGxldCBkYXRhOiBJbnQzMkFycmF5ID0gbmV3IEludDMyQXJyYXkoX3NpemUgKiBfc2l6ZSAqIDQpO1xyXG4gICAgICBSZW5kZXIuY3JjMy5yZWFkUGl4ZWxzKDAsIDAsIF9zaXplLCBfc2l6ZSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5SR0JBX0lOVEVHRVIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuSU5ULCBkYXRhKTtcclxuXHJcbiAgICAgIGxldCBtdHhWaWV3VG9Xb3JsZDogTWF0cml4NHg0ID0gTWF0cml4NHg0LklOVkVSU0lPTihfY21wQ2FtZXJhLm10eFdvcmxkVG9WaWV3KTtcclxuICAgICAgbGV0IHBpY2tlZDogUGlja1tdID0gW107XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBSZW5kZXIuxpJwaWNrZWQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgekJ1ZmZlcjogbnVtYmVyID0gZGF0YVs0ICogaSArIDBdICsgZGF0YVs0ICogaSArIDFdIC8gMjU2O1xyXG4gICAgICAgIGlmICh6QnVmZmVyID09IDApIC8vIGRpc2NhcmQgbWlzc2VzIFxyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgbGV0IHBpY2s6IFBpY2sgPSBSZW5kZXIuxpJwaWNrZWRbaV07XHJcbiAgICAgICAgcGljay56QnVmZmVyID0gY29udmVydEludDMydG9GbG9hdDMyKGRhdGEsIDQgKiBpICsgMCkgKiAyIC0gMTtcclxuICAgICAgICBwaWNrLmNvbG9yID0gY29udmVydEludDMydG9Db2xvcihkYXRhLCA0ICogaSArIDEpO1xyXG4gICAgICAgIHBpY2sudGV4dHVyZVVWID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjIpO1xyXG4gICAgICAgIHBpY2sudGV4dHVyZVVWLnNldChjb252ZXJ0SW50MzJ0b0Zsb2F0MzIoZGF0YSwgNCAqIGkgKyAyKSwgY29udmVydEludDMydG9GbG9hdDMyKGRhdGEsIDQgKiBpICsgMykpO1xyXG4gICAgICAgIHBpY2subXR4Vmlld1RvV29ybGQgPSBtdHhWaWV3VG9Xb3JsZDtcclxuXHJcbiAgICAgICAgcGlja2VkLnB1c2gocGljayk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBwaWNrZWQ7XHJcblxyXG4gICAgICBmdW5jdGlvbiBjb252ZXJ0SW50MzJ0b0Zsb2F0MzIoX2ludDMyQXJyYXk6IEludDMyQXJyYXksIF9pbmRleDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgICAgICBsZXQgYnVmZmVyOiBBcnJheUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcig0KTtcclxuICAgICAgICBsZXQgdmlldzogRGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcclxuICAgICAgICB2aWV3LnNldEludDMyKDAsIF9pbnQzMkFycmF5W19pbmRleF0pO1xyXG4gICAgICAgIHJldHVybiB2aWV3LmdldEZsb2F0MzIoMCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGNvbnZlcnRJbnQzMnRvQ29sb3IoX2ludDMyQXJyYXk6IEludDMyQXJyYXksIF9pbmRleDogbnVtYmVyKTogQ29sb3Ige1xyXG4gICAgICAgIGxldCBidWZmZXI6IEFycmF5QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDQpO1xyXG4gICAgICAgIGxldCB2aWV3OiBEYXRhVmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xyXG4gICAgICAgIHZpZXcuc2V0SW50MzIoMCwgX2ludDMyQXJyYXlbX2luZGV4XSk7XHJcbiAgICAgICAgbGV0IGNvbG9yOiBDb2xvciA9IENvbG9yLkNTUyhgcmdiKCR7dmlldy5nZXRVaW50OCgwKX0sICR7dmlldy5nZXRVaW50OCgxKX0sICR7dmlldy5nZXRVaW50OCgyKX0pYCwgdmlldy5nZXRVaW50OCgzKSAvIDI1NSk7XHJcbiAgICAgICAgcmV0dXJuIGNvbG9yO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFRoZSByZW5kZXIgZnVuY3Rpb24gZm9yIHBpY2tpbmcgYSBzaW5nbGUgbm9kZS4gXHJcbiAgICAqIEEgY2FtZXJhcHJvamVjdGlvbiB3aXRoIGV4dHJlbWVseSBuYXJyb3cgZm9jdXMgaXMgdXNlZCwgc28gZWFjaCBwaXhlbCBvZiB0aGUgYnVmZmVyIHdvdWxkIGhvbGQgdGhlIHNhbWUgaW5mb3JtYXRpb24gZnJvbSB0aGUgbm9kZSwgIFxyXG4gICAgKiBidXQgdGhlIGZyYWdtZW50IHNoYWRlciByZW5kZXJzIG9ubHkgMSBwaXhlbCBmb3IgZWFjaCBub2RlIGludG8gdGhlIHJlbmRlciBidWZmZXIsIDFzdCBub2RlIHRvIDFzdCBwaXhlbCwgMm5kIG5vZGUgdG8gc2Vjb25kIHBpeGVsIGV0Yy5cclxuICAgICovXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHBpY2soX25vZGU6IE5vZGUsIF9tdHhNZXNoVG9Xb3JsZDogTWF0cml4NHg0LCBfbXR4V29ybGRUb1ZpZXc6IE1hdHJpeDR4NCk6IHZvaWQgeyAvLyBjcmVhdGUgVGV4dHVyZSB0byByZW5kZXIgdG8sIGludC1yZ2JhXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgbGV0IGNtcE1hdGVyaWFsOiBDb21wb25lbnRNYXRlcmlhbCA9IF9ub2RlLmdldENvbXBvbmVudChDb21wb25lbnRNYXRlcmlhbCk7XHJcbiAgICAgICAgbGV0IGNtcE1lc2g6IENvbXBvbmVudE1lc2ggPSBfbm9kZS5nZXRDb21wb25lbnQoQ29tcG9uZW50TWVzaCk7XHJcblxyXG4gICAgICAgIGxldCBjb2F0OiBDb2F0ID0gY21wTWF0ZXJpYWwubWF0ZXJpYWwuY29hdDtcclxuICAgICAgICBsZXQgc2hhZGVyOiB0eXBlb2YgU2hhZGVyID0gY29hdCBpbnN0YW5jZW9mIENvYXRUZXh0dXJlZCA/IFNoYWRlclBpY2tUZXh0dXJlZCA6IFNoYWRlclBpY2s7XHJcblxyXG4gICAgICAgIHNoYWRlci51c2VQcm9ncmFtKCk7XHJcbiAgICAgICAgY29hdC51c2VSZW5kZXJEYXRhKHNoYWRlciwgY21wTWF0ZXJpYWwpO1xyXG5cclxuICAgICAgICBsZXQgc2l6ZVVuaWZvcm1Mb2NhdGlvbjogV2ViR0xVbmlmb3JtTG9jYXRpb24gPSBzaGFkZXIudW5pZm9ybXNbXCJ1X3ZjdFNpemVcIl07XHJcbiAgICAgICAgUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpLnVuaWZvcm0yZnYoc2l6ZVVuaWZvcm1Mb2NhdGlvbiwgW1JlbmRlcldlYkdMLnNpemVQaWNrLCBSZW5kZXJXZWJHTC5zaXplUGlja10pO1xyXG5cclxuICAgICAgICBsZXQgbWVzaDogTWVzaCA9IGNtcE1lc2gubWVzaDtcclxuICAgICAgICBsZXQgbkluZGljZXM6IG51bWJlciA9IG1lc2gudXNlUmVuZGVyQnVmZmVycyhzaGFkZXIsIF9tdHhNZXNoVG9Xb3JsZCwgX210eFdvcmxkVG9WaWV3LCBSZW5kZXIuxpJwaWNrZWQubGVuZ3RoKTtcclxuICAgICAgICBSZW5kZXJXZWJHTC5jcmMzLmRyYXdFbGVtZW50cyhXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRSSUFOR0xFUywgbkluZGljZXMsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5TSUdORURfU0hPUlQsIDApO1xyXG5cclxuICAgICAgICBsZXQgcGljazogUGljayA9IG5ldyBQaWNrKF9ub2RlKTtcclxuICAgICAgICBSZW5kZXIuxpJwaWNrZWQucHVzaChwaWNrKTtcclxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XHJcbiAgICAgICAgLy9cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIExpZ2h0c1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgbGlnaHQgZGF0YSBpbiBzaGFkZXJzXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgc2V0TGlnaHRzSW5TaGFkZXIoX3NoYWRlcjogdHlwZW9mIFNoYWRlciwgX2xpZ2h0czogTWFwTGlnaHRUeXBlVG9MaWdodExpc3QpOiB2b2lkIHtcclxuICAgICAgX3NoYWRlci51c2VQcm9ncmFtKCk7XHJcbiAgICAgIGxldCB1bmk6IHsgW25hbWU6IHN0cmluZ106IFdlYkdMVW5pZm9ybUxvY2F0aW9uIH0gPSBfc2hhZGVyLnVuaWZvcm1zO1xyXG5cclxuICAgICAgLy8gQW1iaWVudFxyXG4gICAgICBsZXQgYW1iaWVudDogV2ViR0xVbmlmb3JtTG9jYXRpb24gPSB1bmlbXCJ1X2FtYmllbnQudmN0Q29sb3JcIl07XHJcbiAgICAgIGlmIChhbWJpZW50KSB7XHJcbiAgICAgICAgUmVuZGVyV2ViR0wuY3JjMy51bmlmb3JtNGZ2KGFtYmllbnQsIFswLCAwLCAwLCAwXSk7XHJcbiAgICAgICAgbGV0IGNtcExpZ2h0czogQ29tcG9uZW50TGlnaHRbXSA9IF9saWdodHMuZ2V0KExpZ2h0QW1iaWVudCk7XHJcbiAgICAgICAgaWYgKGNtcExpZ2h0cykge1xyXG4gICAgICAgICAgLy8gVE9ETzogYWRkIHVwIGFtYmllbnQgbGlnaHRzIHRvIGEgc2luZ2xlIGNvbG9yXHJcbiAgICAgICAgICBsZXQgcmVzdWx0OiBDb2xvciA9IG5ldyBDb2xvcigwLCAwLCAwLCAxKTtcclxuICAgICAgICAgIGZvciAobGV0IGNtcExpZ2h0IG9mIGNtcExpZ2h0cylcclxuICAgICAgICAgICAgcmVzdWx0LmFkZChjbXBMaWdodC5saWdodC5jb2xvcik7XHJcbiAgICAgICAgICBSZW5kZXJXZWJHTC5jcmMzLnVuaWZvcm00ZnYoYW1iaWVudCwgcmVzdWx0LmdldEFycmF5KCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRGlyZWN0aW9uYWxcclxuICAgICAgbGV0IG5EaXJlY3Rpb25hbDogV2ViR0xVbmlmb3JtTG9jYXRpb24gPSB1bmlbXCJ1X25MaWdodHNEaXJlY3Rpb25hbFwiXTtcclxuICAgICAgaWYgKG5EaXJlY3Rpb25hbCkge1xyXG4gICAgICAgIFJlbmRlcldlYkdMLmNyYzMudW5pZm9ybTF1aShuRGlyZWN0aW9uYWwsIDApO1xyXG4gICAgICAgIGxldCBjbXBMaWdodHM6IENvbXBvbmVudExpZ2h0W10gPSBfbGlnaHRzLmdldChMaWdodERpcmVjdGlvbmFsKTtcclxuICAgICAgICBpZiAoY21wTGlnaHRzKSB7XHJcbiAgICAgICAgICBsZXQgbjogbnVtYmVyID0gY21wTGlnaHRzLmxlbmd0aDtcclxuICAgICAgICAgIFJlbmRlcldlYkdMLmNyYzMudW5pZm9ybTF1aShuRGlyZWN0aW9uYWwsIG4pO1xyXG4gICAgICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgY21wTGlnaHQ6IENvbXBvbmVudExpZ2h0ID0gY21wTGlnaHRzW2ldO1xyXG4gICAgICAgICAgICBSZW5kZXJXZWJHTC5jcmMzLnVuaWZvcm00ZnYodW5pW2B1X2RpcmVjdGlvbmFsWyR7aX1dLnZjdENvbG9yYF0sIGNtcExpZ2h0LmxpZ2h0LmNvbG9yLmdldEFycmF5KCkpO1xyXG4gICAgICAgICAgICBsZXQgZGlyZWN0aW9uOiBWZWN0b3IzID0gVmVjdG9yMy5aKCk7XHJcbiAgICAgICAgICAgIGRpcmVjdGlvbi50cmFuc2Zvcm0oY21wTGlnaHQubXR4UGl2b3QsIGZhbHNlKTtcclxuICAgICAgICAgICAgZGlyZWN0aW9uLnRyYW5zZm9ybShjbXBMaWdodC5ub2RlLm10eFdvcmxkLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGRpcmVjdGlvbi5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgUmVuZGVyV2ViR0wuY3JjMy51bmlmb3JtM2Z2KHVuaVtgdV9kaXJlY3Rpb25hbFske2l9XS52Y3REaXJlY3Rpb25gXSwgZGlyZWN0aW9uLmdldCgpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhdyBhIG1lc2ggYnVmZmVyIHVzaW5nIHRoZSBnaXZlbiBpbmZvcyBhbmQgdGhlIGNvbXBsZXRlIHByb2plY3Rpb24gbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgZHJhd01lc2goX2NtcE1lc2g6IENvbXBvbmVudE1lc2gsIGNtcE1hdGVyaWFsOiBDb21wb25lbnRNYXRlcmlhbCwgX2NtcENhbWVyYTogQ29tcG9uZW50Q2FtZXJhKTogdm9pZCB7XHJcbiAgICAgIGxldCBzaGFkZXI6IHR5cGVvZiBTaGFkZXIgPSBjbXBNYXRlcmlhbC5tYXRlcmlhbC5nZXRTaGFkZXIoKTtcclxuICAgICAgbGV0IGNvYXQ6IENvYXQgPSBjbXBNYXRlcmlhbC5tYXRlcmlhbC5jb2F0O1xyXG4gICAgICBsZXQgbXR4TWVzaFRvVmlldzogTWF0cml4NHg0ID0gTWF0cml4NHg0Lk1VTFRJUExJQ0FUSU9OKF9jbXBDYW1lcmEubXR4V29ybGRUb1ZpZXcsIF9jbXBNZXNoLm10eFdvcmxkKTtcclxuICAgICAgc2hhZGVyLnVzZVByb2dyYW0oKTtcclxuICAgICAgbGV0IG5JbmRpY2VzOiBudW1iZXIgPSBfY21wTWVzaC5tZXNoLnVzZVJlbmRlckJ1ZmZlcnMoc2hhZGVyLCBfY21wTWVzaC5tdHhXb3JsZCwgbXR4TWVzaFRvVmlldyk7XHJcbiAgICAgIGNvYXQudXNlUmVuZGVyRGF0YShzaGFkZXIsIGNtcE1hdGVyaWFsKTtcclxuICAgICAgbGV0IHVDYW1lcmE6IFdlYkdMVW5pZm9ybUxvY2F0aW9uID0gc2hhZGVyLnVuaWZvcm1zW1widV92Y3RDYW1lcmFcIl07XHJcbiAgICAgIGlmICh1Q2FtZXJhKVxyXG4gICAgICAgIFJlbmRlcldlYkdMLmNyYzMudW5pZm9ybTNmdih1Q2FtZXJhLCBfY21wQ2FtZXJhLm10eFdvcmxkLnRyYW5zbGF0aW9uLmdldCgpKTtcclxuICAgICAgbGV0IHVXb3JsZFRvVmlldzogV2ViR0xVbmlmb3JtTG9jYXRpb24gPSBzaGFkZXIudW5pZm9ybXNbXCJ1X210eFdvcmxkVG9WaWV3XCJdO1xyXG4gICAgICBpZiAodVdvcmxkVG9WaWV3KVxyXG4gICAgICAgIFJlbmRlcldlYkdMLmNyYzMudW5pZm9ybU1hdHJpeDRmdih1V29ybGRUb1ZpZXcsIGZhbHNlLCBfY21wQ2FtZXJhLm10eFdvcmxkVG9WaWV3LmdldCgpKTtcclxuICAgICAgUmVuZGVyV2ViR0wuY3JjMy5kcmF3RWxlbWVudHMoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5UUklBTkdMRVMsIG5JbmRpY2VzLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOU0lHTkVEX1NIT1JULCAwKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAgLy9naXZlcyBXZWJHTCBCdWZmZXIgdGhlIGRhdGEgZnJvbSB0aGUge0BsaW5rIFRleHR1cmVdXVxyXG4gIGV4cG9ydCBjbGFzcyBSZW5kZXJJbmplY3RvclRleHR1cmUgZXh0ZW5kcyBSZW5kZXJJbmplY3RvciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIGRlY29yYXRlKF9jb25zdHJ1Y3RvcjogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgUmVuZGVySW5qZWN0b3IuaW5qZWN0KF9jb25zdHJ1Y3RvciwgUmVuZGVySW5qZWN0b3JUZXh0dXJlKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGluamVjdFRleHR1cmUodGhpczogVGV4dHVyZSk6IHZvaWQge1xyXG4gICAgICBsZXQgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcclxuICAgICAgaWYgKHRoaXMucmVuZGVyRGF0YSkge1xyXG4gICAgICAgIC8vIGJ1ZmZlcnMgZXhpc3RcclxuICAgICAgICBjcmMzLmFjdGl2ZVRleHR1cmUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFMCk7XHJcbiAgICAgICAgY3JjMy5iaW5kVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIHRoaXMucmVuZGVyRGF0YVtcInRleHR1cmUwXCJdKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICB0aGlzLnJlbmRlckRhdGEgPSB7fTtcclxuICAgICAgICAvLyBUT0RPOiBjaGVjayBpZiBhbGwgV2ViR0wtQ3JlYXRpb25zIGFyZSBhc3NlcnRlZFxyXG4gICAgICAgIGNvbnN0IHRleHR1cmU6IFdlYkdMVGV4dHVyZSA9IFJlbmRlci5hc3NlcnQ8V2ViR0xUZXh0dXJlPihjcmMzLmNyZWF0ZVRleHR1cmUoKSk7XHJcbiAgICAgICAgY3JjMy5iaW5kVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIHRleHR1cmUpO1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY3JjMy50ZXhJbWFnZTJEKGNyYzMuVEVYVFVSRV8yRCwgMCwgY3JjMy5SR0JBLCBjcmMzLlJHQkEsIGNyYzMuVU5TSUdORURfQllURSwgdGhpcy50ZXhJbWFnZVNvdXJjZSk7XHJcbiAgICAgICAgICBjcmMzLnRleEltYWdlMkQoXHJcbiAgICAgICAgICAgIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgMCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5SR0JBLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlJHQkEsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5TSUdORURfQllURSxcclxuICAgICAgICAgICAgdGhpcy50ZXhJbWFnZVNvdXJjZVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcclxuICAgICAgICAgIERlYnVnLmVycm9yKF9lcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAodGhpcy5taXBtYXApIHtcclxuICAgICAgICAgIGNhc2UgTUlQTUFQLkNSSVNQOlxyXG4gICAgICAgICAgICBjcmMzLnRleFBhcmFtZXRlcmkoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfTUFHX0ZJTFRFUiwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ORUFSRVNUKTtcclxuICAgICAgICAgICAgY3JjMy50ZXhQYXJhbWV0ZXJpKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFX01JTl9GSUxURVIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTkVBUkVTVCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSBNSVBNQVAuTUVESVVNOlxyXG4gICAgICAgICAgICBjcmMzLnRleFBhcmFtZXRlcmkoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfTUFHX0ZJTFRFUiwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ORUFSRVNUKTtcclxuICAgICAgICAgICAgY3JjMy50ZXhQYXJhbWV0ZXJpKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFX01JTl9GSUxURVIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTkVBUkVTVF9NSVBNQVBfTElORUFSKTtcclxuICAgICAgICAgICAgY3JjMy5nZW5lcmF0ZU1pcG1hcChjcmMzLlRFWFRVUkVfMkQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgTUlQTUFQLkJMVVJSWTpcclxuICAgICAgICAgICAgY3JjMy50ZXhQYXJhbWV0ZXJpKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFX01BR19GSUxURVIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTElORUFSKTtcclxuICAgICAgICAgICAgY3JjMy50ZXhQYXJhbWV0ZXJpKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFX01JTl9GSUxURVIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTElORUFSX01JUE1BUF9MSU5FQVIpO1xyXG4gICAgICAgICAgICBjcmMzLmdlbmVyYXRlTWlwbWFwKGNyYzMuVEVYVFVSRV8yRCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlbmRlckRhdGFbXCJ0ZXh0dXJlMFwiXSA9IHRleHR1cmU7XHJcblxyXG4gICAgICAgIGNyYzMuYmluZFRleHR1cmUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBudWxsKTtcclxuXHJcbiAgICAgICAgdGhpcy51c2VSZW5kZXJEYXRhKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgaW50ZXJmYWNlIE1hcENsYXNzVG9Db21wb25lbnRzIHtcclxuICAgIFtjbGFzc05hbWU6IHN0cmluZ106IENvbXBvbmVudFtdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVwcmVzZW50cyBhIG5vZGUgaW4gdGhlIHNjZW5ldHJlZS5cclxuICAgKiBAYXV0aG9ycyBKYXNjaGEgS2FyYWfDtmwsIEhGVSwgMjAxOSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL0ppcmthRGVsbE9yby9GVURHRS93aWtpL0dyYXBoXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE5vZGUgZXh0ZW5kcyBFdmVudFRhcmdldMaSIGltcGxlbWVudHMgU2VyaWFsaXphYmxlIHtcclxuICAgIHB1YmxpYyBuYW1lOiBzdHJpbmc7IC8vIFRoZSBuYW1lIHRvIGNhbGwgdGhpcyBub2RlIGJ5LlxyXG4gICAgcHVibGljIHJlYWRvbmx5IG10eFdvcmxkOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKTtcclxuICAgIHB1YmxpYyB0aW1lc3RhbXBVcGRhdGU6IG51bWJlciA9IDA7XHJcbiAgICAvKiogVGhlIG51bWJlciBvZiBub2RlcyBvZiB0aGUgd2hvbGUgYnJhbmNoIGluY2x1ZGluZyB0aGlzIG5vZGUgYW5kIGFsbCBzdWNjZXNzb3JzICovXHJcbiAgICBwdWJsaWMgbk5vZGVzSW5CcmFuY2g6IG51bWJlciA9IDA7XHJcbiAgICAvKiogVGhlIHJhZGl1cyBvZiB0aGUgYm91bmRpbmcgc3BoZXJlIGluIHdvcmxkIGRpbWVuc2lvbnMgZW5jbG9zaW5nIHRoZSBnZW9tZXRyeSBvZiB0aGlzIG5vZGUgYW5kIGFsbCBzdWNjZXNzb3JzIGluIHRoZSBicmFuY2ggKi9cclxuICAgIHB1YmxpYyByYWRpdXM6IG51bWJlciA9IDA7XHJcblxyXG4gICAgI210eFdvcmxkSW52ZXJzZVVwZGF0ZWQ6IG51bWJlcjtcclxuICAgICNtdHhXb3JsZEludmVyc2U6IE1hdHJpeDR4NDtcclxuXHJcbiAgICBwcml2YXRlIHBhcmVudDogTm9kZSB8IG51bGwgPSBudWxsOyAvLyBUaGUgcGFyZW50IG9mIHRoaXMgbm9kZS5cclxuICAgIHByaXZhdGUgY2hpbGRyZW46IE5vZGVbXSA9IFtdOyAvLyBhcnJheSBvZiBjaGlsZCBub2RlcyBhcHBlbmRlZCB0byB0aGlzIG5vZGUuXHJcbiAgICBwcml2YXRlIGNvbXBvbmVudHM6IE1hcENsYXNzVG9Db21wb25lbnRzID0ge307XHJcbiAgICAvLyBwcml2YXRlIHRhZ3M6IHN0cmluZ1tdID0gW107IC8vIE5hbWVzIG9mIHRhZ3MgdGhhdCBhcmUgYXR0YWNoZWQgdG8gdGhpcyBub2RlLiAoVE9ETzogQXMgb2YgeWV0IG5vIGZ1bmN0aW9uYWxpdHkpXHJcbiAgICAvLyBwcml2YXRlIGxheWVyczogc3RyaW5nW10gPSBbXTsgLy8gTmFtZXMgb2YgdGhlIGxheWVycyB0aGlzIG5vZGUgaXMgb24uIChUT0RPOiBBcyBvZiB5ZXQgbm8gZnVuY3Rpb25hbGl0eSlcclxuICAgIHByaXZhdGUgbGlzdGVuZXJzOiBNYXBFdmVudFR5cGVUb0xpc3RlbmVyID0ge307XHJcbiAgICBwcml2YXRlIGNhcHR1cmVzOiBNYXBFdmVudFR5cGVUb0xpc3RlbmVyID0ge307XHJcbiAgICBwcml2YXRlIGFjdGl2ZTogYm9vbGVhbiA9IHRydWU7XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBub2RlIHdpdGggYSBuYW1lIGFuZCBpbml0aWFsaXplcyBhbGwgYXR0cmlidXRlc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX25hbWU6IHN0cmluZykge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLm5hbWUgPSBfbmFtZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGlzQWN0aXZlKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy5hY3RpdmU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG9ydGN1dCB0byByZXRyaWV2ZSB0aGlzIG5vZGVzIHtAbGluayBDb21wb25lbnRUcmFuc2Zvcm19XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgY21wVHJhbnNmb3JtKCk6IENvbXBvbmVudFRyYW5zZm9ybSB7XHJcbiAgICAgIHJldHVybiA8Q29tcG9uZW50VHJhbnNmb3JtPnRoaXMuZ2V0Q29tcG9uZW50cyhDb21wb25lbnRUcmFuc2Zvcm0pWzBdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvcnRjdXQgdG8gcmV0cmlldmUgdGhlIGxvY2FsIHtAbGluayBNYXRyaXg0eDR9IGF0dGFjaGVkIHRvIHRoaXMgbm9kZXMge0BsaW5rIENvbXBvbmVudFRyYW5zZm9ybX0gIFxyXG4gICAgICogRmFpbHMgaWYgbm8ge0BsaW5rIENvbXBvbmVudFRyYW5zZm9ybX0gaXMgYXR0YWNoZWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBtdHhMb2NhbCgpOiBNYXRyaXg0eDQge1xyXG4gICAgICByZXR1cm4gdGhpcy5jbXBUcmFuc2Zvcm0ubXR4TG9jYWw7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBtdHhXb3JsZEludmVyc2UoKTogTWF0cml4NHg0IHtcclxuICAgICAgaWYgKHRoaXMuI210eFdvcmxkSW52ZXJzZVVwZGF0ZWQgIT0gdGhpcy50aW1lc3RhbXBVcGRhdGUpXHJcbiAgICAgICAgdGhpcy4jbXR4V29ybGRJbnZlcnNlID0gTWF0cml4NHg0LklOVkVSU0lPTih0aGlzLm10eFdvcmxkKTtcclxuXHJcbiAgICAgIHRoaXMuI210eFdvcmxkSW52ZXJzZVVwZGF0ZWQgPSB0aGlzLnRpbWVzdGFtcFVwZGF0ZTtcclxuICAgICAgcmV0dXJuIHRoaXMuI210eFdvcmxkSW52ZXJzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBhdHRhY2hlZCB0byB0aGlzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgbkNoaWxkcmVuKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRvciB5aWVsZGluZyB0aGUgbm9kZSBhbmQgYWxsIGRlY2VuZGFudHMgaW4gdGhlIGdyYXBoIGJlbG93IGZvciBpdGVyYXRpb25cclxuICAgICAqIEluYWN0aXZlIG5vZGVzIGFuZCB0aGVpciBkZXNjZW5kYW50cyBjYW4gYmUgZmlsdGVyZWRcclxuICAgICAqL1xyXG4gICAgcHVibGljICogZ2V0SXRlcmF0b3IoX2FjdGl2ZTogYm9vbGVhbiA9IGZhbHNlKTogSXRlcmFibGVJdGVyYXRvcjxOb2RlPiB7XHJcbiAgICAgIGlmICghX2FjdGl2ZSB8fCB0aGlzLmlzQWN0aXZlKSB7XHJcbiAgICAgICAgeWllbGQgdGhpcztcclxuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKVxyXG4gICAgICAgICAgeWllbGQqIGNoaWxkLmdldEl0ZXJhdG9yKF9hY3RpdmUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIFtTeW1ib2wuaXRlcmF0b3JdKCk6IEl0ZXJhYmxlSXRlcmF0b3I8Tm9kZT4ge1xyXG4gICAgICByZXR1cm4gdGhpcy5nZXRJdGVyYXRvcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhY3RpdmF0ZShfb246IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgdGhpcy5hY3RpdmUgPSBfb247XHJcbiAgICAgIC8vIFRPRE86IGNoZWNrIGlmIENPTVBPTkVOVF9BQ1RJVkFURS9ERUFDVElWQVRFIGlzIHRoZSBjb3JyZWN0IGV2ZW50IHRvIGRpc3BhdGNoLiBTaG91bGRuJ3QgaXQgYmUgc29tZXRoaW5nIGxpa2UgTk9ERV9BQ1RJVkFURS9ERUFDVElWQVRFP1xyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KF9vbiA/IEVWRU5ULk5PREVfQUNUSVZBVEUgOiBFVkVOVC5OT0RFX0RFQUNUSVZBVEUsIHtidWJibGVzOiB0cnVlfSkpO1xyXG4gICAgICB0aGlzLmJyb2FkY2FzdEV2ZW50KG5ldyBFdmVudChfb24gPyBFVkVOVC5OT0RFX0FDVElWQVRFIDogRVZFTlQuTk9ERV9ERUFDVElWQVRFKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gI3JlZ2lvbiBTY2VuZXRyZWVcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGlzIG5vZGVzIHBhcmVudCBub2RlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRQYXJlbnQoKTogTm9kZSB8IG51bGwge1xyXG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFjZXMgYmFjayB0aGUgYW5jZXN0b3JzIG9mIHRoaXMgbm9kZSBhbmQgcmV0dXJucyB0aGUgZmlyc3RcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEFuY2VzdG9yKCk6IE5vZGUgfCBudWxsIHtcclxuICAgICAgbGV0IGFuY2VzdG9yOiBOb2RlID0gdGhpcztcclxuICAgICAgd2hpbGUgKGFuY2VzdG9yLmdldFBhcmVudCgpKVxyXG4gICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IuZ2V0UGFyZW50KCk7XHJcbiAgICAgIHJldHVybiBhbmNlc3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYWNlcyB0aGUgaGllcmFyY2h5IHVwd2FyZHMgdG8gdGhlIGZpcnN0IGFuY2VzdG9yIGFuZCByZXR1cm5zIHRoZSBwYXRoIHRocm91Z2ggdGhlIGdyYXBoIHRvIHRoaXMgbm9kZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0UGF0aCgpOiBOb2RlW10ge1xyXG4gICAgICBsZXQgYW5jZXN0b3I6IE5vZGUgPSB0aGlzO1xyXG4gICAgICBsZXQgcGF0aDogTm9kZVtdID0gW3RoaXNdO1xyXG4gICAgICB3aGlsZSAoYW5jZXN0b3IuZ2V0UGFyZW50KCkpXHJcbiAgICAgICAgcGF0aC51bnNoaWZ0KGFuY2VzdG9yID0gYW5jZXN0b3IuZ2V0UGFyZW50KCkpO1xyXG4gICAgICByZXR1cm4gcGF0aDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGNoaWxkIGF0IHRoZSBnaXZlbiBpbmRleCBpbiB0aGUgbGlzdCBvZiBjaGlsZHJlblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Q2hpbGQoX2luZGV4OiBudW1iZXIpOiBOb2RlIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5bX2luZGV4XTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgbGlzdCBvZiBjaGlsZHJlblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Q2hpbGRyZW4oKTogTm9kZVtdIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4uc2xpY2UoMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHJlZmVyZW5jZXMgdG8gY2hpbGRub2RlcyB3aXRoIHRoZSBzdXBwbGllZCBuYW1lLiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldENoaWxkcmVuQnlOYW1lKF9uYW1lOiBzdHJpbmcpOiBOb2RlW10ge1xyXG4gICAgICBsZXQgZm91bmQ6IE5vZGVbXSA9IFtdO1xyXG4gICAgICBmb3VuZCA9IHRoaXMuY2hpbGRyZW4uZmlsdGVyKChfbm9kZTogTm9kZSkgPT4gX25vZGUubmFtZSA9PSBfbmFtZSk7XHJcbiAgICAgIHJldHVybiBmb3VuZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNpbXBseSBjYWxscyB7QGxpbmsgYWRkQ2hpbGR9LiBUaGlzIHJlZmVyZW5jZSBpcyBoZXJlIHNvbGVseSBiZWNhdXNlIGFwcGVuZENoaWxkIGlzIHRoZSBlcXVpdmFsZW50IG1ldGhvZCBpbiBET00uXHJcbiAgICAgKiBTZWUgYW5kIHByZWZlcmFibHkgdXNlIHtAbGluayBhZGRDaGlsZH1cclxuICAgICAqL1xyXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBtZW1iZXItb3JkZXJpbmdcclxuICAgIHB1YmxpYyByZWFkb25seSBhcHBlbmRDaGlsZDogKF9jaGlsZDogTm9kZSkgPT4gdm9pZCA9IHRoaXMuYWRkQ2hpbGQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHRoZSBnaXZlbiByZWZlcmVuY2UgdG8gYSBub2RlIHRvIHRoZSBsaXN0IG9mIGNoaWxkcmVuLCBpZiBub3QgYWxyZWFkeSBpblxyXG4gICAgICogQHRocm93cyBFcnJvciB3aGVuIHRyeWluZyB0byBhZGQgYW4gYW5jZXN0b3Igb2YgdGhpcyBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFkZENoaWxkKF9jaGlsZDogTm9kZSk6IHZvaWQge1xyXG4gICAgICBpZiAodGhpcy5jaGlsZHJlbi5pbmNsdWRlcyhfY2hpbGQpKVxyXG4gICAgICAgIC8vIF9ub2RlIGlzIGFscmVhZHkgYSBjaGlsZCBvZiB0aGlzXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgbGV0IGluQXVkaW9HcmFwaDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgICBsZXQgZ3JhcGhMaXN0ZW5lZDogTm9kZSA9IEF1ZGlvTWFuYWdlci5kZWZhdWx0LmdldEdyYXBoTGlzdGVuaW5nVG8oKTtcclxuICAgICAgbGV0IGFuY2VzdG9yOiBOb2RlID0gdGhpcztcclxuICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XHJcbiAgICAgICAgYW5jZXN0b3IudGltZXN0YW1wVXBkYXRlID0gMDtcclxuICAgICAgICBpbkF1ZGlvR3JhcGggPSBpbkF1ZGlvR3JhcGggfHwgKGFuY2VzdG9yID09IGdyYXBoTGlzdGVuZWQpO1xyXG4gICAgICAgIGlmIChhbmNlc3RvciA9PSBfY2hpbGQpXHJcbiAgICAgICAgICB0aHJvdyAobmV3IEVycm9yKFwiQ3ljbGljIHJlZmVyZW5jZSBwcm9oaWJpdGVkIGluIG5vZGUgaGllcmFyY2h5LCBhbmNlc3RvcnMgbXVzdCBub3QgYmUgYWRkZWQgYXMgY2hpbGRyZW5cIikpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgcHJldmlvdXNQYXJlbnQ6IE5vZGUgPSBfY2hpbGQucGFyZW50O1xyXG4gICAgICBpZiAocHJldmlvdXNQYXJlbnQpXHJcbiAgICAgICAgcHJldmlvdXNQYXJlbnQucmVtb3ZlQ2hpbGQoX2NoaWxkKTtcclxuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKF9jaGlsZCk7XHJcbiAgICAgIF9jaGlsZC5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICBfY2hpbGQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuQ0hJTERfQVBQRU5ELCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xyXG4gICAgICBpZiAoaW5BdWRpb0dyYXBoKVxyXG4gICAgICAgIF9jaGlsZC5icm9hZGNhc3RFdmVudChuZXcgRXZlbnQoRVZFTlRfQVVESU8uQ0hJTERfQVBQRU5EKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSByZWZlcmVuY2UgdG8gdGhlIGdpdmUgbm9kZSBmcm9tIHRoZSBsaXN0IG9mIGNoaWxkcmVuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZW1vdmVDaGlsZChfY2hpbGQ6IE5vZGUpOiB2b2lkIHtcclxuICAgICAgbGV0IGZvdW5kOiBudW1iZXIgPSB0aGlzLmZpbmRDaGlsZChfY2hpbGQpO1xyXG4gICAgICBpZiAoZm91bmQgPCAwKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIF9jaGlsZC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVC5DSElMRF9SRU1PVkUsIHsgYnViYmxlczogdHJ1ZSB9KSk7XHJcbiAgICAgIGlmICh0aGlzLmlzRGVzY2VuZGFudE9mKEF1ZGlvTWFuYWdlci5kZWZhdWx0LmdldEdyYXBoTGlzdGVuaW5nVG8oKSkpXHJcbiAgICAgICAgX2NoaWxkLmJyb2FkY2FzdEV2ZW50KG5ldyBFdmVudChFVkVOVF9BVURJTy5DSElMRF9SRU1PVkUpKTtcclxuICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoZm91bmQsIDEpO1xyXG4gICAgICBfY2hpbGQucGFyZW50ID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYWxsIHJlZmVyZW5jZXMgaW4gdGhlIGxpc3Qgb2YgY2hpbGRyZW5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlbW92ZUFsbENoaWxkcmVuKCk6IHZvaWQge1xyXG4gICAgICB3aGlsZSAodGhpcy5jaGlsZHJlbi5sZW5ndGgpXHJcbiAgICAgICAgdGhpcy5yZW1vdmVDaGlsZCh0aGlzLmNoaWxkcmVuWzBdKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBub2RlIGluIHRoZSBsaXN0IG9mIGNoaWxkcmVuIG9yIC0xIGlmIG5vdCBmb3VuZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZmluZENoaWxkKF9zZWFyY2g6IE5vZGUpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5pbmRleE9mKF9zZWFyY2gpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVwbGFjZXMgYSBjaGlsZCBub2RlIHdpdGggYW5vdGhlciwgcHJlc2VydmluZyB0aGUgcG9zaXRpb24gaW4gdGhlIGxpc3Qgb2YgY2hpbGRyZW5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlcGxhY2VDaGlsZChfcmVwbGFjZTogTm9kZSwgX3dpdGg6IE5vZGUpOiBib29sZWFuIHtcclxuICAgICAgbGV0IGZvdW5kOiBudW1iZXIgPSB0aGlzLmZpbmRDaGlsZChfcmVwbGFjZSk7XHJcbiAgICAgIGlmIChmb3VuZCA8IDApXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgbGV0IHByZXZpb3VzUGFyZW50OiBOb2RlID0gX3dpdGguZ2V0UGFyZW50KCk7XHJcbiAgICAgIGlmIChwcmV2aW91c1BhcmVudClcclxuICAgICAgICBwcmV2aW91c1BhcmVudC5yZW1vdmVDaGlsZChfd2l0aCk7XHJcblxyXG4gICAgICBfcmVwbGFjZS5wYXJlbnQgPSBudWxsO1xyXG4gICAgICB0aGlzLmNoaWxkcmVuW2ZvdW5kXSA9IF93aXRoO1xyXG4gICAgICBfd2l0aC5wYXJlbnQgPSB0aGlzO1xyXG5cclxuICAgICAgX3dpdGguZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuQ0hJTERfQVBQRU5ELCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xyXG4gICAgICBpZiAodGhpcy5pc0Rlc2NlbmRhbnRPZihBdWRpb01hbmFnZXIuZGVmYXVsdC5nZXRHcmFwaExpc3RlbmluZ1RvKCkpKVxyXG4gICAgICAgIF93aXRoLmJyb2FkY2FzdEV2ZW50KG5ldyBFdmVudChFVkVOVF9BVURJTy5DSElMRF9BUFBFTkQpKTtcclxuXHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgaXNVcGRhdGVkKF90aW1lc3RhbXBVcGRhdGU6IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gKHRoaXMudGltZXN0YW1wVXBkYXRlID09IF90aW1lc3RhbXBVcGRhdGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBpc0Rlc2NlbmRhbnRPZihfYW5jZXN0b3I6IE5vZGUpOiBib29sZWFuIHtcclxuICAgICAgbGV0IG5vZGU6IE5vZGUgPSB0aGlzO1xyXG4gICAgICB3aGlsZSAobm9kZSAmJiBub2RlICE9IF9hbmNlc3RvcilcclxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XHJcbiAgICAgIHJldHVybiAobm9kZSAhPSBudWxsKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgYSBNdXRhdG9yIGZyb20ge0BsaW5rIEFuaW1hdGlvbn0gdG8gYWxsIGl0cyBjb21wb25lbnRzIGFuZCB0cmFuc2ZlcnMgaXQgdG8gaXRzIGNoaWxkcmVuLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXBwbHlBbmltYXRpb24oX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgaWYgKF9tdXRhdG9yLmNvbXBvbmVudHMpIHtcclxuICAgICAgICBmb3IgKGxldCBjb21wb25lbnROYW1lIGluIF9tdXRhdG9yLmNvbXBvbmVudHMpIHtcclxuICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudHNbY29tcG9uZW50TmFtZV0pIHtcclxuICAgICAgICAgICAgbGV0IG11dGF0b3JPZkNvbXBvbmVudDogTXV0YXRvciA9IDxNdXRhdG9yPl9tdXRhdG9yLmNvbXBvbmVudHM7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgaW4gbXV0YXRvck9mQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50c1tjb21wb25lbnROYW1lXVsraV0pIHtcclxuICAgICAgICAgICAgICAgIGxldCBjb21wb25lbnRUb011dGF0ZTogQ29tcG9uZW50ID0gdGhpcy5jb21wb25lbnRzW2NvbXBvbmVudE5hbWVdWytpXTtcclxuICAgICAgICAgICAgICAgIGxldCBtdXRhdG9yQXJyYXk6IE11dGF0b3JbXSA9ICg8QXJyYXk8TXV0YXRvcj4+bXV0YXRvck9mQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdKTtcclxuICAgICAgICAgICAgICAgIGxldCBtdXRhdG9yV2l0aENvbXBvbmVudE5hbWU6IE11dGF0b3IgPSA8TXV0YXRvcj5tdXRhdG9yQXJyYXlbK2ldO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY25hbWUgaW4gbXV0YXRvcldpdGhDb21wb25lbnROYW1lKSB7ICAgLy8gdHJpY2sgdXNlZCB0byBnZXQgdGhlIG9ubHkgZW50cnkgaW4gdGhlIGxpc3RcclxuICAgICAgICAgICAgICAgICAgbGV0IG11dGF0b3JUb0dpdmU6IE11dGF0b3IgPSA8TXV0YXRvcj5tdXRhdG9yV2l0aENvbXBvbmVudE5hbWVbY25hbWVdO1xyXG4gICAgICAgICAgICAgICAgICBjb21wb25lbnRUb011dGF0ZS5tdXRhdGUobXV0YXRvclRvR2l2ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChfbXV0YXRvci5jaGlsZHJlbikge1xyXG4gICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCAoPEFycmF5PE9iamVjdD4+X211dGF0b3IuY2hpbGRyZW4pLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBsZXQgbmFtZTogc3RyaW5nID0gKDxOb2RlPig8QXJyYXk8TXV0YXRvcj4+X211dGF0b3IuY2hpbGRyZW4pW2ldW1wixpIuTm9kZVwiXSkubmFtZTtcclxuICAgICAgICAgIGxldCBjaGlsZE5vZGVzOiBOb2RlW10gPSB0aGlzLmdldENoaWxkcmVuQnlOYW1lKG5hbWUpO1xyXG4gICAgICAgICAgZm9yIChsZXQgY2hpbGROb2RlIG9mIGNoaWxkTm9kZXMpIHtcclxuICAgICAgICAgICAgY2hpbGROb2RlLmFwcGx5QW5pbWF0aW9uKDxNdXRhdG9yPig8QXJyYXk8TXV0YXRvcj4+X211dGF0b3IuY2hpbGRyZW4pW2ldW1wixpIuTm9kZVwiXSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyAjZW5kcmVnaW9uXHJcblxyXG4gICAgLy8gI3JlZ2lvbiBDb21wb25lbnRzXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGFsbCBjb21wb25lbnRzIGF0dGFjaGVkIHRvIHRoaXMgbm9kZSwgaW5kZXBlbmRlbnQgb2YgdHlwZS4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRBbGxDb21wb25lbnRzKCk6IENvbXBvbmVudFtdIHtcclxuICAgICAgbGV0IGFsbDogQ29tcG9uZW50W10gPSBbXTtcclxuICAgICAgZm9yIChsZXQgdHlwZSBpbiB0aGlzLmNvbXBvbmVudHMpIHtcclxuICAgICAgICBhbGwgPSBhbGwuY29uY2F0KHRoaXMuY29tcG9uZW50c1t0eXBlXSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGFsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgbGlzdCBvZiBjb21wb25lbnRzIG9mIHRoZSBnaXZlbiBjbGFzcyBhdHRhY2hlZCB0byB0aGlzIG5vZGUuIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Q29tcG9uZW50czxUIGV4dGVuZHMgQ29tcG9uZW50PihfY2xhc3M6IG5ldyAoKSA9PiBUKTogVFtdIHtcclxuICAgICAgcmV0dXJuIDxUW10+KHRoaXMuY29tcG9uZW50c1tfY2xhc3MubmFtZV0gfHwgW10pLnNsaWNlKDApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBjb21wb250ZW50IGZvdW5kIG9mIHRoZSBnaXZlbiBjbGFzcyBhdHRhY2hlZCB0aGlzIG5vZGUgb3IgbnVsbCwgaWYgbGlzdCBpcyBlbXB0eSBvciBkb2Vzbid0IGV4aXN0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRDb21wb25lbnQ8VCBleHRlbmRzIENvbXBvbmVudD4oX2NsYXNzOiBuZXcgKCkgPT4gVCk6IFQge1xyXG4gICAgICBsZXQgbGlzdDogVFtdID0gPFRbXT50aGlzLmNvbXBvbmVudHNbX2NsYXNzLm5hbWVdO1xyXG4gICAgICBpZiAobGlzdClcclxuICAgICAgICByZXR1cm4gbGlzdFswXTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBdHRhY2ggdGhlIGdpdmVuIGNvbXBvbmVudCB0byB0aGlzIG5vZGUuIElkZW50aWNhbCB0byB7QGxpbmsgYWRkQ29tcG9uZW50fVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXR0YWNoKF9jb21wb25lbnQ6IENvbXBvbmVudCk6IHZvaWQge1xyXG4gICAgICB0aGlzLmFkZENvbXBvbmVudChfY29tcG9uZW50KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXR0YWNoIHRoZSBnaXZlbiBjb21wb25lbnQgdG8gdGhpcyBub2RlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhZGRDb21wb25lbnQoX2NvbXBvbmVudDogQ29tcG9uZW50KTogdm9pZCB7XHJcbiAgICAgIGlmIChfY29tcG9uZW50Lm5vZGUgPT0gdGhpcylcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIGxldCBjbXBMaXN0OiBDb21wb25lbnRbXSA9IHRoaXMuY29tcG9uZW50c1tfY29tcG9uZW50LnR5cGVdO1xyXG4gICAgICBpZiAoY21wTGlzdCA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHRoaXMuY29tcG9uZW50c1tfY29tcG9uZW50LnR5cGVdID0gW19jb21wb25lbnRdO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgaWYgKGNtcExpc3QubGVuZ3RoICYmIF9jb21wb25lbnQuaXNTaW5nbGV0b24pXHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb21wb25lbnQgaXMgbWFya2VkIHNpbmdsZXRvbiBhbmQgY2FuJ3QgYmUgYXR0YWNoZWQsIG5vIG1vcmUgdGhhbiBvbmUgYWxsb3dlZFwiKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICBjbXBMaXN0LnB1c2goX2NvbXBvbmVudCk7XHJcblxyXG4gICAgICBfY29tcG9uZW50LmF0dGFjaFRvTm9kZSh0aGlzKTtcclxuICAgICAgX2NvbXBvbmVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVC5DT01QT05FTlRfQUREKSk7XHJcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudFRvVGFyZ2V0T25seShuZXcgQ3VzdG9tRXZlbnQoRVZFTlQuQ09NUE9ORU5UX0FERCwgeyBkZXRhaWw6IF9jb21wb25lbnQgfSkpOyAvLyBUT0RPOiBzZWUgaWYgdGhpcyBpcyBiZSBmZWFzYWJsZVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGV0YWNoIHRoZSBnaXZlbiBjb21wb25lbnQgZnJvbSB0aGlzIG5vZGUuIElkZW50aWNhbCB0byB7QGxpbmsgcmVtb3ZlQ29tcG9uZW50fVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZGV0YWNoKF9jb21wb25lbnQ6IENvbXBvbmVudCk6IHZvaWQge1xyXG4gICAgICB0aGlzLnJlbW92ZUNvbXBvbmVudChfY29tcG9uZW50KTtcclxuICAgIH1cclxuICAgIC8qKiBcclxuICAgICAqIFJlbW92ZXMgdGhlIGdpdmVuIGNvbXBvbmVudCBmcm9tIHRoZSBub2RlLCBpZiBpdCB3YXMgYXR0YWNoZWQsIGFuZCBzZXRzIGl0cyBwYXJlbnQgdG8gbnVsbC4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZW1vdmVDb21wb25lbnQoX2NvbXBvbmVudDogQ29tcG9uZW50KTogdm9pZCB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgbGV0IGNvbXBvbmVudHNPZlR5cGU6IENvbXBvbmVudFtdID0gdGhpcy5jb21wb25lbnRzW19jb21wb25lbnQudHlwZV07XHJcbiAgICAgICAgbGV0IGZvdW5kQXQ6IG51bWJlciA9IGNvbXBvbmVudHNPZlR5cGUuaW5kZXhPZihfY29tcG9uZW50KTtcclxuICAgICAgICBpZiAoZm91bmRBdCA8IDApXHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgX2NvbXBvbmVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVC5DT01QT05FTlRfUkVNT1ZFKSk7XHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50VG9UYXJnZXRPbmx5KG5ldyBDdXN0b21FdmVudChFVkVOVC5DT01QT05FTlRfUkVNT1ZFLCB7IGRldGFpbDogX2NvbXBvbmVudCB9KSk7IC8vIFRPRE86IHNlZSBpZiB0aGlzIHdvdWxkIGJlIGZlYXNhYmxlXHJcbiAgICAgICAgY29tcG9uZW50c09mVHlwZS5zcGxpY2UoZm91bmRBdCwgMSk7XHJcbiAgICAgICAgX2NvbXBvbmVudC5hdHRhY2hUb05vZGUobnVsbCk7XHJcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHJlbW92ZSBjb21wb25lbnQgJyR7X2NvbXBvbmVudH0naW4gbm9kZSBuYW1lZCAnJHt0aGlzLm5hbWV9J2ApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyAjZW5kcmVnaW9uXHJcblxyXG4gICAgLy8gI3JlZ2lvbiBTZXJpYWxpemF0aW9uXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHtcclxuICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgYWN0aXZlOiB0aGlzLmFjdGl2ZVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgbGV0IGNvbXBvbmVudHM6IFNlcmlhbGl6YXRpb24gPSB7fTtcclxuICAgICAgZm9yIChsZXQgdHlwZSBpbiB0aGlzLmNvbXBvbmVudHMpIHtcclxuICAgICAgICBjb21wb25lbnRzW3R5cGVdID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgY29tcG9uZW50IG9mIHRoaXMuY29tcG9uZW50c1t0eXBlXSkge1xyXG4gICAgICAgICAgLy8gY29tcG9uZW50c1t0eXBlXS5wdXNoKGNvbXBvbmVudC5zZXJpYWxpemUoKSk7XHJcbiAgICAgICAgICBjb21wb25lbnRzW3R5cGVdLnB1c2goU2VyaWFsaXplci5zZXJpYWxpemUoY29tcG9uZW50KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHNlcmlhbGl6YXRpb25bXCJjb21wb25lbnRzXCJdID0gY29tcG9uZW50cztcclxuXHJcbiAgICAgIGxldCBjaGlsZHJlbjogU2VyaWFsaXphdGlvbltdID0gW107XHJcbiAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcclxuICAgICAgICBjaGlsZHJlbi5wdXNoKFNlcmlhbGl6ZXIuc2VyaWFsaXplKGNoaWxkKSk7XHJcbiAgICAgIH1cclxuICAgICAgc2VyaWFsaXphdGlvbltcImNoaWxkcmVuXCJdID0gY2hpbGRyZW47XHJcblxyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULk5PREVfU0VSSUFMSVpFRCkpO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICB0aGlzLm5hbWUgPSBfc2VyaWFsaXphdGlvbi5uYW1lO1xyXG4gICAgICAvLyB0aGlzLnBhcmVudCA9IGlzIHNldCB3aGVuIHRoZSBub2RlcyBhcmUgYWRkZWRcclxuXHJcbiAgICAgIC8vIGRlc2VyaWFsaXplIGNvbXBvbmVudHMgZmlyc3Qgc28gc2NyaXB0cyBjYW4gcmVhY3QgdG8gY2hpbGRyZW4gYmVpbmcgYXBwZW5kZWRcclxuICAgICAgZm9yIChsZXQgdHlwZSBpbiBfc2VyaWFsaXphdGlvbi5jb21wb25lbnRzKSB7XHJcbiAgICAgICAgZm9yIChsZXQgc2VyaWFsaXplZENvbXBvbmVudCBvZiBfc2VyaWFsaXphdGlvbi5jb21wb25lbnRzW3R5cGVdKSB7XHJcbiAgICAgICAgICBsZXQgZGVzZXJpYWxpemVkQ29tcG9uZW50OiBDb21wb25lbnQgPSA8Q29tcG9uZW50PmF3YWl0IFNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoc2VyaWFsaXplZENvbXBvbmVudCk7XHJcbiAgICAgICAgICB0aGlzLmFkZENvbXBvbmVudChkZXNlcmlhbGl6ZWRDb21wb25lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yIChsZXQgc2VyaWFsaXplZENoaWxkIG9mIF9zZXJpYWxpemF0aW9uLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgbGV0IGRlc2VyaWFsaXplZENoaWxkOiBOb2RlID0gPE5vZGU+YXdhaXQgU2VyaWFsaXplci5kZXNlcmlhbGl6ZShzZXJpYWxpemVkQ2hpbGQpO1xyXG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoZGVzZXJpYWxpemVkQ2hpbGQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULk5PREVfREVTRVJJQUxJWkVEKSk7XHJcbiAgICAgIGZvciAobGV0IGNvbXBvbmVudCBvZiB0aGlzLmdldEFsbENvbXBvbmVudHMoKSlcclxuICAgICAgICBjb21wb25lbnQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuTk9ERV9ERVNFUklBTElaRUQpKTtcclxuXHJcbiAgICAgIHRoaXMuYWN0aXZhdGUoX3NlcmlhbGl6YXRpb24uYWN0aXZlKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvLyAjZW5kcmVnaW9uXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgc3RyaW5nIGFzIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgbm9kZSBhbmQgaXRzIGRlc2NlbmRhbnRzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b0hpZXJhcmNoeVN0cmluZyhfbm9kZTogTm9kZSA9IG51bGwsIF9sZXZlbDogbnVtYmVyID0gMCk6IHN0cmluZyB7XHJcbiAgICAgIC8vIFRPRE86IHJlZmFjdG9yIGZvciBiZXR0ZXIgcmVhZGFiaWxpdHlcclxuICAgICAgaWYgKCFfbm9kZSlcclxuICAgICAgICBfbm9kZSA9IHRoaXM7XHJcblxyXG4gICAgICBsZXQgcHJlZml4OiBzdHJpbmcgPSBcIitcIi5yZXBlYXQoX2xldmVsKTtcclxuXHJcbiAgICAgIGxldCBvdXRwdXQ6IHN0cmluZyA9IHByZWZpeCArIFwiIFwiICsgX25vZGUubmFtZSArIFwiIHwgXCI7XHJcbiAgICAgIGZvciAobGV0IHR5cGUgaW4gX25vZGUuY29tcG9uZW50cylcclxuICAgICAgICBvdXRwdXQgKz0gX25vZGUuY29tcG9uZW50c1t0eXBlXS5sZW5ndGggKyBcIiBcIiArIHR5cGUuc3BsaXQoXCJDb21wb25lbnRcIikucG9wKCkgKyBcIiwgXCI7XHJcbiAgICAgIG91dHB1dCA9IG91dHB1dC5zbGljZSgwLCAtMikgKyBcIjwvYnI+XCI7XHJcbiAgICAgIGZvciAobGV0IGNoaWxkIG9mIF9ub2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgb3V0cHV0ICs9IHRoaXMudG9IaWVyYXJjaHlTdHJpbmcoY2hpbGQsIF9sZXZlbCArIDEpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gI3JlZ2lvbiBFdmVudHNcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciB0byB0aGUgbm9kZS4gVGhlIGdpdmVuIGhhbmRsZXIgd2lsbCBiZSBjYWxsZWQgd2hlbiBhIG1hdGNoaW5nIGV2ZW50IGlzIHBhc3NlZCB0byB0aGUgbm9kZS5cclxuICAgICAqIERldmlhdGluZyBmcm9tIHRoZSBzdGFuZGFyZCBFdmVudFRhcmdldCwgaGVyZSB0aGUgX2hhbmRsZXIgbXVzdCBiZSBhIGZ1bmN0aW9uIGFuZCBfY2FwdHVyZSBpcyB0aGUgb25seSBvcHRpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhZGRFdmVudExpc3RlbmVyKF90eXBlOiBFVkVOVCB8IHN0cmluZywgX2hhbmRsZXI6IEV2ZW50TGlzdGVuZXLGkiwgX2NhcHR1cmU6IGJvb2xlYW4gLyp8IEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zKi8gPSBmYWxzZSk6IHZvaWQge1xyXG4gICAgICBsZXQgbGlzdExpc3RlbmVyczogTWFwRXZlbnRUeXBlVG9MaXN0ZW5lciA9IF9jYXB0dXJlID8gdGhpcy5jYXB0dXJlcyA6IHRoaXMubGlzdGVuZXJzO1xyXG4gICAgICBpZiAoIWxpc3RMaXN0ZW5lcnNbX3R5cGVdKVxyXG4gICAgICAgIGxpc3RMaXN0ZW5lcnNbX3R5cGVdID0gW107XHJcbiAgICAgIGxpc3RMaXN0ZW5lcnNbX3R5cGVdLnB1c2goX2hhbmRsZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGFuIGV2ZW50IGxpc3RlbmVyIGZyb20gdGhlIG5vZGUuIFRoZSBzaWduYXR1cmUgbXVzdCBtYXRjaCB0aGUgb25lIHVzZWQgd2l0aCBhZGRFdmVudExpc3RlbmVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZW1vdmVFdmVudExpc3RlbmVyKF90eXBlOiBFVkVOVCB8IHN0cmluZywgX2hhbmRsZXI6IEV2ZW50TGlzdGVuZXLGkiwgX2NhcHR1cmU6IGJvb2xlYW4gLyp8IEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zKi8gPSBmYWxzZSk6IHZvaWQge1xyXG4gICAgICBsZXQgbGlzdGVuZXJzRm9yVHlwZTogRXZlbnRMaXN0ZW5lcsaSW10gPSBfY2FwdHVyZSA/IHRoaXMuY2FwdHVyZXNbX3R5cGVdIDogdGhpcy5saXN0ZW5lcnNbX3R5cGVdO1xyXG4gICAgICBpZiAobGlzdGVuZXJzRm9yVHlwZSlcclxuICAgICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSBsaXN0ZW5lcnNGb3JUeXBlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxyXG4gICAgICAgICAgaWYgKGxpc3RlbmVyc0ZvclR5cGVbaV0gPT0gX2hhbmRsZXIpXHJcbiAgICAgICAgICAgIGxpc3RlbmVyc0ZvclR5cGUuc3BsaWNlKGksIDEpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwYXRjaGVzIGEgc3ludGhldGljIGV2ZW50IHRvIHRhcmdldC4gVGhpcyBpbXBsZW1lbnRhdGlvbiBhbHdheXMgcmV0dXJucyB0cnVlIChzdGFuZGFyZDogcmV0dXJuIHRydWUgb25seSBpZiBlaXRoZXIgZXZlbnQncyBjYW5jZWxhYmxlIGF0dHJpYnV0ZSB2YWx1ZSBpcyBmYWxzZSBvciBpdHMgcHJldmVudERlZmF1bHQoKSBtZXRob2Qgd2FzIG5vdCBpbnZva2VkKVxyXG4gICAgICogVGhlIGV2ZW50IHRyYXZlbHMgaW50byB0aGUgaGllcmFyY2h5IHRvIHRoaXMgbm9kZSBkaXNwYXRjaGluZyB0aGUgZXZlbnQsIGludm9raW5nIG1hdGNoaW5nIGhhbmRsZXJzIG9mIHRoZSBub2RlcyBhbmNlc3RvcnMgbGlzdGVuaW5nIHRvIHRoZSBjYXB0dXJlIHBoYXNlLCBcclxuICAgICAqIHRoYW4gdGhlIG1hdGNoaW5nIGhhbmRsZXIgb2YgdGhlIHRhcmdldCBub2RlIGluIHRoZSB0YXJnZXQgcGhhc2UsIGFuZCBiYWNrIG91dCBvZiB0aGUgaGllcmFyY2h5IGluIHRoZSBidWJibGluZyBwaGFzZSwgaW52b2tpbmcgYXBwcm9wcmlhdGUgaGFuZGxlcnMgb2YgdGhlIGFudmVzdG9yc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZGlzcGF0Y2hFdmVudChfZXZlbnQ6IEV2ZW50KTogYm9vbGVhbiB7XHJcbiAgICAgIGxldCBhbmNlc3RvcnM6IE5vZGVbXSA9IFtdO1xyXG4gICAgICBsZXQgdXBjb21pbmc6IE5vZGUgPSB0aGlzO1xyXG4gICAgICAvLyBvdmVyd3JpdGUgZXZlbnQgdGFyZ2V0XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXZlbnQsIFwidGFyZ2V0XCIsIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB0aGlzIH0pO1xyXG4gICAgICAvLyBUT0RPOiBjb25zaWRlciB1c2luZyBSZWZsZWN0IGluc3RlYWQgb2YgT2JqZWN0IHRocm91Z2hvdXQuIFNlZSBhbHNvIFJlbmRlciBhbmQgTXV0YWJsZS4uLlxyXG4gICAgICB3aGlsZSAodXBjb21pbmcucGFyZW50KVxyXG4gICAgICAgIGFuY2VzdG9ycy5wdXNoKHVwY29taW5nID0gdXBjb21pbmcucGFyZW50KTtcclxuXHJcbiAgICAgIC8vIGNhcHR1cmUgcGhhc2VcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9ldmVudCwgXCJldmVudFBoYXNlXCIsIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBFdmVudC5DQVBUVVJJTkdfUEhBU0UgfSk7XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IGFuY2VzdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgIGxldCBhbmNlc3RvcjogTm9kZSA9IGFuY2VzdG9yc1tpXTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V2ZW50LCBcImN1cnJlbnRUYXJnZXRcIiwgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGFuY2VzdG9yIH0pO1xyXG4gICAgICAgIHRoaXMuY2FsbExpc3RlbmVycyhhbmNlc3Rvci5jYXB0dXJlc1tfZXZlbnQudHlwZV0sIF9ldmVudCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHRhcmdldCBwaGFzZVxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V2ZW50LCBcImV2ZW50UGhhc2VcIiwgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IEV2ZW50LkFUX1RBUkdFVCB9KTtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9ldmVudCwgXCJjdXJyZW50VGFyZ2V0XCIsIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB0aGlzIH0pO1xyXG4gICAgICB0aGlzLmNhbGxMaXN0ZW5lcnModGhpcy5jYXB0dXJlc1tfZXZlbnQudHlwZV0sIF9ldmVudCk7XHJcbiAgICAgIHRoaXMuY2FsbExpc3RlbmVycyh0aGlzLmxpc3RlbmVyc1tfZXZlbnQudHlwZV0sIF9ldmVudCk7XHJcblxyXG4gICAgICBpZiAoIV9ldmVudC5idWJibGVzKVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgLy8gYnViYmxlIHBoYXNlXHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXZlbnQsIFwiZXZlbnRQaGFzZVwiLCB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogRXZlbnQuQlVCQkxJTkdfUEhBU0UgfSk7XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBhbmNlc3RvcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgYW5jZXN0b3I6IE5vZGUgPSBhbmNlc3RvcnNbaV07XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9ldmVudCwgXCJjdXJyZW50VGFyZ2V0XCIsIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBhbmNlc3RvciB9KTtcclxuICAgICAgICB0aGlzLmNhbGxMaXN0ZW5lcnMoYW5jZXN0b3IubGlzdGVuZXJzW19ldmVudC50eXBlXSwgX2V2ZW50KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdHJ1ZTsgLy9UT0RPOiByZXR1cm4gYSBtZWFuaW5nZnVsIHZhbHVlLCBzZWUgZG9jdW1lbnRhdGlvbiBvZiBkaXNwYXRjaCBldmVudFxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwYXRjaGVzIGEgc3ludGhldGljIGV2ZW50IHRvIHRhcmdldCB3aXRob3V0IHRyYXZlbGxpbmcgdGhyb3VnaCB0aGUgZ3JhcGggaGllcmFyY2h5IG5laXRoZXIgZHVyaW5nIGNhcHR1cmUgbm9yIGJ1YmJsaW5nIHBoYXNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBkaXNwYXRjaEV2ZW50VG9UYXJnZXRPbmx5KF9ldmVudDogRXZlbnQpOiBib29sZWFuIHtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9ldmVudCwgXCJldmVudFBoYXNlXCIsIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBFdmVudC5BVF9UQVJHRVQgfSk7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXZlbnQsIFwiY3VycmVudFRhcmdldFwiLCB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogdGhpcyB9KTtcclxuICAgICAgdGhpcy5jYWxsTGlzdGVuZXJzKHRoaXMubGlzdGVuZXJzW19ldmVudC50eXBlXSwgX2V2ZW50KTsgLy8gVE9ETzogZXhhbWluZSBpZiB0aGlzIHNob3VsZCBnbyB0byB0aGUgY2FwdHVyZXMgaW5zdGVhZCBvZiB0aGUgbGlzdGVuZXJzXHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBCcm9hZGNhc3RzIGEgc3ludGhldGljIGV2ZW50IHRvIHRoaXMgbm9kZSBhbmQgZnJvbSB0aGVyZSB0byBhbGwgbm9kZXMgZGVlcGVyIGluIHRoZSBoaWVyYXJjaHksXHJcbiAgICAgKiBpbnZva2luZyBtYXRjaGluZyBoYW5kbGVycyBvZiB0aGUgbm9kZXMgbGlzdGVuaW5nIHRvIHRoZSBjYXB0dXJlIHBoYXNlLiBXYXRjaCBwZXJmb3JtYW5jZSB3aGVuIHRoZXJlIGFyZSBtYW55IG5vZGVzIGludm9sdmVkXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBicm9hZGNhc3RFdmVudChfZXZlbnQ6IEV2ZW50KTogdm9pZCB7XHJcbiAgICAgIC8vIG92ZXJ3cml0ZSBldmVudCB0YXJnZXQgYW5kIHBoYXNlXHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXZlbnQsIFwiZXZlbnRQaGFzZVwiLCB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogRXZlbnQuQ0FQVFVSSU5HX1BIQVNFIH0pO1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V2ZW50LCBcInRhcmdldFwiLCB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogdGhpcyB9KTtcclxuICAgICAgdGhpcy5icm9hZGNhc3RFdmVudFJlY3Vyc2l2ZShfZXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYnJvYWRjYXN0RXZlbnRSZWN1cnNpdmUoX2V2ZW50OiBFdmVudCk6IHZvaWQge1xyXG4gICAgICAvLyBjYXB0dXJlIHBoYXNlIG9ubHlcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9ldmVudCwgXCJjdXJyZW50VGFyZ2V0XCIsIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB0aGlzIH0pO1xyXG4gICAgICBsZXQgY2FwdHVyZXM6IEV2ZW50TGlzdGVuZXLGkltdID0gdGhpcy5jYXB0dXJlc1tfZXZlbnQudHlwZV0gfHwgW107XHJcbiAgICAgIGZvciAobGV0IGhhbmRsZXIgb2YgY2FwdHVyZXMpXHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIGhhbmRsZXIoX2V2ZW50KTtcclxuICAgICAgLy8gYXBwZWFycyB0byBiZSBzbG93ZXIsIGFzdG9uaXNoaW5nbHkuLi5cclxuICAgICAgLy8gY2FwdHVyZXMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcjogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgLy8gICAgIGhhbmRsZXIoX2V2ZW50KTtcclxuICAgICAgLy8gfSk7XHJcblxyXG4gICAgICAvLyBzYW1lIGZvciBjaGlsZHJlblxyXG4gICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgY2hpbGQuYnJvYWRjYXN0RXZlbnRSZWN1cnNpdmUoX2V2ZW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgY2FsbExpc3RlbmVycyhfbGlzdGVuZXJzOiBFdmVudExpc3RlbmVyxpJbXSwgX2V2ZW50OiBFdmVudCk6IHZvaWQge1xyXG4gICAgICBpZiAoX2xpc3RlbmVycz8ubGVuZ3RoID4gMClcclxuICAgICAgICBmb3IgKGxldCBoYW5kbGVyIG9mIF9saXN0ZW5lcnMpXHJcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgICBoYW5kbGVyKF9ldmVudCk7XHJcbiAgICB9XHJcbiAgICAvLyAjZW5kcmVnaW9uXHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGNvbnN0IGVudW0gRVZFTlRfUEhZU0lDUyB7XHJcbiAgICBUUklHR0VSX0VOVEVSID0gXCJUcmlnZ2VyRW50ZXJlZENvbGxpc2lvblwiLFxyXG4gICAgVFJJR0dFUl9FWElUID0gXCJUcmlnZ2VyTGVmdENvbGxpc2lvblwiLFxyXG4gICAgQ09MTElTSU9OX0VOVEVSID0gXCJDb2xsaWRlckVudGVyZWRDb2xsaXNpb25cIixcclxuICAgIENPTExJU0lPTl9FWElUID0gXCJDb2xsaWRlckxlZnRDb2xsaXNpb25cIlxyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGNsYXNzIEV2ZW50UGh5c2ljcyBleHRlbmRzIEV2ZW50IHtcclxuICAgIC8qKlxyXG4gICAgICogQ29tcG9uZW50UmlnaWRib2R5IHRoYXQgY29sbGlkZWQgd2l0aCB0aGlzIENvbXBvbmVudFJpZ2lkYm9keVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY21wUmlnaWRib2R5OiBDb21wb25lbnRSaWdpZGJvZHk7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBub3JtYWwgaW1wdWxzZSBiZXR3ZWVuIHRoZSB0d28gY29sbGlkaW5nIG9iamVjdHMuIE5vcm1hbCByZXByZXNlbnRzIHRoZSBkZWZhdWx0IGltcHVsc2UuXHJcbiAgICAgKiBJbXB1bHNlIGlzIG9ubHkgaGFwcGVuaW5nIG9uIENPTExJU0lPTl9FTlRFUiwgc28gdGhlcmUgaXMgbm8gaW1wdWxzZSBvbiBleGl0IG5vciBvbiB0cmlnZ2Vycy5cclxuICAgICAqIFVzZSB0aGUgdmVsb2NpdHkgb2YgdGhlIGNtcFJpZ2lkYm9keSB0byBkZXRlcm1pbmUgdGhlIGludGVuc2l0eSBvZiB0aGUgRVZFTlQgaW5zdGVhZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG5vcm1hbEltcHVsc2U6IG51bWJlcjtcclxuICAgIHB1YmxpYyB0YW5nZW50SW1wdWxzZTogbnVtYmVyO1xyXG4gICAgcHVibGljIGJpbm9tYWxJbXB1bHNlOiBudW1iZXI7XHJcbiAgICAvKiogVGhlIHBvaW50IHdoZXJlIHRoZSBjb2xsaXNpb24vdHJpZ2dlcmluZyBpbml0aWFsbHkgaGFwcGVuZWQuIFRoZSBjb2xsaXNpb24gcG9pbnQgZXhpc3RzIG9ubHkgb24gQ09MTElTSU9OX0VOVEVSIC8gVFJJR0dFUl9FTlRFUi4gKi9cclxuICAgIHB1YmxpYyBjb2xsaXNpb25Qb2ludDogVmVjdG9yMztcclxuICAgIC8qKiBUaGUgbm9ybWFsIHZlY3RvciBvZiB0aGUgY29sbGlzaW9uLiBPbmx5IGV4aXN0aW5nIG9uIENPTExJU0lPTl9FTlRFUiAqL1xyXG4gICAgcHVibGljIGNvbGxpc2lvbk5vcm1hbDogVmVjdG9yMztcclxuXHJcbiAgICAvKiogQ3JlYXRlcyBhIG5ldyBldmVudCBjdXN0b21pemVkIGZvciBwaHlzaWNzLiBIb2xkaW5nIGluZm9ybWF0aW9ucyBhYm91dCBpbXB1bHNlcy4gQ29sbGlzaW9uIHBvaW50IGFuZCB0aGUgYm9keSB0aGF0IGlzIGNvbGxpZGluZyAqL1xyXG4gICAgY29uc3RydWN0b3IoX3R5cGU6IEVWRU5UX1BIWVNJQ1MsIF9oaXRSaWdpZGJvZHk6IENvbXBvbmVudFJpZ2lkYm9keSwgX25vcm1hbEltcHVsc2U6IG51bWJlciwgX3RhbmdlbnRJbXB1bHNlOiBudW1iZXIsIF9iaW5vcm1hbEltcHVsc2U6IG51bWJlciwgX2NvbGxpc2lvblBvaW50OiBWZWN0b3IzID0gbnVsbCwgX2NvbGxpc2lvbk5vcm1hbDogVmVjdG9yMyA9IG51bGwpIHtcclxuICAgICAgc3VwZXIoX3R5cGUpO1xyXG4gICAgICB0aGlzLmNtcFJpZ2lkYm9keSA9IF9oaXRSaWdpZGJvZHk7XHJcbiAgICAgIHRoaXMubm9ybWFsSW1wdWxzZSA9IF9ub3JtYWxJbXB1bHNlO1xyXG4gICAgICB0aGlzLnRhbmdlbnRJbXB1bHNlID0gX3RhbmdlbnRJbXB1bHNlO1xyXG4gICAgICB0aGlzLmJpbm9tYWxJbXB1bHNlID0gX2Jpbm9ybWFsSW1wdWxzZTtcclxuICAgICAgdGhpcy5jb2xsaXNpb25Qb2ludCA9IF9jb2xsaXNpb25Qb2ludDtcclxuICAgICAgdGhpcy5jb2xsaXNpb25Ob3JtYWwgPSBfY29sbGlzaW9uTm9ybWFsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgKiBHcm91cHMgdG8gcGxhY2UgYSBub2RlIGluLCBub3QgZXZlcnkgZ3JvdXAgc2hvdWxkIGNvbGxpZGUgd2l0aCBldmVyeSBncm91cC4gVXNlIGEgTWFzayBpbiB0byBleGNsdWRlIGNvbGxpc2lvbnNcclxuICAqL1xyXG4gIGV4cG9ydCBlbnVtIENPTExJU0lPTl9HUk9VUCB7IC8vVE9ETyBHaXZlIGEgcG9zc2libGl0aHkgdG8gc2V0IHdoaWNoIGxheWVyIGNvbGxpZGVzIHdpdGggd2hpY2gsIENvbGxpc2lvbk1hdHJpeD9cclxuICAgIERFRkFVTFQgPSAxLFxyXG4gICAgR1JPVVBfMSA9IDIsXHJcbiAgICBHUk9VUF8yID0gNCxcclxuICAgIEdST1VQXzMgPSA4LFxyXG4gICAgR1JPVVBfNCA9IDE2LFxyXG4gICAgR1JPVVBfNSA9IDMyXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAqIERlZmluZXMgdGhlIHR5cGUgb2YgdGhlIHJpZ2lkYm9keSB3aGljaCBkZXRlcm1pbmVzIHRoZSB3YXkgaXQgaW50ZXJhY3RzIHdpdGggdGhlIHBoeXNpY2FsIGFuZCB0aGUgdmlzdWFsIHdvcmxkXHJcbiAgKi9cclxuICBleHBvcnQgZW51bSBCT0RZX1RZUEUge1xyXG4gICAgLyoqIFRoZSBib2R5IGlnbm9yZXMgdGhlIGhpZXJhcmNoeSBvZiB0aGUgcmVuZGVyIGdyYXBoLCBpcyBjb21wbGV0ZWx5IGNvbnRyb2xsZWQgIGJ5IHBoeXNpY3MgYW5kIHRha2VzIGl0cyBub2RlIHdpdGggaXQgICovXHJcbiAgICBEWU5BTUlDLCAvLyA9IE9JTU8uUmlnaWRCb2R5VHlwZS5EWU5BTUlDLFxyXG4gICAgLyoqIFRoZSBib2R5IGlnbm9yZXMgdGhlIGhpZXJhcmNoeSBvZiB0aGUgcmVuZGVyIGdyYXBoLCBpcyBjb21wbGV0ZWx5IGltbW92ZWJsZSBhbmQga2VlcHMgaXRzIG5vZGUgZnJvbSBtb3ZpbmcgICovXHJcbiAgICBTVEFUSUMsIC8vID0gT0lNTy5SaWdpZEJvZHlUeXBlLlNUQVRJQyxcclxuICAgIC8qKiBUaGUgYm9keSBpcyBjb250cm9sbGVkIGJ5IGl0cyBub2RlIGFuZCBtb3ZlcyB3aXRoIGl0LCB3aGlsZSBpdCBpbXBhY3RzIHRoZSBwaHlzaWNhbCB3b3JsZCBlLmcuIGJ5IGNvbGxpc2lvbnMgKi9cclxuICAgIEtJTkVNQVRJQyAvLyA9IE9JTU8uUmlnaWRCb2R5VHlwZS5LSU5FTUFUSUNcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICogRGlmZmVyZW50IHR5cGVzIG9mIGNvbGxpZGVyIHNoYXBlcywgd2l0aCBkaWZmZXJlbnQgb3B0aW9ucyBpbiBzY2FsaW5nIEJPWCA9IFZlY3RvcjMobGVuZ3RoLCBoZWlnaHQsIGRlcHRoKSxcclxuICAqIFNQSEVSRSA9IFZlY3RvcjMoZGlhbWV0ZXIsIHgsIHgpLCBDQVBTVUxFID0gVmVjdG9yMyhkaWFtZXRlciwgaGVpZ2h0LCB4KSwgQ1lMSU5ERVIgPSBWZWN0b3IzKGRpYW1ldGVyLCBoZWlnaHQsIHgpLFxyXG4gICogQ09ORSA9IFZlY3RvcihkaWFtZXRlciwgaGVpZ2h0LCB4KSwgUFlSQU1JRCA9IFZlY3RvcjMobGVuZ3RoLCBoZWlnaHQsIGRlcHRoKTsgeCA9PSB1bnVzZWQuXHJcbiAgKiBDT05WRVggPSBDb21wb25lbnRNZXNoIG5lZWRzIHRvIGJlIGF2YWlsYWJsZSBpbiB0aGUgUkIgUHJvcGVydHkgY29udmV4TWVzaCwgdGhlIHBvaW50cyBvZiB0aGF0IGNvbXBvbmVudCBhcmUgdXNlZCB0byBjcmVhdGUgYSBjb2xsaWRlciB0aGF0IG1hdGNoZXMsXHJcbiAgKiB0aGUgY2xvc2VzdCBwb3NzaWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGF0IGZvcm0sIGluIGZvcm0gb2YgYSBodWxsLiBDb252ZXggaXMgZXhwZXJpbWVudGFsIGFuZCBjYW4gcHJvZHVjZSB1bmV4cGVjdGVkIGJlaGF2aW91ciB3aGVuIHZlcnRpY2VzXHJcbiAgKiBhcmUgdG9vIGNsb3NlIHRvIG9uZSBhbm90aGVyIGFuZCB0aGUgZ2l2ZW4gdmVydGljZXMgZG8gbm90IGZvcm0gYSBpbiBpdHNlbGYgY2xvc2VkIHNoYXBlIGFuZCBoYXZpbmcgYSBnZW51cyBvZiAwIChubyBob2xlcykuIFZlcnRpY2VzIGluIHRoZSBDb21wb25lbnRNZXNoIGNhbiBiZSBzY2FsZWQgZGlmZmVyZW50bHkgXHJcbiAgKiBmb3IgdGV4dHVyaW5nL25vcm1hbCBvciBvdGhlciByZWFzb25zLCBzbyB0aGUgY29sbGlkZXIgbWlnaHQgYmUgb2ZmIGNvbXBhcmVkIHRvIHRoZSB2aXN1YWwgc2hhcGUsIHRoaXMgY2FuIGJlIGNvcnJlY3RlZCBieSBjaGFuZ2luZyB0aGUgcGl2b3Qgc2NhbGUgb2YgdGhlIENvbXBvbmVudFJpZ2lkYm9keS4gIFxyXG4gICovXHJcbiAgZXhwb3J0IGVudW0gQ09MTElERVJfVFlQRSB7XHJcbiAgICBDVUJFLFxyXG4gICAgU1BIRVJFLFxyXG4gICAgQ0FQU1VMRSxcclxuICAgIENZTElOREVSLFxyXG4gICAgQ09ORSxcclxuICAgIFBZUkFNSUQsXHJcbiAgICBDT05WRVhcclxuICB9XHJcblxyXG4gIC8qKiBEaXNwbGF5aW5nIGRpZmZlcmVudCB0eXBlcyBvZiBkZWJ1ZyBpbmZvcm1hdGlvbiBhYm91dCBkaWZmZXJlbnQgcGh5c2ljIGZlYXR1cmVzLiBEZWZhdWx0ID0gSk9JTlRTX0FORF9DT0xMSURFUi4gKi9cclxuICBleHBvcnQgZW51bSBQSFlTSUNTX0RFQlVHTU9ERSB7XHJcbiAgICBOT05FLFxyXG4gICAgQ09MTElERVJTLFxyXG4gICAgSk9JTlRTX0FORF9DT0xMSURFUixcclxuICAgIEJPVU5ESU5HX0JPWEVTLFxyXG4gICAgQ09OVEFDVFMsXHJcbiAgICBQSFlTSUNfT0JKRUNUU19PTkxZXHJcbiAgfVxyXG5cclxuICAvKiogSW5mbyBhYm91dCBSYXljYXN0cyBzaG90IGZyb20gdGhlIHBoeXNpY3Mgc3lzdGVtLiAqL1xyXG4gIGV4cG9ydCBjbGFzcyBSYXlIaXRJbmZvIHtcclxuICAgIHB1YmxpYyBoaXQ6IGJvb2xlYW47XHJcbiAgICBwdWJsaWMgaGl0RGlzdGFuY2U6IG51bWJlcjtcclxuICAgIHB1YmxpYyBoaXRQb2ludDogVmVjdG9yMztcclxuICAgIHB1YmxpYyByaWdpZGJvZHlDb21wb25lbnQ6IENvbXBvbmVudFJpZ2lkYm9keTtcclxuICAgIHB1YmxpYyBoaXROb3JtYWw6IFZlY3RvcjM7XHJcbiAgICBwdWJsaWMgcmF5T3JpZ2luOiBWZWN0b3IzO1xyXG4gICAgcHVibGljIHJheUVuZDogVmVjdG9yMztcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgdGhpcy5yZWN5Y2xlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlY3ljbGUoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuaGl0ID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuaGl0RGlzdGFuY2UgPSAwO1xyXG4gICAgICB0aGlzLmhpdFBvaW50ID0gVmVjdG9yMy5aRVJPKCk7XHJcbiAgICAgIHRoaXMucmlnaWRib2R5Q29tcG9uZW50ID0gbnVsbDtcclxuICAgICAgdGhpcy5oaXROb3JtYWwgPSBWZWN0b3IzLlpFUk8oKTtcclxuICAgICAgdGhpcy5yYXlPcmlnaW4gPSBWZWN0b3IzLlpFUk8oKTtcclxuICAgICAgdGhpcy5yYXlFbmQgPSBWZWN0b3IzLlpFUk8oKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKiBHZW5lcmFsIHNldHRpbmdzIGZvciB0aGUgcGh5c2ljIHNpbXVsYXRpb24gYW5kIHRoZSBkZWJ1ZyBvZiBpdC4gKi9cclxuICBleHBvcnQgY2xhc3MgUGh5c2ljc1NldHRpbmdzIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihfZGVmYXVsdENvbGxpc2lvbkdyb3VwOiBudW1iZXIsIF9kZWZhdWx0Q29sbGlzaW9uTWFzazogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuZGVmYXVsdENvbGxpc2lvbkdyb3VwID0gX2RlZmF1bHRDb2xsaXNpb25Hcm91cDtcclxuICAgICAgdGhpcy5kZWZhdWx0Q29sbGlzaW9uTWFzayA9IF9kZWZhdWx0Q29sbGlzaW9uTWFzaztcclxuICAgIH1cclxuXHJcbiAgICAvKiogQ2hhbmdlIGlmIHJpZ2lkYm9kaWVzIGFyZSBhYmxlIHRvIHNsZWVwIChkb24ndCBiZSBjb25zaWRlcmVkIGluIHBoeXNpY2FsIGNhbGN1bGF0aW9ucykgd2hlbiB0aGVpciBtb3ZlbWVudCBpcyBiZWxvdyBhIHRocmVzaG9sZC4gRGVhY3RpdmF0aW9uIGlzIGRlY3JlYXNpbmcgcGVyZm9ybWFuY2UgZm9yIG1pbm9yIGFkdmFudGFnZSBpbiBwcmVjaXNpb24uICovXHJcbiAgICBnZXQgZGlzYWJsZVNsZWVwaW5nKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gT0lNTy5TZXR0aW5nLmRpc2FibGVTbGVlcGluZztcclxuICAgIH1cclxuICAgIHNldCBkaXNhYmxlU2xlZXBpbmcoX3ZhbHVlOiBib29sZWFuKSB7XHJcbiAgICAgIE9JTU8uU2V0dGluZy5kaXNhYmxlU2xlZXBpbmcgPSBfdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKiogU2xlZXBpbmcgVGhyZXNob2xkIGZvciBNb3ZlbWVudCBWZWxvY3RpeS4gKi9cclxuICAgIGdldCBzbGVlcGluZ1ZlbG9jaXR5VGhyZXNob2xkKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiBPSU1PLlNldHRpbmcuc2xlZXBpbmdWZWxvY2l0eVRocmVzaG9sZDtcclxuICAgIH1cclxuICAgIHNldCBzbGVlcGluZ1ZlbG9jaXR5VGhyZXNob2xkKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIE9JTU8uU2V0dGluZy5zbGVlcGluZ1ZlbG9jaXR5VGhyZXNob2xkID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBTbGVlcGluZyBUaHJlc2hvbGQgZm9yIFJvdGF0aW9uIFZlbG9jaXR5LiAqL1xyXG4gICAgZ2V0IHNsZWVwaW5nQW5ndWxhclZlbG9jaXR5VGhyZXNob2xkKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiBPSU1PLlNldHRpbmcuc2xlZXBpbmdBbmd1bGFyVmVsb2NpdHlUaHJlc2hvbGQ7XHJcbiAgICB9XHJcbiAgICBzZXQgc2xlZXBpbmdBbmd1bGFyVmVsb2NpdHlUaHJlc2hvbGQoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgT0lNTy5TZXR0aW5nLnNsZWVwaW5nQW5ndWxhclZlbG9jaXR5VGhyZXNob2xkID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUaHJlc2hvbGQgaG93IGxvbmcgdGhlIFJpZ2lkYm9keSBtdXN0IGJlIGJlbG93L2Fib3ZlIHRoZSB0aHJlc2hvbGQgdG8gY291bnQgYXMgc2xlZXBpbmcuICovXHJcbiAgICBnZXQgc2xlZXBpbmdUaW1lVGhyZXNob2xkKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiBPSU1PLlNldHRpbmcuc2xlZXBpbmdUaW1lVGhyZXNob2xkO1xyXG4gICAgfVxyXG4gICAgc2V0IHNsZWVwaW5nVGltZVRocmVzaG9sZChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICBPSU1PLlNldHRpbmcuc2xlZXBpbmdUaW1lVGhyZXNob2xkID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBFcnJvciB0aHJlc2hvbGQuIERlZmF1bHQgaXMgMC4wNS4gVGhlIGhpZ2hlciB0aGUgbW9yZSBsaWtlbHkgY29sbGlzaW9ucyBnZXQgZGV0ZWN0ZWQgYmVmb3JlIGFjdHVhbCBpbXBhY3QgYXQgaGlnaCBzcGVlZHMgYnV0IGl0J3MgdmlzdWFsbHkgbGVzcyBhY2N1cmF0ZS4gKi9cclxuICAgIGdldCBkZWZhdWx0Q29sbGlzaW9uTWFyZ2luKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiBPSU1PLlNldHRpbmcuZGVmYXVsdEdKS01hcmdpbjtcclxuICAgIH1cclxuICAgIHNldCBkZWZhdWx0Q29sbGlzaW9uTWFyZ2luKF90aGlja25lc3M6IG51bWJlcikge1xyXG4gICAgICBPSU1PLlNldHRpbmcuZGVmYXVsdEdKS01hcmdpbiA9IF90aGlja25lc3M7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFRoZSBkZWZhdWx0IGFwcGxpZWQgZnJpY3Rpb24gYmV0d2VlbiB0d28gcmlnaWRib2RpZXMgd2l0aCB0aGUgZGVmYXVsdCB2YWx1ZS4gSG93IG11Y2ggdmVsb2NpdHkgaXMgc2xvd2VkIGRvd24gd2hlbiBtb3ZpbmcgYWNjcm9zcyB0aGlzIHN1cmZhY2UuICovXHJcbiAgICBnZXQgZGVmYXVsdEZyaWN0aW9uKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiBPSU1PLlNldHRpbmcuZGVmYXVsdEZyaWN0aW9uO1xyXG4gICAgfVxyXG4gICAgc2V0IGRlZmF1bHRGcmljdGlvbihfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICBPSU1PLlNldHRpbmcuZGVmYXVsdEZyaWN0aW9uID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBCb3VuY2luZXNzIG9mIHJpZ2lkYm9kaWVzLiBIb3cgbXVjaCBvZiB0aGUgaW1wYWN0IGlzIHJlc3RpdHV0ZWQuICovXHJcbiAgICBnZXQgZGVmYXVsdFJlc3RpdHV0aW9uKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiBPSU1PLlNldHRpbmcuZGVmYXVsdFJlc3RpdHV0aW9uO1xyXG4gICAgfVxyXG4gICAgc2V0IGRlZmF1bHRSZXN0aXR1dGlvbihfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICBPSU1PLlNldHRpbmcuZGVmYXVsdFJlc3RpdHV0aW9uID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBHcm91cHMgdGhlIGRlZmF1bHQgcmlnaWRib2R5IHdpbGwgY29sbGlkZSB3aXRoLiBTZXQgaXQgbGlrZTogKFBIWVNJQ1NfR1JPVVAuREVGQVVMVCB8IFBIWVNJQ1NfR1JPVVAuR1JPVVBfMSB8IFBIWVNJQ1NfR1JPVVAuR1JPVVBfMiB8IFBIWVNJQ1NfR1JPVVAuR1JPVVBfMykgXHJcbiAgICAgKiB0byBjb2xsaWRlIHdpdGggbXVsdGlwbGUgZ3JvdXBzLiBEZWZhdWx0IGlzIGNvbGxpc2lvbiB3aXRoIGV2ZXJ5dGhpbmcgYnV0IHRyaWdnZXJzLlxyXG4gICAgKi9cclxuICAgIGdldCBkZWZhdWx0Q29sbGlzaW9uTWFzaygpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gT0lNTy5TZXR0aW5nLmRlZmF1bHRDb2xsaXNpb25NYXNrO1xyXG4gICAgfVxyXG4gICAgc2V0IGRlZmF1bHRDb2xsaXNpb25NYXNrKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIE9JTU8uU2V0dGluZy5kZWZhdWx0Q29sbGlzaW9uTWFzayA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogVGhlIGdyb3VwIHRoYXQgdGhpcyByaWdpZGJvZHkgYmVsb25ncyB0by4gRGVmYXVsdCBpcyB0aGUgREVGQVVMVCBHcm91cCB3aGljaCBtZWFucyBpdHMganVzdCBhIG5vcm1hbCBSaWdpZGJvZHkgbm90IGEgdHJpZ2dlciBub3IgYW55dGhpbmcgc3BlY2lhbC4gKi9cclxuICAgIGdldCBkZWZhdWx0Q29sbGlzaW9uR3JvdXAoKTogQ09MTElTSU9OX0dST1VQIHtcclxuICAgICAgcmV0dXJuIDxDT0xMSVNJT05fR1JPVVA+T0lNTy5TZXR0aW5nLmRlZmF1bHRDb2xsaXNpb25Hcm91cDtcclxuICAgIH1cclxuICAgIHNldCBkZWZhdWx0Q29sbGlzaW9uR3JvdXAoX3ZhbHVlOiBDT0xMSVNJT05fR1JPVVApIHtcclxuICAgICAgT0lNTy5TZXR0aW5nLmRlZmF1bHRDb2xsaXNpb25Hcm91cCA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQ2hhbmdlIHRoZSB0eXBlIG9mIGpvaW50IHNvbHZlciBhbGdvcml0aG0uIERlZmF1bHQgSXRlcmF0aXZlID09IDAsIGlzIGZhc3RlciBidXQgbGVzcyBzdGFibGUuIERpcmVjdCA9PSAxLCBzbG93IGJ1dCBtb3JlIHN0YWJsZSwgcmVjb21tZW5kZWQgZm9yIGNvbXBsZXggam9pbnQgd29yay4gQ2hhbmdlIHRoaXMgc2V0dGluZyBvbmx5IGF0IHRoZSBzdGFydCBvZiB5b3VyIGdhbWUuICovXHJcbiAgICBnZXQgZGVmYXVsdENvbnN0cmFpbnRTb2x2ZXJUeXBlKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiBPSU1PLlNldHRpbmcuZGVmYXVsdEpvaW50Q29uc3RyYWludFNvbHZlclR5cGU7XHJcbiAgICB9XHJcbiAgICBzZXQgZGVmYXVsdENvbnN0cmFpbnRTb2x2ZXJUeXBlKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIE9JTU8uU2V0dGluZy5kZWZhdWx0Sm9pbnRDb25zdHJhaW50U29sdmVyVHlwZSA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogVGhlIGNvcnJlY3Rpb24gYWxnb3JpdGhtIHVzZWQgdG8gY29ycmVjdCBwaHlzaWNzIGNhbGN1bGF0aW9ucy4gQ2hhbmdlIHRoaXMgb25seSBhdCB0aGUgYmVnaW5uaW5nIG9mIHlvdXIgZ2FtZS4gRWFjaCBoYXMgZGlmZmVyZW50IGFwcHJvYWNoZXMsIHNvIGlmIHlvdSBoYXZlIHByb2JsZW1zIHRlc3QgYW5vdGhlclxyXG4gICAgICogIERlZmF1bHQgMCA9IEJhdW1nYXJ0ZSAoZmFzdCBidXQgbGVzcyBjb3JyZWN0IGluZHVjZXMgc29tZSBlbmVyZ3kgZXJyb3JzKSwgMSA9IFNwbGl0LUltcHVsc2UgKGZhc3QgYW5kIG5vIGVuZ2VyeSBlcnJvcnMsIGJ1dCBtb3JlIGluYWNjdXJhdGUgZm9yIGpvaW50cyksIDIgPSBOb24tbGluZWFyIEdhdXNzIFNlaWRlbCAoc2xvd2VzdCBidXQgbW9zdCBhY2N1cmF0ZSkqL1xyXG4gICAgZ2V0IGRlZmF1bHRDb3JyZWN0aW9uQWxnb3JpdGhtKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiBPSU1PLlNldHRpbmcuZGVmYXVsdEpvaW50UG9zaXRpb25Db3JyZWN0aW9uQWxnb3JpdGhtO1xyXG4gICAgfVxyXG4gICAgc2V0IGRlZmF1bHRDb3JyZWN0aW9uQWxnb3JpdGhtKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIE9JTU8uU2V0dGluZy5kZWZhdWx0Sm9pbnRQb3NpdGlvbkNvcnJlY3Rpb25BbGdvcml0aG0gPSBfdmFsdWU7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICAgKiBBY3RzIGFzIHRoZSBwaHlzaWNhbCByZXByZXNlbnRhdGlvbiBvZiBhIGNvbm5lY3Rpb24gYmV0d2VlbiB0d28ge0BsaW5rIE5vZGV9J3MuXHJcbiAgICAgKiBUaGUgdHlwZSBvZiBjb25uY2V0aW9uIGlzIGRlZmluZWQgYnkgdGhlIHN1YmNsYXNzZXMgbGlrZSBwcmlzbWF0aWMgam9pbnQsIGN5bGluZGVyIGpvaW50IGV0Yy5cclxuICAgICAqIEEgUmlnaWRib2R5IG9uIHRoZSB7QGxpbmsgTm9kZX0gdGhhdCB0aGlzIGNvbXBvbmVudCBpcyBhZGRlZCB0byBpcyBuZWVkZWQuIFNldHRpbmcgdGhlIGNvbm5lY3RlZFJpZ2lkYm9keSBhbmRcclxuICAgICAqIGluaXRpYWxpemluZyB0aGUgY29ubmVjdGlvbiBjcmVhdGVzIGEgcGh5c2ljYWwgY29ubmVjdGlvbiBiZXR3ZWVuIHRoZW0uIFRoaXMgZGlmZmVycyBmcm9tIGEgY29ubmVjdGlvbiB0aHJvdWdoIGhpZXJhcmNoeVxyXG4gICAgICogaW4gdGhlIG5vZGUgc3RydWN0dXJlIG9mIGZ1ZGdlLiBKb2ludHMgY2FuIGhhdmUgZGlmZmVyZW50IERPRidzIChEZWdyZWVzIE9mIEZyZWVkb20pLCAxIEF4aXMgdGhhdCBjYW4gZWl0aGVyIHR3aXN0IG9yIHN3aW5nIGlzIGEgZGVncmVlIG9mIGZyZWVkb20uXHJcbiAgICAgKiBBIGpvaW50IHR5cGljYWxseSBjb25zaXN0cyBvZiBhIG1vdG9yIHRoYXQgbGltaXRzIG1vdmVtZW50L3JvdGF0aW9uIG9yIGlzIGFjdGl2bHkgdHJ5aW5nIHRvIG1vdmUgdG8gYSBsaW1pdC4gQW5kIGEgc3ByaW5nIHdoaWNoIGRlZmluZXMgdGhlIHJpZ2lkaXR5LlxyXG4gICAgICogQGF1dGhvciBNYXJrbyBGZWhyZW5iYWNoLCBIRlUgMjAyMFxyXG4gICAgICovXHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIEpvaW50IGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIC8qKiByZWZlcnMgYmFjayB0byB0aGlzIGNsYXNzIGZyb20gYW55IHN1YmNsYXNzIGUuZy4gaW4gb3JkZXIgdG8gZmluZCBjb21wYXRpYmxlIG90aGVyIHJlc291cmNlcyovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGJhc2VDbGFzczogdHlwZW9mIEpvaW50ID0gSm9pbnQ7XHJcbiAgICAvKiogbGlzdCBvZiBhbGwgdGhlIHN1YmNsYXNzZXMgZGVyaXZlZCBmcm9tIHRoaXMgY2xhc3MsIGlmIHRoZXkgcmVnaXN0ZXJlZCBwcm9wZXJseSovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IHN1YmNsYXNzZXM6IHR5cGVvZiBKb2ludFtdID0gW107XHJcblxyXG4gICAgI2lkQm9keUFuY2hvcjogbnVtYmVyID0gMDtcclxuICAgICNpZEJvZHlUaWVkOiBudW1iZXIgPSAwO1xyXG4gICAgI2JvZHlBbmNob3I6IENvbXBvbmVudFJpZ2lkYm9keTtcclxuICAgICNib2R5VGllZDogQ29tcG9uZW50UmlnaWRib2R5O1xyXG5cclxuICAgICNjb25uZWN0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgICNhbmNob3I6IE9JTU8uVmVjMztcclxuICAgICNpbnRlcm5hbENvbGxpc2lvbjogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICAgICNicmVha0ZvcmNlOiBudW1iZXIgPSAwO1xyXG4gICAgI2JyZWFrVG9ycXVlOiBudW1iZXIgPSAwO1xyXG5cclxuICAgICNuYW1lQ2hpbGRUb0Nvbm5lY3Q6IHN0cmluZztcclxuXHJcblxyXG4gICAgLy8gcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IENvbXBvbmVudC5yZWdpc3RlclN1YmNsYXNzKENvbXBvbmVudEpvaW50KTtcclxuICAgIHByb3RlY3RlZCBzaW5nbGV0b246IGJvb2xlYW4gPSBmYWxzZTsgLy9NdWx0aXBsZSBqb2ludHMgY2FuIGJlIGF0dGFjaGVkIHRvIG9uZSBOb2RlXHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgam9pbnQ6IE9JTU8uSm9pbnQ7XHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgY29uZmlnOiBPSU1PLkpvaW50Q29uZmlnO1xyXG5cclxuXHJcbiAgICAvKiogQ3JlYXRlIGEgam9pbnQgY29ubmVjdGlvbiBiZXR3ZWVuIHRoZSB0d28gZ2l2ZW4gUmlnaWRib2R5Q29tcG9uZW50cy4gKi9cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfYm9keUFuY2hvcjogQ29tcG9uZW50UmlnaWRib2R5ID0gbnVsbCwgX2JvZHlUaWVkOiBDb21wb25lbnRSaWdpZGJvZHkgPSBudWxsKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuYm9keUFuY2hvciA9IF9ib2R5QW5jaG9yO1xyXG4gICAgICB0aGlzLmJvZHlUaWVkID0gX2JvZHlUaWVkO1xyXG5cclxuICAgICAgLypcclxuICAgICAgICBUZWxsIHRoZSBwaHlzaWNzIHRoYXQgdGhlcmUgaXMgYSBuZXcgam9pbnQgYW5kIG9uIHRoZSBwaHlzaWNzIHN0YXJ0IHRoZSBhY3R1YWwgam9pbnQgaXMgZmlyc3QgY3JlYXRlZC4gVmFsdWVzIGNhbiBiZSBzZXQgYnV0IHRoZVxyXG4gICAgICAgIGFjdHVhbCBjb25zdHJhaW50IGFpbid0IGV4aXN0ZW50IHVudGlsIHRoZSBnYW1lIHN0YXJ0c1xyXG4gICAgICAqL1xyXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuQ09NUE9ORU5UX0FERCwgdGhpcy5kaXJ0eVN0YXR1cyk7XHJcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5DT01QT05FTlRfUkVNT1ZFLCB0aGlzLnJlbW92ZUpvaW50KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyByZWdpc3RlclN1YmNsYXNzKF9zdWJjbGFzczogdHlwZW9mIEpvaW50KTogbnVtYmVyIHsgcmV0dXJuIEpvaW50LnN1YmNsYXNzZXMucHVzaChfc3ViY2xhc3MpIC0gMTsgfVxyXG5cclxuICAgIC8qKiBHZXQvU2V0IHRoZSBmaXJzdCBDb21wb25lbnRSaWdpZGJvZHkgb2YgdGhpcyBjb25uZWN0aW9uLiBJdCBzaG91bGQgYWx3YXlzIGJlIHRoZSBvbmUgdGhhdCB0aGlzIGNvbXBvbmVudCBpcyBhdHRhY2hlZCB0b28gaW4gdGhlIHNjZW5lVHJlZS4gKi9cclxuICAgIHB1YmxpYyBnZXQgYm9keUFuY2hvcigpOiBDb21wb25lbnRSaWdpZGJvZHkge1xyXG4gICAgICByZXR1cm4gdGhpcy4jYm9keUFuY2hvcjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IGJvZHlBbmNob3IoX2NtcFJCOiBDb21wb25lbnRSaWdpZGJvZHkpIHtcclxuICAgICAgdGhpcy4jaWRCb2R5QW5jaG9yID0gX2NtcFJCICE9IG51bGwgPyBfY21wUkIuaWQgOiAtMTtcclxuICAgICAgdGhpcy4jYm9keUFuY2hvciA9IF9jbXBSQjtcclxuICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XHJcbiAgICAgIHRoaXMuZGlydHlTdGF0dXMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogR2V0L1NldCB0aGUgc2Vjb25kIENvbXBvbmVudFJpZ2lkYm9keSBvZiB0aGlzIGNvbm5lY3Rpb24uICovXHJcbiAgICBwdWJsaWMgZ2V0IGJvZHlUaWVkKCk6IENvbXBvbmVudFJpZ2lkYm9keSB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNib2R5VGllZDtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgYm9keVRpZWQoX2NtcFJCOiBDb21wb25lbnRSaWdpZGJvZHkpIHtcclxuICAgICAgdGhpcy4jaWRCb2R5VGllZCA9IF9jbXBSQiAhPSBudWxsID8gX2NtcFJCLmlkIDogLTE7XHJcbiAgICAgIHRoaXMuI2JvZHlUaWVkID0gX2NtcFJCO1xyXG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgdGhpcy5kaXJ0eVN0YXR1cygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGV4YWN0IHBvc2l0aW9uIHdoZXJlIHRoZSB0d28ge0BsaW5rIE5vZGV9cyBhcmUgY29ubmVjdGVkLiBXaGVuIGNoYW5nZWQgYWZ0ZXIgaW5pdGlhbGl6YXRpb24gdGhlIGpvaW50IG5lZWRzIHRvIGJlIHJlY29ubmVjdGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGFuY2hvcigpOiBWZWN0b3IzIHtcclxuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKHRoaXMuI2FuY2hvci54LCB0aGlzLiNhbmNob3IueSwgdGhpcy4jYW5jaG9yLnopO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBhbmNob3IoX3ZhbHVlOiBWZWN0b3IzKSB7XHJcbiAgICAgIHRoaXMuI2FuY2hvciA9IG5ldyBPSU1PLlZlYzMoX3ZhbHVlLngsIF92YWx1ZS55LCBfdmFsdWUueik7XHJcbiAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xyXG4gICAgICB0aGlzLmRpcnR5U3RhdHVzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYW1vdW50IG9mIGZvcmNlIG5lZWRlZCB0byBicmVhayB0aGUgSk9JTlQsIHdoaWxlIHJvdGF0aW5nLCBpbiBOZXd0b24uIDAgZXF1YWxzIHVuYnJlYWthYmxlIChkZWZhdWx0KSBcclxuICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGJyZWFrVG9ycXVlKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNicmVha1RvcnF1ZTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgYnJlYWtUb3JxdWUoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jYnJlYWtUb3JxdWUgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuc2V0QnJlYWtUb3JxdWUodGhpcy4jYnJlYWtUb3JxdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGFtb3VudCBvZiBmb3JjZSBuZWVkZWQgdG8gYnJlYWsgdGhlIEpPSU5ULCBpbiBOZXd0b24uIDAgZXF1YWxzIHVuYnJlYWthYmxlIChkZWZhdWx0KSBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBicmVha0ZvcmNlKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNicmVha0ZvcmNlO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBicmVha0ZvcmNlKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI2JyZWFrRm9yY2UgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuc2V0QnJlYWtGb3JjZSh0aGlzLiNicmVha0ZvcmNlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgKiBJZiB0aGUgdHdvIGNvbm5lY3RlZCBSaWdpZEJvZGllcyBjb2xsaWRlIHdpdGggZWF0aCBvdGhlci4gKERlZmF1bHQgPSBmYWxzZSlcclxuICAgICAgKiBPbiBhIHdlbGRpbmcgam9pbnQgdGhlIGNvbm5lY3RlZCBib2RpZXMgc2hvdWxkIG5vdCBiZSBjb2xsaWRpbmcgd2l0aCBlYWNoIG90aGVyLFxyXG4gICAgICAqIGZvciBiZXN0IHJlc3VsdHNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBpbnRlcm5hbENvbGxpc2lvbigpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI2ludGVybmFsQ29sbGlzaW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBpbnRlcm5hbENvbGxpc2lvbihfdmFsdWU6IGJvb2xlYW4pIHtcclxuICAgICAgdGhpcy4jaW50ZXJuYWxDb2xsaXNpb24gPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuc2V0QWxsb3dDb2xsaXNpb24odGhpcy4jaW50ZXJuYWxDb2xsaXNpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBjb25uZWN0Q2hpbGQoX25hbWU6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICB0aGlzLiNuYW1lQ2hpbGRUb0Nvbm5lY3QgPSBfbmFtZTtcclxuICAgICAgaWYgKCF0aGlzLm5vZGUpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgbGV0IGNoaWxkcmVuOiBOb2RlW10gPSB0aGlzLm5vZGUuZ2V0Q2hpbGRyZW5CeU5hbWUoX25hbWUpO1xyXG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09IDEpXHJcbiAgICAgICAgdGhpcy5jb25uZWN0Tm9kZShjaGlsZHJlbi5wb3AoKSk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBEZWJ1Zy53YXJuKGAke3RoaXMuY29uc3RydWN0b3IubmFtZX0gYXQgJHt0aGlzLm5vZGUubmFtZX0gZmFpbHMgdG8gY29ubmVjdCBjaGlsZCB3aXRoIG5vbiBleGlzdGVudCBvciBhbWJpZ291cyBuYW1lICR7X25hbWV9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGNvbm5lY3ROb2RlKF9ub2RlOiBOb2RlKTogdm9pZCB7XHJcbiAgICAgIGlmICghX25vZGUgfHwgIXRoaXMubm9kZSlcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBEZWJ1Zy5mdWRnZShgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9IGNvbm5lY3RlZCAke3RoaXMubm9kZS5uYW1lfSBhbmQgJHtfbm9kZS5uYW1lfWApO1xyXG5cclxuICAgICAgbGV0IGNvbm5lY3RCb2R5OiBDb21wb25lbnRSaWdpZGJvZHkgPSBfbm9kZS5nZXRDb21wb25lbnQoQ29tcG9uZW50UmlnaWRib2R5KTtcclxuICAgICAgbGV0IHRoaXNCb2R5OiBDb21wb25lbnRSaWdpZGJvZHkgPSB0aGlzLm5vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudFJpZ2lkYm9keSk7XHJcblxyXG4gICAgICBpZiAoIWNvbm5lY3RCb2R5IHx8ICF0aGlzQm9keSkge1xyXG4gICAgICAgIERlYnVnLndhcm4oYCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSBhdCAke3RoaXMubm9kZS5uYW1lfSBmYWlscyBkdWUgdG8gbWlzc2luZyByaWdpZGJvZGllcyBvbiAke3RoaXMubm9kZS5uYW1lfSBvciAke19ub2RlLm5hbWV9YCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmJvZHlBbmNob3IgPSB0aGlzQm9keTtcclxuICAgICAgdGhpcy5ib2R5VGllZCA9IGNvbm5lY3RCb2R5O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBDaGVjayBpZiBjb25uZWN0aW9uIGlzIGRpcnR5LCBzbyB3aGVuIGVpdGhlciByYiBpcyBjaGFuZ2VkIGRpc2Nvbm5lY3QgYW5kIHJlY29ubmVjdC4gSW50ZXJuYWxseSB1c2VkIG5vIHVzZXIgaW50ZXJhY3Rpb24gbmVlZGVkLiAqL1xyXG4gICAgcHVibGljIGlzQ29ubmVjdGVkKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy4jY29ubmVjdGVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6aW5nIGFuZCBjb25uZWN0aW5nIHRoZSB0d28gcmlnaWRib2RpZXMgd2l0aCB0aGUgY29uZmlndXJlZCBqb2ludCBwcm9wZXJ0aWVzXHJcbiAgICAgKiBpcyBhdXRvbWF0aWNhbGx5IGNhbGxlZCBieSB0aGUgcGh5c2ljcyBzeXN0ZW0uIE5vIHVzZXIgaW50ZXJhY3Rpb24gbmVlZGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29ubmVjdCgpOiB2b2lkIHtcclxuICAgICAgaWYgKHRoaXMuI2Nvbm5lY3RlZCA9PSBmYWxzZSkge1xyXG4gICAgICAgIGlmICh0aGlzLiNpZEJvZHlBbmNob3IgPT0gLTEgfHwgdGhpcy4jaWRCb2R5VGllZCA9PSAtMSkge1xyXG4gICAgICAgICAgaWYgKHRoaXMuI25hbWVDaGlsZFRvQ29ubmVjdClcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0Q2hpbGQodGhpcy4jbmFtZUNoaWxkVG9Db25uZWN0KTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY29uc3RydWN0Sm9pbnQoKTtcclxuICAgICAgICB0aGlzLiNjb25uZWN0ZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuYWRkSm9pbnQoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGlzY29ubmVjdGluZyB0aGUgdHdvIHJpZ2lkYm9kaWVzIGFuZCByZW1vdmluZyB0aGVtIGZyb20gdGhlIHBoeXNpY3Mgc3lzdGVtLFxyXG4gICAgICogaXMgYXV0b21hdGljYWxseSBjYWxsZWQgYnkgdGhlIHBoeXNpY3Mgc3lzdGVtLiBObyB1c2VyIGludGVyYWN0aW9uIG5lZWRlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGRpc2Nvbm5lY3QoKTogdm9pZCB7XHJcbiAgICAgIGlmICh0aGlzLiNjb25uZWN0ZWQgPT0gdHJ1ZSkge1xyXG4gICAgICAgIHRoaXMucmVtb3ZlSm9pbnQoKTtcclxuICAgICAgICB0aGlzLiNjb25uZWN0ZWQgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgb3JpZ2luYWwgSm9pbnQgdXNlZCBieSB0aGUgcGh5c2ljcyBlbmdpbmUuIFVzZWQgaW50ZXJuYWxseSBubyB1c2VyIGludGVyYWN0aW9uIG5lZWRlZC5cclxuICAgICAqIE9ubHkgdG8gYmUgdXNlZCB3aGVuIGZ1bmN0aW9uYWxpdHkgdGhhdCBpcyBub3QgYWRkZWQgd2l0aGluIEZ1ZGdlIGlzIG5lZWRlZC5cclxuICAgICovXHJcbiAgICBwdWJsaWMgZ2V0T2ltb0pvaW50KCk6IE9JTU8uSm9pbnQge1xyXG4gICAgICByZXR1cm4gdGhpcy5qb2ludDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHRoaXMuI2dldE11dGF0b3IoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5hbmNob3IgPSB0aGlzLmFuY2hvci5zZXJpYWxpemUoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICB0aGlzLmFuY2hvciA9IGF3YWl0IG5ldyBWZWN0b3IzKCkuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24uYW5jaG9yKTtcclxuICAgICAgdGhpcy4jbXV0YXRlKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xyXG4gICAgICB0aGlzLmNvbm5lY3RDaGlsZChfc2VyaWFsaXphdGlvbi5uYW1lQ2hpbGRUb0Nvbm5lY3QpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSBzdXBlci5nZXRNdXRhdG9yKHRydWUpO1xyXG4gICAgICBPYmplY3QuYXNzaWduKG11dGF0b3IsIHRoaXMuI2dldE11dGF0b3IoKSk7XHJcbiAgICAgIG11dGF0b3IuYW5jaG9yID0gdGhpcy5hbmNob3IuZ2V0TXV0YXRvcigpO1xyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIHRoaXMuYW5jaG9yID0gbmV3IFZlY3RvcjMoLi4uPG51bWJlcltdPihPYmplY3QudmFsdWVzKF9tdXRhdG9yLmFuY2hvcikpKTtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLmFuY2hvcjtcclxuICAgICAgdGhpcy5jb25uZWN0Q2hpbGQoX211dGF0b3IubmFtZUNoaWxkVG9Db25uZWN0KTtcclxuICAgICAgdGhpcy4jbXV0YXRlKF9tdXRhdG9yKTtcclxuICAgICAgdGhpcy5kZWxldGVGcm9tTXV0YXRvcihfbXV0YXRvciwgdGhpcy4jZ2V0TXV0YXRvcigpKTtcclxuICAgICAgc3VwZXIubXV0YXRlKF9tdXRhdG9yKTtcclxuICAgIH1cclxuXHJcbiAgICAjZ2V0TXV0YXRvciA9ICgpOiBNdXRhdG9yID0+IHtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSB7XHJcbiAgICAgICAgbmFtZUNoaWxkVG9Db25uZWN0OiB0aGlzLiNuYW1lQ2hpbGRUb0Nvbm5lY3QsXHJcbiAgICAgICAgaW50ZXJuYWxDb2xsaXNpb246IHRoaXMuI2ludGVybmFsQ29sbGlzaW9uLFxyXG4gICAgICAgIGJyZWFrRm9yY2U6IHRoaXMuI2JyZWFrRm9yY2UsXHJcbiAgICAgICAgYnJlYWtUb3JxdWU6IHRoaXMuI2JyZWFrVG9ycXVlXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfVxyXG5cclxuICAgICNtdXRhdGUgPSAoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkID0+IHtcclxuICAgICAgdGhpcy5pbnRlcm5hbENvbGxpc2lvbiA9IF9tdXRhdG9yLmludGVybmFsQ29sbGlzaW9uO1xyXG4gICAgICB0aGlzLmJyZWFrRm9yY2UgPSBfbXV0YXRvci5icmVha0ZvcmNlO1xyXG4gICAgICB0aGlzLmJyZWFrVG9ycXVlID0gX211dGF0b3IuYnJlYWtUb3JxdWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLnNwcmluZ0RhbXBlcjtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLmpvaW50O1xyXG4gICAgICBkZWxldGUgX211dGF0b3IubW90b3I7XHJcbiAgICAgIHN1cGVyLnJlZHVjZU11dGF0b3IoX211dGF0b3IpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUZWxsIHRoZSBGdWRnZVBoeXNpY3Mgc3lzdGVtIHRoYXQgdGhpcyBqb2ludCBuZWVkcyB0byBiZSBoYW5kbGVkIGluIHRoZSBuZXh0IGZyYW1lLiAqL1xyXG4gICAgcHJvdGVjdGVkIGRpcnR5U3RhdHVzKCk6IHZvaWQge1xyXG4gICAgICBQaHlzaWNzLmNoYW5nZUpvaW50U3RhdHVzKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBhZGRKb2ludCgpOiB2b2lkIHtcclxuICAgICAgUGh5c2ljcy5hZGRKb2ludCh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVtb3ZlSm9pbnQoKTogdm9pZCB7XHJcbiAgICAgIFBoeXNpY3MucmVtb3ZlSm9pbnQodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGNvbnN0cnVjdEpvaW50KC4uLl9jb25maWdQYXJhbXM6IE9iamVjdFtdKTogdm9pZCB7XHJcbiAgICAgIGxldCBwb3NCb2R5QW5jaG9yOiBWZWN0b3IzID0gdGhpcy5ib2R5QW5jaG9yLm5vZGUubXR4V29ybGQudHJhbnNsYXRpb247IC8vU2V0dGluZyB0aGUgYW5jaG9yIHBvc2l0aW9uIGxvY2FsbHkgZnJvbSB0aGUgZmlyc3QgcmlnaWRib2R5XHJcbiAgICAgIGxldCB3b3JsZEFuY2hvcjogT0lNTy5WZWMzID0gbmV3IE9JTU8uVmVjMyhwb3NCb2R5QW5jaG9yLnggKyB0aGlzLiNhbmNob3IueCwgcG9zQm9keUFuY2hvci55ICsgdGhpcy4jYW5jaG9yLnksIHBvc0JvZHlBbmNob3IueiArIHRoaXMuI2FuY2hvci56KTtcclxuXHJcbiAgICAgIC8vIEB0cy1pZ25vcmUgICAgLy8gdW5mb3J0dW5hdGVseSwgbWV0aG9kIGluaXQgaXMgbm90IGEgbWVtYmVyIG9mIHRoZSBiYXNlIGNsYXNzIE9JTU8uSm9pbnRDb25maWdcclxuICAgICAgdGhpcy5jb25maWcuaW5pdCh0aGlzLiNib2R5QW5jaG9yLmdldE9pbW9SaWdpZGJvZHkoKSwgdGhpcy4jYm9keVRpZWQuZ2V0T2ltb1JpZ2lkYm9keSgpLCB3b3JsZEFuY2hvciwgLi4uX2NvbmZpZ1BhcmFtcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGNvbmZpZ3VyZUpvaW50KCk6IHZvaWQge1xyXG4gICAgICB0aGlzLmpvaW50LnNldEJyZWFrRm9yY2UodGhpcy5icmVha0ZvcmNlKTtcclxuICAgICAgdGhpcy5qb2ludC5zZXRCcmVha1RvcnF1ZSh0aGlzLmJyZWFrVG9ycXVlKTtcclxuICAgICAgdGhpcy5qb2ludC5zZXRBbGxvd0NvbGxpc2lvbih0aGlzLiNpbnRlcm5hbENvbGxpc2lvbik7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGRlbGV0ZUZyb21NdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yLCBfZGVsZXRlOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIGZvciAobGV0IGtleSBpbiBfZGVsZXRlKVxyXG4gICAgICAgIGRlbGV0ZSBfbXV0YXRvcltrZXldO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAgICogQmFzZSBjbGFzcyBmb3Igam9pbnRzIG9wZXJhdGluZyB3aXRoIGV4YWN0bHkgb25lIGF4aXNcclxuICAgICAqIEBhdXRob3IgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgSm9pbnRBeGlhbCBleHRlbmRzIEpvaW50IHtcclxuXHJcbiAgICAvL0ludGVybmFsIFZhcmlhYmxlc1xyXG5cclxuICAgICNtYXhNb3RvcjogbnVtYmVyID0gMTA7XHJcbiAgICAjbWluTW90b3I6IG51bWJlciA9IC0xMDtcclxuICAgICNtb3RvclNwZWVkOiBudW1iZXIgPSAwO1xyXG4gICAgI2F4aXM6IE9JTU8uVmVjMztcclxuICAgICNzcHJpbmdGcmVxdWVuY3k6IG51bWJlciA9IDA7XHJcbiAgICAjc3ByaW5nRGFtcGluZzogbnVtYmVyID0gMDtcclxuXHJcbiAgICBwcm90ZWN0ZWQgc3ByaW5nRGFtcGVyOiBPSU1PLlNwcmluZ0RhbXBlcjtcclxuXHJcblxyXG4gICAgLyoqIENyZWF0aW5nIGEgY3lsaW5kcmljYWwgam9pbnQgYmV0d2VlbiB0d28gQ29tcG9uZW50UmlnaWRib2RpZXMgbW92aW5nIG9uIG9uZSBheGlzIGFuZCByb3RhdGluZyBhcm91bmQgYW5vdGhlciBib3VuZCBvbiBhIGxvY2FsIGFuY2hvcnBvaW50LiAqL1xyXG4gICAgY29uc3RydWN0b3IoX2JvZHlBbmNob3I6IENvbXBvbmVudFJpZ2lkYm9keSA9IG51bGwsIF9ib2R5VGllZDogQ29tcG9uZW50UmlnaWRib2R5ID0gbnVsbCwgX2F4aXM6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygwLCAxLCAwKSwgX2xvY2FsQW5jaG9yOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMCwgMCwgMCkpIHtcclxuICAgICAgc3VwZXIoX2JvZHlBbmNob3IsIF9ib2R5VGllZCk7XHJcbiAgICAgIHRoaXMuYXhpcyA9IF9heGlzO1xyXG4gICAgICB0aGlzLmFuY2hvciA9IF9sb2NhbEFuY2hvcjtcclxuICAgICAgdGhpcy5taW5Nb3RvciA9IC0xMDtcclxuICAgICAgdGhpcy5tYXhNb3RvciA9IDEwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBHZXQvU2V0IHRyYW5zZm9yIG9mIGZ1ZGdlIHByb3BlcnRpZXMgdG8gdGhlIHBoeXNpY3MgZW5naW5lXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBheGlzIGNvbm5lY3RpbmcgdGhlIHRoZSB0d28ge0BsaW5rIE5vZGV9cyBlLmcuIFZlY3RvcjMoMCwxLDApIHRvIGhhdmUgYSB1cHdhcmQgY29ubmVjdGlvbi5cclxuICAgICAqICBXaGVuIGNoYW5nZWQgYWZ0ZXIgaW5pdGlhbGl6YXRpb24gdGhlIGpvaW50IG5lZWRzIHRvIGJlIHJlY29ubmVjdGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGF4aXMoKTogVmVjdG9yMyB7XHJcbiAgICAgIHJldHVybiBuZXcgVmVjdG9yMyh0aGlzLiNheGlzLngsIHRoaXMuI2F4aXMueSwgdGhpcy4jYXhpcy56KTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgYXhpcyhfdmFsdWU6IFZlY3RvcjMpIHtcclxuICAgICAgdGhpcy4jYXhpcyA9IG5ldyBPSU1PLlZlYzMoX3ZhbHVlLngsIF92YWx1ZS55LCBfdmFsdWUueik7XHJcbiAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xyXG4gICAgICB0aGlzLmRpcnR5U3RhdHVzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICogVGhlIFVwcGVyIExpbWl0IG9mIG1vdmVtZW50IGFsb25nIHRoZSBheGlzIG9mIHRoaXMgam9pbnQuIFRoZSBsaW1pdGVyIGlzIGRpc2FibGUgaWYgbG93ZXJMaW1pdCA+IHVwcGVyTGltaXQuIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG1heE1vdG9yKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNtYXhNb3RvcjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IG1heE1vdG9yKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI21heE1vdG9yID0gX3ZhbHVlO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgICg8T0lNTy5QcmlzbWF0aWNKb2ludD48dW5rbm93bj50aGlzLmpvaW50KS5nZXRMaW1pdE1vdG9yKCkudXBwZXJMaW1pdCA9IF92YWx1ZTtcclxuICAgICAgfSBjYXRjaCAoX2U6IHVua25vd24pIHsgLyogKi8gfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIFRoZSBMb3dlciBMaW1pdCBvZiBtb3ZlbWVudCBhbG9uZyB0aGUgYXhpcyBvZiB0aGlzIGpvaW50LiBUaGUgbGltaXRlciBpcyBkaXNhYmxlIGlmIGxvd2VyTGltaXQgPiB1cHBlckxpbWl0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG1pbk1vdG9yKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNtaW5Nb3RvcjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgbWluTW90b3IoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jbWluTW90b3IgPSBfdmFsdWU7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgKDxPSU1PLlByaXNtYXRpY0pvaW50Pjx1bmtub3duPnRoaXMuam9pbnQpLmdldExpbWl0TW90b3IoKS5sb3dlckxpbWl0ID0gX3ZhbHVlO1xyXG4gICAgICB9IGNhdGNoIChfZTogdW5rbm93bikgeyAvKiAqLyB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZGFtcGluZyBvZiB0aGUgc3ByaW5nLiAxIGVxdWFscyBjb21wbGV0bHkgZGFtcGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHNwcmluZ0RhbXBpbmcoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3NwcmluZ0RhbXBpbmc7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHNwcmluZ0RhbXBpbmcoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jc3ByaW5nRGFtcGluZyA9IF92YWx1ZTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAoPE9JTU8uUHJpc21hdGljSm9pbnQ+PHVua25vd24+dGhpcy5qb2ludCkuZ2V0U3ByaW5nRGFtcGVyKCkuZGFtcGluZ1JhdGlvID0gX3ZhbHVlO1xyXG4gICAgICB9IGNhdGNoIChfZTogdW5rbm93bikgeyAvKiAqLyB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICogVGhlIHRhcmdldCBzcGVlZCBvZiB0aGUgbW90b3IgaW4gbS9zLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG1vdG9yU3BlZWQoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI21vdG9yU3BlZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldCBtb3RvclNwZWVkKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI21vdG9yU3BlZWQgPSBfdmFsdWU7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgKDxPSU1PLlByaXNtYXRpY0pvaW50PnRoaXMuam9pbnQpLmdldExpbWl0TW90b3IoKS5tb3RvclNwZWVkID0gX3ZhbHVlO1xyXG4gICAgICB9IGNhdGNoIChfZTogdW5rbm93bikgeyAvKiAqLyB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZnJlcXVlbmN5IG9mIHRoZSBzcHJpbmcgaW4gSHouIEF0IDAgdGhlIHNwcmluZyBpcyByaWdpZCwgZXF1YWxzIG5vIHNwcmluZy4gVGhlIHNtYWxsZXIgdGhlIHZhbHVlIHRoZSBsZXNzIHJlc3RyaWN0aXZlIGlzIHRoZSBzcHJpbmcuXHJcbiAgICAqL1xyXG4gICAgcHVibGljIGdldCBzcHJpbmdGcmVxdWVuY3koKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3NwcmluZ0ZyZXF1ZW5jeTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgc3ByaW5nRnJlcXVlbmN5KF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI3NwcmluZ0ZyZXF1ZW5jeSA9IF92YWx1ZTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAoPE9JTU8uUHJpc21hdGljSm9pbnQ+dGhpcy5qb2ludCkuZ2V0U3ByaW5nRGFtcGVyKCkuZnJlcXVlbmN5ID0gX3ZhbHVlO1xyXG4gICAgICB9IGNhdGNoIChfZTogdW5rbm93bikgeyAvKiAqLyB9XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gU2F2aW5nL0xvYWRpbmdcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gdGhpcy4jZ2V0TXV0YXRvcigpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLmF4aXMgPSB0aGlzLmF4aXMuc2VyaWFsaXplKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgdGhpcy5heGlzID0gYXdhaXQgbmV3IFZlY3RvcjMoKS5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5heGlzKTtcclxuICAgICAgdGhpcy4jbXV0YXRlKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIHRoaXMuYXhpcyA9IG5ldyBWZWN0b3IzKC4uLjxudW1iZXJbXT4oT2JqZWN0LnZhbHVlcyhfbXV0YXRvci5heGlzKSkpO1xyXG4gICAgICBkZWxldGUgX211dGF0b3IuYXhpcztcclxuICAgICAgdGhpcy4jbXV0YXRlKF9tdXRhdG9yKTtcclxuICAgICAgdGhpcy5kZWxldGVGcm9tTXV0YXRvcihfbXV0YXRvciwgdGhpcy4jZ2V0TXV0YXRvcigpKTtcclxuICAgICAgc3VwZXIubXV0YXRlKF9tdXRhdG9yKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSBzdXBlci5nZXRNdXRhdG9yKCk7XHJcbiAgICAgIG11dGF0b3IuYXhpcyA9IHRoaXMuYXhpcy5nZXRNdXRhdG9yKCk7XHJcbiAgICAgIE9iamVjdC5hc3NpZ24obXV0YXRvciwgdGhpcy4jZ2V0TXV0YXRvcigpKTtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgI2dldE11dGF0b3IgPSAoKTogTXV0YXRvciA9PiB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0ge1xyXG4gICAgICAgIHNwcmluZ0RhbXBpbmc6IHRoaXMuI3NwcmluZ0RhbXBpbmcsXHJcbiAgICAgICAgc3ByaW5nRnJlcXVlbmN5OiB0aGlzLiNzcHJpbmdGcmVxdWVuY3ksXHJcbiAgICAgICAgbWF4TW90b3I6IHRoaXMuI21heE1vdG9yLFxyXG4gICAgICAgIG1pbk1vdG9yOiB0aGlzLiNtaW5Nb3RvcixcclxuICAgICAgICBtb3RvclNwZWVkOiB0aGlzLiNtb3RvclNwZWVkXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfVxyXG4gICAgI211dGF0ZSA9IChfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQgPT4ge1xyXG4gICAgICB0aGlzLnNwcmluZ0RhbXBpbmcgPSBfbXV0YXRvci5zcHJpbmdEYW1waW5nO1xyXG4gICAgICB0aGlzLnNwcmluZ0ZyZXF1ZW5jeSA9IF9tdXRhdG9yLnNwcmluZ0ZyZXF1ZW5jeTtcclxuICAgICAgdGhpcy5tYXhNb3RvciA9IF9tdXRhdG9yLm1heE1vdG9yO1xyXG4gICAgICB0aGlzLm1pbk1vdG9yID0gX211dGF0b3IubWluTW90b3I7XHJcbiAgICAgIHRoaXMubW90b3JTcGVlZCA9IF9tdXRhdG9yLm1vdG9yU3BlZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgcHJvdGVjdGVkIGNvbnN0cnVjdEpvaW50KCk6IHZvaWQge1xyXG4gICAgICB0aGlzLnNwcmluZ0RhbXBlciA9IG5ldyBPSU1PLlNwcmluZ0RhbXBlcigpLnNldFNwcmluZyh0aGlzLiNzcHJpbmdGcmVxdWVuY3ksIHRoaXMuI3NwcmluZ0RhbXBpbmcpO1xyXG4gICAgICBzdXBlci5jb25zdHJ1Y3RKb2ludCh0aGlzLiNheGlzKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCIvLy8gPHJlZmVyZW5jZSBwYXRoPVwiRGVidWcvRGVidWdUYXJnZXQudHNcIi8+XHJcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJEZWJ1Zy9EZWJ1Zy50c1wiLz5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkV2ZW50L0V2ZW50LnRzXCIvPlxyXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiU2VyaWFsaXphdGlvbi9NdXRhYmxlLnRzXCIvPlxyXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiU2VyaWFsaXphdGlvbi9TZXJpYWxpemVyLnRzXCIvPiBcclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkNvbXBvbmVudC9Db21wb25lbnQudHNcIi8+XHJcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJSZWN5Y2xlL1JlY3ljYWJsZUFycmF5LnRzXCIvPlxyXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiUmVuZGVyL1JlbmRlcldlYkdMLnRzXCIvPlxyXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiUmVuZGVyL1JlbmRlckluamVjdG9yVGV4dHVyZS50c1wiLz5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkdyYXBoL05vZGUudHNcIi8+XHJcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJQaHlzaWNzL0hlbHBlcnNQaHlzaWNzLnRzXCIvPlxyXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiUGh5c2ljcy9Kb2ludC50c1wiLz5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlBoeXNpY3MvSm9pbnRBeGlhbC50c1wiLz5cclxuXHJcbi8vZ2xvYmFsIGZ1bmN0aW9uc1xyXG5mdW5jdGlvbiBpZk51bWJlcihfY2hlY2s6IG51bWJlciwgX2RlZmF1bHQ6IG51bWJlcik6IG51bWJlciB7XHJcbiAgcmV0dXJuIHR5cGVvZiBfY2hlY2sgPT0gXCJ1bmRlZmluZWRcIiA/IF9kZWZhdWx0IDogX2NoZWNrO1xyXG59IiwiLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9UcmFuc2Zlci9NdXRhYmxlLnRzXCIvPlxyXG5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogSG9sZHMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIEFuaW1hdGlvblN0cnVjdHVyZSB0aGF0IHRoZSBBbmltYXRpb24gdXNlcyB0byBtYXAgdGhlIFNlcXVlbmNlcyB0byB0aGUgQXR0cmlidXRlcy5cclxuICAgKiBCdWlsdCBvdXQgb2YgYSB7QGxpbmsgTm9kZX0ncyBzZXJpYWxzYXRpb24sIGl0IHN3YXBzIHRoZSB2YWx1ZXMgd2l0aCB7QGxpbmsgQW5pbWF0aW9uU2VxdWVuY2V9cy5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIEFuaW1hdGlvblN0cnVjdHVyZSB7XHJcbiAgICBbYXR0cmlidXRlOiBzdHJpbmddOiBTZXJpYWxpemF0aW9uIHwgQW5pbWF0aW9uU2VxdWVuY2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAqIEFuIGFzc29jaWF0aXZlIGFycmF5IG1hcHBpbmcgbmFtZXMgb2YgbGFibGVzIHRvIHRpbWVzdGFtcHMuXHJcbiAgKiBMYWJlbHMgbmVlZCB0byBiZSB1bmlxdWUgcGVyIEFuaW1hdGlvbi5cclxuICAqIEBhdXRob3IgTHVrYXMgU2NoZXVlcmxlLCBIRlUsIDIwMTlcclxuICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgQW5pbWF0aW9uTGFiZWwge1xyXG4gICAgW25hbWU6IHN0cmluZ106IG51bWJlcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICogSG9sZHMgaW5mb3JtYXRpb24gYWJvdXQgQW5pbWF0aW9uIEV2ZW50IFRyaWdnZXJzXHJcbiAgKiBAYXV0aG9yIEx1a2FzIFNjaGV1ZXJsZSwgSEZVLCAyMDE5XHJcbiAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIEFuaW1hdGlvbkV2ZW50VHJpZ2dlciB7XHJcbiAgICBbbmFtZTogc3RyaW5nXTogbnVtYmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW50ZXJuYWxseSB1c2VkIHRvIGRpZmZlcmVudGlhdGUgYmV0d2VlbiB0aGUgdmFyaW91cyBnZW5lcmF0ZWQgc3RydWN0dXJlcyBhbmQgZXZlbnRzLlxyXG4gICAqIEBhdXRob3IgTHVrYXMgU2NoZXVlcmxlLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBlbnVtIEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRSB7XHJcbiAgICAvKipEZWZhdWx0OiBmb3J3YXJkLCBjb250aW5vdXMgKi9cclxuICAgIE5PUk1BTCxcclxuICAgIC8qKmJhY2t3YXJkLCBjb250aW5vdXMgKi9cclxuICAgIFJFVkVSU0UsXHJcbiAgICAvKipmb3J3YXJkLCByYXN0ZXJlZCAqL1xyXG4gICAgUkFTVEVSRUQsXHJcbiAgICAvKipiYWNrd2FyZCwgcmFzdGVyZWQgKi9cclxuICAgIFJBU1RFUkVEUkVWRVJTRVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSG9sZHMgZGlmZmVyZW50IHBsYXltb2RlcyB0aGUgYW5pbWF0aW9uIHVzZXMgdG8gcGxheSBiYWNrIGl0cyBhbmltYXRpb24uXHJcbiAgICogQGF1dGhvciBMdWthcyBTY2hldWVybGUsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBlbnVtIEFOSU1BVElPTl9QTEFZTU9ERSB7XHJcbiAgICAvKipQbGF5cyBhbmltYXRpb24gaW4gYSBsb29wOiBpdCByZXN0YXJ0cyBvbmNlIGl0IGhpdCB0aGUgZW5kLiovXHJcbiAgICBMT09QLFxyXG4gICAgLyoqUGxheXMgYW5pbWF0aW9uIG9uY2UgYW5kIHN0b3BzIGF0IHRoZSBsYXN0IGtleS9mcmFtZSovXHJcbiAgICBQTEFZT05DRSxcclxuICAgIC8qKlBsYXlzIGFuaW1hdGlvbiBvbmNlIGFuZCBzdG9wcyBvbiB0aGUgZmlyc3Qga2V5L2ZyYW1lICovXHJcbiAgICBQTEFZT05DRVNUT1BBRlRFUixcclxuICAgIC8qKlBsYXlzIGFuaW1hdGlvbiBsaWtlIExPT1AsIGJ1dCBiYWNrd2FyZHMuKi9cclxuICAgIFJFVkVSU0VMT09QLFxyXG4gICAgLyoqQ2F1c2VzIHRoZSBhbmltYXRpb24gbm90IHRvIHBsYXkgYXQgYWxsLiBVc2VmdWwgZm9yIGp1bXBpbmcgdG8gdmFyaW91cyBwb3NpdGlvbnMgaW4gdGhlIGFuaW1hdGlvbiB3aXRob3V0IHByb2NlZWRpbmcgaW4gdGhlIGFuaW1hdGlvbi4qL1xyXG4gICAgU1RPUFxyXG4gICAgLy9UT0RPOiBhZGQgYW4gSU5IRVJJVCBhbmQgYSBQSU5HUE9ORyBtb2RlXHJcbiAgfVxyXG5cclxuICBleHBvcnQgZW51bSBBTklNQVRJT05fUExBWUJBQ0sge1xyXG4gICAgLy9UT0RPOiBhZGQgYW4gaW4tZGVwdGggZGVzY3JpcHRpb24gb2Ygd2hhdCBoYXBwZW5zIHRvIHRoZSBhbmltYXRpb24gKGFuZCBldmVudHMpIGRlcGVuZGluZyBvbiB0aGUgUGxheWJhY2suIFVzZSBHcmFwaHMgdG8gZXhwbGFpbi5cclxuICAgIC8qKkNhbGN1bGF0ZXMgdGhlIHN0YXRlIG9mIHRoZSBhbmltYXRpb24gYXQgdGhlIGV4YWN0IHBvc2l0aW9uIG9mIHRpbWUuIElnbm9yZXMgRlBTIHZhbHVlIG9mIGFuaW1hdGlvbi4qL1xyXG4gICAgVElNRUJBU0VEX0NPTlRJTk9VUyxcclxuICAgIC8qKkxpbWl0cyB0aGUgY2FsY3VsYXRpb24gb2YgdGhlIHN0YXRlIG9mIHRoZSBhbmltYXRpb24gdG8gdGhlIEZQUyB2YWx1ZSBvZiB0aGUgYW5pbWF0aW9uLiBTa2lwcyBmcmFtZXMgaWYgbmVlZGVkLiovXHJcbiAgICBUSU1FQkFTRURfUkFTVEVSRURfVE9fRlBTLFxyXG4gICAgLyoqIEFkdmFuY2VzIHRoZSB0aW1lIGVhY2ggZnJhbWUgYWNjb3JkaW5nIHRvIHRoZSBGUFMgdmFsdWUgb2YgdGhlIGFuaW1hdGlvbiwgaWdub3JpbmcgdGhlIGFjdHVhbCBkdXJhdGlvbiBvZiB0aGUgZnJhbWVzLiBEb2Vzbid0IHNraXAgYW55IGZyYW1lcy4qL1xyXG4gICAgRlJBTUVCQVNFRFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQW5pbWF0aW9uIENsYXNzIHRvIGhvbGQgYWxsIHJlcXVpcmVkIE9iamVjdHMgdGhhdCBhcmUgcGFydCBvZiBhbiBBbmltYXRpb24uXHJcbiAgICogQWxzbyBob2xkcyBmdW5jdGlvbnMgdG8gcGxheSBzYWlkIEFuaW1hdGlvbi5cclxuICAgKiBDYW4gYmUgYWRkZWQgdG8gYSBOb2RlIGFuZCBwbGF5ZWQgdGhyb3VnaCB7QGxpbmsgQ29tcG9uZW50QW5pbWF0b3J9LlxyXG4gICAqIEBhdXRob3IgTHVrYXMgU2NoZXVlcmxlLCBIRlUsIDIwMTkgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBBbmltYXRpb24gZXh0ZW5kcyBNdXRhYmxlIGltcGxlbWVudHMgU2VyaWFsaXphYmxlUmVzb3VyY2Uge1xyXG4gICAgaWRSZXNvdXJjZTogc3RyaW5nO1xyXG4gICAgbmFtZTogc3RyaW5nO1xyXG4gICAgdG90YWxUaW1lOiBudW1iZXIgPSAwO1xyXG4gICAgbGFiZWxzOiBBbmltYXRpb25MYWJlbCA9IHt9O1xyXG4gICAgLy8gc3RlcHNQZXJTZWNvbmQ6IG51bWJlciA9IDEwO1xyXG4gICAgYW5pbWF0aW9uU3RydWN0dXJlOiBBbmltYXRpb25TdHJ1Y3R1cmU7XHJcbiAgICBldmVudHM6IEFuaW1hdGlvbkV2ZW50VHJpZ2dlciA9IHt9O1xyXG4gICAgcHJpdmF0ZSBmcmFtZXNQZXJTZWNvbmQ6IG51bWJlciA9IDYwO1xyXG5cclxuICAgIC8vIHByb2Nlc3NlZCBldmVudGxpc3QgYW5kIGFuaW1hdGlvbiBzdHJ1Y3V0cmVzIGZvciBwbGF5YmFjay5cclxuICAgIHByaXZhdGUgZXZlbnRzUHJvY2Vzc2VkOiBNYXA8QU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLCBBbmltYXRpb25FdmVudFRyaWdnZXI+ID0gbmV3IE1hcDxBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUsIEFuaW1hdGlvbkV2ZW50VHJpZ2dlcj4oKTtcclxuICAgIHByaXZhdGUgYW5pbWF0aW9uU3RydWN0dXJlc1Byb2Nlc3NlZDogTWFwPEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRSwgQW5pbWF0aW9uU3RydWN0dXJlPiA9IG5ldyBNYXA8QU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLCBBbmltYXRpb25TdHJ1Y3R1cmU+KCk7XHJcblxyXG4gICAgY29uc3RydWN0b3IoX25hbWU6IHN0cmluZywgX2FuaW1TdHJ1Y3R1cmU6IEFuaW1hdGlvblN0cnVjdHVyZSA9IHt9LCBfZnBzOiBudW1iZXIgPSA2MCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLm5hbWUgPSBfbmFtZTtcclxuICAgICAgdGhpcy5hbmltYXRpb25TdHJ1Y3R1cmUgPSBfYW5pbVN0cnVjdHVyZTtcclxuICAgICAgdGhpcy5hbmltYXRpb25TdHJ1Y3R1cmVzUHJvY2Vzc2VkLnNldChBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuTk9STUFMLCBfYW5pbVN0cnVjdHVyZSk7XHJcbiAgICAgIHRoaXMuZnJhbWVzUGVyU2Vjb25kID0gX2ZwcztcclxuICAgICAgdGhpcy5jYWxjdWxhdGVUb3RhbFRpbWUoKTtcclxuICAgICAgUHJvamVjdC5yZWdpc3Rlcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgZ2V0TGFiZWxzKCk6IEVudW1lcmF0b3Ige1xyXG4gICAgICAvL1RPRE86IHRoaXMgYWN0dWFsbHkgbmVlZHMgdGVzdGluZ1xyXG4gICAgICBsZXQgZW46IEVudW1lcmF0b3IgPSBuZXcgRW51bWVyYXRvcih0aGlzLmxhYmVscyk7XHJcbiAgICAgIHJldHVybiBlbjtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgZnBzKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmZyYW1lc1BlclNlY29uZDtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgZnBzKF9mcHM6IG51bWJlcikge1xyXG4gICAgICB0aGlzLmZyYW1lc1BlclNlY29uZCA9IF9mcHM7XHJcbiAgICAgIHRoaXMuZXZlbnRzUHJvY2Vzc2VkLmNsZWFyKCk7XHJcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RydWN0dXJlc1Byb2Nlc3NlZC5jbGVhcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIGEgbmV3IFwiTXV0YXRvclwiIHdpdGggdGhlIGluZm9ybWF0aW9uIHRvIGFwcGx5IHRvIHRoZSB7QGxpbmsgTm9kZX0gdGhlIHtAbGluayBDb21wb25lbnRBbmltYXRvcn0gaXMgYXR0YWNoZWQgdG8gd2l0aCB7QGxpbmsgTm9kZS5hcHBseUFuaW1hdGlvbn0uXHJcbiAgICAgKiBAcGFyYW0gX3RpbWUgVGhlIHRpbWUgYXQgd2hpY2ggdGhlIGFuaW1hdGlvbiBjdXJyZW50bHkgaXMgYXRcclxuICAgICAqIEBwYXJhbSBfZGlyZWN0aW9uIFRoZSBkaXJlY3Rpb24gaW4gd2hpY2ggdGhlIGFuaW1hdGlvbiBpcyBzdXBwb3NlZCB0byBiZSBwbGF5aW5nIGJhY2suID4wID09IGZvcndhcmQsIDAgPT0gc3RvcCwgPDAgPT0gYmFja3dhcmRzXHJcbiAgICAgKiBAcGFyYW0gX3BsYXliYWNrIFRoZSBwbGF5YmFja21vZGUgdGhlIGFuaW1hdGlvbiBpcyBzdXBwb3NlZCB0byBiZSBjYWxjdWxhdGVkIHdpdGguXHJcbiAgICAgKiBAcmV0dXJucyBhIFwiTXV0YXRvclwiIHRvIGFwcGx5LlxyXG4gICAgICovXHJcbiAgICBnZXRNdXRhdGVkKF90aW1lOiBudW1iZXIsIF9kaXJlY3Rpb246IG51bWJlciwgX3BsYXliYWNrOiBBTklNQVRJT05fUExBWUJBQ0spOiBNdXRhdG9yIHsgICAgIC8vVE9ETzogZmluZCBhIGJldHRlciBuYW1lIGZvciB0aGlzXHJcbiAgICAgIGxldCBtOiBNdXRhdG9yID0ge307XHJcbiAgICAgIGxldCBhbmltYXRpb25TdHJ1Y3R1cmU6IEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRTtcclxuXHJcbiAgICAgIGlmIChfcGxheWJhY2sgPT0gQU5JTUFUSU9OX1BMQVlCQUNLLlRJTUVCQVNFRF9DT05USU5PVVMpXHJcbiAgICAgICAgYW5pbWF0aW9uU3RydWN0dXJlID0gX2RpcmVjdGlvbiA8IDAgPyBBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuUkVWRVJTRSA6IEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5OT1JNQUw7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBhbmltYXRpb25TdHJ1Y3R1cmUgPSBfZGlyZWN0aW9uIDwgMCA/IEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5SQVNURVJFRFJFVkVSU0UgOiBBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuUkFTVEVSRUQ7XHJcblxyXG4gICAgICBtID0gdGhpcy50cmF2ZXJzZVN0cnVjdHVyZUZvck11dGF0b3IodGhpcy5nZXRQcm9jZXNzZWRBbmltYXRpb25TdHJ1Y3R1cmUoYW5pbWF0aW9uU3RydWN0dXJlKSwgX3RpbWUpO1xyXG4gICAgICByZXR1cm4gbTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIHRoZSBuYW1lcyBvZiB0aGUgZXZlbnRzIHRoZSB7QGxpbmsgQ29tcG9uZW50QW5pbWF0b3J9IG5lZWRzIHRvIGZpcmUgYmV0d2VlbiBfbWluIGFuZCBfbWF4LiBcclxuICAgICAqIEBwYXJhbSBfbWluIFRoZSBtaW5pbXVtIHRpbWUgKGluY2x1c2l2ZSkgdG8gY2hlY2sgYmV0d2VlblxyXG4gICAgICogQHBhcmFtIF9tYXggVGhlIG1heGltdW0gdGltZSAoZXhjbHVzaXZlKSB0byBjaGVjayBiZXR3ZWVuXHJcbiAgICAgKiBAcGFyYW0gX3BsYXliYWNrIFRoZSBwbGF5YmFjayBtb2RlIHRvIGNoZWNrIGluLiBIYXMgYW4gZWZmZWN0IG9uIHdoZW4gdGhlIEV2ZW50cyBhcmUgZmlyZWQuIFxyXG4gICAgICogQHBhcmFtIF9kaXJlY3Rpb24gVGhlIGRpcmVjdGlvbiB0aGUgYW5pbWF0aW9uIGlzIHN1cHBvc2VkIHRvIHJ1biBpbi4gPjAgPT0gZm9yd2FyZCwgMCA9PSBzdG9wLCA8MCA9PSBiYWNrd2FyZHNcclxuICAgICAqIEByZXR1cm5zIGEgbGlzdCBvZiBzdHJpbmdzIHdpdGggdGhlIG5hbWVzIG9mIHRoZSBjdXN0b20gZXZlbnRzIHRvIGZpcmUuXHJcbiAgICAgKi9cclxuICAgIGdldEV2ZW50c1RvRmlyZShfbWluOiBudW1iZXIsIF9tYXg6IG51bWJlciwgX3BsYXliYWNrOiBBTklNQVRJT05fUExBWUJBQ0ssIF9kaXJlY3Rpb246IG51bWJlcik6IHN0cmluZ1tdIHtcclxuICAgICAgbGV0IGV2ZW50TGlzdDogc3RyaW5nW10gPSBbXTtcclxuICAgICAgbGV0IG1pblNlY3Rpb246IG51bWJlciA9IE1hdGguZmxvb3IoX21pbiAvIHRoaXMudG90YWxUaW1lKTtcclxuICAgICAgbGV0IG1heFNlY3Rpb246IG51bWJlciA9IE1hdGguZmxvb3IoX21heCAvIHRoaXMudG90YWxUaW1lKTtcclxuICAgICAgX21pbiA9IF9taW4gJSB0aGlzLnRvdGFsVGltZTtcclxuICAgICAgX21heCA9IF9tYXggJSB0aGlzLnRvdGFsVGltZTtcclxuXHJcbiAgICAgIHdoaWxlIChtaW5TZWN0aW9uIDw9IG1heFNlY3Rpb24pIHtcclxuICAgICAgICBsZXQgZXZlbnRUcmlnZ2VyczogQW5pbWF0aW9uRXZlbnRUcmlnZ2VyID0gdGhpcy5nZXRDb3JyZWN0RXZlbnRMaXN0KF9kaXJlY3Rpb24sIF9wbGF5YmFjayk7XHJcbiAgICAgICAgaWYgKG1pblNlY3Rpb24gPT0gbWF4U2VjdGlvbikge1xyXG4gICAgICAgICAgZXZlbnRMaXN0ID0gZXZlbnRMaXN0LmNvbmNhdCh0aGlzLmNoZWNrRXZlbnRzQmV0d2VlbihldmVudFRyaWdnZXJzLCBfbWluLCBfbWF4KSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGV2ZW50TGlzdCA9IGV2ZW50TGlzdC5jb25jYXQodGhpcy5jaGVja0V2ZW50c0JldHdlZW4oZXZlbnRUcmlnZ2VycywgX21pbiwgdGhpcy50b3RhbFRpbWUpKTtcclxuICAgICAgICAgIF9taW4gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtaW5TZWN0aW9uKys7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBldmVudExpc3Q7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIEV2ZW50IHRvIHRoZSBMaXN0IG9mIGV2ZW50cy5cclxuICAgICAqIEBwYXJhbSBfbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgKG5lZWRzIHRvIGJlIHVuaXF1ZSBwZXIgQW5pbWF0aW9uKS5cclxuICAgICAqIEBwYXJhbSBfdGltZSBUaGUgdGltZXN0YW1wIG9mIHRoZSBldmVudCAoaW4gbWlsbGlzZWNvbmRzKS5cclxuICAgICAqL1xyXG4gICAgc2V0RXZlbnQoX25hbWU6IHN0cmluZywgX3RpbWU6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICB0aGlzLmV2ZW50c1tfbmFtZV0gPSBfdGltZTtcclxuICAgICAgdGhpcy5ldmVudHNQcm9jZXNzZWQuY2xlYXIoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhlIGV2ZW50IHdpdGggdGhlIGdpdmVuIG5hbWUgZnJvbSB0aGUgbGlzdCBvZiBldmVudHMuXHJcbiAgICAgKiBAcGFyYW0gX25hbWUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gcmVtb3ZlLlxyXG4gICAgICovXHJcbiAgICByZW1vdmVFdmVudChfbmFtZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgIGRlbGV0ZSB0aGlzLmV2ZW50c1tfbmFtZV07XHJcbiAgICAgIHRoaXMuZXZlbnRzUHJvY2Vzc2VkLmNsZWFyKCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogKFJlLSlDYWxjdWxhdGUgdGhlIHRvdGFsIHRpbWUgb2YgdGhlIEFuaW1hdGlvbi4gQ2FsY3VsYXRpb24taGVhdnksIHVzZSBvbmx5IGlmIGFjdHVhbGx5IG5lZWRlZC5cclxuICAgICAqL1xyXG4gICAgY2FsY3VsYXRlVG90YWxUaW1lKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLnRvdGFsVGltZSA9IDA7XHJcbiAgICAgIHRoaXMudHJhdmVyc2VTdHJ1Y3R1cmVGb3JUaW1lKHRoaXMuYW5pbWF0aW9uU3RydWN0dXJlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHRpbWUgdG8gdXNlIGZvciBhbmltYXRpb24gc2FtcGxpbmcgd2hlbiBhcHBseWluZyBhIHBsYXltb2RlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRNb2RhbFRpbWUoX3RpbWU6IG51bWJlciwgX3BsYXltb2RlOiBBTklNQVRJT05fUExBWU1PREUsIF90aW1lU3RvcDogbnVtYmVyID0gX3RpbWUpOiBudW1iZXIge1xyXG4gICAgICBzd2l0Y2ggKF9wbGF5bW9kZSkge1xyXG4gICAgICAgIGNhc2UgQU5JTUFUSU9OX1BMQVlNT0RFLlNUT1A6XHJcbiAgICAgICAgICAvLyByZXR1cm4gdGhpcy5sb2NhbFRpbWUuZ2V0T2Zmc2V0KCk7XHJcbiAgICAgICAgICByZXR1cm4gX3RpbWVTdG9wO1xyXG4gICAgICAgIGNhc2UgQU5JTUFUSU9OX1BMQVlNT0RFLlBMQVlPTkNFOlxyXG4gICAgICAgICAgaWYgKF90aW1lID49IHRoaXMudG90YWxUaW1lKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b3RhbFRpbWUgLSAwLjAxOyAgICAgLy9UT0RPOiB0aGlzIG1pZ2h0IGNhdXNlIHNvbWUgaXNzdWVzXHJcbiAgICAgICAgY2FzZSBBTklNQVRJT05fUExBWU1PREUuUExBWU9OQ0VTVE9QQUZURVI6XHJcbiAgICAgICAgICBpZiAoX3RpbWUgPj0gdGhpcy50b3RhbFRpbWUpXHJcbiAgICAgICAgICAgIC8vIFRPRE86IHJldHVybiBfdGltZVN0b3AgaW5zdGVhZD9cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG90YWxUaW1lICsgMC4wMTsgICAgIC8vVE9ETzogdGhpcyBtaWdodCBjYXVzZSBzb21lIGlzc3Vlc1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBfdGltZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgYW5kIHJldHVybnMgdGhlIGRpcmVjdGlvbiB0aGUgYW5pbWF0aW9uIHNob3VsZCBjdXJyZW50bHkgYmUgcGxheWluZyBpbi5cclxuICAgICAqIEBwYXJhbSBfdGltZSB0aGUgdGltZSBhdCB3aGljaCB0byBjYWxjdWxhdGUgdGhlIGRpcmVjdGlvblxyXG4gICAgICogQHJldHVybnMgMSBpZiBmb3J3YXJkLCAwIGlmIHN0b3AsIC0xIGlmIGJhY2t3YXJkc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY2FsY3VsYXRlRGlyZWN0aW9uKF90aW1lOiBudW1iZXIsIF9wbGF5bW9kZTogQU5JTUFUSU9OX1BMQVlNT0RFKTogbnVtYmVyIHtcclxuICAgICAgc3dpdGNoIChfcGxheW1vZGUpIHtcclxuICAgICAgICBjYXNlIEFOSU1BVElPTl9QTEFZTU9ERS5TVE9QOlxyXG4gICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgLy8gY2FzZSBBTklNQVRJT05fUExBWU1PREUuUElOR1BPTkc6XHJcbiAgICAgICAgLy8gICBpZiAoTWF0aC5mbG9vcihfdGltZSAvIHRoaXMuYW5pbWF0aW9uLnRvdGFsVGltZSkgJSAyID09IDApXHJcbiAgICAgICAgLy8gICAgIHJldHVybiAxO1xyXG4gICAgICAgIC8vICAgZWxzZVxyXG4gICAgICAgIC8vICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgY2FzZSBBTklNQVRJT05fUExBWU1PREUuUkVWRVJTRUxPT1A6XHJcbiAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgY2FzZSBBTklNQVRJT05fUExBWU1PREUuUExBWU9OQ0U6XHJcbiAgICAgICAgY2FzZSBBTklNQVRJT05fUExBWU1PREUuUExBWU9OQ0VTVE9QQUZURVI6XHJcbiAgICAgICAgICBpZiAoX3RpbWUgPj0gdGhpcy50b3RhbFRpbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIHRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgczogU2VyaWFsaXphdGlvbiA9IHtcclxuICAgICAgICBpZFJlc291cmNlOiB0aGlzLmlkUmVzb3VyY2UsXHJcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgIGxhYmVsczoge30sXHJcbiAgICAgICAgZXZlbnRzOiB7fSxcclxuICAgICAgICBmcHM6IHRoaXMuZnJhbWVzUGVyU2Vjb25kLFxyXG4gICAgICAgIC8vIHNwczogdGhpcy5zdGVwc1BlclNlY29uZFxyXG4gICAgICB9O1xyXG4gICAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMubGFiZWxzKSB7XHJcbiAgICAgICAgcy5sYWJlbHNbbmFtZV0gPSB0aGlzLmxhYmVsc1tuYW1lXTtcclxuICAgICAgfVxyXG4gICAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMuZXZlbnRzKSB7XHJcbiAgICAgICAgcy5ldmVudHNbbmFtZV0gPSB0aGlzLmV2ZW50c1tuYW1lXTtcclxuICAgICAgfVxyXG4gICAgICBzLmFuaW1hdGlvblN0cnVjdHVyZSA9IHRoaXMudHJhdmVyc2VTdHJ1Y3R1cmVGb3JTZXJpYWxpc2F0aW9uKHRoaXMuYW5pbWF0aW9uU3RydWN0dXJlKTtcclxuICAgICAgcmV0dXJuIHM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgdGhpcy5pZFJlc291cmNlID0gX3NlcmlhbGl6YXRpb24uaWRSZXNvdXJjZTtcclxuICAgICAgdGhpcy5uYW1lID0gX3NlcmlhbGl6YXRpb24ubmFtZTtcclxuICAgICAgdGhpcy5mcmFtZXNQZXJTZWNvbmQgPSBfc2VyaWFsaXphdGlvbi5mcHM7XHJcbiAgICAgIC8vIHRoaXMuc3RlcHNQZXJTZWNvbmQgPSBfc2VyaWFsaXphdGlvbi5zcHM7XHJcbiAgICAgIHRoaXMubGFiZWxzID0ge307XHJcbiAgICAgIGZvciAobGV0IG5hbWUgaW4gX3NlcmlhbGl6YXRpb24ubGFiZWxzKSB7XHJcbiAgICAgICAgdGhpcy5sYWJlbHNbbmFtZV0gPSBfc2VyaWFsaXphdGlvbi5sYWJlbHNbbmFtZV07XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5ldmVudHMgPSB7fTtcclxuICAgICAgZm9yIChsZXQgbmFtZSBpbiBfc2VyaWFsaXphdGlvbi5ldmVudHMpIHtcclxuICAgICAgICB0aGlzLmV2ZW50c1tuYW1lXSA9IF9zZXJpYWxpemF0aW9uLmV2ZW50c1tuYW1lXTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmV2ZW50c1Byb2Nlc3NlZCA9IG5ldyBNYXA8QU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLCBBbmltYXRpb25FdmVudFRyaWdnZXI+KCk7XHJcblxyXG4gICAgICB0aGlzLmFuaW1hdGlvblN0cnVjdHVyZSA9IGF3YWl0IHRoaXMudHJhdmVyc2VTdHJ1Y3R1cmVGb3JEZXNlcmlhbGlzYXRpb24oX3NlcmlhbGl6YXRpb24uYW5pbWF0aW9uU3RydWN0dXJlKTtcclxuXHJcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RydWN0dXJlc1Byb2Nlc3NlZCA9IG5ldyBNYXA8QU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLCBBbmltYXRpb25TdHJ1Y3R1cmU+KCk7XHJcblxyXG4gICAgICB0aGlzLmNhbGN1bGF0ZVRvdGFsVGltZSgpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xyXG4gICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemUoKTtcclxuICAgIH1cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci50b3RhbFRpbWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyYXZlcnNlcyBhbiBBbmltYXRpb25TdHJ1Y3R1cmUgYW5kIHJldHVybnMgdGhlIFNlcmlhbGl6YXRpb24gb2Ygc2FpZCBTdHJ1Y3R1cmUuXHJcbiAgICAgKiBAcGFyYW0gX3N0cnVjdHVyZSBUaGUgQW5pbWF0aW9uIFN0cnVjdHVyZSBhdCB0aGUgY3VycmVudCBsZXZlbCB0byB0cmFuc2Zvcm0gaW50byB0aGUgU2VyaWFsaXphdGlvbi5cclxuICAgICAqIEByZXR1cm5zIHRoZSBmaWxsZWQgU2VyaWFsaXphdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSB0cmF2ZXJzZVN0cnVjdHVyZUZvclNlcmlhbGlzYXRpb24oX3N0cnVjdHVyZTogQW5pbWF0aW9uU3RydWN0dXJlKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBuZXdTZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge307XHJcbiAgICAgIGZvciAobGV0IG4gaW4gX3N0cnVjdHVyZSkge1xyXG4gICAgICAgIGlmIChfc3RydWN0dXJlW25dIGluc3RhbmNlb2YgQW5pbWF0aW9uU2VxdWVuY2UpIHtcclxuICAgICAgICAgIG5ld1NlcmlhbGl6YXRpb25bbl0gPSBfc3RydWN0dXJlW25dLnNlcmlhbGl6ZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuZXdTZXJpYWxpemF0aW9uW25dID0gdGhpcy50cmF2ZXJzZVN0cnVjdHVyZUZvclNlcmlhbGlzYXRpb24oPEFuaW1hdGlvblN0cnVjdHVyZT5fc3RydWN0dXJlW25dKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG5ld1NlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyYXZlcnNlcyBhIFNlcmlhbGl6YXRpb24gdG8gY3JlYXRlIGEgbmV3IEFuaW1hdGlvblN0cnVjdHVyZS5cclxuICAgICAqIEBwYXJhbSBfc2VyaWFsaXphdGlvbiBUaGUgc2VyaWFsaXphdGlvbiB0byB0cmFuc2ZlciBpbnRvIGFuIEFuaW1hdGlvblN0cnVjdHVyZVxyXG4gICAgICogQHJldHVybnMgdGhlIG5ld2x5IGNyZWF0ZWQgQW5pbWF0aW9uU3RydWN0dXJlLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGFzeW5jIHRyYXZlcnNlU3RydWN0dXJlRm9yRGVzZXJpYWxpc2F0aW9uKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxBbmltYXRpb25TdHJ1Y3R1cmU+IHtcclxuICAgICAgbGV0IG5ld1N0cnVjdHVyZTogQW5pbWF0aW9uU3RydWN0dXJlID0ge307XHJcbiAgICAgIGZvciAobGV0IG4gaW4gX3NlcmlhbGl6YXRpb24pIHtcclxuICAgICAgICBpZiAoX3NlcmlhbGl6YXRpb25bbl0uYW5pbWF0aW9uU2VxdWVuY2UpIHtcclxuICAgICAgICAgIGxldCBhbmltU2VxOiBBbmltYXRpb25TZXF1ZW5jZSA9IG5ldyBBbmltYXRpb25TZXF1ZW5jZSgpO1xyXG4gICAgICAgICAgbmV3U3RydWN0dXJlW25dID0gYXdhaXQgYW5pbVNlcS5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltuXSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG5ld1N0cnVjdHVyZVtuXSA9IGF3YWl0IHRoaXMudHJhdmVyc2VTdHJ1Y3R1cmVGb3JEZXNlcmlhbGlzYXRpb24oX3NlcmlhbGl6YXRpb25bbl0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbmV3U3RydWN0dXJlO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kcyB0aGUgbGlzdCBvZiBldmVudHMgdG8gYmUgdXNlZCB3aXRoIHRoZXNlIHNldHRpbmdzLlxyXG4gICAgICogQHBhcmFtIF9kaXJlY3Rpb24gVGhlIGRpcmVjdGlvbiB0aGUgYW5pbWF0aW9uIGlzIHBsYXlpbmcgaW4uXHJcbiAgICAgKiBAcGFyYW0gX3BsYXliYWNrIFRoZSBwbGF5YmFja21vZGUgdGhlIGFuaW1hdGlvbiBpcyBwbGF5aW5nIGluLlxyXG4gICAgICogQHJldHVybnMgVGhlIGNvcnJlY3QgQW5pbWF0aW9uRXZlbnRUcmlnZ2VyIE9iamVjdCB0byB1c2VcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBnZXRDb3JyZWN0RXZlbnRMaXN0KF9kaXJlY3Rpb246IG51bWJlciwgX3BsYXliYWNrOiBBTklNQVRJT05fUExBWUJBQ0spOiBBbmltYXRpb25FdmVudFRyaWdnZXIge1xyXG4gICAgICBpZiAoX3BsYXliYWNrICE9IEFOSU1BVElPTl9QTEFZQkFDSy5GUkFNRUJBU0VEKSB7XHJcbiAgICAgICAgaWYgKF9kaXJlY3Rpb24gPj0gMCkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJvY2Vzc2VkRXZlbnRUcmlnZ2VyKEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5OT1JNQUwpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRQcm9jZXNzZWRFdmVudFRyaWdnZXIoQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlJFVkVSU0UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoX2RpcmVjdGlvbiA+PSAwKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRQcm9jZXNzZWRFdmVudFRyaWdnZXIoQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlJBU1RFUkVEKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJvY2Vzc2VkRXZlbnRUcmlnZ2VyKEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5SQVNURVJFRFJFVkVSU0UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhdmVyc2VzIGFuIEFuaW1hdGlvblN0cnVjdHVyZSB0byB0dXJuIGl0IGludG8gdGhlIFwiTXV0YXRvclwiIHRvIHJldHVybiB0byB0aGUgQ29tcG9uZW50LlxyXG4gICAgICogQHBhcmFtIF9zdHJ1Y3R1cmUgVGhlIHN0cmN1dHVyZSB0byB0cmF2ZXJzZVxyXG4gICAgICogQHBhcmFtIF90aW1lIHRoZSBwb2ludCBpbiB0aW1lIHRvIHdyaXRlIHRoZSBhbmltYXRpb24gbnVtYmVycyBpbnRvLlxyXG4gICAgICogQHJldHVybnMgVGhlIFwiTXV0YXRvclwiIGZpbGxlZCB3aXRoIHRoZSBjb3JyZWN0IHZhbHVlcyBhdCB0aGUgZ2l2ZW4gdGltZS4gXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdHJhdmVyc2VTdHJ1Y3R1cmVGb3JNdXRhdG9yKF9zdHJ1Y3R1cmU6IEFuaW1hdGlvblN0cnVjdHVyZSwgX3RpbWU6IG51bWJlcik6IE11dGF0b3Ige1xyXG4gICAgICBsZXQgbmV3TXV0YXRvcjogTXV0YXRvciA9IHt9O1xyXG4gICAgICBmb3IgKGxldCBuIGluIF9zdHJ1Y3R1cmUpIHtcclxuICAgICAgICBpZiAoX3N0cnVjdHVyZVtuXSBpbnN0YW5jZW9mIEFuaW1hdGlvblNlcXVlbmNlKSB7XHJcbiAgICAgICAgICBuZXdNdXRhdG9yW25dID0gKDxBbmltYXRpb25TZXF1ZW5jZT5fc3RydWN0dXJlW25dKS5ldmFsdWF0ZShfdGltZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG5ld011dGF0b3Jbbl0gPSB0aGlzLnRyYXZlcnNlU3RydWN0dXJlRm9yTXV0YXRvcig8QW5pbWF0aW9uU3RydWN0dXJlPl9zdHJ1Y3R1cmVbbl0sIF90aW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG5ld011dGF0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmF2ZXJzZXMgdGhlIGN1cnJlbnQgQW5pbWF0aW9uU3RyY3V0dXJlIHRvIGZpbmQgdGhlIHRvdGFsVGltZSBvZiB0aGlzIGFuaW1hdGlvbi5cclxuICAgICAqIEBwYXJhbSBfc3RydWN0dXJlIFRoZSBzdHJ1Y3R1cmUgdG8gdHJhdmVyc2VcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSB0cmF2ZXJzZVN0cnVjdHVyZUZvclRpbWUoX3N0cnVjdHVyZTogQW5pbWF0aW9uU3RydWN0dXJlKTogdm9pZCB7XHJcbiAgICAgIGZvciAobGV0IG4gaW4gX3N0cnVjdHVyZSkge1xyXG4gICAgICAgIGlmIChfc3RydWN0dXJlW25dIGluc3RhbmNlb2YgQW5pbWF0aW9uU2VxdWVuY2UpIHtcclxuICAgICAgICAgIGxldCBzZXF1ZW5jZTogQW5pbWF0aW9uU2VxdWVuY2UgPSA8QW5pbWF0aW9uU2VxdWVuY2U+X3N0cnVjdHVyZVtuXTtcclxuICAgICAgICAgIGlmIChzZXF1ZW5jZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGxldCBzZXF1ZW5jZVRpbWU6IG51bWJlciA9IHNlcXVlbmNlLmdldEtleShzZXF1ZW5jZS5sZW5ndGggLSAxKS5UaW1lO1xyXG4gICAgICAgICAgICB0aGlzLnRvdGFsVGltZSA9IHNlcXVlbmNlVGltZSA+IHRoaXMudG90YWxUaW1lID8gc2VxdWVuY2VUaW1lIDogdGhpcy50b3RhbFRpbWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMudHJhdmVyc2VTdHJ1Y3R1cmVGb3JUaW1lKDxBbmltYXRpb25TdHJ1Y3R1cmU+X3N0cnVjdHVyZVtuXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbnN1cmVzIHRoZSBleGlzdGFuY2Ugb2YgdGhlIHJlcXVlc3RlZCB7QGxpbmsgQW5pbWF0aW9uU3RyY3V0dXJlfSBhbmQgcmV0dXJucyBpdC5cclxuICAgICAqIEBwYXJhbSBfdHlwZSB0aGUgdHlwZSBvZiB0aGUgc3RydWN0dXJlIHRvIGdldFxyXG4gICAgICogQHJldHVybnMgdGhlIHJlcXVlc3RlZCB7QGxpbmsgQW5pbWF0aW9uU3RydWN0dXJlXV1cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBnZXRQcm9jZXNzZWRBbmltYXRpb25TdHJ1Y3R1cmUoX3R5cGU6IEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRSk6IEFuaW1hdGlvblN0cnVjdHVyZSB7XHJcbiAgICAgIGlmICghdGhpcy5hbmltYXRpb25TdHJ1Y3R1cmVzUHJvY2Vzc2VkLmhhcyhfdHlwZSkpIHtcclxuICAgICAgICB0aGlzLmNhbGN1bGF0ZVRvdGFsVGltZSgpO1xyXG4gICAgICAgIGxldCBhZTogQW5pbWF0aW9uU3RydWN0dXJlID0ge307XHJcbiAgICAgICAgc3dpdGNoIChfdHlwZSkge1xyXG4gICAgICAgICAgY2FzZSBBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuTk9STUFMOlxyXG4gICAgICAgICAgICBhZSA9IHRoaXMuYW5pbWF0aW9uU3RydWN0dXJlO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlJFVkVSU0U6XHJcbiAgICAgICAgICAgIGFlID0gdGhpcy50cmF2ZXJzZVN0cnVjdHVyZUZvck5ld1N0cnVjdHVyZSh0aGlzLmFuaW1hdGlvblN0cnVjdHVyZSwgdGhpcy5jYWxjdWxhdGVSZXZlcnNlU2VxdWVuY2UuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSBBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuUkFTVEVSRUQ6XHJcbiAgICAgICAgICAgIGFlID0gdGhpcy50cmF2ZXJzZVN0cnVjdHVyZUZvck5ld1N0cnVjdHVyZSh0aGlzLmFuaW1hdGlvblN0cnVjdHVyZSwgdGhpcy5jYWxjdWxhdGVSYXN0ZXJlZFNlcXVlbmNlLmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlJBU1RFUkVEUkVWRVJTRTpcclxuICAgICAgICAgICAgYWUgPSB0aGlzLnRyYXZlcnNlU3RydWN0dXJlRm9yTmV3U3RydWN0dXJlKHRoaXMuZ2V0UHJvY2Vzc2VkQW5pbWF0aW9uU3RydWN0dXJlKEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5SRVZFUlNFKSwgdGhpcy5jYWxjdWxhdGVSYXN0ZXJlZFNlcXVlbmNlLmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdHJ1Y3R1cmVzUHJvY2Vzc2VkLnNldChfdHlwZSwgYWUpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLmFuaW1hdGlvblN0cnVjdHVyZXNQcm9jZXNzZWQuZ2V0KF90eXBlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEVuc3VyZXMgdGhlIGV4aXN0YW5jZSBvZiB0aGUgcmVxdWVzdGVkIHtAbGluayBBbmltYXRpb25FdmVudFRyaWdnZXJ9IGFuZCByZXR1cm5zIGl0LlxyXG4gICAgICogQHBhcmFtIF90eXBlIFRoZSB0eXBlIG9mIEFuaW1hdGlvbkV2ZW50VHJpZ2dlciB0byBnZXRcclxuICAgICAqIEByZXR1cm5zIHRoZSByZXF1ZXN0ZWQge0BsaW5rIEFuaW1hdGlvbkV2ZW50VHJpZ2dlcl1dXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZ2V0UHJvY2Vzc2VkRXZlbnRUcmlnZ2VyKF90eXBlOiBBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUpOiBBbmltYXRpb25FdmVudFRyaWdnZXIge1xyXG4gICAgICBpZiAoIXRoaXMuZXZlbnRzUHJvY2Vzc2VkLmhhcyhfdHlwZSkpIHtcclxuICAgICAgICB0aGlzLmNhbGN1bGF0ZVRvdGFsVGltZSgpO1xyXG4gICAgICAgIGxldCBldjogQW5pbWF0aW9uRXZlbnRUcmlnZ2VyID0ge307XHJcbiAgICAgICAgc3dpdGNoIChfdHlwZSkge1xyXG4gICAgICAgICAgY2FzZSBBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuTk9STUFMOlxyXG4gICAgICAgICAgICBldiA9IHRoaXMuZXZlbnRzO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlJFVkVSU0U6XHJcbiAgICAgICAgICAgIGV2ID0gdGhpcy5jYWxjdWxhdGVSZXZlcnNlRXZlbnRUcmlnZ2Vycyh0aGlzLmV2ZW50cyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSBBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuUkFTVEVSRUQ6XHJcbiAgICAgICAgICAgIGV2ID0gdGhpcy5jYWxjdWxhdGVSYXN0ZXJlZEV2ZW50VHJpZ2dlcnModGhpcy5ldmVudHMpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlJBU1RFUkVEUkVWRVJTRTpcclxuICAgICAgICAgICAgZXYgPSB0aGlzLmNhbGN1bGF0ZVJhc3RlcmVkRXZlbnRUcmlnZ2Vycyh0aGlzLmdldFByb2Nlc3NlZEV2ZW50VHJpZ2dlcihBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuUkVWRVJTRSkpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ldmVudHNQcm9jZXNzZWQuc2V0KF90eXBlLCBldik7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMuZXZlbnRzUHJvY2Vzc2VkLmdldChfdHlwZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmF2ZXJzZXMgYW4gZXhpc3Rpbmcgc3RydWN0dXJlIHRvIGFwcGx5IGEgcmVjYWxjdWxhdGlvbiBmdW5jdGlvbiB0byB0aGUgQW5pbWF0aW9uU3RydWN0dXJlIHRvIHN0b3JlIGluIGEgbmV3IFN0cnVjdHVyZS5cclxuICAgICAqIEBwYXJhbSBfb2xkU3RydWN0dXJlIFRoZSBvbGQgc3RydWN0dXJlIHRvIHRyYXZlcnNlXHJcbiAgICAgKiBAcGFyYW0gX2Z1bmN0aW9uVG9Vc2UgVGhlIGZ1bmN0aW9uIHRvIHVzZSB0byByZWNhbGN1bGF0ZWQgdGhlIHN0cnVjdHVyZS5cclxuICAgICAqIEByZXR1cm5zIEEgbmV3IEFuaW1hdGlvbiBTdHJ1Y3R1cmUgd2l0aCB0aGUgcmVjYWx1bGF0ZWQgQW5pbWF0aW9uIFNlcXVlbmNlcy5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSB0cmF2ZXJzZVN0cnVjdHVyZUZvck5ld1N0cnVjdHVyZShfb2xkU3RydWN0dXJlOiBBbmltYXRpb25TdHJ1Y3R1cmUsIF9mdW5jdGlvblRvVXNlOiBGdW5jdGlvbik6IEFuaW1hdGlvblN0cnVjdHVyZSB7XHJcbiAgICAgIGxldCBuZXdTdHJ1Y3R1cmU6IEFuaW1hdGlvblN0cnVjdHVyZSA9IHt9O1xyXG4gICAgICBmb3IgKGxldCBuIGluIF9vbGRTdHJ1Y3R1cmUpIHtcclxuICAgICAgICBpZiAoX29sZFN0cnVjdHVyZVtuXSBpbnN0YW5jZW9mIEFuaW1hdGlvblNlcXVlbmNlKSB7XHJcbiAgICAgICAgICBuZXdTdHJ1Y3R1cmVbbl0gPSBfZnVuY3Rpb25Ub1VzZShfb2xkU3RydWN0dXJlW25dKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbmV3U3RydWN0dXJlW25dID0gdGhpcy50cmF2ZXJzZVN0cnVjdHVyZUZvck5ld1N0cnVjdHVyZSg8QW5pbWF0aW9uU3RydWN0dXJlPl9vbGRTdHJ1Y3R1cmVbbl0sIF9mdW5jdGlvblRvVXNlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG5ld1N0cnVjdHVyZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSByZXZlcnNlZCBBbmltYXRpb24gU2VxdWVuY2Ugb3V0IG9mIGEgZ2l2ZW4gU2VxdWVuY2UuXHJcbiAgICAgKiBAcGFyYW0gX3NlcXVlbmNlIFRoZSBzZXF1ZW5jZSB0byBjYWxjdWxhdGUgdGhlIG5ldyBzZXF1ZW5jZSBvdXQgb2ZcclxuICAgICAqIEByZXR1cm5zIFRoZSByZXZlcnNlZCBTZXF1ZW5jZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNhbGN1bGF0ZVJldmVyc2VTZXF1ZW5jZShfc2VxdWVuY2U6IEFuaW1hdGlvblNlcXVlbmNlKTogQW5pbWF0aW9uU2VxdWVuY2Uge1xyXG4gICAgICBsZXQgc2VxOiBBbmltYXRpb25TZXF1ZW5jZSA9IG5ldyBBbmltYXRpb25TZXF1ZW5jZSgpO1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgX3NlcXVlbmNlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IG9sZEtleTogQW5pbWF0aW9uS2V5ID0gX3NlcXVlbmNlLmdldEtleShpKTtcclxuICAgICAgICBsZXQga2V5OiBBbmltYXRpb25LZXkgPSBuZXcgQW5pbWF0aW9uS2V5KHRoaXMudG90YWxUaW1lIC0gb2xkS2V5LlRpbWUsIG9sZEtleS5WYWx1ZSwgb2xkS2V5LlNsb3BlT3V0LCBvbGRLZXkuU2xvcGVJbiwgb2xkS2V5LkNvbnN0YW50KTtcclxuICAgICAgICBzZXEuYWRkS2V5KGtleSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHNlcTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSByYXN0ZXJlZCB7QGxpbmsgQW5pbWF0aW9uU2VxdWVuY2V9IG91dCBvZiBhIGdpdmVuIHNlcXVlbmNlLlxyXG4gICAgICogQHBhcmFtIF9zZXF1ZW5jZSBUaGUgc2VxdWVuY2UgdG8gY2FsY3VsYXRlIHRoZSBuZXcgc2VxdWVuY2Ugb3V0IG9mXHJcbiAgICAgKiBAcmV0dXJucyB0aGUgcmFzdGVyZWQgc2VxdWVuY2UuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY2FsY3VsYXRlUmFzdGVyZWRTZXF1ZW5jZShfc2VxdWVuY2U6IEFuaW1hdGlvblNlcXVlbmNlKTogQW5pbWF0aW9uU2VxdWVuY2Uge1xyXG4gICAgICBsZXQgc2VxOiBBbmltYXRpb25TZXF1ZW5jZSA9IG5ldyBBbmltYXRpb25TZXF1ZW5jZSgpO1xyXG4gICAgICBsZXQgZnJhbWVUaW1lOiBudW1iZXIgPSAxMDAwIC8gdGhpcy5mcmFtZXNQZXJTZWNvbmQ7XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLnRvdGFsVGltZTsgaSArPSBmcmFtZVRpbWUpIHtcclxuICAgICAgICBsZXQga2V5OiBBbmltYXRpb25LZXkgPSBuZXcgQW5pbWF0aW9uS2V5KGksIF9zZXF1ZW5jZS5ldmFsdWF0ZShpKSwgMCwgMCwgdHJ1ZSk7XHJcbiAgICAgICAgc2VxLmFkZEtleShrZXkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBzZXE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHJldmVyc2VkIHtAbGluayBBbmltYXRpb25FdmVudFRyaWdnZXJ9IG9iamVjdCBiYXNlZCBvbiB0aGUgZ2l2ZW4gb25lLiAgXHJcbiAgICAgKiBAcGFyYW0gX2V2ZW50cyB0aGUgZXZlbnQgb2JqZWN0IHRvIGNhbGN1bGF0ZSB0aGUgbmV3IG9uZSBvdXQgb2ZcclxuICAgICAqIEByZXR1cm5zIHRoZSByZXZlcnNlZCBldmVudCBvYmplY3RcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjYWxjdWxhdGVSZXZlcnNlRXZlbnRUcmlnZ2VycyhfZXZlbnRzOiBBbmltYXRpb25FdmVudFRyaWdnZXIpOiBBbmltYXRpb25FdmVudFRyaWdnZXIge1xyXG4gICAgICBsZXQgYWU6IEFuaW1hdGlvbkV2ZW50VHJpZ2dlciA9IHt9O1xyXG4gICAgICBmb3IgKGxldCBuYW1lIGluIF9ldmVudHMpIHtcclxuICAgICAgICBhZVtuYW1lXSA9IHRoaXMudG90YWxUaW1lIC0gX2V2ZW50c1tuYW1lXTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgcmFzdGVyZWQge0BsaW5rIEFuaW1hdGlvbkV2ZW50VHJpZ2dlcn0gb2JqZWN0IGJhc2VkIG9uIHRoZSBnaXZlbiBvbmUuICBcclxuICAgICAqIEBwYXJhbSBfZXZlbnRzIHRoZSBldmVudCBvYmplY3QgdG8gY2FsY3VsYXRlIHRoZSBuZXcgb25lIG91dCBvZlxyXG4gICAgICogQHJldHVybnMgdGhlIHJhc3RlcmVkIGV2ZW50IG9iamVjdFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNhbGN1bGF0ZVJhc3RlcmVkRXZlbnRUcmlnZ2VycyhfZXZlbnRzOiBBbmltYXRpb25FdmVudFRyaWdnZXIpOiBBbmltYXRpb25FdmVudFRyaWdnZXIge1xyXG4gICAgICBsZXQgYWU6IEFuaW1hdGlvbkV2ZW50VHJpZ2dlciA9IHt9O1xyXG4gICAgICBsZXQgZnJhbWVUaW1lOiBudW1iZXIgPSAxMDAwIC8gdGhpcy5mcmFtZXNQZXJTZWNvbmQ7XHJcbiAgICAgIGZvciAobGV0IG5hbWUgaW4gX2V2ZW50cykge1xyXG4gICAgICAgIGFlW25hbWVdID0gX2V2ZW50c1tuYW1lXSAtIChfZXZlbnRzW25hbWVdICUgZnJhbWVUaW1lKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3Mgd2hpY2ggZXZlbnRzIGxheSBiZXR3ZWVuIHR3byBnaXZlbiB0aW1lcyBhbmQgcmV0dXJucyB0aGUgbmFtZXMgb2YgdGhlIG9uZXMgdGhhdCBkby5cclxuICAgICAqIEBwYXJhbSBfZXZlbnRUcmlnZ2VycyBUaGUgZXZlbnQgb2JqZWN0IHRvIGNoZWNrIHRoZSBldmVudHMgaW5zaWRlIG9mXHJcbiAgICAgKiBAcGFyYW0gX21pbiB0aGUgbWluaW11bSBvZiB0aGUgcmFuZ2UgdG8gY2hlY2sgYmV0d2VlbiAoaW5jbHVzaXZlKVxyXG4gICAgICogQHBhcmFtIF9tYXggdGhlIG1heGltdW0gb2YgdGhlIHJhbmdlIHRvIGNoZWNrIGJldHdlZW4gKGV4Y2x1c2l2ZSlcclxuICAgICAqIEByZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBuYW1lcyBvZiB0aGUgZXZlbnRzIGluIHRoZSBnaXZlbiByYW5nZS4gXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY2hlY2tFdmVudHNCZXR3ZWVuKF9ldmVudFRyaWdnZXJzOiBBbmltYXRpb25FdmVudFRyaWdnZXIsIF9taW46IG51bWJlciwgX21heDogbnVtYmVyKTogc3RyaW5nW10ge1xyXG4gICAgICBsZXQgZXZlbnRzVG9UcmlnZ2VyOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgICBmb3IgKGxldCBuYW1lIGluIF9ldmVudFRyaWdnZXJzKSB7XHJcbiAgICAgICAgaWYgKF9taW4gPD0gX2V2ZW50VHJpZ2dlcnNbbmFtZV0gJiYgX2V2ZW50VHJpZ2dlcnNbbmFtZV0gPCBfbWF4KSB7XHJcbiAgICAgICAgICBldmVudHNUb1RyaWdnZXIucHVzaChuYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGV2ZW50c1RvVHJpZ2dlcjtcclxuICAgIH1cclxuICB9XHJcbn0iLCIvLyAvIDxyZWZlcmVuY2UgcGF0aD1cIi4uL1RyYW5zZmVyL1NlcmlhbGl6ZXIudHNcIi8+XHJcbi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vVHJhbnNmZXIvTXV0YWJsZS50c1wiLz5cclxuXHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZXMgdGhlIHZhbHVlcyBiZXR3ZWVuIHtAbGluayBBbmltYXRpb25LZXl9cy5cclxuICAgKiBSZXByZXNlbnRlZCBpbnRlcm5hbGx5IGJ5IGEgY3ViaWMgZnVuY3Rpb24gKGBmKHgpID0gYXjCsyArIGJ4wrIgKyBjeCArIGRgKS4gXHJcbiAgICogT25seSBuZWVkcyB0byBiZSByZWNhbGN1bGF0ZWQgd2hlbiB0aGUga2V5cyBjaGFuZ2UsIHNvIGF0IHJ1bnRpbWUgaXQgc2hvdWxkIG9ubHkgYmUgY2FsY3VsYXRlZCBvbmNlLlxyXG4gICAqIEBhdXRob3IgTHVrYXMgU2NoZXVlcmxlLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQW5pbWF0aW9uRnVuY3Rpb24ge1xyXG4gICAgcHJpdmF0ZSBhOiBudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSBiOiBudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSBjOiBudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSBkOiBudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSBrZXlJbjogQW5pbWF0aW9uS2V5O1xyXG4gICAgcHJpdmF0ZSBrZXlPdXQ6IEFuaW1hdGlvbktleTtcclxuXHJcblxyXG4gICAgY29uc3RydWN0b3IoX2tleUluOiBBbmltYXRpb25LZXksIF9rZXlPdXQ6IEFuaW1hdGlvbktleSA9IG51bGwpIHtcclxuICAgICAgdGhpcy5rZXlJbiA9IF9rZXlJbjtcclxuICAgICAgdGhpcy5rZXlPdXQgPSBfa2V5T3V0O1xyXG4gICAgICB0aGlzLmNhbGN1bGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIGF0IHRoZSBnaXZlbiB0aW1lLlxyXG4gICAgICogQHBhcmFtIF90aW1lIHRoZSBwb2ludCBpbiB0aW1lIGF0IHdoaWNoIHRvIGV2YWx1YXRlIHRoZSBmdW5jdGlvbiBpbiBtaWxsaXNlY29uZHMuIFdpbGwgYmUgY29ycmVjdGVkIGZvciBvZmZzZXQgaW50ZXJuYWxseS5cclxuICAgICAqIEByZXR1cm5zIHRoZSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gdGltZVxyXG4gICAgICovXHJcbiAgICBldmFsdWF0ZShfdGltZTogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgICAgX3RpbWUgLT0gdGhpcy5rZXlJbi5UaW1lO1xyXG4gICAgICBsZXQgdGltZTI6IG51bWJlciA9IF90aW1lICogX3RpbWU7XHJcbiAgICAgIGxldCB0aW1lMzogbnVtYmVyID0gdGltZTIgKiBfdGltZTtcclxuICAgICAgcmV0dXJuIHRoaXMuYSAqIHRpbWUzICsgdGhpcy5iICogdGltZTIgKyB0aGlzLmMgKiBfdGltZSArIHRoaXMuZDtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgc2V0S2V5SW4oX2tleUluOiBBbmltYXRpb25LZXkpIHtcclxuICAgICAgdGhpcy5rZXlJbiA9IF9rZXlJbjtcclxuICAgICAgdGhpcy5jYWxjdWxhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgc2V0S2V5T3V0KF9rZXlPdXQ6IEFuaW1hdGlvbktleSkge1xyXG4gICAgICB0aGlzLmtleU91dCA9IF9rZXlPdXQ7XHJcbiAgICAgIHRoaXMuY2FsY3VsYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAoUmUtKUNhbGN1bGF0ZXMgdGhlIHBhcmFtZXRlcnMgb2YgdGhlIGN1YmljIGZ1bmN0aW9uLlxyXG4gICAgICogU2VlIGh0dHBzOi8vbWF0aC5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMzE3MzQ2OS9jYWxjdWxhdGUtY3ViaWMtZXF1YXRpb24tZnJvbS10d28tcG9pbnRzLWFuZC10d28tc2xvcGVzLXZhcmlhYmx5XHJcbiAgICAgKiBhbmQgaHR0cHM6Ly9qaXJrYWRlbGxvcm8uZ2l0aHViLmlvL0ZVREdFL0RvY3VtZW50YXRpb24vTG9ncy8xOTA0MTBfTm90aXplbl9MU1xyXG4gICAgICovXHJcbiAgICBjYWxjdWxhdGUoKTogdm9pZCB7XHJcbiAgICAgIGlmICghdGhpcy5rZXlJbikge1xyXG4gICAgICAgIHRoaXMuZCA9IHRoaXMuYyA9IHRoaXMuYiA9IHRoaXMuYSA9IDA7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghdGhpcy5rZXlPdXQgfHwgdGhpcy5rZXlJbi5Db25zdGFudCkge1xyXG4gICAgICAgIHRoaXMuZCA9IHRoaXMua2V5SW4uVmFsdWU7XHJcbiAgICAgICAgdGhpcy5jID0gdGhpcy5iID0gdGhpcy5hID0gMDtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCB4MTogbnVtYmVyID0gdGhpcy5rZXlPdXQuVGltZSAtIHRoaXMua2V5SW4uVGltZTtcclxuXHJcbiAgICAgIHRoaXMuZCA9IHRoaXMua2V5SW4uVmFsdWU7XHJcbiAgICAgIHRoaXMuYyA9IHRoaXMua2V5SW4uU2xvcGVPdXQ7XHJcblxyXG4gICAgICB0aGlzLmEgPSAoLXgxICogKHRoaXMua2V5SW4uU2xvcGVPdXQgKyB0aGlzLmtleU91dC5TbG9wZUluKSAtIDIgKiB0aGlzLmtleUluLlZhbHVlICsgMiAqIHRoaXMua2V5T3V0LlZhbHVlKSAvIC1NYXRoLnBvdyh4MSwgMyk7XHJcbiAgICAgIHRoaXMuYiA9ICh0aGlzLmtleU91dC5TbG9wZUluIC0gdGhpcy5rZXlJbi5TbG9wZU91dCAtIDMgKiB0aGlzLmEgKiBNYXRoLnBvdyh4MSwgMikpIC8gKDIgKiB4MSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxufSIsIi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vVHJhbnNmZXIvU2VyaWFsaXplci50c1wiLz5cclxuLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9UcmFuc2Zlci9NdXRhYmxlLnRzXCIvPlxyXG5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogSG9sZHMgaW5mb3JtYXRpb24gYWJvdXQgc2V0IHBvaW50cyBpbiB0aW1lLCB0aGVpciBhY2NvbXBhbnlpbmcgdmFsdWVzIGFzIHdlbGwgYXMgdGhlaXIgc2xvcGVzLiBcclxuICAgKiBBbHNvIGhvbGRzIGEgcmVmZXJlbmNlIHRvIHRoZSB7QGxpbmsgQW5pbWF0aW9uRnVuY3Rpb259cyB0aGF0IGNvbWUgaW4gYW5kIG91dCBvZiB0aGUgc2lkZXMuIFRoZSB7QGxpbmsgQW5pbWF0aW9uRnVuY3Rpb259cyBhcmUgaGFuZGxlZCBieSB0aGUge0BsaW5rIEFuaW1hdGlvblNlcXVlbmNlfXMuXHJcbiAgICogU2F2ZWQgaW5zaWRlIGFuIHtAbGluayBBbmltYXRpb25TZXF1ZW5jZX0uXHJcbiAgICogQGF1dGhvciBMdWthcyBTY2hldWVybGUsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBBbmltYXRpb25LZXkgZXh0ZW5kcyBNdXRhYmxlIGltcGxlbWVudHMgU2VyaWFsaXphYmxlIHtcclxuICAgIC8vIFRPRE86IGNoZWNrIGlmIGZ1bmN0aW9uSW4gY2FuIGJlIHJlbW92ZWRcclxuICAgIC8qKkRvbid0IG1vZGlmeSB0aGlzIHVubGVzcyB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZy4qL1xyXG4gICAgZnVuY3Rpb25JbjogQW5pbWF0aW9uRnVuY3Rpb247XHJcbiAgICAvKipEb24ndCBtb2RpZnkgdGhpcyB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmcuKi9cclxuICAgIGZ1bmN0aW9uT3V0OiBBbmltYXRpb25GdW5jdGlvbjtcclxuICAgIFxyXG4gICAgYnJva2VuOiBib29sZWFuO1xyXG5cclxuICAgIHByaXZhdGUgdGltZTogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSB2YWx1ZTogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBjb25zdGFudDogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICAgIHByaXZhdGUgc2xvcGVJbjogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgc2xvcGVPdXQ6IG51bWJlciA9IDA7XHJcblxyXG4gICAgY29uc3RydWN0b3IoX3RpbWU6IG51bWJlciA9IDAsIF92YWx1ZTogbnVtYmVyID0gMCwgX3Nsb3BlSW46IG51bWJlciA9IDAsIF9zbG9wZU91dDogbnVtYmVyID0gMCwgX2NvbnN0YW50OiBib29sZWFuID0gZmFsc2UpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy50aW1lID0gX3RpbWU7XHJcbiAgICAgIHRoaXMudmFsdWUgPSBfdmFsdWU7XHJcbiAgICAgIHRoaXMuc2xvcGVJbiA9IF9zbG9wZUluO1xyXG4gICAgICB0aGlzLnNsb3BlT3V0ID0gX3Nsb3BlT3V0O1xyXG4gICAgICB0aGlzLmNvbnN0YW50ID0gX2NvbnN0YW50O1xyXG5cclxuICAgICAgdGhpcy5icm9rZW4gPSB0aGlzLnNsb3BlSW4gIT0gLXRoaXMuc2xvcGVPdXQ7XHJcbiAgICAgIHRoaXMuZnVuY3Rpb25PdXQgPSBuZXcgQW5pbWF0aW9uRnVuY3Rpb24odGhpcywgbnVsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGF0aWMgY29tcGFyYXRpb24gZnVuY3Rpb24gdG8gdXNlIGluIGFuIGFycmF5IHNvcnQgZnVuY3Rpb24gdG8gc29ydCB0aGUga2V5cyBieSB0aGVpciB0aW1lLlxyXG4gICAgICogQHBhcmFtIF9hIHRoZSBhbmltYXRpb24ga2V5IHRvIGNoZWNrXHJcbiAgICAgKiBAcGFyYW0gX2IgdGhlIGFuaW1hdGlvbiBrZXkgdG8gY2hlY2sgYWdhaW5zdFxyXG4gICAgICogQHJldHVybnMgPjAgaWYgYT5iLCAwIGlmIGE9YiwgPDAgaWYgYTxiXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjb21wYXJlKF9hOiBBbmltYXRpb25LZXksIF9iOiBBbmltYXRpb25LZXkpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gX2EudGltZSAtIF9iLnRpbWU7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGdldCBUaW1lKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLnRpbWU7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IFRpbWUoX3RpbWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLnRpbWUgPSBfdGltZTtcclxuICAgICAgdGhpcy5mdW5jdGlvbkluLmNhbGN1bGF0ZSgpO1xyXG4gICAgICB0aGlzLmZ1bmN0aW9uT3V0LmNhbGN1bGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBWYWx1ZSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy52YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgVmFsdWUoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy52YWx1ZSA9IF92YWx1ZTtcclxuICAgICAgdGhpcy5mdW5jdGlvbkluLmNhbGN1bGF0ZSgpO1xyXG4gICAgICB0aGlzLmZ1bmN0aW9uT3V0LmNhbGN1bGF0ZSgpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBnZXQgQ29uc3RhbnQoKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0YW50O1xyXG4gICAgfVxyXG5cclxuICAgIHNldCBDb25zdGFudChfY29uc3RhbnQ6IGJvb2xlYW4pIHtcclxuICAgICAgdGhpcy5jb25zdGFudCA9IF9jb25zdGFudDtcclxuICAgICAgdGhpcy5mdW5jdGlvbkluLmNhbGN1bGF0ZSgpO1xyXG4gICAgICB0aGlzLmZ1bmN0aW9uT3V0LmNhbGN1bGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBTbG9wZUluKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNsb3BlSW47XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHNldCBTbG9wZUluKF9zbG9wZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuc2xvcGVJbiA9IF9zbG9wZTtcclxuICAgICAgdGhpcy5mdW5jdGlvbkluLmNhbGN1bGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBTbG9wZU91dCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5zbG9wZU91dDtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgU2xvcGVPdXQoX3Nsb3BlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5zbG9wZU91dCA9IF9zbG9wZTtcclxuICAgICAgdGhpcy5mdW5jdGlvbk91dC5jYWxjdWxhdGUoKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8jcmVnaW9uIHRyYW5zZmVyXHJcbiAgICBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzOiBTZXJpYWxpemF0aW9uID0ge307XHJcbiAgICAgIHMudGltZSA9IHRoaXMudGltZTtcclxuICAgICAgcy52YWx1ZSA9IHRoaXMudmFsdWU7XHJcbiAgICAgIHMuc2xvcGVJbiA9IHRoaXMuc2xvcGVJbjtcclxuICAgICAgcy5zbG9wZU91dCA9IHRoaXMuc2xvcGVPdXQ7XHJcbiAgICAgIHMuY29uc3RhbnQgPSB0aGlzLmNvbnN0YW50O1xyXG4gICAgICByZXR1cm4gcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICB0aGlzLnRpbWUgPSBfc2VyaWFsaXphdGlvbi50aW1lO1xyXG4gICAgICB0aGlzLnZhbHVlID0gX3NlcmlhbGl6YXRpb24udmFsdWU7XHJcbiAgICAgIHRoaXMuc2xvcGVJbiA9IF9zZXJpYWxpemF0aW9uLnNsb3BlSW47XHJcbiAgICAgIHRoaXMuc2xvcGVPdXQgPSBfc2VyaWFsaXphdGlvbi5zbG9wZU91dDtcclxuICAgICAgdGhpcy5jb25zdGFudCA9IF9zZXJpYWxpemF0aW9uLmNvbnN0YW50O1xyXG5cclxuICAgICAgdGhpcy5icm9rZW4gPSB0aGlzLnNsb3BlSW4gIT0gLXRoaXMuc2xvcGVPdXQ7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xyXG4gICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemUoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICAvL1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gIH1cclxuXHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBBIHNlcXVlbmNlIG9mIHtAbGluayBBbmltYXRpb25LZXl9cyB0aGF0IGlzIG1hcHBlZCB0byBhbiBhdHRyaWJ1dGUgb2YgYSB7QGxpbmsgTm9kZX0gb3IgaXRzIHtAbGluayBDb21wb25lbnR9cyBpbnNpZGUgdGhlIHtAbGluayBBbmltYXRpb259LlxyXG4gICAqIFByb3ZpZGVzIGZ1bmN0aW9ucyB0byBtb2RpZnkgc2FpZCBrZXlzXHJcbiAgICogQGF1dGhvciBMdWthcyBTY2hldWVybGUsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBBbmltYXRpb25TZXF1ZW5jZSBleHRlbmRzIE11dGFibGUgaW1wbGVtZW50cyBTZXJpYWxpemFibGUge1xyXG4gICAgcHJpdmF0ZSBrZXlzOiBBbmltYXRpb25LZXlbXSA9IFtdO1xyXG5cclxuICAgIGdldCBsZW5ndGgoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMua2V5cy5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogRXZhbHVhdGVzIHRoZSBzZXF1ZW5jZSBhdCB0aGUgZ2l2ZW4gcG9pbnQgaW4gdGltZS5cclxuICAgICAqIEBwYXJhbSBfdGltZSB0aGUgcG9pbnQgaW4gdGltZSBhdCB3aGljaCB0byBldmFsdWF0ZSB0aGUgc2VxdWVuY2UgaW4gbWlsbGlzZWNvbmRzLlxyXG4gICAgICogQHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBzZXF1ZW5jZSBhdCB0aGUgZ2l2ZW4gdGltZS4gMCBpZiB0aGVyZSBhcmUgbm8ga2V5cy5cclxuICAgICAqL1xyXG4gICAgZXZhbHVhdGUoX3RpbWU6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgIGlmICh0aGlzLmtleXMubGVuZ3RoID09IDApXHJcbiAgICAgICAgcmV0dXJuIDA7IC8vVE9ETzogc2hvdWxkbid0IHJldHVybiAwIGJ1dCBzb21ldGhpbmcgaW5kaWNhdGluZyBubyBjaGFuZ2UsIGxpa2UgbnVsbC4gcHJvYmFibHkgbmVlZHMgdG8gYmUgY2hhbmdlZCBpbiBOb2RlIGFzIHdlbGwgdG8gaWdub3JlIG5vbi1udW1lcmljIHZhbHVlcyBpbiB0aGUgYXBwbHlBbmltYXRpb24gZnVuY3Rpb25cclxuICAgICAgaWYgKHRoaXMua2V5cy5sZW5ndGggPT0gMSB8fCB0aGlzLmtleXNbMF0uVGltZSA+PSBfdGltZSlcclxuICAgICAgICByZXR1cm4gdGhpcy5rZXlzWzBdLlZhbHVlO1xyXG5cclxuXHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLmtleXMubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgaWYgKHRoaXMua2V5c1tpXS5UaW1lIDw9IF90aW1lICYmIHRoaXMua2V5c1tpICsgMV0uVGltZSA+IF90aW1lKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5rZXlzW2ldLmZ1bmN0aW9uT3V0LmV2YWx1YXRlKF90aW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMua2V5c1t0aGlzLmtleXMubGVuZ3RoIC0gMV0uVmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbmV3IGtleSB0byB0aGUgc2VxdWVuY2UuXHJcbiAgICAgKiBAcGFyYW0gX2tleSB0aGUga2V5IHRvIGFkZFxyXG4gICAgICovXHJcbiAgICBhZGRLZXkoX2tleTogQW5pbWF0aW9uS2V5KTogdm9pZCB7XHJcbiAgICAgIHRoaXMua2V5cy5wdXNoKF9rZXkpO1xyXG4gICAgICB0aGlzLmtleXMuc29ydChBbmltYXRpb25LZXkuY29tcGFyZSk7XHJcbiAgICAgIHRoaXMucmVnZW5lcmF0ZUZ1bmN0aW9ucygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhIGdpdmVuIGtleSBmcm9tIHRoZSBzZXF1ZW5jZS5cclxuICAgICAqIEBwYXJhbSBfa2V5IHRoZSBrZXkgdG8gcmVtb3ZlXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZUtleShfa2V5OiBBbmltYXRpb25LZXkpOiB2b2lkIHtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMua2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmICh0aGlzLmtleXNbaV0gPT0gX2tleSkge1xyXG4gICAgICAgICAgdGhpcy5rZXlzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgIHRoaXMucmVnZW5lcmF0ZUZ1bmN0aW9ucygpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgQW5pbWF0aW9uIEtleSBhdCB0aGUgZ2l2ZW4gaW5kZXggZnJvbSB0aGUga2V5cy5cclxuICAgICAqIEBwYXJhbSBfaW5kZXggdGhlIHplcm8tYmFzZWQgaW5kZXggYXQgd2hpY2ggdG8gcmVtb3ZlIHRoZSBrZXlcclxuICAgICAqIEByZXR1cm5zIHRoZSByZW1vdmVkIEFuaW1hdGlvbktleSBpZiBzdWNjZXNzZnVsLCBudWxsIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlS2V5QXRJbmRleChfaW5kZXg6IG51bWJlcik6IEFuaW1hdGlvbktleSB7XHJcbiAgICAgIGlmIChfaW5kZXggPCAwIHx8IF9pbmRleCA+PSB0aGlzLmtleXMubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgbGV0IGFrOiBBbmltYXRpb25LZXkgPSB0aGlzLmtleXNbX2luZGV4XTtcclxuICAgICAgdGhpcy5rZXlzLnNwbGljZShfaW5kZXgsIDEpO1xyXG4gICAgICB0aGlzLnJlZ2VuZXJhdGVGdW5jdGlvbnMoKTtcclxuICAgICAgcmV0dXJuIGFrO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhIGtleSBmcm9tIHRoZSBzZXF1ZW5jZSBhdCB0aGUgZGVzaXJlZCBpbmRleC5cclxuICAgICAqIEBwYXJhbSBfaW5kZXggdGhlIHplcm8tYmFzZWQgaW5kZXggYXQgd2hpY2ggdG8gZ2V0IHRoZSBrZXlcclxuICAgICAqIEByZXR1cm5zIHRoZSBBbmltYXRpb25LZXkgYXQgdGhlIGluZGV4IGlmIGl0IGV4aXN0cywgbnVsbCBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIGdldEtleShfaW5kZXg6IG51bWJlcik6IEFuaW1hdGlvbktleSB7XHJcbiAgICAgIGlmIChfaW5kZXggPCAwIHx8IF9pbmRleCA+PSB0aGlzLmtleXMubGVuZ3RoKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICByZXR1cm4gdGhpcy5rZXlzW19pbmRleF07XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vI3JlZ2lvbiB0cmFuc2ZlclxyXG4gICAgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgczogU2VyaWFsaXphdGlvbiA9IHtcclxuICAgICAgICBrZXlzOiBbXSxcclxuICAgICAgICBhbmltYXRpb25TZXF1ZW5jZTogdHJ1ZVxyXG4gICAgICB9O1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5rZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgcy5rZXlzW2ldID0gdGhpcy5rZXlzW2ldLnNlcmlhbGl6ZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBzO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IF9zZXJpYWxpemF0aW9uLmtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAvLyB0aGlzLmtleXMucHVzaCg8QW5pbWF0aW9uS2V5PlNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24ua2V5c1tpXSkpO1xyXG4gICAgICAgIGxldCBrOiBBbmltYXRpb25LZXkgPSBuZXcgQW5pbWF0aW9uS2V5KCk7XHJcbiAgICAgICAgYXdhaXQgay5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5rZXlzW2ldKTtcclxuICAgICAgICB0aGlzLmtleXNbaV0gPSBrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnJlZ2VuZXJhdGVGdW5jdGlvbnMoKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICAvL1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVdGlsaXR5IGZ1bmN0aW9uIHRoYXQgKHJlLSlnZW5lcmF0ZXMgYWxsIGZ1bmN0aW9ucyBpbiB0aGUgc2VxdWVuY2UuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcmVnZW5lcmF0ZUZ1bmN0aW9ucygpOiB2b2lkIHtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMua2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCBmOiBBbmltYXRpb25GdW5jdGlvbiA9IG5ldyBBbmltYXRpb25GdW5jdGlvbih0aGlzLmtleXNbaV0pO1xyXG4gICAgICAgIHRoaXMua2V5c1tpXS5mdW5jdGlvbk91dCA9IGY7XHJcbiAgICAgICAgaWYgKGkgPT0gdGhpcy5rZXlzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgIC8vVE9ETzogY2hlY2sgaWYgdGhpcyBpcyBldmVuIHVzZWZ1bC4gTWF5YmUgdXBkYXRlIHRoZSBydW5jb25kaXRpb24gdG8gbGVuZ3RoIC0gMSBpbnN0ZWFkLiBNaWdodCBiZSByZWR1bmRhbnQgaWYgZnVuY3Rpb25JbiBpcyByZW1vdmVkLCBzZWUgVE9ETyBpbiBBbmltYXRpb25LZXkuXHJcbiAgICAgICAgICBmLnNldEtleU91dCA9IHRoaXMua2V5c1swXTtcclxuICAgICAgICAgIHRoaXMua2V5c1swXS5mdW5jdGlvbkluID0gZjtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmLnNldEtleU91dCA9IHRoaXMua2V5c1tpICsgMV07XHJcbiAgICAgICAgdGhpcy5rZXlzW2kgKyAxXS5mdW5jdGlvbkluID0gZjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEV4dGVuc2lvbiBvZiBBdWRpb0J1ZmZlciB3aXRoIGEgbG9hZCBtZXRob2QgdGhhdCBjcmVhdGVzIGEgYnVmZmVyIGluIHRoZSB7QGxpbmsgQXVkaW9NYW5hZ2VyfS5kZWZhdWx0IHRvIGJlIHVzZWQgd2l0aCB7QGxpbmsgQ29tcG9uZW50QXVkaW99XHJcbiAgICogQGF1dGhvcnMgVGhvbWFzIERvcm5lciwgSEZVLCAyMDE5IHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjBcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQXVkaW8gZXh0ZW5kcyBNdXRhYmxlIGltcGxlbWVudHMgU2VyaWFsaXphYmxlUmVzb3VyY2Uge1xyXG4gICAgcHVibGljIG5hbWU6IHN0cmluZyA9IFwiQXVkaW9cIjtcclxuICAgIHB1YmxpYyBpZFJlc291cmNlOiBzdHJpbmcgPSB1bmRlZmluZWQ7XHJcbiAgICBwdWJsaWMgYnVmZmVyOiBBdWRpb0J1ZmZlciA9IHVuZGVmaW5lZDtcclxuICAgIHB1YmxpYyBwYXRoOiBVUkwgPSB1bmRlZmluZWQ7XHJcbiAgICBwcml2YXRlIHVybDogUmVxdWVzdEluZm8gPSB1bmRlZmluZWQ7XHJcbiAgICBwcml2YXRlIHJlYWR5OiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgY29uc3RydWN0b3IoX3VybD86IFJlcXVlc3RJbmZvKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIGlmIChfdXJsKSB7XHJcbiAgICAgICAgdGhpcy5sb2FkKF91cmwpO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IF91cmwudG9TdHJpbmcoKS5zcGxpdChcIi9cIikucG9wKCk7XHJcbiAgICAgIH1cclxuICAgICAgUHJvamVjdC5yZWdpc3Rlcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgaXNSZWFkeSgpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIHRoaXMucmVhZHk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBc3luY2hyb25vdXNseSBsb2FkcyB0aGUgYXVkaW8gKG1wMykgZnJvbSB0aGUgZ2l2ZW4gdXJsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBsb2FkKF91cmw6IFJlcXVlc3RJbmZvKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIERlYnVnLmZ1ZGdlKFwiQXVkaW9Mb2FkXCIsIF91cmwpO1xyXG4gICAgICB0aGlzLnVybCA9IF91cmw7XHJcbiAgICAgIHRoaXMucmVhZHkgPSBmYWxzZTtcclxuICAgICAgdGhpcy5wYXRoID0gbmV3IFVSTCh0aGlzLnVybC50b1N0cmluZygpLCBQcm9qZWN0LmJhc2VVUkwpO1xyXG4gICAgICBjb25zdCByZXNwb25zZTogUmVzcG9uc2UgPSBhd2FpdCB3aW5kb3cuZmV0Y2godGhpcy5wYXRoLnRvU3RyaW5nKCkpO1xyXG4gICAgICBjb25zdCBhcnJheUJ1ZmZlcjogQXJyYXlCdWZmZXIgPSBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xyXG4gICAgICBsZXQgYnVmZmVyOiBBdWRpb0J1ZmZlciA9IGF3YWl0IEF1ZGlvTWFuYWdlci5kZWZhdWx0LmRlY29kZUF1ZGlvRGF0YShhcnJheUJ1ZmZlcik7XHJcbiAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xyXG4gICAgICB0aGlzLnJlYWR5ID0gdHJ1ZTtcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVF9BVURJTy5SRUFEWSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB1cmw6IHRoaXMudXJsLFxyXG4gICAgICAgIGlkUmVzb3VyY2U6IHRoaXMuaWRSZXNvdXJjZSxcclxuICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgdHlwZTogdGhpcy50eXBlXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBQcm9qZWN0LnJlZ2lzdGVyKHRoaXMsIF9zZXJpYWxpemF0aW9uLmlkUmVzb3VyY2UpO1xyXG4gICAgICBhd2FpdCB0aGlzLmxvYWQoX3NlcmlhbGl6YXRpb24udXJsKTtcclxuICAgICAgdGhpcy5uYW1lID0gX3NlcmlhbGl6YXRpb24ubmFtZTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBsZXQgdXJsOiBzdHJpbmcgPSBfbXV0YXRvci51cmw7IC8vIHNhdmUgdXJsIGZvciByZWNvbnN0cnVjdGlvbiBhZnRlciBleGNsdXNpb25cclxuICAgICAgaWYgKF9tdXRhdG9yLnVybCAhPSB0aGlzLnVybC50b1N0cmluZygpKVxyXG4gICAgICAgIHRoaXMubG9hZChfbXV0YXRvci51cmwpO1xyXG4gICAgICAvLyBleGNlcHQgdXJsIGZyb20gbXV0YXRvciBmb3IgZnVydGhlciBwcm9jZXNzaW5nXHJcbiAgICAgIGRlbGV0ZSAoX211dGF0b3IudXJsKTtcclxuICAgICAgc3VwZXIubXV0YXRlKF9tdXRhdG9yKTtcclxuICAgICAgLy8gcmVjb25zdHJ1Y3QsIGZvciBtdXRhdG9yIG1heSBiZSBrZXB0IGJ5IGNhbGxlclxyXG4gICAgICBSZWZsZWN0LnNldChfbXV0YXRvciwgXCJ1cmxcIiwgdXJsKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICAvLyBkZWxldGUgX211dGF0b3IuaWRSZXNvdXJjZTsgXHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5yZWFkeTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEV4dGVuZHMgdGhlIHN0YW5kYXJkIEF1ZGlvQ29udGV4dCBmb3IgaW50ZWdyYXRpb24gd2l0aCBGVURHRS1ncmFwaHMuXHJcbiAgICogQ3JlYXRlcyBhIGRlZmF1bHQgb2JqZWN0IGF0IHN0YXJ0dXAgdG8gYmUgYWRkcmVzc2VkIGFzIEF1ZGlvTWFuYWdlciBkZWZhdWx0LlxyXG4gICAqIE90aGVyIG9iamVjdHMgb2YgdGhpcyBjbGFzcyBtYXkgYmUgY3JlYXRlIGZvciBzcGVjaWFsIHB1cnBvc2VzLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBBdWRpb01hbmFnZXIgZXh0ZW5kcyBBdWRpb0NvbnRleHQge1xyXG4gICAgLyoqIFRoZSBkZWZhdWx0IGNvbnRleHQgdGhhdCBtYXkgYmUgdXNlZCB0aHJvdWdob3V0IHRoZSBwcm9qZWN0IHdpdGhvdXQgdGhlIG5lZWQgdG8gY3JlYXRlIG90aGVycyAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBkZWZhdWx0OiBBdWRpb01hbmFnZXIgPSBuZXcgQXVkaW9NYW5hZ2VyKHsgbGF0ZW5jeUhpbnQ6IFwiaW50ZXJhY3RpdmVcIiwgc2FtcGxlUmF0ZTogNDQxMDAgfSk7XHJcbiAgICAvKiogVGhlIG1hc3RlciB2b2x1bWUgYWxsIEF1ZGlvTm9kZXMgaW4gdGhlIGNvbnRleHQgc2hvdWxkIGF0dGFjaCB0byAqL1xyXG4gICAgcHVibGljIHJlYWRvbmx5IGdhaW46IEdhaW5Ob2RlO1xyXG4gICAgcHJpdmF0ZSBncmFwaDogTm9kZSA9IG51bGw7XHJcbiAgICBwcml2YXRlIGNtcExpc3RlbmVyOiBDb21wb25lbnRBdWRpb0xpc3RlbmVyID0gbnVsbDtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0T3B0aW9ucz86IEF1ZGlvQ29udGV4dE9wdGlvbnMpIHtcclxuICAgICAgc3VwZXIoY29udGV4dE9wdGlvbnMpO1xyXG4gICAgICB0aGlzLmdhaW4gPSB0aGlzLmNyZWF0ZUdhaW4oKTtcclxuICAgICAgdGhpcy5nYWluLmNvbm5lY3QodGhpcy5kZXN0aW5hdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIG1hc3RlciB2b2x1bWVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldCB2b2x1bWUoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5nYWluLmdhaW4udmFsdWUgPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIG1hc3RlciB2b2x1bWVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCB2b2x1bWUoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2Fpbi5nYWluLnZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lcyBGVURHRS1ncmFwaCB0byBsaXN0ZW4gdG8uIEVhY2gge0BsaW5rIENvbXBvbmVudEF1ZGlvfSBpbiB0aGUgZ3JhcGggd2lsbCBjb25uZWN0IHRvIHRoaXMgY29udGV4dHMgbWFzdGVyIGdhaW4sIGFsbCBvdGhlcnMgZGlzY29ubmVjdC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGxpc3RlblRvID0gKF9ncmFwaDogTm9kZSB8IG51bGwpOiB2b2lkID0+IHtcclxuICAgICAgaWYgKHRoaXMuZ3JhcGgpXHJcbiAgICAgICAgdGhpcy5ncmFwaC5icm9hZGNhc3RFdmVudChuZXcgRXZlbnQoRVZFTlRfQVVESU8uQ0hJTERfUkVNT1ZFKSk7XHJcbiAgICAgIGlmICghX2dyYXBoKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgdGhpcy5ncmFwaCA9IF9ncmFwaDtcclxuICAgICAgdGhpcy5ncmFwaC5icm9hZGNhc3RFdmVudChuZXcgRXZlbnQoRVZFTlRfQVVESU8uQ0hJTERfQVBQRU5EKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZSB0aGUgRlVER0UtZ3JhcGggY3VycmVudGx5IGxpc3RlbmluZyB0b1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0R3JhcGhMaXN0ZW5pbmdUbyA9ICgpOiBOb2RlID0+IHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ3JhcGg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHtAbGluayBDb21wb25lbnRBdWRpb0xpc3RlbmVyfSB0aGF0IHNlcnZlcyB0aGUgc3BhdGlhbCBsb2NhdGlvbiBhbmQgb3JpZW50YXRpb24gZm9yIHRoaXMgY29udGV4dHMgbGlzdGVuZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGxpc3RlbldpdGggPSAoX2NtcExpc3RlbmVyOiBDb21wb25lbnRBdWRpb0xpc3RlbmVyIHwgbnVsbCk6IHZvaWQgPT4ge1xyXG4gICAgICB0aGlzLmNtcExpc3RlbmVyID0gX2NtcExpc3RlbmVyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgc3BhdGlhbCBzZXR0aW5ncyBvZiB0aGUgQXVkaW9Ob2RlcyBlZmZlY3RlZCBpbiB0aGUgY3VycmVudCBGVURHRS1ncmFwaFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdXBkYXRlID0gKCk6IHZvaWQgPT4ge1xyXG4gICAgICB0aGlzLmdyYXBoLmJyb2FkY2FzdEV2ZW50KG5ldyBFdmVudChFVkVOVF9BVURJTy5VUERBVEUpKTtcclxuICAgICAgaWYgKHRoaXMuY21wTGlzdGVuZXIpXHJcbiAgICAgICAgdGhpcy5jbXBMaXN0ZW5lci51cGRhdGUodGhpcy5saXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwiLy8gbmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgICBcclxuLy8gICAgIC8qKlxyXG4vLyAgICAgICogRW51bWVyYXRvciBmb3IgYWxsIHBvc3NpYmxlIE9zY2lsbGF0b3IgVHlwZXNcclxuLy8gICAgICAqL1xyXG4vLyAgICAgdHlwZSBPU0NJTExBVE9SX1RZUEUgPSBcInNpbmVcIiB8IFwic3F1YXJlXCIgfCBcInNhd3Rvb3RoXCIgfCBcInRyaWFuZ2xlXCIgfCBcImN1c3RvbVwiO1xyXG5cclxuLy8gICAgIC8qKlxyXG4vLyAgICAgICogSW50ZXJmYWNlIHRvIGNyZWF0ZSBDdXN0b20gT3NjaWxsYXRvciBUeXBlcy5cclxuLy8gICAgICAqIFN0YXJ0LS9FbmRwb2ludCBvZiBhIGN1c3R1bSBjdXJ2ZSBlLmcuIHNpbmUgY3VydmUuXHJcbi8vICAgICAgKiBCb3RoIHBhcmFtZXRlcnMgbmVlZCB0byBiZSBpbmJldHdlZW4gLTEgYW5kIDEuXHJcbi8vICAgICAgKiBAcGFyYW0gc3RhcnRwb2ludCBzdGFydHBvaW50IG9mIGEgY3VydmUgXHJcbi8vICAgICAgKiBAcGFyYW0gZW5kcG9pbnQgRW5kcG9pbnQgb2YgYSBjdXJ2ZSBcclxuLy8gICAgICAqL1xyXG4vLyAgICAgaW50ZXJmYWNlIE9zY2lsbGF0b3JXYXZlIHtcclxuLy8gICAgICAgICBzdGFydHBvaW50OiBudW1iZXI7XHJcbi8vICAgICAgICAgZW5kcG9pbnQ6IG51bWJlcjtcclxuLy8gICAgIH1cclxuLy8gICAgIC8qKlxyXG4vLyAgICAgICogQWRkIGFuIHtAbGluayBBdWRpb0ZpbHRlcn0gdG8gYW4ge0BsaW5rIEF1ZGlvXV1cclxuLy8gICAgICAqIEBhdXRob3JzIFRob21hcyBEb3JuZXIsIEhGVSwgMjAxOVxyXG4vLyAgICAgICovXHJcbi8vICAgICBleHBvcnQgY2xhc3MgQXVkaW9Pc2NpbGxhdG9yIHtcclxuXHJcbi8vICAgICAgICAgcHVibGljIGF1ZGlvT3NjaWxsYXRvcjogT3NjaWxsYXRvck5vZGU7IFxyXG5cclxuLy8gICAgICAgICBwcml2YXRlIGZyZXF1ZW5jeTogbnVtYmVyO1xyXG4vLyAgICAgICAgIHByaXZhdGUgb3NjaWxsYXRvclR5cGU6IE9TQ0lMTEFUT1JfVFlQRTtcclxuLy8gICAgICAgICBwcml2YXRlIG9zY2lsbGF0b3JXYXZlOiBQZXJpb2RpY1dhdmU7XHJcblxyXG4vLyAgICAgICAgIHByaXZhdGUgbG9jYWxHYWluOiBHYWluTm9kZTtcclxuLy8gICAgICAgICBwcml2YXRlIGxvY2FsR2FpblZhbHVlOiBudW1iZXI7XHJcblxyXG4vLyAgICAgICAgIGNvbnN0cnVjdG9yKF9hdWRpb1NldHRpbmdzOiBBdWRpb1NldHRpbmdzLCBfb3NjaWxsYXRvclR5cGU/OiBPU0NJTExBVE9SX1RZUEUpIHtcclxuLy8gICAgICAgICAgICAgdGhpcy5hdWRpb09zY2lsbGF0b3IgPSBfYXVkaW9TZXR0aW5ncy5nZXRBdWRpb0NvbnRleHQoKS5jcmVhdGVPc2NpbGxhdG9yKCk7XHJcbi8vICAgICAgICAgICAgIHRoaXMubG9jYWxHYWluID0gX2F1ZGlvU2V0dGluZ3MuZ2V0QXVkaW9Db250ZXh0KCkuY3JlYXRlR2FpbigpO1xyXG4vLyAgICAgICAgICAgICB0aGlzLm9zY2lsbGF0b3JUeXBlID0gX29zY2lsbGF0b3JUeXBlO1xyXG4vLyAgICAgICAgICAgICBpZiAodGhpcy5vc2NpbGxhdG9yVHlwZSAhPSBcImN1c3RvbVwiKSB7XHJcbi8vICAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvT3NjaWxsYXRvci50eXBlID0gdGhpcy5vc2NpbGxhdG9yVHlwZTtcclxuLy8gICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgICAgICBlbHNlIHtcclxuLy8gICAgICAgICAgICAgICAgIGlmICghdGhpcy5vc2NpbGxhdG9yV2F2ZSkge1xyXG4vLyAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9Pc2NpbGxhdG9yLnNldFBlcmlvZGljV2F2ZSh0aGlzLm9zY2lsbGF0b3JXYXZlKTtcclxuLy8gICAgICAgICAgICAgICAgIH1cclxuLy8gICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4vLyAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ3JlYXRlIGEgQ3VzdG9tIFBlcmlvZGljIFdhdmUgZmlyc3QgdG8gdXNlIEN1c3RvbSBUeXBlXCIpO1xyXG4vLyAgICAgICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgICAgICB9XHJcbi8vICAgICAgICAgfVxyXG5cclxuLy8gICAgICAgICBwdWJsaWMgc2V0T3NjaWxsYXRvclR5cGUoX29zY2lsbGF0b3JUeXBlOiBPU0NJTExBVE9SX1RZUEUpOiB2b2lkIHtcclxuLy8gICAgICAgICAgICAgaWYgKHRoaXMub3NjaWxsYXRvclR5cGUgIT0gXCJjdXN0b21cIikge1xyXG4vLyAgICAgICAgICAgICAgICAgdGhpcy5hdWRpb09zY2lsbGF0b3IudHlwZSA9IHRoaXMub3NjaWxsYXRvclR5cGU7XHJcbi8vICAgICAgICAgICAgIH1cclxuLy8gICAgICAgICAgICAgZWxzZSB7XHJcbi8vICAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3NjaWxsYXRvcldhdmUpIHtcclxuLy8gICAgICAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvT3NjaWxsYXRvci5zZXRQZXJpb2RpY1dhdmUodGhpcy5vc2NpbGxhdG9yV2F2ZSk7XHJcbi8vICAgICAgICAgICAgICAgICB9XHJcbi8vICAgICAgICAgICAgIH1cclxuLy8gICAgICAgICB9XHJcblxyXG4vLyAgICAgICAgIHB1YmxpYyBnZXRPc2NpbGxhdG9yVHlwZSgpOiBPU0NJTExBVE9SX1RZUEUge1xyXG4vLyAgICAgICAgICAgICByZXR1cm4gdGhpcy5vc2NpbGxhdG9yVHlwZTtcclxuLy8gICAgICAgICB9XHJcblxyXG4vLyAgICAgICAgIHB1YmxpYyBjcmVhdGVQZXJpb2RpY1dhdmUoX2F1ZGlvU2V0dGluZ3M6IEF1ZGlvU2V0dGluZ3MsIF9yZWFsOiBPc2NpbGxhdG9yV2F2ZSwgX2ltYWc6IE9zY2lsbGF0b3JXYXZlKTogdm9pZCB7XHJcbi8vICAgICAgICAgICAgIGxldCB3YXZlUmVhbDogRmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcclxuLy8gICAgICAgICAgICAgd2F2ZVJlYWxbMF0gPSBfcmVhbC5zdGFydHBvaW50O1xyXG4vLyAgICAgICAgICAgICB3YXZlUmVhbFsxXSA9IF9yZWFsLmVuZHBvaW50O1xyXG5cclxuLy8gICAgICAgICAgICAgbGV0IHdhdmVJbWFnOiBGbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xyXG4vLyAgICAgICAgICAgICB3YXZlSW1hZ1swXSA9IF9pbWFnLnN0YXJ0cG9pbnQ7XHJcbi8vICAgICAgICAgICAgIHdhdmVJbWFnWzFdID0gX2ltYWcuZW5kcG9pbnQ7XHJcblxyXG4vLyAgICAgICAgICAgICB0aGlzLm9zY2lsbGF0b3JXYXZlID0gX2F1ZGlvU2V0dGluZ3MuZ2V0QXVkaW9Db250ZXh0KCkuY3JlYXRlUGVyaW9kaWNXYXZlKHdhdmVSZWFsLCB3YXZlSW1hZyk7XHJcbi8vICAgICAgICAgfVxyXG5cclxuLy8gICAgICAgICBwdWJsaWMgc2V0TG9jYWxHYWluKF9sb2NhbEdhaW46IEdhaW5Ob2RlKTogdm9pZCB7XHJcbi8vICAgICAgICAgICAgIHRoaXMubG9jYWxHYWluID0gX2xvY2FsR2FpbjtcclxuLy8gICAgICAgICB9XHJcblxyXG4vLyAgICAgICAgIHB1YmxpYyBnZXRMb2NhbEdhaW4oKTogR2Fpbk5vZGUge1xyXG4vLyAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbEdhaW47XHJcbi8vICAgICAgICAgfVxyXG5cclxuLy8gICAgICAgICBwdWJsaWMgc2V0TG9jYWxHYWluVmFsdWUoX2xvY2FsR2FpblZhbHVlOiBudW1iZXIpOiB2b2lkIHtcclxuLy8gICAgICAgICAgICAgdGhpcy5sb2NhbEdhaW5WYWx1ZSA9IF9sb2NhbEdhaW5WYWx1ZTtcclxuLy8gICAgICAgICAgICAgdGhpcy5sb2NhbEdhaW4uZ2Fpbi52YWx1ZSA9IHRoaXMubG9jYWxHYWluVmFsdWU7XHJcbi8vICAgICAgICAgfVxyXG5cclxuLy8gICAgICAgICBwdWJsaWMgZ2V0TG9jYWxHYWluVmFsdWUoKTogbnVtYmVyIHtcclxuLy8gICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxHYWluVmFsdWU7XHJcbi8vICAgICAgICAgfVxyXG5cclxuLy8gICAgICAgICBwdWJsaWMgc2V0RnJlcXVlbmN5KF9hdWRpb1NldHRpbmdzOiBBdWRpb1NldHRpbmdzLCBfZnJlcXVlbmN5OiBudW1iZXIpOiB2b2lkIHtcclxuLy8gICAgICAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBfZnJlcXVlbmN5O1xyXG4vLyAgICAgICAgICAgICB0aGlzLmF1ZGlvT3NjaWxsYXRvci5mcmVxdWVuY3kuc2V0VmFsdWVBdFRpbWUodGhpcy5mcmVxdWVuY3ksIF9hdWRpb1NldHRpbmdzLmdldEF1ZGlvQ29udGV4dCgpLmN1cnJlbnRUaW1lKTtcclxuLy8gICAgICAgICB9XHJcblxyXG4vLyAgICAgICAgIHB1YmxpYyBnZXRGcmVxdWVuY3koKTogbnVtYmVyIHtcclxuLy8gICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJlcXVlbmN5O1xyXG4vLyAgICAgICAgIH1cclxuXHJcbi8vICAgICAgICAgcHVibGljIGNyZWF0ZVNuYXJlKF9hdWRpb1NldHRpbmdzOiBBdWRpb1NldHRpbmdzKTogdm9pZCB7XHJcbi8vICAgICAgICAgICAgIHRoaXMuc2V0T3NjaWxsYXRvclR5cGUoXCJ0cmlhbmdsZVwiKTtcclxuLy8gICAgICAgICAgICAgdGhpcy5zZXRGcmVxdWVuY3koX2F1ZGlvU2V0dGluZ3MsIDEwMCk7XHJcbi8vICAgICAgICAgICAgIHRoaXMuc2V0TG9jYWxHYWluVmFsdWUoMCk7XHJcbi8vICAgICAgICAgICAgIHRoaXMubG9jYWxHYWluLmdhaW4uc2V0VmFsdWVBdFRpbWUoMCwgX2F1ZGlvU2V0dGluZ3MuZ2V0QXVkaW9Db250ZXh0KCkuY3VycmVudFRpbWUpO1xyXG4vLyAgICAgICAgICAgICB0aGlzLmxvY2FsR2Fpbi5nYWluLmV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUoMC4wMSwgX2F1ZGlvU2V0dGluZ3MuZ2V0QXVkaW9Db250ZXh0KCkuY3VycmVudFRpbWUgKyAuMSk7XHJcblxyXG4vLyAgICAgICAgICAgICB0aGlzLmF1ZGlvT3NjaWxsYXRvci5jb25uZWN0KHRoaXMubG9jYWxHYWluKTtcclxuLy8gICAgICAgICB9XHJcbi8vICAgICB9XHJcbi8vIH0iLCIvLyAvIDxyZWZlcmVuY2UgcGF0aD1cIi4uL1RpbWUvTG9vcC50c1wiLz5cclxuLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9BbmltYXRpb24vQW5pbWF0aW9uLnRzXCIvPlxyXG5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEhvbGRzIGEgcmVmZXJlbmNlIHRvIGFuIHtAbGluayBBbmltYXRpb259IGFuZCBjb250cm9scyBpdC4gQ29udHJvbHMgcGxheWJhY2sgYW5kIHBsYXltb2RlIGFzIHdlbGwgYXMgc3BlZWQuXHJcbiAgICogQGF1dGhvcnMgTHVrYXMgU2NoZXVlcmxlLCBIRlUsIDIwMTkgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb21wb25lbnRBbmltYXRvciBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gQ29tcG9uZW50LnJlZ2lzdGVyU3ViY2xhc3MoQ29tcG9uZW50QW5pbWF0b3IpO1xyXG4gICAgLy9UT0RPOiBhZGQgZnVuY3Rpb25hbGl0eSB0byBibGVuZCBmcm9tIG9uZSBhbmltYXRpb24gdG8gYW5vdGhlci5cclxuICAgIGFuaW1hdGlvbjogQW5pbWF0aW9uO1xyXG4gICAgcGxheW1vZGU6IEFOSU1BVElPTl9QTEFZTU9ERTtcclxuICAgIHBsYXliYWNrOiBBTklNQVRJT05fUExBWUJBQ0s7XHJcbiAgICBzY2FsZVdpdGhHYW1lVGltZTogYm9vbGVhbiA9IHRydWU7XHJcblxyXG4gICAgI3NjYWxlOiBudW1iZXIgPSAxO1xyXG4gICAgI3RpbWVMb2NhbDogVGltZTtcclxuICAgICNwcmV2aW91czogbnVtYmVyID0gMDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihfYW5pbWF0aW9uOiBBbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKFwiXCIpLCBfcGxheW1vZGU6IEFOSU1BVElPTl9QTEFZTU9ERSA9IEFOSU1BVElPTl9QTEFZTU9ERS5MT09QLCBfcGxheWJhY2s6IEFOSU1BVElPTl9QTEFZQkFDSyA9IEFOSU1BVElPTl9QTEFZQkFDSy5USU1FQkFTRURfQ09OVElOT1VTKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuYW5pbWF0aW9uID0gX2FuaW1hdGlvbjtcclxuICAgICAgdGhpcy5wbGF5bW9kZSA9IF9wbGF5bW9kZTtcclxuICAgICAgdGhpcy5wbGF5YmFjayA9IF9wbGF5YmFjaztcclxuXHJcbiAgICAgIHRoaXMuI3RpbWVMb2NhbCA9IG5ldyBUaW1lKCk7XHJcblxyXG4gICAgICAvL1RPRE86IHVwZGF0ZSBhbmltYXRpb24gdG90YWwgdGltZSB3aGVuIGxvYWRpbmcgYSBkaWZmZXJlbnQgYW5pbWF0aW9uP1xyXG4gICAgICB0aGlzLmFuaW1hdGlvbi5jYWxjdWxhdGVUb3RhbFRpbWUoKTtcclxuXHJcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5DT01QT05FTlRfUkVNT1ZFLCAoKSA9PiB0aGlzLmFjdGl2YXRlKGZhbHNlKSk7XHJcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5DT01QT05FTlRfQURELCAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuQ0hJTERfUkVNT1ZFLCAoKSA9PiB0aGlzLmFjdGl2YXRlKGZhbHNlKSk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmF0ZSh0cnVlKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldCBzY2FsZShfc2NhbGU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNzY2FsZSA9IF9zY2FsZTtcclxuICAgICAgdGhpcy51cGRhdGVTY2FsZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgc2NhbGUoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3NjYWxlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBzYW1wbGUgdGltZSBvZiB0aGUgYW5pbWF0aW9uXHJcbiAgICAgKi9cclxuICAgICBwdWJsaWMgZ2V0IHRpbWUoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3RpbWVMb2NhbC5nZXQoKSAlIHRoaXMuYW5pbWF0aW9uLnRvdGFsVGltZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYWN0aXZhdGUoX29uOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgIHN1cGVyLmFjdGl2YXRlKF9vbik7XHJcbiAgICAgIGlmICghdGhpcy5ub2RlKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGlmIChfb24pIHtcclxuICAgICAgICBUaW1lLmdhbWUuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5USU1FX1NDQUxFRCwgdGhpcy51cGRhdGVTY2FsZSk7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuUkVOREVSX1BSRVBBUkUsIHRoaXMudXBkYXRlQW5pbWF0aW9uTG9vcCk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgVGltZS5nYW1lLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuVElNRV9TQ0FMRUQsIHRoaXMudXBkYXRlU2NhbGUpO1xyXG4gICAgICAgIHRoaXMubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5ULlJFTkRFUl9QUkVQQVJFLCB0aGlzLnVwZGF0ZUFuaW1hdGlvbkxvb3ApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBKdW1wcyB0byBhIGNlcnRhaW4gdGltZSBpbiB0aGUgYW5pbWF0aW9uIHRvIHBsYXkgZnJvbSB0aGVyZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGp1bXBUbyhfdGltZTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuI3RpbWVMb2NhbC5zZXQoX3RpbWUpO1xyXG4gICAgICB0aGlzLiNwcmV2aW91cyA9IF90aW1lO1xyXG4gICAgICBfdGltZSA9IF90aW1lICUgdGhpcy5hbmltYXRpb24udG90YWxUaW1lO1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHRoaXMuYW5pbWF0aW9uLmdldE11dGF0ZWQoX3RpbWUsIHRoaXMuYW5pbWF0aW9uLmNhbGN1bGF0ZURpcmVjdGlvbihfdGltZSwgdGhpcy5wbGF5bW9kZSksIHRoaXMucGxheWJhY2spO1xyXG4gICAgICB0aGlzLm5vZGUuYXBwbHlBbmltYXRpb24obXV0YXRvcik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBKdW1wcyB0byBhIGNlcnRhaW4gbGFiZWwgaW4gdGhlIGFuaW1hdGlvbiBpZiBkZWZpbmVkXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBqdW1wVG9MYWJlbChfbGFiZWw6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICBsZXQgdGltZTogbnVtYmVyID0gdGhpcy5hbmltYXRpb24ubGFiZWxzW19sYWJlbF07XHJcbiAgICAgIGlmICh0aW1lKVxyXG4gICAgICAgIHRoaXMuanVtcFRvKHRpbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRm9yY2VzIGFuIHVwZGF0ZSBvZiB0aGUgYW5pbWF0aW9uIGZyb20gb3V0c2lkZS4gVXNlZCBpbiB0aGUgVmlld0FuaW1hdGlvbi4gU2hvdWxkbid0IGJlIHVzZWQgZHVyaW5nIHRoZSBnYW1lLlxyXG4gICAgICogQHBhcmFtIF90aW1lIHRoZSAodW5zY2FsZWQpIHRpbWUgdG8gdXBkYXRlIHRoZSBhbmltYXRpb24gd2l0aC5cclxuICAgICAqIEByZXR1cm5zIGEgVHVwZWwgY29udGFpbmluZyB0aGUgTXV0YXRvciBmb3IgQW5pbWF0aW9uIGFuZCB0aGUgcGxheW1vZGUgY29ycmVjdGVkIHRpbWUuIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdXBkYXRlQW5pbWF0aW9uKF90aW1lOiBudW1iZXIpOiBbTXV0YXRvciwgbnVtYmVyXSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUFuaW1hdGlvbkxvb3AobnVsbCwgX3RpbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiB0cmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5pZEFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uLmlkUmVzb3VyY2U7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24ucGxheW1vZGUgPSB0aGlzLnBsYXltb2RlO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnBsYXliYWNrID0gdGhpcy5wbGF5YmFjaztcclxuICAgICAgc2VyaWFsaXphdGlvbi5zY2FsZSA9IHRoaXMuc2NhbGU7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24uc2NhbGVXaXRoR2FtZVRpbWUgPSB0aGlzLnNjYWxlV2l0aEdhbWVUaW1lO1xyXG4gICAgICBzZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcblxyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XHJcbiAgICAgIHRoaXMuYW5pbWF0aW9uID0gPEFuaW1hdGlvbj5hd2FpdCBQcm9qZWN0LmdldFJlc291cmNlKF9zZXJpYWxpemF0aW9uLmlkQW5pbWF0aW9uKTtcclxuICAgICAgdGhpcy5wbGF5YmFjayA9IF9zZXJpYWxpemF0aW9uLnBsYXliYWNrO1xyXG4gICAgICB0aGlzLnBsYXltb2RlID0gX3NlcmlhbGl6YXRpb24ucGxheW1vZGU7XHJcbiAgICAgIHRoaXMuc2NhbGUgPSBfc2VyaWFsaXphdGlvbi5zY2FsZTtcclxuICAgICAgdGhpcy5zY2FsZVdpdGhHYW1lVGltZSA9IF9zZXJpYWxpemF0aW9uLnNjYWxlV2l0aEdhbWVUaW1lO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gdXBkYXRlQW5pbWF0aW9uXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIEFuaW1hdGlvbi5cclxuICAgICAqIEdldHMgY2FsbGVkIGV2ZXJ5IHRpbWUgdGhlIExvb3AgZmlyZXMgdGhlIExPT1BfRlJBTUUgRXZlbnQuXHJcbiAgICAgKiBVc2VzIHRoZSBidWlsdC1pbiB0aW1lIHVubGVzcyBhIGRpZmZlcmVudCB0aW1lIGlzIHNwZWNpZmllZC5cclxuICAgICAqIE1heSBhbHNvIGJlIGNhbGxlZCBmcm9tIHVwZGF0ZUFuaW1hdGlvbigpLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHVwZGF0ZUFuaW1hdGlvbkxvb3AgPSAoX2U6IEV2ZW50LCBfdGltZT86IG51bWJlcik6IFtNdXRhdG9yLCBudW1iZXJdID0+IHtcclxuICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uLnRvdGFsVGltZSA9PSAwKVxyXG4gICAgICAgIHJldHVybiBbbnVsbCwgMF07XHJcbiAgICAgIGxldCB0aW1lOiBudW1iZXIgPSBfdGltZSB8fCB0aGlzLiN0aW1lTG9jYWwuZ2V0KCk7XHJcbiAgICAgIGlmICh0aGlzLnBsYXliYWNrID09IEFOSU1BVElPTl9QTEFZQkFDSy5GUkFNRUJBU0VEKSB7XHJcbiAgICAgICAgdGltZSA9IHRoaXMuI3ByZXZpb3VzICsgKDEwMDAgLyB0aGlzLmFuaW1hdGlvbi5mcHMpO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCBkaXJlY3Rpb246IG51bWJlciA9IHRoaXMuYW5pbWF0aW9uLmNhbGN1bGF0ZURpcmVjdGlvbih0aW1lLCB0aGlzLnBsYXltb2RlKTtcclxuICAgICAgdGltZSA9IHRoaXMuYW5pbWF0aW9uLmdldE1vZGFsVGltZSh0aW1lLCB0aGlzLnBsYXltb2RlLCB0aGlzLiN0aW1lTG9jYWwuZ2V0T2Zmc2V0KCkpO1xyXG4gICAgICB0aGlzLmV4ZWN1dGVFdmVudHModGhpcy5hbmltYXRpb24uZ2V0RXZlbnRzVG9GaXJlKHRoaXMuI3ByZXZpb3VzLCB0aW1lLCB0aGlzLnBsYXliYWNrLCBkaXJlY3Rpb24pKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLiNwcmV2aW91cyAhPSB0aW1lKSB7XHJcbiAgICAgICAgdGhpcy4jcHJldmlvdXMgPSB0aW1lO1xyXG4gICAgICAgIHRpbWUgPSB0aW1lICUgdGhpcy5hbmltYXRpb24udG90YWxUaW1lO1xyXG4gICAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0gdGhpcy5hbmltYXRpb24uZ2V0TXV0YXRlZCh0aW1lLCBkaXJlY3Rpb24sIHRoaXMucGxheWJhY2spO1xyXG4gICAgICAgIGlmICh0aGlzLm5vZGUpIHtcclxuICAgICAgICAgIHRoaXMubm9kZS5hcHBseUFuaW1hdGlvbihtdXRhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFttdXRhdG9yLCB0aW1lXTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gW251bGwsIHRpbWVdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZXMgYWxsIGN1c3RvbSBldmVudHMgdGhlIEFuaW1hdGlvbiBzaG91bGQgaGF2ZSBmaXJlZCBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBmcmFtZS5cclxuICAgICAqIEBwYXJhbSBldmVudHMgYSBsaXN0IG9mIG5hbWVzIG9mIGN1c3RvbSBldmVudHMgdG8gZmlyZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGV4ZWN1dGVFdmVudHMoZXZlbnRzOiBzdHJpbmdbXSk6IHZvaWQge1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChldmVudHNbaV0pKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgc2NhbGUgb2YgdGhlIGFuaW1hdGlvbiBpZiB0aGUgdXNlciBjaGFuZ2VzIGl0IG9yIGlmIHRoZSBnbG9iYWwgZ2FtZSB0aW1lciBjaGFuZ2VkIGl0cyBzY2FsZS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSB1cGRhdGVTY2FsZSA9ICgpOiB2b2lkID0+IHtcclxuICAgICAgbGV0IG5ld1NjYWxlOiBudW1iZXIgPSB0aGlzLiNzY2FsZTtcclxuICAgICAgaWYgKHRoaXMuc2NhbGVXaXRoR2FtZVRpbWUpXHJcbiAgICAgICAgbmV3U2NhbGUgKj0gVGltZS5nYW1lLmdldFNjYWxlKCk7XHJcbiAgICAgIHRoaXMuI3RpbWVMb2NhbC5zZXRTY2FsZShuZXdTY2FsZSk7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgZW51bSBBVURJT19QQU5ORVIge1xyXG4gICAgQ09ORV9JTk5FUl9BTkdMRSA9IFwiY29uZUlubmVyQW5nbGVcIixcclxuICAgIENPTkVfT1VURVJfQU5HTEUgPSBcImNvbmVPdXRlckFuZ2xlXCIsXHJcbiAgICBDT05FX09VVEVSX0dBSU4gPSBcImNvbmVPdXRlckdhaW5cIixcclxuICAgIERJU1RBTkNFX01PREVMID0gXCJkaXN0YW5jZU1vZGVsXCIsXHJcbiAgICBNQVhfRElTVEFOQ0UgPSBcIm1heERpc3RhbmNlXCIsXHJcbiAgICBQQU5OSU5HX01PREVMID0gXCJwYW5uaW5nTW9kZWxcIixcclxuICAgIFJFRl9ESVNUQU5DRSA9IFwicmVmRGlzdGFuY2VcIixcclxuICAgIFJPTExPRkZfRkFDVE9SID0gXCJyb2xsb2ZmRmFjdG9yXCJcclxuICB9XHJcblxyXG4gIGV4cG9ydCBlbnVtIEFVRElPX05PREVfVFlQRSB7XHJcbiAgICBTT1VSQ0UsIFBBTk5FUiwgR0FJTlxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQnVpbGRzIGEgbWluaW1hbCBhdWRpbyBncmFwaCAoYnkgZGVmYXVsdCBpbiB7QGxpbmsgQXVkaW9NYW5hZ2VyfS5kZWZhdWx0KSBhbmQgc3luY2hyb25pemVzIGl0IHdpdGggdGhlIGNvbnRhaW5pbmcge0BsaW5rIE5vZGV9XHJcbiAgICogYGBgcGxhaW50ZXh0XHJcbiAgICog4pSMIEF1ZGlvTWFuYWdlciguZGVmYXVsdCkg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXHJcbiAgICog4pSCIOKUjCBDb21wb25lbnRBdWRpbyDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJAgICAgICAgICAg4pSCXHJcbiAgICog4pSCIOKUgiAgICDilIzilIDilIDilIDilIDilIDilIDilJAgICDilIzilIDilIDilIDilIDilIDilIDilJAgICDilIzilIDilIDilIDilIDilIDilIDilJAg4pSCIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUkCDilIIgIFxyXG4gICAqIOKUgiDilIIgICAg4pSCc291cmNl4pSCIOKGkiDilIJwYW5uZXLilIIg4oaSIOKUgiBnYWluIOKUgiDihpIg4pSCIGdhaW4g4pSCIOKUglxyXG4gICAqIOKUgiDilIIgICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSYICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSYICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSYIOKUgiDilJTilIDilIDilIDilIDilIDilIDilJgg4pSCICBcclxuICAgKiDilIIg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYICAgICAgICAgIOKUglxyXG4gICAqIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxyXG4gICAqIGBgYFxyXG4gICAqIEBhdXRob3JzIFRob21hcyBEb3JuZXIsIEhGVSwgMjAxOSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIENvbXBvbmVudEF1ZGlvIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRBdWRpbyk7XHJcbiAgICAvKiogcGxhY2VzIGFuZCBkaXJlY3RzIHRoZSBwYW5uZXIgcmVsYXRpdmUgdG8gdGhlIHdvcmxkIHRyYW5zZm9ybSBvZiB0aGUge0BsaW5rIE5vZGV9ICAqL1xyXG4gICAgcHVibGljIG10eFBpdm90OiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgc2luZ2xldG9uOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgcHJpdmF0ZSBhdWRpbzogQXVkaW87XHJcbiAgICBwcml2YXRlIGdhaW46IEdhaW5Ob2RlO1xyXG4gICAgcHJpdmF0ZSBwYW5uZXI6IFBhbm5lck5vZGU7XHJcbiAgICBwcml2YXRlIHNvdXJjZTogQXVkaW9CdWZmZXJTb3VyY2VOb2RlO1xyXG4gICAgcHJpdmF0ZSBhdWRpb01hbmFnZXI6IEF1ZGlvTWFuYWdlcjtcclxuICAgIHByaXZhdGUgcGxheWluZzogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgcHJpdmF0ZSBsaXN0ZW5lZDogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKF9hdWRpbzogQXVkaW8gPSBudWxsLCBfbG9vcDogYm9vbGVhbiA9IGZhbHNlLCBfc3RhcnQ6IGJvb2xlYW4gPSBmYWxzZSwgX2F1ZGlvTWFuYWdlcjogQXVkaW9NYW5hZ2VyID0gQXVkaW9NYW5hZ2VyLmRlZmF1bHQpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5pbnN0YWxsKF9hdWRpb01hbmFnZXIpO1xyXG4gICAgICB0aGlzLmNyZWF0ZVNvdXJjZShfYXVkaW8sIF9sb29wKTtcclxuXHJcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5DT01QT05FTlRfQURELCB0aGlzLmhhbmRsZUF0dGFjaCk7XHJcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5DT01QT05FTlRfUkVNT1ZFLCB0aGlzLmhhbmRsZUF0dGFjaCk7XHJcblxyXG4gICAgICBpZiAoX3N0YXJ0KVxyXG4gICAgICAgIHRoaXMucGxheShfc3RhcnQpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgc2V0IHZvbHVtZShfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLmdhaW4uZ2Fpbi52YWx1ZSA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHZvbHVtZSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5nYWluLmdhaW4udmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldCBsb29wKF9vbjogYm9vbGVhbikge1xyXG4gICAgICB0aGlzLnNvdXJjZS5sb29wID0gX29uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgbG9vcCgpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLmxvb3A7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBpc1BsYXlpbmcoKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLnBsYXlpbmc7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgZ2V0IGlzQXR0YWNoZWQoKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLm5vZGUgIT0gbnVsbDtcclxuICAgIH1cclxuICAgIHB1YmxpYyBnZXQgaXNMaXN0ZW5lZCgpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldEF1ZGlvKF9hdWRpbzogQXVkaW8pOiB2b2lkIHtcclxuICAgICAgdGhpcy5jcmVhdGVTb3VyY2UoX2F1ZGlvLCB0aGlzLnNvdXJjZS5sb29wKTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBnZXRBdWRpbygpOiBBdWRpbyB7XHJcbiAgICAgIHJldHVybiB0aGlzLmF1ZGlvO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBwcm9wZXJ0eSBvZiB0aGUgcGFubmVyIHRvIHRoZSBnaXZlbiB2YWx1ZS4gVXNlIHRvIG1hbmlwdWxhdGUgcmFuZ2UgYW5kIHJvbGxvZmYgZXRjLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0UGFubmVyKF9wcm9wZXJ0eTogQVVESU9fUEFOTkVSLCBfdmFsdWU6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICBSZWZsZWN0LnNldCh0aGlzLnBhbm5lciwgX3Byb3BlcnR5LCBfdmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE86IG1heSBiZSB1c2VkIGZvciBzZXJpYWxpemF0aW9uIG9mIEF1ZGlvTm9kZXNcclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yT2ZOb2RlKF90eXBlOiBBVURJT19OT0RFX1RZUEUpOiBNdXRhdG9yIHtcclxuICAgICAgbGV0IG5vZGU6IEF1ZGlvTm9kZSA9IHRoaXMuZ2V0QXVkaW9Ob2RlKF90eXBlKTtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSBnZXRNdXRhdG9yT2ZBcmJpdHJhcnkobm9kZSk7XHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc3BlY2lmaWVkIEF1ZGlvTm9kZSBvZiB0aGUgc3RhbmRhcmQgZ3JhcGggZm9yIGZ1cnRoZXIgbWFuaXB1bGF0aW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRBdWRpb05vZGUoX3R5cGU6IEFVRElPX05PREVfVFlQRSk6IEF1ZGlvTm9kZSB7XHJcbiAgICAgIHN3aXRjaCAoX3R5cGUpIHtcclxuICAgICAgICBjYXNlIEFVRElPX05PREVfVFlQRS5TT1VSQ0U6IHJldHVybiB0aGlzLnNvdXJjZTtcclxuICAgICAgICBjYXNlIEFVRElPX05PREVfVFlQRS5QQU5ORVI6IHJldHVybiB0aGlzLnBhbm5lcjtcclxuICAgICAgICBjYXNlIEFVRElPX05PREVfVFlQRS5HQUlOOiByZXR1cm4gdGhpcy5nYWluO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydCBvciBzdG9wIHBsYXlpbmcgdGhlIGF1ZGlvXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwbGF5KF9vbjogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICBpZiAoX29uKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYXVkaW8uaXNSZWFkeSkge1xyXG4gICAgICAgICAgdGhpcy5jcmVhdGVTb3VyY2UodGhpcy5hdWRpbywgdGhpcy5zb3VyY2UubG9vcCk7XHJcbiAgICAgICAgICB0aGlzLnNvdXJjZS5zdGFydCgwLCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLmF1ZGlvLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRfQVVESU8uUkVBRFksIHRoaXMuaG5kQXVkaW9SZWFkeSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRfQVVESU8uRU5ERUQsIHRoaXMuaG5kQXVkaW9FbmRlZCk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICB0aGlzLnNvdXJjZS5zdG9wKCk7XHJcbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yOiB1bmtub3duKSB7IC8qIGNhdGNoIGV4Y2VwdGlvbiB3aGVuIHNvdXJjZSBoYXNuJ3QgYmVlbiBzdGFydGVkLi4uICovIH1cclxuICAgICAgdGhpcy5wbGF5aW5nID0gX29uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5zZXJ0cyBBdWRpb05vZGVzIGJldHdlZW4gdGhlIHBhbm5lciBhbmQgdGhlIGxvY2FsIGdhaW4gb2YgdGhpcyB7QGxpbmsgQ29tcG9uZW50QXVkaW99XHJcbiAgICAgKiBfaW5wdXQgYW5kIF9vdXRwdXQgbWF5IGJlIHRoZSBzYW1lIEF1ZGlvTm9kZSwgaWYgdGhlcmUgaXMgb25seSBvbmUgdG8gaW5zZXJ0LFxyXG4gICAgICogb3IgbWF5IGhhdmUgbXVsdGlwbGUgQXVkaW9Ob2RlIGJldHdlZW4gdGhlbSB0byBjcmVhdGUgYW4gZWZmZWN0LWdyYXBoLlxcXHJcbiAgICAgKiBOb3RlIHRoYXQge0BsaW5rIENvbXBvbmVudEF1ZGlvfSBkb2VzIG5vdCBrZWVwIHRyYWNrIG9mIGluc2VydGVkIEF1ZGlvTm9kZXMhXHJcbiAgICAgKiBgYGBwbGFpbnRleHRcclxuICAgICAqIOKUjCBBdWRpb01hbmFnZXIoLmRlZmF1bHQpIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxyXG4gICAgICog4pSCIOKUjCBDb21wb25lbnRBdWRpbyDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJAgICAgICAgICAg4pSCXHJcbiAgICAgKiDilIIg4pSCICAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgICAgICAgICDilIzilIDilIDilIDilIDilIDilIDilIDilJAgICDilIzilIDilIDilIDilIDilIDilIDilJAg4pSCIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUkCDilIIgIFxyXG4gICAgICog4pSCIOKUgiAgICDilIJzb3VyY2XilIIg4oaSIOKUgnBhbm5lcuKUgiDihpIg4pSCX2lucHV04pSCIOKGkiAuLi4gIOKGkiDilIJfb3V0cHV04pSCIOKGkiDilIIgZ2FpbiDilIIg4oaSIOKUgiBnYWluIOKUgiDilIJcclxuICAgICAqIOKUgiDilIIgICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSYICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSYICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSYICAgICAgICAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUmCDilIIg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSYIOKUgiAgXHJcbiAgICAgKiDilIIg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYICAgICAgICAgIOKUglxyXG4gICAgICog4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGluc2VydEF1ZGlvTm9kZXMoX2lucHV0OiBBdWRpb05vZGUsIF9vdXRwdXQ6IEF1ZGlvTm9kZSk6IHZvaWQge1xyXG4gICAgICB0aGlzLnBhbm5lci5kaXNjb25uZWN0KDApO1xyXG4gICAgICBpZiAoIV9pbnB1dCAmJiAhX291dHB1dCkge1xyXG4gICAgICAgIHRoaXMucGFubmVyLmNvbm5lY3QodGhpcy5nYWluKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5wYW5uZXIuY29ubmVjdChfaW5wdXQpO1xyXG4gICAgICBfb3V0cHV0LmNvbm5lY3QodGhpcy5nYWluKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFjdGl2YXRlIG92ZXJyaWRlLiBDb25uZWN0cyBvciBkaXNjb25uZWN0cyBBdWRpb05vZGVzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhY3RpdmF0ZShfb246IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgc3VwZXIuYWN0aXZhdGUoX29uKTtcclxuICAgICAgdGhpcy51cGRhdGVDb25uZWN0aW9uKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25uZWN0cyB0aGlzIGNvbXBvbmVudHMgZ2Fpbi1ub2RlIHRvIHRoZSBnYWluIG5vZGUgb2YgdGhlIEF1ZGlvTWFuYWdlciB0aGlzIGNvbXBvbmVudCBydW5zIG9uLlxyXG4gICAgICogT25seSBjYWxsIHRoaXMgbWV0aG9kIGlmIHRoZSBjb21wb25lbnQgaXMgbm90IGF0dGFjaGVkIHRvIGEge0BsaW5rIE5vZGV9IGJ1dCBuZWVkcyB0byBiZSBoZWFyZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGNvbm5lY3QoX29uOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgIGlmIChfb24pXHJcbiAgICAgICAgdGhpcy5nYWluLmNvbm5lY3QodGhpcy5hdWRpb01hbmFnZXIuZ2Fpbik7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICB0aGlzLmdhaW4uZGlzY29ubmVjdCh0aGlzLmF1ZGlvTWFuYWdlci5nYWluKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24uaWRSZXNvdXJjZSA9IHRoaXMuYXVkaW8uaWRSZXNvdXJjZTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5wbGF5aW5nID0gdGhpcy5wbGF5aW5nO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLmxvb3AgPSB0aGlzLmxvb3A7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24udm9sdW1lID0gdGhpcy52b2x1bWU7XHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuZ2V0TXV0YXRvck9mTm9kZShBVURJT19OT0RFX1RZUEUuUEFOTkVSKSk7XHJcbiAgICAgIC8vIFRPRE86IHNlcmlhbGl6ZSBwYW5uZXIgcGFyYW1ldGVyc1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgbGV0IGF1ZGlvOiBBdWRpbyA9IDxBdWRpbz5hd2FpdCBQcm9qZWN0LmdldFJlc291cmNlKF9zZXJpYWxpemF0aW9uLmlkUmVzb3VyY2UpO1xyXG4gICAgICB0aGlzLmNyZWF0ZVNvdXJjZShhdWRpbywgX3NlcmlhbGl6YXRpb24ubG9vcCk7XHJcbiAgICAgIHRoaXMudm9sdW1lID0gX3NlcmlhbGl6YXRpb24udm9sdW1lO1xyXG4gICAgICB0aGlzLnBsYXkoX3NlcmlhbGl6YXRpb24ucGxheWluZyk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHN1cGVyLmdldE11dGF0b3IodHJ1ZSk7XHJcbiAgICAgIGxldCBhdWRpbzogTXV0YXRvciA9IG11dGF0b3IuYXVkaW87XHJcbiAgICAgIGRlbGV0ZSBtdXRhdG9yLmF1ZGlvOyAvLyBqdXN0IHRvIHJlYXJyYW5nZSBpbiBpbnRlcmZhY2VzLi4uXHJcbiAgICAgIG11dGF0b3IubG9vcCA9IHRoaXMubG9vcDtcclxuICAgICAgbXV0YXRvci52b2x1bWUgPSB0aGlzLnZvbHVtZTtcclxuICAgICAgbXV0YXRvci5hdWRpbyA9IGF1ZGlvOyAvLy4uLiBzbyBhdWRpbyBjb21lcyBsYXN0XHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgYXdhaXQgc3VwZXIubXV0YXRlKF9tdXRhdG9yKTtcclxuICAgICAgdGhpcy52b2x1bWUgPSBfbXV0YXRvci52b2x1bWU7XHJcbiAgICAgIHRoaXMubG9vcCA9IF9tdXRhdG9yLmxvb3A7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgc3VwZXIucmVkdWNlTXV0YXRvcihfbXV0YXRvcik7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5saXN0ZW5lZDtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuXHJcbiAgICBwcml2YXRlIGhuZEF1ZGlvUmVhZHk6IEV2ZW50TGlzdGVuZXIgPSAoX2V2ZW50OiBFdmVudCkgPT4ge1xyXG4gICAgICBEZWJ1Zy5mdWRnZShcIkF1ZGlvIHN0YXJ0XCIsIFJlZmxlY3QuZ2V0KF9ldmVudC50YXJnZXQsIFwidXJsXCIpKTtcclxuICAgICAgaWYgKHRoaXMucGxheWluZylcclxuICAgICAgICB0aGlzLnBsYXkodHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBobmRBdWRpb0VuZGVkOiBFdmVudExpc3RlbmVyID0gKF9ldmVudDogRXZlbnQpID0+IHtcclxuICAgICAgLy8gRGVidWcuZnVkZ2UoXCJBdWRpbyBlbmRlZFwiLCBSZWZsZWN0LmdldChfZXZlbnQudGFyZ2V0LCBcInVybFwiKSk7XHJcbiAgICAgIHRoaXMucGxheWluZyA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaW5zdGFsbChfYXVkaW9NYW5hZ2VyOiBBdWRpb01hbmFnZXIgPSBBdWRpb01hbmFnZXIuZGVmYXVsdCk6IHZvaWQge1xyXG4gICAgICBsZXQgYWN0aXZlOiBib29sZWFuID0gdGhpcy5pc0FjdGl2ZTtcclxuICAgICAgdGhpcy5hY3RpdmF0ZShmYWxzZSk7XHJcbiAgICAgIHRoaXMuYXVkaW9NYW5hZ2VyID0gX2F1ZGlvTWFuYWdlcjtcclxuICAgICAgdGhpcy5wYW5uZXIgPSBfYXVkaW9NYW5hZ2VyLmNyZWF0ZVBhbm5lcigpO1xyXG4gICAgICB0aGlzLmdhaW4gPSBfYXVkaW9NYW5hZ2VyLmNyZWF0ZUdhaW4oKTtcclxuICAgICAgdGhpcy5wYW5uZXIuY29ubmVjdCh0aGlzLmdhaW4pO1xyXG4gICAgICB0aGlzLmdhaW4uY29ubmVjdChfYXVkaW9NYW5hZ2VyLmdhaW4pO1xyXG4gICAgICB0aGlzLmFjdGl2YXRlKGFjdGl2ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBjcmVhdGVTb3VyY2UoX2F1ZGlvOiBBdWRpbywgX2xvb3A6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgaWYgKHRoaXMuc291cmNlKSB7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgIHRoaXMuc291cmNlLmJ1ZmZlciA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5zb3VyY2UgPSB0aGlzLmF1ZGlvTWFuYWdlci5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcclxuICAgICAgdGhpcy5zb3VyY2UuY29ubmVjdCh0aGlzLnBhbm5lcik7XHJcblxyXG4gICAgICBpZiAoX2F1ZGlvKSB7XHJcbiAgICAgICAgdGhpcy5hdWRpbyA9IF9hdWRpbztcclxuICAgICAgICB0aGlzLnNvdXJjZS5idWZmZXIgPSBfYXVkaW8uYnVmZmVyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnNvdXJjZS5sb29wID0gX2xvb3A7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSB1cGRhdGVDb25uZWN0aW9uKCk6IHZvaWQge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuY29ubmVjdCh0aGlzLmlzQWN0aXZlICYmIHRoaXMuaXNBdHRhY2hlZCAmJiB0aGlzLmxpc3RlbmVkKTtcclxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XHJcbiAgICAgICAgLy8gbm9wXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBBdXRvbWF0aWNhbGx5IGNvbm5lY3RzL2Rpc2Nvbm5lY3RzIEF1ZGlvTm9kZXMgd2hlbiBhZGRpbmcvcmVtb3ZpbmcgdGhpcyBjb21wb25lbnQgdG8vZnJvbSBhIG5vZGUuIFxyXG4gICAgICogVGhlcmVmb3JlIHVudXNlZCBBdWRpb05vZGVzIG1heSBiZSBnYXJiYWdlIGNvbGxlY3RlZCB3aGVuIGFuIHVudXNlZCBjb21wb25lbnQgaXMgY29sbGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgaGFuZGxlQXR0YWNoID0gKF9ldmVudDogRXZlbnQpOiB2b2lkID0+IHtcclxuICAgICAgLy8gRGVidWcubG9nKF9ldmVudCk7XHJcbiAgICAgIGlmIChfZXZlbnQudHlwZSA9PSBFVkVOVC5DT01QT05FTlRfQUREKSB7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRfQVVESU8uQ0hJTERfQVBQRU5ELCB0aGlzLmhhbmRsZUdyYXBoLCB0cnVlKTtcclxuICAgICAgICB0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVF9BVURJTy5DSElMRF9SRU1PVkUsIHRoaXMuaGFuZGxlR3JhcGgsIHRydWUpO1xyXG4gICAgICAgIHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKEVWRU5UX0FVRElPLlVQREFURSwgdGhpcy51cGRhdGUsIHRydWUpO1xyXG4gICAgICAgIHRoaXMubGlzdGVuZWQgPSB0aGlzLm5vZGUuaXNEZXNjZW5kYW50T2YoQXVkaW9NYW5hZ2VyLmRlZmF1bHQuZ2V0R3JhcGhMaXN0ZW5pbmdUbygpKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICB0aGlzLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVF9BVURJTy5DSElMRF9BUFBFTkQsIHRoaXMuaGFuZGxlR3JhcGgsIHRydWUpO1xyXG4gICAgICAgIHRoaXMubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5UX0FVRElPLkNISUxEX1JFTU9WRSwgdGhpcy5oYW5kbGVHcmFwaCwgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlRfQVVESU8uVVBEQVRFLCB0aGlzLnVwZGF0ZSwgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lZCA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMudXBkYXRlQ29ubmVjdGlvbigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEF1dG9tYXRpY2FsbHkgY29ubmVjdHMvZGlzY29ubmVjdHMgQXVkaW9Ob2RlcyB3aGVuIGFwcGVuZGluZy9yZW1vdmluZyB0aGUgRlVER0UtZ3JhcGggdGhlIGNvbXBvbmVudCBpcyBpbi4gXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgaGFuZGxlR3JhcGggPSAoX2V2ZW50OiBFdmVudCk6IHZvaWQgPT4ge1xyXG4gICAgICAvLyBEZWJ1Zy5sb2coX2V2ZW50KTtcclxuICAgICAgdGhpcy5saXN0ZW5lZCA9IChfZXZlbnQudHlwZSA9PSBFVkVOVF9BVURJTy5DSElMRF9BUFBFTkQpO1xyXG4gICAgICB0aGlzLnVwZGF0ZUNvbm5lY3Rpb24oKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBwYW5uZXIgbm9kZSwgaXRzIHBvc2l0aW9uIGFuZCBkaXJlY3Rpb24sIHVzaW5nIHRoZSB3b3JsZG1hdHJpeCBvZiB0aGUgY29udGFpbmVyIGFuZCB0aGUgcGl2b3Qgb2YgdGhpcyBjb21wb25lbnQuIFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHVwZGF0ZSA9IChfZXZlbnQ6IEV2ZW50KTogdm9pZCA9PiB7XHJcbiAgICAgIGxldCBtdHhSZXN1bHQ6IE1hdHJpeDR4NCA9IHRoaXMubXR4UGl2b3Q7XHJcbiAgICAgIGlmICh0aGlzLm5vZGUpXHJcbiAgICAgICAgbXR4UmVzdWx0ID0gTWF0cml4NHg0Lk1VTFRJUExJQ0FUSU9OKHRoaXMubm9kZS5tdHhXb3JsZCwgdGhpcy5tdHhQaXZvdCk7XHJcblxyXG4gICAgICAvLyBEZWJ1Zy5sb2cobXR4UmVzdWx0LnRvU3RyaW5nKCkpO1xyXG4gICAgICBsZXQgcG9zaXRpb246IFZlY3RvcjMgPSBtdHhSZXN1bHQudHJhbnNsYXRpb247XHJcbiAgICAgIGxldCBmb3J3YXJkOiBWZWN0b3IzID0gVmVjdG9yMy5UUkFOU0ZPUk1BVElPTihWZWN0b3IzLlooMSksIG10eFJlc3VsdCwgZmFsc2UpO1xyXG5cclxuICAgICAgdGhpcy5wYW5uZXIucG9zaXRpb25YLnZhbHVlID0gcG9zaXRpb24ueDtcclxuICAgICAgdGhpcy5wYW5uZXIucG9zaXRpb25ZLnZhbHVlID0gcG9zaXRpb24ueTtcclxuICAgICAgdGhpcy5wYW5uZXIucG9zaXRpb25aLnZhbHVlID0gcG9zaXRpb24uejtcclxuXHJcbiAgICAgIHRoaXMucGFubmVyLm9yaWVudGF0aW9uWC52YWx1ZSA9IGZvcndhcmQueDtcclxuICAgICAgdGhpcy5wYW5uZXIub3JpZW50YXRpb25ZLnZhbHVlID0gZm9yd2FyZC55O1xyXG4gICAgICB0aGlzLnBhbm5lci5vcmllbnRhdGlvbloudmFsdWUgPSBmb3J3YXJkLno7XHJcblxyXG4gICAgICBSZWN5Y2xlci5zdG9yZShmb3J3YXJkKTtcclxuICAgICAgLy8gVE9ETzogZXhhbWluZSB3aHkgdGhlIGZvbGxvd2luZyBwcm9kdWNlcyBlcnJvbmVvdXMgcmVzdWx0cywgc2VlIHRlc3QgXCJTcGF0aWFsIEF1ZGlvXCJcclxuICAgICAgaWYgKHRoaXMubm9kZSlcclxuICAgICAgICBSZWN5Y2xlci5zdG9yZShtdHhSZXN1bHQpO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFNlcnZlcyB0byBzZXQgdGhlIHNwYXRpYWwgbG9jYXRpb24gYW5kIG9yaWVudGF0aW9uIG9mIEF1ZGlvTGlzdGVuZXJzIHJlbGF0aXZlIHRvIHRoZVxyXG4gICAqIHdvcmxkIHRyYW5zZm9ybSBvZiB0aGUge0BsaW5rIE5vZGV9IGl0IGlzIGF0dGFjaGVkIHRvLlxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIENvbXBvbmVudEF1ZGlvTGlzdGVuZXIgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IENvbXBvbmVudC5yZWdpc3RlclN1YmNsYXNzKENvbXBvbmVudEF1ZGlvTGlzdGVuZXIpO1xyXG4gICAgcHVibGljIG10eFBpdm90OiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIHBvc2l0aW9uIGFuZCBvcmllbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gQXVkaW9MaXN0ZW5lclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdXBkYXRlKF9saXN0ZW5lcjogQXVkaW9MaXN0ZW5lcik6IHZvaWQge1xyXG4gICAgICBsZXQgbXR4UmVzdWx0OiBNYXRyaXg0eDQgPSB0aGlzLm10eFBpdm90O1xyXG4gICAgICBpZiAodGhpcy5ub2RlKVxyXG4gICAgICAgIG10eFJlc3VsdCA9IE1hdHJpeDR4NC5NVUxUSVBMSUNBVElPTih0aGlzLm5vZGUubXR4V29ybGQsIHRoaXMubXR4UGl2b3QpO1xyXG5cclxuICAgICAgLy8gRGVidWcubG9nKG10eFJlc3VsdC50b1N0cmluZygpKTtcclxuICAgICAgbGV0IHBvc2l0aW9uOiBWZWN0b3IzID0gbXR4UmVzdWx0LnRyYW5zbGF0aW9uO1xyXG4gICAgICBsZXQgZm9yd2FyZDogVmVjdG9yMyA9IFZlY3RvcjMuVFJBTlNGT1JNQVRJT04oVmVjdG9yMy5aKDEpLCBtdHhSZXN1bHQsIGZhbHNlKTtcclxuICAgICAgbGV0IHVwOiBWZWN0b3IzID0gVmVjdG9yMy5UUkFOU0ZPUk1BVElPTihWZWN0b3IzLlkoKSwgbXR4UmVzdWx0LCBmYWxzZSk7XHJcblxyXG4gICAgICBpZiAoX2xpc3RlbmVyLnBvc2l0aW9uWCAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICBfbGlzdGVuZXIucG9zaXRpb25YLnZhbHVlID0gcG9zaXRpb24ueDtcclxuICAgICAgICBfbGlzdGVuZXIucG9zaXRpb25ZLnZhbHVlID0gcG9zaXRpb24ueTtcclxuICAgICAgICBfbGlzdGVuZXIucG9zaXRpb25aLnZhbHVlID0gcG9zaXRpb24uejtcclxuXHJcbiAgICAgICAgX2xpc3RlbmVyLmZvcndhcmRYLnZhbHVlID0gZm9yd2FyZC54O1xyXG4gICAgICAgIF9saXN0ZW5lci5mb3J3YXJkWS52YWx1ZSA9IGZvcndhcmQueTtcclxuICAgICAgICBfbGlzdGVuZXIuZm9yd2FyZFoudmFsdWUgPSBmb3J3YXJkLno7XHJcblxyXG4gICAgICAgIF9saXN0ZW5lci51cFgudmFsdWUgPSB1cC54O1xyXG4gICAgICAgIF9saXN0ZW5lci51cFkudmFsdWUgPSB1cC55O1xyXG4gICAgICAgIF9saXN0ZW5lci51cFoudmFsdWUgPSB1cC56O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIEZpcmVmb3ggc3RpbGwgdXNlcyBkZXByZWNhdGVkIG1ldGhvZHMuIFRPRE86IGRlbGV0ZSBhcyBzb29uIGFzIHBvc3NpYmxlIVxyXG4gICAgICAgIF9saXN0ZW5lci5zZXRQb3NpdGlvbihwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56KTtcclxuICAgICAgICBfbGlzdGVuZXIuc2V0T3JpZW50YXRpb24oZm9yd2FyZC54LCBmb3J3YXJkLnksIGZvcndhcmQueiwgdXAueCwgdXAueSwgdXAueik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKGZvcndhcmQpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZSh1cCk7XHJcblxyXG4gICAgICAvLyBEZWJ1Zy5sb2cobXR4UmVzdWx0LnRyYW5zbGF0aW9uLnRvU3RyaW5nKCksIGZvcndhcmQudG9TdHJpbmcoKSwgdXAudG9TdHJpbmcoKSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsIi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiQ29tcG9uZW50LnRzXCIvPlxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgZW51bSBGSUVMRF9PRl9WSUVXIHtcclxuICAgIEhPUklaT05UQUwsIFZFUlRJQ0FMLCBESUFHT05BTFxyXG4gIH1cclxuICAvKipcclxuICAgKiBEZWZpbmVzIGlkZW50aWZpZXJzIGZvciB0aGUgdmFyaW91cyBwcm9qZWN0aW9ucyBhIGNhbWVyYSBjYW4gcHJvdmlkZS4gIFxyXG4gICAqIFRPRE86IGNoYW5nZSBiYWNrIHRvIG51bWJlciBlbnVtIGlmIHN0cmluZ3Mgbm90IG5lZWRlZFxyXG4gICAqL1xyXG4gIGV4cG9ydCBlbnVtIFBST0pFQ1RJT04ge1xyXG4gICAgQ0VOVFJBTCA9IFwiY2VudHJhbFwiLFxyXG4gICAgT1JUSE9HUkFQSElDID0gXCJvcnRob2dyYXBoaWNcIixcclxuICAgIERJTUVUUklDID0gXCJkaW1ldHJpY1wiLFxyXG4gICAgU1RFUkVPID0gXCJzdGVyZW9cIlxyXG4gIH1cclxuICAvKipcclxuICAgKiBUaGUgY2FtZXJhIGNvbXBvbmVudCBob2xkcyB0aGUgcHJvamVjdGlvbi1tYXRyaXggYW5kIG90aGVyIGRhdGEgbmVlZGVkIHRvIHJlbmRlciBhIHNjZW5lIGZyb20gdGhlIHBlcnNwZWN0aXZlIG9mIHRoZSBub2RlIGl0IGlzIGF0dGFjaGVkIHRvLlxyXG4gICAqIEBhdXRob3JzIEphc2NoYSBLYXJhZ8O2bCwgSEZVLCAyMDE5IHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29tcG9uZW50Q2FtZXJhIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRDYW1lcmEpO1xyXG4gICAgcHVibGljIG10eFBpdm90OiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKTtcclxuICAgIHB1YmxpYyBjbHJCYWNrZ3JvdW5kOiBDb2xvciA9IG5ldyBDb2xvcigwLCAwLCAwLCAxKTsgLy8gVGhlIGNvbG9yIG9mIHRoZSBiYWNrZ3JvdW5kIHRoZSBjYW1lcmEgd2lsbCByZW5kZXIuXHJcbiAgICAvL3ByaXZhdGUgb3J0aG9ncmFwaGljOiBib29sZWFuID0gZmFsc2U7IC8vIERldGVybWluZXMgd2hldGhlciB0aGUgaW1hZ2Ugd2lsbCBiZSByZW5kZXJlZCB3aXRoIHBlcnNwZWN0aXZlIG9yIG9ydGhvZ3JhcGhpYyBwcm9qZWN0aW9uLlxyXG4gICAgI210eFdvcmxkVG9WaWV3OiBNYXRyaXg0eDQ7XHJcbiAgICBwcml2YXRlIHByb2plY3Rpb246IFBST0pFQ1RJT04gPSBQUk9KRUNUSU9OLkNFTlRSQUw7XHJcbiAgICBwcml2YXRlIG10eFByb2plY3Rpb246IE1hdHJpeDR4NCA9IG5ldyBNYXRyaXg0eDQ7IC8vIFRoZSBtYXRyaXggdG8gbXVsdGlwbHkgZWFjaCBzY2VuZSBvYmplY3RzIHRyYW5zZm9ybWF0aW9uIGJ5LCB0byBkZXRlcm1pbmUgd2hlcmUgaXQgd2lsbCBiZSBkcmF3bi5cclxuICAgIHByaXZhdGUgZmllbGRPZlZpZXc6IG51bWJlciA9IDQ1OyAvLyBUaGUgY2FtZXJhJ3Mgc2Vuc29yYW5nbGUuXHJcbiAgICBwcml2YXRlIGFzcGVjdFJhdGlvOiBudW1iZXIgPSAxLjA7XHJcbiAgICBwcml2YXRlIGRpcmVjdGlvbjogRklFTERfT0ZfVklFVyA9IEZJRUxEX09GX1ZJRVcuRElBR09OQUw7XHJcbiAgICBwcml2YXRlIG5lYXI6IG51bWJlciA9IDE7XHJcbiAgICBwcml2YXRlIGZhcjogbnVtYmVyID0gMjAwMDtcclxuICAgIHByaXZhdGUgYmFja2dyb3VuZEVuYWJsZWQ6IGJvb2xlYW4gPSB0cnVlOyAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHRoZSBiYWNrZ3JvdW5kIG9mIHRoaXMgY2FtZXJhIHdpbGwgYmUgcmVuZGVyZWQuXHJcbiAgICAvLyBUT0RPOiBleGFtaW5lLCBpZiBiYWNrZ3JvdW5kIHNob3VsZCBiZSBhbiBhdHRyaWJ1dGUgb2YgQ2FtZXJhIG9yIFZpZXdwb3J0XHJcblxyXG4gICAgcHVibGljIGdldCBtdHhXb3JsZCgpOiBNYXRyaXg0eDQge1xyXG4gICAgICBsZXQgbXR4Q2FtZXJhOiBNYXRyaXg0eDQgPSB0aGlzLm10eFBpdm90LmNsb25lO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIG10eENhbWVyYSA9IE1hdHJpeDR4NC5NVUxUSVBMSUNBVElPTih0aGlzLm5vZGUubXR4V29ybGQsIHRoaXMubXR4UGl2b3QpO1xyXG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHsgICBcclxuICAgICAgICAvLyBubyBjb250YWluZXIgbm9kZSBvciBubyB3b3JsZCB0cmFuc2Zvcm1hdGlvbiBmb3VuZCAtPiBjb250aW51ZSB3aXRoIHBpdm90IG9ubHlcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbXR4Q2FtZXJhO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBtdWx0aXBsaWNhdGlvbiBvZiB0aGUgd29ybGR0cmFuc2Zvcm1hdGlvbiBvZiB0aGUgY2FtZXJhIGNvbnRhaW5lciwgdGhlIHBpdm90IG9mIHRoaXMgY2FtZXJhIGFuZCB0aGUgaW52ZXJzaW9uIG9mIHRoZSBwcm9qZWN0aW9uIG1hdHJpeFxyXG4gICAgICogeWllbGRpbmcgdGhlIHdvcmxkc3BhY2UgdG8gdmlld3NwYWNlIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG10eFdvcmxkVG9WaWV3KCk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIGlmICh0aGlzLiNtdHhXb3JsZFRvVmlldyApXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuI210eFdvcmxkVG9WaWV3O1xyXG4gICAgICAgIFxyXG4gICAgICAvL1RPRE86IG9wdGltaXplLCBubyBuZWVkIHRvIHJlY2FsY3VsYXRlIGlmIG5laXRoZXIgbXR4V29ybGQgbm9yIHBpdm90IGhhdmUgY2hhbmdlZFxyXG4gICAgICBsZXQgbXR4Q2FtZXJhOiBNYXRyaXg0eDQgPSB0aGlzLm10eFdvcmxkO1xyXG4gICAgICBsZXQgbXR4SW52ZXJzaW9uOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSU5WRVJTSU9OKG10eENhbWVyYSk7XHJcbiAgICAgIHRoaXMuI210eFdvcmxkVG9WaWV3ID0gTWF0cml4NHg0Lk1VTFRJUExJQ0FUSU9OKHRoaXMubXR4UHJvamVjdGlvbiwgbXR4SW52ZXJzaW9uKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUobXR4Q2FtZXJhKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUobXR4SW52ZXJzaW9uKTtcclxuICAgICAgXHJcbiAgICAgIHJldHVybiB0aGlzLiNtdHhXb3JsZFRvVmlldztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVzZXRXb3JsZFRvVmlldygpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jbXR4V29ybGRUb1ZpZXcgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRQcm9qZWN0aW9uKCk6IFBST0pFQ1RJT04ge1xyXG4gICAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRCYWNrZ3JvdW5kRW5hYmxlZCgpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYmFja2dyb3VuZEVuYWJsZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEFzcGVjdCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5hc3BlY3RSYXRpbztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0RmllbGRPZlZpZXcoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZmllbGRPZlZpZXc7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldERpcmVjdGlvbigpOiBGSUVMRF9PRl9WSUVXIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXROZWFyKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLm5lYXI7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgZ2V0RmFyKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmZhcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgY2FtZXJhIHRvIHBlcnNwZWN0aXZlIHByb2plY3Rpb24uIFRoZSB3b3JsZCBvcmlnaW4gaXMgaW4gdGhlIGNlbnRlciBvZiB0aGUgY2FudmFzZWxlbWVudC5cclxuICAgICAqIEBwYXJhbSBfYXNwZWN0IFRoZSBhc3BlY3QgcmF0aW8gYmV0d2VlbiB3aWR0aCBhbmQgaGVpZ2h0IG9mIHByb2plY3Rpb25zcGFjZS4oRGVmYXVsdCA9IGNhbnZhcy5jbGllbnRXaWR0aCAvIGNhbnZhcy5DbGllbnRIZWlnaHQpXHJcbiAgICAgKiBAcGFyYW0gX2ZpZWxkT2ZWaWV3IFRoZSBmaWVsZCBvZiB2aWV3IGluIERlZ3JlZXMuIChEZWZhdWx0ID0gNDUpXHJcbiAgICAgKiBAcGFyYW0gX2RpcmVjdGlvbiBUaGUgcGxhbmUgb24gd2hpY2ggdGhlIGZpZWxkT2ZWaWV3LUFuZ2xlIGlzIGdpdmVuIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcHJvamVjdENlbnRyYWwoX2FzcGVjdDogbnVtYmVyID0gdGhpcy5hc3BlY3RSYXRpbywgX2ZpZWxkT2ZWaWV3OiBudW1iZXIgPSB0aGlzLmZpZWxkT2ZWaWV3LCBfZGlyZWN0aW9uOiBGSUVMRF9PRl9WSUVXID0gdGhpcy5kaXJlY3Rpb24sIF9uZWFyOiBudW1iZXIgPSAxLCBfZmFyOiBudW1iZXIgPSAyMDAwKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuYXNwZWN0UmF0aW8gPSBfYXNwZWN0O1xyXG4gICAgICB0aGlzLmZpZWxkT2ZWaWV3ID0gX2ZpZWxkT2ZWaWV3O1xyXG4gICAgICB0aGlzLmRpcmVjdGlvbiA9IF9kaXJlY3Rpb247XHJcbiAgICAgIHRoaXMucHJvamVjdGlvbiA9IFBST0pFQ1RJT04uQ0VOVFJBTDtcclxuICAgICAgdGhpcy5uZWFyID0gX25lYXI7XHJcbiAgICAgIHRoaXMuZmFyID0gX2ZhcjtcclxuICAgICAgdGhpcy5tdHhQcm9qZWN0aW9uID0gTWF0cml4NHg0LlBST0pFQ1RJT05fQ0VOVFJBTChfYXNwZWN0LCB0aGlzLmZpZWxkT2ZWaWV3LCBfbmVhciwgX2ZhciwgdGhpcy5kaXJlY3Rpb24pOyAvLyBUT0RPOiByZW1vdmUgbWFnaWMgbnVtYmVyc1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGNhbWVyYSB0byBvcnRob2dyYXBoaWMgcHJvamVjdGlvbi4gVGhlIG9yaWdpbiBpcyBpbiB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXMuXHJcbiAgICAgKiBAcGFyYW0gX2xlZnQgVGhlIHBvc2l0aW9udmFsdWUgb2YgdGhlIHByb2plY3Rpb25zcGFjZSdzIGxlZnQgYm9yZGVyLiAoRGVmYXVsdCA9IDApXHJcbiAgICAgKiBAcGFyYW0gX3JpZ2h0IFRoZSBwb3NpdGlvbnZhbHVlIG9mIHRoZSBwcm9qZWN0aW9uc3BhY2UncyByaWdodCBib3JkZXIuIChEZWZhdWx0ID0gY2FudmFzLmNsaWVudFdpZHRoKVxyXG4gICAgICogQHBhcmFtIF9ib3R0b20gVGhlIHBvc2l0aW9udmFsdWUgb2YgdGhlIHByb2plY3Rpb25zcGFjZSdzIGJvdHRvbSBib3JkZXIuKERlZmF1bHQgPSBjYW52YXMuY2xpZW50SGVpZ2h0KVxyXG4gICAgICogQHBhcmFtIF90b3AgVGhlIHBvc2l0aW9udmFsdWUgb2YgdGhlIHByb2plY3Rpb25zcGFjZSdzIHRvcCBib3JkZXIuKERlZmF1bHQgPSAwKVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcHJvamVjdE9ydGhvZ3JhcGhpYyhfbGVmdDogbnVtYmVyID0gMCwgX3JpZ2h0OiBudW1iZXIgPSBSZW5kZXIuZ2V0Q2FudmFzKCkuY2xpZW50V2lkdGgsIF9ib3R0b206IG51bWJlciA9IFJlbmRlci5nZXRDYW52YXMoKS5jbGllbnRIZWlnaHQsIF90b3A6IG51bWJlciA9IDApOiB2b2lkIHtcclxuICAgICAgdGhpcy5wcm9qZWN0aW9uID0gUFJPSkVDVElPTi5PUlRIT0dSQVBISUM7XHJcbiAgICAgIHRoaXMubXR4UHJvamVjdGlvbiA9IE1hdHJpeDR4NC5QUk9KRUNUSU9OX09SVEhPR1JBUEhJQyhfbGVmdCwgX3JpZ2h0LCBfYm90dG9tLCBfdG9wLCA0MDAsIC00MDApOyAvLyBUT0RPOiBleGFtaW5lIG1hZ2ljIG51bWJlcnMhXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIGNhbGN1bGF0ZWQgZGltZW5zaW9uIG9mIGEgcHJvamVjdGlvbiBzdXJmYWNlIGluIHRoZSBoeXBvdGhldGljYWwgZGlzdGFuY2Ugb2YgMSB0byB0aGUgY2FtZXJhXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRQcm9qZWN0aW9uUmVjdGFuZ2xlKCk6IFJlY3RhbmdsZSB7XHJcbiAgICAgIGxldCB0YW5Gb3Y6IG51bWJlciA9IE1hdGgudGFuKE1hdGguUEkgKiB0aGlzLmZpZWxkT2ZWaWV3IC8gMzYwKTsgLy8gSGFsZiBvZiB0aGUgYW5nbGUsIHRvIGNhbGN1bGF0ZSBkaW1lbnNpb24gZnJvbSB0aGUgY2VudGVyIC0+IHJpZ2h0IGFuZ2xlXHJcbiAgICAgIGxldCB0YW5Ib3Jpem9udGFsOiBudW1iZXIgPSAwO1xyXG4gICAgICBsZXQgdGFuVmVydGljYWw6IG51bWJlciA9IDA7XHJcblxyXG4gICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT0gRklFTERfT0ZfVklFVy5ESUFHT05BTCkge1xyXG4gICAgICAgIGxldCBhc3BlY3Q6IG51bWJlciA9IE1hdGguc3FydCh0aGlzLmFzcGVjdFJhdGlvKTtcclxuICAgICAgICB0YW5Ib3Jpem9udGFsID0gdGFuRm92ICogYXNwZWN0O1xyXG4gICAgICAgIHRhblZlcnRpY2FsID0gdGFuRm92IC8gYXNwZWN0O1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKHRoaXMuZGlyZWN0aW9uID09IEZJRUxEX09GX1ZJRVcuVkVSVElDQUwpIHtcclxuICAgICAgICB0YW5WZXJ0aWNhbCA9IHRhbkZvdjtcclxuICAgICAgICB0YW5Ib3Jpem9udGFsID0gdGFuVmVydGljYWwgKiB0aGlzLmFzcGVjdFJhdGlvO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Ugey8vRk9WX0RJUkVDVElPTi5IT1JJWk9OVEFMXHJcbiAgICAgICAgdGFuSG9yaXpvbnRhbCA9IHRhbkZvdjtcclxuICAgICAgICB0YW5WZXJ0aWNhbCA9IHRhbkhvcml6b250YWwgLyB0aGlzLmFzcGVjdFJhdGlvO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gUmVjdGFuZ2xlLkdFVCgwLCAwLCB0YW5Ib3Jpem9udGFsICogMiwgdGFuVmVydGljYWwgKiAyKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcG9pbnRXb3JsZFRvQ2xpcChfcG9pbnRJbldvcmxkU3BhY2U6IFZlY3RvcjMpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMztcclxuICAgICAgbGV0IG06IEZsb2F0MzJBcnJheSA9IHRoaXMubXR4V29ybGRUb1ZpZXcuZ2V0KCk7XHJcbiAgICAgIGxldCB3OiBudW1iZXIgPSBtWzNdICogX3BvaW50SW5Xb3JsZFNwYWNlLnggKyBtWzddICogX3BvaW50SW5Xb3JsZFNwYWNlLnkgKyBtWzExXSAqIF9wb2ludEluV29ybGRTcGFjZS56ICsgbVsxNV07XHJcblxyXG4gICAgICByZXN1bHQgPSBWZWN0b3IzLlRSQU5TRk9STUFUSU9OKF9wb2ludEluV29ybGRTcGFjZSwgdGhpcy5tdHhXb3JsZFRvVmlldyk7XHJcbiAgICAgIHJlc3VsdC5zY2FsZSgxIC8gdyk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHBvaW50Q2xpcFRvV29ybGQoX3BvaW50SW5DbGlwU3BhY2U6IFZlY3RvcjMpOiBWZWN0b3IzIHsgICAgICBcclxuICAgICAgbGV0IG10eFZpZXdUb1dvcmxkOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSU5WRVJTSU9OKHRoaXMubXR4V29ybGRUb1ZpZXcpO1xyXG4gICAgICBsZXQgbTogRmxvYXQzMkFycmF5ID0gbXR4Vmlld1RvV29ybGQuZ2V0KCk7XHJcbiAgICAgIGxldCByYXlXb3JsZDogVmVjdG9yMyA9IFZlY3RvcjMuVFJBTlNGT1JNQVRJT04oX3BvaW50SW5DbGlwU3BhY2UsIG10eFZpZXdUb1dvcmxkLCB0cnVlKTtcclxuICAgICAgbGV0IHc6IG51bWJlciA9IG1bM10gKiBfcG9pbnRJbkNsaXBTcGFjZS54ICsgbVs3XSAqIF9wb2ludEluQ2xpcFNwYWNlLnkgKyBtWzExXSAqIF9wb2ludEluQ2xpcFNwYWNlLnogKyBtWzE1XTtcclxuICAgICAgcmF5V29ybGQuc2NhbGUoMSAvIHcpO1xyXG5cclxuICAgICAgcmV0dXJuIHJheVdvcmxkO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLmNsckJhY2tncm91bmQsXHJcbiAgICAgICAgYmFja2dyb3VuZEVuYWJsZWQ6IHRoaXMuYmFja2dyb3VuZEVuYWJsZWQsXHJcbiAgICAgICAgcHJvamVjdGlvbjogdGhpcy5wcm9qZWN0aW9uLFxyXG4gICAgICAgIGZpZWxkT2ZWaWV3OiB0aGlzLmZpZWxkT2ZWaWV3LFxyXG4gICAgICAgIGRpcmVjdGlvbjogdGhpcy5kaXJlY3Rpb24sXHJcbiAgICAgICAgYXNwZWN0OiB0aGlzLmFzcGVjdFJhdGlvLFxyXG4gICAgICAgIHBpdm90OiB0aGlzLm10eFBpdm90LnNlcmlhbGl6ZSgpLFxyXG4gICAgICAgIFtzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXTogc3VwZXIuc2VyaWFsaXplKClcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgdGhpcy5jbHJCYWNrZ3JvdW5kID0gX3NlcmlhbGl6YXRpb24uYmFja2dyb3VuZENvbG9yO1xyXG4gICAgICB0aGlzLmJhY2tncm91bmRFbmFibGVkID0gX3NlcmlhbGl6YXRpb24uYmFja2dyb3VuZEVuYWJsZWQ7XHJcbiAgICAgIHRoaXMucHJvamVjdGlvbiA9IF9zZXJpYWxpemF0aW9uLnByb2plY3Rpb247XHJcbiAgICAgIHRoaXMuZmllbGRPZlZpZXcgPSBfc2VyaWFsaXphdGlvbi5maWVsZE9mVmlldztcclxuICAgICAgdGhpcy5hc3BlY3RSYXRpbyA9IF9zZXJpYWxpemF0aW9uLmFzcGVjdDtcclxuICAgICAgdGhpcy5kaXJlY3Rpb24gPSBfc2VyaWFsaXphdGlvbi5kaXJlY3Rpb247XHJcbiAgICAgIGF3YWl0IHRoaXMubXR4UGl2b3QuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24ucGl2b3QpO1xyXG4gICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XHJcbiAgICAgIHN3aXRjaCAodGhpcy5wcm9qZWN0aW9uKSB7XHJcbiAgICAgICAgY2FzZSBQUk9KRUNUSU9OLk9SVEhPR1JBUEhJQzpcclxuICAgICAgICAgIHRoaXMucHJvamVjdE9ydGhvZ3JhcGhpYygpOyAvLyBUT0RPOiBzZXJpYWxpemUgYW5kIGRlc2VyaWFsaXplIHBhcmFtZXRlcnNcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgUFJPSkVDVElPTi5DRU5UUkFMOlxyXG4gICAgICAgICAgdGhpcy5wcm9qZWN0Q2VudHJhbCgpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3JBdHRyaWJ1dGVUeXBlcyhfbXV0YXRvcjogTXV0YXRvcik6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyB7XHJcbiAgICAgIGxldCB0eXBlczogTXV0YXRvckF0dHJpYnV0ZVR5cGVzID0gc3VwZXIuZ2V0TXV0YXRvckF0dHJpYnV0ZVR5cGVzKF9tdXRhdG9yKTtcclxuICAgICAgaWYgKHR5cGVzLmRpcmVjdGlvbilcclxuICAgICAgICB0eXBlcy5kaXJlY3Rpb24gPSBGSUVMRF9PRl9WSUVXO1xyXG4gICAgICBpZiAodHlwZXMucHJvamVjdGlvbilcclxuICAgICAgICB0eXBlcy5wcm9qZWN0aW9uID0gUFJPSkVDVElPTjtcclxuICAgICAgcmV0dXJuIHR5cGVzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgc3VwZXIubXV0YXRlKF9tdXRhdG9yKTtcclxuXHJcbiAgICAgIHN3aXRjaCAodGhpcy5wcm9qZWN0aW9uKSB7XHJcbiAgICAgICAgY2FzZSBQUk9KRUNUSU9OLkNFTlRSQUw6XHJcbiAgICAgICAgICB0aGlzLnByb2plY3RDZW50cmFsKHRoaXMuYXNwZWN0UmF0aW8sIHRoaXMuZmllbGRPZlZpZXcsIHRoaXMuZGlyZWN0aW9uKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLnRyYW5zZm9ybTtcclxuICAgICAgc3VwZXIucmVkdWNlTXV0YXRvcihfbXV0YXRvcik7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgdHlwZSBUeXBlT2ZMaWdodCA9IG5ldyAoKSA9PiBMaWdodDtcclxuICAvKipcclxuICAgKiBCYXNlY2xhc3MgZm9yIGRpZmZlcmVudCBraW5kcyBvZiBsaWdodHMuIFxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIExpZ2h0IGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZSB7XHJcbiAgICBwdWJsaWMgY29sb3I6IENvbG9yO1xyXG4gICAgY29uc3RydWN0b3IoX2NvbG9yOiBDb2xvciA9IG5ldyBDb2xvcigxLCAxLCAxLCAxKSkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLmNvbG9yID0gX2NvbG9yO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRUeXBlKCk6IFR5cGVPZkxpZ2h0IHtcclxuICAgICAgcmV0dXJuIDxUeXBlT2ZMaWdodD50aGlzLmNvbnN0cnVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge1xyXG4gICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLnNlcmlhbGl6ZSgpXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGF3YWl0IHRoaXMuY29sb3IuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24uY29sb3IpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcigpOiB2b2lkIHsvKiovIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFtYmllbnQgbGlnaHQsIGNvbWluZyBmcm9tIGFsbCBkaXJlY3Rpb25zLCBpbGx1bWluYXRpbmcgZXZlcnl0aGluZyB3aXRoIGl0cyBjb2xvciBpbmRlcGVuZGVudCBvZiBwb3NpdGlvbiBhbmQgb3JpZW50YXRpb24gKGxpa2UgYSBmb2dneSBkYXkgb3IgaW4gdGhlIHNoYWRlcykgIFxyXG4gICAqIGBgYHBsYWludGV4dFxyXG4gICAqIH4gfiB+ICBcclxuICAgKiAgfiB+IH4gIFxyXG4gICAqIGBgYFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBMaWdodEFtYmllbnQgZXh0ZW5kcyBMaWdodCB7XHJcbiAgICBjb25zdHJ1Y3RvcihfY29sb3I6IENvbG9yID0gbmV3IENvbG9yKDEsIDEsIDEsIDEpKSB7XHJcbiAgICAgIHN1cGVyKF9jb2xvcik7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIERpcmVjdGlvbmFsIGxpZ2h0LCBpbGx1bWluYXRpbmcgZXZlcnl0aGluZyBmcm9tIGEgc3BlY2lmaWVkIGRpcmVjdGlvbiB3aXRoIGl0cyBjb2xvciAobGlrZSBzdGFuZGluZyBpbiBicmlnaHQgc3VubGlnaHQpICBcclxuICAgKiBgYGBwbGFpbnRleHRcclxuICAgKiAtLS0+ICBcclxuICAgKiAtLS0+ICBcclxuICAgKiAtLS0+ICBcclxuICAgKiBgYGBcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgTGlnaHREaXJlY3Rpb25hbCBleHRlbmRzIExpZ2h0IHtcclxuICAgIGNvbnN0cnVjdG9yKF9jb2xvcjogQ29sb3IgPSBuZXcgQ29sb3IoMSwgMSwgMSwgMSkpIHtcclxuICAgICAgc3VwZXIoX2NvbG9yKTtcclxuICAgIH1cclxuICB9XHJcbiAgLyoqXHJcbiAgICogT21uaWRpcmVjdGlvbmFsIGxpZ2h0IGVtaXR0aW5nIGZyb20gaXRzIHBvc2l0aW9uLCBpbGx1bWluYXRpbmcgb2JqZWN0cyBkZXBlbmRpbmcgb24gdGhlaXIgcG9zaXRpb24gYW5kIGRpc3RhbmNlIHdpdGggaXRzIGNvbG9yIChsaWtlIGEgY29sb3JlZCBsaWdodCBidWxiKSAgXHJcbiAgICogYGBgcGxhaW50ZXh0XHJcbiAgICogICAgICAgICAuXFx8Ly5cclxuICAgKiAgICAgICAgLS0gbyAtLVxyXG4gICAqICAgICAgICAgwrQvfFxcYFxyXG4gICAqIGBgYFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBMaWdodFBvaW50IGV4dGVuZHMgTGlnaHQge1xyXG4gICAgcHVibGljIHJhbmdlOiBudW1iZXIgPSAxMDtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogU3BvdCBsaWdodCBlbWl0dGluZyB3aXRoaW4gYSBzcGVjaWZpZWQgYW5nbGUgZnJvbSBpdHMgcG9zaXRpb24sIGlsbHVtaW5hdGluZyBvYmplY3RzIGRlcGVuZGluZyBvbiB0aGVpciBwb3NpdGlvbiBhbmQgZGlzdGFuY2Ugd2l0aCBpdHMgY29sb3IgIFxyXG4gICAqIGBgYHBsYWludGV4dFxyXG4gICAqICAgICAgICAgIG8gIFxyXG4gICAqICAgICAgICAgL3xcXCAgXHJcbiAgICogICAgICAgIC8gfCBcXCBcclxuICAgKiBgYGAgICBcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgTGlnaHRTcG90IGV4dGVuZHMgTGlnaHQge1xyXG4gIH1cclxufSIsIi8vLzxyZWZlcmVuY2UgcGF0aD1cIi4uL0xpZ2h0L0xpZ2h0LnRzXCIvPlxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuIFxyXG4gIC8qKlxyXG4gICAqIERlZmluZXMgaWRlbnRpZmllcnMgZm9yIHRoZSB2YXJpb3VzIHR5cGVzIG9mIGxpZ2h0IHRoaXMgY29tcG9uZW50IGNhbiBwcm92aWRlLiAgXHJcbiAgICovXHJcbiAgLy8gZXhwb3J0IGxldCBMSUdIVF9UWVBFOiB7IFt0eXBlOiBzdHJpbmddOiBzdHJpbmcgfSA9IHtcclxuICBleHBvcnQgZW51bSBMSUdIVF9UWVBFIHtcclxuICAgIEFNQklFTlQgPSBcIkxpZ2h0QW1iaWVudFwiLFxyXG4gICAgRElSRUNUSU9OQUwgPSBcIkxpZ2h0RGlyZWN0aW9uYWxcIixcclxuICAgIFBPSU5UID0gXCJMaWdodFBvaW50XCIsXHJcbiAgICBTUE9UID0gXCJMaWdodFNwb3RcIlxyXG4gIH1cclxuIC8qKlxyXG4gICAqIEF0dGFjaGVzIGEge0BsaW5rIExpZ2h0fSB0byB0aGUgbm9kZVxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIENvbXBvbmVudExpZ2h0IGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRMaWdodCk7XHJcbiAgICAvLyBwcml2YXRlIHN0YXRpYyBjb25zdHJ1Y3RvcnM6IHsgW3R5cGU6IHN0cmluZ106IEdlbmVyYWwgfSA9IHsgW0xJR0hUX1RZUEUuQU1CSUVOVF06IExpZ2h0QW1iaWVudCwgW0xJR0hUX1RZUEUuRElSRUNUSU9OQUxdOiBMaWdodERpcmVjdGlvbmFsLCBbTElHSFRfVFlQRS5QT0lOVF06IExpZ2h0UG9pbnQsIFtMSUdIVF9UWVBFLlNQT1RdOiBMaWdodFNwb3QgfTtcclxuICAgIHB1YmxpYyBtdHhQaXZvdDogTWF0cml4NHg0ID0gTWF0cml4NHg0LklERU5USVRZKCk7XHJcbiAgICBwdWJsaWMgbGlnaHQ6IExpZ2h0ID0gbnVsbDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihfbGlnaHQ6IExpZ2h0ID0gbmV3IExpZ2h0QW1iaWVudCgpKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuc2luZ2xldG9uID0gZmFsc2U7XHJcbiAgICAgIHRoaXMubGlnaHQgPSBfbGlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldFR5cGU8VCBleHRlbmRzIExpZ2h0PihfY2xhc3M6IG5ldyAoKSA9PiBUKTogdm9pZCB7XHJcbiAgICAgIGxldCBtdHJPbGQ6IE11dGF0b3IgPSB7fTtcclxuICAgICAgaWYgKHRoaXMubGlnaHQpXHJcbiAgICAgICAgbXRyT2xkID0gdGhpcy5saWdodC5nZXRNdXRhdG9yKCk7XHJcblxyXG4gICAgICB0aGlzLmxpZ2h0ID0gbmV3IF9jbGFzcygpO1xyXG4gICAgICB0aGlzLmxpZ2h0Lm11dGF0ZShtdHJPbGQpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge1xyXG4gICAgICAgIHBpdm90OiB0aGlzLm10eFBpdm90LnNlcmlhbGl6ZSgpLFxyXG4gICAgICAgIGxpZ2h0OiBTZXJpYWxpemVyLnNlcmlhbGl6ZSh0aGlzLmxpZ2h0KVxyXG4gICAgICB9O1xyXG4gICAgICBzZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdKTtcclxuICAgICAgYXdhaXQgdGhpcy5tdHhQaXZvdC5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5waXZvdCk7XHJcbiAgICAgIHRoaXMubGlnaHQgPSBhd2FpdCA8UHJvbWlzZTxMaWdodD4+U2VyaWFsaXplci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5saWdodCk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHN1cGVyLmdldE11dGF0b3IodHJ1ZSk7XHJcbiAgICAgIG11dGF0b3IudHlwZSA9IHRoaXMubGlnaHQuZ2V0VHlwZSgpLm5hbWU7XHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yQXR0cmlidXRlVHlwZXMoX211dGF0b3I6IE11dGF0b3IpOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMge1xyXG4gICAgICBsZXQgdHlwZXM6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyA9IHN1cGVyLmdldE11dGF0b3JBdHRyaWJ1dGVUeXBlcyhfbXV0YXRvcik7XHJcbiAgICAgIGlmICh0eXBlcy50eXBlKVxyXG4gICAgICAgIHR5cGVzLnR5cGUgPSBMSUdIVF9UWVBFO1xyXG4gICAgICByZXR1cm4gdHlwZXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBsZXQgdHlwZTogc3RyaW5nID0gX211dGF0b3IudHlwZTtcclxuICAgICAgaWYgKHR5cGUgIT0gdGhpcy5saWdodC5jb25zdHJ1Y3Rvci5uYW1lKVxyXG4gICAgICB0aGlzLnNldFR5cGUoU2VyaWFsaXplci5nZXRDb25zdHJ1Y3RvcjxMaWdodD4odHlwZSkpO1xyXG5cclxuICAgICAgZGVsZXRlIChfbXV0YXRvci50eXBlKTsgLy8gZXhjbHVkZSBsaWdodCB0eXBlIGZyb20gZnVydGhlciBtdXRhdGlvblxyXG4gICAgICBzdXBlci5tdXRhdGUoX211dGF0b3IpO1xyXG4gICAgICBfbXV0YXRvci50eXBlID0gdHlwZTsgLy8gcmVjb25zdHJ1Y3QgbXV0YXRvclxyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBBdHRhY2hlcyBhIHtAbGluayBNYXRlcmlhbH0gdG8gdGhlIG5vZGVcclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOSAtIDIwMjFcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29tcG9uZW50TWF0ZXJpYWwgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IENvbXBvbmVudC5yZWdpc3RlclN1YmNsYXNzKENvbXBvbmVudE1hdGVyaWFsKTtcclxuICAgIHB1YmxpYyBjbHJQcmltYXJ5OiBDb2xvciA9IENvbG9yLkNTUyhcIndoaXRlXCIpO1xyXG4gICAgcHVibGljIGNsclNlY29uZGFyeTogQ29sb3IgPSBDb2xvci5DU1MoXCJ3aGl0ZVwiKTtcclxuICAgIHB1YmxpYyBtdHhQaXZvdDogTWF0cml4M3gzID0gTWF0cml4M3gzLklERU5USVRZKCk7XHJcbiAgICBwdWJsaWMgbWF0ZXJpYWw6IE1hdGVyaWFsO1xyXG4gICAgLy8qKiBzdXBwb3J0IHNvcnRpbmcgb2Ygb2JqZWN0cyB3aXRoIHRyYW5zcGFyZW5jeSB3aGVuIHJlbmRlcmluZywgcmVuZGVyIG9iamVjdHMgaW4gdGhlIGJhY2sgZmlyc3QgKi9cclxuICAgIHB1YmxpYyBzb3J0Rm9yQWxwaGE6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIC8vIHB1YmxpYyBtdXRhdG9yQ29hdDogTXV0YXRvckZvckNvbXBvbmVudDtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX21hdGVyaWFsOiBNYXRlcmlhbCA9IG51bGwpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5tYXRlcmlhbCA9IF9tYXRlcmlhbDtcclxuICAgICAgLy8gdGhpcy5tdXRhdG9yQ29hdCA9IF9tYXRlcmlhbC5nZXRDb2F0KCkuZ2V0TXV0YXRvckZvckNvbXBvbmVudCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgc29ydEZvckFscGhhOiB0aGlzLnNvcnRGb3JBbHBoYSxcclxuICAgICAgICBjbHJQcmltYXJ5OiB0aGlzLmNsclByaW1hcnkuc2VyaWFsaXplKCksXHJcbiAgICAgICAgY2xyU2Vjb25kYXJ5OiB0aGlzLmNsclNlY29uZGFyeS5zZXJpYWxpemUoKSxcclxuICAgICAgICBwaXZvdDogdGhpcy5tdHhQaXZvdC5zZXJpYWxpemUoKSxcclxuICAgICAgICBbc3VwZXIuY29uc3RydWN0b3IubmFtZV06IHN1cGVyLnNlcmlhbGl6ZSgpLFxyXG4gICAgICAgIGlkTWF0ZXJpYWw6IHRoaXMubWF0ZXJpYWwuaWRSZXNvdXJjZVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgdGhpcy5tYXRlcmlhbCA9IDxNYXRlcmlhbD5hd2FpdCBQcm9qZWN0LmdldFJlc291cmNlKF9zZXJpYWxpemF0aW9uLmlkTWF0ZXJpYWwpO1xyXG4gICAgICBhd2FpdCB0aGlzLmNsclByaW1hcnkuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24uY2xyUHJpbWFyeSk7XHJcbiAgICAgIGF3YWl0IHRoaXMuY2xyU2Vjb25kYXJ5LmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLmNsclNlY29uZGFyeSk7XHJcbiAgICAgIHRoaXMuc29ydEZvckFscGhhID0gX3NlcmlhbGl6YXRpb24uc29ydEZvckFscGhhO1xyXG4gICAgICBhd2FpdCB0aGlzLm10eFBpdm90LmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLnBpdm90KTtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBwdWJsaWMgZ2V0TXV0YXRvckZvclVzZXJJbnRlcmZhY2UoKTogTXV0YXRvckZvclVzZXJJbnRlcmZhY2Uge1xyXG4gICAgLy8gICBsZXQgbXV0YXRvckNvYXQ6IE11dGF0b3JGb3JDb21wb25lbnQgPSB0aGlzLm1hdGVyaWFsLmdldENvYXQoKS5nZXRNdXRhdG9yRm9yQ29tcG9uZW50KCk7XHJcbiAgICAvLyAgIHJldHVybiA8TXV0YXRvckZvclVzZXJJbnRlcmZhY2U+PHVua25vd24+bXV0YXRvckNvYXQ7XHJcbiAgICAvLyB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBBdHRhY2hlcyBhIHtAbGluayBNZXNofSB0byB0aGUgbm9kZVxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIENvbXBvbmVudE1lc2ggZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IENvbXBvbmVudC5yZWdpc3RlclN1YmNsYXNzKENvbXBvbmVudE1lc2gpO1xyXG4gICAgcHVibGljIG10eFBpdm90OiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKTtcclxuICAgIHB1YmxpYyByZWFkb25seSBtdHhXb3JsZDogTWF0cml4NHg0ID0gTWF0cml4NHg0LklERU5USVRZKCk7XHJcbiAgICBwdWJsaWMgbWVzaDogTWVzaCA9IG51bGw7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9tZXNoOiBNZXNoID0gbnVsbCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLm1lc2ggPSBfbWVzaDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHJhZGl1cygpOiBudW1iZXIge1xyXG4gICAgICBsZXQgc2NhbGluZzogVmVjdG9yMyA9IHRoaXMubXR4V29ybGQuc2NhbGluZztcclxuICAgICAgbGV0IHNjYWxlOiBudW1iZXIgPSBNYXRoLm1heChNYXRoLmFicyhzY2FsaW5nLngpLCBNYXRoLmFicyhzY2FsaW5nLnkpLCBNYXRoLmFicyhzY2FsaW5nLnopKTtcclxuICAgICAgcmV0dXJuIHRoaXMubWVzaC5yYWRpdXMgKiBzY2FsZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPOiByZW1vdmUgb3IgdGhpbmsgaWYgdGhlIHRyYW5zZm9ybWVkIGJvdW5kaW5nIGJveCBpcyBvZiB2YWx1ZSBvciBjYW4gYmUgbWFkZSB0byBiZVxyXG4gICAgLy8gcHVibGljIGdldCBib3VuZGluZ0JveCgpOiBCb3gge1xyXG4gICAgLy8gICBsZXQgYm94OiBCb3ggPSBSZWN5Y2xlci5nZXQoQm94KTtcclxuICAgIC8vICAgYm94LnNldChcclxuICAgIC8vICAgICBWZWN0b3IzLlRSQU5TRk9STUFUSU9OKHRoaXMubWVzaC5ib3VuZGluZ0JveC5taW4sIHRoaXMubXR4V29ybGQsIHRydWUpLFxyXG4gICAgLy8gICAgIFZlY3RvcjMuVFJBTlNGT1JNQVRJT04odGhpcy5tZXNoLmJvdW5kaW5nQm94Lm1heCwgdGhpcy5tdHhXb3JsZCwgdHJ1ZSlcclxuICAgIC8vICAgKTtcclxuICAgIC8vICAgcmV0dXJuIGJveDtcclxuICAgIC8vIH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uO1xyXG4gICAgICAvKiBhdCB0aGlzIHBvaW50IG9mIHRpbWUsIHNlcmlhbGl6YXRpb24gYXMgcmVzb3VyY2UgYW5kIGFzIGlubGluZSBvYmplY3QgaXMgcG9zc2libGUuIFRPRE86IGNoZWNrIGlmIGlubGluZSBiZWNvbWVzIG9ic29sZXRlICovXHJcbiAgICAgIGxldCBpZE1lc2g6IHN0cmluZyA9IHRoaXMubWVzaC5pZFJlc291cmNlO1xyXG4gICAgICBpZiAoaWRNZXNoKVxyXG4gICAgICAgIHNlcmlhbGl6YXRpb24gPSB7IGlkTWVzaDogaWRNZXNoIH07XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBzZXJpYWxpemF0aW9uID0geyBtZXNoOiBTZXJpYWxpemVyLnNlcmlhbGl6ZSh0aGlzLm1lc2gpIH07XHJcblxyXG4gICAgICBzZXJpYWxpemF0aW9uLnBpdm90ID0gdGhpcy5tdHhQaXZvdC5zZXJpYWxpemUoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBsZXQgbWVzaDogTWVzaDtcclxuICAgICAgaWYgKF9zZXJpYWxpemF0aW9uLmlkTWVzaClcclxuICAgICAgICBtZXNoID0gPE1lc2g+YXdhaXQgUHJvamVjdC5nZXRSZXNvdXJjZShfc2VyaWFsaXphdGlvbi5pZE1lc2gpO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgbWVzaCA9IDxNZXNoPmF3YWl0IFNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24ubWVzaCk7XHJcbiAgICAgIHRoaXMubWVzaCA9IG1lc2g7XHJcblxyXG4gICAgICBhd2FpdCB0aGlzLm10eFBpdm90LmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLnBpdm90KTtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvckZvclVzZXJJbnRlcmZhY2UoKTogTXV0YXRvckZvclVzZXJJbnRlcmZhY2Uge1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvckZvclVzZXJJbnRlcmZhY2UgPSA8TXV0YXRvckZvclVzZXJJbnRlcmZhY2U+dGhpcy5nZXRNdXRhdG9yKCk7XHJcbiAgICAgIC8vIGlmICghdGhpcy5tZXNoKVxyXG4gICAgICAvLyAgIG11dGF0b3IubWVzaCA9IE1lc2g7XHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59XHJcbiIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEJhc2UgY2xhc3MgZm9yIHNjcmlwdHMgdGhlIHVzZXIgd3JpdGVzXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vSmlya2FEZWxsT3JvL0ZVREdFL3dpa2kvQ29tcG9uZW50XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIENvbXBvbmVudFNjcmlwdCBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICAvLyByZWdpc3RlcmluZyB0aGlzIGRvZXNuJ3QgbWFrZSBzZW5zZSwgb25seSBpdHMgc3ViY2xhc3Nlcy4gT3IgdGhpcyBjb21wb25lbnQgbXVzdCByZWZlciB0byBzY3JpcHRzIHRvIGJlIGF0dGFjaGVkIHRvIHRoaXMgY29tcG9uZW50XHJcbiAgICAvLyBUT0RPOiByZXRoaW5rICYgcmVmYWN0b3JcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRTY3JpcHQpO1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuc2luZ2xldG9uID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2V0TXV0YXRvcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIHRoaXMubXV0YXRlKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIGV4cG9ydCBlbnVtIEJBU0Uge1xyXG4gICAgU0VMRiwgUEFSRU5ULCBXT1JMRCwgTk9ERVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgYSB0cmFuc2Zvcm0tW1tNYXRyaXg0eDR9IHRvIHRoZSBub2RlLCBtb3ZpbmcsIHNjYWxpbmcgYW5kIHJvdGF0aW5nIGl0IGluIHNwYWNlIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQuXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29tcG9uZW50VHJhbnNmb3JtIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRUcmFuc2Zvcm0pO1xyXG4gICAgcHVibGljIG10eExvY2FsOiBNYXRyaXg0eDQ7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9tdHhJbml0OiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKSkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLm10eExvY2FsID0gX210eEluaXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZm9ybWF0aW9ucyByZXNwZWN0aW5nIHRoZSBoaWVyYXJjaHlcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkanVzdHMgdGhlIHJvdGF0aW9uIHRvIHBvaW50IHRoZSB6LWF4aXMgZGlyZWN0bHkgYXQgdGhlIGdpdmVuIHRhcmdldCBwb2ludCBpbiB3b3JsZCBzcGFjZSBhbmQgdGlsdHMgaXQgdG8gYWNjb3JkIHdpdGggdGhlIGdpdmVuIHVwIHZlY3RvcixcclxuICAgICAqIHJlc3BlY3RpdmVseSBjYWxjdWxhdGluZyB5YXcgYW5kIHBpdGNoLiBJZiBubyB1cCB2ZWN0b3IgaXMgZ2l2ZW4sIHRoZSBwcmV2aW91cyB1cC12ZWN0b3IgaXMgdXNlZC4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBsb29rQXQoX3RhcmdldFdvcmxkOiBWZWN0b3IzLCBfdXA/OiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIGxldCBjb250YWluZXI6IE5vZGUgPSB0aGlzLm5vZGU7XHJcbiAgICAgIGlmICghY29udGFpbmVyICYmICFjb250YWluZXIuZ2V0UGFyZW50KCkpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMubXR4TG9jYWwubG9va0F0KF90YXJnZXRXb3JsZCwgX3VwKTtcclxuXHJcbiAgICAgIC8vIGNvbXBvbmVudCBpcyBhdHRhY2hlZCB0byBhIGNoaWxkIG5vZGUgLT4gdHJhbnNmb3JtIHJlc3BlY3RpbmcgdGhlIGhpZXJhcmNoeVxyXG4gICAgICBsZXQgbXR4V29ybGQ6IE1hdHJpeDR4NCA9IGNvbnRhaW5lci5tdHhXb3JsZC5jbG9uZTtcclxuICAgICAgbXR4V29ybGQubG9va0F0KF90YXJnZXRXb3JsZCwgX3VwLCB0cnVlKTtcclxuICAgICAgbGV0IG10eExvY2FsOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuUkVMQVRJVkUobXR4V29ybGQsIG51bGwsIGNvbnRhaW5lci5nZXRQYXJlbnQoKS5tdHhXb3JsZEludmVyc2UpO1xyXG4gICAgICB0aGlzLm10eExvY2FsID0gbXR4TG9jYWw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGp1c3RzIHRoZSByb3RhdGlvbiB0byBtYXRjaCBpdHMgeS1heGlzIHdpdGggdGhlIGdpdmVuIHVwLXZlY3RvciBhbmQgZmFjaW5nIGl0cyB6LWF4aXMgdG93YXJkIHRoZSBnaXZlbiB0YXJnZXQgYXQgbWluaW1hbCBhbmdsZSxcclxuICAgICAqIHJlc3BlY3RpdmVseSBjYWxjdWxhdGluZyB5YXcgb25seS4gSWYgbm8gdXAgdmVjdG9yIGlzIGdpdmVuLCB0aGUgcHJldmlvdXMgdXAtdmVjdG9yIGlzIHVzZWQuIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2hvd1RvKF90YXJnZXRXb3JsZDogVmVjdG9yMywgX3VwPzogVmVjdG9yMyk6IHZvaWQge1xyXG4gICAgICBsZXQgY29udGFpbmVyOiBOb2RlID0gdGhpcy5ub2RlO1xyXG4gICAgICBpZiAoIWNvbnRhaW5lciAmJiAhY29udGFpbmVyLmdldFBhcmVudCgpKVxyXG4gICAgICAgIHJldHVybiB0aGlzLm10eExvY2FsLnNob3dUbyhfdGFyZ2V0V29ybGQsIF91cCk7XHJcblxyXG4gICAgICAvLyBjb21wb25lbnQgaXMgYXR0YWNoZWQgdG8gYSBjaGlsZCBub2RlIC0+IHRyYW5zZm9ybSByZXNwZWN0aW5nIHRoZSBoaWVyYXJjaHlcclxuICAgICAgbGV0IG10eFdvcmxkOiBNYXRyaXg0eDQgPSBjb250YWluZXIubXR4V29ybGQuY2xvbmU7XHJcbiAgICAgIG10eFdvcmxkLnNob3dUbyhfdGFyZ2V0V29ybGQsIF91cCwgdHJ1ZSk7XHJcbiAgICAgIGxldCBtdHhMb2NhbDogTWF0cml4NHg0ID0gTWF0cml4NHg0LlJFTEFUSVZFKG10eFdvcmxkLCBudWxsLCBjb250YWluZXIuZ2V0UGFyZW50KCkubXR4V29ybGRJbnZlcnNlKTtcclxuICAgICAgdGhpcy5tdHhMb2NhbCA9IG10eExvY2FsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmVjYWxjdWxhdGVzIHRoaXMgbG9jYWwgbWF0cml4IHRvIHlpZWxkIHRoZSBpZGVudGljYWwgd29ybGQgbWF0cml4IGJhc2VkIG9uIHRoZSBnaXZlbiBub2RlLlxyXG4gICAgICogVXNlIHJlYmFzZSBiZWZvcmUgYXBwZW5kaW5nIHRoZSBjb250YWluZXIgb2YgdGhpcyBjb21wb25lbnQgdG8gYW5vdGhlciBub2RlIHdoaWxlIHByZXNlcnZpbmcgaXRzIHRyYW5zZm9ybWF0aW9uIGluIHRoZSB3b3JsZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlYmFzZShfbm9kZTogTm9kZSA9IG51bGwpOiB2b2lkIHtcclxuICAgICAgbGV0IG10eFJlc3VsdDogTWF0cml4NHg0ID0gdGhpcy5tdHhMb2NhbDtcclxuICAgICAgbGV0IGNvbnRhaW5lcjogTm9kZSA9IHRoaXMubm9kZTtcclxuICAgICAgaWYgKGNvbnRhaW5lcilcclxuICAgICAgICBtdHhSZXN1bHQgPSBjb250YWluZXIubXR4V29ybGQ7XHJcblxyXG4gICAgICBpZiAoX25vZGUpXHJcbiAgICAgICAgbXR4UmVzdWx0ID0gTWF0cml4NHg0LlJFTEFUSVZFKG10eFJlc3VsdCwgbnVsbCwgX25vZGUubXR4V29ybGRJbnZlcnNlKTtcclxuXHJcbiAgICAgIHRoaXMubXR4TG9jYWwgPSBtdHhSZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBnaXZlbiB0cmFuc2Zvcm1hdGlvbiByZWxhdGl2ZSB0byB0aGUgc2VsZWN0ZWQgYmFzZSAoU0VMRiwgUEFSRU5ULCBXT1JMRCkgb3IgYSBwYXJ0aWN1bGFyIG90aGVyIG5vZGUgKE5PREUpXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0cmFuc2Zvcm0oX210eFRyYW5zZm9ybTogTWF0cml4NHg0LCBfYmFzZTogQkFTRSA9IEJBU0UuU0VMRiwgX25vZGU6IE5vZGUgPSBudWxsKTogdm9pZCB7XHJcbiAgICAgIHN3aXRjaCAoX2Jhc2UpIHtcclxuICAgICAgICBjYXNlIEJBU0UuU0VMRjpcclxuICAgICAgICAgIHRoaXMubXR4TG9jYWwubXVsdGlwbHkoX210eFRyYW5zZm9ybSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEJBU0UuUEFSRU5UOlxyXG4gICAgICAgICAgdGhpcy5tdHhMb2NhbC5tdWx0aXBseShfbXR4VHJhbnNmb3JtLCB0cnVlKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQkFTRS5OT0RFOlxyXG4gICAgICAgICAgaWYgKCFfbm9kZSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQkFTRS5OT0RFIHJlcXVpcmVzIGEgbm9kZSBnaXZlbiBhcyBiYXNlXCIpO1xyXG4gICAgICAgIGNhc2UgQkFTRS5XT1JMRDpcclxuICAgICAgICAgIHRoaXMucmViYXNlKF9ub2RlKTtcclxuICAgICAgICAgIHRoaXMubXR4TG9jYWwubXVsdGlwbHkoX210eFRyYW5zZm9ybSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgbGV0IG5vZGU6IE5vZGUgPSB0aGlzLm5vZGU7XHJcbiAgICAgICAgICBpZiAobm9kZSkge1xyXG4gICAgICAgICAgICBsZXQgbXR4VGVtcDogTWF0cml4NHg0O1xyXG4gICAgICAgICAgICBpZiAoX2Jhc2UgPT0gQkFTRS5OT0RFKSB7XHJcbiAgICAgICAgICAgICAgLy8gZml4IG10eFdvcmxkIG9mIGNvbnRhaW5lciBmb3Igc3Vic2VxdWVudCByZWJhc2luZyBcclxuICAgICAgICAgICAgICBtdHhUZW1wID0gTWF0cml4NHg0Lk1VTFRJUExJQ0FUSU9OKF9ub2RlLm10eFdvcmxkLCBub2RlLm10eExvY2FsKTtcclxuICAgICAgICAgICAgICBub2RlLm10eFdvcmxkLnNldChtdHhUZW1wKTtcclxuICAgICAgICAgICAgICBSZWN5Y2xlci5zdG9yZShtdHhUZW1wKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IHBhcmVudDogTm9kZSA9IG5vZGUuZ2V0UGFyZW50KCk7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAvLyBmaXggbXR4TG9jYWwgZm9yIGN1cnJlbnQgcGFyZW50XHJcbiAgICAgICAgICAgICAgdGhpcy5yZWJhc2Uobm9kZS5nZXRQYXJlbnQoKSk7XHJcbiAgICAgICAgICAgICAgbXR4VGVtcCA9IE1hdHJpeDR4NC5NVUxUSVBMSUNBVElPTihub2RlLmdldFBhcmVudCgpLm10eFdvcmxkLCBub2RlLm10eExvY2FsKTtcclxuICAgICAgICAgICAgICBub2RlLm10eFdvcmxkLnNldChtdHhUZW1wKTtcclxuICAgICAgICAgICAgICBSZWN5Y2xlci5zdG9yZShtdHhUZW1wKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgbG9jYWw6IHRoaXMubXR4TG9jYWwuc2VyaWFsaXplKCksXHJcbiAgICAgICAgW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdOiBzdXBlci5zZXJpYWxpemUoKVxyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdKTtcclxuICAgICAgYXdhaXQgdGhpcy5tdHhMb2NhbC5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5sb2NhbCk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHB1YmxpYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgIC8vICAgICB0aGlzLmxvY2FsLm11dGF0ZShfbXV0YXRvcik7XHJcbiAgICAvLyB9XHJcbiAgICAvLyBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHsgXHJcbiAgICAvLyAgICAgcmV0dXJuIHRoaXMubG9jYWwuZ2V0TXV0YXRvcigpO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIC8vIHB1YmxpYyBnZXRNdXRhdG9yQXR0cmlidXRlVHlwZXMoX211dGF0b3I6IE11dGF0b3IpOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMge1xyXG4gICAgLy8gICAgIGxldCB0eXBlczogTXV0YXRvckF0dHJpYnV0ZVR5cGVzID0gdGhpcy5sb2NhbC5nZXRNdXRhdG9yQXR0cmlidXRlVHlwZXMoX211dGF0b3IpO1xyXG4gICAgLy8gICAgIHJldHVybiB0eXBlcztcclxuICAgIC8vIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICBkZWxldGUgX211dGF0b3Iud29ybGQ7XHJcbiAgICAgIHN1cGVyLnJlZHVjZU11dGF0b3IoX211dGF0b3IpO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59XHJcbiIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBjb25zdCBlbnVtIEVWRU5UX0NPTlRST0wge1xyXG4gICAgSU5QVVQgPSBcImlucHV0XCIsXHJcbiAgICBPVVRQVVQgPSBcIm91dHB1dFwiXHJcbiAgfVxyXG5cclxuICBleHBvcnQgY29uc3QgZW51bSBDT05UUk9MX1RZUEUge1xyXG4gICAgLyoqIFRoZSBvdXRwdXQgc2ltcGx5IGZvbGxvd3MgdGhlIHNjYWxlZCBhbmQgZGVsYXllZCBpbnB1dCAqL1xyXG4gICAgUFJPUE9SVElPTkFMLFxyXG4gICAgLyoqIFRoZSBvdXRwdXQgdmFsdWUgY2hhbmdlcyBvdmVyIHRpbWUgd2l0aCBhIHJhdGUgZ2l2ZW4gYnkgdGhlIHNjYWxlZCBhbmQgZGVsYXllZCBpbnB1dCAqL1xyXG4gICAgSU5URUdSQUwsXHJcbiAgICAvKiogVGhlIG91dHB1dCB2YWx1ZSByZWFjdHMgdG8gY2hhbmdlcyBvZiB0aGUgc2NhbGVkIGlucHV0IGFuZCBkcm9wcyB0byAwIHdpdGggZ2l2ZW4gZGVsYXksIGlmIGlucHV0IHJlbWFpbnMgY29uc3RhbnQgKi9cclxuICAgIERJRkZFUkVOVElBTFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUHJvY2Vzc2VzIGlucHV0IHNpZ25hbHMgb2YgdHlwZSBudW1iZXIgYW5kIGdlbmVyYXRlcyBhbiBvdXRwdXQgc2lnbmFsIG9mIHRoZSBzYW1lIHR5cGUgdXNpbmcgXHJcbiAgICogcHJvcG9ydGlvbmFsLCBpbnRlZ3JhbCBvciBkaWZmZXJlbnRpYWwgbWFwcGluZywgYW4gYW1wbGlmaWNhdGlvbiBmYWN0b3IgYW5kIGEgbGluZWFyIGRhbXBlbmluZy9kZWxheVxyXG4gICAqIGBgYHBsYWludGV4dFxyXG4gICAqICAgICAgICAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxyXG4gICAqICAgICAgICAgIOKUgiAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUkCAgICAgIHBhc3MgdGhyb3VnaCAoUHJvcG9ydGlvbmFsKSAgICAgIOKUglxyXG4gICAqICBJbnB1dCDihpIg4pSCIOKGkiDilIJhbXBsaWZ54pSCIOKGkiDilIJkZWxheeKUgiDihpIg4pqfIHN1bSB1cCBvdmVyIHRpbWUgKEludGVncmFsKSDimp4g4oaSIOKUgiDihpIgT3V0cHV0XHJcbiAgICogICAgICAgICAg4pSCICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSYICAgICAgcGFzcyBjaGFuZ2UgIChEaWZmZXJlbnRpYWwpICAgICAg4pSCXHJcbiAgICogICAgICAgICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYIFxyXG4gICAqIGBgYFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb250cm9sIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xyXG4gICAgcHVibGljIHJlYWRvbmx5IHR5cGU6IENPTlRST0xfVFlQRTtcclxuICAgIHB1YmxpYyBhY3RpdmU6IGJvb2xlYW47XHJcbiAgICBwdWJsaWMgbmFtZTogc3RyaW5nO1xyXG5cclxuICAgIHByb3RlY3RlZCByYXRlRGlzcGF0Y2hPdXRwdXQ6IG51bWJlciA9IDA7XHJcbiAgICBwcm90ZWN0ZWQgdmFsdWVQcmV2aW91czogbnVtYmVyID0gMDtcclxuICAgIHByb3RlY3RlZCBvdXRwdXRCYXNlOiBudW1iZXIgPSAwO1xyXG4gICAgcHJvdGVjdGVkIG91dHB1dFRhcmdldDogbnVtYmVyID0gMDtcclxuICAgIHByb3RlY3RlZCBvdXRwdXRQcmV2aW91czogbnVtYmVyID0gMDtcclxuICAgIHByb3RlY3RlZCBvdXRwdXRUYXJnZXRQcmV2aW91czogbnVtYmVyID0gMDtcclxuICAgIHByb3RlY3RlZCBmYWN0b3I6IG51bWJlciA9IDA7XHJcblxyXG4gICAgcHJvdGVjdGVkIHRpbWU6IFRpbWUgPSBUaW1lLmdhbWU7XHJcbiAgICBwcm90ZWN0ZWQgdGltZVZhbHVlRGVsYXk6IG51bWJlciA9IDA7XHJcbiAgICBwcm90ZWN0ZWQgdGltZU91dHB1dFRhcmdldFNldDogbnVtYmVyID0gMDtcclxuICAgIHByb3RlY3RlZCBpZFRpbWVyOiBudW1iZXIgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgY29uc3RydWN0b3IoX25hbWU6IHN0cmluZywgX2ZhY3RvcjogbnVtYmVyID0gMSwgX3R5cGU6IENPTlRST0xfVFlQRSA9IENPTlRST0xfVFlQRS5QUk9QT1JUSU9OQUwsIF9hY3RpdmU6IGJvb2xlYW4gPSB0cnVlKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuZmFjdG9yID0gX2ZhY3RvcjtcclxuICAgICAgdGhpcy50eXBlID0gX3R5cGU7XHJcbiAgICAgIHRoaXMuYWN0aXZlID0gX2FjdGl2ZTtcclxuICAgICAgdGhpcy5uYW1lID0gX25hbWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHRpbWUtb2JqZWN0IHRvIGJlIHVzZWQgd2hlbiBjYWxjdWxhdGluZyB0aGUgb3V0cHV0IGluIHtAbGluayBDT05UUk9MX1RZUEUuSU5URUdSQUx9XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRUaW1lYmFzZShfdGltZTogVGltZSk6IHZvaWQge1xyXG4gICAgICB0aGlzLnRpbWUgPSBfdGltZTtcclxuICAgICAgdGhpcy5jYWxjdWxhdGVPdXRwdXQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZlZWQgYW4gaW5wdXQgdmFsdWUgaW50byB0aGlzIGNvbnRyb2wgYW5kIGZpcmUgdGhlIGV2ZW50cyB7QGxpbmsgRVZFTlRfQ09OVFJPTC5JTlBVVH0gYW5kIHtAbGluayBFVkVOVF9DT05UUk9MLk9VVFBVVH1cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldElucHV0KF9pbnB1dDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIGlmICghdGhpcy5hY3RpdmUpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIFxyXG4gICAgICB0aGlzLm91dHB1dEJhc2UgPSB0aGlzLmNhbGN1bGF0ZU91dHB1dCgpO1xyXG4gICAgICB0aGlzLnZhbHVlUHJldmlvdXMgPSB0aGlzLmdldFZhbHVlRGVsYXllZCgpO1xyXG4gICAgICB0aGlzLm91dHB1dFRhcmdldCA9IHRoaXMuZmFjdG9yICogX2lucHV0O1xyXG4gICAgICB0aGlzLnRpbWVPdXRwdXRUYXJnZXRTZXQgPSB0aGlzLnRpbWUuZ2V0KCk7XHJcblxyXG4gICAgICBpZiAodGhpcy50eXBlID09IENPTlRST0xfVFlQRS5ESUZGRVJFTlRJQUwpIHtcclxuICAgICAgICB0aGlzLnZhbHVlUHJldmlvdXMgPSB0aGlzLm91dHB1dFRhcmdldCAtIHRoaXMub3V0cHV0VGFyZ2V0UHJldmlvdXM7XHJcbiAgICAgICAgdGhpcy5vdXRwdXRUYXJnZXRQcmV2aW91cyA9IHRoaXMub3V0cHV0VGFyZ2V0O1xyXG4gICAgICAgIHRoaXMub3V0cHV0VGFyZ2V0ID0gMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVF9DT05UUk9MLklOUFVUKSk7XHJcbiAgICAgIGlmICh0aGlzLnR5cGUgPT0gQ09OVFJPTF9UWVBFLkRJRkZFUkVOVElBTClcclxuICAgICAgICB0aGlzLmRpc3BhdGNoT3V0cHV0KHRoaXMudmFsdWVQcmV2aW91cyk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICB0aGlzLmRpc3BhdGNoT3V0cHV0KG51bGwpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBwdWxzZShfaW5wdXQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICB0aGlzLnNldElucHV0KF9pbnB1dCk7XHJcbiAgICAgIHRoaXMuc2V0SW5wdXQoMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHRpbWUgdG8gdGFrZSBmb3IgdGhlIGludGVybmFsIGxpbmVhciBkYW1wZW5pbmcgdW50aWwgdGhlIGZpbmFsIG91cHV0IHZhbHVlIGlzIHJlYWNoZWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldERlbGF5KF90aW1lOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy50aW1lVmFsdWVEZWxheSA9IE1hdGgubWF4KDAsIF90aW1lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgbnVtYmVyIG9mIG91dHB1dC1ldmVudHMgdG8gZGlzcGF0Y2ggcGVyIHNlY29uZC4gXHJcbiAgICAgKiBBdCB0aGUgZGVmYXVsdCBvZiAwLCB0aGUgY29udHJvbCBvdXRwdXQgbXVzdCBiZSBwb2xsZWQgYW5kIHdpbGwgb25seSBhY3RpdmVseSBkaXNwYXRjaGVkIG9uY2UgZWFjaCB0aW1lIGlucHV0IG9jY3VycyBhbmQgdGhlIG91dHB1dCBjaGFuZ2VzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0UmF0ZURpc3BhdGNoT3V0cHV0KF9yYXRlRGlzcGF0Y2hPdXRwdXQ6IG51bWJlciA9IDApOiB2b2lkIHtcclxuICAgICAgdGhpcy5yYXRlRGlzcGF0Y2hPdXRwdXQgPSBfcmF0ZURpc3BhdGNoT3V0cHV0O1xyXG4gICAgICB0aGlzLnRpbWUuZGVsZXRlVGltZXIodGhpcy5pZFRpbWVyKTtcclxuICAgICAgdGhpcy5pZFRpbWVyID0gdW5kZWZpbmVkO1xyXG4gICAgICBpZiAodGhpcy5yYXRlRGlzcGF0Y2hPdXRwdXQpXHJcbiAgICAgICAgdGhpcy5pZFRpbWVyID0gdGhpcy50aW1lLnNldFRpbWVyKDEwMDAgLyB0aGlzLnJhdGVEaXNwYXRjaE91dHB1dCwgMCwgdGhpcy5kaXNwYXRjaE91dHB1dCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGZhY3RvciB0byBtdWx0aXBseSB0aGUgaW5wdXQgdmFsdWUgZ2l2ZW4gd2l0aCB7QGxpbmsgc2V0SW5wdXR9IHdpdGhcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldEZhY3RvcihfZmFjdG9yOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy5mYWN0b3IgPSBfZmFjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBvdXRwdXQgb2YgdGhpcyBjb250cm9sXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRPdXRwdXQoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY2FsY3VsYXRlT3V0cHV0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBvdXRwdXQgb2YgdGhpcyBjb250cm9sXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBjYWxjdWxhdGVPdXRwdXQoKTogbnVtYmVyIHtcclxuICAgICAgbGV0IG91dHB1dDogbnVtYmVyID0gMDtcclxuICAgICAgbGV0IHZhbHVlOiBudW1iZXIgPSB0aGlzLmdldFZhbHVlRGVsYXllZCgpO1xyXG5cclxuICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcclxuICAgICAgICBjYXNlIENPTlRST0xfVFlQRS5JTlRFR1JBTDpcclxuICAgICAgICAgIGxldCB0aW1lQ3VycmVudDogbnVtYmVyID0gdGhpcy50aW1lLmdldCgpO1xyXG4gICAgICAgICAgbGV0IHRpbWVFbGFwc2VkU2luY2VJbnB1dDogbnVtYmVyID0gdGltZUN1cnJlbnQgLSB0aGlzLnRpbWVPdXRwdXRUYXJnZXRTZXQ7XHJcbiAgICAgICAgICBvdXRwdXQgPSB0aGlzLm91dHB1dEJhc2U7XHJcblxyXG4gICAgICAgICAgaWYgKHRoaXMudGltZVZhbHVlRGVsYXkgPiAwKSB7XHJcbiAgICAgICAgICAgIGlmICh0aW1lRWxhcHNlZFNpbmNlSW5wdXQgPCB0aGlzLnRpbWVWYWx1ZURlbGF5KSB7XHJcbiAgICAgICAgICAgICAgb3V0cHV0ICs9IDAuNSAqICh0aGlzLnZhbHVlUHJldmlvdXMgKyB2YWx1ZSkgKiB0aW1lRWxhcHNlZFNpbmNlSW5wdXQ7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgb3V0cHV0ICs9IDAuNSAqICh0aGlzLnZhbHVlUHJldmlvdXMgKyB2YWx1ZSkgKiB0aGlzLnRpbWVWYWx1ZURlbGF5O1xyXG4gICAgICAgICAgICAgIHRpbWVFbGFwc2VkU2luY2VJbnB1dCAtPSB0aGlzLnRpbWVWYWx1ZURlbGF5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBvdXRwdXQgKz0gdmFsdWUgKiB0aW1lRWxhcHNlZFNpbmNlSW5wdXQ7XHJcbiAgICAgICAgICAvLyB2YWx1ZSArPSAwLjUgKiAodGhpcy5pbnB1dFByZXZpb3VzIC0gaW5wdXQpICogdGhpcy50aW1lSW5wdXREZWxheSArIGlucHV0ICogdGltZUVsYXBzZWRTaW5jZUlucHV0O1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBDT05UUk9MX1RZUEUuRElGRkVSRU5USUFMOlxyXG4gICAgICAgIGNhc2UgQ09OVFJPTF9UWVBFLlBST1BPUlRJT05BTDpcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgb3V0cHV0ID0gdmFsdWU7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBjYWxjdWxhdGVzIHRoZSBvdXRwdXQgY29uc2lkZXJpbmcgdGhlIHRpbWUgb2YgdGhlIGRlbGF5XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZ2V0VmFsdWVEZWxheWVkKCk6IG51bWJlciB7XHJcbiAgICAgIGlmICh0aGlzLnRpbWVWYWx1ZURlbGF5ID4gMCkge1xyXG4gICAgICAgIGxldCB0aW1lRWxhcHNlZFNpbmNlSW5wdXQ6IG51bWJlciA9IHRoaXMudGltZS5nZXQoKSAtIHRoaXMudGltZU91dHB1dFRhcmdldFNldDtcclxuICAgICAgICBpZiAodGltZUVsYXBzZWRTaW5jZUlucHV0IDwgdGhpcy50aW1lVmFsdWVEZWxheSlcclxuICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlUHJldmlvdXMgKyAodGhpcy5vdXRwdXRUYXJnZXQgLSB0aGlzLnZhbHVlUHJldmlvdXMpICogdGltZUVsYXBzZWRTaW5jZUlucHV0IC8gdGhpcy50aW1lVmFsdWVEZWxheTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy5vdXRwdXRUYXJnZXQ7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHByaXZhdGUgZGlzcGF0Y2hPdXRwdXQgPSAoX2V2ZW50T3JWYWx1ZTogRXZlbnRUaW1lciB8IG51bWJlcik6IHZvaWQgPT4ge1xyXG4gICAgICBpZiAoIXRoaXMuYWN0aXZlKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgICBcclxuICAgICAgbGV0IHRpbWVyOiBUaW1lciA9IHRoaXMudGltZS5nZXRUaW1lcih0aGlzLmlkVGltZXIpO1xyXG4gICAgICBsZXQgb3V0cHV0OiBudW1iZXI7XHJcbiAgICAgIGlmICh0eXBlb2YgKF9ldmVudE9yVmFsdWUpID09IFwibnVtYmVyXCIpXHJcbiAgICAgICAgb3V0cHV0ID0gX2V2ZW50T3JWYWx1ZTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIG91dHB1dCA9IHRoaXMuY2FsY3VsYXRlT3V0cHV0KCk7XHJcbiAgICAgIGxldCBvdXRwdXRDaGFuZ2VkOiBib29sZWFuID0gKG91dHB1dCAhPSB0aGlzLm91dHB1dFByZXZpb3VzKTtcclxuXHJcbiAgICAgIGlmICh0aW1lcikge1xyXG4gICAgICAgIHRpbWVyLmFjdGl2ZSA9IG91dHB1dENoYW5nZWQ7XHJcbiAgICAgICAgaWYgKCFvdXRwdXRDaGFuZ2VkKVxyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLm91dHB1dFByZXZpb3VzID0gb3V0cHV0O1xyXG5cclxuICAgICAgbGV0IGV2ZW50OiBDdXN0b21FdmVudCA9IG5ldyBDdXN0b21FdmVudChFVkVOVF9DT05UUk9MLk9VVFBVVCwge1xyXG4gICAgICAgIGRldGFpbDoge1xyXG4gICAgICAgICAgb3V0cHV0OiBvdXRwdXRcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgIH1cclxuICB9XHJcbn0iLCIvLy88cmVmZXJlbmNlIHBhdGg9XCJDb250cm9sLnRzXCIvPlxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBIYW5kbGVzIG11bHRpcGxlIGNvbnRyb2xzIGFzIGlucHV0cyBhbmQgY3JlYXRlcyBhbiBvdXRwdXQgZnJvbSB0aGF0LlxyXG4gICAqIEFzIGEgc3ViY2xhc3Mgb2Yge0BsaW5rIENvbnRyb2x9LCBheGlzIGNhbGN1bGF0ZXMgdGhlIG91cHV0IHN1bW1pbmcgdXAgdGhlIGlucHV0cyBhbmQgcHJvY2Vzc2luZyB0aGUgcmVzdWx0IHVzaW5nIGl0cyBvd24gc2V0dGluZ3MuICBcclxuICAgKiBEaXNwYXRjaGVzIHtAbGluayBFVkVOVF9DT05UUk9MLk9VVFBVVH0gYW5kIHtAbGluayBFVkVOVF9DT05UUk9MLklOUFVUfSB3aGVuIG9uZSBvZiB0aGUgY29udHJvbHMgZGlzcGF0Y2hlcyB0aGVtLlxyXG4gICAqIGBgYHBsYWludGV4dFxyXG4gICAqICAgICAgICAgICDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcclxuICAgKiAgICAgICAgICAg4pSCIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxyXG4gICAqICAgSW5wdXQg4oaSIOKUgiDilIJjb250cm9s4pSCXFwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxyXG4gICAqICAgICAgICAgICDilIIg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYIFxcICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxyXG4gICAqICAgICAgICAgICDilIIg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQICBcXOKUjOKUgOKUgOKUgOKUkCAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgIOKUglxyXG4gICAqICAgSW5wdXQg4oaSIOKUgiDilIJjb250cm9s4pSCLS0t4pSCc3Vt4pSCIOKGkiDilIJpbnRlcm5hbCBjb250cm9sIOKUgiDihpIg4pSCIOKGkiBPdXRwdXRcclxuICAgKiAgICAgICAgICAg4pSCIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgL+KUlOKUgOKUgOKUgOKUmCAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgIOKUglxyXG4gICAqICAgICAgICAgICDilIIg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQIC8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXHJcbiAgICogICBJbnB1dCDihpIg4pSCIOKUgmNvbnRyb2zilIIvICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcclxuICAgKiAgICAgICAgICAg4pSCIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxyXG4gICAqICAgICAgICAgICDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJggIFxyXG4gICAqIGBgYFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBBeGlzIGV4dGVuZHMgQ29udHJvbCB7XHJcbiAgICBwcml2YXRlIGNvbnRyb2xzOiBNYXA8c3RyaW5nLCBDb250cm9sPiA9IG5ldyBNYXAoKTtcclxuICAgIHByaXZhdGUgc3VtUHJldmlvdXM6IG51bWJlciA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgdGhlIGNvbnRyb2wgZ2l2ZW4gdG8gdGhlIGxpc3Qgb2YgY29udHJvbHMgZmVlZGluZyBpbnRvIHRoaXMgYXhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWRkQ29udHJvbChfY29udHJvbDogQ29udHJvbCk6IHZvaWQge1xyXG4gICAgICB0aGlzLmNvbnRyb2xzLnNldChfY29udHJvbC5uYW1lLCBfY29udHJvbCk7XHJcbiAgICAgIF9jb250cm9sLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRfQ09OVFJPTC5JTlBVVCwgdGhpcy5obmRJbnB1dEV2ZW50KTtcclxuICAgICAgX2NvbnRyb2wuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVF9DT05UUk9MLk9VVFBVVCwgdGhpcy5obmRPdXRwdXRFdmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjb250cm9sIHdpdGggdGhlIGdpdmVuIG5hbWVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldENvbnRyb2woX25hbWU6IHN0cmluZyk6IENvbnRyb2wge1xyXG4gICAgICByZXR1cm4gdGhpcy5jb250cm9scy5nZXQoX25hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgY29udHJvbCB3aXRoIHRoZSBnaXZlbiBuYW1lXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZW1vdmVDb250cm9sKF9uYW1lOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgbGV0IGNvbnRyb2w6IENvbnRyb2wgPSB0aGlzLmdldENvbnRyb2woX25hbWUpO1xyXG4gICAgICBpZiAoY29udHJvbCkge1xyXG4gICAgICAgIGNvbnRyb2wucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVF9DT05UUk9MLklOUFVULCB0aGlzLmhuZElucHV0RXZlbnQpO1xyXG4gICAgICAgIGNvbnRyb2wucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVF9DT05UUk9MLk9VVFBVVCwgdGhpcy5obmRPdXRwdXRFdmVudCk7XHJcbiAgICAgICAgdGhpcy5jb250cm9scy5kZWxldGUoX25hbWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGlzIGF4aXMgYWZ0ZXIgc3VtbWluZyB1cCBhbGwgaW5wdXRzIGFuZCBwcm9jZXNzaW5nIHRoZSBzdW0gYWNjb3JkaW5nIHRvIHRoZSBheGlzJyBzZXR0aW5nc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0T3V0cHV0KCk6IG51bWJlciB7XHJcbiAgICAgIGxldCBzdW1JbnB1dDogbnVtYmVyID0gMDtcclxuICAgICAgZm9yIChsZXQgY29udHJvbCBvZiB0aGlzLmNvbnRyb2xzKSB7XHJcblxyXG4gICAgICAgIGlmIChjb250cm9sWzFdLmFjdGl2ZSlcclxuICAgICAgICAgIHN1bUlucHV0ICs9IGNvbnRyb2xbMV0uZ2V0T3V0cHV0KCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzdW1JbnB1dCAhPSB0aGlzLnN1bVByZXZpb3VzKVxyXG4gICAgICAgIHN1cGVyLnNldElucHV0KHN1bUlucHV0KTtcclxuXHJcbiAgICAgIHRoaXMuc3VtUHJldmlvdXMgPSBzdW1JbnB1dDtcclxuXHJcbiAgICAgIHJldHVybiBzdXBlci5nZXRPdXRwdXQoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGhuZE91dHB1dEV2ZW50OiBFdmVudExpc3RlbmVyID0gKF9ldmVudDogRXZlbnQpOiB2b2lkID0+IHtcclxuICAgICAgaWYgKCF0aGlzLmFjdGl2ZSlcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBsZXQgY29udHJvbDogQ29udHJvbCA9ICg8Q29udHJvbD5fZXZlbnQudGFyZ2V0KTtcclxuICAgICAgbGV0IGV2ZW50OiBDdXN0b21FdmVudCA9IG5ldyBDdXN0b21FdmVudChFVkVOVF9DT05UUk9MLk9VVFBVVCwge2RldGFpbDoge1xyXG4gICAgICAgIGNvbnRyb2w6IGNvbnRyb2wsIFxyXG4gICAgICAgIGlucHV0OiAoPEN1c3RvbUV2ZW50Pl9ldmVudCkuZGV0YWlsLm91dHB1dCxcclxuICAgICAgICBvdXRwdXQ6IHRoaXMuZ2V0T3V0cHV0KClcclxuICAgICAgfX0pO1xyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaG5kSW5wdXRFdmVudDogRXZlbnRMaXN0ZW5lciA9IChfZXZlbnQ6IEV2ZW50KTogdm9pZCA9PiB7XHJcbiAgICAgIGlmICghdGhpcy5hY3RpdmUpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIFxyXG4gICAgICBsZXQgZXZlbnQ6IEV2ZW50ID0gbmV3IEV2ZW50KEVWRU5UX0NPTlRST0wuSU5QVVQsIF9ldmVudCk7XHJcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgaW50ZXJmYWNlIEtleVByZXNzZWQge1xyXG4gICAgW2NvZGU6IHN0cmluZ106IGJvb2xlYW47XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb2xsZWN0cyB0aGUga2V5cyBwcmVzc2VkIG9uIHRoZSBrZXlib2FyZCBhbmQgc3RvcmVzIHRoZWlyIHN0YXR1cy4gXHJcbiAgICovXHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIEtleWJvYXJkIHtcclxuICAgIHByaXZhdGUgc3RhdGljIGtleXNQcmVzc2VkOiBLZXlQcmVzc2VkID0gS2V5Ym9hcmQuaW5pdGlhbGl6ZSgpO1xyXG4gICAgLy8gcHJpdmF0ZSBzdGF0aWMgY29kZV9lbjogT2JqZWN0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIG9uZSBvZiB0aGUgZ2l2ZW4ga2V5cyBpcyBpcyBjdXJyZW50bHkgYmVpbmcgcHJlc3NlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBpc1ByZXNzZWRPbmUoX2tleXM6IEtFWUJPQVJEX0NPREVbXSk6IGJvb2xlYW4ge1xyXG4gICAgICBmb3IgKGxldCBjb2RlIG9mIF9rZXlzKSB7XHJcbiAgICAgICAgaWYgKEtleWJvYXJkLmtleXNQcmVzc2VkW2NvZGVdKVxyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGFsbCBvZiB0aGUgZ2l2ZW4ga2V5cyBhcmUgY3VycmVudGx5IGJlaW5nIHByZXNzZWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBpc1ByZXNzZWRDb21ibyhfa2V5czogS0VZQk9BUkRfQ09ERVtdKTogYm9vbGVhbiB7XHJcbiAgICAgIGZvciAobGV0IGNvZGUgb2YgX2tleXMpIHtcclxuICAgICAgICBpZiAoIUtleWJvYXJkLmtleXNQcmVzc2VkW2NvZGVdKVxyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgZ2l2ZW4gYXMgX2FjdGl2ZSBpZiBvbmUgb3IsIHdoZW4gX2NvbWJvIGlzIHRydWUsIGFsbCBvZiB0aGUgZ2l2ZW4ga2V5cyBhcmUgcHJlc3NlZC5cclxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIGdpdmVuIGFzIF9pbmFjdGl2ZSBpZiBub3QuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgbWFwVG9WYWx1ZTxUPihfYWN0aXZlOiBULCBfaW5hY3RpdmU6IFQsIF9rZXlzOiBLRVlCT0FSRF9DT0RFW10sIF9jb21ibzogYm9vbGVhbiA9IGZhbHNlKTogVCB7XHJcbiAgICAgIGlmICghX2NvbWJvICYmIEtleWJvYXJkLmlzUHJlc3NlZE9uZShfa2V5cykpXHJcbiAgICAgICAgcmV0dXJuIF9hY3RpdmU7XHJcbiAgICAgIGlmIChLZXlib2FyZC5pc1ByZXNzZWRDb21ibyhfa2V5cykpXHJcbiAgICAgICAgcmV0dXJuIF9hY3RpdmU7XHJcbiAgICAgIHJldHVybiBfaW5hY3RpdmU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgYmFsYW5jZWQgdGVybmFyeSB2YWx1ZSAoZWl0aGVyIC0xLCAwIG9yIDEpIFxyXG4gICAgICogYWNjb3JkaW5nIHRvIHRoZSBtYXRjaCBvZiB0aGUga2V5cyBjdXJyZW50bHkgYmVpbmcgcHJlc3NlZCBhbmQgdGhlIGxpc3RzIG9mIGtleXMgZ2l2ZW4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgbWFwVG9Ucml0KF9wb3NpdGl2ZTogS0VZQk9BUkRfQ09ERVtdLCBfbmVnYXRpdmU6IEtFWUJPQVJEX0NPREVbXSk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiBLZXlib2FyZC5tYXBUb1ZhbHVlKC0xLCAwLCBfbmVnYXRpdmUpICsgS2V5Ym9hcmQubWFwVG9WYWx1ZSgxLCAwLCBfcG9zaXRpdmUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHB1YmxpYyBzdGF0aWMgbG9jYWxlKF9rZXlib2FyZDogT2JqZWN0KTogdm9pZCB7XHJcbiAgICAvLyAgIGlmICghS2V5Ym9hcmQuY29kZV9lbikge1xyXG4gICAgLy8gICAgIC8vIHNhdmUgb3JpZ2luYWwga2V5Ym9hcmQgY29kZXMgdG8gYmUgYWJsZSB0byBzd2l0Y2ggYmFjayBsYXRlclxyXG4gICAgLy8gICAgIEtleWJvYXJkLmNvZGVfZW4gPSB7fTtcclxuICAgIC8vICAgICBPYmplY3QuYXNzaWduKEtleWJvYXJkLmNvZGVfZW4sIEtFWUJPQVJEX0NPREUpO1xyXG4gICAgLy8gICB9XHJcblxyXG4gICAgLy8gICBmb3IgKGxldCBrZXkgaW4gX2tleWJvYXJkKSB7XHJcbiAgICAvLyAgICAgbGV0IHZhbHVlOiBzdHJpbmcgPSBSZWZsZWN0LmdldChfa2V5Ym9hcmQsIGtleSk7XHJcbiAgICAvLyAgICAgZm9yIChsZXQgb3JpZ2luYWwgaW4gS0VZQk9BUkRfQ09ERSlcclxuICAgIC8vICAgICAgIGlmIChSZWZsZWN0LmdldChLRVlCT0FSRF9DT0RFLCBvcmlnaW5hbCkgPT0gdmFsdWUpXHJcbiAgICAvLyAgICAgICAgIC8vIHJlbW92ZSBvcmlnaW5hbCBrZXkgdGhlIHlpZWxkcyB0aGUgdmFsdWVcclxuICAgIC8vICAgICAgICAgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShLRVlCT0FSRF9DT0RFLCBvcmlnaW5hbCk7XHJcbiAgICAvLyAgICAgLy8gYWRkIG5ldyBrZXkgdG8geWllbGQgdGhhdCB2YWx1ZVxyXG4gICAgLy8gICAgIFJlZmxlY3Quc2V0KEtFWUJPQVJEX0NPREUsIGtleSwgdmFsdWUpO1xyXG4gICAgLy8gICB9XHJcbiAgICAvLyB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgaW5pdGlhbGl6ZSgpOiBLZXlQcmVzc2VkIHtcclxuICAgICAgbGV0IHN0b3JlOiBLZXlQcmVzc2VkID0ge307XHJcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIEtleWJvYXJkLmhuZEtleUludGVyYWN0aW9uKTtcclxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIEtleWJvYXJkLmhuZEtleUludGVyYWN0aW9uKTtcclxuICAgICAgcmV0dXJuIHN0b3JlO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGhuZEtleUludGVyYWN0aW9uKF9ldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xyXG4gICAgICBLZXlib2FyZC5rZXlzUHJlc3NlZFtfZXZlbnQuY29kZV0gPSAoX2V2ZW50LnR5cGUgPT0gXCJrZXlkb3duXCIpO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiRGVidWdUYXJnZXQudHNcIi8+XHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFJvdXRpbmcgdG8gdGhlIGFsZXJ0IGJveFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBEZWJ1Z0FsZXJ0IGV4dGVuZHMgRGVidWdUYXJnZXQge1xyXG4gICAgcHVibGljIHN0YXRpYyBkZWxlZ2F0ZXM6IE1hcERlYnVnRmlsdGVyVG9EZWxlZ2F0ZSA9IHtcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5JTkZPXTogRGVidWdBbGVydC5jcmVhdGVEZWxlZ2F0ZShERUJVR19TWU1CT0xbREVCVUdfRklMVEVSLklORk9dKSxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5MT0ddOiBEZWJ1Z0FsZXJ0LmNyZWF0ZURlbGVnYXRlKERFQlVHX1NZTUJPTFtERUJVR19GSUxURVIuTE9HXSksXHJcbiAgICAgIFtERUJVR19GSUxURVIuV0FSTl06IERlYnVnQWxlcnQuY3JlYXRlRGVsZWdhdGUoREVCVUdfU1lNQk9MW0RFQlVHX0ZJTFRFUi5XQVJOXSksXHJcbiAgICAgIFtERUJVR19GSUxURVIuRVJST1JdOiBEZWJ1Z0FsZXJ0LmNyZWF0ZURlbGVnYXRlKERFQlVHX1NZTUJPTFtERUJVR19GSUxURVIuRVJST1JdKSxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5GVURHRV06IERlYnVnQWxlcnQuY3JlYXRlRGVsZWdhdGUoREVCVUdfU1lNQk9MW0RFQlVHX0ZJTFRFUi5GVURHRV0pLFxyXG4gICAgICBbREVCVUdfRklMVEVSLlNPVVJDRV06IERlYnVnQWxlcnQuY3JlYXRlRGVsZWdhdGUoREVCVUdfU1lNQk9MW0RFQlVHX0ZJTFRFUi5TT1VSQ0VdKVxyXG4gICAgfTtcclxuICAgIHB1YmxpYyBzdGF0aWMgY3JlYXRlRGVsZWdhdGUoX2hlYWRsaW5lOiBzdHJpbmcpOiBGdW5jdGlvbiB7XHJcbiAgICAgIGxldCBkZWxlZ2F0ZTogRnVuY3Rpb24gPSBmdW5jdGlvbiAoX21lc3NhZ2U6IE9iamVjdCwgLi4uX2FyZ3M6IE9iamVjdFtdKTogdm9pZCB7XHJcbiAgICAgICAgbGV0IGFyZ3M6IHN0cmluZ1tdID0gX2FyZ3MubWFwKF9hcmcgPT4gX2FyZy50b1N0cmluZygpKTtcclxuICAgICAgICBsZXQgb3V0OiBzdHJpbmcgPSBfaGVhZGxpbmUgKyBcIiBcIiArIERlYnVnVGFyZ2V0Lm1lcmdlQXJndW1lbnRzKF9tZXNzYWdlLCBhcmdzKTtcclxuICAgICAgICBhbGVydChvdXQpO1xyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gZGVsZWdhdGU7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwiLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCJEZWJ1Z1RhcmdldC50c1wiLz5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgICAvKipcclxuICAgICAqIFJvdXRpbmcgdG8gYSBIVE1MRGlhbG9nRWxlbWVudFxyXG4gICAgICovXHJcbiAgICBleHBvcnQgY2xhc3MgRGVidWdEaWFsb2cgZXh0ZW5kcyBEZWJ1Z1RhcmdldCB7XHJcbiAgICAgICAgLy8gVE9ETzogY2hlY2tvdXQgSFRNTERpYWxvZ0VsZW1lbnQ7ICEhIVxyXG4gICAgfVxyXG59IiwiLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCJEZWJ1Z1RhcmdldC50c1wiLz5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogUm91dGUgdG8gYW4gSFRNTFRleHRBcmVhLCBtYXkgYmUgb2Jzb2xldGUgd2hlbiB1c2luZyBIVE1MRGlhbG9nRWxlbWVudFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBEZWJ1Z1RleHRBcmVhIGV4dGVuZHMgRGVidWdUYXJnZXQge1xyXG4gICAgcHVibGljIHN0YXRpYyB0ZXh0QXJlYTogSFRNTFRleHRBcmVhRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKTtcclxuICAgIHB1YmxpYyBzdGF0aWMgYXV0b1Njcm9sbDogYm9vbGVhbiA9IHRydWU7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBkZWxlZ2F0ZXM6IE1hcERlYnVnRmlsdGVyVG9EZWxlZ2F0ZSA9IHtcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5JTkZPXTogRGVidWdUZXh0QXJlYS5jcmVhdGVEZWxlZ2F0ZShERUJVR19TWU1CT0xbREVCVUdfRklMVEVSLklORk9dKSxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5MT0ddOiBEZWJ1Z1RleHRBcmVhLmNyZWF0ZURlbGVnYXRlKERFQlVHX1NZTUJPTFtERUJVR19GSUxURVIuTE9HXSksXHJcbiAgICAgIFtERUJVR19GSUxURVIuV0FSTl06IERlYnVnVGV4dEFyZWEuY3JlYXRlRGVsZWdhdGUoREVCVUdfU1lNQk9MW0RFQlVHX0ZJTFRFUi5XQVJOXSksXHJcbiAgICAgIFtERUJVR19GSUxURVIuRVJST1JdOiBEZWJ1Z1RleHRBcmVhLmNyZWF0ZURlbGVnYXRlKERFQlVHX1NZTUJPTFtERUJVR19GSUxURVIuRVJST1JdKSxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5GVURHRV06IERlYnVnVGV4dEFyZWEuY3JlYXRlRGVsZWdhdGUoREVCVUdfU1lNQk9MW0RFQlVHX0ZJTFRFUi5GVURHRV0pLFxyXG4gICAgICBbREVCVUdfRklMVEVSLkNMRUFSXTogRGVidWdUZXh0QXJlYS5jbGVhcixcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5HUk9VUF06IERlYnVnVGV4dEFyZWEuZ3JvdXAsXHJcbiAgICAgIFtERUJVR19GSUxURVIuR1JPVVBDT0xMQVBTRURdOiBEZWJ1Z1RleHRBcmVhLmdyb3VwLFxyXG4gICAgICBbREVCVUdfRklMVEVSLkdST1VQRU5EXTogRGVidWdUZXh0QXJlYS5ncm91cEVuZCxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5TT1VSQ0VdOiBEZWJ1Z1RleHRBcmVhLmNyZWF0ZURlbGVnYXRlKERFQlVHX1NZTUJPTFtERUJVR19GSUxURVIuU09VUkNFXSlcclxuICAgIH07XHJcbiAgICBwcml2YXRlIHN0YXRpYyBncm91cHM6IHN0cmluZ1tdID0gW107XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBjbGVhcigpOiB2b2lkIHtcclxuICAgICAgRGVidWdUZXh0QXJlYS50ZXh0QXJlYS50ZXh0Q29udGVudCA9IFwiXCI7XHJcbiAgICAgIERlYnVnVGV4dEFyZWEuZ3JvdXBzID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBncm91cChfbmFtZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgIERlYnVnVGV4dEFyZWEucHJpbnQoXCLilrwgXCIgKyBfbmFtZSk7XHJcbiAgICAgIERlYnVnVGV4dEFyZWEuZ3JvdXBzLnB1c2goX25hbWUpO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHN0YXRpYyBncm91cEVuZCgpOiB2b2lkIHtcclxuICAgICAgRGVidWdUZXh0QXJlYS5ncm91cHMucG9wKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBjcmVhdGVEZWxlZ2F0ZShfaGVhZGxpbmU6IHN0cmluZyk6IEZ1bmN0aW9uIHtcclxuICAgICAgbGV0IGRlbGVnYXRlOiBGdW5jdGlvbiA9IGZ1bmN0aW9uIChfbWVzc2FnZTogT2JqZWN0LCAuLi5fYXJnczogT2JqZWN0W10pOiB2b2lkIHtcclxuICAgICAgICBEZWJ1Z1RleHRBcmVhLnByaW50KF9oZWFkbGluZSArIFwiIFwiICsgRGVidWdUYXJnZXQubWVyZ2VBcmd1bWVudHMoX21lc3NhZ2UsIF9hcmdzKSk7XHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBkZWxlZ2F0ZTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBnZXRJbmRlbnRhdGlvbihfbGV2ZWw6IG51bWJlcik6IHN0cmluZyB7XHJcbiAgICAgIGxldCByZXN1bHQ6IHN0cmluZyA9IFwiXCI7XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBfbGV2ZWw7IGkrKylcclxuICAgICAgICByZXN1bHQgKz0gXCJ8IFwiO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIHByaW50KF90ZXh0OiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgRGVidWdUZXh0QXJlYS50ZXh0QXJlYS50ZXh0Q29udGVudCArPSBEZWJ1Z1RleHRBcmVhLmdldEluZGVudGF0aW9uKERlYnVnVGV4dEFyZWEuZ3JvdXBzLmxlbmd0aCkgKyBfdGV4dCArIFwiXFxuXCI7XHJcbiAgICAgIGlmIChEZWJ1Z1RleHRBcmVhLmF1dG9TY3JvbGwpXHJcbiAgICAgICAgRGVidWdUZXh0QXJlYS50ZXh0QXJlYS5zY3JvbGxUb3AgPSBEZWJ1Z1RleHRBcmVhLnRleHRBcmVhLnNjcm9sbEhlaWdodDtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgY29uc3QgZW51bSBFVkVOVF9BVURJTyB7XHJcbiAgICAvKiogYnJvYWRjYXN0IHRvIGEge0BsaW5rIE5vZGV9IGFuZCBhbGwgaXRzIGRlc2NlbmRhbnRzIGluIHRoZSBncmFwaCBhZnRlciBpdCB3YXMgYXBwZW5kZWQgdG8gYSBwYXJlbnQgKi9cclxuICAgIENISUxEX0FQUEVORCA9IFwiY2hpbGRBcHBlbmRUb0F1ZGlvR3JhcGhcIixcclxuICAgIC8qKiBicm9hZGNhc3QgdG8gYSB7QGxpbmsgTm9kZX0gYW5kIGFsbCBpdHMgZGVzY2VuZGFudHMgaW4gdGhlIGdyYXBoIGp1c3QgYmVmb3JlIGl0cyBiZWluZyByZW1vdmVkIGZyb20gaXRzIHBhcmVudCAqL1xyXG4gICAgQ0hJTERfUkVNT1ZFID0gXCJjaGlsZFJlbW92ZUZyb21BdWRpb0dyYXBoXCIsXHJcbiAgICAvKiogYnJvYWRjYXN0IHRvIGEge0BsaW5rIE5vZGV9IGFuZCBhbGwgaXRzIGRlc2NlbmRhbnRzIGluIHRoZSBncmFwaCB0byB1cGRhdGUgdGhlIHBhbm5lcnMgaW4gQXVkaW9Db21wb25lbnRzICovXHJcbiAgICBVUERBVEUgPSBcInVwZGF0ZUF1ZGlvR3JhcGhcIixcclxuICAgIC8qKiBmaXJlZCB3aGVuIHRoZSBhdWRpbyBmaWxlIHdhcyBsb2FkZWQgYW5kIGlzIHJlYWR5IGZvciBwbGF5aW5nICovXHJcbiAgICBSRUFEWSA9IFwicmVhZHlcIixcclxuICAgIC8qKiBmaXJlZCB3aGVuIHRoZSBlbmQgb2YgdGhlIGF1ZGlvIGlzIHJlYWNoZWQgd2hpbGUgcGxheWluZyAqL1xyXG4gICAgRU5ERUQgPSBcImVuZGVkXCJcclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAgIGV4cG9ydCBjb25zdCBlbnVtIEVWRU5UX0RSQUdEUk9QIHtcclxuICAgICAgICBEUkFHID0gXCLGkmRyYWdcIixcclxuICAgICAgICBEUk9QID0gXCLGkmRyb3BcIixcclxuICAgICAgICBTVEFSVCA9IFwixpJkcmFnc3RhcnRcIixcclxuICAgICAgICBFTkQgPSBcIsaSZHJhZ2VuZFwiLFxyXG4gICAgICAgIE9WRVIgPSBcIsaSZHJhZ292ZXJcIlxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBhIHN1YmNsYXNzIG9mIERyYWdFdmVudCAuQSBldmVudCB0aGF0IHJlcHJlc2VudHMgYSBkcmFnIGFuZCBkcm9wIGludGVyYWN0aW9uXHJcbiAgICAgKi9cclxuICAgIGV4cG9ydCBjbGFzcyBFdmVudERyYWdEcm9wIGV4dGVuZHMgRHJhZ0V2ZW50IHtcclxuICAgICAgICBwdWJsaWMgcG9pbnRlclg6IG51bWJlcjtcclxuICAgICAgICBwdWJsaWMgcG9pbnRlclk6IG51bWJlcjtcclxuICAgICAgICBwdWJsaWMgY2FudmFzWDogbnVtYmVyO1xyXG4gICAgICAgIHB1YmxpYyBjYW52YXNZOiBudW1iZXI7XHJcbiAgICAgICAgcHVibGljIGNsaWVudFJlY3Q6IENsaWVudFJlY3Q7XHJcblxyXG4gICAgICAgIGNvbnN0cnVjdG9yKHR5cGU6IHN0cmluZywgX2V2ZW50OiBFdmVudERyYWdEcm9wKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKHR5cGUsIF9ldmVudCk7XHJcbiAgICAgICAgICAgIGxldCB0YXJnZXQ6IEhUTUxFbGVtZW50ID0gPEhUTUxFbGVtZW50Pl9ldmVudC50YXJnZXQ7XHJcbiAgICAgICAgICAgIHRoaXMuY2xpZW50UmVjdCA9IHRhcmdldC5nZXRDbGllbnRSZWN0cygpWzBdO1xyXG4gICAgICAgICAgICB0aGlzLnBvaW50ZXJYID0gX2V2ZW50LmNsaWVudFggLSB0aGlzLmNsaWVudFJlY3QubGVmdDtcclxuICAgICAgICAgICAgdGhpcy5wb2ludGVyWSA9IF9ldmVudC5jbGllbnRZIC0gdGhpcy5jbGllbnRSZWN0LnRvcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBhIHN1YmNsYXNzIG9mIEtleWJvYXJkRXZlbnQuIEV2ZW50S2V5Ym9hcmQgb2JqZWN0cyBkZXNjcmliZSBhIHVzZXIgaW50ZXJhY3Rpb24gd2l0aCB0aGUga2V5Ym9hcmRcclxuICAgKiBlYWNoIGV2ZW50IGRlc2NyaWJlcyBhIHNpbmdsZSBpbnRlcmFjdGlvbiBiZXR3ZWVuIHRoZSB1c2VyIGFuZCBhIGtleSAob3IgY29tYmluYXRpb24gb2YgYSBrZXkgd2l0aCBtb2RpZmllciBrZXlzKSBvbiB0aGUga2V5Ym9hcmQuXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEV2ZW50S2V5Ym9hcmQgZXh0ZW5kcyBLZXlib2FyZEV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHR5cGU6IHN0cmluZywgX2V2ZW50OiBFdmVudEtleWJvYXJkKSB7XHJcbiAgICAgIHN1cGVyKHR5cGUsIF9ldmVudCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNYXBwaW5ncyBvZiBzdGFuZGFyZCBET00vQnJvd3Nlci1FdmVudHMgYXMgcGFzc2VkIGZyb20gYSBjYW52YXMgdG8gdGhlIHZpZXdwb3J0XHJcbiAgICovXHJcbiAgZXhwb3J0IGNvbnN0IGVudW0gRVZFTlRfS0VZQk9BUkQge1xyXG4gICAgVVAgPSBcIsaSa2V5dXBcIixcclxuICAgIERPV04gPSBcIsaSa2V5ZG93blwiLFxyXG4gICAgUFJFU1MgPSBcIsaSa2V5cHJlc3NcIlxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGNvZGVzIHNlbnQgZnJvbSBhIHN0YW5kYXJkIGVuZ2xpc2gga2V5Ym9hcmQgbGF5b3V0XHJcbiAgICovXHJcbiAgZXhwb3J0IGVudW0gS0VZQk9BUkRfQ09ERSB7XHJcbiAgICBBID0gXCJLZXlBXCIsXHJcbiAgICBCID0gXCJLZXlCXCIsXHJcbiAgICBDID0gXCJLZXlDXCIsXHJcbiAgICBEID0gXCJLZXlEXCIsXHJcbiAgICBFID0gXCJLZXlFXCIsXHJcbiAgICBGID0gXCJLZXlGXCIsXHJcbiAgICBHID0gXCJLZXlHXCIsXHJcbiAgICBIID0gXCJLZXlIXCIsXHJcbiAgICBJID0gXCJLZXlJXCIsXHJcbiAgICBKID0gXCJLZXlKXCIsXHJcbiAgICBLID0gXCJLZXlLXCIsXHJcbiAgICBMID0gXCJLZXlMXCIsXHJcbiAgICBNID0gXCJLZXlNXCIsXHJcbiAgICBOID0gXCJLZXlOXCIsXHJcbiAgICBPID0gXCJLZXlPXCIsXHJcbiAgICBQID0gXCJLZXlQXCIsXHJcbiAgICBRID0gXCJLZXlRXCIsXHJcbiAgICBSID0gXCJLZXlSXCIsXHJcbiAgICBTID0gXCJLZXlTXCIsXHJcbiAgICBUID0gXCJLZXlUXCIsXHJcbiAgICBVID0gXCJLZXlVXCIsXHJcbiAgICBWID0gXCJLZXlWXCIsXHJcbiAgICBXID0gXCJLZXlXXCIsXHJcbiAgICBYID0gXCJLZXlYXCIsXHJcbiAgICBZID0gXCJLZXlZXCIsXHJcbiAgICBaID0gXCJLZXlaXCIsXHJcbiAgICBFU0MgPSBcIkVzY2FwZVwiLFxyXG4gICAgWkVSTyA9IFwiRGlnaXQwXCIsXHJcbiAgICBPTkUgPSBcIkRpZ2l0MVwiLFxyXG4gICAgVFdPID0gXCJEaWdpdDJcIixcclxuICAgIFRIUkVFID0gXCJEaWdpdDNcIixcclxuICAgIEZPVVIgPSBcIkRpZ2l0NFwiLFxyXG4gICAgRklWRSA9IFwiRGlnaXQ1XCIsXHJcbiAgICBTSVggPSBcIkRpZ2l0NlwiLFxyXG4gICAgU0VWRU4gPSBcIkRpZ2l0N1wiLFxyXG4gICAgRUlHSFQgPSBcIkRpZ2l0OFwiLFxyXG4gICAgTklORSA9IFwiRGlnaXQ5XCIsXHJcbiAgICBNSU5VUyA9IFwiTWludXNcIixcclxuICAgIEVRVUFMID0gXCJFcXVhbFwiLFxyXG4gICAgQkFDS1NQQUNFID0gXCJCYWNrc3BhY2VcIixcclxuICAgIFRBQlVMQVRPUiA9IFwiVGFiXCIsXHJcbiAgICBCUkFDS0VUX0xFRlQgPSBcIkJyYWNrZXRMZWZ0XCIsXHJcbiAgICBCUkFDS0VUX1JJR0hUID0gXCJCcmFja2V0UmlnaHRcIixcclxuICAgIEVOVEVSID0gXCJFbnRlclwiLFxyXG4gICAgQ1RSTF9MRUZUID0gXCJDb250cm9sTGVmdFwiLFxyXG4gICAgU0VNSUNPTE9OID0gXCJTZW1pY29sb25cIixcclxuICAgIFFVT1RFID0gXCJRdW90ZVwiLFxyXG4gICAgQkFDS19RVU9URSA9IFwiQmFja3F1b3RlXCIsXHJcbiAgICBTSElGVF9MRUZUID0gXCJTaGlmdExlZnRcIixcclxuICAgIEJBQ0tTTEFTSCA9IFwiQmFja3NsYXNoXCIsXHJcbiAgICBDT01NQSA9IFwiQ29tbWFcIixcclxuICAgIFBFUklPRCA9IFwiUGVyaW9kXCIsXHJcbiAgICBTTEFTSCA9IFwiU2xhc2hcIixcclxuICAgIFNISUZUX1JJR0hUID0gXCJTaGlmdFJpZ2h0XCIsXHJcbiAgICBOVU1QQURfTVVMVElQTFkgPSBcIk51bXBhZE11bHRpcGx5XCIsXHJcbiAgICBBTFRfTEVGVCA9IFwiQWx0TGVmdFwiLFxyXG4gICAgU1BBQ0UgPSBcIlNwYWNlXCIsXHJcbiAgICBDQVBTX0xPQ0sgPSBcIkNhcHNMb2NrXCIsXHJcbiAgICBGMSA9IFwiRjFcIixcclxuICAgIEYyID0gXCJGMlwiLFxyXG4gICAgRjMgPSBcIkYzXCIsXHJcbiAgICBGNCA9IFwiRjRcIixcclxuICAgIEY1ID0gXCJGNVwiLFxyXG4gICAgRjYgPSBcIkY2XCIsXHJcbiAgICBGNyA9IFwiRjdcIixcclxuICAgIEY4ID0gXCJGOFwiLFxyXG4gICAgRjkgPSBcIkY5XCIsXHJcbiAgICBGMTAgPSBcIkYxMFwiLFxyXG4gICAgUEFVU0UgPSBcIlBhdXNlXCIsXHJcbiAgICBTQ1JPTExfTE9DSyA9IFwiU2Nyb2xsTG9ja1wiLFxyXG4gICAgTlVNUEFENyA9IFwiTnVtcGFkN1wiLFxyXG4gICAgTlVNUEFEOCA9IFwiTnVtcGFkOFwiLFxyXG4gICAgTlVNUEFEOSA9IFwiTnVtcGFkOVwiLFxyXG4gICAgTlVNUEFEX1NVQlRSQUNUID0gXCJOdW1wYWRTdWJ0cmFjdFwiLFxyXG4gICAgTlVNUEFENCA9IFwiTnVtcGFkNFwiLFxyXG4gICAgTlVNUEFENSA9IFwiTnVtcGFkNVwiLFxyXG4gICAgTlVNUEFENiA9IFwiTnVtcGFkNlwiLFxyXG4gICAgTlVNUEFEX0FERCA9IFwiTnVtcGFkQWRkXCIsXHJcbiAgICBOVU1QQUQxID0gXCJOdW1wYWQxXCIsXHJcbiAgICBOVU1QQUQyID0gXCJOdW1wYWQyXCIsXHJcbiAgICBOVU1QQUQzID0gXCJOdW1wYWQzXCIsXHJcbiAgICBOVU1QQUQwID0gXCJOdW1wYWQwXCIsXHJcbiAgICBOVU1QQURfREVDSU1BTCA9IFwiTnVtcGFkRGVjaW1hbFwiLFxyXG4gICAgUFJJTlRfU0NSRUVOID0gXCJQcmludFNjcmVlblwiLFxyXG4gICAgSU5UTF9CQUNLX1NMQVNIID0gXCJJbnRsQmFja1NsYXNoXCIsXHJcbiAgICBGMTEgPSBcIkYxMVwiLFxyXG4gICAgRjEyID0gXCJGMTJcIixcclxuICAgIE5VTVBBRF9FUVVBTCA9IFwiTnVtcGFkRXF1YWxcIixcclxuICAgIEYxMyA9IFwiRjEzXCIsXHJcbiAgICBGMTQgPSBcIkYxNFwiLFxyXG4gICAgRjE1ID0gXCJGMTVcIixcclxuICAgIEYxNiA9IFwiRjE2XCIsXHJcbiAgICBGMTcgPSBcIkYxN1wiLFxyXG4gICAgRjE4ID0gXCJGMThcIixcclxuICAgIEYxOSA9IFwiRjE5XCIsXHJcbiAgICBGMjAgPSBcIkYyMFwiLFxyXG4gICAgRjIxID0gXCJGMjFcIixcclxuICAgIEYyMiA9IFwiRjIyXCIsXHJcbiAgICBGMjMgPSBcIkYyM1wiLFxyXG4gICAgRjI0ID0gXCJGMjRcIixcclxuICAgIEtBTkFfTU9ERSA9IFwiS2FuYU1vZGVcIixcclxuICAgIExBTkcyID0gXCJMYW5nMlwiLFxyXG4gICAgTEFORzEgPSBcIkxhbmcxXCIsXHJcbiAgICBJTlRMX1JPID0gXCJJbnRsUm9cIixcclxuICAgIENPTlZFUlQgPSBcIkNvbnZlcnRcIixcclxuICAgIE5PTl9DT05WRVJUID0gXCJOb25Db252ZXJ0XCIsXHJcbiAgICBJTlRMX1lFTiA9IFwiSW50bFllblwiLFxyXG4gICAgTlVNUEFEX0NPTU1BID0gXCJOdW1wYWRDb21tYVwiLFxyXG4gICAgVU5ETyA9IFwiVW5kb1wiLFxyXG4gICAgUEFTVEUgPSBcIlBhc3RlXCIsXHJcbiAgICBNRURJQV9UUkFDS19QUkVWSU9VUyA9IFwiTWVkaWFUcmFja1ByZXZpb3VzXCIsXHJcbiAgICBDVVQgPSBcIkN1dFwiLFxyXG4gICAgQ09QWSA9IFwiQ29weVwiLFxyXG4gICAgTUVESUFfVFJBQ0tfTkVYVCA9IFwiTWVkaWFUcmFja05leHRcIixcclxuICAgIE5VTVBBRF9FTlRFUiA9IFwiTnVtcGFkRW50ZXJcIixcclxuICAgIENUUkxfUklHSFQgPSBcIkNvbnRyb2xSaWdodFwiLFxyXG4gICAgQVVESU9fVk9MVU1FX01VVEUgPSBcIkF1ZGlvVm9sdW1lTXV0ZVwiLFxyXG4gICAgTEFVTkNIX0FQUDIgPSBcIkxhdW5jaEFwcDJcIixcclxuICAgIE1FRElBX1BMQVlfUEFVU0UgPSBcIk1lZGlhUGxheVBhdXNlXCIsXHJcbiAgICBNRURJQV9TVE9QID0gXCJNZWRpYVN0b3BcIixcclxuICAgIEVKRUNUID0gXCJFamVjdFwiLFxyXG4gICAgQVVESU9fVk9MVU1FX0RPV04gPSBcIkF1ZGlvVm9sdW1lRG93blwiLFxyXG4gICAgVk9MVU1FX0RPV04gPSBcIlZvbHVtZURvd25cIixcclxuICAgIEFVRElPX1ZPTFVNRV9VUCA9IFwiQXVkaW9Wb2x1bWVVcFwiLFxyXG4gICAgVk9MVU1FX1VQID0gXCJWb2x1bWVVcFwiLFxyXG4gICAgQlJPV1NFUl9IT01FID0gXCJCcm93c2VySG9tZVwiLFxyXG4gICAgTlVNUEFEX0RJVklERSA9IFwiTnVtcGFkRGl2aWRlXCIsXHJcbiAgICBBTFRfUklHSFQgPSBcIkFsdFJpZ2h0XCIsXHJcbiAgICBIRUxQID0gXCJIZWxwXCIsXHJcbiAgICBOVU1fTE9DSyA9IFwiTnVtTG9ja1wiLFxyXG4gICAgSE9NRSA9IFwiSG9tZVwiLFxyXG4gICAgQVJST1dfVVAgPSBcIkFycm93VXBcIixcclxuICAgIEFSUk9XX1JJR0hUID0gXCJBcnJvd1JpZ2h0XCIsXHJcbiAgICBBUlJPV19ET1dOID0gXCJBcnJvd0Rvd25cIixcclxuICAgIEFSUk9XX0xFRlQgPSBcIkFycm93TGVmdFwiLFxyXG4gICAgRU5EID0gXCJFbmRcIixcclxuICAgIFBBR0VfVVAgPSBcIlBhZ2VVcFwiLFxyXG4gICAgUEFHRV9ET1dOID0gXCJQYWdlRG93blwiLFxyXG4gICAgSU5TRVJUID0gXCJJbnNlcnRcIixcclxuICAgIERFTEVURSA9IFwiRGVsZXRlXCIsXHJcbiAgICBNRVRBX0xFRlQgPSBcIk1ldGFfTGVmdFwiLFxyXG4gICAgT1NfTEVGVCA9IFwiT1NMZWZ0XCIsXHJcbiAgICBNRVRBX1JJR0hUID0gXCJNZXRhUmlnaHRcIixcclxuICAgIE9TX1JJR0hUID0gXCJPU1JpZ2h0XCIsXHJcbiAgICBDT05URVhUX01FTlUgPSBcIkNvbnRleHRNZW51XCIsXHJcbiAgICBQT1dFUiA9IFwiUG93ZXJcIixcclxuICAgIEJST1dTRVJfU0VBUkNIID0gXCJCcm93c2VyU2VhcmNoXCIsXHJcbiAgICBCUk9XU0VSX0ZBVk9SSVRFUyA9IFwiQnJvd3NlckZhdm9yaXRlc1wiLFxyXG4gICAgQlJPV1NFUl9SRUZSRVNIID0gXCJCcm93c2VyUmVmcmVzaFwiLFxyXG4gICAgQlJPV1NFUl9TVE9QID0gXCJCcm93c2VyU3RvcFwiLFxyXG4gICAgQlJPV1NFUl9GT1JXQVJEID0gXCJCcm93c2VyRm9yd2FyZFwiLFxyXG4gICAgQlJPV1NFUl9CQUNLID0gXCJCcm93c2VyQmFja1wiLFxyXG4gICAgTEFVTkNIX0FQUDEgPSBcIkxhdW5jaEFwcDFcIixcclxuICAgIExBVU5DSF9NQUlMID0gXCJMYXVuY2hNYWlsXCIsXHJcbiAgICBMQVVOQ0hfTUVESUFfUExBWUVSID0gXCJMYXVuY2hNZWRpYVBsYXllclwiLFxyXG5cclxuICAgIC8vbWFjIGJyaW5ncyB0aGlzIGJ1dHR0b25cclxuICAgIEZOID0gXCJGblwiLCAvL25vIGV2ZW50IGZpcmVkIGFjdHVhbGx5XHJcblxyXG4gICAgLy9MaW51eCBicmluZ3MgdGhlc2VcclxuICAgIEFHQUlOID0gXCJBZ2FpblwiLFxyXG4gICAgUFJPUFMgPSBcIlByb3BzXCIsXHJcbiAgICBTRUxFQ1QgPSBcIlNlbGVjdFwiLFxyXG4gICAgT1BFTiA9IFwiT3BlblwiLFxyXG4gICAgRklORCA9IFwiRmluZFwiLFxyXG4gICAgV0FLRV9VUCA9IFwiV2FrZVVwXCIsXHJcbiAgICBOVU1QQURfUEFSRU5UX0xFRlQgPSBcIk51bXBhZFBhcmVudExlZnRcIixcclxuICAgIE5VTVBBRF9QQVJFTlRfUklHSFQgPSBcIk51bXBhZFBhcmVudFJpZ2h0XCIsXHJcblxyXG4gICAgLy9hbmRyb2lkXHJcbiAgICBTTEVFUCA9IFwiU2xlZXBcIlxyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGVudW0gS0VZQk9BUkRfQ09ERV9ERSB7XHJcbiAgICBaID0gS0VZQk9BUkRfQ09ERS5ZLFxyXG4gICAgWSA9IEtFWUJPQVJEX0NPREUuWixcclxuICAgIMOWID0gS0VZQk9BUkRfQ09ERS5TRU1JQ09MT04sXHJcbiAgICDDhCA9IEtFWUJPQVJEX0NPREUuUVVPVEUsXHJcbiAgICDDnCA9IEtFWUJPQVJEX0NPREUuQlJBQ0tFVF9MRUZULFxyXG4gICAgSEFTSCA9IEtFWUJPQVJEX0NPREUuQkFDS1NMQVNILFxyXG4gICAgUExVUyA9IEtFWUJPQVJEX0NPREUuQlJBQ0tFVF9SSUdIVCxcclxuICAgIMOfID0gS0VZQk9BUkRfQ09ERS5NSU5VUyxcclxuICAgIEFDVVRFID0gS0VZQk9BUkRfQ09ERS5FUVVBTCxcclxuICAgIExFU1NfVEhBTiA9IEtFWUJPQVJEX0NPREUuSU5UTF9CQUNLX1NMQVNILFxyXG4gICAgTUlOVVMgPSBLRVlCT0FSRF9DT0RFLlNMQVNIXHJcbiAgfVxyXG5cclxuICAvKiBcclxuICBGaXJlZm94IGNhbid0IG1ha2UgdXNlIG9mIHRob3NlIGJ1dHRvbnMgYW5kIENvbWJpbmF0aW9uczpcclxuICBTSU5HRUxFX0JVVFRPTlM6XHJcbiAgIERydWNrLFxyXG4gIENPTUJJTkFUSU9OUzpcclxuICAgU2hpZnQgKyBGMTAsIFNoaWZ0ICsgTnVtcGFkNSxcclxuICAgQ1RSTCArIHEsIENUUkwgKyBGNCxcclxuICAgQUxUICsgRjEsIEFMVCArIEYyLCBBTFQgKyBGMywgQUxUICsgRjcsIEFMVCArIEY4LCBBTFQgKyBGMTBcclxuICBPcGVyYSB3b24ndCBkbyBnb29kIHdpdGggdGhlc2UgQnV0dG9ucyBhbmQgY29tYmluYXRpb25zOlxyXG4gIFNJTkdMRV9CVVRUT05TOlxyXG4gICBGbG9hdDMyQXJyYXksIEYxMSwgQUxULFxyXG4gIENPTUJJTkFUSU9OUzpcclxuICAgQ1RSTCArIHEsIENUUkwgKyB0LCBDVFJMICsgaCwgQ1RSTCArIGcsIENUUkwgKyBuLCBDVFJMICsgZiBcclxuICAgQUxUICsgRjEsIEFMVCArIEYyLCBBTFQgKyBGNCwgQUxUICsgRjUsIEFMVCArIEY2LCBBTFQgKyBGNywgQUxUICsgRjgsIEFMVCArIEYxMFxyXG4gICAqL1xyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgICBleHBvcnQgY29uc3QgZW51bSBFVkVOVF9QT0lOVEVSIHtcclxuICAgICAgICBVUCA9IFwixpJwb2ludGVydXBcIixcclxuICAgICAgICBET1dOID0gXCLGknBvaW50ZXJkb3duXCIsXHJcbiAgICAgICAgTU9WRSA9IFwixpJwb2ludGVybW92ZVwiLFxyXG4gICAgICAgIE9WRVIgPSBcIsaScG9pbnRlcm92ZXJcIixcclxuICAgICAgICBFTlRFUiA9IFwixpJwb2ludGVyZW50ZXJcIixcclxuICAgICAgICBDQU5DRUwgPSBcIsaScG9pbnRlcmNhbmNlbFwiLFxyXG4gICAgICAgIE9VVCA9IFwixpJwb2ludGVyb3V0XCIsXHJcbiAgICAgICAgTEVBVkUgPSBcIsaScG9pbnRlcmxlYXZlXCIsXHJcbiAgICAgICAgR09UQ0FQVFVSRSA9IFwixpJnb3Rwb2ludGVyY2FwdHVyZVwiLFxyXG4gICAgICAgIExPU1RDQVBUVVJFID0gXCLGkmxvc3Rwb2ludGVyY2FwdHVyZVwiXHJcbiAgICB9XHJcbiAgICAvKiogIFxyXG4gICAgICogYSBzdWJjbGFzcyBvZiBQb2ludGVyRXZlbnQuIFRoZSBzdGF0ZSBvZiBhIERPTSBldmVudCBwcm9kdWNlZCBieSBhIHBvaW50ZXIgc3VjaCBhcyB0aGUgZ2VvbWV0cnkgb2YgdGhlIGNvbnRhY3QgcG9pbnRcclxuICAgICAqICovXHJcbiAgICBleHBvcnQgY2xhc3MgRXZlbnRQb2ludGVyIGV4dGVuZHMgUG9pbnRlckV2ZW50IHtcclxuICAgICAgICBwdWJsaWMgcG9pbnRlclg6IG51bWJlcjtcclxuICAgICAgICBwdWJsaWMgcG9pbnRlclk6IG51bWJlcjtcclxuICAgICAgICBwdWJsaWMgY2FudmFzWDogbnVtYmVyO1xyXG4gICAgICAgIHB1YmxpYyBjYW52YXNZOiBudW1iZXI7XHJcbiAgICAgICAgcHVibGljIGNsaWVudFJlY3Q6IENsaWVudFJlY3Q7XHJcblxyXG4gICAgICAgIGNvbnN0cnVjdG9yKHR5cGU6IHN0cmluZywgX2V2ZW50OiBFdmVudFBvaW50ZXIpIHtcclxuICAgICAgICAgICAgc3VwZXIodHlwZSwgX2V2ZW50KTtcclxuICAgICAgICAgICAgbGV0IHRhcmdldDogSFRNTEVsZW1lbnQgPSA8SFRNTEVsZW1lbnQ+X2V2ZW50LnRhcmdldDtcclxuICAgICAgICAgICAgdGhpcy5jbGllbnRSZWN0ID0gdGFyZ2V0LmdldENsaWVudFJlY3RzKClbMF07XHJcbiAgICAgICAgICAgIHRoaXMucG9pbnRlclggPSBfZXZlbnQuY2xpZW50WCAtIHRoaXMuY2xpZW50UmVjdC5sZWZ0O1xyXG4gICAgICAgICAgICB0aGlzLnBvaW50ZXJZID0gX2V2ZW50LmNsaWVudFkgLSB0aGlzLmNsaWVudFJlY3QudG9wO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gICAgZXhwb3J0IGNvbnN0IGVudW0gRVZFTlRfVElNRVIge1xyXG4gICAgICAgIENBTEwgPSBcIsaSbGFwc2VcIlxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBldmVudCB0aGF0IHJlcHJlc2VudHMgYSBjYWxsIGZyb20gYSBUaW1lclxyXG4gICAgICogKi9cclxuICAgIGV4cG9ydCBjbGFzcyBFdmVudFRpbWVyIHtcclxuICAgICAgICBwdWJsaWMgdHlwZTogRVZFTlRfVElNRVIgPSBFVkVOVF9USU1FUi5DQUxMO1xyXG4gICAgICAgIHB1YmxpYyB0YXJnZXQ6IFRpbWVyO1xyXG4gICAgICAgIHB1YmxpYyBhcmd1bWVudHM6IE9iamVjdFtdO1xyXG4gICAgICAgIHB1YmxpYyBmaXJzdENhbGw6IGJvb2xlYW4gPSB0cnVlO1xyXG4gICAgICAgIHB1YmxpYyBsYXN0Q2FsbDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgICAgIHB1YmxpYyBjb3VudDogbnVtYmVyO1xyXG5cclxuICAgICAgICBjb25zdHJ1Y3RvcihfdGltZXI6IFRpbWVyLCAuLi5fYXJndW1lbnRzOiBPYmplY3RbXSkge1xyXG4gICAgICAgICAgICB0aGlzLnRhcmdldCA9IF90aW1lcjtcclxuICAgICAgICAgICAgdGhpcy5hcmd1bWVudHMgPSBfYXJndW1lbnRzO1xyXG4gICAgICAgICAgICB0aGlzLmZpcnN0Q2FsbCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgICBleHBvcnQgY29uc3QgZW51bSBFVkVOVF9XSEVFTCB7XHJcbiAgICAgICAgV0hFRUwgPSBcIsaSd2hlZWxcIlxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHN1cGNsYXNzIG9mIFdoZWVsRXZlbnQuIEV2ZW50cyB0aGF0IG9jY3VyIGR1ZSB0byB0aGUgdXNlciBtb3ZpbmcgYSBtb3VzZSB3aGVlbCBvciBzaW1pbGFyIGlucHV0IGRldmljZS5cclxuICAgICAqICovXHJcbiAgICBleHBvcnQgY2xhc3MgRXZlbnRXaGVlbCBleHRlbmRzIFdoZWVsRXZlbnQge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKHR5cGU6IHN0cmluZywgX2V2ZW50OiBFdmVudFdoZWVsKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKHR5cGUsIF9ldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQSBub2RlIG1hbmFnZWQgYnkge0BsaW5rIFByb2plY3R9IHRoYXQgZnVuY3Rpb25zIGFzIGEgdGVtcGxhdGUgZm9yIHtAbGluayBHcmFwaEluc3RhbmNlfXMgXHJcbiAgICogQGF1dGhvciBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9KaXJrYURlbGxPcm8vRlVER0Uvd2lraS9SZXNvdXJjZVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBHcmFwaCBleHRlbmRzIE5vZGUgaW1wbGVtZW50cyBTZXJpYWxpemFibGVSZXNvdXJjZSB7XHJcbiAgICBwdWJsaWMgaWRSZXNvdXJjZTogc3RyaW5nID0gdW5kZWZpbmVkO1xyXG4gICAgcHVibGljIHR5cGU6IHN0cmluZyA9IFwiR3JhcGhcIjtcclxuXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLmlkUmVzb3VyY2UgPSB0aGlzLmlkUmVzb3VyY2U7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24udHlwZSA9IHRoaXMudHlwZTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICBQcm9qZWN0LnJlZ2lzdGVyKHRoaXMsIF9zZXJpYWxpemF0aW9uLmlkUmVzb3VyY2UpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBBbiBpbnN0YW5jZSBvZiBhIHtAbGluayBHcmFwaH0uICBcclxuICAgKiBUaGlzIG5vZGUga2VlcHMgYSByZWZlcmVuY2UgdG8gaXRzIHJlc291cmNlIGFuIGNhbiB0aHVzIG9wdGltaXplIHNlcmlhbGl6YXRpb25cclxuICAgKiBAYXV0aG9yIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL0ppcmthRGVsbE9yby9GVURHRS93aWtpL1Jlc291cmNlXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEdyYXBoSW5zdGFuY2UgZXh0ZW5kcyBOb2RlIHtcclxuICAgIC8qKiBpZCBvZiB0aGUgcmVzb3VyY2UgdGhhdCBpbnN0YW5jZSB3YXMgY3JlYXRlZCBmcm9tICovXHJcbiAgICAvLyBUT0RPOiBleGFtaW5lLCBpZiB0aGlzIHNob3VsZCBiZSBhIGRpcmVjdCByZWZlcmVuY2UgdG8gdGhlIEdyYXBoLCBpbnN0ZWFkIG9mIHRoZSBpZFxyXG4gICAgcHJpdmF0ZSBpZFNvdXJjZTogc3RyaW5nID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBjb25zdHJ1Y3RvciBhbGxvbmUgd2lsbCBub3QgY3JlYXRlIGEgcmVjb25zdHJ1Y3Rpb24sIGJ1dCBvbmx5IHNhdmUgdGhlIGlkLlxyXG4gICAgICogVG8gY3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoZSBncmFwaCwgY2FsbCByZXNldCBvbiB0aGlzIG9yIHNldCB3aXRoIGEgZ3JhcGggYXMgcGFyYW1ldGVyLlxyXG4gICAgICogUHJlZmVyIFByb2plY3QuY3JlYXRlR3JhcGhJbnN0YW5jZShfZ3JhcGgpLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihfZ3JhcGg/OiBHcmFwaCkge1xyXG4gICAgICBzdXBlcihcIkdyYXBoXCIpO1xyXG4gICAgICBpZiAoIV9ncmFwaClcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIHRoaXMuaWRTb3VyY2UgPSBfZ3JhcGguaWRSZXNvdXJjZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlY3JlYXRlIHRoaXMgbm9kZSBmcm9tIHRoZSB7QGxpbmsgR3JhcGh9IHJlZmVyZW5jZWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIHJlc2V0KCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBsZXQgcmVzb3VyY2U6IEdyYXBoID0gPEdyYXBoPmF3YWl0IFByb2plY3QuZ2V0UmVzb3VyY2UodGhpcy5pZFNvdXJjZSk7XHJcbiAgICAgIGF3YWl0IHRoaXMuc2V0KHJlc291cmNlKTtcclxuICAgIH1cclxuXHJcbiAgICAvL1RPRE86IG9wdGltaXplIHVzaW5nIHRoZSByZWZlcmVuY2VkIEdyYXBoLCBzZXJpYWxpemUvZGVzZXJpYWxpemUgb25seSB0aGUgZGlmZmVyZW5jZXNcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24uaWRTb3VyY2UgPSB0aGlzLmlkU291cmNlO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIHRoaXMuaWRTb3VyY2UgPSBfc2VyaWFsaXphdGlvbi5pZFNvdXJjZTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhpcyBub2RlIHRvIGJlIGEgcmVjcmVhdGlvbiBvZiB0aGUge0BsaW5rIEdyYXBofSBnaXZlblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgc2V0KF9ncmFwaDogR3JhcGgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgLy8gVE9ETzogZXhhbWluZSwgaWYgdGhlIHNlcmlhbGl6YXRpb24gc2hvdWxkIGJlIHN0b3JlZCBpbiB0aGUgR3JhcGggZm9yIG9wdGltaXphdGlvblxyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IFNlcmlhbGl6ZXIuc2VyaWFsaXplKF9ncmFwaCk7XHJcbiAgICAgIC8vU2VyaWFsaXplci5kZXNlcmlhbGl6ZShzZXJpYWxpemF0aW9uKTtcclxuICAgICAgZm9yIChsZXQgcGF0aCBpbiBzZXJpYWxpemF0aW9uKSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5kZXNlcmlhbGl6ZShzZXJpYWxpemF0aW9uW3BhdGhdKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmlkU291cmNlID0gX2dyYXBoLmlkUmVzb3VyY2U7XHJcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuR1JBUEhfSU5TVEFOVElBVEVEKSk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogSG9sZHMgZGF0YSB0byBmZWVkIGludG8gYSB7QGxpbmsgU2hhZGVyfSB0byBkZXNjcmliZSB0aGUgc3VyZmFjZSBvZiB7QGxpbmsgTWVzaH0uICBcclxuICAgKiB7QGxpbmsgTWF0ZXJpYWx9cyByZWZlcmVuY2Uge0BsaW5rIENvYXR9IGFuZCB7QGxpbmsgU2hhZGVyfS4gICBcclxuICAgKiBUaGUgbWV0aG9kIHVzZVJlbmRlckRhdGEgd2lsbCBiZSBpbmplY3RlZCBieSB7QGxpbmsgUmVuZGVySW5qZWN0b3J9IGF0IHJ1bnRpbWUsIGV4dGVuZGluZyB0aGUgZnVuY3Rpb25hbGl0eSBvZiB0aGlzIGNsYXNzIHRvIGRlYWwgd2l0aCB0aGUgcmVuZGVyZXIuXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIENvYXQgZXh0ZW5kcyBNdXRhYmxlIGltcGxlbWVudHMgU2VyaWFsaXphYmxlIHtcclxuICAgIC8vIHB1YmxpYyBuYW1lOiBzdHJpbmcgPSBcIkNvYXRcIjtcclxuICAgIHByb3RlY3RlZCByZW5kZXJEYXRhOiB7IFtrZXk6IHN0cmluZ106IHVua25vd24gfTtcclxuXHJcbiAgICBwdWJsaWMgdXNlUmVuZGVyRGF0YShfc2hhZGVyOiB0eXBlb2YgU2hhZGVyLCBfY21wTWF0ZXJpYWw6IENvbXBvbmVudE1hdGVyaWFsKTogdm9pZCB7LyogaW5qZWN0ZWQgYnkgUmVuZGVySW5qZWN0b3IqLyB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICByZXR1cm4ge307XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQgeyBcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLnJlbmRlckRhdGE7XHJcbiAgICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgc2ltcGxlc3Qge0BsaW5rIENvYXR9IHByb3ZpZGluZyBqdXN0IGEgY29sb3JcclxuICAgKi9cclxuICBAUmVuZGVySW5qZWN0b3JDb2F0LmRlY29yYXRlXHJcbiAgZXhwb3J0IGNsYXNzIENvYXRDb2xvcmVkIGV4dGVuZHMgQ29hdCB7XHJcbiAgICBwdWJsaWMgY29sb3I6IENvbG9yO1xyXG4gICAgcHVibGljIHNoaW5pbmVzczogbnVtYmVyO1xyXG4gICAgY29uc3RydWN0b3IoX2NvbG9yPzogQ29sb3IsIF9zaGluaW5lc3M/OiBudW1iZXIpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5jb2xvciA9IF9jb2xvciB8fCBuZXcgQ29sb3IoKTtcclxuICAgICAgdGhpcy5zaGluaW5lc3MgPSBfc2hpbmluZXNzIHx8IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLmNvbG9yID0gdGhpcy5jb2xvci5zZXJpYWxpemUoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5zaGluaW5lc3MgPSB0aGlzLnNoaW5pbmVzcztcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIGF3YWl0IHRoaXMuY29sb3IuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24uY29sb3IpO1xyXG4gICAgICB0aGlzLnNoaW5pbmVzcyA9IF9zZXJpYWxpemF0aW9uLnNoaW5pbmVzcztcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEEge0BsaW5rIENvYXR9IHRvIGJlIHVzZWQgYnkgdGhlIE1hdENhcCBTaGFkZXIgcHJvdmlkaW5nIGEgdGV4dHVyZSwgYSB0aW50IGNvbG9yICgwLjUgZ3JleSBpcyBuZXV0cmFsKS4gU2V0IHNoYWRlU21vb3RoIHRvIDEgZm9yIHNtb290aCBzaGFkaW5nLlxyXG4gICAqL1xyXG4gIC8vIEBSZW5kZXJJbmplY3RvckNvYXQuZGVjb3JhdGVcclxuICAvLyBleHBvcnQgY2xhc3MgQ29hdE1hdENhcCBleHRlbmRzIENvYXQge1xyXG4gIC8vICAgcHVibGljIHRleHR1cmU6IFRleHR1cmVJbWFnZSA9IG51bGw7XHJcbiAgLy8gICBwdWJsaWMgY29sb3I6IENvbG9yID0gbmV3IENvbG9yKCk7XHJcbiAgLy8gICBwdWJsaWMgc2hhZGVTbW9vdGg6IG51bWJlcjtcclxuXHJcbiAgLy8gICBjb25zdHJ1Y3RvcihfdGV4dHVyZT86IFRleHR1cmVJbWFnZSwgX2NvbG9yPzogQ29sb3IsIF9zaGFkZVNtb290aD86IG51bWJlcikge1xyXG4gIC8vICAgICBzdXBlcigpO1xyXG4gIC8vICAgICB0aGlzLnRleHR1cmUgPSBfdGV4dHVyZSB8fCBuZXcgVGV4dHVyZUltYWdlKCk7XHJcbiAgLy8gICAgIHRoaXMuY29sb3IgPSBfY29sb3IgfHwgbmV3IENvbG9yKCk7XHJcbiAgLy8gICAgIHRoaXMuc2hhZGVTbW9vdGggPSBfc2hhZGVTbW9vdGggfHwgMDtcclxuICAvLyAgIH1cclxuICAgIFxyXG4gIC8vICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgLy8gICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gIC8vICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gIC8vICAgICBzZXJpYWxpemF0aW9uLmNvbG9yID0gdGhpcy5jb2xvci5zZXJpYWxpemUoKTtcclxuICAvLyAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgLy8gICB9XHJcbiAgLy8gICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gIC8vICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgLy8gICAgIGF3YWl0IHRoaXMuY29sb3IuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24uY29sb3IpO1xyXG4gIC8vICAgICByZXR1cm4gdGhpcztcclxuICAvLyAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gIC8vIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEEge0BsaW5rIENvYXR9IHByb3ZpZGluZyBhIHRleHR1cmUgYW5kIGFkZGl0aW9uYWwgZGF0YSBmb3IgdGV4dHVyaW5nXHJcbiAgICovXHJcbiAgQFJlbmRlckluamVjdG9yQ29hdC5kZWNvcmF0ZVxyXG4gIGV4cG9ydCBjbGFzcyBDb2F0VGV4dHVyZWQgZXh0ZW5kcyBDb2F0Q29sb3JlZCB7XHJcbiAgICBwdWJsaWMgdGV4dHVyZTogVGV4dHVyZSA9IG51bGw7XHJcblxyXG4gICAgY29uc3RydWN0b3IoX2NvbG9yPzogQ29sb3IsIF90ZXh0dXJlPzogVGV4dHVyZSkge1xyXG4gICAgICBzdXBlcihfY29sb3IpO1xyXG4gICAgICB0aGlzLnRleHR1cmUgPSBfdGV4dHVyZSB8fCBUZXh0dXJlRGVmYXVsdC50ZXh0dXJlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5pZFRleHR1cmUgPSB0aGlzLnRleHR1cmUuaWRSZXNvdXJjZTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIGlmIChfc2VyaWFsaXphdGlvbi5pZFRleHR1cmUpXHJcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gPFRleHR1cmU+YXdhaXQgUHJvamVjdC5nZXRSZXNvdXJjZShfc2VyaWFsaXphdGlvbi5pZFRleHR1cmUpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIERlZmluZXMgYSBjb2xvciBhcyB2YWx1ZXMgaW4gdGhlIHJhbmdlIG9mIDAgdG8gMSBmb3IgdGhlIGZvdXIgY2hhbm5lbHMgcmVkLCBncmVlbiwgYmx1ZSBhbmQgYWxwaGEgKGZvciBvcGFjaXR5KVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb2xvciBleHRlbmRzIE11dGFibGUgaW1wbGVtZW50cyBTZXJpYWxpemFibGUge1xyXG4gICAgLy8gY3JjMiBvbmx5IHVzZWQgZm9yIGNvbnZlcnRpbmcgY29sb3JzIGZyb20gc3RyaW5ncyBwcmVkZWZpbmVkIGJ5IENTU1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgY3JjMjogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKS5nZXRDb250ZXh0KFwiMmRcIik7XHJcblxyXG4gICAgcHVibGljIHI6IG51bWJlcjtcclxuICAgIHB1YmxpYyBnOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgYjogbnVtYmVyO1xyXG4gICAgcHVibGljIGE6IG51bWJlcjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihfcjogbnVtYmVyID0gMSwgX2c6IG51bWJlciA9IDEsIF9iOiBudW1iZXIgPSAxLCBfYTogbnVtYmVyID0gMSkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLnNldE5vcm1SR0JBKF9yLCBfZywgX2IsIF9hKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldEhleEZyb21DU1NLZXl3b3JkKF9rZXl3b3JkOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICBDb2xvci5jcmMyLmZpbGxTdHlsZSA9IF9rZXl3b3JkO1xyXG4gICAgICByZXR1cm4gQ29sb3IuY3JjMi5maWxsU3R5bGU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBDU1MoX2tleXdvcmQ6IHN0cmluZywgX2FscGhhOiBudW1iZXIgPSAxKTogQ29sb3Ige1xyXG4gICAgICBsZXQgaGV4OiBzdHJpbmcgPSBDb2xvci5nZXRIZXhGcm9tQ1NTS2V5d29yZChfa2V5d29yZCk7XHJcbiAgICAgIGxldCBjb2xvcjogQ29sb3IgPSBuZXcgQ29sb3IoXHJcbiAgICAgICAgcGFyc2VJbnQoaGV4LnN1YnN0cigxLCAyKSwgMTYpIC8gMjU1LFxyXG4gICAgICAgIHBhcnNlSW50KGhleC5zdWJzdHIoMywgMiksIDE2KSAvIDI1NSxcclxuICAgICAgICBwYXJzZUludChoZXguc3Vic3RyKDUsIDIpLCAxNikgLyAyNTUsXHJcbiAgICAgICAgX2FscGhhKTtcclxuICAgICAgcmV0dXJuIGNvbG9yO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIE1VTFRJUExZKF9jb2xvcjE6IENvbG9yLCBfY29sb3IyOiBDb2xvcik6IENvbG9yIHtcclxuICAgICAgcmV0dXJuIG5ldyBDb2xvcihfY29sb3IxLnIgKiBfY29sb3IyLnIsIF9jb2xvcjEuZyAqIF9jb2xvcjIuZywgX2NvbG9yMS5iICogX2NvbG9yMi5iLCBfY29sb3IxLmEgKiBfY29sb3IyLmEpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXROb3JtUkdCQShfcjogbnVtYmVyLCBfZzogbnVtYmVyLCBfYjogbnVtYmVyLCBfYTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuciA9IE1hdGgubWluKDEsIE1hdGgubWF4KDAsIF9yKSk7XHJcbiAgICAgIHRoaXMuZyA9IE1hdGgubWluKDEsIE1hdGgubWF4KDAsIF9nKSk7XHJcbiAgICAgIHRoaXMuYiA9IE1hdGgubWluKDEsIE1hdGgubWF4KDAsIF9iKSk7XHJcbiAgICAgIHRoaXMuYSA9IE1hdGgubWluKDEsIE1hdGgubWF4KDAsIF9hKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldEJ5dGVzUkdCQShfcjogbnVtYmVyLCBfZzogbnVtYmVyLCBfYjogbnVtYmVyLCBfYTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuc2V0Tm9ybVJHQkEoX3IgLyAyNTUsIF9nIC8gMjU1LCBfYiAvIDI1NSwgX2EgLyAyNTUpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRBcnJheSgpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbdGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdGhpcy5hXSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldEFycmF5Tm9ybVJHQkEoX2NvbG9yOiBGbG9hdDMyQXJyYXkpOiB2b2lkIHtcclxuICAgICAgdGhpcy5zZXROb3JtUkdCQShfY29sb3JbMF0sIF9jb2xvclsxXSwgX2NvbG9yWzJdLCBfY29sb3JbM10pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXRBcnJheUJ5dGVzUkdCQShfY29sb3I6IFVpbnQ4Q2xhbXBlZEFycmF5KTogdm9pZCB7XHJcbiAgICAgIHRoaXMuc2V0Qnl0ZXNSR0JBKF9jb2xvclswXSwgX2NvbG9yWzFdLCBfY29sb3JbMl0sIF9jb2xvclszXSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEFycmF5Qnl0ZXNSR0JBKCk6IFVpbnQ4Q2xhbXBlZEFycmF5IHtcclxuICAgICAgcmV0dXJuIG5ldyBVaW50OENsYW1wZWRBcnJheShbdGhpcy5yICogMjU1LCB0aGlzLmcgKiAyNTUsIHRoaXMuYiAqIDI1NSwgdGhpcy5hICogMjU1XSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFkZChfY29sb3I6IENvbG9yKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuciArPSBfY29sb3IucjtcclxuICAgICAgdGhpcy5nICs9IF9jb2xvci5nO1xyXG4gICAgICB0aGlzLmIgKz0gX2NvbG9yLmI7XHJcbiAgICAgIHRoaXMuYSArPSBfY29sb3IuYTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0Q1NTKCk6IHN0cmluZyB7XHJcbiAgICAgIGxldCBieXRlczogVWludDhDbGFtcGVkQXJyYXkgPSB0aGlzLmdldEFycmF5Qnl0ZXNSR0JBKCk7XHJcbiAgICAgIHJldHVybiBgUkdCQSgke2J5dGVzWzBdfSwgJHtieXRlc1sxXX0sICR7Ynl0ZXNbMl19LCAke2J5dGVzWzNdfSlgO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRIZXgoKTogc3RyaW5nIHtcclxuICAgICAgbGV0IGJ5dGVzOiBVaW50OENsYW1wZWRBcnJheSA9IHRoaXMuZ2V0QXJyYXlCeXRlc1JHQkEoKTtcclxuICAgICAgbGV0IGhleDogc3RyaW5nID0gXCJcIjtcclxuICAgICAgZm9yIChsZXQgYnl0ZSBvZiBieXRlcylcclxuICAgICAgICBoZXggKz0gYnl0ZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpO1xyXG4gICAgICByZXR1cm4gaGV4O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXRIZXgoX2hleDogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgIGxldCBieXRlczogVWludDhDbGFtcGVkQXJyYXkgPSB0aGlzLmdldEFycmF5Qnl0ZXNSR0JBKCk7XHJcbiAgICAgIGxldCBjaGFubmVsOiBudW1iZXIgPSAwO1xyXG4gICAgICBmb3IgKGxldCBieXRlIGluIGJ5dGVzKVxyXG4gICAgICAgIGJ5dGVzW2J5dGVdID0gcGFyc2VJbnQoX2hleC5zdWJzdHIoY2hhbm5lbCsrICogMiwgMiksIDE2KTtcclxuICAgICAgdGhpcy5zZXRBcnJheUJ5dGVzUkdCQShieXRlcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGNvcHkoX2NvbG9yOiBDb2xvcik6IHZvaWQge1xyXG4gICAgICB0aGlzLnIgPSBfY29sb3IucjsgXHJcbiAgICAgIHRoaXMuZyA9IF9jb2xvci5nOyBcclxuICAgICAgdGhpcy5iID0gX2NvbG9yLmI7IFxyXG4gICAgICB0aGlzLmEgPSBfY29sb3IuYTsgXHJcbiAgICB9XHJcbiAgICBcclxuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gYChyOiAke3RoaXMuci50b0ZpeGVkKDMpfSwgZzogJHt0aGlzLmcudG9GaXhlZCgzKX0sIGI6ICR7dGhpcy5iLnRvRml4ZWQoMyl9LCBhOiAke3RoaXMuYS50b0ZpeGVkKDMpfSlgO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB0aGlzLmdldE11dGF0b3IodHJ1ZSk7XHJcbiAgICAgIC8vIHNlcmlhbGl6YXRpb24udG9KU09OID0gKCkgPT4geyByZXR1cm4gYHsgXCJyXCI6ICR7dGhpcy5yfSwgXCJnXCI6ICR7dGhpcy5nfSwgXCJiXCI6ICR7dGhpcy5ifSwgXCJhXCI6ICR7dGhpcy5hfX1gOyB9O1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnRvSlNPTiA9ICgpID0+IHsgcmV0dXJuIGBbJHt0aGlzLnJ9LCAke3RoaXMuZ30sICR7dGhpcy5ifSwgJHt0aGlzLmF9XWA7IH07XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGlmICh0eXBlb2YgKF9zZXJpYWxpemF0aW9uKSA9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgW3RoaXMuciwgdGhpcy5nLCB0aGlzLmIsIHRoaXMuYV0gPSBKU09OLnBhcnNlKDxzdHJpbmc+PHVua25vd24+X3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2VcclxuICAgICAgICB0aGlzLm11dGF0ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7LyoqICovIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBCYXNlY2xhc3MgZm9yIG1hdGVyaWFscy4gQ29tYmluZXMgYSB7QGxpbmsgU2hhZGVyfSB3aXRoIGEgY29tcGF0aWJsZSB7QGxpbmsgQ29hdH1cclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBNYXRlcmlhbCBleHRlbmRzIE11dGFibGUgaW1wbGVtZW50cyBTZXJpYWxpemFibGVSZXNvdXJjZSB7XHJcbiAgICAvKiogVGhlIG5hbWUgdG8gY2FsbCB0aGUgTWF0ZXJpYWwgYnkuICovXHJcbiAgICAjY29hdDogQ29hdDtcclxuICAgIHB1YmxpYyBuYW1lOiBzdHJpbmc7XHJcbiAgICBwdWJsaWMgaWRSZXNvdXJjZTogc3RyaW5nID0gdW5kZWZpbmVkO1xyXG4gICAgcHJpdmF0ZSBzaGFkZXJUeXBlOiB0eXBlb2YgU2hhZGVyOyAvLyBUaGUgc2hhZGVyIHByb2dyYW0gdXNlZCBieSB0aGlzIEJhc2VNYXRlcmlhbFxyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nLCBfc2hhZGVyPzogdHlwZW9mIFNoYWRlciwgX2NvYXQ/OiBDb2F0KSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMubmFtZSA9IF9uYW1lO1xyXG4gICAgICB0aGlzLnNoYWRlclR5cGUgPSBfc2hhZGVyO1xyXG4gICAgICBpZiAoX3NoYWRlcikge1xyXG4gICAgICAgIGlmIChfY29hdClcclxuICAgICAgICAgIHRoaXMuY29hdCA9IF9jb2F0O1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIHRoaXMuY29hdCA9IHRoaXMuY3JlYXRlQ29hdE1hdGNoaW5nU2hhZGVyKCk7XHJcbiAgICAgIH1cclxuICAgICAgUHJvamVjdC5yZWdpc3Rlcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnRseSByZWZlcmVuY2VkIHtAbGluayBDb2F0fSBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICAgcHVibGljIGdldCBjb2F0KCk6IENvYXQge1xyXG4gICAgICByZXR1cm4gdGhpcy4jY29hdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTWFrZXMgdGhpcyBtYXRlcmlhbCByZWZlcmVuY2UgdGhlIGdpdmVuIHtAbGluayBDb2F0fSBpZiBpdCBpcyBjb21wYXRpYmxlIHdpdGggdGhlIHJlZmVyZW5jZWQge0BsaW5rIFNoYWRlcn1cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldCBjb2F0KF9jb2F0OiBDb2F0KSB7XHJcbiAgICAgIGlmIChfY29hdC5jb25zdHJ1Y3RvciAhPSB0aGlzLnNoYWRlclR5cGUuZ2V0Q29hdCgpKVxyXG4gICAgICAgIGlmIChfY29hdCBpbnN0YW5jZW9mIHRoaXMuc2hhZGVyVHlwZS5nZXRDb2F0KCkpXHJcbiAgICAgICAgICBEZWJ1Zy5mdWRnZShcIkNvYXQgaXMgZXh0ZW5zaW9uIG9mIENvYXQgcmVxdWlyZWQgYnkgc2hhZGVyXCIpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIHRocm93IChuZXcgRXJyb3IoXCJTaGFkZXIgYW5kIGNvYXQgZG9uJ3QgbWF0Y2hcIikpO1xyXG4gICAgICB0aGlzLiNjb2F0ID0gX2NvYXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBDb2F0fSBpbnN0YW5jZSB0aGF0IGlzIHZhbGlkIGZvciB0aGUge0BsaW5rIFNoYWRlcn0gcmVmZXJlbmNlZCBieSB0aGlzIG1hdGVyaWFsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjcmVhdGVDb2F0TWF0Y2hpbmdTaGFkZXIoKTogQ29hdCB7XHJcbiAgICAgIGxldCBjb2F0OiBDb2F0ID0gbmV3ICh0aGlzLnNoYWRlclR5cGUuZ2V0Q29hdCgpKSgpO1xyXG4gICAgICByZXR1cm4gY29hdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZXMgdGhlIG1hdGVyaWFscyByZWZlcmVuY2UgdG8gdGhlIGdpdmVuIHtAbGluayBTaGFkZXJ9LCBjcmVhdGVzIGFuZCByZWZlcmVuY2VzIGEgbmV3IHtAbGluayBDb2F0fSBpbnN0YW5jZSAgXHJcbiAgICAgKiBhbmQgbXV0YXRlcyB0aGUgbmV3IGNvYXQgdG8gcHJlc2VydmUgbWF0Y2hpbmcgcHJvcGVydGllcy5cclxuICAgICAqIEBwYXJhbSBfc2hhZGVyVHlwZSBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFNoYWRlcihfc2hhZGVyVHlwZTogdHlwZW9mIFNoYWRlcik6IHZvaWQge1xyXG4gICAgICB0aGlzLnNoYWRlclR5cGUgPSBfc2hhZGVyVHlwZTtcclxuICAgICAgbGV0IGNvYXQ6IENvYXQgPSB0aGlzLmNyZWF0ZUNvYXRNYXRjaGluZ1NoYWRlcigpO1xyXG4gICAgICBjb2F0Lm11dGF0ZSh0aGlzLiNjb2F0LmdldE11dGF0b3IoKSk7XHJcbiAgICAgIHRoaXMuY29hdCA9IGNvYXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB7QGxpbmsgU2hhZGVyfSByZWZlcmVuY2VkIGJ5IHRoaXMgbWF0ZXJpYWxcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFNoYWRlcigpOiB0eXBlb2YgU2hhZGVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc2hhZGVyVHlwZTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICAvLyBUT0RPOiB0aGlzIHR5cGUgb2Ygc2VyaWFsaXphdGlvbiB3YXMgaW1wbGVtZW50ZWQgZm9yIGltcGxpY2l0IE1hdGVyaWFsIGNyZWF0ZS4gQ2hlY2sgaWYgb2Jzb2xldGUgd2hlbiBvbmx5IG9uZSBtYXRlcmlhbCBjbGFzcyBleGlzdHMgYW5kL29yIG1hdGVyaWFscyBhcmUgc3RvcmVkIHNlcGFyYXRlbHlcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge1xyXG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICBpZFJlc291cmNlOiB0aGlzLmlkUmVzb3VyY2UsXHJcbiAgICAgICAgc2hhZGVyOiB0aGlzLnNoYWRlclR5cGUubmFtZSxcclxuICAgICAgICBjb2F0OiBTZXJpYWxpemVyLnNlcmlhbGl6ZSh0aGlzLiNjb2F0KVxyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIHRoaXMubmFtZSA9IF9zZXJpYWxpemF0aW9uLm5hbWU7XHJcbiAgICAgIFByb2plY3QucmVnaXN0ZXIodGhpcywgX3NlcmlhbGl6YXRpb24uaWRSZXNvdXJjZSk7XHJcbiAgICAgIHRoaXMuc2hhZGVyVHlwZSA9ICg8R2VuZXJhbD5GdWRnZUNvcmUpW19zZXJpYWxpemF0aW9uLnNoYWRlcl07XHJcbiAgICAgIGxldCBjb2F0OiBDb2F0ID0gPENvYXQ+YXdhaXQgU2VyaWFsaXplci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5jb2F0KTtcclxuICAgICAgdGhpcy5jb2F0ID0gY29hdDtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0gc3VwZXIuZ2V0TXV0YXRvcih0cnVlKTtcclxuICAgICAgbXV0YXRvci5jb2F0ID0gdGhpcy5jb2F0LmdldE11dGF0b3IoKTtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBhd2FpdCBzdXBlci5tdXRhdGUoX211dGF0b3IpO1xyXG4gICAgICAvLyBhcHBlYXJlbnR5LCBjb2F0IGFscmVhZHkgbXV0YXRlcy4uLiBuZXh0IGxpbmUgdW5uZWNlc3NhcnkgYW5kIGJ1Z2d5LCBzaW5jZSB1cmwgZ2V0cyBzdHJpcHBlZFxyXG4gICAgICAvLyBhd2FpdCB0aGlzLmNvYXQubXV0YXRlKF9tdXRhdG9yLmNvYXQpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIC8vIGRlbGV0ZSBfbXV0YXRvci5pZFJlc291cmNlO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGludGVyZmFjZSBCb3JkZXIge1xyXG4gICAgbGVmdDogbnVtYmVyO1xyXG4gICAgdG9wOiBudW1iZXI7XHJcbiAgICByaWdodDogbnVtYmVyO1xyXG4gICAgYm90dG9tOiBudW1iZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGcmFtaW5nIGRlc2NyaWJlcyBob3cgdG8gbWFwIGEgcmVjdGFuZ2xlIGludG8gYSBnaXZlbiBmcmFtZVxyXG4gICAqIGFuZCBob3cgcG9pbnRzIGluIHRoZSBmcmFtZSBjb3JyZXNwb25kIHRvIHBvaW50cyBpbiB0aGUgcmVzdWx0aW5nIHJlY3RhbmdsZSBhbmQgdmljZSB2ZXJzYVxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5ICBcclxuICAgKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vSmlya2FEZWxsT3JvL0ZVREdFL3dpa2kvRnJhbWluZ1xyXG4gICAqL1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBGcmFtaW5nIGV4dGVuZHMgTXV0YWJsZSB7XHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgYSBwb2ludCBpbiB0aGUgZ2l2ZW4gZnJhbWUgYWNjb3JkaW5nIHRvIHRoaXMgZnJhbWluZ1xyXG4gICAgICogQHBhcmFtIF9wb2ludEluRnJhbWUgVGhlIHBvaW50IGluIHRoZSBmcmFtZSBnaXZlblxyXG4gICAgICogQHBhcmFtIF9yZWN0RnJhbWUgVGhlIGZyYW1lIHRoZSBwb2ludCBpcyByZWxhdGl2ZSB0b1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0UG9pbnQoX3BvaW50SW5GcmFtZTogVmVjdG9yMiwgX3JlY3RGcmFtZTogUmVjdGFuZ2xlKTogVmVjdG9yMjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgYSBwb2ludCBpbiBhIGdpdmVuIHJlY3RhbmdsZSBiYWNrIHRvIGEgY2FsY3VsYXRlZCBmcmFtZSBvZiBvcmlnaW5cclxuICAgICAqIEBwYXJhbSBfcG9pbnQgVGhlIHBvaW50IGluIHRoZSByZWN0YW5nbGVcclxuICAgICAqIEBwYXJhbSBfcmVjdCBUaGUgcmVjdGFuZ2xlIHRoZSBwb2ludCBpcyByZWxhdGl2ZSB0b1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0UG9pbnRJbnZlcnNlKF9wb2ludDogVmVjdG9yMiwgX3JlY3Q6IFJlY3RhbmdsZSk6IFZlY3RvcjI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUYWtlcyBhIHJlY3RhbmdsZSBhcyB0aGUgZnJhbWUgYW5kIGNyZWF0ZXMgYSBuZXcgcmVjdGFuZ2xlIGFjY29yZGluZyB0byB0aGUgZnJhbWluZ1xyXG4gICAgICogQHBhcmFtIF9yZWN0RnJhbWVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IGdldFJlY3QoX3JlY3RGcmFtZTogUmVjdGFuZ2xlKTogUmVjdGFuZ2xlO1xyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHsvKiogKi8gfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHJlc3VsdGluZyByZWN0YW5nbGUgaGFzIGEgZml4ZWQgd2lkdGggYW5kIGhlaWdodCBhbmQgZGlzcGxheSBzaG91bGQgc2NhbGUgdG8gZml0IHRoZSBmcmFtZVxyXG4gICAqIFBvaW50cyBhcmUgc2NhbGVkIGluIHRoZSBzYW1lIHJhdGlvXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEZyYW1pbmdGaXhlZCBleHRlbmRzIEZyYW1pbmcge1xyXG4gICAgcHVibGljIHdpZHRoOiBudW1iZXIgPSAzMDA7XHJcbiAgICBwdWJsaWMgaGVpZ2h0OiBudW1iZXIgPSAxNTA7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF93aWR0aDogbnVtYmVyID0gMzAwLCBfaGVpZ2h0OiBudW1iZXIgPSAxNTApIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5zZXRTaXplKF93aWR0aCwgX2hlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldFNpemUoX3dpZHRoOiBudW1iZXIsIF9oZWlnaHQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICB0aGlzLndpZHRoID0gX3dpZHRoO1xyXG4gICAgICB0aGlzLmhlaWdodCA9IF9oZWlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFBvaW50KF9wb2ludEluRnJhbWU6IFZlY3RvcjIsIF9yZWN0RnJhbWU6IFJlY3RhbmdsZSk6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IyID0gbmV3IFZlY3RvcjIoXHJcbiAgICAgICAgdGhpcy53aWR0aCAqIChfcG9pbnRJbkZyYW1lLnggLSBfcmVjdEZyYW1lLngpIC8gX3JlY3RGcmFtZS53aWR0aCxcclxuICAgICAgICB0aGlzLmhlaWdodCAqIChfcG9pbnRJbkZyYW1lLnkgLSBfcmVjdEZyYW1lLnkpIC8gX3JlY3RGcmFtZS5oZWlnaHRcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0UG9pbnRJbnZlcnNlKF9wb2ludDogVmVjdG9yMiwgX3JlY3Q6IFJlY3RhbmdsZSk6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IyID0gbmV3IFZlY3RvcjIoXHJcbiAgICAgICAgX3BvaW50LnggKiBfcmVjdC53aWR0aCAvIHRoaXMud2lkdGggKyBfcmVjdC54LFxyXG4gICAgICAgIF9wb2ludC55ICogX3JlY3QuaGVpZ2h0IC8gdGhpcy5oZWlnaHQgKyBfcmVjdC55XHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFJlY3QoX3JlY3RGcmFtZTogUmVjdGFuZ2xlKTogUmVjdGFuZ2xlIHtcclxuICAgICAgcmV0dXJuIFJlY3RhbmdsZS5HRVQoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKipcclxuICAgKiBXaWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSByZXN1bHRpbmcgcmVjdGFuZ2xlIGFyZSBmcmFjdGlvbnMgb2YgdGhvc2Ugb2YgdGhlIGZyYW1lLCBzY2FsZWQgYnkgbm9ybWVkIHZhbHVlcyBub3JtV2lkdGggYW5kIG5vcm1IZWlnaHQuXHJcbiAgICogRGlzcGxheSBzaG91bGQgc2NhbGUgdG8gZml0IHRoZSBmcmFtZSBhbmQgcG9pbnRzIGFyZSBzY2FsZWQgaW4gdGhlIHNhbWUgcmF0aW9cclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgRnJhbWluZ1NjYWxlZCBleHRlbmRzIEZyYW1pbmcge1xyXG4gICAgcHVibGljIG5vcm1XaWR0aDogbnVtYmVyID0gMS4wO1xyXG4gICAgcHVibGljIG5vcm1IZWlnaHQ6IG51bWJlciA9IDEuMDtcclxuXHJcbiAgICBwdWJsaWMgc2V0U2NhbGUoX25vcm1XaWR0aDogbnVtYmVyLCBfbm9ybUhlaWdodDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIHRoaXMubm9ybVdpZHRoID0gX25vcm1XaWR0aDtcclxuICAgICAgdGhpcy5ub3JtSGVpZ2h0ID0gX25vcm1IZWlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFBvaW50KF9wb2ludEluRnJhbWU6IFZlY3RvcjIsIF9yZWN0RnJhbWU6IFJlY3RhbmdsZSk6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IyID0gbmV3IFZlY3RvcjIoXHJcbiAgICAgICAgdGhpcy5ub3JtV2lkdGggKiAoX3BvaW50SW5GcmFtZS54IC0gX3JlY3RGcmFtZS54KSxcclxuICAgICAgICB0aGlzLm5vcm1IZWlnaHQgKiAoX3BvaW50SW5GcmFtZS55IC0gX3JlY3RGcmFtZS55KVxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRQb2ludEludmVyc2UoX3BvaW50OiBWZWN0b3IyLCBfcmVjdDogUmVjdGFuZ2xlKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjIgPSBuZXcgVmVjdG9yMihcclxuICAgICAgICBfcG9pbnQueCAvIHRoaXMubm9ybVdpZHRoICsgX3JlY3QueCxcclxuICAgICAgICBfcG9pbnQueSAvIHRoaXMubm9ybUhlaWdodCArIF9yZWN0LnlcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0UmVjdChfcmVjdEZyYW1lOiBSZWN0YW5nbGUpOiBSZWN0YW5nbGUge1xyXG4gICAgICByZXR1cm4gUmVjdGFuZ2xlLkdFVCgwLCAwLCB0aGlzLm5vcm1XaWR0aCAqIF9yZWN0RnJhbWUud2lkdGgsIHRoaXMubm9ybUhlaWdodCAqIF9yZWN0RnJhbWUuaGVpZ2h0KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSByZXN1bHRpbmcgcmVjdGFuZ2xlIGZpdHMgaW50byBhIG1hcmdpbiBnaXZlbiBhcyBmcmFjdGlvbnMgb2YgdGhlIHNpemUgb2YgdGhlIGZyYW1lIGdpdmVuIGJ5IG5vcm1BbmNob3JcclxuICAgKiBwbHVzIGFuIGFic29sdXRlIHBhZGRpbmcgZ2l2ZW4gYnkgcGl4ZWxCb3JkZXIuIERpc3BsYXkgc2hvdWxkIGZpdCBpbnRvIHRoaXMuXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEZyYW1pbmdDb21wbGV4IGV4dGVuZHMgRnJhbWluZyB7XHJcbiAgICBwdWJsaWMgbWFyZ2luOiBCb3JkZXIgPSB7IGxlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCB9O1xyXG4gICAgcHVibGljIHBhZGRpbmc6IEJvcmRlciA9IHsgbGVmdDogMCwgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwIH07XHJcblxyXG4gICAgcHVibGljIGdldFBvaW50KF9wb2ludEluRnJhbWU6IFZlY3RvcjIsIF9yZWN0RnJhbWU6IFJlY3RhbmdsZSk6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IyID0gbmV3IFZlY3RvcjIoXHJcbiAgICAgICAgX3BvaW50SW5GcmFtZS54IC0gdGhpcy5wYWRkaW5nLmxlZnQgLSB0aGlzLm1hcmdpbi5sZWZ0ICogX3JlY3RGcmFtZS53aWR0aCxcclxuICAgICAgICBfcG9pbnRJbkZyYW1lLnkgLSB0aGlzLnBhZGRpbmcudG9wIC0gdGhpcy5tYXJnaW4udG9wICogX3JlY3RGcmFtZS5oZWlnaHRcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHB1YmxpYyBnZXRQb2ludEludmVyc2UoX3BvaW50OiBWZWN0b3IyLCBfcmVjdDogUmVjdGFuZ2xlKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjIgPSBuZXcgVmVjdG9yMihcclxuICAgICAgICBfcG9pbnQueCArIHRoaXMucGFkZGluZy5sZWZ0ICsgdGhpcy5tYXJnaW4ubGVmdCAqIF9yZWN0LndpZHRoLFxyXG4gICAgICAgIF9wb2ludC55ICsgdGhpcy5wYWRkaW5nLnRvcCArIHRoaXMubWFyZ2luLnRvcCAqIF9yZWN0LmhlaWdodFxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRSZWN0KF9yZWN0RnJhbWU6IFJlY3RhbmdsZSk6IFJlY3RhbmdsZSB7XHJcbiAgICAgIGlmICghX3JlY3RGcmFtZSlcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgIGxldCBtaW5YOiBudW1iZXIgPSBfcmVjdEZyYW1lLnggKyB0aGlzLm1hcmdpbi5sZWZ0ICogX3JlY3RGcmFtZS53aWR0aCArIHRoaXMucGFkZGluZy5sZWZ0O1xyXG4gICAgICBsZXQgbWluWTogbnVtYmVyID0gX3JlY3RGcmFtZS55ICsgdGhpcy5tYXJnaW4udG9wICogX3JlY3RGcmFtZS5oZWlnaHQgKyB0aGlzLnBhZGRpbmcudG9wO1xyXG4gICAgICBsZXQgbWF4WDogbnVtYmVyID0gX3JlY3RGcmFtZS54ICsgKDEgLSB0aGlzLm1hcmdpbi5yaWdodCkgKiBfcmVjdEZyYW1lLndpZHRoIC0gdGhpcy5wYWRkaW5nLnJpZ2h0O1xyXG4gICAgICBsZXQgbWF4WTogbnVtYmVyID0gX3JlY3RGcmFtZS55ICsgKDEgLSB0aGlzLm1hcmdpbi5ib3R0b20pICogX3JlY3RGcmFtZS5oZWlnaHQgLSB0aGlzLnBhZGRpbmcuYm90dG9tO1xyXG5cclxuICAgICAgcmV0dXJuIFJlY3RhbmdsZS5HRVQobWluWCwgbWluWSwgbWF4WCAtIG1pblgsIG1heFkgLSBtaW5ZKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcclxuICAgICAgcmV0dXJuIHsgbWFyZ2luOiB0aGlzLm1hcmdpbiwgcGFkZGluZzogdGhpcy5wYWRkaW5nIH07XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogUmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3IyIGFzIHBvbGFyIGNvb3JkaW5hdGVzIFxyXG4gICAqIGBgYHBsYWludGV4dFxyXG4gICAqICDihpUtIGFuZ2xlIChBbmdsZSB0byB0aGUgeC1heGlzKVxyXG4gICAqICAt4oaSIE1hZ25pdHVkZSAoRGlzdGFuY2UgZnJvbSB0aGUgY2VudGVyKSAgXHJcbiAgICogYGBgXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEdlbzIgaW1wbGVtZW50cyBSZWN5Y2FibGUge1xyXG4gICAgcHVibGljIG1hZ25pdHVkZTogbnVtYmVyID0gMDtcclxuICAgIHB1YmxpYyBhbmdsZTogbnVtYmVyID0gMDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihfYW5nbGU6IG51bWJlciA9IDAsIF9tYWduaXR1ZGU6IG51bWJlciA9IDEpIHtcclxuICAgICAgdGhpcy5zZXQoX2FuZ2xlLCBfbWFnbml0dWRlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgcHJvcGVydGllcyBvZiB0aGlzIGluc3RhbmNlIGF0IG9uY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldChfYW5nbGU6IG51bWJlciA9IDAsIF9tYWduaXR1ZGU6IG51bWJlciA9IDEpOiB2b2lkIHtcclxuICAgICAgdGhpcy5tYWduaXR1ZGUgPSBfbWFnbml0dWRlO1xyXG4gICAgICB0aGlzLmFuZ2xlID0gX2FuZ2xlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyByZWN5Y2xlKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLnNldCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHByZXR0eSBzdHJpbmcgcmVwcmVzZW50YXRpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiBgYW5nbGU6ICR7dGhpcy5hbmdsZS50b1ByZWNpc2lvbig1KX0sICBtYWduaXR1ZGU6ICR7dGhpcy5tYWduaXR1ZGUudG9QcmVjaXNpb24oNSl9YDtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBSZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvcjMgYXMgZ2VvZ3JhcGhpYyBjb29yZGluYXRlcyBhcyBzZWVuIG9uIGEgZ2xvYmVcclxuICAgKiBgYGBwbGFpbnRleHRcclxuICAgKiDihpB84oaSIExvbmdpdHVkZSAoQW5nbGUgdG8gdGhlIHotYXhpcykgXHJcbiAgICogIOKGlS0gTGF0aXR1ZGUgKEFuZ2xlIHRvIHRoZSBlcXVhdG9yKVxyXG4gICAqICAt4oaSIE1hZ25pdHVkZSAoRGlzdGFuY2UgZnJvbSB0aGUgY2VudGVyKSAgXHJcbiAgICogYGBgXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEdlbzMgaW1wbGVtZW50cyBSZWN5Y2FibGUge1xyXG4gICAgcHVibGljIG1hZ25pdHVkZTogbnVtYmVyID0gMDtcclxuICAgIHB1YmxpYyBsYXRpdHVkZTogbnVtYmVyID0gMDtcclxuICAgIHB1YmxpYyBsb25naXR1ZGU6IG51bWJlciA9IDA7XHJcblxyXG4gICAgY29uc3RydWN0b3IoX2xvbmdpdHVkZTogbnVtYmVyID0gMCwgX2xhdGl0dWRlOiBudW1iZXIgPSAwLCBfbWFnbml0dWRlOiBudW1iZXIgPSAxKSB7XHJcbiAgICAgIHRoaXMuc2V0KF9sb25naXR1ZGUsIF9sYXRpdHVkZSwgX21hZ25pdHVkZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHByb3BlcnRpZXMgb2YgdGhpcyBpbnN0YW5jZSBhdCBvbmNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQoX2xvbmdpdHVkZTogbnVtYmVyID0gMCwgX2xhdGl0dWRlOiBudW1iZXIgPSAwLCBfbWFnbml0dWRlOiBudW1iZXIgPSAxKTogdm9pZCB7XHJcbiAgICAgIHRoaXMubWFnbml0dWRlID0gX21hZ25pdHVkZTtcclxuICAgICAgdGhpcy5sYXRpdHVkZSA9IF9sYXRpdHVkZTtcclxuICAgICAgdGhpcy5sb25naXR1ZGUgPSBfbG9uZ2l0dWRlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyByZWN5Y2xlKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLnNldCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHByZXR0eSBzdHJpbmcgcmVwcmVzZW50YXRpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiBgbG9uZ2l0dWRlOiAke3RoaXMubG9uZ2l0dWRlLnRvUHJlY2lzaW9uKDUpfSwgbGF0aXR1ZGU6ICR7dGhpcy5sYXRpdHVkZS50b1ByZWNpc2lvbig1KX0sIG1hZ25pdHVkZTogJHt0aGlzLm1hZ25pdHVkZS50b1ByZWNpc2lvbig1KX1gO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8vIEZyb20gaHR0cDovL2JhYWdvZS5jb20vZW4vUmFuZG9tTXVzaW5ncy9qYXZhc2NyaXB0L1xyXG4gIC8vIEpvaGFubmVzIEJhYWfDuGUgPGJhYWdvZUBiYWFnb2UuY29tPiwgMjAxMFxyXG4gIGV4cG9ydCBmdW5jdGlvbiBNYXNoKCk6IEZ1bmN0aW9uIHtcclxuICAgIGxldCBuOiBudW1iZXIgPSAweGVmYzgyNDlkO1xyXG5cclxuICAgIGxldCBtYXNoOiBGdW5jdGlvbiA9IGZ1bmN0aW9uIChkYXRhOiBzdHJpbmcgfCBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICBkYXRhID0gZGF0YS50b1N0cmluZygpO1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIG4gKz0gZGF0YS5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGxldCBoOiBudW1iZXIgPSAwLjAyNTE5NjAzMjgyNDE2OTM4ICogbjtcclxuICAgICAgICBuID0gaCA+Pj4gMDtcclxuICAgICAgICBoIC09IG47XHJcbiAgICAgICAgaCAqPSBuO1xyXG4gICAgICAgIG4gPSBoID4+PiAwO1xyXG4gICAgICAgIGggLT0gbjtcclxuICAgICAgICBuICs9IGggKiAweDEwMDAwMDAwMDsgLy8gMl4zMlxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAobiA+Pj4gMCkgKiAyLjMyODMwNjQzNjUzODY5NjNlLTEwOyAvLyAyXi0zMlxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBtYXNoLnZlcnNpb24gPSAnTWFzaCAwLjknO1xyXG4gICAgcmV0dXJuIG1hc2g7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gRnJvbSBodHRwOi8vYmFhZ29lLmNvbS9lbi9SYW5kb21NdXNpbmdzL2phdmFzY3JpcHQvXHJcbiAgZXhwb3J0IGZ1bmN0aW9uIExGSUI0KCk6IEZ1bmN0aW9uIHtcclxuICAgIC8vIEdlb3JnZSBNYXJzYWdsaWEncyBMRklCNCxcclxuICAgIC8vaHR0cDovL2dyb3Vwcy5nb29nbGUuY29tL2dyb3VwL3NjaS5jcnlwdC9tc2cvZWI0ZGRkZTc4MmIxNzA1MVxyXG4gICAgbGV0IGFyZ3M6IG51bWJlcltdID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcclxuICAgIGxldCBrMDogbnVtYmVyID0gMCxcclxuICAgICAgazE6IG51bWJlciA9IDU4LFxyXG4gICAgICBrMjogbnVtYmVyID0gMTE5LFxyXG4gICAgICBrMzogbnVtYmVyID0gMTc4O1xyXG5cclxuICAgIGxldCBzOiBudW1iZXJbXSA9IFtdO1xyXG5cclxuICAgIGxldCBtYXNoOiBGdW5jdGlvbiA9IE1hc2goKTtcclxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICBhcmdzID0gWytuZXcgRGF0ZSgpXTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCAyNTY7IGorKykge1xyXG4gICAgICBzW2pdID0gbWFzaChcIiBcIik7XHJcbiAgICAgIHNbal0gLT0gbWFzaChcIiBcIikgKiA0Ljc2ODM3MTU4MjAzMTI1ZS03OyAvLyAyXi0yMVxyXG4gICAgICBpZiAoc1tqXSA8IDApIHtcclxuICAgICAgICBzW2pdICs9IDE7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCAyNTY7IGorKykge1xyXG4gICAgICAgIHNbal0gLT0gbWFzaChhcmdzW2ldKTtcclxuICAgICAgICBzW2pdIC09IG1hc2goYXJnc1tpXSkgKiA0Ljc2ODM3MTU4MjAzMTI1ZS03OyAvLyAyXi0yMVxyXG4gICAgICAgIGlmIChzW2pdIDwgMCkge1xyXG4gICAgICAgICAgc1tqXSArPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgbWFzaCA9IG51bGw7XHJcblxyXG4gICAgbGV0IHJhbmRvbTogRnVuY3Rpb24gPSBmdW5jdGlvbiAoKTogbnVtYmVyIHtcclxuICAgICAgbGV0IHg6IG51bWJlcjtcclxuXHJcbiAgICAgIGswID0gKGswICsgMSkgJiAyNTU7XHJcbiAgICAgIGsxID0gKGsxICsgMSkgJiAyNTU7XHJcbiAgICAgIGsyID0gKGsyICsgMSkgJiAyNTU7XHJcbiAgICAgIGszID0gKGszICsgMSkgJiAyNTU7XHJcblxyXG4gICAgICB4ID0gc1trMF0gLSBzW2sxXTtcclxuICAgICAgaWYgKHggPCAwKSB7XHJcbiAgICAgICAgeCArPSAxO1xyXG4gICAgICB9XHJcbiAgICAgIHggLT0gc1trMl07XHJcbiAgICAgIGlmICh4IDwgMCkge1xyXG4gICAgICAgIHggKz0gMTtcclxuICAgICAgfVxyXG4gICAgICB4IC09IHNbazNdO1xyXG4gICAgICBpZiAoeCA8IDApIHtcclxuICAgICAgICB4ICs9IDE7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBzW2swXSA9IHg7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIHJhbmRvbS51aW50MzIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyAgIHJldHVybiByYW5kb20oKSAqIDB4MTAwMDAwMDAwID4+PiAwOyAvLyAyXjMyXHJcbiAgICAvLyB9O1xyXG4gICAgLy8gcmFuZG9tLmZyYWN0NTMgPSByYW5kb207XHJcbiAgICAvLyByYW5kb20udmVyc2lvbiA9IFwiTEZJQjQgMC45XCI7XHJcbiAgICAvLyByYW5kb20uYXJncyA9IGFyZ3M7XHJcblxyXG4gICAgcmV0dXJuIHJhbmRvbTtcclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVwcmVzZW50cyB0aGUgbWF0cml4IGFzIHRyYW5zbGF0aW9uLCByb3RhdGlvbiBhbmQgc2NhbGluZyB7QGxpbmsgVmVjdG9yMn0sIGJlaW5nIGNhbGN1bGF0ZWQgZnJvbSB0aGUgbWF0cml4XHJcbiAgICovXHJcbiAgaW50ZXJmYWNlIFZlY3RvclJlcHJlc2VudGF0aW9uIHtcclxuICAgIHRyYW5zbGF0aW9uOiBWZWN0b3IyO1xyXG4gICAgcm90YXRpb246IG51bWJlcjtcclxuICAgIHNjYWxpbmc6IFZlY3RvcjI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTaW1wbGUgY2xhc3MgZm9yIDN4MyBtYXRyaXggb3BlcmF0aW9uc1xyXG4gICAqIEBhdXRob3JzIEphc2NoYSBLYXJhZ8O2bCwgSEZVLCAyMDE5IHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjBcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgTWF0cml4M3gzIGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZSwgUmVjeWNhYmxlIHtcclxuICAgIHByaXZhdGUgc3RhdGljIGRlZzJyYWQ6IG51bWJlciA9IE1hdGguUEkgLyAxODA7XHJcbiAgICBwcml2YXRlIGRhdGE6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoOSk7IC8vIFRoZSBkYXRhIG9mIHRoZSBtYXRyaXguXHJcbiAgICBwcml2YXRlIG11dGF0b3I6IE11dGF0b3IgPSBudWxsOyAvLyBwcmVwYXJlZCBmb3Igb3B0aW1pemF0aW9uLCBrZWVwIG11dGF0b3IgdG8gcmVkdWNlIHJlZHVuZGFudCBjYWxjdWxhdGlvbiBhbmQgZm9yIGNvbXBhcmlzb24uIFNldCB0byBudWxsIHdoZW4gZGF0YSBjaGFuZ2VzIVxyXG4gICAgcHJpdmF0ZSB2ZWN0b3JzOiBWZWN0b3JSZXByZXNlbnRhdGlvbjsgLy8gdmVjdG9yIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgbWF0cml4XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLnJlY3ljbGUoKTtcclxuICAgICAgdGhpcy5yZXNldENhY2hlKCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vVE9ETzogZmlndXJlIG91dCB3aGF0IHRoaXMgaXMgdXNlZCBmb3JcclxuICAgIHB1YmxpYyBzdGF0aWMgUFJPSkVDVElPTihfd2lkdGg6IG51bWJlciwgX2hlaWdodDogbnVtYmVyKTogTWF0cml4M3gzIHtcclxuICAgICAgbGV0IG10eFJlc3VsdDogTWF0cml4M3gzID0gbmV3IE1hdHJpeDN4MztcclxuICAgICAgbXR4UmVzdWx0LmRhdGEuc2V0KFtcclxuICAgICAgICAyIC8gX3dpZHRoLCAwLCAwLFxyXG4gICAgICAgIDAsIC0yIC8gX2hlaWdodCwgMCxcclxuICAgICAgICAtMSwgMSwgMVxyXG4gICAgICBdKTtcclxuICAgICAgcmV0dXJuIG10eFJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIElERU5USVRZKCk6IE1hdHJpeDN4MyB7XHJcbiAgICAgIGNvbnN0IG10eFJlc3VsdDogTWF0cml4M3gzID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDN4Myk7XHJcbiAgICAgIHJldHVybiBtdHhSZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbWF0cml4IHRoYXQgdHJhbnNsYXRlcyBjb29yZGluYXRlcyBhbG9uZyB0aGUgeC0sIHktIGFuZCB6LWF4aXMgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiB7QGxpbmsgVmVjdG9yMn0uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgVFJBTlNMQVRJT04oX3RyYW5zbGF0ZTogVmVjdG9yMik6IE1hdHJpeDN4MyB7XHJcbiAgICAgIGNvbnN0IG10eFJlc3VsdDogTWF0cml4M3gzID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDN4Myk7XHJcbiAgICAgIG10eFJlc3VsdC5kYXRhLnNldChbXHJcbiAgICAgICAgMSwgMCwgMCxcclxuICAgICAgICAwLCAxLCAwLFxyXG4gICAgICAgIF90cmFuc2xhdGUueCwgX3RyYW5zbGF0ZS55LCAxXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gbXR4UmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG1hdHJpeCB0aGF0IHJvdGF0ZXMgY29vcmRpbmF0ZXMgb24gdGhlIHotYXhpcyB3aGVuIG11bHRpcGxpZWQgYnkuXHJcbiAgICAgKiBAcGFyYW0gX2FuZ2xlSW5EZWdyZWVzIFRoZSB2YWx1ZSBvZiB0aGUgcm90YXRpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgUk9UQVRJT04oX2FuZ2xlSW5EZWdyZWVzOiBudW1iZXIpOiBNYXRyaXgzeDMge1xyXG4gICAgICBjb25zdCBtdHhSZXN1bHQ6IE1hdHJpeDN4MyA9IFJlY3ljbGVyLmdldChNYXRyaXgzeDMpO1xyXG4gICAgICBsZXQgYW5nbGVJblJhZGlhbnM6IG51bWJlciA9IF9hbmdsZUluRGVncmVlcyAqIE1hdHJpeDN4My5kZWcycmFkO1xyXG4gICAgICBsZXQgc2luOiBudW1iZXIgPSBNYXRoLnNpbihhbmdsZUluUmFkaWFucyk7XHJcbiAgICAgIGxldCBjb3M6IG51bWJlciA9IE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKTtcclxuICAgICAgbXR4UmVzdWx0LmRhdGEuc2V0KFtcclxuICAgICAgICBjb3MsIHNpbiwgMCxcclxuICAgICAgICAtc2luLCBjb3MsIDAsXHJcbiAgICAgICAgMCwgMCwgMVxyXG4gICAgICBdKTtcclxuICAgICAgcmV0dXJuIG10eFJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBtYXRyaXggdGhhdCBzY2FsZXMgY29vcmRpbmF0ZXMgYWxvbmcgdGhlIHgtLCB5LSBhbmQgei1heGlzIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4ge0BsaW5rIFZlY3RvcjJ9XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgU0NBTElORyhfc2NhbGFyOiBWZWN0b3IyKTogTWF0cml4M3gzIHtcclxuICAgICAgY29uc3QgbXR4UmVzdWx0OiBNYXRyaXgzeDMgPSBSZWN5Y2xlci5nZXQoTWF0cml4M3gzKTtcclxuICAgICAgbXR4UmVzdWx0LmRhdGEuc2V0KFtcclxuICAgICAgICBfc2NhbGFyLngsIDAsIDAsXHJcbiAgICAgICAgMCwgX3NjYWxhci55LCAwLFxyXG4gICAgICAgIDAsIDAsIDFcclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiBtdHhSZXN1bHQ7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBNVUxUSVBMSUNBVElPTihfbXR4TGVmdDogTWF0cml4M3gzLCBfbXR4UmlnaHQ6IE1hdHJpeDN4Myk6IE1hdHJpeDN4MyB7XHJcbiAgICAgIGxldCBhMDA6IG51bWJlciA9IF9tdHhMZWZ0LmRhdGFbMCAqIDMgKyAwXTtcclxuICAgICAgbGV0IGEwMTogbnVtYmVyID0gX210eExlZnQuZGF0YVswICogMyArIDFdO1xyXG4gICAgICBsZXQgYTAyOiBudW1iZXIgPSBfbXR4TGVmdC5kYXRhWzAgKiAzICsgMl07XHJcbiAgICAgIGxldCBhMTA6IG51bWJlciA9IF9tdHhMZWZ0LmRhdGFbMSAqIDMgKyAwXTtcclxuICAgICAgbGV0IGExMTogbnVtYmVyID0gX210eExlZnQuZGF0YVsxICogMyArIDFdO1xyXG4gICAgICBsZXQgYTEyOiBudW1iZXIgPSBfbXR4TGVmdC5kYXRhWzEgKiAzICsgMl07XHJcbiAgICAgIGxldCBhMjA6IG51bWJlciA9IF9tdHhMZWZ0LmRhdGFbMiAqIDMgKyAwXTtcclxuICAgICAgbGV0IGEyMTogbnVtYmVyID0gX210eExlZnQuZGF0YVsyICogMyArIDFdO1xyXG4gICAgICBsZXQgYTIyOiBudW1iZXIgPSBfbXR4TGVmdC5kYXRhWzIgKiAzICsgMl07XHJcbiAgICAgIGxldCBiMDA6IG51bWJlciA9IF9tdHhSaWdodC5kYXRhWzAgKiAzICsgMF07XHJcbiAgICAgIGxldCBiMDE6IG51bWJlciA9IF9tdHhSaWdodC5kYXRhWzAgKiAzICsgMV07XHJcbiAgICAgIGxldCBiMDI6IG51bWJlciA9IF9tdHhSaWdodC5kYXRhWzAgKiAzICsgMl07XHJcbiAgICAgIGxldCBiMTA6IG51bWJlciA9IF9tdHhSaWdodC5kYXRhWzEgKiAzICsgMF07XHJcbiAgICAgIGxldCBiMTE6IG51bWJlciA9IF9tdHhSaWdodC5kYXRhWzEgKiAzICsgMV07XHJcbiAgICAgIGxldCBiMTI6IG51bWJlciA9IF9tdHhSaWdodC5kYXRhWzEgKiAzICsgMl07XHJcbiAgICAgIGxldCBiMjA6IG51bWJlciA9IF9tdHhSaWdodC5kYXRhWzIgKiAzICsgMF07XHJcbiAgICAgIGxldCBiMjE6IG51bWJlciA9IF9tdHhSaWdodC5kYXRhWzIgKiAzICsgMV07XHJcbiAgICAgIGxldCBiMjI6IG51bWJlciA9IF9tdHhSaWdodC5kYXRhWzIgKiAzICsgMl07XHJcbiAgICAgIGxldCBtdHhSZXN1bHQ6IE1hdHJpeDN4MyA9IG5ldyBNYXRyaXgzeDM7XHJcbiAgICAgIG10eFJlc3VsdC5kYXRhLnNldChbXHJcbiAgICAgICAgYjAwICogYTAwICsgYjAxICogYTEwICsgYjAyICogYTIwLFxyXG4gICAgICAgIGIwMCAqIGEwMSArIGIwMSAqIGExMSArIGIwMiAqIGEyMSxcclxuICAgICAgICBiMDAgKiBhMDIgKyBiMDEgKiBhMTIgKyBiMDIgKiBhMjIsXHJcbiAgICAgICAgYjEwICogYTAwICsgYjExICogYTEwICsgYjEyICogYTIwLFxyXG4gICAgICAgIGIxMCAqIGEwMSArIGIxMSAqIGExMSArIGIxMiAqIGEyMSxcclxuICAgICAgICBiMTAgKiBhMDIgKyBiMTEgKiBhMTIgKyBiMTIgKiBhMjIsXHJcbiAgICAgICAgYjIwICogYTAwICsgYjIxICogYTEwICsgYjIyICogYTIwLFxyXG4gICAgICAgIGIyMCAqIGEwMSArIGIyMSAqIGExMSArIGIyMiAqIGEyMSxcclxuICAgICAgICBiMjAgKiBhMDIgKyBiMjEgKiBhMTIgKyBiMjIgKiBhMjJcclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiBtdHhSZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogLSBnZXQ6IHJldHVybiBhIHZlY3RvciByZXByZXNlbnRhdGlvbiBvZiB0aGUgdHJhbnNsYXRpb24ge0BsaW5rIFZlY3RvcjJ9LiAgXHJcbiAgICAgKiAqKkNhdXRpb24hKiogVXNlIGltbWVkaWF0ZWx5LCBzaW5jZSB0aGUgdmVjdG9yIGlzIGdvaW5nIHRvIGJlIHJldXNlZCBieSBSZWN5Y2xlci4gQ3JlYXRlIGEgY2xvbmUgdG8ga2VlcCBsb25nZXIgYW5kIG1hbmlwdWxhdGUuIFxyXG4gICAgICogLSBzZXQ6IGVmZmVjdCB0aGUgbWF0cml4IGlnbm9yaW5nIGl0cyByb3RhdGlvbiBhbmQgc2NhbGluZ1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHRyYW5zbGF0aW9uKCk6IFZlY3RvcjIge1xyXG4gICAgICBpZiAoIXRoaXMudmVjdG9ycy50cmFuc2xhdGlvbilcclxuICAgICAgICB0aGlzLnZlY3RvcnMudHJhbnNsYXRpb24gPSBuZXcgVmVjdG9yMih0aGlzLmRhdGFbNl0sIHRoaXMuZGF0YVs3XSk7XHJcbiAgICAgIHJldHVybiB0aGlzLnZlY3RvcnMudHJhbnNsYXRpb247IC8vIC5jbG9uZTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgdHJhbnNsYXRpb24oX3RyYW5zbGF0aW9uOiBWZWN0b3IyKSB7XHJcbiAgICAgIHRoaXMuZGF0YS5zZXQoX3RyYW5zbGF0aW9uLmdldCgpLCA2KTtcclxuICAgICAgLy8gbm8gZnVsbCBjYWNoZSByZXNldCByZXF1aXJlZFxyXG4gICAgICB0aGlzLnZlY3RvcnMudHJhbnNsYXRpb24gPSBfdHJhbnNsYXRpb247XHJcbiAgICAgIHRoaXMubXV0YXRvciA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogLSBnZXQ6IGEgY29weSBvZiB0aGUgY2FsY3VsYXRlZCByb3RhdGlvbiB7QGxpbmsgVmVjdG9yMn0gICBcclxuICAgICAqIC0gc2V0OiBlZmZlY3QgdGhlIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHJvdGF0aW9uKCk6IG51bWJlciB7XHJcbiAgICAgIGlmICghdGhpcy52ZWN0b3JzLnJvdGF0aW9uKVxyXG4gICAgICAgIHRoaXMudmVjdG9ycy5yb3RhdGlvbiA9IHRoaXMuZ2V0RXVsZXJBbmdsZSgpO1xyXG4gICAgICByZXR1cm4gdGhpcy52ZWN0b3JzLnJvdGF0aW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCByb3RhdGlvbihfcm90YXRpb246IG51bWJlcikge1xyXG4gICAgICB0aGlzLm11dGF0ZSh7IFwicm90YXRpb25cIjogX3JvdGF0aW9uIH0pO1xyXG4gICAgICB0aGlzLnJlc2V0Q2FjaGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiAtIGdldDogcmV0dXJuIGEgdmVjdG9yIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzY2FsZSB7QGxpbmsgVmVjdG9yM30uICBcclxuICAgICAqICoqQ2F1dGlvbiEqKiBEbyBub3QgbWFuaXB1bGF0ZSByZXN1bHQsIGluc3RlYWQgY3JlYXRlIGEgY2xvbmUhICAgIFxyXG4gICAgICogLSBzZXQ6IGVmZmVjdCB0aGUgbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgc2NhbGluZygpOiBWZWN0b3IyIHtcclxuICAgICAgaWYgKCF0aGlzLnZlY3RvcnMuc2NhbGluZylcclxuICAgICAgICB0aGlzLnZlY3RvcnMuc2NhbGluZyA9IG5ldyBWZWN0b3IyKFxyXG4gICAgICAgICAgTWF0aC5oeXBvdCh0aGlzLmRhdGFbMF0sIHRoaXMuZGF0YVsxXSksXHJcbiAgICAgICAgICBNYXRoLmh5cG90KHRoaXMuZGF0YVszXSwgdGhpcy5kYXRhWzRdKVxyXG4gICAgICAgICk7XHJcbiAgICAgIHJldHVybiB0aGlzLnZlY3RvcnMuc2NhbGluZzsgLy8gLmNsb25lO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBzY2FsaW5nKF9zY2FsaW5nOiBWZWN0b3IyKSB7XHJcbiAgICAgIHRoaXMubXV0YXRlKHsgXCJzY2FsaW5nXCI6IF9zY2FsaW5nIH0pO1xyXG4gICAgICB0aGlzLnJlc2V0Q2FjaGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhIGNvcHkgb2YgdGhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGNsb25lKCk6IE1hdHJpeDN4MyB7XHJcbiAgICAgIGxldCBtdHhDbG9uZTogTWF0cml4M3gzID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDN4Myk7XHJcbiAgICAgIG10eENsb25lLnNldCh0aGlzKTtcclxuICAgICAgcmV0dXJuIG10eENsb25lO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyByZWN5Y2xlKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KFtcclxuICAgICAgICAxLCAwLCAwLFxyXG4gICAgICAgIDAsIDEsIDAsXHJcbiAgICAgICAgMCwgMCwgMVxyXG4gICAgICBdKTtcclxuICAgICAgdGhpcy5yZXNldENhY2hlKCk7IFxyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2xhdGlvblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSB0cmFuc2xhdGlvbiBieSB0aGUgZ2l2ZW4ge0BsaW5rIFZlY3RvcjJ9IHRvIHRoaXMgbWF0cml4IFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdHJhbnNsYXRlKF9ieTogVmVjdG9yMik6IHZvaWQge1xyXG4gICAgICBjb25zdCBtdHhSZXN1bHQ6IE1hdHJpeDN4MyA9IE1hdHJpeDN4My5NVUxUSVBMSUNBVElPTih0aGlzLCBNYXRyaXgzeDMuVFJBTlNMQVRJT04oX2J5KSk7XHJcbiAgICAgIC8vIFRPRE86IHBvc3NpYmxlIG9wdGltaXphdGlvbiwgdHJhbnNsYXRpb24gbWF5IGFsdGVyIG11dGF0b3IgaW5zdGVhZCBvZiBkZWxldGluZyBpdC5cclxuICAgICAgdGhpcy5zZXQobXR4UmVzdWx0KTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUobXR4UmVzdWx0KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIHRyYW5zbGF0aW9uIGFsb25nIHRoZSB4LUF4aXMgYnkgdGhlIGdpdmVuIGFtb3VudCB0byB0aGlzIG1hdHJpeCBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHRyYW5zbGF0ZVgoX3g6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICB0aGlzLmRhdGFbNl0gKz0gX3g7XHJcbiAgICAgIHRoaXMubXV0YXRvciA9IG51bGw7XHJcbiAgICAgIHRoaXMudmVjdG9ycy50cmFuc2xhdGlvbiA9IG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIHRyYW5zbGF0aW9uIGFsb25nIHRoZSB5LUF4aXMgYnkgdGhlIGdpdmVuIGFtb3VudCB0byB0aGlzIG1hdHJpeCBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHRyYW5zbGF0ZVkoX3k6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICB0aGlzLmRhdGFbN10gKz0gX3k7XHJcbiAgICAgIHRoaXMubXV0YXRvciA9IG51bGw7XHJcbiAgICAgIHRoaXMudmVjdG9ycy50cmFuc2xhdGlvbiA9IG51bGw7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gU2NhbGluZ1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSBzY2FsaW5nIGJ5IHRoZSBnaXZlbiB7QGxpbmsgVmVjdG9yMn0gdG8gdGhpcyBtYXRyaXggXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzY2FsZShfYnk6IFZlY3RvcjIpOiB2b2lkIHtcclxuICAgICAgY29uc3QgbXR4UmVzdWx0OiBNYXRyaXgzeDMgPSBNYXRyaXgzeDMuTVVMVElQTElDQVRJT04odGhpcywgTWF0cml4M3gzLlNDQUxJTkcoX2J5KSk7XHJcbiAgICAgIHRoaXMuc2V0KG10eFJlc3VsdCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIHNjYWxpbmcgYWxvbmcgdGhlIHgtQXhpcyBieSB0aGUgZ2l2ZW4gYW1vdW50IHRvIHRoaXMgbWF0cml4IFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2NhbGVYKF9ieTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIGxldCB2ZWN0b3I6IFZlY3RvcjIgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMik7XHJcbiAgICAgIHZlY3Rvci5zZXQoX2J5LCAxKTtcclxuICAgICAgdGhpcy5zY2FsZSh2ZWN0b3IpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZSh2ZWN0b3IpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSBzY2FsaW5nIGFsb25nIHRoZSB5LUF4aXMgYnkgdGhlIGdpdmVuIGFtb3VudCB0byB0aGlzIG1hdHJpeCBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNjYWxlWShfYnk6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICBsZXQgdmVjdG9yOiBWZWN0b3IyID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjIpO1xyXG4gICAgICB2ZWN0b3Iuc2V0KDEsIF9ieSk7XHJcbiAgICAgIHRoaXMuc2NhbGUodmVjdG9yKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUodmVjdG9yKTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuXHJcbiAgICAvLyNyZWdpb24gUm90YXRpb25cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHJvdGF0aW9uIGFyb3VuZCB0aGUgei1BeGlzIHRvIHRoaXMgbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByb3RhdGUoX2FuZ2xlSW5EZWdyZWVzOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgY29uc3QgbXR4UmVzdWx0OiBNYXRyaXgzeDMgPSBNYXRyaXgzeDMuTVVMVElQTElDQVRJT04odGhpcywgTWF0cml4M3gzLlJPVEFUSU9OKF9hbmdsZUluRGVncmVlcykpO1xyXG4gICAgICB0aGlzLnNldChtdHhSZXN1bHQpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShtdHhSZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZm9ybWF0aW9uXHJcbiAgICAvKipcclxuICAgICAqIE11bHRpcGx5IHRoaXMgbWF0cml4IHdpdGggdGhlIGdpdmVuIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbXVsdGlwbHkoX210eFJpZ2h0OiBNYXRyaXgzeDMpOiB2b2lkIHtcclxuICAgICAgbGV0IG10eFJlc3VsdDogTWF0cml4M3gzID0gTWF0cml4M3gzLk1VTFRJUExJQ0FUSU9OKHRoaXMsIF9tdHhSaWdodCk7XHJcbiAgICAgIHRoaXMuc2V0KG10eFJlc3VsdCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFJlc3VsdCk7XHJcbiAgICAgIHRoaXMubXV0YXRvciA9IG51bGw7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgYW5kIHJldHVybnMgdGhlIGV1bGVyLWFuZ2xlcyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgcm90YXRpb24gb2YgdGhpcyBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEV1bGVyQW5nbGUoKTogbnVtYmVyIHtcclxuICAgICAgbGV0IHNjYWxpbmc6IFZlY3RvcjIgPSB0aGlzLnNjYWxpbmc7XHJcblxyXG4gICAgICBsZXQgczA6IG51bWJlciA9IHRoaXMuZGF0YVswXSAvIHNjYWxpbmcueDtcclxuICAgICAgbGV0IHMxOiBudW1iZXIgPSB0aGlzLmRhdGFbMV0gLyBzY2FsaW5nLng7XHJcbiAgICAgIGxldCBzMzogbnVtYmVyID0gdGhpcy5kYXRhWzNdIC8gc2NhbGluZy55O1xyXG4gICAgICBsZXQgczQ6IG51bWJlciA9IHRoaXMuZGF0YVs0XSAvIHNjYWxpbmcueTtcclxuXHJcbiAgICAgIGxldCB4U2tldzogbnVtYmVyID0gTWF0aC5hdGFuMigtczMsIHM0KTtcclxuICAgICAgbGV0IHlTa2V3OiBudW1iZXIgPSBNYXRoLmF0YW4yKHMwLCBzMSk7XHJcblxyXG4gICAgICBsZXQgc3k6IG51bWJlciA9IE1hdGguaHlwb3QoczAsIHMxKTsgLy8gcHJvYmFibHkgMi4gcGFyYW0gc2hvdWxkIGJlIHRoaXMuZGF0YVs0XSAvIHNjYWxpbmcueVxyXG4gICAgICBsZXQgcm90YXRpb246IG51bWJlcjtcclxuXHJcbiAgICAgIGlmICghKHN5ID4gMWUtNikpXHJcbiAgICAgICAgcm90YXRpb24gPSB5U2tldztcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHJvdGF0aW9uID0geFNrZXc7XHJcblxyXG4gICAgICByb3RhdGlvbiAqPSAxODAgLyBNYXRoLlBJO1xyXG5cclxuICAgICAgcmV0dXJuIHJvdGF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgZWxlbWVudHMgb2YgdGhpcyBtYXRyaXggdG8gdGhlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQoX210eFRvOiBNYXRyaXgzeDMpOiB2b2lkIHtcclxuICAgICAgLy8gdGhpcy5kYXRhID0gX3RvLmdldCgpO1xyXG4gICAgICB0aGlzLmRhdGEuc2V0KF9tdHhUby5kYXRhKTtcclxuICAgICAgdGhpcy5yZXNldENhY2hlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiBgxpIuTWF0cml4M3gzKHRyYW5zbGF0aW9uOiAke3RoaXMudHJhbnNsYXRpb24udG9TdHJpbmcoKX0sIHJvdGF0aW9uOiAke3RoaXMucm90YXRpb24udG9TdHJpbmcoKX0sIHNjYWxpbmc6ICR7dGhpcy5zY2FsaW5nLnRvU3RyaW5nKCl9YDtcclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBlbGVtZW50cyBvZiB0aGlzIG1hdHJpeCBhcyBhIEZsb2F0MzJBcnJheVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0KCk6IEZsb2F0MzJBcnJheSB7XHJcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KHRoaXMuZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgLy8gdGhpcy5nZXRNdXRhdG9yKCk7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge1xyXG4gICAgICAgIHRyYW5zbGF0aW9uOiB0aGlzLnRyYW5zbGF0aW9uLnNlcmlhbGl6ZSgpLFxyXG4gICAgICAgIHJvdGF0aW9uOiB0aGlzLnJvdGF0aW9uLFxyXG4gICAgICAgIHNjYWxpbmc6IHRoaXMuc2NhbGluZy5zZXJpYWxpemUoKVxyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0ge1xyXG4gICAgICAgIHRyYW5zbGF0aW9uOiBhd2FpdCB0aGlzLnRyYW5zbGF0aW9uLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLnRyYW5zbGF0aW9uKSxcclxuICAgICAgICByb3RhdGlvbjogX3NlcmlhbGl6YXRpb24ucm90YXRpb24sXHJcbiAgICAgICAgc2NhbGluZzogYXdhaXQgdGhpcy5zY2FsaW5nLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLnNjYWxpbmcpXHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMubXV0YXRlKG11dGF0b3IpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcclxuICAgICAgaWYgKHRoaXMubXV0YXRvcilcclxuICAgICAgICByZXR1cm4gdGhpcy5tdXRhdG9yO1xyXG5cclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSB7XHJcbiAgICAgICAgdHJhbnNsYXRpb246IHRoaXMudHJhbnNsYXRpb24uZ2V0TXV0YXRvcigpLFxyXG4gICAgICAgIHJvdGF0aW9uOiB0aGlzLnJvdGF0aW9uLFxyXG4gICAgICAgIHNjYWxpbmc6IHRoaXMuc2NhbGluZy5nZXRNdXRhdG9yKClcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIGNhY2hlIG11dGF0b3JcclxuICAgICAgdGhpcy5tdXRhdG9yID0gbXV0YXRvcjtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBsZXQgb2xkVHJhbnNsYXRpb246IFZlY3RvcjIgPSB0aGlzLnRyYW5zbGF0aW9uO1xyXG4gICAgICBsZXQgb2xkUm90YXRpb246IG51bWJlciA9IHRoaXMucm90YXRpb247XHJcbiAgICAgIGxldCBvbGRTY2FsaW5nOiBWZWN0b3IyID0gdGhpcy5zY2FsaW5nO1xyXG4gICAgICBsZXQgbmV3VHJhbnNsYXRpb246IFZlY3RvcjIgPSA8VmVjdG9yMj5fbXV0YXRvcltcInRyYW5zbGF0aW9uXCJdO1xyXG4gICAgICBsZXQgbmV3Um90YXRpb246IG51bWJlciA9IDxudW1iZXI+X211dGF0b3JbXCJyb3RhdGlvblwiXTtcclxuICAgICAgbGV0IG5ld1NjYWxpbmc6IFZlY3RvcjIgPSA8VmVjdG9yMj5fbXV0YXRvcltcInNjYWxpbmdcIl07XHJcbiAgICAgIGxldCB2ZWN0b3JzOiBWZWN0b3JSZXByZXNlbnRhdGlvbiA9IHsgdHJhbnNsYXRpb246IG9sZFRyYW5zbGF0aW9uLCByb3RhdGlvbjogb2xkUm90YXRpb24sIHNjYWxpbmc6IG9sZFNjYWxpbmcgfTtcclxuICAgICAgaWYgKG5ld1RyYW5zbGF0aW9uKSB7XHJcbiAgICAgICAgdmVjdG9ycy50cmFuc2xhdGlvbiA9IG5ldyBWZWN0b3IyKFxyXG4gICAgICAgICAgbmV3VHJhbnNsYXRpb24ueCAhPSB1bmRlZmluZWQgPyBuZXdUcmFuc2xhdGlvbi54IDogb2xkVHJhbnNsYXRpb24ueCxcclxuICAgICAgICAgIG5ld1RyYW5zbGF0aW9uLnkgIT0gdW5kZWZpbmVkID8gbmV3VHJhbnNsYXRpb24ueSA6IG9sZFRyYW5zbGF0aW9uLnlcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2ZWN0b3JzLnJvdGF0aW9uID0gKG5ld1JvdGF0aW9uID09IHVuZGVmaW5lZCkgPyBvbGRSb3RhdGlvbiA6IG5ld1JvdGF0aW9uO1xyXG5cclxuICAgICAgaWYgKG5ld1NjYWxpbmcpIHtcclxuICAgICAgICB2ZWN0b3JzLnNjYWxpbmcgPSBuZXcgVmVjdG9yMihcclxuICAgICAgICAgIG5ld1NjYWxpbmcueCAhPSB1bmRlZmluZWQgPyBuZXdTY2FsaW5nLnggOiBvbGRTY2FsaW5nLngsXHJcbiAgICAgICAgICBuZXdTY2FsaW5nLnkgIT0gdW5kZWZpbmVkID8gbmV3U2NhbGluZy55IDogb2xkU2NhbGluZy55XHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVE9ETzogcG9zc2libGUgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIHdoZW4gb25seSBvbmUgb3IgdHdvIGNvbXBvbmVudHMgY2hhbmdlLCB0aGVuIHVzZSBvbGQgbWF0cml4IGluc3RlYWQgb2YgSURFTlRJVFkgYW5kIHRyYW5zZm9ybSBieSBkaWZmZXJlbmNlcy9xdW90aWVudHNcclxuICAgICAgbGV0IG10eFJlc3VsdDogTWF0cml4M3gzID0gTWF0cml4M3gzLklERU5USVRZKCk7XHJcbiAgICAgIGlmICh2ZWN0b3JzLnRyYW5zbGF0aW9uKVxyXG4gICAgICAgIG10eFJlc3VsdC50cmFuc2xhdGUodmVjdG9ycy50cmFuc2xhdGlvbik7XHJcbiAgICAgIGlmICh2ZWN0b3JzLnJvdGF0aW9uKSB7XHJcbiAgICAgICAgbXR4UmVzdWx0LnJvdGF0ZSh2ZWN0b3JzLnJvdGF0aW9uKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodmVjdG9ycy5zY2FsaW5nKVxyXG4gICAgICAgIG10eFJlc3VsdC5zY2FsZSh2ZWN0b3JzLnNjYWxpbmcpO1xyXG4gICAgICB0aGlzLnNldChtdHhSZXN1bHQpO1xyXG5cclxuICAgICAgdGhpcy52ZWN0b3JzID0gdmVjdG9ycztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvckF0dHJpYnV0ZVR5cGVzKF9tdXRhdG9yOiBNdXRhdG9yKTogTXV0YXRvckF0dHJpYnV0ZVR5cGVzIHtcclxuICAgICAgbGV0IHR5cGVzOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMgPSB7fTtcclxuICAgICAgaWYgKF9tdXRhdG9yLnRyYW5zbGF0aW9uKSB0eXBlcy50cmFuc2xhdGlvbiA9IFwiVmVjdG9yMlwiO1xyXG4gICAgICBpZiAoX211dGF0b3Iucm90YXRpb24gIT0gdW5kZWZpbmVkKSB0eXBlcy5yb3RhdGlvbiA9IFwibnVtYmVyXCI7XHJcbiAgICAgIGlmIChfbXV0YXRvci5zY2FsaW5nKSB0eXBlcy5zY2FsaW5nID0gXCJWZWN0b3IyXCI7XHJcbiAgICAgIHJldHVybiB0eXBlcztcclxuICAgIH1cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7LyoqICovIH1cclxuXHJcbiAgICBwcml2YXRlIHJlc2V0Q2FjaGUoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMudmVjdG9ycyA9IHsgdHJhbnNsYXRpb246IG51bGwsIHJvdGF0aW9uOiBudWxsLCBzY2FsaW5nOiBudWxsIH07XHJcbiAgICAgIHRoaXMubXV0YXRvciA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vI2VuZHJlZ2lvblxyXG5cclxufVxyXG4iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVwcmVzZW50cyB0aGUgbWF0cml4IGFzIHRyYW5zbGF0aW9uLCByb3RhdGlvbiBhbmQgc2NhbGluZyB7QGxpbmsgVmVjdG9yM30sIGJlaW5nIGNhbGN1bGF0ZWQgZnJvbSB0aGUgbWF0cml4XHJcbiAgICovXHJcbiAgaW50ZXJmYWNlIFZlY3RvclJlcHJlc2VudGF0aW9uIHtcclxuICAgIHRyYW5zbGF0aW9uOiBWZWN0b3IzO1xyXG4gICAgcm90YXRpb246IFZlY3RvcjM7XHJcbiAgICBzY2FsaW5nOiBWZWN0b3IzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RvcmVzIGEgNHg0IHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBhbmQgcHJvdmlkZXMgb3BlcmF0aW9ucyBmb3IgaXQuXHJcbiAgICogYGBgcGxhaW50ZXh0XHJcbiAgICogWyAwLCAxLCAyLCAzIF0g4oaQIHJvdyB2ZWN0b3IgeFxyXG4gICAqIFsgNCwgNSwgNiwgNyBdIOKGkCByb3cgdmVjdG9yIHlcclxuICAgKiBbIDgsIDksMTAsMTEgXSDihpAgcm93IHZlY3RvciB6XHJcbiAgICogWzEyLDEzLDE0LDE1IF0g4oaQIHRyYW5zbGF0aW9uXHJcbiAgICogICAgICAgICAgICDihpEgIGhvbW9nZW5lb3VzIGNvbHVtblxyXG4gICAqIGBgYFxyXG4gICAqIEBhdXRob3JzIEphc2NoYSBLYXJhZ8O2bCwgSEZVLCAyMDE5IHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuXHJcbiAgZXhwb3J0IGNsYXNzIE1hdHJpeDR4NCBleHRlbmRzIE11dGFibGUgaW1wbGVtZW50cyBTZXJpYWxpemFibGUsIFJlY3ljYWJsZSB7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBkZWcycmFkOiBudW1iZXIgPSBNYXRoLlBJIC8gMTgwO1xyXG4gICAgI2V1bGVyQW5nbGVzOiBWZWN0b3IzID0gVmVjdG9yMy5aRVJPKCk7XHJcbiAgICAjdmVjdG9yczogVmVjdG9yUmVwcmVzZW50YXRpb24gPSB7IHRyYW5zbGF0aW9uOiBWZWN0b3IzLlpFUk8oKSwgcm90YXRpb246IFZlY3RvcjMuWkVSTygpLCBzY2FsaW5nOiBWZWN0b3IzLlpFUk8oKSB9O1xyXG5cclxuICAgIHByaXZhdGUgZGF0YTogRmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSgxNik7IC8vIFRoZSBkYXRhIG9mIHRoZSBtYXRyaXguXHJcbiAgICBwcml2YXRlIG11dGF0b3I6IE11dGF0b3IgPSBudWxsOyAvLyBwcmVwYXJlZCBmb3Igb3B0aW1pemF0aW9uLCBrZWVwIG11dGF0b3IgdG8gcmVkdWNlIHJlZHVuZGFudCBjYWxjdWxhdGlvbiBhbmQgZm9yIGNvbXBhcmlzb24uIFNldCB0byBudWxsIHdoZW4gZGF0YSBjaGFuZ2VzIVxyXG4gICAgcHJpdmF0ZSB2ZWN0b3JzOiBWZWN0b3JSZXByZXNlbnRhdGlvbjsgLy8gdmVjdG9yIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgbWF0cml4XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLnJlY3ljbGUoKTtcclxuICAgICAgdGhpcy5yZXNldENhY2hlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFNUQVRJQ1NcclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmUgYSBuZXcgaWRlbnRpdHkgbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgSURFTlRJVFkoKTogTWF0cml4NHg0IHtcclxuICAgICAgY29uc3QgbXR4UmVzdWx0OiBNYXRyaXg0eDQgPSBSZWN5Y2xlci5nZXQoTWF0cml4NHg0KTtcclxuICAgICAgcmV0dXJuIG10eFJlc3VsdDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IG1hdHJpeCBhY2NvcmRpbmcgdG8gdGhlIHRyYW5zbGF0aW9uLCByb3RhdGlvbiBhbmQgc2NhbGluZyB7QGxpbmsgVmVjdG9yM31zIGdpdmVuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgQ09OU1RSVUNUSU9OKF92ZWN0b3JzOiBWZWN0b3JSZXByZXNlbnRhdGlvbik6IE1hdHJpeDR4NCB7XHJcbiAgICAgIGxldCByZXN1bHQ6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpO1xyXG4gICAgICByZXN1bHQubXV0YXRlKF92ZWN0b3JzKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIGFuZCByZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHR3byBwYXNzZWQgbWF0cmljZXMuXHJcbiAgICAgKiBAcGFyYW0gX210eExlZnQgVGhlIG1hdHJpeCB0byBtdWx0aXBseS5cclxuICAgICAqIEBwYXJhbSBfbXR4UmlnaHQgVGhlIG1hdHJpeCB0byBtdWx0aXBseSBieS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBNVUxUSVBMSUNBVElPTihfbXR4TGVmdDogTWF0cml4NHg0LCBfbXR4UmlnaHQ6IE1hdHJpeDR4NCk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIGxldCBhOiBGbG9hdDMyQXJyYXkgPSBfbXR4TGVmdC5kYXRhO1xyXG4gICAgICBsZXQgYjogRmxvYXQzMkFycmF5ID0gX210eFJpZ2h0LmRhdGE7XHJcbiAgICAgIC8vIGxldCBtYXRyaXg6IE1hdHJpeDR4NCA9IG5ldyBNYXRyaXg0eDQoKTtcclxuICAgICAgY29uc3QgbXR4UmVzdWx0OiBNYXRyaXg0eDQgPSBSZWN5Y2xlci5nZXQoTWF0cml4NHg0KTtcclxuICAgICAgbGV0IGEwMDogbnVtYmVyID0gYVswICogNCArIDBdO1xyXG4gICAgICBsZXQgYTAxOiBudW1iZXIgPSBhWzAgKiA0ICsgMV07XHJcbiAgICAgIGxldCBhMDI6IG51bWJlciA9IGFbMCAqIDQgKyAyXTtcclxuICAgICAgbGV0IGEwMzogbnVtYmVyID0gYVswICogNCArIDNdO1xyXG4gICAgICBsZXQgYTEwOiBudW1iZXIgPSBhWzEgKiA0ICsgMF07XHJcbiAgICAgIGxldCBhMTE6IG51bWJlciA9IGFbMSAqIDQgKyAxXTtcclxuICAgICAgbGV0IGExMjogbnVtYmVyID0gYVsxICogNCArIDJdO1xyXG4gICAgICBsZXQgYTEzOiBudW1iZXIgPSBhWzEgKiA0ICsgM107XHJcbiAgICAgIGxldCBhMjA6IG51bWJlciA9IGFbMiAqIDQgKyAwXTtcclxuICAgICAgbGV0IGEyMTogbnVtYmVyID0gYVsyICogNCArIDFdO1xyXG4gICAgICBsZXQgYTIyOiBudW1iZXIgPSBhWzIgKiA0ICsgMl07XHJcbiAgICAgIGxldCBhMjM6IG51bWJlciA9IGFbMiAqIDQgKyAzXTtcclxuICAgICAgbGV0IGEzMDogbnVtYmVyID0gYVszICogNCArIDBdO1xyXG4gICAgICBsZXQgYTMxOiBudW1iZXIgPSBhWzMgKiA0ICsgMV07XHJcbiAgICAgIGxldCBhMzI6IG51bWJlciA9IGFbMyAqIDQgKyAyXTtcclxuICAgICAgbGV0IGEzMzogbnVtYmVyID0gYVszICogNCArIDNdO1xyXG4gICAgICBsZXQgYjAwOiBudW1iZXIgPSBiWzAgKiA0ICsgMF07XHJcbiAgICAgIGxldCBiMDE6IG51bWJlciA9IGJbMCAqIDQgKyAxXTtcclxuICAgICAgbGV0IGIwMjogbnVtYmVyID0gYlswICogNCArIDJdO1xyXG4gICAgICBsZXQgYjAzOiBudW1iZXIgPSBiWzAgKiA0ICsgM107XHJcbiAgICAgIGxldCBiMTA6IG51bWJlciA9IGJbMSAqIDQgKyAwXTtcclxuICAgICAgbGV0IGIxMTogbnVtYmVyID0gYlsxICogNCArIDFdO1xyXG4gICAgICBsZXQgYjEyOiBudW1iZXIgPSBiWzEgKiA0ICsgMl07XHJcbiAgICAgIGxldCBiMTM6IG51bWJlciA9IGJbMSAqIDQgKyAzXTtcclxuICAgICAgbGV0IGIyMDogbnVtYmVyID0gYlsyICogNCArIDBdO1xyXG4gICAgICBsZXQgYjIxOiBudW1iZXIgPSBiWzIgKiA0ICsgMV07XHJcbiAgICAgIGxldCBiMjI6IG51bWJlciA9IGJbMiAqIDQgKyAyXTtcclxuICAgICAgbGV0IGIyMzogbnVtYmVyID0gYlsyICogNCArIDNdO1xyXG4gICAgICBsZXQgYjMwOiBudW1iZXIgPSBiWzMgKiA0ICsgMF07XHJcbiAgICAgIGxldCBiMzE6IG51bWJlciA9IGJbMyAqIDQgKyAxXTtcclxuICAgICAgbGV0IGIzMjogbnVtYmVyID0gYlszICogNCArIDJdO1xyXG4gICAgICBsZXQgYjMzOiBudW1iZXIgPSBiWzMgKiA0ICsgM107XHJcbiAgICAgIG10eFJlc3VsdC5kYXRhLnNldChcclxuICAgICAgICBbXHJcbiAgICAgICAgICBiMDAgKiBhMDAgKyBiMDEgKiBhMTAgKyBiMDIgKiBhMjAgKyBiMDMgKiBhMzAsXHJcbiAgICAgICAgICBiMDAgKiBhMDEgKyBiMDEgKiBhMTEgKyBiMDIgKiBhMjEgKyBiMDMgKiBhMzEsXHJcbiAgICAgICAgICBiMDAgKiBhMDIgKyBiMDEgKiBhMTIgKyBiMDIgKiBhMjIgKyBiMDMgKiBhMzIsXHJcbiAgICAgICAgICBiMDAgKiBhMDMgKyBiMDEgKiBhMTMgKyBiMDIgKiBhMjMgKyBiMDMgKiBhMzMsXHJcbiAgICAgICAgICBiMTAgKiBhMDAgKyBiMTEgKiBhMTAgKyBiMTIgKiBhMjAgKyBiMTMgKiBhMzAsXHJcbiAgICAgICAgICBiMTAgKiBhMDEgKyBiMTEgKiBhMTEgKyBiMTIgKiBhMjEgKyBiMTMgKiBhMzEsXHJcbiAgICAgICAgICBiMTAgKiBhMDIgKyBiMTEgKiBhMTIgKyBiMTIgKiBhMjIgKyBiMTMgKiBhMzIsXHJcbiAgICAgICAgICBiMTAgKiBhMDMgKyBiMTEgKiBhMTMgKyBiMTIgKiBhMjMgKyBiMTMgKiBhMzMsXHJcbiAgICAgICAgICBiMjAgKiBhMDAgKyBiMjEgKiBhMTAgKyBiMjIgKiBhMjAgKyBiMjMgKiBhMzAsXHJcbiAgICAgICAgICBiMjAgKiBhMDEgKyBiMjEgKiBhMTEgKyBiMjIgKiBhMjEgKyBiMjMgKiBhMzEsXHJcbiAgICAgICAgICBiMjAgKiBhMDIgKyBiMjEgKiBhMTIgKyBiMjIgKiBhMjIgKyBiMjMgKiBhMzIsXHJcbiAgICAgICAgICBiMjAgKiBhMDMgKyBiMjEgKiBhMTMgKyBiMjIgKiBhMjMgKyBiMjMgKiBhMzMsXHJcbiAgICAgICAgICBiMzAgKiBhMDAgKyBiMzEgKiBhMTAgKyBiMzIgKiBhMjAgKyBiMzMgKiBhMzAsXHJcbiAgICAgICAgICBiMzAgKiBhMDEgKyBiMzEgKiBhMTEgKyBiMzIgKiBhMjEgKyBiMzMgKiBhMzEsXHJcbiAgICAgICAgICBiMzAgKiBhMDIgKyBiMzEgKiBhMTIgKyBiMzIgKiBhMjIgKyBiMzMgKiBhMzIsXHJcbiAgICAgICAgICBiMzAgKiBhMDMgKyBiMzEgKiBhMTMgKyBiMzIgKiBhMjMgKyBiMzMgKiBhMzNcclxuICAgICAgICBdKTtcclxuICAgICAgcmV0dXJuIG10eFJlc3VsdDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBhbmQgcmV0dXJucyB0aGUgdHJhbnNwb3NlIG9mIGEgcGFzc2VkIG1hdHJpeC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBUUkFOU1BPU0UoX210eDogTWF0cml4NHg0KTogTWF0cml4NHg0IHtcclxuICAgICAgbGV0IG06IEZsb2F0MzJBcnJheSA9IF9tdHguZGF0YTtcclxuICAgICAgbGV0IHJlc3VsdDogTWF0cml4NHg0ID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDR4NCk7XHJcbiAgICAgIHJlc3VsdC5kYXRhLnNldChbXHJcbiAgICAgICAgbVswXSwgbVs0XSwgbVs4XSwgbVsxMl0sXHJcbiAgICAgICAgbVsxXSwgbVs1XSwgbVs5XSwgbVsxM10sXHJcbiAgICAgICAgbVsyXSwgbVs2XSwgbVsxMF0sIG1bMTRdLFxyXG4gICAgICAgIG1bM10sIG1bN10sIG1bMTFdLCBtWzE1XVxyXG4gICAgICBdKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIGFuZCByZXR1cm5zIHRoZSBpbnZlcnNlIG9mIGEgcGFzc2VkIG1hdHJpeC5cclxuICAgICAqIEBwYXJhbSBfbXR4IFRoZSBtYXRyaXggdG8gY29tcHV0ZSB0aGUgaW52ZXJzZSBvZi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBJTlZFUlNJT04oX210eDogTWF0cml4NHg0KTogTWF0cml4NHg0IHtcclxuICAgICAgbGV0IG06IEZsb2F0MzJBcnJheSA9IF9tdHguZGF0YTtcclxuICAgICAgbGV0IG0wMDogbnVtYmVyID0gbVswICogNCArIDBdO1xyXG4gICAgICBsZXQgbTAxOiBudW1iZXIgPSBtWzAgKiA0ICsgMV07XHJcbiAgICAgIGxldCBtMDI6IG51bWJlciA9IG1bMCAqIDQgKyAyXTtcclxuICAgICAgbGV0IG0wMzogbnVtYmVyID0gbVswICogNCArIDNdO1xyXG4gICAgICBsZXQgbTEwOiBudW1iZXIgPSBtWzEgKiA0ICsgMF07XHJcbiAgICAgIGxldCBtMTE6IG51bWJlciA9IG1bMSAqIDQgKyAxXTtcclxuICAgICAgbGV0IG0xMjogbnVtYmVyID0gbVsxICogNCArIDJdO1xyXG4gICAgICBsZXQgbTEzOiBudW1iZXIgPSBtWzEgKiA0ICsgM107XHJcbiAgICAgIGxldCBtMjA6IG51bWJlciA9IG1bMiAqIDQgKyAwXTtcclxuICAgICAgbGV0IG0yMTogbnVtYmVyID0gbVsyICogNCArIDFdO1xyXG4gICAgICBsZXQgbTIyOiBudW1iZXIgPSBtWzIgKiA0ICsgMl07XHJcbiAgICAgIGxldCBtMjM6IG51bWJlciA9IG1bMiAqIDQgKyAzXTtcclxuICAgICAgbGV0IG0zMDogbnVtYmVyID0gbVszICogNCArIDBdO1xyXG4gICAgICBsZXQgbTMxOiBudW1iZXIgPSBtWzMgKiA0ICsgMV07XHJcbiAgICAgIGxldCBtMzI6IG51bWJlciA9IG1bMyAqIDQgKyAyXTtcclxuICAgICAgbGV0IG0zMzogbnVtYmVyID0gbVszICogNCArIDNdO1xyXG4gICAgICBsZXQgdG1wMDogbnVtYmVyID0gbTIyICogbTMzO1xyXG4gICAgICBsZXQgdG1wMTogbnVtYmVyID0gbTMyICogbTIzO1xyXG4gICAgICBsZXQgdG1wMjogbnVtYmVyID0gbTEyICogbTMzO1xyXG4gICAgICBsZXQgdG1wMzogbnVtYmVyID0gbTMyICogbTEzO1xyXG4gICAgICBsZXQgdG1wNDogbnVtYmVyID0gbTEyICogbTIzO1xyXG4gICAgICBsZXQgdG1wNTogbnVtYmVyID0gbTIyICogbTEzO1xyXG4gICAgICBsZXQgdG1wNjogbnVtYmVyID0gbTAyICogbTMzO1xyXG4gICAgICBsZXQgdG1wNzogbnVtYmVyID0gbTMyICogbTAzO1xyXG4gICAgICBsZXQgdG1wODogbnVtYmVyID0gbTAyICogbTIzO1xyXG4gICAgICBsZXQgdG1wOTogbnVtYmVyID0gbTIyICogbTAzO1xyXG4gICAgICBsZXQgdG1wMTA6IG51bWJlciA9IG0wMiAqIG0xMztcclxuICAgICAgbGV0IHRtcDExOiBudW1iZXIgPSBtMTIgKiBtMDM7XHJcbiAgICAgIGxldCB0bXAxMjogbnVtYmVyID0gbTIwICogbTMxO1xyXG4gICAgICBsZXQgdG1wMTM6IG51bWJlciA9IG0zMCAqIG0yMTtcclxuICAgICAgbGV0IHRtcDE0OiBudW1iZXIgPSBtMTAgKiBtMzE7XHJcbiAgICAgIGxldCB0bXAxNTogbnVtYmVyID0gbTMwICogbTExO1xyXG4gICAgICBsZXQgdG1wMTY6IG51bWJlciA9IG0xMCAqIG0yMTtcclxuICAgICAgbGV0IHRtcDE3OiBudW1iZXIgPSBtMjAgKiBtMTE7XHJcbiAgICAgIGxldCB0bXAxODogbnVtYmVyID0gbTAwICogbTMxO1xyXG4gICAgICBsZXQgdG1wMTk6IG51bWJlciA9IG0zMCAqIG0wMTtcclxuICAgICAgbGV0IHRtcDIwOiBudW1iZXIgPSBtMDAgKiBtMjE7XHJcbiAgICAgIGxldCB0bXAyMTogbnVtYmVyID0gbTIwICogbTAxO1xyXG4gICAgICBsZXQgdG1wMjI6IG51bWJlciA9IG0wMCAqIG0xMTtcclxuICAgICAgbGV0IHRtcDIzOiBudW1iZXIgPSBtMTAgKiBtMDE7XHJcblxyXG4gICAgICBsZXQgdDA6IG51bWJlciA9ICh0bXAwICogbTExICsgdG1wMyAqIG0yMSArIHRtcDQgKiBtMzEpIC1cclxuICAgICAgICAodG1wMSAqIG0xMSArIHRtcDIgKiBtMjEgKyB0bXA1ICogbTMxKTtcclxuXHJcbiAgICAgIGxldCB0MTogbnVtYmVyID0gKHRtcDEgKiBtMDEgKyB0bXA2ICogbTIxICsgdG1wOSAqIG0zMSkgLVxyXG4gICAgICAgICh0bXAwICogbTAxICsgdG1wNyAqIG0yMSArIHRtcDggKiBtMzEpO1xyXG4gICAgICBsZXQgdDI6IG51bWJlciA9ICh0bXAyICogbTAxICsgdG1wNyAqIG0xMSArIHRtcDEwICogbTMxKSAtXHJcbiAgICAgICAgKHRtcDMgKiBtMDEgKyB0bXA2ICogbTExICsgdG1wMTEgKiBtMzEpO1xyXG4gICAgICBsZXQgdDM6IG51bWJlciA9ICh0bXA1ICogbTAxICsgdG1wOCAqIG0xMSArIHRtcDExICogbTIxKSAtXHJcbiAgICAgICAgKHRtcDQgKiBtMDEgKyB0bXA5ICogbTExICsgdG1wMTAgKiBtMjEpO1xyXG5cclxuICAgICAgbGV0IGQ6IG51bWJlciA9IDEuMCAvIChtMDAgKiB0MCArIG0xMCAqIHQxICsgbTIwICogdDIgKyBtMzAgKiB0Myk7XHJcblxyXG4gICAgICBjb25zdCBtdHhSZXN1bHQ6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLmdldChNYXRyaXg0eDQpO1xyXG4gICAgICBtdHhSZXN1bHQuZGF0YS5zZXQoW1xyXG4gICAgICAgIGQgKiB0MCwgLy8gWzBdXHJcbiAgICAgICAgZCAqIHQxLCAvLyBbMV1cclxuICAgICAgICBkICogdDIsIC8vIFsyXVxyXG4gICAgICAgIGQgKiB0MywgLy8gWzNdXHJcbiAgICAgICAgZCAqICgodG1wMSAqIG0xMCArIHRtcDIgKiBtMjAgKyB0bXA1ICogbTMwKSAtICh0bXAwICogbTEwICsgdG1wMyAqIG0yMCArIHRtcDQgKiBtMzApKSwgICAgICAgIC8vIFs0XVxyXG4gICAgICAgIGQgKiAoKHRtcDAgKiBtMDAgKyB0bXA3ICogbTIwICsgdG1wOCAqIG0zMCkgLSAodG1wMSAqIG0wMCArIHRtcDYgKiBtMjAgKyB0bXA5ICogbTMwKSksICAgICAgICAvLyBbNV1cclxuICAgICAgICBkICogKCh0bXAzICogbTAwICsgdG1wNiAqIG0xMCArIHRtcDExICogbTMwKSAtICh0bXAyICogbTAwICsgdG1wNyAqIG0xMCArIHRtcDEwICogbTMwKSksICAgICAgLy8gWzZdXHJcbiAgICAgICAgZCAqICgodG1wNCAqIG0wMCArIHRtcDkgKiBtMTAgKyB0bXAxMCAqIG0yMCkgLSAodG1wNSAqIG0wMCArIHRtcDggKiBtMTAgKyB0bXAxMSAqIG0yMCkpLCAgICAgIC8vIFs3XVxyXG4gICAgICAgIGQgKiAoKHRtcDEyICogbTEzICsgdG1wMTUgKiBtMjMgKyB0bXAxNiAqIG0zMykgLSAodG1wMTMgKiBtMTMgKyB0bXAxNCAqIG0yMyArIHRtcDE3ICogbTMzKSksICAvLyBbOF1cclxuICAgICAgICBkICogKCh0bXAxMyAqIG0wMyArIHRtcDE4ICogbTIzICsgdG1wMjEgKiBtMzMpIC0gKHRtcDEyICogbTAzICsgdG1wMTkgKiBtMjMgKyB0bXAyMCAqIG0zMykpLCAgLy8gWzldXHJcbiAgICAgICAgZCAqICgodG1wMTQgKiBtMDMgKyB0bXAxOSAqIG0xMyArIHRtcDIyICogbTMzKSAtICh0bXAxNSAqIG0wMyArIHRtcDE4ICogbTEzICsgdG1wMjMgKiBtMzMpKSwgIC8vIFsxMF1cclxuICAgICAgICBkICogKCh0bXAxNyAqIG0wMyArIHRtcDIwICogbTEzICsgdG1wMjMgKiBtMjMpIC0gKHRtcDE2ICogbTAzICsgdG1wMjEgKiBtMTMgKyB0bXAyMiAqIG0yMykpLCAgLy8gWzExXVxyXG4gICAgICAgIGQgKiAoKHRtcDE0ICogbTIyICsgdG1wMTcgKiBtMzIgKyB0bXAxMyAqIG0xMikgLSAodG1wMTYgKiBtMzIgKyB0bXAxMiAqIG0xMiArIHRtcDE1ICogbTIyKSksICAvLyBbMTJdXHJcbiAgICAgICAgZCAqICgodG1wMjAgKiBtMzIgKyB0bXAxMiAqIG0wMiArIHRtcDE5ICogbTIyKSAtICh0bXAxOCAqIG0yMiArIHRtcDIxICogbTMyICsgdG1wMTMgKiBtMDIpKSwgIC8vIFsxM11cclxuICAgICAgICBkICogKCh0bXAxOCAqIG0xMiArIHRtcDIzICogbTMyICsgdG1wMTUgKiBtMDIpIC0gKHRtcDIyICogbTMyICsgdG1wMTQgKiBtMDIgKyB0bXAxOSAqIG0xMikpLCAgLy8gWzE0XVxyXG4gICAgICAgIGQgKiAoKHRtcDIyICogbTIyICsgdG1wMTYgKiBtMDIgKyB0bXAyMSAqIG0xMikgLSAodG1wMjAgKiBtMTIgKyB0bXAyMyAqIG0yMiArIHRtcDE3ICogbTAyKSkgIC8vIFsxNV1cclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiBtdHhSZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBhbmQgcmV0dXJucyBhIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiB0cmFuc2xhdGlvbiwgaXRzIHotYXhpcyBwb2ludGluZyBkaXJlY3RseSBhdCB0aGUgZ2l2ZW4gdGFyZ2V0LFxyXG4gICAgICogYW5kIGEgbWluaW1hbCBhbmdsZSBiZXR3ZWVuIGl0cyB5LWF4aXMgYW5kIHRoZSBnaXZlbiB1cC17QGxpbmsgVmVjdG9yM30sIHJlc3BldGl2ZWx5IGNhbGN1bGF0aW5nIHlhdyBhbmQgcGl0Y2guXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgTE9PS19BVChfdHJhbnNsYXRpb246IFZlY3RvcjMsIF90YXJnZXQ6IFZlY3RvcjMsIF91cDogVmVjdG9yMyA9IFZlY3RvcjMuWSgpKTogTWF0cml4NHg0IHtcclxuICAgICAgY29uc3QgbXR4UmVzdWx0OiBNYXRyaXg0eDQgPSBSZWN5Y2xlci5nZXQoTWF0cml4NHg0KTtcclxuICAgICAgbGV0IHpBeGlzOiBWZWN0b3IzID0gVmVjdG9yMy5ESUZGRVJFTkNFKF90YXJnZXQsIF90cmFuc2xhdGlvbik7XHJcbiAgICAgIHpBeGlzLm5vcm1hbGl6ZSgpO1xyXG4gICAgICBsZXQgeEF4aXM6IFZlY3RvcjMgPSBWZWN0b3IzLk5PUk1BTElaQVRJT04oVmVjdG9yMy5DUk9TUyhfdXAsIHpBeGlzKSk7XHJcbiAgICAgIGxldCB5QXhpczogVmVjdG9yMyA9IFZlY3RvcjMuTk9STUFMSVpBVElPTihWZWN0b3IzLkNST1NTKHpBeGlzLCB4QXhpcykpO1xyXG4gICAgICBtdHhSZXN1bHQuZGF0YS5zZXQoXHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgeEF4aXMueCwgeEF4aXMueSwgeEF4aXMueiwgMCxcclxuICAgICAgICAgIHlBeGlzLngsIHlBeGlzLnksIHlBeGlzLnosIDAsXHJcbiAgICAgICAgICB6QXhpcy54LCB6QXhpcy55LCB6QXhpcy56LCAwLFxyXG4gICAgICAgICAgX3RyYW5zbGF0aW9uLngsXHJcbiAgICAgICAgICBfdHJhbnNsYXRpb24ueSxcclxuICAgICAgICAgIF90cmFuc2xhdGlvbi56LFxyXG4gICAgICAgICAgMVxyXG4gICAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gbXR4UmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgYW5kIHJldHVybnMgYSBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gdHJhbnNsYXRpb24sIGl0cyB5LWF4aXMgbWF0Y2hpbmcgdGhlIGdpdmVuIHVwLXtAbGluayBWZWN0b3IzfVxyXG4gICAgICogYW5kIGl0cyB6LWF4aXMgZmFjaW5nIHRvd2FyZHMgdGhlIGdpdmVuIHRhcmdldCBhdCBhIG1pbmltYWwgYW5nbGUsIHJlc3BldGl2ZWx5IGNhbGN1bGF0aW5nIHlhdyBvbmx5LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFNIT1dfVE8oX3RyYW5zbGF0aW9uOiBWZWN0b3IzLCBfdGFyZ2V0OiBWZWN0b3IzLCBfdXA6IFZlY3RvcjMgPSBWZWN0b3IzLlkoKSk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIGNvbnN0IG10eFJlc3VsdDogTWF0cml4NHg0ID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDR4NCk7XHJcbiAgICAgIGxldCB6QXhpczogVmVjdG9yMyA9IFZlY3RvcjMuRElGRkVSRU5DRShfdGFyZ2V0LCBfdHJhbnNsYXRpb24pO1xyXG4gICAgICB6QXhpcy5ub3JtYWxpemUoKTtcclxuICAgICAgbGV0IHhBeGlzOiBWZWN0b3IzID0gVmVjdG9yMy5OT1JNQUxJWkFUSU9OKFZlY3RvcjMuQ1JPU1MoX3VwLCB6QXhpcykpO1xyXG4gICAgICAvLyBsZXQgeUF4aXM6IFZlY3RvcjMgPSBWZWN0b3IzLk5PUk1BTElaQVRJT04oVmVjdG9yMy5DUk9TUyh6QXhpcywgeEF4aXMpKTtcclxuICAgICAgekF4aXMgPSBWZWN0b3IzLk5PUk1BTElaQVRJT04oVmVjdG9yMy5DUk9TUyh4QXhpcywgX3VwKSk7XHJcbiAgICAgIG10eFJlc3VsdC5kYXRhLnNldChcclxuICAgICAgICBbXHJcbiAgICAgICAgICB4QXhpcy54LCB4QXhpcy55LCB4QXhpcy56LCAwLFxyXG4gICAgICAgICAgX3VwLngsIF91cC55LCBfdXAueiwgMCxcclxuICAgICAgICAgIHpBeGlzLngsIHpBeGlzLnksIHpBeGlzLnosIDAsXHJcbiAgICAgICAgICBfdHJhbnNsYXRpb24ueCxcclxuICAgICAgICAgIF90cmFuc2xhdGlvbi55LFxyXG4gICAgICAgICAgX3RyYW5zbGF0aW9uLnosXHJcbiAgICAgICAgICAxXHJcbiAgICAgICAgXSk7XHJcbiAgICAgIHJldHVybiBtdHhSZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbWF0cml4IHRoYXQgdHJhbnNsYXRlcyBjb29yZGluYXRlcyBhbG9uZyB0aGUgeC0sIHktIGFuZCB6LWF4aXMgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiB7QGxpbmsgVmVjdG9yM30uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgVFJBTlNMQVRJT04oX3RyYW5zbGF0ZTogVmVjdG9yMyk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIGNvbnN0IG10eFJlc3VsdDogTWF0cml4NHg0ID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDR4NCk7XHJcbiAgICAgIG10eFJlc3VsdC5kYXRhLnNldChbXHJcbiAgICAgICAgMSwgMCwgMCwgMCxcclxuICAgICAgICAwLCAxLCAwLCAwLFxyXG4gICAgICAgIDAsIDAsIDEsIDAsXHJcbiAgICAgICAgX3RyYW5zbGF0ZS54LCBfdHJhbnNsYXRlLnksIF90cmFuc2xhdGUueiwgMVxyXG4gICAgICBdKTtcclxuICAgICAgcmV0dXJuIG10eFJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBtYXRyaXggdGhhdCByb3RhdGVzIGNvb3JkaW5hdGVzIG9uIHRoZSB4LWF4aXMgd2hlbiBtdWx0aXBsaWVkIGJ5LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFJPVEFUSU9OX1goX2FuZ2xlSW5EZWdyZWVzOiBudW1iZXIpOiBNYXRyaXg0eDQge1xyXG4gICAgICBjb25zdCBtdHhSZXN1bHQ6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLmdldChNYXRyaXg0eDQpO1xyXG4gICAgICBsZXQgYW5nbGVJblJhZGlhbnM6IG51bWJlciA9IF9hbmdsZUluRGVncmVlcyAqIE1hdHJpeDR4NC5kZWcycmFkO1xyXG4gICAgICBsZXQgc2luOiBudW1iZXIgPSBNYXRoLnNpbihhbmdsZUluUmFkaWFucyk7XHJcbiAgICAgIGxldCBjb3M6IG51bWJlciA9IE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKTtcclxuICAgICAgbXR4UmVzdWx0LmRhdGEuc2V0KFtcclxuICAgICAgICAxLCAwLCAwLCAwLFxyXG4gICAgICAgIDAsIGNvcywgc2luLCAwLFxyXG4gICAgICAgIDAsIC1zaW4sIGNvcywgMCxcclxuICAgICAgICAwLCAwLCAwLCAxXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gbXR4UmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG1hdHJpeCB0aGF0IHJvdGF0ZXMgY29vcmRpbmF0ZXMgb24gdGhlIHktYXhpcyB3aGVuIG11bHRpcGxpZWQgYnkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgUk9UQVRJT05fWShfYW5nbGVJbkRlZ3JlZXM6IG51bWJlcik6IE1hdHJpeDR4NCB7XHJcbiAgICAgIGxldCBtdHhSZXN1bHQ6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLmdldChNYXRyaXg0eDQpO1xyXG4gICAgICBsZXQgYW5nbGVJblJhZGlhbnM6IG51bWJlciA9IF9hbmdsZUluRGVncmVlcyAqIE1hdHJpeDR4NC5kZWcycmFkO1xyXG4gICAgICBsZXQgc2luOiBudW1iZXIgPSBNYXRoLnNpbihhbmdsZUluUmFkaWFucyk7XHJcbiAgICAgIGxldCBjb3M6IG51bWJlciA9IE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKTtcclxuICAgICAgbXR4UmVzdWx0LmRhdGEuc2V0KFtcclxuICAgICAgICBjb3MsIDAsIC1zaW4sIDAsXHJcbiAgICAgICAgMCwgMSwgMCwgMCxcclxuICAgICAgICBzaW4sIDAsIGNvcywgMCxcclxuICAgICAgICAwLCAwLCAwLCAxXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gbXR4UmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG1hdHJpeCB0aGF0IHJvdGF0ZXMgY29vcmRpbmF0ZXMgb24gdGhlIHotYXhpcyB3aGVuIG11bHRpcGxpZWQgYnkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgUk9UQVRJT05fWihfYW5nbGVJbkRlZ3JlZXM6IG51bWJlcik6IE1hdHJpeDR4NCB7XHJcbiAgICAgIGNvbnN0IG10eFJlc3VsdDogTWF0cml4NHg0ID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDR4NCk7XHJcbiAgICAgIGxldCBhbmdsZUluUmFkaWFuczogbnVtYmVyID0gX2FuZ2xlSW5EZWdyZWVzICogTWF0cml4NHg0LmRlZzJyYWQ7XHJcbiAgICAgIGxldCBzaW46IG51bWJlciA9IE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKTtcclxuICAgICAgbGV0IGNvczogbnVtYmVyID0gTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpO1xyXG4gICAgICBtdHhSZXN1bHQuZGF0YS5zZXQoW1xyXG4gICAgICAgIGNvcywgc2luLCAwLCAwLFxyXG4gICAgICAgIC1zaW4sIGNvcywgMCwgMCxcclxuICAgICAgICAwLCAwLCAxLCAwLFxyXG4gICAgICAgIDAsIDAsIDAsIDFcclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiBtdHhSZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbWF0cml4IHRoYXQgcm90YXRlcyBjb29yZGluYXRlcyB3aGVuIG11bHRpcGxpZWQgYnksIHVzaW5nIHRoZSBhbmdsZXMgZ2l2ZW4uXHJcbiAgICAgKiBSb3RhdGlvbiBvY2N1cnMgYXJvdW5kIHRoZSBheGlzIGluIHRoZSBvcmRlciBaLVktWCAuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgUk9UQVRJT04oX2V1bGVyQW5nbGVzSW5EZWdyZWVzOiBWZWN0b3IzKTogTWF0cml4NHg0IHtcclxuICAgICAgY29uc3QgbXR4UmVzdWx0OiBNYXRyaXg0eDQgPSBSZWN5Y2xlci5nZXQoTWF0cml4NHg0KTtcclxuICAgICAgbGV0IGFuZ2xlc0luUmFkaWFuczogVmVjdG9yMyA9IFZlY3RvcjMuU0NBTEUoX2V1bGVyQW5nbGVzSW5EZWdyZWVzLCBNYXRyaXg0eDQuZGVnMnJhZCk7XHJcbiAgICAgIGxldCBzaW5YOiBudW1iZXIgPSBNYXRoLnNpbihhbmdsZXNJblJhZGlhbnMueCk7XHJcbiAgICAgIGxldCBjb3NYOiBudW1iZXIgPSBNYXRoLmNvcyhhbmdsZXNJblJhZGlhbnMueCk7XHJcbiAgICAgIGxldCBzaW5ZOiBudW1iZXIgPSBNYXRoLnNpbihhbmdsZXNJblJhZGlhbnMueSk7XHJcbiAgICAgIGxldCBjb3NZOiBudW1iZXIgPSBNYXRoLmNvcyhhbmdsZXNJblJhZGlhbnMueSk7XHJcbiAgICAgIGxldCBzaW5aOiBudW1iZXIgPSBNYXRoLnNpbihhbmdsZXNJblJhZGlhbnMueik7XHJcbiAgICAgIGxldCBjb3NaOiBudW1iZXIgPSBNYXRoLmNvcyhhbmdsZXNJblJhZGlhbnMueik7XHJcbiAgICAgIG10eFJlc3VsdC5kYXRhLnNldChbXHJcbiAgICAgICAgLyoqLyAgICAgICAgICAgICAgICAgY29zWiAqIGNvc1ksIC8qKi8gICAgICAgICAgICAgICAgIHNpblogKiBjb3NZLCAvKiovICAgICAgIC1zaW5ZLCAwLFxyXG4gICAgICAgIGNvc1ogKiBzaW5ZICogc2luWCAtIHNpblogKiBjb3NYLCBzaW5aICogc2luWSAqIHNpblggKyBjb3NaICogY29zWCwgLyoqLyBjb3NZICogc2luWCwgMCxcclxuICAgICAgICBjb3NaICogc2luWSAqIGNvc1ggKyBzaW5aICogc2luWCwgc2luWiAqIHNpblkgKiBjb3NYIC0gY29zWiAqIHNpblgsIC8qKi8gY29zWSAqIGNvc1gsIDAsXHJcbiAgICAgICAgMCwgMCwgMCwgMVxyXG4gICAgICBdKTtcclxuICAgICAgcmV0dXJuIG10eFJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBtYXRyaXggdGhhdCBzY2FsZXMgY29vcmRpbmF0ZXMgYWxvbmcgdGhlIHgtLCB5LSBhbmQgei1heGlzIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4ge0BsaW5rIFZlY3RvcjN9XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgU0NBTElORyhfc2NhbGFyOiBWZWN0b3IzKTogTWF0cml4NHg0IHtcclxuICAgICAgY29uc3QgbXR4UmVzdWx0OiBNYXRyaXg0eDQgPSBSZWN5Y2xlci5nZXQoTWF0cml4NHg0KTtcclxuICAgICAgbXR4UmVzdWx0LmRhdGEuc2V0KFtcclxuICAgICAgICBfc2NhbGFyLngsIDAsIDAsIDAsXHJcbiAgICAgICAgMCwgX3NjYWxhci55LCAwLCAwLFxyXG4gICAgICAgIDAsIDAsIF9zY2FsYXIueiwgMCxcclxuICAgICAgICAwLCAwLCAwLCAxXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gbXR4UmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBtYXRyaXggcmVsYXRpdmUgdG8gdGhlIGdpdmVuIGJhc2UuXHJcbiAgICAgKiBJZiBrbm93biwgcGFzcyB0aGUgaW52ZXJzZSBvZiB0aGUgYmFzZSB0byBhdm9pZCB1bm5lY2Nlc2FyeSBjYWxjdWxhdGlvbiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBSRUxBVElWRShfbXR4OiBNYXRyaXg0eDQsIF9tdHhCYXNlOiBNYXRyaXg0eDQsIF9tdHhJbnZlcnNlPzogTWF0cml4NHg0KTogTWF0cml4NHg0IHtcclxuICAgICAgaWYgKF9tdHhJbnZlcnNlKVxyXG4gICAgICAgcmV0dXJuIE1hdHJpeDR4NC5NVUxUSVBMSUNBVElPTihfbXR4SW52ZXJzZSwgX210eCk7XHJcblxyXG4gICAgICBsZXQgbXR4SW52ZXJzZTogTWF0cml4NHg0ID0gTWF0cml4NHg0LklOVkVSU0lPTihfbXR4QmFzZSk7XHJcbiAgICAgIGxldCBtdHhSZXN1bHQ6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5NVUxUSVBMSUNBVElPTihtdHhJbnZlcnNlLCBfbXR4KTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUobXR4SW52ZXJzZSk7XHJcbiAgICAgIHJldHVybiBtdHhSZXN1bHQ7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gUFJPSkVDVElPTlNcclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgYW5kIHJldHVybnMgYSBtYXRyaXggdGhhdCBhcHBsaWVzIHBlcnNwZWN0aXZlIHRvIGFuIG9iamVjdCwgaWYgaXRzIHRyYW5zZm9ybSBpcyBtdWx0aXBsaWVkIGJ5IGl0LlxyXG4gICAgICogQHBhcmFtIF9hc3BlY3QgVGhlIGFzcGVjdCByYXRpbyBiZXR3ZWVuIHdpZHRoIGFuZCBoZWlnaHQgb2YgcHJvamVjdGlvbnNwYWNlLihEZWZhdWx0ID0gY2FudmFzLmNsaWVudFdpZHRoIC8gY2FudmFzLkNsaWVudEhlaWdodClcclxuICAgICAqIEBwYXJhbSBfZmllbGRPZlZpZXdJbkRlZ3JlZXMgVGhlIGZpZWxkIG9mIHZpZXcgaW4gRGVncmVlcy4gKERlZmF1bHQgPSA0NSlcclxuICAgICAqIEBwYXJhbSBfbmVhciBUaGUgbmVhciBjbGlwc3BhY2UgYm9yZGVyIG9uIHRoZSB6LWF4aXMuXHJcbiAgICAgKiBAcGFyYW0gX2ZhciBUaGUgZmFyIGNsaXBzcGFjZSBib3JkZXIgb24gdGhlIHotYXhpcy5cclxuICAgICAqIEBwYXJhbSBfZGlyZWN0aW9uIFRoZSBwbGFuZSBvbiB3aGljaCB0aGUgZmllbGRPZlZpZXctQW5nbGUgaXMgZ2l2ZW4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgUFJPSkVDVElPTl9DRU5UUkFMKF9hc3BlY3Q6IG51bWJlciwgX2ZpZWxkT2ZWaWV3SW5EZWdyZWVzOiBudW1iZXIsIF9uZWFyOiBudW1iZXIsIF9mYXI6IG51bWJlciwgX2RpcmVjdGlvbjogRklFTERfT0ZfVklFVyk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIC8vVE9ETzogY2FtZXJhIGxvb2tzIGRvd24gbmVnYXRpdmUgei1kaXJlY3Rpb24sIHNob3VsZCBiZSBwb3NpdGl2ZVxyXG4gICAgICBsZXQgZmllbGRPZlZpZXdJblJhZGlhbnM6IG51bWJlciA9IF9maWVsZE9mVmlld0luRGVncmVlcyAqIE1hdHJpeDR4NC5kZWcycmFkO1xyXG4gICAgICBsZXQgZjogbnVtYmVyID0gTWF0aC50YW4oMC41ICogKE1hdGguUEkgLSBmaWVsZE9mVmlld0luUmFkaWFucykpO1xyXG4gICAgICBsZXQgcmFuZ2VJbnY6IG51bWJlciA9IDEuMCAvIChfbmVhciAtIF9mYXIpO1xyXG4gICAgICBjb25zdCBtdHhSZXN1bHQ6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLmdldChNYXRyaXg0eDQpO1xyXG4gICAgICBtdHhSZXN1bHQuZGF0YS5zZXQoW1xyXG4gICAgICAgIGYsIDAsIDAsIDAsXHJcbiAgICAgICAgMCwgZiwgMCwgMCxcclxuICAgICAgICAwLCAwLCAoX25lYXIgKyBfZmFyKSAqIHJhbmdlSW52LCAtMSxcclxuICAgICAgICAwLCAwLCBfbmVhciAqIF9mYXIgKiByYW5nZUludiAqIDIsIDBcclxuICAgICAgXSk7XHJcblxyXG4gICAgICBpZiAoX2RpcmVjdGlvbiA9PSBGSUVMRF9PRl9WSUVXLkRJQUdPTkFMKSB7XHJcbiAgICAgICAgX2FzcGVjdCA9IE1hdGguc3FydChfYXNwZWN0KTtcclxuICAgICAgICBtdHhSZXN1bHQuZGF0YVswXSA9IGYgLyBfYXNwZWN0O1xyXG4gICAgICAgIG10eFJlc3VsdC5kYXRhWzVdID0gZiAqIF9hc3BlY3Q7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoX2RpcmVjdGlvbiA9PSBGSUVMRF9PRl9WSUVXLlZFUlRJQ0FMKVxyXG4gICAgICAgIG10eFJlc3VsdC5kYXRhWzBdID0gZiAvIF9hc3BlY3Q7XHJcbiAgICAgIGVsc2UgLy9GT1ZfRElSRUNUSU9OLkhPUklaT05UQUxcclxuICAgICAgICBtdHhSZXN1bHQuZGF0YVs1XSA9IGYgKiBfYXNwZWN0O1xyXG5cclxuICAgICAgLy8gSEFDSzogbWF0cml4IHNob3VsZCBsb29rIGluIHBvc2l0aXZlIHotZGlyZWN0aW9uLCBwcmVmZXJhYmx5IHRoZSBtYXRyaXggc2hvdWxkIGJlIGNhbGN1bGF0ZWQgbGlrZSB0aGF0IHJpZ2h0IGF3YXlcclxuICAgICAgbXR4UmVzdWx0LnJvdGF0ZVkoMTgwKTtcclxuXHJcbiAgICAgIHJldHVybiBtdHhSZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBhbmQgcmV0dXJucyBhIG1hdHJpeCB0aGF0IGFwcGxpZXMgb3J0aG9ncmFwaGljIHByb2plY3Rpb24gdG8gYW4gb2JqZWN0LCBpZiBpdHMgdHJhbnNmb3JtIGlzIG11bHRpcGxpZWQgYnkgaXQuXHJcbiAgICAgKiBAcGFyYW0gX2xlZnQgVGhlIHBvc2l0aW9udmFsdWUgb2YgdGhlIHByb2plY3Rpb25zcGFjZSdzIGxlZnQgYm9yZGVyLlxyXG4gICAgICogQHBhcmFtIF9yaWdodCBUaGUgcG9zaXRpb252YWx1ZSBvZiB0aGUgcHJvamVjdGlvbnNwYWNlJ3MgcmlnaHQgYm9yZGVyLlxyXG4gICAgICogQHBhcmFtIF9ib3R0b20gVGhlIHBvc2l0aW9udmFsdWUgb2YgdGhlIHByb2plY3Rpb25zcGFjZSdzIGJvdHRvbSBib3JkZXIuXHJcbiAgICAgKiBAcGFyYW0gX3RvcCBUaGUgcG9zaXRpb252YWx1ZSBvZiB0aGUgcHJvamVjdGlvbnNwYWNlJ3MgdG9wIGJvcmRlci5cclxuICAgICAqIEBwYXJhbSBfbmVhciBUaGUgcG9zaXRpb252YWx1ZSBvZiB0aGUgcHJvamVjdGlvbnNwYWNlJ3MgbmVhciBib3JkZXIuXHJcbiAgICAgKiBAcGFyYW0gX2ZhciBUaGUgcG9zaXRpb252YWx1ZSBvZiB0aGUgcHJvamVjdGlvbnNwYWNlJ3MgZmFyIGJvcmRlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFBST0pFQ1RJT05fT1JUSE9HUkFQSElDKF9sZWZ0OiBudW1iZXIsIF9yaWdodDogbnVtYmVyLCBfYm90dG9tOiBudW1iZXIsIF90b3A6IG51bWJlciwgX25lYXI6IG51bWJlciA9IC00MDAsIF9mYXI6IG51bWJlciA9IDQwMCk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIGNvbnN0IG10eFJlc3VsdDogTWF0cml4NHg0ID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDR4NCk7XHJcbiAgICAgIG10eFJlc3VsdC5kYXRhLnNldChbXHJcbiAgICAgICAgMiAvIChfcmlnaHQgLSBfbGVmdCksIDAsIDAsIDAsXHJcbiAgICAgICAgMCwgMiAvIChfdG9wIC0gX2JvdHRvbSksIDAsIDAsXHJcbiAgICAgICAgMCwgMCwgMiAvIChfbmVhciAtIF9mYXIpLCAwLFxyXG4gICAgICAgIChfbGVmdCArIF9yaWdodCkgLyAoX2xlZnQgLSBfcmlnaHQpLFxyXG4gICAgICAgIChfYm90dG9tICsgX3RvcCkgLyAoX2JvdHRvbSAtIF90b3ApLFxyXG4gICAgICAgIChfbmVhciArIF9mYXIpIC8gKF9uZWFyIC0gX2ZhciksXHJcbiAgICAgICAgMVxyXG4gICAgICBdKTtcclxuICAgICAgcmV0dXJuIG10eFJlc3VsdDtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiAgQWNjZXNzb3JzXHJcbiAgICAvKiogXHJcbiAgICAgKiAtIGdldDogcmV0dXJuIGEgdmVjdG9yIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0cmFuc2xhdGlvbiB7QGxpbmsgVmVjdG9yM30uICBcclxuICAgICAqICoqQ2F1dGlvbiEqKiBVc2UgaW1tZWRpYXRlbHkgYW5kIHJlYWRvbmx5LCBzaW5jZSB0aGUgdmVjdG9yIGlzIGdvaW5nIHRvIGJlIHJldXNlZCBieSBSZWN5Y2xlci4gQ3JlYXRlIGEgY2xvbmUgdG8ga2VlcCBsb25nZXIgYW5kIG1hbmlwdWxhdGUuIFxyXG4gICAgICogLSBzZXQ6IGVmZmVjdCB0aGUgbWF0cml4IGlnbm9yaW5nIGl0cyByb3RhdGlvbiBhbmQgc2NhbGluZ1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0IHRyYW5zbGF0aW9uKF90cmFuc2xhdGlvbjogVmVjdG9yMykge1xyXG4gICAgICB0aGlzLmRhdGEuc2V0KF90cmFuc2xhdGlvbi5nZXQoKSwgMTIpO1xyXG4gICAgICAvLyBubyBmdWxsIGNhY2hlIHJlc2V0IHJlcXVpcmVkXHJcbiAgICAgIGlmICh0aGlzLnZlY3RvcnMudHJhbnNsYXRpb24pXHJcbiAgICAgICAgdGhpcy52ZWN0b3JzLnRyYW5zbGF0aW9uLnNldChfdHJhbnNsYXRpb24ueCwgX3RyYW5zbGF0aW9uLnksIF90cmFuc2xhdGlvbi56KTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHRoaXMudmVjdG9ycy50cmFuc2xhdGlvbiA9IF90cmFuc2xhdGlvbi5jbG9uZTtcclxuICAgICAgdGhpcy5tdXRhdG9yID0gbnVsbDtcclxuICAgIH1cclxuICAgIHB1YmxpYyBnZXQgdHJhbnNsYXRpb24oKTogVmVjdG9yMyB7XHJcbiAgICAgIGlmICghdGhpcy52ZWN0b3JzLnRyYW5zbGF0aW9uKSB7XHJcbiAgICAgICAgdGhpcy52ZWN0b3JzLnRyYW5zbGF0aW9uID0gdGhpcy4jdmVjdG9ycy50cmFuc2xhdGlvbjtcclxuICAgICAgICB0aGlzLnZlY3RvcnMudHJhbnNsYXRpb24uc2V0KHRoaXMuZGF0YVsxMl0sIHRoaXMuZGF0YVsxM10sIHRoaXMuZGF0YVsxNF0pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLnZlY3RvcnMudHJhbnNsYXRpb247IC8vIC5jbG9uZTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiAtIGdldDogcmV0dXJuIGEgdmVjdG9yIHJlcHJlc2VudGF0aW9uIG9mIHRoZSByb3RhdGlvbiB7QGxpbmsgVmVjdG9yM30uICBcclxuICAgICAqICoqQ2F1dGlvbiEqKiBVc2UgaW1tZWRpYXRlbHkgYW5kIHJlYWRvbmx5LCBzaW5jZSB0aGUgdmVjdG9yIGlzIGdvaW5nIHRvIGJlIHJldXNlZCBieSBSZWN5Y2xlci4gQ3JlYXRlIGEgY2xvbmUgdG8ga2VlcCBsb25nZXIgYW5kIG1hbmlwdWxhdGUuIFxyXG4gICAgICogLSBzZXQ6IGVmZmVjdCB0aGUgbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgcm90YXRpb24oKTogVmVjdG9yMyB7XHJcbiAgICAgIGlmICghdGhpcy52ZWN0b3JzLnJvdGF0aW9uKVxyXG4gICAgICAgIHRoaXMudmVjdG9ycy5yb3RhdGlvbiA9IHRoaXMuZ2V0RXVsZXJBbmdsZXMoKS5jbG9uZTtcclxuICAgICAgcmV0dXJuIHRoaXMudmVjdG9ycy5yb3RhdGlvbjsgLy8uY2xvbmU7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHJvdGF0aW9uKF9yb3RhdGlvbjogVmVjdG9yMykge1xyXG4gICAgICB0aGlzLm11dGF0ZSh7IFwicm90YXRpb25cIjogX3JvdGF0aW9uIH0pO1xyXG4gICAgICB0aGlzLnJlc2V0Q2FjaGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiAtIGdldDogcmV0dXJuIGEgdmVjdG9yIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzY2FsaW5nIHtAbGluayBWZWN0b3IzfS4gIFxyXG4gICAgICogKipDYXV0aW9uISoqIFVzZSBpbW1lZGlhdGVseSBhbmQgcmVhZG9ubHksIHNpbmNlIHRoZSB2ZWN0b3IgaXMgZ29pbmcgdG8gYmUgcmV1c2VkIGJ5IFJlY3ljbGVyLiBDcmVhdGUgYSBjbG9uZSB0byBrZWVwIGxvbmdlciBhbmQgbWFuaXB1bGF0ZS4gXHJcbiAgICAgKiAtIHNldDogZWZmZWN0IHRoZSBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBzY2FsaW5nKCk6IFZlY3RvcjMge1xyXG4gICAgICBpZiAoIXRoaXMudmVjdG9ycy5zY2FsaW5nKSB7XHJcbiAgICAgICAgdGhpcy52ZWN0b3JzLnNjYWxpbmcgPSB0aGlzLiN2ZWN0b3JzLnNjYWxpbmc7XHJcbiAgICAgICAgdGhpcy52ZWN0b3JzLnNjYWxpbmcuc2V0KFxyXG4gICAgICAgICAgTWF0aC5oeXBvdCh0aGlzLmRhdGFbMF0sIHRoaXMuZGF0YVsxXSwgdGhpcy5kYXRhWzJdKSxcclxuICAgICAgICAgIE1hdGguaHlwb3QodGhpcy5kYXRhWzRdLCB0aGlzLmRhdGFbNV0sIHRoaXMuZGF0YVs2XSksXHJcbiAgICAgICAgICBNYXRoLmh5cG90KHRoaXMuZGF0YVs4XSwgdGhpcy5kYXRhWzldLCB0aGlzLmRhdGFbMTBdKVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMudmVjdG9ycy5zY2FsaW5nOyAvLyAuY2xvbmU7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHNjYWxpbmcoX3NjYWxpbmc6IFZlY3RvcjMpIHtcclxuICAgICAgdGhpcy5tdXRhdGUoeyBcInNjYWxpbmdcIjogX3NjYWxpbmcgfSk7XHJcbiAgICAgIHRoaXMucmVzZXRDYWNoZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGEgY29weSBvZiB0aGlzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgY2xvbmUoKTogTWF0cml4NHg0IHtcclxuICAgICAgbGV0IG10eENsb25lOiBNYXRyaXg0eDQgPSBSZWN5Y2xlci5nZXQoTWF0cml4NHg0KTtcclxuICAgICAgbXR4Q2xvbmUuc2V0KHRoaXMpO1xyXG4gICAgICByZXR1cm4gbXR4Q2xvbmU7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICBwdWJsaWMgcmVjeWNsZSgpOiB2b2lkIHtcclxuICAgICAgdGhpcy5kYXRhLnNldChbXHJcbiAgICAgICAgMSwgMCwgMCwgMCxcclxuICAgICAgICAwLCAxLCAwLCAwLFxyXG4gICAgICAgIDAsIDAsIDEsIDAsXHJcbiAgICAgICAgMCwgMCwgMCwgMVxyXG4gICAgICBdKTtcclxuICAgICAgdGhpcy5yZXNldENhY2hlKCk7IFxyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBSb3RhdGlvblxyXG4gICAgLyoqXHJcbiAgICAgKiBSb3RhdGUgdGhpcyBtYXRyaXggYnkgZ2l2ZW4ge0BsaW5rIFZlY3RvcjN9IGluIHRoZSBvcmRlciBaLCBZLCBYLiBSaWdodCBoYW5kIHJvdGF0aW9uIGlzIHVzZWQsIHRodW1iIHBvaW50cyBpbiBheGlzIGRpcmVjdGlvbiwgZmluZ2VycyBjdXJsaW5nIGluZGljYXRlIHJvdGF0aW9uXHJcbiAgICAgKiBUaGUgcm90YXRpb24gaXMgYXBwZW5kZWQgdG8gYWxyZWFkeSBhcHBsaWVkIHRyYW5zZm9ybXMsIHRodXMgbXVsdGlwbGllZCBmcm9tIHRoZSByaWdodC4gU2V0IF9mcm9tTGVmdCB0byB0cnVlIHRvIHN3aXRjaCBhbmQgcHV0IGl0IGluIGZyb250LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcm90YXRlKF9ieTogVmVjdG9yMywgX2Zyb21MZWZ0OiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcclxuICAgICAgLy8gdGhpcy5yb3RhdGVaKF9ieS56LCBfZnJvbUxlZnQpO1xyXG4gICAgICAvLyB0aGlzLnJvdGF0ZVkoX2J5LnksIF9mcm9tTGVmdCk7XHJcbiAgICAgIC8vIHRoaXMucm90YXRlWChfYnkueCwgX2Zyb21MZWZ0KTtcclxuICAgICAgbGV0IG10eFJvdGF0aW9uOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuUk9UQVRJT04oX2J5KTtcclxuICAgICAgdGhpcy5tdWx0aXBseShtdHhSb3RhdGlvbiwgX2Zyb21MZWZ0KTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUobXR4Um90YXRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB0cmFuc3Bvc2UoKTogTWF0cml4NHg0IHtcclxuICAgICAgbGV0IG1hdHJpeDogRmxvYXQzMkFycmF5ID0gdGhpcy5kYXRhO1xyXG4gICAgICB0aGlzLmRhdGEuc2V0KFtcclxuICAgICAgICBtYXRyaXhbMF0sIG1hdHJpeFs0XSwgbWF0cml4WzhdLCAgbWF0cml4WzEyXSxcclxuICAgICAgICBtYXRyaXhbMV0sIG1hdHJpeFs1XSwgbWF0cml4WzldLCAgbWF0cml4WzEzXSxcclxuICAgICAgICBtYXRyaXhbMl0sIG1hdHJpeFs2XSwgbWF0cml4WzEwXSwgbWF0cml4WzE0XSxcclxuICAgICAgICBtYXRyaXhbM10sIG1hdHJpeFs3XSwgbWF0cml4WzExXSwgbWF0cml4WzE1XVxyXG4gICAgICBdKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGludmVyc2UoKTogTWF0cml4NHg0IHtcclxuICAgICAgbGV0IG06IEZsb2F0MzJBcnJheSA9IHRoaXMuZGF0YTtcclxuICAgICAgbGV0IG0wMDogbnVtYmVyID0gbVswICogNCArIDBdO1xyXG4gICAgICBsZXQgbTAxOiBudW1iZXIgPSBtWzAgKiA0ICsgMV07XHJcbiAgICAgIGxldCBtMDI6IG51bWJlciA9IG1bMCAqIDQgKyAyXTtcclxuICAgICAgbGV0IG0wMzogbnVtYmVyID0gbVswICogNCArIDNdO1xyXG4gICAgICBsZXQgbTEwOiBudW1iZXIgPSBtWzEgKiA0ICsgMF07XHJcbiAgICAgIGxldCBtMTE6IG51bWJlciA9IG1bMSAqIDQgKyAxXTtcclxuICAgICAgbGV0IG0xMjogbnVtYmVyID0gbVsxICogNCArIDJdO1xyXG4gICAgICBsZXQgbTEzOiBudW1iZXIgPSBtWzEgKiA0ICsgM107XHJcbiAgICAgIGxldCBtMjA6IG51bWJlciA9IG1bMiAqIDQgKyAwXTtcclxuICAgICAgbGV0IG0yMTogbnVtYmVyID0gbVsyICogNCArIDFdO1xyXG4gICAgICBsZXQgbTIyOiBudW1iZXIgPSBtWzIgKiA0ICsgMl07XHJcbiAgICAgIGxldCBtMjM6IG51bWJlciA9IG1bMiAqIDQgKyAzXTtcclxuICAgICAgbGV0IG0zMDogbnVtYmVyID0gbVszICogNCArIDBdO1xyXG4gICAgICBsZXQgbTMxOiBudW1iZXIgPSBtWzMgKiA0ICsgMV07XHJcbiAgICAgIGxldCBtMzI6IG51bWJlciA9IG1bMyAqIDQgKyAyXTtcclxuICAgICAgbGV0IG0zMzogbnVtYmVyID0gbVszICogNCArIDNdO1xyXG4gICAgICBsZXQgdG1wMDogbnVtYmVyID0gbTIyICogbTMzO1xyXG4gICAgICBsZXQgdG1wMTogbnVtYmVyID0gbTMyICogbTIzO1xyXG4gICAgICBsZXQgdG1wMjogbnVtYmVyID0gbTEyICogbTMzO1xyXG4gICAgICBsZXQgdG1wMzogbnVtYmVyID0gbTMyICogbTEzO1xyXG4gICAgICBsZXQgdG1wNDogbnVtYmVyID0gbTEyICogbTIzO1xyXG4gICAgICBsZXQgdG1wNTogbnVtYmVyID0gbTIyICogbTEzO1xyXG4gICAgICBsZXQgdG1wNjogbnVtYmVyID0gbTAyICogbTMzO1xyXG4gICAgICBsZXQgdG1wNzogbnVtYmVyID0gbTMyICogbTAzO1xyXG4gICAgICBsZXQgdG1wODogbnVtYmVyID0gbTAyICogbTIzO1xyXG4gICAgICBsZXQgdG1wOTogbnVtYmVyID0gbTIyICogbTAzO1xyXG4gICAgICBsZXQgdG1wMTA6IG51bWJlciA9IG0wMiAqIG0xMztcclxuICAgICAgbGV0IHRtcDExOiBudW1iZXIgPSBtMTIgKiBtMDM7XHJcbiAgICAgIGxldCB0bXAxMjogbnVtYmVyID0gbTIwICogbTMxO1xyXG4gICAgICBsZXQgdG1wMTM6IG51bWJlciA9IG0zMCAqIG0yMTtcclxuICAgICAgbGV0IHRtcDE0OiBudW1iZXIgPSBtMTAgKiBtMzE7XHJcbiAgICAgIGxldCB0bXAxNTogbnVtYmVyID0gbTMwICogbTExO1xyXG4gICAgICBsZXQgdG1wMTY6IG51bWJlciA9IG0xMCAqIG0yMTtcclxuICAgICAgbGV0IHRtcDE3OiBudW1iZXIgPSBtMjAgKiBtMTE7XHJcbiAgICAgIGxldCB0bXAxODogbnVtYmVyID0gbTAwICogbTMxO1xyXG4gICAgICBsZXQgdG1wMTk6IG51bWJlciA9IG0zMCAqIG0wMTtcclxuICAgICAgbGV0IHRtcDIwOiBudW1iZXIgPSBtMDAgKiBtMjE7XHJcbiAgICAgIGxldCB0bXAyMTogbnVtYmVyID0gbTIwICogbTAxO1xyXG4gICAgICBsZXQgdG1wMjI6IG51bWJlciA9IG0wMCAqIG0xMTtcclxuICAgICAgbGV0IHRtcDIzOiBudW1iZXIgPSBtMTAgKiBtMDE7XHJcblxyXG4gICAgICBsZXQgdDA6IG51bWJlciA9ICh0bXAwICogbTExICsgdG1wMyAqIG0yMSArIHRtcDQgKiBtMzEpIC1cclxuICAgICAgICAodG1wMSAqIG0xMSArIHRtcDIgKiBtMjEgKyB0bXA1ICogbTMxKTtcclxuXHJcbiAgICAgIGxldCB0MTogbnVtYmVyID0gKHRtcDEgKiBtMDEgKyB0bXA2ICogbTIxICsgdG1wOSAqIG0zMSkgLVxyXG4gICAgICAgICh0bXAwICogbTAxICsgdG1wNyAqIG0yMSArIHRtcDggKiBtMzEpO1xyXG4gICAgICBsZXQgdDI6IG51bWJlciA9ICh0bXAyICogbTAxICsgdG1wNyAqIG0xMSArIHRtcDEwICogbTMxKSAtXHJcbiAgICAgICAgKHRtcDMgKiBtMDEgKyB0bXA2ICogbTExICsgdG1wMTEgKiBtMzEpO1xyXG4gICAgICBsZXQgdDM6IG51bWJlciA9ICh0bXA1ICogbTAxICsgdG1wOCAqIG0xMSArIHRtcDExICogbTIxKSAtXHJcbiAgICAgICAgKHRtcDQgKiBtMDEgKyB0bXA5ICogbTExICsgdG1wMTAgKiBtMjEpO1xyXG5cclxuICAgICAgbGV0IGQ6IG51bWJlciA9IDEuMCAvIChtMDAgKiB0MCArIG0xMCAqIHQxICsgbTIwICogdDIgKyBtMzAgKiB0Myk7XHJcblxyXG4gICAgICAvLyBsZXQgbWF0cml4OiBNYXRyaXg0eDQgPSBuZXcgTWF0cml4NHg0O1xyXG4gICAgICBjb25zdCBtYXRyaXg6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLmdldChNYXRyaXg0eDQpO1xyXG4gICAgICBtYXRyaXguZGF0YS5zZXQoW1xyXG4gICAgICAgIGQgKiB0MCwgLy8gWzBdXHJcbiAgICAgICAgZCAqIHQxLCAvLyBbMV1cclxuICAgICAgICBkICogdDIsIC8vIFsyXVxyXG4gICAgICAgIGQgKiB0MywgLy8gWzNdXHJcbiAgICAgICAgZCAqICgodG1wMSAqIG0xMCArIHRtcDIgKiBtMjAgKyB0bXA1ICogbTMwKSAtICh0bXAwICogbTEwICsgdG1wMyAqIG0yMCArIHRtcDQgKiBtMzApKSwgICAgICAgIC8vIFs0XVxyXG4gICAgICAgIGQgKiAoKHRtcDAgKiBtMDAgKyB0bXA3ICogbTIwICsgdG1wOCAqIG0zMCkgLSAodG1wMSAqIG0wMCArIHRtcDYgKiBtMjAgKyB0bXA5ICogbTMwKSksICAgICAgICAvLyBbNV1cclxuICAgICAgICBkICogKCh0bXAzICogbTAwICsgdG1wNiAqIG0xMCArIHRtcDExICogbTMwKSAtICh0bXAyICogbTAwICsgdG1wNyAqIG0xMCArIHRtcDEwICogbTMwKSksICAgICAgLy8gWzZdXHJcbiAgICAgICAgZCAqICgodG1wNCAqIG0wMCArIHRtcDkgKiBtMTAgKyB0bXAxMCAqIG0yMCkgLSAodG1wNSAqIG0wMCArIHRtcDggKiBtMTAgKyB0bXAxMSAqIG0yMCkpLCAgICAgIC8vIFs3XVxyXG4gICAgICAgIGQgKiAoKHRtcDEyICogbTEzICsgdG1wMTUgKiBtMjMgKyB0bXAxNiAqIG0zMykgLSAodG1wMTMgKiBtMTMgKyB0bXAxNCAqIG0yMyArIHRtcDE3ICogbTMzKSksICAvLyBbOF1cclxuICAgICAgICBkICogKCh0bXAxMyAqIG0wMyArIHRtcDE4ICogbTIzICsgdG1wMjEgKiBtMzMpIC0gKHRtcDEyICogbTAzICsgdG1wMTkgKiBtMjMgKyB0bXAyMCAqIG0zMykpLCAgLy8gWzldXHJcbiAgICAgICAgZCAqICgodG1wMTQgKiBtMDMgKyB0bXAxOSAqIG0xMyArIHRtcDIyICogbTMzKSAtICh0bXAxNSAqIG0wMyArIHRtcDE4ICogbTEzICsgdG1wMjMgKiBtMzMpKSwgIC8vIFsxMF1cclxuICAgICAgICBkICogKCh0bXAxNyAqIG0wMyArIHRtcDIwICogbTEzICsgdG1wMjMgKiBtMjMpIC0gKHRtcDE2ICogbTAzICsgdG1wMjEgKiBtMTMgKyB0bXAyMiAqIG0yMykpLCAgLy8gWzExXVxyXG4gICAgICAgIGQgKiAoKHRtcDE0ICogbTIyICsgdG1wMTcgKiBtMzIgKyB0bXAxMyAqIG0xMikgLSAodG1wMTYgKiBtMzIgKyB0bXAxMiAqIG0xMiArIHRtcDE1ICogbTIyKSksICAvLyBbMTJdXHJcbiAgICAgICAgZCAqICgodG1wMjAgKiBtMzIgKyB0bXAxMiAqIG0wMiArIHRtcDE5ICogbTIyKSAtICh0bXAxOCAqIG0yMiArIHRtcDIxICogbTMyICsgdG1wMTMgKiBtMDIpKSwgIC8vIFsxM11cclxuICAgICAgICBkICogKCh0bXAxOCAqIG0xMiArIHRtcDIzICogbTMyICsgdG1wMTUgKiBtMDIpIC0gKHRtcDIyICogbTMyICsgdG1wMTQgKiBtMDIgKyB0bXAxOSAqIG0xMikpLCAgLy8gWzE0XVxyXG4gICAgICAgIGQgKiAoKHRtcDIyICogbTIyICsgdG1wMTYgKiBtMDIgKyB0bXAyMSAqIG0xMikgLSAodG1wMjAgKiBtMTIgKyB0bXAyMyAqIG0yMiArIHRtcDE3ICogbTAyKSkgIC8vIFsxNV1cclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiBtYXRyaXg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgcm90YXRpb24gYXJvdW5kIHRoZSB4LWF4aXMgdG8gdGhpcyBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgcHVibGljIHJvdGF0ZVgoX2FuZ2xlSW5EZWdyZWVzOiBudW1iZXIsIF9mcm9tTGVmdDogYm9vbGVhbiA9IGZhbHNlKTogdm9pZCB7XHJcbiAgICAgIGxldCBtdHhSb3RhdGlvbjogTWF0cml4NHg0ID0gTWF0cml4NHg0LlJPVEFUSU9OX1goX2FuZ2xlSW5EZWdyZWVzKTtcclxuICAgICAgdGhpcy5tdWx0aXBseShtdHhSb3RhdGlvbiwgX2Zyb21MZWZ0KTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUobXR4Um90YXRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHJvdGF0aW9uIGFyb3VuZCB0aGUgeS1heGlzIHRvIHRoaXMgbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByb3RhdGVZKF9hbmdsZUluRGVncmVlczogbnVtYmVyLCBfZnJvbUxlZnQ6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xyXG4gICAgICBsZXQgbXR4Um90YXRpb246IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5ST1RBVElPTl9ZKF9hbmdsZUluRGVncmVlcyk7XHJcbiAgICAgIHRoaXMubXVsdGlwbHkobXR4Um90YXRpb24sIF9mcm9tTGVmdCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFJvdGF0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSByb3RhdGlvbiBhcm91bmQgdGhlIHotYXhpcyB0byB0aGlzIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcm90YXRlWihfYW5nbGVJbkRlZ3JlZXM6IG51bWJlciwgX2Zyb21MZWZ0OiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcclxuICAgICAgbGV0IG10eFJvdGF0aW9uOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuUk9UQVRJT05fWihfYW5nbGVJbkRlZ3JlZXMpO1xyXG4gICAgICB0aGlzLm11bHRpcGx5KG10eFJvdGF0aW9uLCBfZnJvbUxlZnQpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShtdHhSb3RhdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGp1c3RzIHRoZSByb3RhdGlvbiBvZiB0aGlzIG1hdHJpeCB0byBwb2ludCB0aGUgei1heGlzIGRpcmVjdGx5IGF0IHRoZSBnaXZlbiB0YXJnZXQgYW5kIHRpbHRzIGl0IHRvIGFjY29yZCB3aXRoIHRoZSBnaXZlbiB1cC17QGxpbmsgVmVjdG9yM30sXHJcbiAgICAgKiByZXNwZWN0aXZlbHkgY2FsY3VsYXRpbmcgeWF3IGFuZCBwaXRjaC4gSWYgbm8gdXAte0BsaW5rIFZlY3RvcjN9IGlzIGdpdmVuLCB0aGUgcHJldmlvdXMgdXAte0BsaW5rIFZlY3RvcjN9IGlzIHVzZWQuIFxyXG4gICAgICogV2hlbiBfcHJlc2VydmVTY2FsaW5nIGlzIGZhbHNlLCBhIHJvdGF0ZWQgaWRlbnRpdHkgbWF0cml4IGlzIHRoZSByZXN1bHQuIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbG9va0F0KF90YXJnZXQ6IFZlY3RvcjMsIF91cD86IFZlY3RvcjMsIF9wcmVzZXJ2ZVNjYWxpbmc6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XHJcbiAgICAgIGlmICghX3VwKVxyXG4gICAgICAgIF91cCA9IHRoaXMuZ2V0WSgpO1xyXG5cclxuICAgICAgY29uc3QgbXR4UmVzdWx0OiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuTE9PS19BVCh0aGlzLnRyYW5zbGF0aW9uLCBfdGFyZ2V0LCBfdXApO1xyXG4gICAgICBpZiAoX3ByZXNlcnZlU2NhbGluZylcclxuICAgICAgICBtdHhSZXN1bHQuc2NhbGUodGhpcy5zY2FsaW5nKTtcclxuICAgICAgdGhpcy5zZXQobXR4UmVzdWx0KTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUobXR4UmVzdWx0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2FtZSBhcyB7QGxpbmsgTWF0cml4NHg0Lmxvb2tBdH0sIGJ1dCBvcHRpbWl6ZWQgYW5kIG5lZWRzIHRlc3RpbmdcclxuICAgICAqL1xyXG4gICAgLy8gVE9ETzogdGVzdGluZyBsb29rYXQgdGhhdCByZWFsbHkganVzdCByb3RhdGVzIHRoZSBtYXRyaXggcmF0aGVyIHRoYW4gY3JlYXRpbmcgYSBuZXcgb25lXHJcbiAgICBwdWJsaWMgbG9va0F0Um90YXRlKF90YXJnZXQ6IFZlY3RvcjMsIF91cD86IFZlY3RvcjMsIF9wcmVzZXJ2ZVNjYWxpbmc6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XHJcbiAgICAgIGlmICghX3VwKVxyXG4gICAgICAgIF91cCA9IHRoaXMuZ2V0WSgpO1xyXG5cclxuICAgICAgbGV0IHNjYWxpbmc6IFZlY3RvcjMgPSB0aGlzLnNjYWxpbmc7XHJcbiAgICAgIGxldCBkaWZmZXJlbmNlOiBWZWN0b3IzID0gVmVjdG9yMy5ESUZGRVJFTkNFKF90YXJnZXQsIHRoaXMudHJhbnNsYXRpb24pO1xyXG4gICAgICBkaWZmZXJlbmNlLm5vcm1hbGl6ZSgpO1xyXG4gICAgICBsZXQgY29zOiBudW1iZXIgPSBWZWN0b3IzLkRPVChWZWN0b3IzLk5PUk1BTElaQVRJT04odGhpcy5nZXRaKCkpLCBkaWZmZXJlbmNlKTtcclxuICAgICAgbGV0IHNpbjogbnVtYmVyID0gVmVjdG9yMy5ET1QoVmVjdG9yMy5OT1JNQUxJWkFUSU9OKHRoaXMuZ2V0WCgpKSwgZGlmZmVyZW5jZSk7XHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKHNpbiwgY29zKTtcclxuICAgICAgbGV0IG10eFJvdGF0aW9uOiBNYXRyaXg0eDQgPSBSZWN5Y2xlci5ib3Jyb3coTWF0cml4NHg0KTtcclxuICAgICAgbXR4Um90YXRpb24uZGF0YS5zZXQoW1xyXG4gICAgICAgIGNvcywgMCwgLXNpbiwgMCxcclxuICAgICAgICAwLCAxLCAwLCAwLFxyXG4gICAgICAgIHNpbiwgMCwgY29zLCAwLFxyXG4gICAgICAgIDAsIDAsIDAsIDFcclxuICAgICAgXSk7XHJcbiAgICAgIHRoaXMubXVsdGlwbHkobXR4Um90YXRpb24sIGZhbHNlKTtcclxuXHJcbiAgICAgIGNvcyA9IFZlY3RvcjMuRE9UKFZlY3RvcjMuTk9STUFMSVpBVElPTih0aGlzLmdldFooKSksIGRpZmZlcmVuY2UpO1xyXG4gICAgICBzaW4gPSAtVmVjdG9yMy5ET1QoVmVjdG9yMy5OT1JNQUxJWkFUSU9OKHRoaXMuZ2V0WSgpKSwgZGlmZmVyZW5jZSk7XHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKHNpbiwgY29zKTtcclxuICAgICAgbXR4Um90YXRpb24uZGF0YS5zZXQoW1xyXG4gICAgICAgIDEsIDAsIDAsIDAsXHJcbiAgICAgICAgMCwgY29zLCBzaW4sIDAsXHJcbiAgICAgICAgMCwgLXNpbiwgY29zLCAwLFxyXG4gICAgICAgIDAsIDAsIDAsIDFcclxuICAgICAgXSk7XHJcbiAgICAgIHRoaXMubXVsdGlwbHkobXR4Um90YXRpb24sIGZhbHNlKTtcclxuICAgICAgdGhpcy5zY2FsaW5nID0gc2NhbGluZztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkanVzdHMgdGhlIHJvdGF0aW9uIG9mIHRoaXMgbWF0cml4IHRvIG1hdGNoIGl0cyB5LWF4aXMgd2l0aCB0aGUgZ2l2ZW4gdXAte0BsaW5rIFZlY3RvcjN9IGFuZCBmYWNpbmcgaXRzIHotYXhpcyB0b3dhcmQgdGhlIGdpdmVuIHRhcmdldCBhdCBtaW5pbWFsIGFuZ2xlLFxyXG4gICAgICogcmVzcGVjdGl2ZWx5IGNhbGN1bGF0aW5nIHlhdyBvbmx5LiBJZiBubyB1cC17QGxpbmsgVmVjdG9yM30gaXMgZ2l2ZW4sIHRoZSBwcmV2aW91cyB1cC17QGxpbmsgVmVjdG9yM30gaXMgdXNlZC4gXHJcbiAgICAgKiBXaGVuIF9wcmVzZXJ2ZVNjYWxpbmcgaXMgZmFsc2UsIGEgcm90YXRlZCBpZGVudGl0eSBtYXRyaXggaXMgdGhlIHJlc3VsdC4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzaG93VG8oX3RhcmdldDogVmVjdG9yMywgX3VwPzogVmVjdG9yMywgX3ByZXNlcnZlU2NhbGluZzogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcclxuICAgICAgaWYgKCFfdXApXHJcbiAgICAgICAgX3VwID0gdGhpcy5nZXRZKCk7XHJcblxyXG4gICAgICBjb25zdCBtdHhSZXN1bHQ6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5TSE9XX1RPKHRoaXMudHJhbnNsYXRpb24sIF90YXJnZXQsIF91cCk7XHJcbiAgICAgIGlmIChfcHJlc2VydmVTY2FsaW5nKVxyXG4gICAgICAgIG10eFJlc3VsdC5zY2FsZSh0aGlzLnNjYWxpbmcpO1xyXG4gICAgICB0aGlzLnNldChtdHhSZXN1bHQpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShtdHhSZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zbGF0aW9uXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIHRyYW5zbGF0aW9uIGJ5IHRoZSBnaXZlbiB7QGxpbmsgVmVjdG9yM30gdG8gdGhpcyBtYXRyaXguXHJcbiAgICAgKiBJZiBfbG9jYWwgaXMgdHJ1ZSwgdHJhbnNsYXRpb24gb2NjdXJzIGFjY29yZGluZyB0byB0aGUgY3VycmVudCByb3RhdGlvbiBhbmQgc2NhbGluZyBvZiB0aGlzIG1hdHJpeCxcclxuICAgICAqIGFjY29yZGluZyB0byB0aGUgcGFyZW50IG90aGVyd2lzZS4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0cmFuc2xhdGUoX2J5OiBWZWN0b3IzLCBfbG9jYWw6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XHJcbiAgICAgIGlmIChfbG9jYWwpIHtcclxuICAgICAgICBsZXQgbXR4VHJhbnNsYXRpb246IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5UUkFOU0xBVElPTihfYnkpO1xyXG4gICAgICAgIHRoaXMubXVsdGlwbHkobXR4VHJhbnNsYXRpb24pO1xyXG4gICAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFRyYW5zbGF0aW9uKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmRhdGFbMTJdICs9IF9ieS54O1xyXG4gICAgICAgIHRoaXMuZGF0YVsxM10gKz0gX2J5Lnk7XHJcbiAgICAgICAgdGhpcy5kYXRhWzE0XSArPSBfYnkuejtcclxuICAgICAgICB0aGlzLm11dGF0b3IgPSBudWxsO1xyXG4gICAgICAgIGlmICh0aGlzLnZlY3RvcnMudHJhbnNsYXRpb24pXHJcbiAgICAgICAgICBSZWN5Y2xlci5zdG9yZSh0aGlzLnZlY3RvcnMudHJhbnNsYXRpb24pO1xyXG4gICAgICAgIHRoaXMudmVjdG9ycy50cmFuc2xhdGlvbiA9IG51bGw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGNvbnN0IG1hdHJpeDogTWF0cml4NHg0ID0gTWF0cml4NHg0Lk1VTFRJUExJQ0FUSU9OKHRoaXMsIE1hdHJpeDR4NC5UUkFOU0xBVElPTihfYnkpKTtcclxuICAgICAgLy8gLy8gVE9ETzogcG9zc2libGUgb3B0aW1pemF0aW9uLCB0cmFuc2xhdGlvbiBtYXkgYWx0ZXIgbXV0YXRvciBpbnN0ZWFkIG9mIGRlbGV0aW5nIGl0LlxyXG4gICAgICAvLyB0aGlzLnNldChtYXRyaXgpO1xyXG4gICAgICAvLyBSZWN5Y2xlci5zdG9yZShtYXRyaXgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgdHJhbnNsYXRpb24gYWxvbmcgdGhlIHgtYXhpcyBieSB0aGUgZ2l2ZW4gYW1vdW50IHRvIHRoaXMgbWF0cml4IFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdHJhbnNsYXRlWChfeDogbnVtYmVyLCBfbG9jYWw6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XHJcbiAgICAgIGxldCB0cmFuc2xhdGlvbjogVmVjdG9yMyA9IFZlY3RvcjMuWChfeCk7XHJcbiAgICAgIHRoaXMudHJhbnNsYXRlKHRyYW5zbGF0aW9uLCBfbG9jYWwpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZSh0cmFuc2xhdGlvbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIHRyYW5zbGF0aW9uIGFsb25nIHRoZSB5LWF4aXMgYnkgdGhlIGdpdmVuIGFtb3VudCB0byB0aGlzIG1hdHJpeCBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHRyYW5zbGF0ZVkoX3k6IG51bWJlciwgX2xvY2FsOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xyXG4gICAgICBsZXQgdHJhbnNsYXRpb246IFZlY3RvcjMgPSBWZWN0b3IzLlkoX3kpO1xyXG4gICAgICB0aGlzLnRyYW5zbGF0ZSh0cmFuc2xhdGlvbiwgX2xvY2FsKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUodHJhbnNsYXRpb24pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSB0cmFuc2xhdGlvbiBhbG9uZyB0aGUgei1heGlzIGJ5IHRoZSBnaXZlbiBhbW91bnQgdG8gdGhpcyBtYXRyaXggXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0cmFuc2xhdGVaKF96OiBudW1iZXIsIF9sb2NhbDogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcclxuICAgICAgbGV0IHRyYW5zbGF0aW9uOiBWZWN0b3IzID0gVmVjdG9yMy5aKF96KTtcclxuICAgICAgdGhpcy50cmFuc2xhdGUodHJhbnNsYXRpb24sIF9sb2NhbCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKHRyYW5zbGF0aW9uKTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBTY2FsaW5nXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIHNjYWxpbmcgYnkgdGhlIGdpdmVuIHtAbGluayBWZWN0b3IzfSB0byB0aGlzIG1hdHJpeCBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNjYWxlKF9ieTogVmVjdG9yMyk6IHZvaWQge1xyXG4gICAgICBjb25zdCBtdHhSZXN1bHQ6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5NVUxUSVBMSUNBVElPTih0aGlzLCBNYXRyaXg0eDQuU0NBTElORyhfYnkpKTtcclxuICAgICAgdGhpcy5zZXQobXR4UmVzdWx0KTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUobXR4UmVzdWx0KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIHNjYWxpbmcgYWxvbmcgdGhlIHgtYXhpcyBieSB0aGUgZ2l2ZW4gYW1vdW50IHRvIHRoaXMgbWF0cml4IFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2NhbGVYKF9ieTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIGxldCB2ZWN0b3I6IFZlY3RvcjMgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XHJcbiAgICAgIHZlY3Rvci5zZXQoX2J5LCAxLCAxKTtcclxuICAgICAgdGhpcy5zY2FsZSh2ZWN0b3IpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZSh2ZWN0b3IpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSBzY2FsaW5nIGFsb25nIHRoZSB5LWF4aXMgYnkgdGhlIGdpdmVuIGFtb3VudCB0byB0aGlzIG1hdHJpeCBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNjYWxlWShfYnk6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICBsZXQgdmVjdG9yOiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xyXG4gICAgICB2ZWN0b3Iuc2V0KDEsIF9ieSwgMSk7XHJcbiAgICAgIHRoaXMuc2NhbGUodmVjdG9yKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUodmVjdG9yKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgc2NhbGluZyBhbG9uZyB0aGUgei1heGlzIGJ5IHRoZSBnaXZlbiBhbW91bnQgdG8gdGhpcyBtYXRyaXggXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzY2FsZVooX2J5OiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgbGV0IHZlY3RvcjogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgdmVjdG9yLnNldCgxLCAxLCBfYnkpO1xyXG4gICAgICB0aGlzLnNjYWxlKHZlY3Rvcik7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKHZlY3Rvcik7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmb3JtYXRpb25cclxuICAgIC8qKlxyXG4gICAgICogTXVsdGlwbHkgdGhpcyBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBtdWx0aXBseShfbWF0cml4OiBNYXRyaXg0eDQsIF9mcm9tTGVmdDogYm9vbGVhbiA9IGZhbHNlKTogdm9pZCB7XHJcbiAgICAgIGNvbnN0IG10eFJlc3VsdDogTWF0cml4NHg0ID0gX2Zyb21MZWZ0ID8gTWF0cml4NHg0Lk1VTFRJUExJQ0FUSU9OKF9tYXRyaXgsIHRoaXMpIDogTWF0cml4NHg0Lk1VTFRJUExJQ0FUSU9OKHRoaXMsIF9tYXRyaXgpO1xyXG4gICAgICB0aGlzLnNldChtdHhSZXN1bHQpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShtdHhSZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgYW5kIHJldHVybnMgdGhlIGV1bGVyLWFuZ2xlcyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgcm90YXRpb24gb2YgdGhpcyBtYXRyaXguICBcclxuICAgICAqICoqQ2F1dGlvbiEqKiBVc2UgaW1tZWRpYXRlbHkgYW5kIHJlYWRvbmx5LCBzaW5jZSB0aGUgdmVjdG9yIGlzIGdvaW5nIHRvIGJlIHJldXNlZCBieSBSZWN5Y2xlci4gQ3JlYXRlIGEgY2xvbmUgdG8ga2VlcCBsb25nZXIgYW5kIG1hbmlwdWxhdGUuIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0RXVsZXJBbmdsZXMoKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCBzY2FsaW5nOiBWZWN0b3IzID0gdGhpcy5zY2FsaW5nO1xyXG5cclxuICAgICAgbGV0IHMwOiBudW1iZXIgPSB0aGlzLmRhdGFbMF0gLyBzY2FsaW5nLng7XHJcbiAgICAgIGxldCBzMTogbnVtYmVyID0gdGhpcy5kYXRhWzFdIC8gc2NhbGluZy54O1xyXG4gICAgICBsZXQgczI6IG51bWJlciA9IHRoaXMuZGF0YVsyXSAvIHNjYWxpbmcueDtcclxuICAgICAgbGV0IHM2OiBudW1iZXIgPSB0aGlzLmRhdGFbNl0gLyBzY2FsaW5nLnk7XHJcbiAgICAgIGxldCBzMTA6IG51bWJlciA9IHRoaXMuZGF0YVsxMF0gLyBzY2FsaW5nLno7XHJcblxyXG4gICAgICBsZXQgc3k6IG51bWJlciA9IE1hdGguaHlwb3QoczAsIHMxKTsgLy8gcHJvYmFibHkgMi4gcGFyYW0gc2hvdWxkIGJlIHRoaXMuZGF0YVs0XSAvIHNjYWxpbmcueVxyXG5cclxuICAgICAgbGV0IHNpbmd1bGFyOiBib29sZWFuID0gc3kgPCAxZS02OyAvLyBJZlxyXG5cclxuICAgICAgbGV0IHgxOiBudW1iZXIsIHkxOiBudW1iZXIsIHoxOiBudW1iZXI7XHJcbiAgICAgIGxldCB4MjogbnVtYmVyLCB5MjogbnVtYmVyLCB6MjogbnVtYmVyO1xyXG5cclxuICAgICAgaWYgKCFzaW5ndWxhcikge1xyXG4gICAgICAgIHgxID0gTWF0aC5hdGFuMihzNiwgczEwKTtcclxuICAgICAgICB5MSA9IE1hdGguYXRhbjIoLXMyLCBzeSk7XHJcbiAgICAgICAgejEgPSBNYXRoLmF0YW4yKHMxLCBzMCk7XHJcblxyXG4gICAgICAgIHgyID0gTWF0aC5hdGFuMigtczYsIC1zMTApO1xyXG4gICAgICAgIHkyID0gTWF0aC5hdGFuMigtczIsIC1zeSk7XHJcbiAgICAgICAgejIgPSBNYXRoLmF0YW4yKC1zMSwgLXMwKTtcclxuXHJcbiAgICAgICAgaWYgKE1hdGguYWJzKHgyKSArIE1hdGguYWJzKHkyKSArIE1hdGguYWJzKHoyKSA8IE1hdGguYWJzKHgxKSArIE1hdGguYWJzKHkxKSArIE1hdGguYWJzKHoxKSkge1xyXG4gICAgICAgICAgeDEgPSB4MjtcclxuICAgICAgICAgIHkxID0geTI7XHJcbiAgICAgICAgICB6MSA9IHoyO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICB4MSA9IE1hdGguYXRhbjIoLXRoaXMuZGF0YVs5XSAvIHNjYWxpbmcueiwgdGhpcy5kYXRhWzVdIC8gc2NhbGluZy55KTtcclxuICAgICAgICB5MSA9IE1hdGguYXRhbjIoLXRoaXMuZGF0YVsyXSAvIHNjYWxpbmcueCwgc3kpO1xyXG4gICAgICAgIHoxID0gMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gbGV0IHJvdGF0aW9uOiBWZWN0b3IzID0gUmVjeWNsZXIuYm9ycm93KFZlY3RvcjMpO1xyXG4gICAgICB0aGlzLiNldWxlckFuZ2xlcy5zZXQoeDEsIHkxLCB6MSk7XHJcbiAgICAgIHRoaXMuI2V1bGVyQW5nbGVzLnNjYWxlKDE4MCAvIE1hdGguUEkpO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuI2V1bGVyQW5nbGVzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgZWxlbWVudHMgb2YgdGhpcyBtYXRyaXggdG8gdGhlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQoX210eFRvOiBNYXRyaXg0eDQgfCBGbG9hdDMyQXJyYXkpOiB2b2lkIHtcclxuICAgICAgaWYgKF9tdHhUbyBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSlcclxuICAgICAgICB0aGlzLmRhdGEuc2V0KF9tdHhUbyk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICB0aGlzLmRhdGEuc2V0KF9tdHhUby5kYXRhKTtcclxuICAgICAgdGhpcy5yZXNldENhY2hlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiBgxpIuTWF0cml4NHg0KHRyYW5zbGF0aW9uOiAke3RoaXMudHJhbnNsYXRpb24udG9TdHJpbmcoKX0sIHJvdGF0aW9uOiAke3RoaXMucm90YXRpb24udG9TdHJpbmcoKX0sIHNjYWxpbmc6ICR7dGhpcy5zY2FsaW5nLnRvU3RyaW5nKCl9YDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgZWxlbWVudHMgb2YgdGhpcyBtYXRyaXggYXMgYSBGbG9hdDMyQXJyYXlcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCgpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGNhcmRpbmFsIHgtYXhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0WCgpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgcmVzdWx0LnNldCh0aGlzLmRhdGFbMF0sIHRoaXMuZGF0YVsxXSwgdGhpcy5kYXRhWzJdKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGNhcmRpbmFsIHktYXhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0WSgpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgcmVzdWx0LnNldCh0aGlzLmRhdGFbNF0sIHRoaXMuZGF0YVs1XSwgdGhpcy5kYXRhWzZdKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGNhcmRpbmFsIHotYXhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0WigpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgcmVzdWx0LnNldCh0aGlzLmRhdGFbOF0sIHRoaXMuZGF0YVs5XSwgdGhpcy5kYXRhWzEwXSk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTd2FwcyB0aGUgdHdvIGNhcmRpbmFsIGF4aXMgYW5kIHJldmVyc2VzIHRoZSB0aGlyZCwgZWZmZWN0aXZlbHkgcm90YXRpbmcgdGhlIHRyYW5zZm9ybSAxODAgZGVncmVlcyBhcm91bmQgb25lIGFuZCA5MCBkZWdyZWVzIGFyb3VuZCBhIHNlY29uZCBheGlzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzd2FwWFkoKTogdm9pZCB7XHJcbiAgICAgIGxldCB0ZW1wOiBudW1iZXJbXSA9IFt0aGlzLmRhdGFbMF0sIHRoaXMuZGF0YVsxXSwgdGhpcy5kYXRhWzJdXTsgLy8gc3RvcmUgeC1heGlzXHJcbiAgICAgIHRoaXMuZGF0YS5zZXQoW3RoaXMuZGF0YVs0XSwgdGhpcy5kYXRhWzVdLCB0aGlzLmRhdGFbNl1dLCAwKTsgLy8gb3ZlcndyaXRlIHgtYXhpcyB3aXRoIHktYXhpc1xyXG4gICAgICB0aGlzLmRhdGEuc2V0KHRlbXAsIDQpOyAvLyBvdmVyd3JpdGUgWSB3aXRoIHRlbXBcclxuICAgICAgdGhpcy5kYXRhLnNldChbLXRoaXMuZGF0YVs4XSwgLXRoaXMuZGF0YVs5XSwgLXRoaXMuZGF0YVsxMF1dLCA4KTsgLy8gcmV2ZXJzZSB6LWF4aXNcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3dhcHMgdGhlIHR3byBjYXJkaW5hbCBheGlzIGFuZCByZXZlcnNlcyB0aGUgdGhpcmQsIGVmZmVjdGl2ZWx5IHJvdGF0aW5nIHRoZSB0cmFuc2Zvcm0gMTgwIGRlZ3JlZXMgYXJvdW5kIG9uZSBhbmQgOTAgZGVncmVlcyBhcm91bmQgYSBzZWNvbmQgYXhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3dhcFhaKCk6IHZvaWQge1xyXG4gICAgICBsZXQgdGVtcDogbnVtYmVyW10gPSBbdGhpcy5kYXRhWzBdLCB0aGlzLmRhdGFbMV0sIHRoaXMuZGF0YVsyXV07IC8vIHN0b3JlIHgtYXhpc1xyXG4gICAgICB0aGlzLmRhdGEuc2V0KFt0aGlzLmRhdGFbOF0sIHRoaXMuZGF0YVs5XSwgdGhpcy5kYXRhWzEwXV0sIDApOyAvLyBvdmVyd3JpdGUgeC1heGlzIHdpdGggei1heGlzXHJcbiAgICAgIHRoaXMuZGF0YS5zZXQodGVtcCwgOCk7IC8vIG92ZXJ3cml0ZSBaIHdpdGggdGVtcFxyXG4gICAgICB0aGlzLmRhdGEuc2V0KFstdGhpcy5kYXRhWzRdLCAtdGhpcy5kYXRhWzVdLCAtdGhpcy5kYXRhWzZdXSwgNCk7IC8vIHJldmVyc2UgeS1heGlzXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN3YXBzIHRoZSB0d28gY2FyZGluYWwgYXhpcyBhbmQgcmV2ZXJzZXMgdGhlIHRoaXJkLCBlZmZlY3RpdmVseSByb3RhdGluZyB0aGUgdHJhbnNmb3JtIDE4MCBkZWdyZWVzIGFyb3VuZCBvbmUgYW5kIDkwIGRlZ3JlZXMgYXJvdW5kIGEgc2Vjb25kIGF4aXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN3YXBZWigpOiB2b2lkIHtcclxuICAgICAgbGV0IHRlbXA6IG51bWJlcltdID0gW3RoaXMuZGF0YVs0XSwgdGhpcy5kYXRhWzVdLCB0aGlzLmRhdGFbNl1dOyAvLyBzdG9yZSB5LWF4aXNcclxuICAgICAgdGhpcy5kYXRhLnNldChbdGhpcy5kYXRhWzhdLCB0aGlzLmRhdGFbOV0sIHRoaXMuZGF0YVsxMF1dLCA0KTsgLy8gb3ZlcndyaXRlIHktYXhpcyB3aXRoIHotYXhpc1xyXG4gICAgICB0aGlzLmRhdGEuc2V0KHRlbXAsIDgpOyAvLyBvdmVyd3JpdGUgWiB3aXRoIHRlbXBcclxuICAgICAgdGhpcy5kYXRhLnNldChbLXRoaXMuZGF0YVswXSwgLXRoaXMuZGF0YVsxXSwgLXRoaXMuZGF0YVsyXV0sIDApOyAvLyByZXZlcnNlIHgtYXhpc1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdHJhbmxhdGlvbiBmcm9tIHRoaXMgbWF0cml4IHRvIHRoZSB0YXJnZXQgbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRUcmFuc2xhdGlvblRvKF9tdHhUYXJnZXQ6IE1hdHJpeDR4NCk6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgZGlmZmVyZW5jZTogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgZGlmZmVyZW5jZS5zZXQoX210eFRhcmdldC5kYXRhWzEyXSAtIHRoaXMuZGF0YVsxMl0sIF9tdHhUYXJnZXQuZGF0YVsxM10gLSB0aGlzLmRhdGFbMTNdLCBfbXR4VGFyZ2V0LmRhdGFbMTRdIC0gdGhpcy5kYXRhWzE0XSk7XHJcbiAgICAgIHJldHVybiBkaWZmZXJlbmNlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIC8vIHRoaXMuZ2V0TXV0YXRvcigpO1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHtcclxuICAgICAgICB0cmFuc2xhdGlvbjogdGhpcy50cmFuc2xhdGlvbi5zZXJpYWxpemUoKSxcclxuICAgICAgICByb3RhdGlvbjogdGhpcy5yb3RhdGlvbi5zZXJpYWxpemUoKSxcclxuICAgICAgICBzY2FsaW5nOiB0aGlzLnNjYWxpbmcuc2VyaWFsaXplKClcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHtcclxuICAgICAgICB0cmFuc2xhdGlvbjogYXdhaXQgdGhpcy50cmFuc2xhdGlvbi5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi50cmFuc2xhdGlvbiksXHJcbiAgICAgICAgcm90YXRpb246IGF3YWl0IHRoaXMucm90YXRpb24uZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24ucm90YXRpb24pLFxyXG4gICAgICAgIHNjYWxpbmc6IGF3YWl0IHRoaXMuc2NhbGluZy5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5zY2FsaW5nKVxyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLm11dGF0ZShtdXRhdG9yKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XHJcbiAgICAgIGlmICh0aGlzLm11dGF0b3IpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMubXV0YXRvcjtcclxuXHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0ge1xyXG4gICAgICAgIHRyYW5zbGF0aW9uOiB0aGlzLnRyYW5zbGF0aW9uLmdldE11dGF0b3IoKSxcclxuICAgICAgICByb3RhdGlvbjogdGhpcy5yb3RhdGlvbi5nZXRNdXRhdG9yKCksXHJcbiAgICAgICAgc2NhbGluZzogdGhpcy5zY2FsaW5nLmdldE11dGF0b3IoKVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gY2FjaGUgbXV0YXRvclxyXG4gICAgICB0aGlzLm11dGF0b3IgPSBtdXRhdG9yO1xyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIGxldCBvbGRUcmFuc2xhdGlvbjogVmVjdG9yMyA9IHRoaXMudHJhbnNsYXRpb247XHJcbiAgICAgIGxldCBvbGRSb3RhdGlvbjogVmVjdG9yMyA9IHRoaXMucm90YXRpb247XHJcbiAgICAgIGxldCBvbGRTY2FsaW5nOiBWZWN0b3IzID0gdGhpcy5zY2FsaW5nO1xyXG4gICAgICBsZXQgbmV3VHJhbnNsYXRpb246IFZlY3RvcjMgPSA8VmVjdG9yMz5fbXV0YXRvcltcInRyYW5zbGF0aW9uXCJdO1xyXG4gICAgICBsZXQgbmV3Um90YXRpb246IFZlY3RvcjMgPSA8VmVjdG9yMz5fbXV0YXRvcltcInJvdGF0aW9uXCJdO1xyXG4gICAgICBsZXQgbmV3U2NhbGluZzogVmVjdG9yMyA9IDxWZWN0b3IzPl9tdXRhdG9yW1wic2NhbGluZ1wiXTtcclxuICAgICAgbGV0IHZlY3RvcnM6IFZlY3RvclJlcHJlc2VudGF0aW9uID0geyB0cmFuc2xhdGlvbjogb2xkVHJhbnNsYXRpb24sIHJvdGF0aW9uOiBvbGRSb3RhdGlvbiwgc2NhbGluZzogb2xkU2NhbGluZyB9O1xyXG4gICAgICBpZiAobmV3VHJhbnNsYXRpb24pIHtcclxuICAgICAgICB2ZWN0b3JzLnRyYW5zbGF0aW9uID0gdmVjdG9ycy50cmFuc2xhdGlvbiB8fCB0aGlzLiN2ZWN0b3JzLnRyYW5zbGF0aW9uO1xyXG4gICAgICAgIHZlY3RvcnMudHJhbnNsYXRpb24uc2V0KFxyXG4gICAgICAgICAgbmV3VHJhbnNsYXRpb24ueCAhPSB1bmRlZmluZWQgPyBuZXdUcmFuc2xhdGlvbi54IDogb2xkVHJhbnNsYXRpb24ueCxcclxuICAgICAgICAgIG5ld1RyYW5zbGF0aW9uLnkgIT0gdW5kZWZpbmVkID8gbmV3VHJhbnNsYXRpb24ueSA6IG9sZFRyYW5zbGF0aW9uLnksXHJcbiAgICAgICAgICBuZXdUcmFuc2xhdGlvbi56ICE9IHVuZGVmaW5lZCA/IG5ld1RyYW5zbGF0aW9uLnogOiBvbGRUcmFuc2xhdGlvbi56XHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAobmV3Um90YXRpb24pIHtcclxuICAgICAgICB2ZWN0b3JzLnJvdGF0aW9uID0gdmVjdG9ycy5yb3RhdGlvbiB8fCB0aGlzLiN2ZWN0b3JzLnJvdGF0aW9uO1xyXG4gICAgICAgIHZlY3RvcnMucm90YXRpb24uc2V0KFxyXG4gICAgICAgICAgbmV3Um90YXRpb24ueCAhPSB1bmRlZmluZWQgPyBuZXdSb3RhdGlvbi54IDogb2xkUm90YXRpb24ueCxcclxuICAgICAgICAgIG5ld1JvdGF0aW9uLnkgIT0gdW5kZWZpbmVkID8gbmV3Um90YXRpb24ueSA6IG9sZFJvdGF0aW9uLnksXHJcbiAgICAgICAgICBuZXdSb3RhdGlvbi56ICE9IHVuZGVmaW5lZCA/IG5ld1JvdGF0aW9uLnogOiBvbGRSb3RhdGlvbi56XHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAobmV3U2NhbGluZykge1xyXG4gICAgICAgIHZlY3RvcnMuc2NhbGluZyA9IHZlY3RvcnMuc2NhbGluZyB8fCB0aGlzLiN2ZWN0b3JzLnNjYWxpbmc7XHJcbiAgICAgICAgdmVjdG9ycy5zY2FsaW5nLnNldChcclxuICAgICAgICAgIG5ld1NjYWxpbmcueCAhPSB1bmRlZmluZWQgPyBuZXdTY2FsaW5nLnggOiBvbGRTY2FsaW5nLngsXHJcbiAgICAgICAgICBuZXdTY2FsaW5nLnkgIT0gdW5kZWZpbmVkID8gbmV3U2NhbGluZy55IDogb2xkU2NhbGluZy55LFxyXG4gICAgICAgICAgbmV3U2NhbGluZy56ICE9IHVuZGVmaW5lZCA/IG5ld1NjYWxpbmcueiA6IG9sZFNjYWxpbmcuelxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFRPRE86IHBvc3NpYmxlIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiB3aGVuIG9ubHkgb25lIG9yIHR3byBjb21wb25lbnRzIGNoYW5nZSwgdGhlbiB1c2Ugb2xkIG1hdHJpeCBpbnN0ZWFkIG9mIElERU5USVRZIGFuZCB0cmFuc2Zvcm0gYnkgZGlmZmVyZW5jZXMvcXVvdGllbnRzXHJcbiAgICAgIGxldCBtdHhSZXN1bHQ6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpO1xyXG4gICAgICBpZiAodmVjdG9ycy50cmFuc2xhdGlvbilcclxuICAgICAgICBtdHhSZXN1bHQudHJhbnNsYXRlKHZlY3RvcnMudHJhbnNsYXRpb24pO1xyXG4gICAgICBpZiAodmVjdG9ycy5yb3RhdGlvbikge1xyXG4gICAgICAgIC8vIG10eFJlc3VsdC5yb3RhdGVaKHZlY3RvcnMucm90YXRpb24ueik7XHJcbiAgICAgICAgLy8gbXR4UmVzdWx0LnJvdGF0ZVkodmVjdG9ycy5yb3RhdGlvbi55KTtcclxuICAgICAgICAvLyBtdHhSZXN1bHQucm90YXRlWCh2ZWN0b3JzLnJvdGF0aW9uLngpO1xyXG4gICAgICAgIG10eFJlc3VsdC5yb3RhdGUodmVjdG9ycy5yb3RhdGlvbik7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHZlY3RvcnMuc2NhbGluZylcclxuICAgICAgICBtdHhSZXN1bHQuc2NhbGUodmVjdG9ycy5zY2FsaW5nKTtcclxuXHJcbiAgICAgIHRoaXMuc2V0KG10eFJlc3VsdCk7XHJcbiAgICAgIHRoaXMudmVjdG9ycyA9IHZlY3RvcnM7XHJcblxyXG4gICAgICBSZWN5Y2xlci5zdG9yZShtdHhSZXN1bHQpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yQXR0cmlidXRlVHlwZXMoX211dGF0b3I6IE11dGF0b3IpOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMge1xyXG4gICAgICBsZXQgdHlwZXM6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyA9IHt9O1xyXG4gICAgICBpZiAoX211dGF0b3IudHJhbnNsYXRpb24pIHR5cGVzLnRyYW5zbGF0aW9uID0gXCJWZWN0b3IzXCI7XHJcbiAgICAgIGlmIChfbXV0YXRvci5yb3RhdGlvbikgdHlwZXMucm90YXRpb24gPSBcIlZlY3RvcjNcIjtcclxuICAgICAgaWYgKF9tdXRhdG9yLnNjYWxpbmcpIHR5cGVzLnNjYWxpbmcgPSBcIlZlY3RvcjNcIjtcclxuICAgICAgcmV0dXJuIHR5cGVzO1xyXG4gICAgfVxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHsvKiogKi8gfVxyXG5cclxuICAgIHByaXZhdGUgcmVzZXRDYWNoZSgpOiB2b2lkIHtcclxuICAgICAgdGhpcy52ZWN0b3JzID0geyB0cmFuc2xhdGlvbjogbnVsbCwgcm90YXRpb246IG51bGwsIHNjYWxpbmc6IG51bGwgfTtcclxuICAgICAgdGhpcy5tdXRhdG9yID0gbnVsbDtcclxuICAgIH1cclxuICB9XHJcbiAgLy8jZW5kcmVnaW9uXHJcbn1cclxuIiwiLyoqXHJcbiAqIEJhc2VjbGFzcyBmb3IgTm9pc2UyLCBOb2lzZTMgYW5kIE5vaXNlNFxyXG4gKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxyXG4gKiBUaGlzIGlzIGFuIGFkYXB0aW9uIG9mIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2Zhc3Qtc2ltcGxleC1ub2lzZVxyXG4gKi9cclxuXHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBjbGFzcyBOb2lzZSB7XHJcbiAgICBwcm90ZWN0ZWQgcGVybTogVWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KDUxMik7XHJcbiAgICBwcm90ZWN0ZWQgcGVybU1vZDEyOiBVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoNTEyKTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihfcmFuZG9tOiBGdW5jdGlvbiA9IE1hdGgucmFuZG9tKSB7XHJcbiAgICAgIGNvbnN0IHA6IFVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheSgyNTYpO1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgMjU2OyBpKyspXHJcbiAgICAgICAgcFtpXSA9IGk7XHJcblxyXG4gICAgICBsZXQgbjogbnVtYmVyO1xyXG4gICAgICBsZXQgcTogbnVtYmVyO1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAyNTU7IGkgPiAwOyBpLS0pIHtcclxuICAgICAgICBuID0gTWF0aC5mbG9vcigoaSArIDEpICogX3JhbmRvbSgpKTtcclxuICAgICAgICBxID0gcFtpXTtcclxuICAgICAgICBwW2ldID0gcFtuXTtcclxuICAgICAgICBwW25dID0gcTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IDUxMjsgaSsrKSB7XHJcbiAgICAgICAgdGhpcy5wZXJtW2ldID0gcFtpICYgMjU1XTtcclxuICAgICAgICB0aGlzLnBlcm1Nb2QxMltpXSA9IHRoaXMucGVybVtpXSAlIDEyO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59IiwiLy8vPHJlZmVyZW5jZSBwYXRoPVwiLi9Ob2lzZS50c1wiLz5cclxuLyoqXHJcbiAqIFRoaXMgaXMgYW4gYWRhcHRpb24gb2YgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZmFzdC1zaW1wbGV4LW5vaXNlXHJcbiAqIGRvbmUgYnkgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuICpcclxuICogQmFzZWQgb24gZXhhbXBsZSBjb2RlIGJ5IFN0ZWZhbiBHdXN0YXZzb24gKHN0ZWd1QGl0bi5saXUuc2UpLlxyXG4gKiBPcHRpbWlzYXRpb25zIGJ5IFBldGVyIEVhc3RtYW4gKHBlYXN0bWFuQGRyaXp6bGUuc3RhbmZvcmQuZWR1KS5cclxuICogQmV0dGVyIHJhbmsgb3JkZXJpbmcgbWV0aG9kIGJ5IFN0ZWZhbiBHdXN0YXZzb24gaW4gMjAxMi5cclxuICpcclxuICogVGhpcyBjb2RlIHdhcyBwbGFjZWQgaW4gdGhlIHB1YmxpYyBkb21haW4gYnkgaXRzIG9yaWdpbmFsIGF1dGhvcixcclxuICogU3RlZmFuIEd1c3RhdnNvbi4gWW91IG1heSB1c2UgaXQgYXMgeW91IHNlZSBmaXQsIGJ1dFxyXG4gKiBhdHRyaWJ1dGlvbiBpcyBhcHByZWNpYXRlZC5cclxuICovXHJcblxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgY2xhc3MgTm9pc2UyIGV4dGVuZHMgTm9pc2Uge1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgb2Zmc2V0OiBudW1iZXIgPSAoMy4wIC0gTWF0aC5zcXJ0KDMuMCkpIC8gNi4wO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ3JhZGllbnQ6IG51bWJlcltdW10gPSBbWzEsIDFdLCBbLTEsIDFdLCBbMSwgLTFdLCBbLTEsIC0xXSwgWzEsIDBdLCBbLTEsIDBdLCBbMSwgMF0sIFstMSwgMF0sIFswLCAxXSwgWzAsIC0xXSwgWzAsIDFdLCBbMCwgLTFdXTtcclxuICAgICNzYW1wbGU6IChfeDogbnVtYmVyLCBfeTogbnVtYmVyKSA9PiBudW1iZXIgPSBudWxsO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKF9yYW5kb206IEZ1bmN0aW9uID0gTWF0aC5yYW5kb20pIHtcclxuICAgICAgc3VwZXIoX3JhbmRvbSk7XHJcblxyXG4gICAgICB0aGlzLiNzYW1wbGUgPSAoX3g6IG51bWJlciwgX3k6IG51bWJlcikgPT4ge1xyXG4gICAgICAgIC8vIFNrZXcgdGhlIGlucHV0IHNwYWNlIHRvIGRldGVybWluZSB3aGljaCBzaW1wbGV4IGNlbGwgd2UncmUgaW5cclxuICAgICAgICBjb25zdCBzOiBudW1iZXIgPSAoX3ggKyBfeSkgKiAwLjUgKiAoTWF0aC5zcXJ0KDMuMCkgLSAxLjApOyAvLyBIYWlyeSBmYWN0b3IgZm9yIDJEXHJcbiAgICAgICAgY29uc3QgaTogbnVtYmVyID0gTWF0aC5mbG9vcihfeCArIHMpO1xyXG4gICAgICAgIGNvbnN0IGo6IG51bWJlciA9IE1hdGguZmxvb3IoX3kgKyBzKTtcclxuICAgICAgICBjb25zdCB0OiBudW1iZXIgPSAoaSArIGopICogTm9pc2UyLm9mZnNldDtcclxuICAgICAgICBjb25zdCBYMDogbnVtYmVyID0gaSAtIHQ7IC8vIFVuc2tldyB0aGUgY2VsbCBvcmlnaW4gYmFjayB0byAoeCx5KSBzcGFjZVxyXG4gICAgICAgIGNvbnN0IFkwOiBudW1iZXIgPSBqIC0gdDtcclxuICAgICAgICBjb25zdCB4MDogbnVtYmVyID0gX3ggLSBYMDsgLy8gVGhlIHgseSBkaXN0YW5jZXMgZnJvbSB0aGUgY2VsbCBvcmlnaW5cclxuICAgICAgICBjb25zdCB5MDogbnVtYmVyID0gX3kgLSBZMDtcclxuXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIHNpbXBsZXggd2UgYXJlIGluLlxyXG4gICAgICAgIGNvbnN0IGkxOiBudW1iZXIgPSB4MCA+IHkwID8gMSA6IDA7XHJcbiAgICAgICAgY29uc3QgajE6IG51bWJlciA9IHgwID4geTAgPyAwIDogMTtcclxuXHJcbiAgICAgICAgLy8gT2Zmc2V0Om51bWJlcnMgZm9yIGNvcm5lcnNcclxuICAgICAgICBjb25zdCB4MTogbnVtYmVyID0geDAgLSBpMSArIE5vaXNlMi5vZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgeTE6IG51bWJlciA9IHkwIC0gajEgKyBOb2lzZTIub2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IHgyOiBudW1iZXIgPSB4MCAtIDEuMCArIDIuMCAqIE5vaXNlMi5vZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgeTI6IG51bWJlciA9IHkwIC0gMS4wICsgMi4wICogTm9pc2UyLm9mZnNldDtcclxuXHJcbiAgICAgICAgLy8gV29yayBvdXQgdGhlIGhhc2hlZCBncmFkaWVudCBpbmRpY2VzIG9mIHRoZSB0aHJlZSBzaW1wbGV4IGNvcm5lcnNcclxuICAgICAgICBjb25zdCBpaTogbnVtYmVyID0gaSAmIDI1NTtcclxuICAgICAgICBjb25zdCBqajogbnVtYmVyID0gaiAmIDI1NTtcclxuICAgICAgICBjb25zdCBnMDogbnVtYmVyW10gPSBOb2lzZTIuZ3JhZGllbnRbdGhpcy5wZXJtTW9kMTJbaWkgKyB0aGlzLnBlcm1bampdXV07XHJcbiAgICAgICAgY29uc3QgZzE6IG51bWJlcltdID0gTm9pc2UyLmdyYWRpZW50W3RoaXMucGVybU1vZDEyW2lpICsgaTEgKyB0aGlzLnBlcm1bamogKyBqMV1dXTtcclxuICAgICAgICBjb25zdCBnMjogbnVtYmVyW10gPSBOb2lzZTIuZ3JhZGllbnRbdGhpcy5wZXJtTW9kMTJbaWkgKyAxICsgdGhpcy5wZXJtW2pqICsgMV1dXTtcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBjb250cmlidXRpb24gZnJvbSB0aGUgdGhyZWUgY29ybmVyc1xyXG4gICAgICAgIGNvbnN0IHQwOiBudW1iZXIgPSAwLjUgLSB4MCAqIHgwIC0geTAgKiB5MDtcclxuICAgICAgICBjb25zdCBuMDogbnVtYmVyID0gdDAgPCAwID8gMC4wIDogTWF0aC5wb3codDAsIDQpICogKGcwWzBdICogeDAgKyBnMFsxXSAqIHkwKTtcclxuXHJcbiAgICAgICAgY29uc3QgdDE6IG51bWJlciA9IDAuNSAtIHgxICogeDEgLSB5MSAqIHkxO1xyXG4gICAgICAgIGNvbnN0IG4xOiBudW1iZXIgPSB0MSA8IDAgPyAwLjAgOiBNYXRoLnBvdyh0MSwgNCkgKiAoZzFbMF0gKiB4MSArIGcxWzFdICogeTEpO1xyXG5cclxuICAgICAgICBjb25zdCB0MjogbnVtYmVyID0gMC41IC0geDIgKiB4MiAtIHkyICogeTI7XHJcbiAgICAgICAgY29uc3QgbjI6IG51bWJlciA9IHQyIDwgMCA/IDAuMCA6IE1hdGgucG93KHQyLCA0KSAqIChnMlswXSAqIHgyICsgZzJbMV0gKiB5Mik7XHJcblxyXG4gICAgICAgIC8vIEFkZCBjb250cmlidXRpb25zIGZyb20gZWFjaCBjb3JuZXIgdG8gZ2V0IHRoZSBmaW5hbCBub2lzZSB2YWx1ZS5cclxuICAgICAgICAvLyBUaGUgcmVzdWx0IGlzIHNjYWxlZCB0byByZXR1cm4gdmFsdWVzIGluIHRoZSBpbnRlcnZhbCBbLTEsIDFdXHJcbiAgICAgICAgcmV0dXJuIDcwLjE0ODA1NzcwNjUzOTUyICogKG4wICsgbjEgKyBuMik7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNhbXBsZSA9IChfeDogbnVtYmVyLCBfeTogbnVtYmVyKTogbnVtYmVyID0+IHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3NhbXBsZShfeCwgX3kpO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIi8qKlxyXG4gKiBUaGlzIGlzIGFuIGFkYXB0aW9uIG9mIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2Zhc3Qtc2ltcGxleC1ub2lzZVxyXG4gKiBkb25lIGJ5IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxXHJcbiAqXHJcbiAqIEJhc2VkIG9uIGV4YW1wbGUgY29kZSBieSBTdGVmYW4gR3VzdGF2c29uIChzdGVndUBpdG4ubGl1LnNlKS5cclxuICogT3B0aW1pc2F0aW9ucyBieSBQZXRlciBFYXN0bWFuIChwZWFzdG1hbkBkcml6emxlLnN0YW5mb3JkLmVkdSkuXHJcbiAqIEJldHRlciByYW5rIG9yZGVyaW5nIG1ldGhvZCBieSBTdGVmYW4gR3VzdGF2c29uIGluIDIwMTIuXHJcbiAqXHJcbiAqIFRoaXMgY29kZSB3YXMgcGxhY2VkIGluIHRoZSBwdWJsaWMgZG9tYWluIGJ5IGl0cyBvcmlnaW5hbCBhdXRob3IsXHJcbiAqIFN0ZWZhbiBHdXN0YXZzb24uIFlvdSBtYXkgdXNlIGl0IGFzIHlvdSBzZWUgZml0LCBidXRcclxuICogYXR0cmlidXRpb24gaXMgYXBwcmVjaWF0ZWQuXHJcbiAqL1xyXG5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIC8vIFRPRE86IFRlc3RcclxuICBleHBvcnQgY2xhc3MgTm9pc2UzIGV4dGVuZHMgTm9pc2Uge1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgb2Zmc2V0OiBudW1iZXIgPSAxLjAgLyA2LjA7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBncmFkaWVudDogbnVtYmVyW11bXSA9IFtbMSwgMSwgMF0sIFstMSwgMSwgMF0sIFsxLCAtMSwgMF0sIFstMSwgLTEsIDBdLCBbMSwgMCwgMV0sIFstMSwgMCwgMV0sIFsxLCAwLCAtMV0sIFstMSwgMCwgLTFdLCBbMCwgMSwgMV0sIFswLCAtMSwgLTFdLCBbMCwgMSwgLTFdLCBbMCwgLTEsIC0xXVxyXG4gICAgXTtcclxuICAgICNzYW1wbGU6IChfeDogbnVtYmVyLCBfeTogbnVtYmVyLCBfejogbnVtYmVyKSA9PiBudW1iZXIgPSBudWxsO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKF9yYW5kb206IEZ1bmN0aW9uID0gTWF0aC5yYW5kb20pIHtcclxuICAgICAgc3VwZXIoX3JhbmRvbSk7XHJcblxyXG4gICAgICB0aGlzLiNzYW1wbGUgPSAoX3g6IG51bWJlciwgX3k6IG51bWJlciwgX3o6IG51bWJlcikgPT4ge1xyXG4gICAgICAgIC8vIFNrZXcgdGhlIGlucHV0IHNwYWNlIHRvIGRldGVybWluZSB3aGljaCBzaW1wbGV4IGNlbGwgd2UncmUgaW5cclxuICAgICAgICBjb25zdCBzOiBudW1iZXIgPSAoX3ggKyBfeSArIF96KSAvIDMuMDsgLy8gVmVyeSBuaWNlIGFuZCBzaW1wbGUgc2tldyBmYWN0b3IgZm9yIDNEXHJcbiAgICAgICAgY29uc3QgaTogbnVtYmVyID0gTWF0aC5mbG9vcihfeCArIHMpO1xyXG4gICAgICAgIGNvbnN0IGo6IG51bWJlciA9IE1hdGguZmxvb3IoX3kgKyBzKTtcclxuICAgICAgICBjb25zdCBrOiBudW1iZXIgPSBNYXRoLmZsb29yKF96ICsgcyk7XHJcbiAgICAgICAgY29uc3QgdDogbnVtYmVyID0gKGkgKyBqICsgaykgKiBOb2lzZTMub2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IFgwOiBudW1iZXIgPSBpIC0gdDsgLy8gVW5za2V3IHRoZSBjZWxsIG9yaWdpbiBiYWNrIHRvICh4LHkseikgc3BhY2VcclxuICAgICAgICBjb25zdCBZMDogbnVtYmVyID0gaiAtIHQ7XHJcbiAgICAgICAgY29uc3QgWjA6IG51bWJlciA9IGsgLSB0O1xyXG4gICAgICAgIGNvbnN0IHgwOiBudW1iZXIgPSBfeCAtIFgwOyAvLyBUaGUgeCx5LHogZGlzdGFuY2VzIGZyb20gdGhlIGNlbGwgb3JpZ2luXHJcbiAgICAgICAgY29uc3QgeTA6IG51bWJlciA9IF95IC0gWTA7XHJcbiAgICAgICAgY29uc3QgejA6IG51bWJlciA9IF96IC0gWjA7XHJcblxyXG4gICAgICAgIC8vIERldGVyaW5lIHdoaWNoIHNpbXBsZXggd2UgYXJlIGluXHJcbiAgICAgICAgbGV0IGkxOiBudW1iZXIsIGoxOiBudW1iZXIsIGsxOiBudW1iZXIgLy8gT2Zmc2V0cyBmb3Igc2Vjb25kIGNvcm5lciBvZiBzaW1wbGV4IGluIChpLGosaykgY29vcmRzXHJcbiAgICAgICAgICA7XHJcbiAgICAgICAgbGV0IGkyOiBudW1iZXIsIGoyOiBudW1iZXIsIGsyOiBudW1iZXIgLy8gT2Zmc2V0cyBmb3IgdGhpcmQgY29ybmVyIG9mIHNpbXBsZXggaW4gKGksaixrKSBjb29yZHNcclxuICAgICAgICAgIDtcclxuICAgICAgICBpZiAoeDAgPj0geTApIHtcclxuICAgICAgICAgIGlmICh5MCA+PSB6MCkge1xyXG4gICAgICAgICAgICBpMSA9IGkyID0gajIgPSAxO1xyXG4gICAgICAgICAgICBqMSA9IGsxID0gazIgPSAwO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICh4MCA+PSB6MCkge1xyXG4gICAgICAgICAgICBpMSA9IGkyID0gazIgPSAxO1xyXG4gICAgICAgICAgICBqMSA9IGsxID0gajIgPSAwO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgazEgPSBpMiA9IGsyID0gMTtcclxuICAgICAgICAgICAgaTEgPSBqMSA9IGoyID0gMDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYgKHkwIDwgejApIHtcclxuICAgICAgICAgICAgazEgPSBqMiA9IGsyID0gMTtcclxuICAgICAgICAgICAgaTEgPSBqMSA9IGkyID0gMDtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoeDAgPCB6MCkge1xyXG4gICAgICAgICAgICBqMSA9IGoyID0gazIgPSAxO1xyXG4gICAgICAgICAgICBpMSA9IGsxID0gaTIgPSAwO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgajEgPSBpMiA9IGoyID0gMTtcclxuICAgICAgICAgICAgaTEgPSBrMSA9IGsyID0gMDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHgxOiBudW1iZXIgPSB4MCAtIGkxICsgTm9pc2UzLm9mZnNldDsgLy8gT2Zmc2V0cyBmb3Igc2Vjb25kIGNvcm5lciBpbiAoeCx5LHopIGNvb3Jkc1xyXG4gICAgICAgIGNvbnN0IHkxOiBudW1iZXIgPSB5MCAtIGoxICsgTm9pc2UzLm9mZnNldDtcclxuICAgICAgICBjb25zdCB6MTogbnVtYmVyID0gejAgLSBrMSArIE5vaXNlMy5vZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgeDI6IG51bWJlciA9IHgwIC0gaTIgKyAyLjAgKiBOb2lzZTMub2Zmc2V0OyAvLyBPZmZzZXRzIGZvciB0aGlyZCBjb3JuZXIgaW4gKHgseSx6KSBjb29yZHNcclxuICAgICAgICBjb25zdCB5MjogbnVtYmVyID0geTAgLSBqMiArIDIuMCAqIE5vaXNlMy5vZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgejI6IG51bWJlciA9IHowIC0gazIgKyAyLjAgKiBOb2lzZTMub2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IHgzOiBudW1iZXIgPSB4MCAtIDEuMCArIDMuMCAqIE5vaXNlMy5vZmZzZXQ7IC8vIE9mZnNldHMgZm9yIGxhc3QgY29ybmVyIGluICh4LHkseikgY29vcmRzXHJcbiAgICAgICAgY29uc3QgeTM6IG51bWJlciA9IHkwIC0gMS4wICsgMy4wICogTm9pc2UzLm9mZnNldDtcclxuICAgICAgICBjb25zdCB6MzogbnVtYmVyID0gejAgLSAxLjAgKyAzLjAgKiBOb2lzZTMub2Zmc2V0O1xyXG5cclxuICAgICAgICAvLyBXb3JrIDpudW1iZXJ1dCB0aGUgaGFzaGVkIGdyYWRpZW50IGluZGljZXMgb2YgdGhlIGZvdXIgc2ltcGxleCBjb3JuZXJzXHJcbiAgICAgICAgY29uc3QgaWk6IG51bWJlciA9IGkgJiAyNTU7XHJcbiAgICAgICAgY29uc3Qgamo6IG51bWJlciA9IGogJiAyNTU7XHJcbiAgICAgICAgY29uc3Qga2s6IG51bWJlciA9IGsgJiAyNTU7XHJcbiAgICAgICAgY29uc3QgZzA6IG51bWJlcltdID0gTm9pc2UzLmdyYWRpZW50W3RoaXMucGVybU1vZDEyW2lpICsgdGhpcy5wZXJtW2pqICsgdGhpcy5wZXJtW2trXV1dXTtcclxuICAgICAgICBjb25zdCBnMTogbnVtYmVyW10gPSBOb2lzZTMuZ3JhZGllbnRbdGhpcy5wZXJtTW9kMTJbaWkgKyBpMSArIHRoaXMucGVybVtqaiArIGoxICsgdGhpcy5wZXJtW2trICsgazFdXV1dO1xyXG4gICAgICAgIGNvbnN0IGcyOiBudW1iZXJbXSA9IE5vaXNlMy5ncmFkaWVudFt0aGlzLnBlcm1Nb2QxMltpaSArIGkyICsgdGhpcy5wZXJtW2pqICsgajIgKyB0aGlzLnBlcm1ba2sgKyBrMl1dXV07XHJcbiAgICAgICAgY29uc3QgZzM6IG51bWJlcltdID0gTm9pc2UzLmdyYWRpZW50W3RoaXMucGVybU1vZDEyW2lpICsgMSArIHRoaXMucGVybVtqaiArIDEgKyB0aGlzLnBlcm1ba2sgKyAxXV1dXTtcclxuXHJcbiAgICAgICAgLy8gQ2FsY3U6bnVtYmVyYXRlIHRoZSBjb250cmlidXRpb24gZnJvbSB0aGUgZm91ciBjb3JuZXJzXHJcbiAgICAgICAgY29uc3QgdDA6IG51bWJlciA9IDAuNSAtIHgwICogeDAgLSB5MCAqIHkwIC0gejAgKiB6MDtcclxuICAgICAgICBjb25zdCBuMDogbnVtYmVyID0gdDAgPCAwXHJcbiAgICAgICAgICA/IDAuMFxyXG4gICAgICAgICAgOiBNYXRoLnBvdyh0MCwgNCkgKiAoZzBbMF0gKiB4MCArIGcwWzFdICogeTAgKyBnMFsyXSAqIHowKTtcclxuICAgICAgICBjb25zdCB0MTogbnVtYmVyID0gMC41IC0geDEgKiB4MSAtIHkxICogeTEgLSB6MSAqIHoxO1xyXG4gICAgICAgIGNvbnN0IG4xOiBudW1iZXIgPSB0MSA8IDBcclxuICAgICAgICAgID8gMC4wXHJcbiAgICAgICAgICA6IE1hdGgucG93KHQxLCA0KSAqIChnMVswXSAqIHgxICsgZzFbMV0gKiB5MSArIGcxWzJdICogejEpO1xyXG4gICAgICAgIGNvbnN0IHQyOiBudW1iZXIgPSAwLjUgLSB4MiAqIHgyIC0geTIgKiB5MiAtIHoyICogejI7XHJcbiAgICAgICAgY29uc3QgbjI6IG51bWJlciA9IHQyIDwgMFxyXG4gICAgICAgICAgPyAwLjBcclxuICAgICAgICAgIDogTWF0aC5wb3codDIsIDQpICogKGcyWzBdICogeDIgKyBnMlsxXSAqIHkyICsgZzJbMl0gKiB6Mik7XHJcbiAgICAgICAgY29uc3QgdDM6IG51bWJlciA9IDAuNSAtIHgzICogeDMgLSB5MyAqIHkzIC0gejMgKiB6MztcclxuICAgICAgICBjb25zdCBuMzogbnVtYmVyID0gdDMgPCAwXHJcbiAgICAgICAgICA/IDAuMFxyXG4gICAgICAgICAgOiBNYXRoLnBvdyh0MywgNCkgKiAoZzNbMF0gKiB4MyArIGczWzFdICogeTMgKyBnM1syXSAqIHozKTtcclxuXHJcbiAgICAgICAgLy8gQWRkIGNvbnRyaWJ1dGlvbnMgZnJvbSBlYWNoIGNvcm5lciB0byBnZXQgdGhlIGZpbmFsIG5vaXNlIHZhbHVlLlxyXG4gICAgICAgIC8vIFRoZSByZXN1bHQgaXMgc2NhbGVkIHRvIHN0YXkganVzdCBpbnNpZGUgWy0xLDFdXHJcbiAgICAgICAgcmV0dXJuIDk0LjY4NDkzMTUwNjgxOTcyICogKG4wICsgbjEgKyBuMiArIG4zKTtcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2FtcGxlID0gKF94OiBudW1iZXIsIF95OiBudW1iZXIsIF96OiBudW1iZXIpOiBudW1iZXIgPT4ge1xyXG4gICAgICByZXR1cm4gdGhpcy4jc2FtcGxlKF94LCBfeSwgX3opO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIi8qKlxyXG4gKiBUaGlzIGlzIGFuIGFkYXB0aW9uIG9mIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2Zhc3Qtc2ltcGxleC1ub2lzZVxyXG4gKiBkb25lIGJ5IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxXHJcbiAqXHJcbiAqIEJhc2VkIG9uIGV4YW1wbGUgY29kZSBieSBTdGVmYW4gR3VzdGF2c29uIChzdGVndUBpdG4ubGl1LnNlKS5cclxuICogT3B0aW1pc2F0aW9ucyBieSBQZXRlciBFYXN0bWFuIChwZWFzdG1hbkBkcml6emxlLnN0YW5mb3JkLmVkdSkuXHJcbiAqIEJldHRlciByYW5rIG9yZGVyaW5nIG1ldGhvZCBieSBTdGVmYW4gR3VzdGF2c29uIGluIDIwMTIuXHJcbiAqXHJcbiAqIFRoaXMgY29kZSB3YXMgcGxhY2VkIGluIHRoZSBwdWJsaWMgZG9tYWluIGJ5IGl0cyBvcmlnaW5hbCBhdXRob3IsXHJcbiAqIFN0ZWZhbiBHdXN0YXZzb24uIFlvdSBtYXkgdXNlIGl0IGFzIHlvdSBzZWUgZml0LCBidXRcclxuICogYXR0cmlidXRpb24gaXMgYXBwcmVjaWF0ZWQuXHJcbiAqL1xyXG5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLy8gVE9ETzogVGVzdFxyXG4gIGV4cG9ydCBjbGFzcyBOb2lzZTQgZXh0ZW5kcyBOb2lzZSB7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBvZmZzZXQ6IG51bWJlciA9ICg1LjAgLSBNYXRoLnNxcnQoNS4wKSkgLyAyMC4wO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ3JhZGllbnQ6IG51bWJlcltdW10gPSBbWzAsIDEsIDEsIDFdLCBbMCwgMSwgMSwgLTFdLCBbMCwgMSwgLTEsIDFdLCBbMCwgMSwgLTEsIC0xXSwgWzAsIC0xLCAxLCAxXSwgWzAsIC0xLCAxLCAtMV0sIFswLCAtMSwgLTEsIDFdLCBbMCwgLTEsIC0xLCAtMV0sIFsxLCAwLCAxLCAxXSwgWzEsIDAsIDEsIC0xXSwgWzEsIDAsIC0xLCAxXSwgWzEsIDAsIC0xLCAtMV0sIFstMSwgMCwgMSwgMV0sIFstMSwgMCwgMSwgLTFdLCBbLTEsIDAsIC0xLCAxXSwgWy0xLCAwLCAtMSwgLTFdLCBbMSwgMSwgMCwgMV0sIFsxLCAxLCAwLCAtMV0sIFsxLCAtMSwgMCwgMV0sIFsxLCAtMSwgMCwgLTFdLCBbLTEsIDEsIDAsIDFdLCBbLTEsIDEsIDAsIC0xXSwgWy0xLCAtMSwgMCwgMV0sIFstMSwgLTEsIDAsIC0xXSwgWzEsIDEsIDEsIDBdLCBbMSwgMSwgLTEsIDBdLCBbMSwgLTEsIDEsIDBdLCBbMSwgLTEsIC0xLCAwXSwgWy0xLCAxLCAxLCAwXSwgWy0xLCAxLCAtMSwgMF0sIFstMSwgLTEsIDEsIDBdLCBbLTEsIC0xLCAtMSwgMF1dO1xyXG4gICAgI3NhbXBsZTogKF94OiBudW1iZXIsIF95OiBudW1iZXIsIF96OiBudW1iZXIsIF93OiBudW1iZXIpID0+IG51bWJlciA9IG51bGw7XHJcblxyXG4gICAgY29uc3RydWN0b3IoX3JhbmRvbTogRnVuY3Rpb24gPSBNYXRoLnJhbmRvbSkge1xyXG4gICAgICBzdXBlcihfcmFuZG9tKVxyXG5cclxuICAgICAgdGhpcy4jc2FtcGxlID0gKHg6IG51bWJlciwgeTogbnVtYmVyLCB6OiBudW1iZXIsIHc6IG51bWJlcik6IG51bWJlciA9PiB7XHJcbiAgICAgICAgLy8gU2tldyB0aGUgKHgseSx6LHcpIHNwYWNlIHRvIGRldGVybWluZSB3aGljaCBjZWxsIG9mIDI0IHNpbXBsaWNlcyB3ZSdyZSBpblxyXG4gICAgICAgIGNvbnN0IHM6IG51bWJlciA9ICh4ICsgeSArIHogKyB3KSAqIChNYXRoLnNxcnQoNS4wKSAtIDEuMCkgLyA0LjA7IC8vIEZhY3RvciBmb3IgNEQgc2tld2luZ1xyXG4gICAgICAgIGNvbnN0IGk6IG51bWJlciA9IE1hdGguZmxvb3IoeCArIHMpO1xyXG4gICAgICAgIGNvbnN0IGo6IG51bWJlciA9IE1hdGguZmxvb3IoeSArIHMpO1xyXG4gICAgICAgIGNvbnN0IGs6IG51bWJlciA9IE1hdGguZmxvb3IoeiArIHMpO1xyXG4gICAgICAgIGNvbnN0IGw6IG51bWJlciA9IE1hdGguZmxvb3IodyArIHMpO1xyXG4gICAgICAgIGNvbnN0IHQ6IG51bWJlciA9IChpICsgaiArIGsgKyBsKSAqIE5vaXNlNC5vZmZzZXQ7IC8vIEZhY3RvciBmb3IgNEQgdW5za2V3aW5nXHJcbiAgICAgICAgY29uc3QgWDA6IG51bWJlciA9IGkgLSB0OyAvLyBVbnNrZXcgdGhlIGNlbGwgb3JpZ2luIGJhY2sgdG8gKHgseSx6LHcpIHNwYWNlXHJcbiAgICAgICAgY29uc3QgWTA6IG51bWJlciA9IGogLSB0O1xyXG4gICAgICAgIGNvbnN0IFowOiBudW1iZXIgPSBrIC0gdDtcclxuICAgICAgICBjb25zdCBXMDogbnVtYmVyID0gbCAtIHQ7XHJcbiAgICAgICAgY29uc3QgeDA6IG51bWJlciA9IHggLSBYMDsgLy8gVGhlIHgseSx6LHcgZGlzdGFuY2VzIGZyb20gdGhlIGNlbGwgb3JpZ2luXHJcbiAgICAgICAgY29uc3QgeTA6IG51bWJlciA9IHkgLSBZMDtcclxuICAgICAgICBjb25zdCB6MDogbnVtYmVyID0geiAtIFowO1xyXG4gICAgICAgIGNvbnN0IHcwOiBudW1iZXIgPSB3IC0gVzA7XHJcblxyXG4gICAgICAgIC8vIFRvIGZpbmQgb3V0IHdoaWNoIG9mIHRoZSAyNCBwb3NzaWJsZSBzaW1wbGljZXMgd2UncmUgaW4sIHdlIG5lZWQgdG8gZGV0ZXJtaW5lIHRoZVxyXG4gICAgICAgIC8vIG1hZ25pdHVkZSBvcmRlcmluZyBvZiB4MCwgeTAsIHowIGFuZCB3MC4gU2l4IHBhaXItd2lzZSBjb21wYXJpc29ucyBhcmUgcGVyZm9ybWVkIGJldHdlZW5cclxuICAgICAgICAvLyBlYWNoIHBvc3NpYmxlIHBhaXIgb2YgdGhlIGZvdXIgY29vcmRpbmF0ZXMsIGFuZCB0aGUgcmVzdWx0cyBhcmUgdXNlZCB0byByYW5rIHRoZSBudW1iZXJzLlxyXG4gICAgICAgIGxldCByYW5reDogbnVtYmVyID0gMDtcclxuICAgICAgICBsZXQgcmFua3k6IG51bWJlciA9IDA7XHJcbiAgICAgICAgbGV0IHJhbmt6OiBudW1iZXIgPSAwO1xyXG4gICAgICAgIGxldCByYW5rdzogbnVtYmVyID0gMDtcclxuICAgICAgICBpZiAoeDAgPiB5MCkgcmFua3grKztcclxuICAgICAgICBlbHNlIHJhbmt5Kys7XHJcbiAgICAgICAgaWYgKHgwID4gejApIHJhbmt4Kys7XHJcbiAgICAgICAgZWxzZSByYW5reisrO1xyXG4gICAgICAgIGlmICh4MCA+IHcwKSByYW5reCsrO1xyXG4gICAgICAgIGVsc2UgcmFua3crKztcclxuICAgICAgICBpZiAoeTAgPiB6MCkgcmFua3krKztcclxuICAgICAgICBlbHNlIHJhbmt6Kys7XHJcbiAgICAgICAgaWYgKHkwID4gdzApIHJhbmt5Kys7XHJcbiAgICAgICAgZWxzZSByYW5rdysrO1xyXG4gICAgICAgIGlmICh6MCA+IHcwKSByYW5reisrO1xyXG4gICAgICAgIGVsc2UgcmFua3crKztcclxuXHJcbiAgICAgICAgLy8gc2ltcGxleFtjXSBpcyBhIDQtdmVjdG9yIHdpdGggdGhlIG51bWJlcnMgMCwgMSwgMiBhbmQgMyBpbiBzb21lIG9yZGVyLlxyXG4gICAgICAgIC8vIE1hbnkgdmFsdWVzIG9mIGMgd2lsbCBuZXZlciBvY2N1ciwgc2luY2UgZS5nLiB4Pnk+ej53IG1ha2VzIHg8eiwgeTx3IGFuZCB4PHdcclxuICAgICAgICAvLyBpbXBvc3NpYmxlLiBPbmx5IHRoZSAyNCBpbmRpY2VzIHdoaWNoIGhhdmUgbm9uLXplcm8gZW50cmllcyBtYWtlIGFueSBzZW5zZS5cclxuICAgICAgICAvLyBXZSB1c2UgYSB0aHJlc2hvbGRpbmcgdG8gc2V0IHRoZSBjb29yZGluYXRlcyBpbiB0dXJuIGZyb20gdGhlIGxhcmdlc3QgbWFnbml0dWRlLlxyXG4gICAgICAgIC8vIFJhbmsgMyBkZW5vdGVzIHRoZSBsYXJnZXN0IGNvb3JkaW5hdGUuXHJcbiAgICAgICAgY29uc3QgaTE6IG51bWJlciA9IHJhbmt4ID49IDMgPyAxIDogMDtcclxuICAgICAgICBjb25zdCBqMTogbnVtYmVyID0gcmFua3kgPj0gMyA/IDEgOiAwO1xyXG4gICAgICAgIGNvbnN0IGsxOiBudW1iZXIgPSByYW5reiA+PSAzID8gMSA6IDA7XHJcbiAgICAgICAgY29uc3QgbDE6IG51bWJlciA9IHJhbmt3ID49IDMgPyAxIDogMDtcclxuICAgICAgICAvLyBSYW5rIDogMiBkZW5vdGVzIHRoZSBzZWNvbmQgbGFyZ2VzdCBjb29yZGluYXRlLlxyXG4gICAgICAgIGNvbnN0IGkyOiBudW1iZXIgPSByYW5reCA+PSAyID8gMSA6IDA7XHJcbiAgICAgICAgY29uc3QgajI6IG51bWJlciA9IHJhbmt5ID49IDIgPyAxIDogMDtcclxuICAgICAgICBjb25zdCBrMjogbnVtYmVyID0gcmFua3ogPj0gMiA/IDEgOiAwO1xyXG4gICAgICAgIGNvbnN0IGwyOiBudW1iZXIgPSByYW5rdyA+PSAyID8gMSA6IDA7XHJcbiAgICAgICAgLy8gUmFuayA6IDEgZGVub3RlcyB0aGUgc2Vjb25kIHNtYWxsZXN0IGNvb3JkaW5hdGUuXHJcbiAgICAgICAgY29uc3QgaTM6IG51bWJlciA9IHJhbmt4ID49IDEgPyAxIDogMDtcclxuICAgICAgICBjb25zdCBqMzogbnVtYmVyID0gcmFua3kgPj0gMSA/IDEgOiAwO1xyXG4gICAgICAgIGNvbnN0IGszOiBudW1iZXIgPSByYW5reiA+PSAxID8gMSA6IDA7XHJcbiAgICAgICAgY29uc3QgbDM6IG51bWJlciA9IHJhbmt3ID49IDEgPyAxIDogMDtcclxuXHJcbiAgICAgICAgLy8gVGhlIGZpZnRoIGNvcm5lciBoYXMgYWxsIGNvb3JkaW5hdGUgb2Zmc2V0cyA9IDEsIHNvIG5vIG5lZWQgdG8gY29tcHV0ZSB0aGF0LlxyXG4gICAgICAgIGNvbnN0IHgxOiBudW1iZXIgPSB4MCAtIGkxICsgTm9pc2U0Lm9mZnNldDsgLy8gT2Zmc2V0cyBmb3Igc2Vjb25kIGNvcm5lciBpbiAoeCx5LHosdykgY29vcmRzXHJcbiAgICAgICAgY29uc3QgeTE6IG51bWJlciA9IHkwIC0gajEgKyBOb2lzZTQub2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IHoxOiBudW1iZXIgPSB6MCAtIGsxICsgTm9pc2U0Lm9mZnNldDtcclxuICAgICAgICBjb25zdCB3MTogbnVtYmVyID0gdzAgLSBsMSArIE5vaXNlNC5vZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgeDI6IG51bWJlciA9IHgwIC0gaTIgKyAyLjAgKiBOb2lzZTQub2Zmc2V0OyAvLyBPZmZzZXRzIGZvciB0aGlyZCBjb3JuZXIgaW4gKHgseSx6LHcpIGNvb3Jkc1xyXG4gICAgICAgIGNvbnN0IHkyOiBudW1iZXIgPSB5MCAtIGoyICsgMi4wICogTm9pc2U0Lm9mZnNldDtcclxuICAgICAgICBjb25zdCB6MjogbnVtYmVyID0gejAgLSBrMiArIDIuMCAqIE5vaXNlNC5vZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgdzI6IG51bWJlciA9IHcwIC0gbDIgKyAyLjAgKiBOb2lzZTQub2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IHgzOiBudW1iZXIgPSB4MCAtIGkzICsgMy4wICogTm9pc2U0Lm9mZnNldDsgLy8gT2Zmc2V0cyBmb3IgZm91cnRoIGNvcm5lciBpbiAoeCx5LHosdykgY29vcmRzXHJcbiAgICAgICAgY29uc3QgeTM6IG51bWJlciA9IHkwIC0gajMgKyAzLjAgKiBOb2lzZTQub2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IHozOiBudW1iZXIgPSB6MCAtIGszICsgMy4wICogTm9pc2U0Lm9mZnNldDtcclxuICAgICAgICBjb25zdCB3MzogbnVtYmVyID0gdzAgLSBsMyArIDMuMCAqIE5vaXNlNC5vZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgeDQ6IG51bWJlciA9IHgwIC0gMS4wICsgNC4wICogTm9pc2U0Lm9mZnNldDsgLy8gT2Zmc2V0cyBmb3IgbGFzdCBjb3JuZXIgaW4gKHgseSx6LHcpIGNvb3Jkc1xyXG4gICAgICAgIGNvbnN0IHk0OiBudW1iZXIgPSB5MCAtIDEuMCArIDQuMCAqIE5vaXNlNC5vZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgejQ6IG51bWJlciA9IHowIC0gMS4wICsgNC4wICogTm9pc2U0Lm9mZnNldDtcclxuICAgICAgICBjb25zdCB3NDogbnVtYmVyID0gdzAgLSAxLjAgKyA0LjAgKiBOb2lzZTQub2Zmc2V0O1xyXG5cclxuICAgICAgICAvLyBXb3JrIG91dCB0aGUgaGFzaGVkIGdyYWRpZW50IGluZGljZXMgb2YgdGhlIGZpdmUgc2ltcGxleCBjb3JuZXJzXHJcbiAgICAgICAgY29uc3QgaWk6IG51bWJlciA9IGkgJiAyNTU7XHJcbiAgICAgICAgY29uc3Qgamo6IG51bWJlciA9IGogJiAyNTU7XHJcbiAgICAgICAgY29uc3Qga2s6IG51bWJlciA9IGsgJiAyNTU7XHJcbiAgICAgICAgY29uc3QgbGw6IG51bWJlciA9IGwgJiAyNTU7XHJcbiAgICAgICAgY29uc3QgZzA6IG51bWJlcltdID0gTm9pc2U0LmdyYWRpZW50W1xyXG4gICAgICAgICAgdGhpcy5wZXJtW2lpICsgdGhpcy5wZXJtW2pqICsgdGhpcy5wZXJtW2trICsgdGhpcy5wZXJtW2xsXV1dXSAlXHJcbiAgICAgICAgICAzMlxyXG4gICAgICAgIF07XHJcbiAgICAgICAgY29uc3QgZzE6IG51bWJlcltdID0gTm9pc2U0LmdyYWRpZW50W1xyXG4gICAgICAgICAgdGhpcy5wZXJtW1xyXG4gICAgICAgICAgaWkgKyBpMSArIHRoaXMucGVybVtqaiArIGoxICsgdGhpcy5wZXJtW2trICsgazEgKyB0aGlzLnBlcm1bbGwgKyBsMV1dXVxyXG4gICAgICAgICAgXSAlIDMyXHJcbiAgICAgICAgXTtcclxuICAgICAgICBjb25zdCBnMjogbnVtYmVyW10gPSBOb2lzZTQuZ3JhZGllbnRbXHJcbiAgICAgICAgICB0aGlzLnBlcm1bXHJcbiAgICAgICAgICBpaSArIGkyICsgdGhpcy5wZXJtW2pqICsgajIgKyB0aGlzLnBlcm1ba2sgKyBrMiArIHRoaXMucGVybVtsbCArIGwyXV1dXHJcbiAgICAgICAgICBdICUgMzJcclxuICAgICAgICBdO1xyXG4gICAgICAgIGNvbnN0IGczOiBudW1iZXJbXSA9IE5vaXNlNC5ncmFkaWVudFtcclxuICAgICAgICAgIHRoaXMucGVybVtcclxuICAgICAgICAgIGlpICsgaTMgKyB0aGlzLnBlcm1bamogKyBqMyArIHRoaXMucGVybVtrayArIGszICsgdGhpcy5wZXJtW2xsICsgbDNdXV1cclxuICAgICAgICAgIF0gJSAzMlxyXG4gICAgICAgIF07XHJcbiAgICAgICAgY29uc3QgZzQ6IG51bWJlcltdID0gTm9pc2U0LmdyYWRpZW50W1xyXG4gICAgICAgICAgdGhpcy5wZXJtW1xyXG4gICAgICAgICAgaWkgKyAxICsgdGhpcy5wZXJtW2pqICsgMSArIHRoaXMucGVybVtrayArIDEgKyB0aGlzLnBlcm1bbGwgKyAxXV1dXHJcbiAgICAgICAgICBdICUgMzJcclxuICAgICAgICBdO1xyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGNvbnRyaWJ1dGlvbiBmcm9tIHRoZSBmaXZlIGNvcm5lcnNcclxuICAgICAgICBjb25zdCB0MDogbnVtYmVyID0gMC41IC0geDAgKiB4MCAtIHkwICogeTAgLSB6MCAqIHowIC0gdzAgKiB3MDtcclxuICAgICAgICBjb25zdCBuMDogbnVtYmVyID0gdDAgPCAwXHJcbiAgICAgICAgICA/IDAuMFxyXG4gICAgICAgICAgOiBNYXRoLnBvdyh0MCwgNCkgKiAoZzBbMF0gKiB4MCArIGcwWzFdICogeTAgKyBnMFsyXSAqIHowICsgZzBbM10gKiB3MCk7XHJcbiAgICAgICAgY29uc3QgdDE6IG51bWJlciA9IDAuNSAtIHgxICogeDEgLSB5MSAqIHkxIC0gejEgKiB6MSAtIHcxICogdzE7XHJcbiAgICAgICAgY29uc3QgbjE6IG51bWJlciA9IHQxIDwgMFxyXG4gICAgICAgICAgPyAwLjBcclxuICAgICAgICAgIDogTWF0aC5wb3codDEsIDQpICogKGcxWzBdICogeDEgKyBnMVsxXSAqIHkxICsgZzFbMl0gKiB6MSArIGcxWzNdICogdzEpO1xyXG4gICAgICAgIGNvbnN0IHQyOiBudW1iZXIgPSAwLjUgLSB4MiAqIHgyIC0geTIgKiB5MiAtIHoyICogejIgLSB3MiAqIHcyO1xyXG4gICAgICAgIGNvbnN0IG4yOiBudW1iZXIgPSB0MiA8IDBcclxuICAgICAgICAgID8gMC4wXHJcbiAgICAgICAgICA6IE1hdGgucG93KHQyLCA0KSAqIChnMlswXSAqIHgyICsgZzJbMV0gKiB5MiArIGcyWzJdICogejIgKyBnMlszXSAqIHcyKTtcclxuICAgICAgICBjb25zdCB0MzogbnVtYmVyID0gMC41IC0geDMgKiB4MyAtIHkzICogeTMgLSB6MyAqIHozIC0gdzMgKiB3MztcclxuICAgICAgICBjb25zdCBuMzogbnVtYmVyID0gdDMgPCAwXHJcbiAgICAgICAgICA/IDAuMFxyXG4gICAgICAgICAgOiBNYXRoLnBvdyh0MywgNCkgKiAoZzNbMF0gKiB4MyArIGczWzFdICogeTMgKyBnM1syXSAqIHozICsgZzNbM10gKiB3Myk7XHJcbiAgICAgICAgY29uc3QgdDQ6IG51bWJlciA9IDAuNSAtIHg0ICogeDQgLSB5NCAqIHk0IC0gejQgKiB6NCAtIHc0ICogdzQ7XHJcbiAgICAgICAgY29uc3QgbjQ6IG51bWJlciA9IHQ0IDwgMFxyXG4gICAgICAgICAgPyAwLjBcclxuICAgICAgICAgIDogTWF0aC5wb3codDQsIDQpICogKGc0WzBdICogeDQgKyBnNFsxXSAqIHk0ICsgZzRbMl0gKiB6NCArIGc0WzNdICogdzQpO1xyXG5cclxuICAgICAgICAvLyBTdW0gdXAgYW5kIHNjYWxlIHRoZSByZXN1bHQgdG8gY292ZXIgdGhlIHJhbmdlIFstMSwxXVxyXG4gICAgICAgIHJldHVybiA3Mi4zNzg1NTc2NTE1MzY2NSAqIChuMCArIG4xICsgbjIgKyBuMyArIG40KTtcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2FtcGxlID0gKF94OiBudW1iZXIsIF95OiBudW1iZXIsIF96OiBudW1iZXIsIF93OiBudW1iZXIpOiBudW1iZXIgPT4ge1xyXG4gICAgICByZXR1cm4gdGhpcy4jc2FtcGxlKF94LCBfeSwgX3osIF93KTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBDbGFzcyBmb3IgY3JlYXRpbmcgcmFuZG9tIHZhbHVlcywgc3VwcG9ydGluZyBKYXZhc2NyaXB0J3MgTWF0aC5yYW5kb20gYW5kIGEgZGV0ZXJtaW5pc3RpZyBwc2V1ZG8tcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgKFBSTkcpIFxyXG4gICAqIHRoYXQgY2FuIGJlIGZlZCB3aXRoIGEgc2VlZCBhbmQgdGhlbiByZXR1cm5zIGEgcmVwcm9kdWNhYmxlIHNldCBvZiByYW5kb20gbnVtYmVycyAoaWYgdGhlIHByZWNpc2lvbiBvZiBKYXZhc2NyaXB0IGFsbG93cykgXHJcbiAgICogXHJcbiAgICogQGF1dGhvciBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBSYW5kb20ge1xyXG4gICAgcHVibGljIHN0YXRpYyBkZWZhdWx0OiBSYW5kb20gPSBuZXcgUmFuZG9tKCk7XHJcbiAgICBwcml2YXRlIGdlbmVyYXRlOiBGdW5jdGlvbiA9IE1hdGgucmFuZG9tO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHtAbGluayBSYW5kb219LiBcclxuICAgICAqIElmIGEgc2VlZCBpcyBnaXZlbiwgTEZJQjQgaXMgdXNlZCBhcyBnZW5lcmF0b3IsIHJlcHJvZHVjaW5nIGEgc2VyaWVzIG9mIG51bWJlcnMgZnJvbSB0aGF0IHNlZWQuXHJcbiAgICAgKiBJZiBhIGZ1bmN0aW9uIHByb2R1Y2luZyB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAxIGlzIGdpdmVuLCBpdCB3aWxsIGJlIHVzZWQgYXMgZ2VuZXJhdG9yLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihfc2VlZE9yRnVuY3Rpb24/OiBudW1iZXIgfCBGdW5jdGlvbikge1xyXG4gICAgICBpZiAoX3NlZWRPckZ1bmN0aW9uIGluc3RhbmNlb2YgRnVuY3Rpb24pXHJcbiAgICAgICAgdGhpcy5nZW5lcmF0ZSA9IF9zZWVkT3JGdW5jdGlvbjtcclxuICAgICAgZWxzZSBpZiAoX3NlZWRPckZ1bmN0aW9uID09IHVuZGVmaW5lZClcclxuICAgICAgICB0aGlzLmdlbmVyYXRlID0gTWF0aC5yYW5kb207XHJcbiAgICAgIGVsc2VcclxuICAgICAgICAvL0B0cy1pZ25vcmVcclxuICAgICAgICB0aGlzLmdlbmVyYXRlID0gbmV3IExGSUI0KF9zZWVkT3JGdW5jdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbm9ybWVkIHJhbmRvbSBudW1iZXIsIHRodXMgaW4gdGhlIHJhbmdlIG9mIFswLCAxW1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Tm9ybSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHJhbmRvbSBudW1iZXIgaW4gdGhlIHJhbmdlIG9mIGdpdmVuIFtfbWluLCBfbWF4W1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0UmFuZ2UoX21pbjogbnVtYmVyLCBfbWF4OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gX21pbiArIHRoaXMuZ2VuZXJhdGUoKSAqIChfbWF4IC0gX21pbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcmFuZG9tIGludGVnZXIgbnVtYmVyIGluIHRoZSByYW5nZSBvZiBnaXZlbiBmbG9vcmVkIFtfbWluLCBfbWF4W1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0UmFuZ2VGbG9vcmVkKF9taW46IG51bWJlciwgX21heDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy5nZXRSYW5nZShfbWluLCBfbWF4KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgb3IgZmFsc2UgcmFuZG9tbHlcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEJvb2xlYW4oKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlKCkgPCAwLjU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIC0xIG9yIDEgcmFuZG9tbHlcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFNpZ24oKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2V0Qm9vbGVhbigpID8gMSA6IC0xO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHJhbmRvbWx5IHNlbGVjdGVkIGluZGV4IGludG8gdGhlIGdpdmVuIGFycmF5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRJbmRleDxUPihfYXJyYXk6IEFycmF5PFQ+KTogbnVtYmVyIHtcclxuICAgICAgaWYgKF9hcnJheS5sZW5ndGggPiAwKVxyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFJhbmdlRmxvb3JlZCgwLCBfYXJyYXkubGVuZ3RoKTtcclxuICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHJhbmRvbWx5IHNlbGVjdGVkIGVsZW1lbnQgb2YgdGhlIGdpdmVuIGFycmF5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRFbGVtZW50PFQ+KF9hcnJheTogQXJyYXk8VD4pOiBUIHtcclxuICAgICAgaWYgKF9hcnJheS5sZW5ndGggPiAwKVxyXG4gICAgICAgIHJldHVybiBfYXJyYXlbdGhpcy5nZXRJbmRleChfYXJyYXkpXTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgcmFuZG9tbHkgc2VsZWN0ZWQgZWxlbWVudCBmcm9tIHRoZSBnaXZlbiBhcnJheSBhbmQgcmV0dXJucyBpdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3BsaWNlPFQ+KF9hcnJheTogQXJyYXk8VD4pOiBUIHtcclxuICAgICAgcmV0dXJuIF9hcnJheS5zcGxpY2UodGhpcy5nZXRJbmRleChfYXJyYXkpLCAxKVswXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSByYW5kb21seSBzZWxlY3RlZCBrZXkgZnJvbSB0aGUgZ2l2ZW4gTWFwLWluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRLZXk8VCwgVT4oX21hcDogTWFwPFQsIFU+KTogVCB7XHJcbiAgICAgIGxldCBrZXlzOiBHZW5lcmFsID0gQXJyYXkuZnJvbShfbWFwLmtleXMoKSk7XHJcbiAgICAgIHJldHVybiBrZXlzW3RoaXMuZ2V0SW5kZXgoa2V5cyldO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHJhbmRvbWx5IHNlbGVjdGVkIHByb3BlcnR5IG5hbWUgZnJvbSB0aGUgZ2l2ZW4gb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRQcm9wZXJ0eU5hbWUoX29iamVjdDogT2JqZWN0KTogc3RyaW5nIHtcclxuICAgICAgbGV0IGtleXM6IHN0cmluZ1tdID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoX29iamVjdCk7XHJcbiAgICAgIHJldHVybiBrZXlzW3RoaXMuZ2V0SW5kZXgoa2V5cyldO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHJhbmRvbWx5IHNlbGVjdGVkIHN5bWJvbCBmcm9tIHRoZSBnaXZlbiBvYmplY3QsIGlmIHN5bWJvbHMgYXJlIHVzZWQgYXMga2V5c1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0UHJvcGVydHlTeW1ib2woX29iamVjdDogT2JqZWN0KTogc3ltYm9sIHtcclxuICAgICAgbGV0IGtleXM6IHN5bWJvbFtdID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhfb2JqZWN0KTtcclxuICAgICAgcmV0dXJuIGtleXNbdGhpcy5nZXRJbmRleChrZXlzKV07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcmFuZG9tIHRocmVlLWRpbWVuc2lvbmFsIHZlY3RvciBpbiB0aGUgbGltaXRzIG9mIHRoZSBib3ggZGVmaW5lZCBieSB0aGUgdmVjdG9ycyBnaXZlbiBhcyBbX2Nvcm5lcjAsIF9jb3JuZXIxW1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0VmVjdG9yMyhfY29ybmVyMDogVmVjdG9yMywgX2Nvcm5lcjE6IFZlY3RvcjMpOiBWZWN0b3IzIHtcclxuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKHRoaXMuZ2V0UmFuZ2UoX2Nvcm5lcjAueCwgX2Nvcm5lcjEueCksIHRoaXMuZ2V0UmFuZ2UoX2Nvcm5lcjAueSwgX2Nvcm5lcjEueSksIHRoaXMuZ2V0UmFuZ2UoX2Nvcm5lcjAueiwgX2Nvcm5lcjEueikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHJhbmRvbSB0d28tZGltZW5zaW9uYWwgdmVjdG9yIGluIHRoZSBsaW1pdHMgb2YgdGhlIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IHRoZSB2ZWN0b3JzIGdpdmVuIGFzIFtfY29ybmVyMCwgX2Nvcm5lcjFbXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRWZWN0b3IyKF9jb3JuZXIwOiBWZWN0b3IyLCBfY29ybmVyMTogVmVjdG9yMik6IFZlY3RvcjIge1xyXG4gICAgICByZXR1cm4gbmV3IFZlY3RvcjIodGhpcy5nZXRSYW5nZShfY29ybmVyMC54LCBfY29ybmVyMS54KSwgdGhpcy5nZXRSYW5nZShfY29ybmVyMC55LCBfY29ybmVyMS55KSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGFuZGFyZCB7QGxpbmsgUmFuZG9tfS1pbnN0YW5jZSB1c2luZyBNYXRoLnJhbmRvbSgpLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBjb25zdCByYW5kb206IFJhbmRvbSA9IG5ldyBSYW5kb20oKTtcclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFN0b3JlcyBhbmQgbWFuaXB1bGF0ZXMgYSB0aHJlZWRpbWVuc2lvbmFsIHZlY3RvciBjb21wcmlzZWQgb2YgdGhlIGNvbXBvbmVudHMgeCwgeSBhbmQgelxyXG4gICAqIGBgYHBsYWludGV4dFxyXG4gICAqICAgICAgICAgICAgK3lcclxuICAgKiAgICAgICAgICAgICB8X18gK3hcclxuICAgKiAgICAgICAgICAgIC9cclxuICAgKiAgICAgICAgICAreiAgIFxyXG4gICAqIGBgYFxyXG4gICAqIEBhdXRob3JzIEphc2NoYSBLYXJhZ8O2bCwgSEZVLCAyMDE5IHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTktMjAyMlxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBWZWN0b3IzIGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFJlY3ljYWJsZSB7XHJcbiAgICBwcml2YXRlIGRhdGE6IEZsb2F0MzJBcnJheTsgLy8gVE9ETzogY2hlY2sgd2h5IHRoaXMgc2hvdWxkbid0IGJlIHgseSx6IGFzIG51bWJlcnMuLi5cclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3g6IG51bWJlciA9IDAsIF95OiBudW1iZXIgPSAwLCBfejogbnVtYmVyID0gMCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KFtfeCwgX3ksIF96XSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFN0YXRpY1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgdmVjdG9yIHdpdGggdGhlIGdpdmVuIGxlbmd0aCBwb2ludGluZyBpbiB4LWRpcmVjdGlvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFgoX3NjYWxlOiBudW1iZXIgPSAxKTogVmVjdG9yMyB7XHJcbiAgICAgIGNvbnN0IHZlY3RvcjogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgdmVjdG9yLnNldChfc2NhbGUsIDAsIDApO1xyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBsZW5ndGggcG9pbnRpbmcgaW4geS1kaXJlY3Rpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBZKF9zY2FsZTogbnVtYmVyID0gMSk6IFZlY3RvcjMge1xyXG4gICAgICBjb25zdCB2ZWN0b3I6IFZlY3RvcjMgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XHJcbiAgICAgIHZlY3Rvci5zZXQoMCwgX3NjYWxlLCAwKTtcclxuICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gbGVuZ3RoIHBvaW50aW5nIGluIHotZGlyZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgWihfc2NhbGU6IG51bWJlciA9IDEpOiBWZWN0b3IzIHtcclxuICAgICAgY29uc3QgdmVjdG9yOiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xyXG4gICAgICB2ZWN0b3IuZGF0YS5zZXQoWzAsIDAsIF9zY2FsZV0pO1xyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIHZlY3RvciB3aXRoIHRoZSB2YWx1ZSAwIG9uIGVhY2ggYXhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFpFUk8oKTogVmVjdG9yMyB7XHJcbiAgICAgIGNvbnN0IHZlY3RvcjogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgdmVjdG9yLnNldCgwLCAwLCAwKTtcclxuICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSB2ZWN0b3Igb2YgdGhlIGdpdmVuIHNpemUgb24gZWFjaCBvZiB0aGUgdGhyZWUgYXhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIE9ORShfc2NhbGU6IG51bWJlciA9IDEpOiBWZWN0b3IzIHtcclxuICAgICAgY29uc3QgdmVjdG9yOiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xyXG4gICAgICB2ZWN0b3Iuc2V0KF9zY2FsZSwgX3NjYWxlLCBfc2NhbGUpO1xyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIHZlY3RvciB0aHJvdWdoIHRyYW5zZm9ybWF0aW9uIG9mIHRoZSBnaXZlbiB2ZWN0b3IgYnkgdGhlIGdpdmVuIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFRSQU5TRk9STUFUSU9OKF92ZWN0b3I6IFZlY3RvcjMsIF9tdHhUcmFuc2Zvcm06IE1hdHJpeDR4NCwgX2luY2x1ZGVUcmFuc2xhdGlvbjogYm9vbGVhbiA9IHRydWUpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgbGV0IG06IEZsb2F0MzJBcnJheSA9IF9tdHhUcmFuc2Zvcm0uZ2V0KCk7XHJcbiAgICAgIGxldCBbeCwgeSwgel0gPSBfdmVjdG9yLmdldCgpO1xyXG5cclxuICAgICAgcmVzdWx0LnggPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHo7XHJcbiAgICAgIHJlc3VsdC55ID0gbVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6O1xyXG4gICAgICByZXN1bHQueiA9IG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHo7XHJcblxyXG4gICAgICBpZiAoX2luY2x1ZGVUcmFuc2xhdGlvbikge1xyXG4gICAgICAgIHJlc3VsdC5hZGQoX210eFRyYW5zZm9ybS50cmFuc2xhdGlvbik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgdmVjdG9yIHdoaWNoIGlzIGEgY29weSBvZiB0aGUgZ2l2ZW4gdmVjdG9yIHNjYWxlZCB0byB0aGUgZ2l2ZW4gbGVuZ3RoXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgTk9STUFMSVpBVElPTihfdmVjdG9yOiBWZWN0b3IzLCBfbGVuZ3RoOiBudW1iZXIgPSAxKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCBtYWduaXR1ZGVTcXVhcmVkOiBudW1iZXIgPSBfdmVjdG9yLm1hZ25pdHVkZVNxdWFyZWQ7XHJcbiAgICAgIGxldCB2ZWN0b3I6IFZlY3RvcjMgPSBfdmVjdG9yLmNsb25lO1xyXG4gICAgICBpZiAobWFnbml0dWRlU3F1YXJlZCA9PSAwKVxyXG4gICAgICAgIHRocm93IChuZXcgUmFuZ2VFcnJvcihcIkltcG9zc2libGUgbm9ybWFsaXphdGlvblwiKSk7XHJcbiAgICAgIHZlY3Rvci5zY2FsZShfbGVuZ3RoIC8gTWF0aC5zcXJ0KG1hZ25pdHVkZVNxdWFyZWQpKVxyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcmVzdWx0aW5nIHZlY3RvciBhdHRhaW5lZCBieSBhZGRpdGlvbiBvZiBhbGwgZ2l2ZW4gdmVjdG9ycy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBTVU0oLi4uX3ZlY3RvcnM6IFZlY3RvcjNbXSk6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xyXG4gICAgICBmb3IgKGxldCB2ZWN0b3Igb2YgX3ZlY3RvcnMpXHJcbiAgICAgICAgcmVzdWx0LnNldChyZXN1bHQueCArIHZlY3Rvci54LCByZXN1bHQueSArIHZlY3Rvci55LCByZXN1bHQueiArIHZlY3Rvci56KTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgc3VidHJhY3Rpb24gb2YgdHdvIHZlY3RvcnMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgRElGRkVSRU5DRShfbWludWVuZDogVmVjdG9yMywgX3N1YnRyYWhlbmQ6IFZlY3RvcjMpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHZlY3RvcjogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgdmVjdG9yLnNldChfbWludWVuZC54IC0gX3N1YnRyYWhlbmQueCwgX21pbnVlbmQueSAtIF9zdWJ0cmFoZW5kLnksIF9taW51ZW5kLnogLSBfc3VidHJhaGVuZC56KTtcclxuICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBuZXcgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gdmVjdG9yIHNjYWxlZCBieSB0aGUgZ2l2ZW4gc2NhbGluZyBmYWN0b3JcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBTQ0FMRShfdmVjdG9yOiBWZWN0b3IzLCBfc2NhbGluZzogbnVtYmVyKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCBzY2FsZWQ6IFZlY3RvcjMgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XHJcbiAgICAgIHNjYWxlZC5zZXQoX3ZlY3Rvci54ICogX3NjYWxpbmcsIF92ZWN0b3IueSAqIF9zY2FsaW5nLCBfdmVjdG9yLnogKiBfc2NhbGluZyk7XHJcbiAgICAgIHJldHVybiBzY2FsZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyB0aGUgY3Jvc3Nwcm9kdWN0IG9mIDIgdmVjdG9ycy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBDUk9TUyhfYTogVmVjdG9yMywgX2I6IFZlY3RvcjMpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHZlY3RvcjogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgdmVjdG9yLnNldChcclxuICAgICAgICBfYS55ICogX2IueiAtIF9hLnogKiBfYi55LFxyXG4gICAgICAgIF9hLnogKiBfYi54IC0gX2EueCAqIF9iLnosXHJcbiAgICAgICAgX2EueCAqIF9iLnkgLSBfYS55ICogX2IueFxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyB0aGUgZG90cHJvZHVjdCBvZiAyIHZlY3RvcnMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgRE9UKF9hOiBWZWN0b3IzLCBfYjogVmVjdG9yMyk6IG51bWJlciB7XHJcbiAgICAgIGxldCBzY2FsYXJQcm9kdWN0OiBudW1iZXIgPSBfYS54ICogX2IueCArIF9hLnkgKiBfYi55ICsgX2EueiAqIF9iLno7XHJcbiAgICAgIHJldHVybiBzY2FsYXJQcm9kdWN0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyBhbmQgcmV0dXJucyB0aGUgcmVmbGVjdGlvbiBvZiB0aGUgaW5jb21pbmcgdmVjdG9yIGF0IHRoZSBnaXZlbiBub3JtYWwgdmVjdG9yLiBUaGUgbGVuZ3RoIG9mIG5vcm1hbCBzaG91bGQgYmUgMS5cclxuICAgICAqICAgICBfX19fX19fX19fX19fX19fX19cclxuICAgICAqICAgICAgICAgICAvfFxcXHJcbiAgICAgKiBpbmNvbWluZyAvIHwgXFwgcmVmbGVjdGlvblxyXG4gICAgICogICAgICAgICAvICB8ICBcXCAgIFxyXG4gICAgICogICAgICAgICAgbm9ybWFsXHJcbiAgICAgKiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBSRUZMRUNUSU9OKF9pbmNvbWluZzogVmVjdG9yMywgX25vcm1hbDogVmVjdG9yMyk6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgZG90OiBudW1iZXIgPSAtVmVjdG9yMy5ET1QoX2luY29taW5nLCBfbm9ybWFsKTtcclxuICAgICAgbGV0IHJlZmxlY3Rpb246IFZlY3RvcjMgPSBWZWN0b3IzLlNVTShfaW5jb21pbmcsIFZlY3RvcjMuU0NBTEUoX25vcm1hbCwgMiAqIGRvdCkpO1xyXG4gICAgICByZXR1cm4gcmVmbGVjdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERpdmlkZXMgdGhlIGRpdmlkZW5kIGJ5IHRoZSBkaXZpc29yIGNvbXBvbmVudCBieSBjb21wb25lbnQgYW5kIHJldHVybnMgdGhlIHJlc3VsdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFJBVElPKF9kaXZpZGVuZDogVmVjdG9yMywgX2Rpdmlzb3I6IFZlY3RvcjMpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHZlY3RvcjogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgdmVjdG9yLnNldChfZGl2aWRlbmQueCAvIF9kaXZpc29yLngsIF9kaXZpZGVuZC55IC8gX2Rpdmlzb3IueSwgX2RpdmlkZW5kLnogLyBfZGl2aXNvci56KTtcclxuICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBjYXJ0ZXNpYW4gdmVjdG9yIGZyb20gZ2VvZ3JhcGhpYyBjb29yZGluYXRlc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIEdFTyhfbG9uZ2l0dWRlOiBudW1iZXIgPSAwLCBfbGF0aXR1ZGU6IG51bWJlciA9IDAsIF9tYWduaXR1ZGU6IG51bWJlciA9IDEpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHZlY3RvcjogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgbGV0IGdlbzogR2VvMyA9IFJlY3ljbGVyLmdldChHZW8zKTtcclxuICAgICAgZ2VvLnNldChfbG9uZ2l0dWRlLCBfbGF0aXR1ZGUsIF9tYWduaXR1ZGUpO1xyXG4gICAgICB2ZWN0b3IuZ2VvID0gZ2VvO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShnZW8pO1xyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIEFjY2Vzc29yc1xyXG4gICAgLy8gVE9ETzogaW1wbGVtZW50IGVxdWFscy1mdW5jdGlvbnNcclxuICAgIGdldCB4KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmRhdGFbMF07XHJcbiAgICB9XHJcbiAgICBnZXQgeSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5kYXRhWzFdO1xyXG4gICAgfVxyXG4gICAgZ2V0IHooKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZGF0YVsyXTtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgeChfeDogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuZGF0YVswXSA9IF94O1xyXG4gICAgfVxyXG4gICAgc2V0IHkoX3k6IG51bWJlcikge1xyXG4gICAgICB0aGlzLmRhdGFbMV0gPSBfeTtcclxuICAgIH1cclxuICAgIHNldCB6KF96OiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5kYXRhWzJdID0gX3o7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBnZXQgbWFnbml0dWRlKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiBNYXRoLmh5cG90KC4uLnRoaXMuZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzcXVhcmUgb2YgdGhlIG1hZ25pdHVkZSBvZiB0aGUgdmVjdG9yIHdpdGhvdXQgY2FsY3VsYXRpbmcgYSBzcXVhcmUgcm9vdC4gRmFzdGVyIGZvciBzaW1wbGUgcHJveGltaXR5IGV2YWx1YXRpb24uXHJcbiAgICAgKi9cclxuICAgIGdldCBtYWduaXR1ZGVTcXVhcmVkKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiBWZWN0b3IzLkRPVCh0aGlzLCB0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgdmVjdG9yXHJcbiAgICAgKiBUT0RPOiByZW5hbWUgdGhpcyBjbG9uZSBhbmQgY3JlYXRlIGEgbmV3IG1ldGhvZCBjb3B5LCB3aGljaCBjb3BpZXMgdGhlIHZhbHVlcyBmcm9tIGEgdmVjdG9yIGdpdmVuIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGNsb25lKCk6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgY2xvbmU6IFZlY3RvcjMgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XHJcbiAgICAgIGNsb25lLmRhdGEuc2V0KHRoaXMuZGF0YSk7XHJcbiAgICAgIHJldHVybiBjbG9uZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIC0gZ2V0OiByZXR1cm5zIGEgZ2VvZ3JhcGhpYyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHZlY3RvciAgXHJcbiAgICAgKiAtIHNldDogYWRqdXN0IHRoZSBjYXJ0ZXNpYW4gdmFsdWVzIG9mIHRoaXMgdmVjdG9yIHRvIHJlcHJlc2VudCB0aGUgZ2l2ZW4gYXMgZ2VvZ3JhcGhpYyBjb29yZGluYXRlc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0IGdlbyhfZ2VvOiBHZW8zKSB7XHJcbiAgICAgIHRoaXMuc2V0KDAsIDAsIF9nZW8ubWFnbml0dWRlKTtcclxuICAgICAgdGhpcy50cmFuc2Zvcm0oTWF0cml4NHg0LlJPVEFUSU9OX1goLV9nZW8ubGF0aXR1ZGUpKTtcclxuICAgICAgdGhpcy50cmFuc2Zvcm0oTWF0cml4NHg0LlJPVEFUSU9OX1koX2dlby5sb25naXR1ZGUpKTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBnZXQgZ2VvKCk6IEdlbzMge1xyXG4gICAgICBsZXQgZ2VvOiBHZW8zID0gUmVjeWNsZXIuZ2V0KEdlbzMpO1xyXG4gICAgICBnZW8ubWFnbml0dWRlID0gdGhpcy5tYWduaXR1ZGU7XHJcblxyXG4gICAgICBpZiAoZ2VvLm1hZ25pdHVkZSA9PT0gMClcclxuICAgICAgICByZXR1cm4gZ2VvO1xyXG5cclxuICAgICAgZ2VvLmxvbmdpdHVkZSA9IDE4MCAqIE1hdGguYXRhbjIodGhpcy54IC8gZ2VvLm1hZ25pdHVkZSwgdGhpcy56IC8gZ2VvLm1hZ25pdHVkZSkgLyBNYXRoLlBJO1xyXG4gICAgICBnZW8ubGF0aXR1ZGUgPSAxODAgKiBNYXRoLmFzaW4odGhpcy55IC8gZ2VvLm1hZ25pdHVkZSkgLyBNYXRoLlBJO1xyXG4gICAgICByZXR1cm4gZ2VvO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgcHVibGljIHJlY3ljbGUoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuZGF0YS5zZXQoWzAsIDAsIDBdKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY29vcmRpbmF0ZXMgb2YgdGhpcyBhbmQgdGhlIGdpdmVuIHZlY3RvciBhcmUgdG8gYmUgY29uc2lkZXJlZCBpZGVudGljYWwgd2l0aGluIHRoZSBnaXZlbiB0b2xlcmFuY2VcclxuICAgICAqIFRPRE86IGV4YW1pbmUsIGlmIHRvbGVyYW5jZSBhcyBjcml0ZXJpdW0gZm9yIHRoZSBkaWZmZXJlbmNlIGlzIGFwcHJvcHJpYXRlIHdpdGggdmVyeSBsYXJnZSBjb29yZGluYXRlIHZhbHVlcyBvciBpZiBfdG9sZXJhbmNlIHNob3VsZCBiZSBtdWx0aXBsaWVkIGJ5IGNvb3JkaW5hdGUgdmFsdWVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGVxdWFscyhfY29tcGFyZTogVmVjdG9yMywgX3RvbGVyYW5jZTogbnVtYmVyID0gTnVtYmVyLkVQU0lMT04pOiBib29sZWFuIHtcclxuICAgICAgaWYgKE1hdGguYWJzKHRoaXMueCAtIF9jb21wYXJlLngpID4gX3RvbGVyYW5jZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAoTWF0aC5hYnModGhpcy55IC0gX2NvbXBhcmUueSkgPiBfdG9sZXJhbmNlKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmIChNYXRoLmFicyh0aGlzLnogLSBfY29tcGFyZS56KSA+IF90b2xlcmFuY2UpIHJldHVybiBmYWxzZTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBvc2l0aW9uIGRlc2NyaWJlZCBieSB0aGlzIGlzIHdpdGhpbiBhIGN1YmUgd2l0aCB0aGUgb3Bwb3NpdGUgY29ybmVycyAxIGFuZCAyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpc0luc2lkZUN1YmUoX2Nvcm5lcjE6IFZlY3RvcjMsIF9jb3JuZXIyOiBWZWN0b3IzKTogYm9vbGVhbiB7XHJcbiAgICAgIGxldCBkaWFnb25hbDogVmVjdG9yMyA9IFZlY3RvcjMuRElGRkVSRU5DRShfY29ybmVyMiwgX2Nvcm5lcjEpO1xyXG4gICAgICBsZXQgcmVsYXRpdmU6IFZlY3RvcjMgPSBWZWN0b3IzLkRJRkZFUkVOQ0UodGhpcywgX2Nvcm5lcjEpO1xyXG4gICAgICBsZXQgcmF0aW86IFZlY3RvcjMgPSBWZWN0b3IzLlJBVElPKHJlbGF0aXZlLCBkaWFnb25hbCk7XHJcbiAgICAgIGlmIChyYXRpby54ID4gMSB8fCByYXRpby54IDwgMClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmIChyYXRpby55ID4gMSB8fCByYXRpby55IDwgMClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmIChyYXRpby56ID4gMSB8fCByYXRpby56IDwgMClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwb3NpdGlvbiBkZXNjcmliZWQgYnkgdGhpcyBpcyB3aXRoaW4gYSBzcGhlcmUgd2l0aCB0aGUgZ2l2ZW4gY2VudGVyIGFuZCByYWRpdXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGlzSW5zaWRlU3BoZXJlKF9jZW50ZXI6IFZlY3RvcjMsIF9yYWRpdXM6IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgICBsZXQgZGlmZmVyZW5jZTogVmVjdG9yMyA9IFZlY3RvcjMuRElGRkVSRU5DRSh0aGlzLCBfY2VudGVyKTtcclxuICAgICAgcmV0dXJuIGRpZmZlcmVuY2UubWFnbml0dWRlU3F1YXJlZCA8IChfcmFkaXVzICogX3JhZGl1cyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHRoZSBnaXZlbiB2ZWN0b3IgdG8gdGhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWRkKF9hZGRlbmQ6IFZlY3RvcjMpOiB2b2lkIHtcclxuICAgICAgdGhpcy5kYXRhLnNldChbX2FkZGVuZC54ICsgdGhpcy54LCBfYWRkZW5kLnkgKyB0aGlzLnksIF9hZGRlbmQueiArIHRoaXMuel0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3VidHJhY3RzIHRoZSBnaXZlbiB2ZWN0b3IgZnJvbSB0aGlzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdWJ0cmFjdChfc3VidHJhaGVuZDogVmVjdG9yMyk6IHZvaWQge1xyXG4gICAgICB0aGlzLmRhdGEuc2V0KFt0aGlzLnggLSBfc3VidHJhaGVuZC54LCB0aGlzLnkgLSBfc3VidHJhaGVuZC55LCB0aGlzLnogLSBfc3VidHJhaGVuZC56XSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTY2FsZXMgdGhpcyB2ZWN0b3IgYnkgdGhlIGdpdmVuIHNjYWxhclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2NhbGUoX3NjYWxhcjogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuZGF0YS5zZXQoW19zY2FsYXIgKiB0aGlzLngsIF9zY2FsYXIgKiB0aGlzLnksIF9zY2FsYXIgKiB0aGlzLnpdKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE5vcm1hbGl6ZXMgdGhpcyB0byB0aGUgZ2l2ZW4gbGVuZ3RoLCAxIGJ5IGRlZmF1bHRcclxuICAgICAqL1xyXG4gICAgcHVibGljIG5vcm1hbGl6ZShfbGVuZ3RoOiBudW1iZXIgPSAxKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuZGF0YSA9IFZlY3RvcjMuTk9STUFMSVpBVElPTih0aGlzLCBfbGVuZ3RoKS5kYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyB0aGUgY29tcG9uZW50cyBvZiB0aGlzIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBudW1iZXJzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQoX3g6IG51bWJlciA9IDAsIF95OiBudW1iZXIgPSAwLCBfejogbnVtYmVyID0gMCk6IHZvaWQge1xyXG4gICAgICB0aGlzLmRhdGFbMF0gPSBfeDtcclxuICAgICAgdGhpcy5kYXRhWzFdID0gX3k7XHJcbiAgICAgIHRoaXMuZGF0YVsyXSA9IF96O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGlzIHZlY3RvciBhcyBhIG5ldyBGbG9hdDMyQXJyYXkgKGNvcHkpXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkodGhpcy5kYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zZm9ybXMgdGhpcyB2ZWN0b3IgYnkgdGhlIGdpdmVuIG1hdHJpeCwgaW5jbHVkaW5nIG9yIGV4bHVkaW5nIHRoZSB0cmFuc2xhdGlvbi5cclxuICAgICAqIEluY2x1ZGluZyBpcyB0aGUgZGVmYXVsdCwgZXhjbHVkaW5nIHdpbGwgb25seSByb3RhdGUgYW5kIHNjYWxlIHRoaXMgdmVjdG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdHJhbnNmb3JtKF9tdHhUcmFuc2Zvcm06IE1hdHJpeDR4NCwgX2luY2x1ZGVUcmFuc2xhdGlvbjogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcclxuICAgICAgbGV0IHRyYW5zZm9ybWVkOiBWZWN0b3IzID0gVmVjdG9yMy5UUkFOU0ZPUk1BVElPTih0aGlzLCBfbXR4VHJhbnNmb3JtLCBfaW5jbHVkZVRyYW5zbGF0aW9uKTtcclxuICAgICAgdGhpcy5kYXRhLnNldCh0cmFuc2Zvcm1lZC5kYXRhKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUodHJhbnNmb3JtZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJvcHMgdGhlIHotY29tcG9uZW50IGFuZCByZXR1cm5zIGEgVmVjdG9yMiBjb25zaXN0aW5nIG9mIHRoZSB4LSBhbmQgeS1jb21wb25lbnRzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b1ZlY3RvcjIoKTogVmVjdG9yMiB7XHJcbiAgICAgIHJldHVybiBuZXcgVmVjdG9yMih0aGlzLngsIHRoaXMueSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZsZWN0cyB0aGlzIHZlY3RvciBhdCBhIGdpdmVuIG5vcm1hbC4gU2VlIHtAbGluayBWZWN0b3IzLlJFRkxFQ1RJT059XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZWZsZWN0KF9ub3JtYWw6IFZlY3RvcjMpOiB2b2lkIHtcclxuICAgICAgY29uc3QgcmVmbGVjdGVkOiBWZWN0b3IzID0gVmVjdG9yMy5SRUZMRUNUSU9OKHRoaXMsIF9ub3JtYWwpO1xyXG4gICAgICB0aGlzLnNldChyZWZsZWN0ZWQueCwgcmVmbGVjdGVkLnksIHJlZmxlY3RlZC56KTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUocmVmbGVjdGVkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNodWZmbGVzIHRoZSBjb21wb25lbnRzIG9mIHRoaXMgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIHNodWZmbGUoKTogdm9pZCB7XHJcbiAgICAgIGxldCBhOiBudW1iZXJbXSA9IEFycmF5LmZyb20odGhpcy5kYXRhKTtcclxuICAgICAgdGhpcy5zZXQoUmFuZG9tLmRlZmF1bHQuc3BsaWNlKGEpLCBSYW5kb20uZGVmYXVsdC5zcGxpY2UoYSksIGFbMF0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXREaXN0YW5jZShfdG86IFZlY3RvcjMpOiBudW1iZXIge1xyXG4gICAgICBsZXQgZGlmZmVyZW5jZTogVmVjdG9yMyA9IFZlY3RvcjMuRElGRkVSRU5DRSh0aGlzLCBfdG8pO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShkaWZmZXJlbmNlKTtcclxuICAgICAgcmV0dXJuIGRpZmZlcmVuY2UubWFnbml0dWRlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3IgZWFjaCBkaW1lbnNpb24sIG1vdmVzIHRoZSBjb21wb25lbnQgdG8gdGhlIG1pbmltdW0gb2YgdGhpcyBhbmQgdGhlIGdpdmVuIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbWluKF9jb21wYXJlOiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIHRoaXMueCA9IE1hdGgubWluKHRoaXMueCwgX2NvbXBhcmUueCk7XHJcbiAgICAgIHRoaXMueSA9IE1hdGgubWluKHRoaXMueSwgX2NvbXBhcmUueSk7XHJcbiAgICAgIHRoaXMueiA9IE1hdGgubWluKHRoaXMueiwgX2NvbXBhcmUueik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZvciBlYWNoIGRpbWVuc2lvbiwgbW92ZXMgdGhlIGNvbXBvbmVudCB0byB0aGUgbWF4aW11bSBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBtYXgoX2NvbXBhcmU6IFZlY3RvcjMpOiB2b2lkIHtcclxuICAgICAgdGhpcy54ID0gTWF0aC5tYXgodGhpcy54LCBfY29tcGFyZS54KTtcclxuICAgICAgdGhpcy55ID0gTWF0aC5tYXgodGhpcy55LCBfY29tcGFyZS55KTtcclxuICAgICAgdGhpcy56ID0gTWF0aC5tYXgodGhpcy56LCBfY29tcGFyZS56KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBmb3JtYXR0ZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG4gICAgICBsZXQgcmVzdWx0OiBzdHJpbmcgPSBgKCR7dGhpcy54LnRvUHJlY2lzaW9uKDUpfSwgJHt0aGlzLnkudG9QcmVjaXNpb24oNSl9LCAke3RoaXMuei50b1ByZWNpc2lvbig1KX0pYDtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVzZXMgdGhlIHN0YW5kYXJkIGFycmF5Lm1hcCBmdW5jdGlvbmFsaXR5IHRvIHBlcmZvcm0gdGhlIGdpdmVuIGZ1bmN0aW9uIG9uIGFsbCBjb21wb25lbnRzIG9mIHRoaXMgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBtYXAoX2Z1bmN0aW9uOiAodmFsdWU6IG51bWJlciwgaW5kZXg6IG51bWJlciwgYXJyYXk6IEZsb2F0MzJBcnJheSkgPT4gbnVtYmVyKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCBjb3B5OiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xyXG4gICAgICBjb3B5LmRhdGEgPSB0aGlzLmRhdGEubWFwKF9mdW5jdGlvbik7XHJcbiAgICAgIHJldHVybiBjb3B5O1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB0aGlzLmdldE11dGF0b3IoKTtcclxuICAgICAgLy8gc2VyaWFsaXphdGlvbi50b0pTT04gPSAoKSA9PiB7IHJldHVybiBgeyBcInJcIjogJHt0aGlzLnJ9LCBcImdcIjogJHt0aGlzLmd9LCBcImJcIjogJHt0aGlzLmJ9LCBcImFcIjogJHt0aGlzLmF9fWA7IH07XHJcbiAgICAgIHNlcmlhbGl6YXRpb24udG9KU09OID0gKCkgPT4geyByZXR1cm4gYFske3RoaXMueH0sICR7dGhpcy55fSwgJHt0aGlzLnp9XWA7IH07XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8VmVjdG9yMz4ge1xyXG4gICAgICBpZiAodHlwZW9mIChfc2VyaWFsaXphdGlvbikgPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIFt0aGlzLngsIHRoaXMueSwgdGhpcy56XSA9IEpTT04ucGFyc2UoPHN0cmluZz48dW5rbm93bj5fc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZVxyXG4gICAgICAgIHRoaXMubXV0YXRlKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0ge1xyXG4gICAgICAgIHg6IHRoaXMuZGF0YVswXSwgeTogdGhpcy5kYXRhWzFdLCB6OiB0aGlzLmRhdGFbMl1cclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQgey8qKiAqLyB9XHJcbiAgICAvLyNlbmRyZWdpb24gVHJhbnNmZXJcclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBEZXNjcmliZXMgYSBmYWNlIG9mIGEge0BsaW5rIE1lc2h9IGJ5IHJlZmVyZW5jaW5nIHRocmVlIHtAbGluayBWZXJ0aWNlc30gd2l0aCB0aGVpciBpbmRpemVzXHJcbiAgICogYW5kIGNhbGN1bGF0ZXMgZmFjZSBub3JtYWxzLlxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIyXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEZhY2Uge1xyXG4gICAgcHVibGljIGluZGljZXM6IG51bWJlcltdID0gW107XHJcbiAgICBwdWJsaWMgbm9ybWFsVW5zY2FsZWQ6IFZlY3RvcjM7XHJcbiAgICBwdWJsaWMgbm9ybWFsOiBWZWN0b3IzO1xyXG4gICAgcHJpdmF0ZSB2ZXJ0aWNlczogVmVydGljZXM7XHJcblxyXG4gICAgY29uc3RydWN0b3IoX3ZlcnRpY2VzOiBWZXJ0aWNlcywgX2luZGV4MDogbnVtYmVyLCBfaW5kZXgxOiBudW1iZXIsIF9pbmRleDI6IG51bWJlcikge1xyXG4gICAgICB0aGlzLmluZGljZXMgPSBbX2luZGV4MCwgX2luZGV4MSwgX2luZGV4Ml07XHJcbiAgICAgIHRoaXMudmVydGljZXMgPSBfdmVydGljZXM7XHJcbiAgICAgIHRoaXMuY2FsY3VsYXRlTm9ybWFscygpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBjYWxjdWxhdGVOb3JtYWxzKCk6IHZvaWQge1xyXG4gICAgICBsZXQgdHJpZ29uOiBWZWN0b3IzW10gPSB0aGlzLmluZGljZXMubWFwKChfaW5kZXg6IG51bWJlcikgPT4gdGhpcy52ZXJ0aWNlcy5wb3NpdGlvbihfaW5kZXgpKTtcclxuICAgICAgbGV0IHYxOiBWZWN0b3IzID0gVmVjdG9yMy5ESUZGRVJFTkNFKHRyaWdvblsxXSwgdHJpZ29uWzBdKTtcclxuICAgICAgbGV0IHYyOiBWZWN0b3IzID0gVmVjdG9yMy5ESUZGRVJFTkNFKHRyaWdvblsyXSwgdHJpZ29uWzBdKTtcclxuICAgICAgdGhpcy5ub3JtYWxVbnNjYWxlZCA9IFZlY3RvcjMuQ1JPU1ModjEsIHYyKTtcclxuICAgICAgdGhpcy5ub3JtYWwgPSBWZWN0b3IzLk5PUk1BTElaQVRJT04odGhpcy5ub3JtYWxVbnNjYWxlZCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFBvc2l0aW9uKF9pbmRleDogbnVtYmVyKTogVmVjdG9yMyB7XHJcbiAgICAgIHJldHVybiB0aGlzLnZlcnRpY2VzLnBvc2l0aW9uKHRoaXMuaW5kaWNlc1tfaW5kZXhdKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIG11c3QgYmUgY29wbGFuYXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGlzSW5zaWRlKF9wb2ludDogVmVjdG9yMyk6IGJvb2xlYW4ge1xyXG4gICAgICBsZXQgZGlmZnM6IFZlY3RvcjNbXSA9IFtdO1xyXG4gICAgICBmb3IgKGxldCBpbmRleCBvZiB0aGlzLmluZGljZXMpIHtcclxuICAgICAgICBsZXQgZGlmZjogVmVjdG9yMyA9IFZlY3RvcjMuRElGRkVSRU5DRSh0aGlzLnZlcnRpY2VzLnBvc2l0aW9uKGluZGV4KSwgX3BvaW50KTtcclxuICAgICAgICBkaWZmcy5wdXNoKGRpZmYpO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCBuMDogVmVjdG9yMyA9IFZlY3RvcjMuQ1JPU1MoZGlmZnNbMV0sIGRpZmZzWzBdKTtcclxuICAgICAgbGV0IG4xOiBWZWN0b3IzID0gVmVjdG9yMy5DUk9TUyhkaWZmc1syXSwgZGlmZnNbMV0pO1xyXG4gICAgICBsZXQgbjI6IFZlY3RvcjMgPSBWZWN0b3IzLkNST1NTKGRpZmZzWzBdLCBkaWZmc1syXSk7XHJcbiAgXHJcbiAgICAgIGxldCBkb3QxOiBudW1iZXIgPSBWZWN0b3IzLkRPVChuMCwgbjEpO1xyXG4gICAgICBsZXQgZG90MjogbnVtYmVyID0gVmVjdG9yMy5ET1QobjAsIG4yKTtcclxuICBcclxuICAgICAgcmV0dXJuICEoZG90MSA8IDAgfHwgZG90MiA8IDApO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIGFsbCBtZXNoZXMuIFxyXG4gICAqIE1lc2hlcyBwcm92aWRlIGluZGV4ZWQgdmVydGljZXMsIHRoZSBvcmRlciBvZiBpbmRpY2VzIHRvIGNyZWF0ZSB0cmlnb25zIGFuZCBub3JtYWxzLCBhbmQgdGV4dHVyZSBjb29yZGluYXRlc1xyXG4gICAqIFxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5LzIyXHJcbiAgICovXHJcbiAgQFJlbmRlckluamVjdG9yTWVzaC5kZWNvcmF0ZVxyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBNZXNoIGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZVJlc291cmNlIHtcclxuICAgIC8qKiByZWZlcnMgYmFjayB0byB0aGlzIGNsYXNzIGZyb20gYW55IHN1YmNsYXNzIGUuZy4gaW4gb3JkZXIgdG8gZmluZCBjb21wYXRpYmxlIG90aGVyIHJlc291cmNlcyovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGJhc2VDbGFzczogdHlwZW9mIE1lc2ggPSBNZXNoO1xyXG4gICAgLyoqIGxpc3Qgb2YgYWxsIHRoZSBzdWJjbGFzc2VzIGRlcml2ZWQgZnJvbSB0aGlzIGNsYXNzLCBpZiB0aGV5IHJlZ2lzdGVyZWQgcHJvcGVybHkqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBzdWJjbGFzc2VzOiB0eXBlb2YgTWVzaFtdID0gW107XHJcblxyXG4gICAgLy8gVE9ETzogYXQgdGhpcyB0aW1lLCBjcmVhdGluZyB0aGUgYnVmZmVycyBmb3IgZmxhdCBzaGFkaW5nIGlzIGEgYnJ1dGUgZm9yY2UgYWxnb3JpdGhtIGFuZCBzaG91bGQgYmUgb3B0aW1pemVkIGluIHRoZSBkaWZmZXJlbnQgc3ViY2xhc3Nlc1xyXG4gICAgLy8gVE9ETzogcmVuYW1lIHZlcnRpY2VzIHRvIHZlcnRpY2VzU21vb3RoIG9yIGp1c3QgY2xvdWQsIGFuZCBjbG91ZCB0byB2ZXJ0aWNlc1xyXG4gICAgLy8gXHJcblxyXG4gICAgcHVibGljIGlkUmVzb3VyY2U6IHN0cmluZyA9IHVuZGVmaW5lZDtcclxuICAgIHB1YmxpYyBuYW1lOiBzdHJpbmcgPSBcIk1lc2hcIjtcclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyQnVmZmVyczogUmVuZGVyQnVmZmVyczsgLyogZGVmaW5lZCBieSBSZW5kZXJJbmplY3RvciovXHJcblxyXG4gICAgLy8gYmFzZSBzdHJ1Y3R1cmUgZm9yIG1lc2hlcyBpbiBGVURHRVxyXG4gICAgcHJvdGVjdGVkIGNsb3VkOiBWZXJ0aWNlcyA9IG5ldyBWZXJ0aWNlcygpO1xyXG4gICAgcHJvdGVjdGVkIGZhY2VzOiBGYWNlW10gPSBbXTtcclxuXHJcbiAgICAvLyBUT0RPOiBtb3ZlIGFsbCDGki1TdHVmZiB0byB0aGUgUmVuZGVySW5qZWN0b3IuLi5cclxuICAgIC8qKiB2ZXJ0aWNlcyBvZiB0aGUgYWN0dWFsIHBvaW50IGNsb3VkLCBzb21lIHBvaW50cyBtaWdodCBiZSBpbiB0aGUgc2FtZSBsb2NhdGlvbiBpbiBvcmRlciB0byByZWZlciB0byBkaWZmZXJlbnQgdGV4ZWxzICovXHJcbiAgICBwcm90ZWN0ZWQgxpJ2ZXJ0aWNlczogRmxvYXQzMkFycmF5O1xyXG4gICAgLyoqIGluZGljZXMgdG8gY3JlYXRlIGZhY2VzIGZyb20gdGhlIHZlcnRpY2VzLCByb3RhdGlvbiBkZXRlcm1pbmVzIGRpcmVjdGlvbiBvZiBmYWNlLW5vcm1hbCAqL1xyXG4gICAgcHJvdGVjdGVkIMaSaW5kaWNlczogVWludDE2QXJyYXk7XHJcbiAgICAvKiogdGV4dHVyZSBjb29yZGluYXRlcyBhc3NvY2lhdGVkIHdpdGggdGhlIHZlcnRpY2VzIGJ5IHRoZSBwb3NpdGlvbiBpbiB0aGUgYXJyYXkgKi9cclxuICAgIHByb3RlY3RlZCDGknRleHR1cmVVVnM6IEZsb2F0MzJBcnJheTtcclxuICAgIC8qKiBub3JtYWxzIG9mIHRoZSBmYWNlcywgbm90IHVzZWQgZm9yIHJlbmRlcmluZyBidXQgY29tcHV0YXRpb24gb2YgZmxhdC0gYW5kIHZlcnRleC1ub3JtYWxzICovXHJcbiAgICBwcm90ZWN0ZWQgxpJub3JtYWxzRmFjZVVuc2NhbGVkOiBGbG9hdDMyQXJyYXk7XHJcbiAgICAvKiogdmVydGV4IG5vcm1hbHMgZm9yIHNtb290aCBzaGFkaW5nLCBpbnRlcnBvbGF0ZWQgYmV0d2VlbiB2ZXJ0aWNlcyBkdXJpbmcgcmVuZGVyaW5nICovXHJcbiAgICBwcm90ZWN0ZWQgxpJub3JtYWxzVmVydGV4OiBGbG9hdDMyQXJyYXk7XHJcblxyXG4gICAgLyoqIGZsYXQtc2hhZGluZzogbm9ybWFsaXplZCBmYWNlIG5vcm1hbHMsIGV2ZXJ5IHRoaXJkIGVudHJ5IGlzIHVzZWQgb25seSAqL1xyXG4gICAgcHJvdGVjdGVkIMaSbm9ybWFsc0ZsYXQ6IEZsb2F0MzJBcnJheTtcclxuICAgIC8qKiBmbGF0LXNoYWRpbmc6IGV4dHJhIHZlcnRleCBhcnJheSwgc2luY2UgdXNpbmcgdmVydGljZXMgd2l0aCBtdWx0aXBsZSBmYWNlcyBpcyByYXJlbHkgcG9zc2libGUgZHVlIHRvIHRoZSBsaW1pdGF0aW9uIGFib3ZlICovXHJcbiAgICBwcm90ZWN0ZWQgxpJ2ZXJ0aWNlc0ZsYXQ6IEZsb2F0MzJBcnJheTtcclxuICAgIC8qKiBmbGF0LXNoYWRpbmc6IHRoZXJlZm9yZSBhbiBleHRyYSBpbmRpY2VzLWFycmF5IGlzIG5lZWRlZCAqL1xyXG4gICAgcHJvdGVjdGVkIMaSaW5kaWNlc0ZsYXQ6IFVpbnQxNkFycmF5O1xyXG4gICAgLyoqIGZsYXQtc2hhZGluZzogYW5kIGFuIGV4dHJhIHRleHR1cmVVVi1hcnJheSAqL1xyXG4gICAgcHJvdGVjdGVkIMaSdGV4dHVyZVVWc0ZsYXQ6IEZsb2F0MzJBcnJheTtcclxuXHJcbiAgICAvKiogYm91bmRpbmcgYm94IEFBQkIgKi9cclxuICAgIHByb3RlY3RlZCDGkmJveDogQm94O1xyXG4gICAgLy8gVE9ETzogZXhwbG9yZSBtYXRoZW1hdGljcyBmb3IgZWFzeSB0cmFuc2Zvcm1hdGlvbnMgb2YgcmFkaXVzIFxyXG4gICAgLyoqIGJvdW5kaW5nIHJhZGl1cyAqL1xyXG4gICAgcHJvdGVjdGVkIMaScmFkaXVzOiBudW1iZXI7XHJcblxyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nID0gXCJNZXNoXCIpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5uYW1lID0gX25hbWU7XHJcbiAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgICAgUHJvamVjdC5yZWdpc3Rlcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHJlZ2lzdGVyU3ViY2xhc3MoX3N1YkNsYXNzOiB0eXBlb2YgTWVzaCk6IG51bWJlciB7IHJldHVybiBNZXNoLnN1YmNsYXNzZXMucHVzaChfc3ViQ2xhc3MpIC0gMTsgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgdHlwZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgdmVydGljZXMoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgcmV0dXJuIHRoaXMuxpJ2ZXJ0aWNlcyB8fCAoIC8vIHJldHVybiBjYWNoZSBvciAuLi5cclxuICAgICAgICAvLyAuLi4gZmxhdHRlbiBhbGwgdmVydGV4IHBvc2l0aW9ucyBmcm9tIGNsb3VkIGludG8gYSB0eXBlZCBhcnJheVxyXG4gICAgICAgIHRoaXMuxpJ2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5jbG91ZC5mbGF0TWFwKChfdmVydGV4OiBWZXJ0ZXgsIF9pbmRleDogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgICByZXR1cm4gWy4uLnRoaXMuY2xvdWQucG9zaXRpb24oX2luZGV4KS5nZXQoKV07XHJcbiAgICAgICAgfSkpKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGluZGljZXMoKTogVWludDE2QXJyYXkge1xyXG4gICAgICByZXR1cm4gdGhpcy7GkmluZGljZXMgfHwgKCAvLyByZXR1cm4gY2FjaGUgb3IgLi4uXHJcbiAgICAgICAgLy8gLi4uIGZsYXR0ZW4gYWxsIGluZGljZXMgZnJvbSB0aGUgZmFjZXMgaW50byBhIHR5cGVkIGFycmF5XHJcbiAgICAgICAgdGhpcy7GkmluZGljZXMgPSBuZXcgVWludDE2QXJyYXkodGhpcy5mYWNlcy5mbGF0TWFwKChfZmFjZTogRmFjZSkgPT4gWy4uLl9mYWNlLmluZGljZXNdKVxyXG4gICAgICAgICkpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgbm9ybWFsc1ZlcnRleCgpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICBpZiAodGhpcy7Gkm5vcm1hbHNWZXJ0ZXggPT0gbnVsbCkge1xyXG4gICAgICAgIC8vIHN1bSB1cCBhbGwgdW5zY2FsZWQgbm9ybWFscyBvZiBmYWNlcyBjb25uZWN0ZWQgdG8gb25lIHZlcnRleC4uLlxyXG4gICAgICAgIHRoaXMuY2xvdWQuZm9yRWFjaChfdmVydGV4ID0+IF92ZXJ0ZXgubm9ybWFsLnNldCgwLCAwLCAwKSk7XHJcbiAgICAgICAgZm9yIChsZXQgZmFjZSBvZiB0aGlzLmZhY2VzKVxyXG4gICAgICAgICAgZm9yIChsZXQgaW5kZXggb2YgZmFjZS5pbmRpY2VzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xvdWQubm9ybWFsKGluZGV4KS5hZGQoZmFjZS5ub3JtYWxVbnNjYWxlZCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgLy8gLi4uIGFuZCBub3JtYWxpemUgdGhlbVxyXG4gICAgICAgIHRoaXMuY2xvdWQuZm9yRWFjaChfdmVydGV4ID0+IHtcclxuICAgICAgICAgIC8vIHNvbWUgdmVydGljZXMgbWlnaHQgYmUgdW51c2VkIGFuZCB5aWVsZCBhIHplcm8tbm9ybWFsLi4uXHJcbiAgICAgICAgICBpZiAoX3ZlcnRleC5ub3JtYWwubWFnbml0dWRlU3F1YXJlZCA+IDApXHJcbiAgICAgICAgICAgIF92ZXJ0ZXgubm9ybWFsLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyB0aGlzLsaSbm9ybWFsc1ZlcnRleCA9IG5ldyBGbG9hdDMyQXJyYXkobm9ybWFsc1ZlcnRleC5mbGF0TWFwKChfbm9ybWFsOiBWZWN0b3IzKSA9PiBbLi4uX25vcm1hbC5nZXQoKV0pKTtcclxuXHJcbiAgICAgICAgdGhpcy7Gkm5vcm1hbHNWZXJ0ZXggPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuY2xvdWQuZmxhdE1hcCgoX3ZlcnRleDogVmVydGV4LCBfaW5kZXg6IG51bWJlcikgPT4ge1xyXG4gICAgICAgICAgcmV0dXJuIFsuLi50aGlzLmNsb3VkLm5vcm1hbChfaW5kZXgpLmdldCgpXTtcclxuICAgICAgICB9KSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzLsaSbm9ybWFsc1ZlcnRleDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHRleHR1cmVVVnMoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgcmV0dXJuIHRoaXMuxpJ0ZXh0dXJlVVZzIHx8ICggLy8gcmV0dXJuIGNhY2hlIG9yIC4uLlxyXG4gICAgICAgIC8vIC4uLiBmbGF0dGVuIGFsbCB1dnMgZnJvbSB0aGUgY2xvdXMgaW50byBhIHR5cGVkIGFycmF5XHJcbiAgICAgICAgdGhpcy7GknRleHR1cmVVVnMgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuY2xvdWQuZmxhdE1hcCgoX3ZlcnRleDogVmVydGV4KSA9PiBbLi4uX3ZlcnRleC51di5nZXQoKV0pXHJcbiAgICAgICAgKSk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyBnZXQgdmVydGljZXNGbGF0KCk6IEZsb2F0MzJBcnJheSB7XHJcbiAgICAgIHJldHVybiB0aGlzLsaSdmVydGljZXNGbGF0IHx8ICh0aGlzLsaSdmVydGljZXNGbGF0ID0gdGhpcy5jcmVhdGVWZXJ0aWNlc0ZsYXQoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBpbmRpY2VzRmxhdCgpOiBVaW50MTZBcnJheSB7XHJcbiAgICAgIHJldHVybiB0aGlzLsaSaW5kaWNlc0ZsYXQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBub3JtYWxzRmxhdCgpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICByZXR1cm4gdGhpcy7Gkm5vcm1hbHNGbGF0IHx8ICh0aGlzLsaSbm9ybWFsc0ZsYXQgPSB0aGlzLmNyZWF0ZU5vcm1hbHNGbGF0KCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgdGV4dHVyZVVWc0ZsYXQoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgcmV0dXJuIHRoaXMuxpJ0ZXh0dXJlVVZzRmxhdCB8fCAodGhpcy7GknRleHR1cmVVVnNGbGF0ID0gdGhpcy5jcmVhdGVUZXh0dXJlVVZzRmxhdCgpKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGJvdW5kaW5nQm94KCk6IEJveCB7XHJcbiAgICAgIGlmICh0aGlzLsaSYm94ID09IG51bGwpXHJcbiAgICAgICAgdGhpcy7GkmJveCA9IHRoaXMuY3JlYXRlQm91bmRpbmdCb3goKTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLsaSYm94O1xyXG4gICAgfVxyXG4gICAgcHVibGljIGdldCByYWRpdXMoKTogbnVtYmVyIHtcclxuICAgICAgaWYgKHRoaXMuxpJyYWRpdXMgPT0gbnVsbClcclxuICAgICAgICB0aGlzLsaScmFkaXVzID0gdGhpcy5jcmVhdGVSYWRpdXMoKTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLsaScmFkaXVzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB1c2VSZW5kZXJCdWZmZXJzKF9zaGFkZXI6IHR5cGVvZiBTaGFkZXIsIF9tdHhXb3JsZDogTWF0cml4NHg0LCBfbXR4UHJvamVjdGlvbjogTWF0cml4NHg0LCBfaWQ/OiBudW1iZXIpOiBudW1iZXIgeyByZXR1cm4gMDsgLyogaW5qZWN0ZWQgYnkgUmVuZGVySW5qZWN0b3IqLyB9XHJcbiAgICBwdWJsaWMgY3JlYXRlUmVuZGVyQnVmZmVycygpOiB2b2lkIHsvKiBpbmplY3RlZCBieSBSZW5kZXJJbmplY3RvciovIH1cclxuICAgIHB1YmxpYyBkZWxldGVSZW5kZXJCdWZmZXJzKF9zaGFkZXI6IHR5cGVvZiBTaGFkZXIpOiB2b2lkIHsvKiBpbmplY3RlZCBieSBSZW5kZXJJbmplY3RvciovIH1cclxuXHJcbiAgICBwdWJsaWMgY2xlYXIoKTogdm9pZCB7XHJcbiAgICAgIC8vIGJ1ZmZlcnMgZm9yIHNtb290aCBzaGFkaW5nXHJcbiAgICAgIHRoaXMuxpJ2ZXJ0aWNlcyA9IHVuZGVmaW5lZDtcclxuICAgICAgdGhpcy7GkmluZGljZXMgPSB1bmRlZmluZWQ7XHJcbiAgICAgIHRoaXMuxpJ0ZXh0dXJlVVZzID0gdW5kZWZpbmVkO1xyXG4gICAgICB0aGlzLsaSbm9ybWFsc1ZlcnRleCA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgIC8vIHNwZWNpYWwgYnVmZmVycyBmb3IgZmxhdCBzaGFkaW5nXHJcbiAgICAgIHRoaXMuxpJub3JtYWxzRmxhdCA9IHVuZGVmaW5lZDtcclxuICAgICAgdGhpcy7GknZlcnRpY2VzRmxhdCA9IHVuZGVmaW5lZDtcclxuICAgICAgdGhpcy7GkmluZGljZXNGbGF0ID0gdW5kZWZpbmVkO1xyXG4gICAgICB0aGlzLsaSdGV4dHVyZVVWc0ZsYXQgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAvLyBcclxuICAgICAgdGhpcy7Gkm5vcm1hbHNGYWNlVW5zY2FsZWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgIHRoaXMuxpJib3ggPSB1bmRlZmluZWQ7XHJcbiAgICAgIHRoaXMuxpJyYWRpdXMgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICB0aGlzLnJlbmRlckJ1ZmZlcnMgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgLy8gU2VyaWFsaXplL0Rlc2VyaWFsaXplIGZvciBhbGwgbWVzaGVzIHRoYXQgY2FsY3VsYXRlIHdpdGhvdXQgcGFyYW1ldGVyc1xyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgaWRSZXNvdXJjZTogdGhpcy5pZFJlc291cmNlLFxyXG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUgLy8gc3RvcmUgZm9yIGVkaXRvciB2aWV3XHJcbiAgICAgIH07IC8vIG5vIGRhdGEgbmVlZGVkIC4uLlxyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIFByb2plY3QucmVnaXN0ZXIodGhpcywgX3NlcmlhbGl6YXRpb24uaWRSZXNvdXJjZSk7XHJcbiAgICAgIHRoaXMubmFtZSA9IF9zZXJpYWxpemF0aW9uLm5hbWU7XHJcbiAgICAgIC8vIHR5cGUgaXMgYW4gYWNjZXNzb3IgYW5kIG11c3Qgbm90IGJlIGRlc2VyaWFsaXplZFxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICAvLyBUT0RPOiBzbyBtdWNoIHRvIGRlbGV0ZS4uLiByYXRoZXIganVzdCBnYXRoZXIgd2hhdCB0byBtdXRhdGVcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLsaSYm94O1xyXG4gICAgICBkZWxldGUgX211dGF0b3IuxpJyYWRpdXM7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci7GknZlcnRpY2VzO1xyXG4gICAgICBkZWxldGUgX211dGF0b3IuxpJpbmRpY2VzO1xyXG4gICAgICBkZWxldGUgX211dGF0b3IuxpJub3JtYWxzVmVydGV4O1xyXG4gICAgICBkZWxldGUgX211dGF0b3IuxpJub3JtYWxzRmFjZVVuc2NhbGVkO1xyXG4gICAgICBkZWxldGUgX211dGF0b3IuxpJ0ZXh0dXJlVVZzO1xyXG4gICAgICBkZWxldGUgX211dGF0b3IuxpJub3JtYWxzRmxhdDtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLsaSdmVydGljZXNGbGF0O1xyXG4gICAgICBkZWxldGUgX211dGF0b3IuxpJpbmRpY2VzRmxhdDtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLsaSdGV4dHVyZVVWc0ZsYXQ7XHJcblxyXG4gICAgICBkZWxldGUgX211dGF0b3IucmVuZGVyQnVmZmVycztcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIHByb3RlY3RlZCBjcmVhdGVWZXJ0aWNlc0ZsYXQoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgbGV0IHBvc2l0aW9uczogVmVjdG9yM1tdID0gW107XHJcbiAgICAgIGxldCBpbmRpY2VzOiBudW1iZXJbXSA9IFtdO1xyXG4gICAgICBsZXQgaTogbnVtYmVyID0gMDtcclxuICAgICAgZm9yIChsZXQgZmFjZSBvZiB0aGlzLmZhY2VzKVxyXG4gICAgICAgIGZvciAobGV0IGluZGV4IG9mIGZhY2UuaW5kaWNlcykge1xyXG4gICAgICAgICAgaW5kaWNlcy5wdXNoKGkrKyk7XHJcbiAgICAgICAgICBwb3NpdGlvbnMucHVzaCh0aGlzLmNsb3VkLnBvc2l0aW9uKGluZGV4KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICB0aGlzLsaSaW5kaWNlc0ZsYXQgPSBuZXcgVWludDE2QXJyYXkoaW5kaWNlcyk7XHJcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9ucy5mbGF0TWFwKF92ID0+IFsuLi5fdi5nZXQoKV0pKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlTm9ybWFsc0ZsYXQoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgbGV0IG5vcm1hbHM6IFZlY3RvcjNbXSA9IFtdO1xyXG4gICAgICBsZXQgemVybzogVmVjdG9yMyA9IFZlY3RvcjMuWkVSTygpO1xyXG4gICAgICBmb3IgKGxldCBmYWNlIG9mIHRoaXMuZmFjZXMpIHtcclxuICAgICAgICAvLyBzdG9yZSB0aGUgZmFjZSBub3JtYWwgYXQgdGhlIHBvc2l0aW9uIG9mIHRoZSB0aGlyZCB2ZXJ0ZXhcclxuICAgICAgICBub3JtYWxzLnB1c2goemVybyk7XHJcbiAgICAgICAgbm9ybWFscy5wdXNoKHplcm8pO1xyXG4gICAgICAgIG5vcm1hbHMucHVzaChmYWNlLm5vcm1hbCk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy7Gkm5vcm1hbHNGbGF0ID0gbmV3IEZsb2F0MzJBcnJheShub3JtYWxzLmZsYXRNYXAoX24gPT4gWy4uLl9uLmdldCgpXSkpO1xyXG4gICAgICByZXR1cm4gdGhpcy7Gkm5vcm1hbHNGbGF0O1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBjcmVhdGVUZXh0dXJlVVZzRmxhdCgpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICBsZXQgdXY6IG51bWJlcltdID0gW107XHJcbiAgICAgIC8vIGNyZWF0ZSB1bmlxdWUgdmVydGljZXMgZm9yIGVhY2ggZmFjZSwgdHJpcGxpbmcgdGhlIG51bWJlclxyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5pbmRpY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IGluZGV4OiBudW1iZXIgPSB0aGlzLmluZGljZXNbaV0gKiAyO1xyXG4gICAgICAgIHV2LnB1c2godGhpcy50ZXh0dXJlVVZzW2luZGV4XSwgdGhpcy50ZXh0dXJlVVZzW2luZGV4ICsgMV0pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KHV2KTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY2FsY3VsYXRlRmFjZUNyb3NzUHJvZHVjdHMoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgbGV0IGNyb3NzUHJvZHVjdHM6IG51bWJlcltdID0gW107XHJcbiAgICAgIGxldCB2ZXJ0aWNlczogVmVjdG9yM1tdID0gW107XHJcblxyXG4gICAgICBmb3IgKGxldCB2OiBudW1iZXIgPSAwOyB2IDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IHYgKz0gMylcclxuICAgICAgICB2ZXJ0aWNlcy5wdXNoKG5ldyBWZWN0b3IzKHRoaXMudmVydGljZXNbdl0sIHRoaXMudmVydGljZXNbdiArIDFdLCB0aGlzLnZlcnRpY2VzW3YgKyAyXSkpO1xyXG5cclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMuaW5kaWNlcy5sZW5ndGg7IGkgKz0gMykge1xyXG4gICAgICAgIGxldCB0cmlnb246IG51bWJlcltdID0gW3RoaXMuaW5kaWNlc1tpXSwgdGhpcy5pbmRpY2VzW2kgKyAxXSwgdGhpcy5pbmRpY2VzW2kgKyAyXV07XHJcblxyXG4gICAgICAgIGxldCB2MDogVmVjdG9yMyA9IFZlY3RvcjMuRElGRkVSRU5DRSh2ZXJ0aWNlc1t0cmlnb25bMF1dLCB2ZXJ0aWNlc1t0cmlnb25bMV1dKTtcclxuICAgICAgICBsZXQgdjE6IFZlY3RvcjMgPSBWZWN0b3IzLkRJRkZFUkVOQ0UodmVydGljZXNbdHJpZ29uWzBdXSwgdmVydGljZXNbdHJpZ29uWzJdXSk7XHJcbiAgICAgICAgbGV0IGNyb3NzUHJvZHVjdDogVmVjdG9yMyA9IFZlY3RvcjMuQ1JPU1ModjAsIHYxKTtcclxuICAgICAgICBsZXQgaW5kZXg6IG51bWJlciA9IHRyaWdvblsyXSAqIDM7XHJcbiAgICAgICAgY3Jvc3NQcm9kdWN0c1tpbmRleF0gPSBjcm9zc1Byb2R1Y3QueDtcclxuICAgICAgICBjcm9zc1Byb2R1Y3RzW2luZGV4ICsgMV0gPSBjcm9zc1Byb2R1Y3QueTtcclxuICAgICAgICBjcm9zc1Byb2R1Y3RzW2luZGV4ICsgMl0gPSBjcm9zc1Byb2R1Y3QuejtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShjcm9zc1Byb2R1Y3RzKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlUmFkaXVzKCk6IG51bWJlciB7XHJcbiAgICAgIC8vVE9ETzogcmFkaXVzIGFuZCBib3VuZGluZyBib3ggY291bGQgYmUgY3JlYXRlZCBvbiBjb25zdHJ1Y3Rpb24gb2YgdmVydGV4LWFycmF5XHJcbiAgICAgIGxldCByYWRpdXM6IG51bWJlciA9IDA7XHJcbiAgICAgIGZvciAobGV0IHZlcnRleDogbnVtYmVyID0gMDsgdmVydGV4IDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IHZlcnRleCArPSAzKSB7XHJcbiAgICAgICAgcmFkaXVzID0gTWF0aC5tYXgocmFkaXVzLCBNYXRoLmh5cG90KHRoaXMudmVydGljZXNbdmVydGV4XSwgdGhpcy52ZXJ0aWNlc1t2ZXJ0ZXggKyAxXSwgdGhpcy52ZXJ0aWNlc1t2ZXJ0ZXggKyAyXSkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByYWRpdXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZUJvdW5kaW5nQm94KCk6IEJveCB7XHJcbiAgICAgIGxldCBib3g6IEJveCA9IFJlY3ljbGVyLmdldChCb3gpO1xyXG4gICAgICBib3guc2V0KCk7XHJcbiAgICAgIGZvciAobGV0IHZlcnRleDogbnVtYmVyID0gMDsgdmVydGV4IDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IHZlcnRleCArPSAzKSB7XHJcbiAgICAgICAgYm94Lm1pbi54ID0gTWF0aC5taW4odGhpcy52ZXJ0aWNlc1t2ZXJ0ZXhdLCBib3gubWluLngpO1xyXG4gICAgICAgIGJveC5tYXgueCA9IE1hdGgubWF4KHRoaXMudmVydGljZXNbdmVydGV4XSwgYm94Lm1heC54KTtcclxuICAgICAgICBib3gubWluLnkgPSBNYXRoLm1pbih0aGlzLnZlcnRpY2VzW3ZlcnRleCArIDFdLCBib3gubWluLnkpO1xyXG4gICAgICAgIGJveC5tYXgueSA9IE1hdGgubWF4KHRoaXMudmVydGljZXNbdmVydGV4ICsgMV0sIGJveC5tYXgueSk7XHJcbiAgICAgICAgYm94Lm1pbi56ID0gTWF0aC5taW4odGhpcy52ZXJ0aWNlc1t2ZXJ0ZXggKyAyXSwgYm94Lm1pbi56KTtcclxuICAgICAgICBib3gubWF4LnogPSBNYXRoLm1heCh0aGlzLnZlcnRpY2VzW3ZlcnRleCArIDJdLCBib3gubWF4LnopO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBib3g7XHJcbiAgICB9XHJcblxyXG5cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBHZW5lcmF0ZSBhIHNpbXBsZSBjdWJlIHdpdGggZWRnZXMgb2YgbGVuZ3RoIDEsIGVhY2ggZmFjZSBjb25zaXN0aW5nIG9mIHR3byB0cmlnb25zXHJcbiAgICogYGBgcGxhaW50ZXh0XHJcbiAgICogICAgICAgKDEyKSA0X19fXzcgICgxMSlcclxuICAgKiAgICAgICAoOCkgMC9fXzMvfCAoMTApXHJcbiAgICogICAgICAgKDE1KSB8fDVffHw2ICgxNClcclxuICAgKiAgICAgICAoOSkgMXwvXzJ8LyAoMTMpXHJcbiAgICogYGBgXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgTWVzaEN1YmUgZXh0ZW5kcyBNZXNoIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBNZXNoLnJlZ2lzdGVyU3ViY2xhc3MoTWVzaEN1YmUpO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nID0gXCJNZXNoQ3ViZVwiKSB7XHJcbiAgICAgIHN1cGVyKF9uYW1lKTtcclxuICAgICAgLy8gdGhpcy5jcmVhdGUoKTtcclxuICAgICAgdGhpcy5jbG91ZCA9IG5ldyBWZXJ0aWNlcyhcclxuICAgICAgICAvLyBmcm9udFxyXG4gICAgICAgIG5ldyBWZXJ0ZXgobmV3IFZlY3RvcjMoLTAuNSwgMC41LCAwLjUpLCBuZXcgVmVjdG9yMigwLCAwKSksIC8vIDBcclxuICAgICAgICBuZXcgVmVydGV4KG5ldyBWZWN0b3IzKC0wLjUsIC0wLjUsIDAuNSksIG5ldyBWZWN0b3IyKDAsIDEpKSwgLy8gMVxyXG4gICAgICAgIG5ldyBWZXJ0ZXgobmV3IFZlY3RvcjMoMC41LCAtMC41LCAwLjUpLCBuZXcgVmVjdG9yMigxLCAxKSksIC8vIDJcclxuICAgICAgICBuZXcgVmVydGV4KG5ldyBWZWN0b3IzKDAuNSwgMC41LCAwLjUpLCBuZXcgVmVjdG9yMigxLCAwKSksIC8vIDNcclxuICAgICAgICAvLyBiYWNrXHJcbiAgICAgICAgbmV3IFZlcnRleChuZXcgVmVjdG9yMygtMC41LCAwLjUsIC0wLjUpLCBuZXcgVmVjdG9yMigzLCAwKSksIC8vIDRcclxuICAgICAgICBuZXcgVmVydGV4KG5ldyBWZWN0b3IzKC0wLjUsIC0wLjUsIC0wLjUpLCBuZXcgVmVjdG9yMigzLCAxKSksIC8vIDVcclxuICAgICAgICBuZXcgVmVydGV4KG5ldyBWZWN0b3IzKDAuNSwgLTAuNSwgLTAuNSksIG5ldyBWZWN0b3IyKDIsIDEpKSwgLy8gNlxyXG4gICAgICAgIG5ldyBWZXJ0ZXgobmV3IFZlY3RvcjMoMC41LCAwLjUsIC0wLjUpLCBuZXcgVmVjdG9yMigyLCAwKSksIC8vIDdcclxuICAgICAgICAvLyByZWZlcmVuY2VzXHJcbiAgICAgICAgbmV3IFZlcnRleCgwLCBuZXcgVmVjdG9yMig0LCAwKSksIC8vIDhcclxuICAgICAgICBuZXcgVmVydGV4KDEsIG5ldyBWZWN0b3IyKDQsIDEpKSwgLy8gOVxyXG4gICAgICAgIG5ldyBWZXJ0ZXgoMywgbmV3IFZlY3RvcjIoMCwgMSkpLCAvLyAxMFxyXG4gICAgICAgIG5ldyBWZXJ0ZXgoNywgbmV3IFZlY3RvcjIoMSwgMSkpLCAvLyAxMVxyXG4gICAgICAgIG5ldyBWZXJ0ZXgoNCwgbmV3IFZlY3RvcjIoMSwgMCkpLCAvLyAxMlxyXG4gICAgICAgIG5ldyBWZXJ0ZXgoMiwgbmV3IFZlY3RvcjIoMCwgMCkpLCAvLyAxM1xyXG4gICAgICAgIG5ldyBWZXJ0ZXgoNiwgbmV3IFZlY3RvcjIoMSwgMCkpLCAvLyAxNFxyXG4gICAgICAgIG5ldyBWZXJ0ZXgoNSwgbmV3IFZlY3RvcjIoMSwgMSkpICAvLyAxNVxyXG4gICAgICApO1xyXG5cclxuICAgICAgdGhpcy5mYWNlcyA9IFtcclxuICAgICAgICAuLi5uZXcgUXVhZCh0aGlzLmNsb3VkLCAwLCAxLCAyLCAzKS5mYWNlcywgLy8gZnJvbnRcclxuICAgICAgICAuLi5uZXcgUXVhZCh0aGlzLmNsb3VkLCA3LCA2LCA1LCA0KS5mYWNlcywgLy8gYmFja1xyXG4gICAgICAgIC4uLm5ldyBRdWFkKHRoaXMuY2xvdWQsIDMsIDIsIDYsIDcpLmZhY2VzLCAvLyByaWdodFxyXG4gICAgICAgIC4uLm5ldyBRdWFkKHRoaXMuY2xvdWQsIDQsIDUsIDksIDgpLmZhY2VzLCAvLyBsZWZ0XHJcbiAgICAgICAgLi4ubmV3IFF1YWQodGhpcy5jbG91ZCwgMCwgMTAsIDExLCAxMikuZmFjZXMsIC8vIHRvcFxyXG4gICAgICAgIC4uLm5ldyBRdWFkKHRoaXMuY2xvdWQsIDEzLCAxLCAxNSwgMTQpLmZhY2VzICAvLyBib3R0b21cclxuICAgICAgXTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBHZW5lcmF0ZSBhIGZsYXQgcG9seWdvbi4gQWxsIHRyaWdvbnMgc2hhcmUgdmVydGV4IDAsIHNvIGNhcmVmdWwgZGVzaWduIGlzIHJlcXVpcmVkIHRvIGNyZWF0ZSBjb25jYXZlIHBvbHlnb25zLiBcclxuICAgKiBWZXJ0ZXggMCBpcyBhbHNvIGFzc29jaWF0ZWQgd2l0aCB0aGUgZmFjZSBub3JtYWwuXHJcbiAgICogYGBgcGxhaW50ZXh0XHJcbiAgICogICAgICAgICAgICAgMCBcclxuICAgKiAgICAgICAgICAgMeKVsXzilbIgIDQgLi4uXHJcbiAgICogICAgICAgICAgICDilbJ8X+KVsuKVsSBcclxuICAgKiAgICAgICAgICAgIDIgICAzXHJcbiAgICogYGBgXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjEtMjAyMlxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBNZXNoUG9seWdvbiBleHRlbmRzIE1lc2gge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IE1lc2gucmVnaXN0ZXJTdWJjbGFzcyhNZXNoUG9seWdvbik7XHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHNoYXBlRGVmYXVsdDogVmVjdG9yMltdID0gWyAvLyB0cmlnb24gaXMgdGhlIG1pbmltYWwgc2hhcGVcclxuICAgICAgbmV3IFZlY3RvcjIoLTEsIC0xKSxcclxuICAgICAgbmV3IFZlY3RvcjIoMSwgLTEpLFxyXG4gICAgICBuZXcgVmVjdG9yMigwLCAxKVxyXG4gICAgXTtcclxuICAgIHByb3RlY3RlZCBzaGFwZTogTXV0YWJsZUFycmF5PFZlY3RvcjI+ID0gbmV3IE11dGFibGVBcnJheTxWZWN0b3IyPigpO1xyXG4gICAgcHJvdGVjdGVkIGZpdFRleHR1cmU6IGJvb2xlYW47XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9uYW1lOiBzdHJpbmcgPSBcIk1lc2hQb2x5Z29uXCIsIF9zaGFwZTogVmVjdG9yMltdID0gTWVzaFBvbHlnb24uc2hhcGVEZWZhdWx0LCBfZml0VGV4dHVyZTogYm9vbGVhbiA9IHRydWUpIHtcclxuICAgICAgc3VwZXIoX25hbWUpO1xyXG4gICAgICB0aGlzLmNyZWF0ZShfc2hhcGUsIF9maXRUZXh0dXJlKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgZ2V0IG1pblZlcnRpY2VzKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiAzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBjcmVhdGUoX3NoYXBlOiBWZWN0b3IyW10gPSBbXSwgX2ZpdFRleHR1cmU6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuc2hhcGUgPSA8TXV0YWJsZUFycmF5PFZlY3RvcjI+Pk11dGFibGVBcnJheS5mcm9tKF9zaGFwZS5tYXAoX3ZlcnRleCA9PiBfdmVydGV4LmNsb25lKSk7XHJcbiAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgICAgdGhpcy5maXRUZXh0dXJlID0gX2ZpdFRleHR1cmU7XHJcblxyXG4gICAgICBpZiAoX3NoYXBlLmxlbmd0aCA8IHRoaXMubWluVmVydGljZXMpIHtcclxuICAgICAgICBEZWJ1Zy53YXJuKGBBdCBsZWFzdCAke3RoaXMubWluVmVydGljZXN9IHZlcnRpY2VzIG5lZWRlZCB0byBjb25zdHJ1Y3QgTWVzaFBvbHlnb24sIGRlZmF1bHQgdHJpZ29uIHVzZWRgKTtcclxuICAgICAgICB0aGlzLmNyZWF0ZShNZXNoUG9seWdvbi5zaGFwZURlZmF1bHQsIHRydWUpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IHNoYXBlOiBWZWN0b3IyW10gPSBfc2hhcGU7XHJcblxyXG4gICAgICBsZXQgbWluOiBWZWN0b3IyID0gVmVjdG9yMi5aRVJPKCk7XHJcbiAgICAgIGxldCBtYXg6IFZlY3RvcjIgPSBWZWN0b3IyLlpFUk8oKTtcclxuICAgICAgdGhpcy5jbG91ZCA9IG5ldyBWZXJ0aWNlcygpO1xyXG4gICAgICBmb3IgKGxldCB2ZXJ0ZXggb2Ygc2hhcGUpIHtcclxuICAgICAgICB0aGlzLmNsb3VkLnB1c2gobmV3IFZlcnRleCh2ZXJ0ZXgudG9WZWN0b3IzKCkpKTtcclxuXHJcbiAgICAgICAgbWluLnggPSBNYXRoLm1pbihtaW4ueCwgdmVydGV4LngpO1xyXG4gICAgICAgIG1heC54ID0gTWF0aC5tYXgobWF4LngsIHZlcnRleC54KTtcclxuICAgICAgICBtaW4ueSA9IE1hdGgubWluKG1pbi55LCB2ZXJ0ZXgueSk7XHJcbiAgICAgICAgbWF4LnkgPSBNYXRoLm1heChtYXgueSwgdmVydGV4LnkpO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCBzaXplOiBWZWN0b3IyID0gbmV3IFZlY3RvcjIobWF4LnggLSBtaW4ueCwgbWF4LnkgLSBtaW4ueSk7XHJcblxyXG4gICAgICBpZiAodGhpcy5maXRUZXh0dXJlKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHNoYXBlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBsZXQgdGV4dHVyZVVWOiBWZWN0b3IyID0gVmVjdG9yMi5TVU0oc2hhcGVbaV0sIG1pbik7XHJcbiAgICAgICAgICB0aGlzLmNsb3VkW2ldLnV2ID0gbmV3IFZlY3RvcjIodGV4dHVyZVVWLnggLyBzaXplLngsIC10ZXh0dXJlVVYueSAvIHNpemUueSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIF9zaGFwZS5mb3JFYWNoKChfdmVydGV4LCBpKSA9PiB0aGlzLmNsb3VkW2ldLnV2ID0gbmV3IFZlY3RvcjIoX3ZlcnRleC54LCAtX3ZlcnRleC55KSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuZmFjZXMgPSBbXTtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMjsgaSA8IHRoaXMuY2xvdWQubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgdGhpcy5mYWNlcy5wdXNoKG5ldyBGYWNlKHRoaXMuY2xvdWQsIGkgLSAxLCBpLCAwKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnNoYXBlID0gU2VyaWFsaXplci5zZXJpYWxpemVBcnJheShWZWN0b3IyLCB0aGlzLnNoYXBlKTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5maXRUZXh0dXJlID0gdGhpcy5maXRUZXh0dXJlO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgbGV0IHZlY3RvcnM6IFZlY3RvcjJbXSA9IDxWZWN0b3IyW10+YXdhaXQgU2VyaWFsaXplci5kZXNlcmlhbGl6ZUFycmF5KF9zZXJpYWxpemF0aW9uLnNoYXBlKTtcclxuICAgICAgdGhpcy5jcmVhdGUodmVjdG9ycywgX3NlcmlhbGl6YXRpb24uZml0VGV4dHVyZSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgYXdhaXQgc3VwZXIubXV0YXRlKF9tdXRhdG9yKTtcclxuICAgICAgdGhpcy5jcmVhdGUodGhpcy5zaGFwZSwgX211dGF0b3IuZml0VGV4dHVyZSk7XHJcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuTVVUQVRFKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgc3VwZXIucmVkdWNlTXV0YXRvcihfbXV0YXRvcik7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICB9XHJcbn0iLCIvLy88cmVmZXJlbmNlIHBhdGg9XCJNZXNoUG9seWdvbi50c1wiLz5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogR2VuZXJhdGVzIGFuIGV4dHJ1c2lvbiBvZiBhIHBvbHlnb24gYnkgYSBzZXJpZXMgb2YgdHJhbnNmb3JtYXRpb25zXHJcbiAgICogYGBgcGxhaW50ZXh0ICBcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICBfX19fXHJcbiAgICogUG9seWdvbiAgICAgICAgIF9fX1/ilbHilbIgICDilbIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlcclxuICAgKiBUcmFuc2Zvcm0gMCAg4oaSIOKVsSDilbJfX+KVsl/ilbJfX1/ilbIg4oaQIFRyYW5zZm9ybSAyICAgICAgICAgIHogX1/ilIJcclxuICAgKiAoYmFzZSkgICAgICAgICDilbJf4pWxX1/ilbEg4pWxICAg4pWxICAgKGxpZCkgICAgICAgICAgICAgICAgICAgICDilbIgICAgICAgXHJcbiAgICogICAgIFRyYW5zZm9ybSAxICDihpIgIOKVsuKVsV9fX+KVsSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4XHJcbiAgICogYGBgXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjEtMjAyMlxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBNZXNoRXh0cnVzaW9uIGV4dGVuZHMgTWVzaFBvbHlnb24ge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IE1lc2gucmVnaXN0ZXJTdWJjbGFzcyhNZXNoRXh0cnVzaW9uKTtcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgbXR4RGVmYXVsdHM6IE1hdHJpeDR4NFtdID0gWyAvLyBvZmZzZXQgb2YgKzAuNXogYW5kIC0wLjV6IGFzIGRlZmF1bHRcclxuICAgICAgTWF0cml4NHg0LlRSQU5TTEFUSU9OKFZlY3RvcjMuWigwLjUpKSxcclxuICAgICAgTWF0cml4NHg0LlRSQU5TTEFUSU9OKFZlY3RvcjMuWigtMC41KSlcclxuICAgIF07XHJcbiAgICBwcml2YXRlIG10eFRyYW5zZm9ybXM6IE11dGFibGVBcnJheTxNYXRyaXg0eDQ+ID0gbmV3IE11dGFibGVBcnJheTxNYXRyaXg0eDQ+KCk7XHJcbiAgICAvLyBwcml2YXRlIHRyYW5zZm9ybXM6IE11dGFibGVBcnJheTxNYXRyaXg0eDQ+ID0gbmV3IE11dGFibGVBcnJheShNYXRyaXg0eDQpO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nID0gXCJNZXNoRXh0cnVzaW9uXCIsIF92ZXJ0aWNlczogVmVjdG9yMltdID0gTWVzaFBvbHlnb24uc2hhcGVEZWZhdWx0LCBfbXR4VHJhbnNmb3JtczogTWF0cml4NHg0W10gPSBNZXNoRXh0cnVzaW9uLm10eERlZmF1bHRzLCBfZml0VGV4dHVyZTogYm9vbGVhbiA9IHRydWUpIHtcclxuICAgICAgc3VwZXIoX25hbWUsIF92ZXJ0aWNlcywgX2ZpdFRleHR1cmUpO1xyXG4gICAgICB0aGlzLmV4dHJ1ZGUoX210eFRyYW5zZm9ybXMpO1xyXG4gICAgICAvLyBjb25zb2xlLmxvZyhcIk11dGF0b3JcIiwgdGhpcy5nZXRNdXRhdG9yKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbi50cmFuc2Zvcm1zID0gU2VyaWFsaXplci5zZXJpYWxpemVBcnJheShNYXRyaXg0eDQsIHRoaXMubXR4VHJhbnNmb3Jtcyk7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgbGV0IG10eFRyYW5zZm9ybXM6IE1hdHJpeDR4NFtdO1xyXG4gICAgICBpZiAoX3NlcmlhbGl6YXRpb24udHJhbnNmb3JtcylcclxuICAgICAgICBtdHhUcmFuc2Zvcm1zID0gPE1hdHJpeDR4NFtdPmF3YWl0IFNlcmlhbGl6ZXIuZGVzZXJpYWxpemVBcnJheShfc2VyaWFsaXphdGlvbi50cmFuc2Zvcm1zKTtcclxuICAgICAgdGhpcy5leHRydWRlKG10eFRyYW5zZm9ybXMpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIGF3YWl0IHN1cGVyLm11dGF0ZShfbXV0YXRvcik7XHJcbiAgICAgIHRoaXMuZXh0cnVkZSh0aGlzLm10eFRyYW5zZm9ybXMpO1xyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULk1VVEFURSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIHN1cGVyLnJlZHVjZU11dGF0b3IoX211dGF0b3IpO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG5cclxuICAgIHByaXZhdGUgZXh0cnVkZShfbXR4VHJhbnNmb3JtczogTWF0cml4NHg0W10gPSBNZXNoRXh0cnVzaW9uLm10eERlZmF1bHRzKTogdm9pZCB7XHJcbiAgICAgIHRoaXMubXR4VHJhbnNmb3JtcyA9IDxNdXRhYmxlQXJyYXk8TWF0cml4NHg0Pj5NdXRhYmxlQXJyYXkuZnJvbSg8TXV0YWJsZUFycmF5PE1hdHJpeDR4ND4+X210eFRyYW5zZm9ybXMpO1xyXG4gICAgICBsZXQgblRyYW5zZm9ybXM6IG51bWJlciA9IF9tdHhUcmFuc2Zvcm1zLmxlbmd0aDtcclxuICAgICAgbGV0IG5WZXJ0aWNlc1NoYXBlOiBudW1iZXIgPSB0aGlzLmNsb3VkLmxlbmd0aDtcclxuXHJcbiAgICAgIC8vIGNyZWF0ZSBuZXcgdmVydGV4IGNsb3VkLCBjdXJyZW50IGNsb3VkIGhvbGRzIE1lc2hQb2x5Z29uXHJcbiAgICAgIGxldCB2ZXJ0aWNlczogVmVydGljZXMgPSBuZXcgVmVydGljZXMoKTtcclxuXHJcbiAgICAgIC8vIGNyZWF0ZSBiYXNlIGJ5IHRyYW5zZm9ybWF0aW9uIG9mIHBvbHlnb24gd2l0aCBmaXJzdCB0cmFuc2Zvcm1cclxuICAgICAgbGV0IGJhc2U6IFZlcnRleFtdID0gdGhpcy5jbG91ZC5tYXAoKF92OiBWZXJ0ZXgpID0+IG5ldyBWZXJ0ZXgoVmVjdG9yMy5UUkFOU0ZPUk1BVElPTihfdi5wb3NpdGlvbiwgX210eFRyYW5zZm9ybXNbMF0sIHRydWUpLCBfdi51dikpO1xyXG4gICAgICB2ZXJ0aWNlcy5wdXNoKC4uLmJhc2UpO1xyXG4gICAgICAvLyBjcmVhdGUgbGlkIGJ5IHRyYW5zZm9ybWF0aW9uIG9mIHBvbHlnb24gd2l0aCBsYXN0IHRyYW5zZm9ybVxyXG4gICAgICBsZXQgbGlkOiBWZXJ0ZXhbXSA9IHRoaXMuY2xvdWQubWFwKChfdjogVmVydGV4KSA9PiBuZXcgVmVydGV4KFZlY3RvcjMuVFJBTlNGT1JNQVRJT04oX3YucG9zaXRpb24sIF9tdHhUcmFuc2Zvcm1zW25UcmFuc2Zvcm1zIC0gMV0sIHRydWUpLCBfdi51dikpO1xyXG4gICAgICB2ZXJ0aWNlcy5wdXNoKC4uLmxpZCk7XHJcblxyXG4gICAgICAvLyByZWNyZWF0ZSBiYXNlIGZhY2VzIHRvIHJlY2FsY3VsYXRlIG5vcm1hbHNcclxuICAgICAgdGhpcy5mYWNlcyA9IHRoaXMuZmFjZXMubWFwKChfZmFjZTogRmFjZSkgPT4gbmV3IEZhY2UodmVydGljZXMsIF9mYWNlLmluZGljZXNbMF0sIF9mYWNlLmluZGljZXNbMV0sIF9mYWNlLmluZGljZXNbMl0pKTtcclxuICAgICAgLy8gY3JlYXRlIHRoZSBsaWQgZmFjZXMgdXNpbmcgdGhlIGluZGljZXMgb2YgdGhlIGJhc2UgZmFjZXMsIGJ1dCB3aXRoIGFuIGluZGV4IG9mZnNldCBhbmQgcmV2ZXJzZSBvcmRlciBvZiBpbmRpY2VzXHJcbiAgICAgIHRoaXMuZmFjZXMucHVzaCguLi50aGlzLmZhY2VzLm1hcChfZmFjZSA9PlxyXG4gICAgICAgIG5ldyBGYWNlKHZlcnRpY2VzLCBfZmFjZS5pbmRpY2VzWzJdICsgblZlcnRpY2VzU2hhcGUsIF9mYWNlLmluZGljZXNbMV0gKyBuVmVydGljZXNTaGFwZSwgX2ZhY2UuaW5kaWNlc1swXSArIG5WZXJ0aWNlc1NoYXBlKVxyXG4gICAgICApKTtcclxuXHJcbiAgICAgIGZvciAobGV0IHQ6IG51bWJlciA9IDA7IHQgPCBuVHJhbnNmb3JtczsgdCsrKSB7XHJcbiAgICAgICAgbGV0IG10eFRyYW5zZm9ybTogTWF0cml4NHg0ID0gX210eFRyYW5zZm9ybXNbdF07XHJcbiAgICAgICAgbGV0IHJlZmVyVG9DbG9zZTogbnVtYmVyID0gdmVydGljZXMubGVuZ3RoO1xyXG4gICAgICAgIGxldCB3cmFwOiBWZXJ0ZXhbXSA9IHRoaXMuY2xvdWQubWFwKChfdjogVmVydGV4LCBfaTogbnVtYmVyKSA9PlxyXG4gICAgICAgICAgbmV3IFZlcnRleChWZWN0b3IzLlRSQU5TRk9STUFUSU9OKF92LnBvc2l0aW9uLCBtdHhUcmFuc2Zvcm0sIHRydWUpLCBuZXcgVmVjdG9yMihfaSAvIG5WZXJ0aWNlc1NoYXBlLCB0IC8gblRyYW5zZm9ybXMpKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdmVydGljZXMucHVzaCguLi53cmFwKTtcclxuICAgICAgICB2ZXJ0aWNlcy5wdXNoKG5ldyBWZXJ0ZXgocmVmZXJUb0Nsb3NlLCBuZXcgVmVjdG9yMigxLCB0IC8gblRyYW5zZm9ybXMpKSk7XHJcbiAgICAgICAgLy8gaWYgKGkgPiAwICYmIGkgPCBuVHJhbnNmb3JtcyAtIDEpXHJcbiAgICAgICAgLy8gICB2ZXJ0aWNlcy5wdXNoKC4uLndyYXAubWFwKChfdmVjdG9yOiBWZWN0b3IzKSA9PiBfdmVjdG9yLmNsb25lKSk7IDwtIG5vIHNsaWNpbmcgZm9yIGZsYXQgc2hhZGluZyB5ZXQuLi5cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gY3JlYXRlIGluZGl6ZXMgZm9yIHdyYXBwZXJcclxuICAgICAgZm9yIChsZXQgdDogbnVtYmVyID0gMDsgdCA8IG5UcmFuc2Zvcm1zIC0gMTsgdCsrKVxyXG4gICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBuVmVydGljZXNTaGFwZTsgaSsrKSB7XHJcbiAgICAgICAgICBsZXQgaW5kZXg6IG51bWJlciA9XHJcbiAgICAgICAgICAgICsgMiAqIG5WZXJ0aWNlc1NoYXBlIC8vIGJhc2UgJiBsaWQgYXJlIG9mZnNldHMgXHJcbiAgICAgICAgICAgICsgdCAqIChuVmVydGljZXNTaGFwZSArIDEpIC8vIG9mZnNldCBmb3IgZWFjaCB0cmFuc2Zvcm1hdGlvblxyXG4gICAgICAgICAgICArIGk7XHJcbiAgICAgICAgICBsZXQgcXVhZDogUXVhZCA9IG5ldyBRdWFkKHZlcnRpY2VzLCBpbmRleCwgaW5kZXggKyBuVmVydGljZXNTaGFwZSArIDEsIGluZGV4ICsgblZlcnRpY2VzU2hhcGUgKyAyLCBpbmRleCArIDEsIFFVQURTUExJVC5BVF8wKTtcclxuICAgICAgICAgIHRoaXMuZmFjZXMucHVzaCguLi5xdWFkLmZhY2VzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICB0aGlzLmNsb3VkID0gdmVydGljZXM7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gcHJpdmF0ZSBjYWxjdWxhdGVQb2x5Z29uTGVuZ3RocygpOiBudW1iZXJbXSB7XHJcbiAgICAvLyAgIGxldCByZXN1bHQ6IG51bWJlcltdID0gW107XHJcbiAgICAvLyAgIGxldCBmaXJzdDogVmVjdG9yMztcclxuICAgIC8vICAgbGV0IHByZXY6IFZlY3RvcjM7XHJcbiAgICAvLyAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSArPSAzKSB7XHJcbiAgICAvLyAgICAgbGV0IGN1cnJlbnQ6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMyh0aGlzLnZlcnRpY2VzW2ldLCB0aGlzLnZlcnRpY2VzW2kgKyAxXSwgdGhpcy52ZXJ0aWNlc1tpICsgMl0pO1xyXG4gICAgLy8gICAgIGlmIChwcmV2KVxyXG4gICAgLy8gICAgICAgcmVzdWx0LnB1c2goVmVjdG9yMy5ESUZGRVJFTkNFKGN1cnJlbnQsIHByZXYpLm1hZ25pdHVkZSk7XHJcbiAgICAvLyAgICAgZWxzZVxyXG4gICAgLy8gICAgICAgZmlyc3QgPSBjdXJyZW50O1xyXG4gICAgLy8gICAgIHByZXYgPSBjdXJyZW50O1xyXG4gICAgLy8gICB9XHJcbiAgICAvLyAgIHJlc3VsdC5wdXNoKFZlY3RvcjMuRElGRkVSRU5DRShmaXJzdCwgcHJldikubWFnbml0dWRlKTtcclxuICAgIC8vICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIC8vIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuXHJcbiAgICAvKiogQWxsb3dzIHRvIGNyZWF0ZSBjdXN0b20gbWVzaGVzIGZyb20gZ2l2ZW4gRGF0YSAqL1xyXG4gICAgZXhwb3J0IGNsYXNzIE1lc2hGcm9tRGF0YSBleHRlbmRzIE1lc2gge1xyXG4gICAgICAgICAgICBwcm90ZWN0ZWQgdmVydGljZXNUb1NldDogRmxvYXQzMkFycmF5O1xyXG4gICAgICAgICAgICBwcm90ZWN0ZWQgdGV4dHVyZVVWc1RvU2V0OiBGbG9hdDMyQXJyYXk7XHJcbiAgICAgICAgICAgIHByb3RlY3RlZCBpbmRpY2VzVG9TZXQ6IFVpbnQxNkFycmF5O1xyXG4gICAgICAgICAgICBwcm90ZWN0ZWQgZmFjZU5vcm1hbHNUb1NldDogRmxvYXQzMkFycmF5O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfdmVydGljZXM6IEZsb2F0MzJBcnJheSwgX3RleHR1cmVVVnM6IEZsb2F0MzJBcnJheSwgX2luZGljZXM6IFVpbnQxNkFycmF5LCBfZmFjZU5vcm1hbHM6IEZsb2F0MzJBcnJheSkge1xyXG4gICAgICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzVG9TZXQgPSBfdmVydGljZXM7XHJcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZVVWc1RvU2V0ID0gX3RleHR1cmVVVnM7XHJcbiAgICAgICAgICAgIHRoaXMuaW5kaWNlc1RvU2V0ID0gX2luZGljZXM7XHJcbiAgICAgICAgICAgIHRoaXMuZmFjZU5vcm1hbHNUb1NldCA9IF9mYWNlTm9ybWFscztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByb3RlY3RlZCBjcmVhdGVWZXJ0aWNlcygpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJ0aWNlc1RvU2V0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJvdGVjdGVkIGNyZWF0ZVRleHR1cmVVVnMoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZVVWc1RvU2V0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJvdGVjdGVkIGNyZWF0ZUluZGljZXMoKTogVWludDE2QXJyYXkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRpY2VzVG9TZXQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcm90ZWN0ZWQgY3JlYXRlRmxhdE5vcm1hbHMoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmFjZU5vcm1hbHNUb1NldDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIC8qKlNpbXBsZSBXYXZlZnJvbnQgT0JKIGltcG9ydC4gVGFrZXMgYSB3YXZlZnJvbnQgb2JqIHN0cmluZy4gVG8gTG9hZCBmcm9tIGEgZmlsZSB1cmwsIHVzZSB0aGVcclxuICAgKiBzdGF0aWMgTE9BRCBNZXRob2QuIEN1cnJlbnRseSBvbmx5IHdvcmtzIHdpdGggdHJpYW5ndWxhdGVkIE1lc2hlc1xyXG4gICAqIChhY3RpdmF0ZSAnR2VvbWVudHJ5IOKGkiBUcmlhbmd1bGF0ZSBGYWNlcycgaW4gQmxlbmRlcnMgb2JqIGV4cG9ydGVyKVxyXG4gICAqIEB0b2RvIFVWcywgTG9hZCBNYXRlcmlhbHMsIFN1cHBvcnQgUXVhZHNcclxuICAgKiBAYXV0aG9ycyBTaW1vbiBTdG9ybC1TY2h1bGtlIDIwMjEgfCBMdWlzIEtlY2ssIEhGVSwgMjAyMSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxLTIwMjIgKi9cclxuXHJcbiAgaW50ZXJmYWNlIEZhY2VJbmZvIHtcclxuICAgIGlQb3NpdGlvbjogbnVtYmVyO1xyXG4gICAgaVVWOiBudW1iZXI7XHJcbiAgICBpTm9ybWFsOiBudW1iZXI7XHJcbiAgfVxyXG5cclxuICBleHBvcnQgY2xhc3MgTWVzaE9iaiBleHRlbmRzIE1lc2gge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IE1lc2gucmVnaXN0ZXJTdWJjbGFzcyhNZXNoT2JqKTtcclxuICAgIHB1YmxpYyB1cmw6IFJlcXVlc3RJbmZvO1xyXG5cclxuICAgIC8vIHByb3RlY3RlZCB2ZXJ0czogbnVtYmVyW10gPSBbXTtcclxuICAgIC8vIHByb3RlY3RlZCB1dnM6IG51bWJlcltdID0gW107XHJcbiAgICAvLyBwcm90ZWN0ZWQgaW5kczogbnVtYmVyW10gPSBbXTtcclxuICAgIC8vIHByb3RlY3RlZCBmYWNlbm9ybWFsczogbnVtYmVyW10gPSBbXTtcclxuICAgIC8vIHByb3RlY3RlZCBmYWNlY3Jvc3Nwcm9kdWN0czogbnVtYmVyW10gPSBbXTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX25hbWU/OiBzdHJpbmcsIF91cmw/OiBSZXF1ZXN0SW5mbykge1xyXG4gICAgICBzdXBlcihfbmFtZSk7IHtcclxuICAgICAgICBpZiAoX3VybCkge1xyXG4gICAgICAgICAgdGhpcy5sb2FkKF91cmwpO1xyXG4gICAgICAgICAgaWYgKCFfbmFtZSlcclxuICAgICAgICAgICAgX25hbWUgPSBfdXJsLnRvU3RyaW5nKCkuc3BsaXQoXCIvXCIpLnBvcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIV9uYW1lKVxyXG4gICAgICAgICAgX25hbWUgPSBcIk1lc2hPYmpcIjtcclxuXHJcbiAgICAgICAgdGhpcy5uYW1lID0gX25hbWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgICAgKiBBc3luY2hyb25vdXNseSBsb2FkcyB0aGUgaW1hZ2UgZnJvbSB0aGUgZ2l2ZW4gdXJsXHJcbiAgICAgICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgbG9hZChfdXJsOiBSZXF1ZXN0SW5mbyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICB0aGlzLnVybCA9IF91cmw7XHJcbiAgICAgIGxldCB1cmw6IHN0cmluZyA9IG5ldyBVUkwodGhpcy51cmwudG9TdHJpbmcoKSwgUHJvamVjdC5iYXNlVVJMKS50b1N0cmluZygpO1xyXG4gICAgICBsZXQgZGF0YTogc3RyaW5nID0gYXdhaXQgKGF3YWl0IGZldGNoKHVybCkpLnRleHQoKTtcclxuICAgICAgdGhpcy5wYXJzZU9iaihkYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogU3BsaXRzIHVwIHRoZSBvYmogc3RyaW5nIGludG8gc2VwYXJhdGUgYXJyYXlzIGZvciBlYWNoIGRhdGF0eXBlICovXHJcbiAgICBwdWJsaWMgcGFyc2VPYmooZGF0YTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgICAgY29uc3QgbGluZXM6IHN0cmluZ1tdID0gZGF0YS5zcGxpdChcIlxcblwiKTtcclxuXHJcbiAgICAgIGxldCBwb3NpdGlvbnM6IFZlY3RvcjNbXSA9IFtdO1xyXG4gICAgICBsZXQgdXZzOiBWZWN0b3IyW10gPSBbXTtcclxuICAgICAgbGV0IGZhY2VJbmZvOiBGYWNlSW5mb1tdID0gW107XHJcblxyXG4gICAgICBmb3IgKGxldCBsaW5lIG9mIGxpbmVzKSB7XHJcbiAgICAgICAgbGluZSA9IGxpbmUudHJpbSgpO1xyXG5cclxuICAgICAgICBpZiAoIWxpbmUgfHwgbGluZS5zdGFydHNXaXRoKFwiI1wiKSlcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICBjb25zdCBwYXJ0czogc3RyaW5nW10gPSBsaW5lLnNwbGl0KFwiIFwiKTtcclxuICAgICAgICBwYXJ0cy5zaGlmdCgpO1xyXG5cclxuICAgICAgICAvL1ZlcnRleCAtIGV4YW1wbGU6IHYgMC43MCAtMC40NSAtMC41MlxyXG4gICAgICAgIGlmICghbGluZSB8fCBsaW5lLnN0YXJ0c1dpdGgoXCJ2IFwiKSlcclxuICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKG5ldyBWZWN0b3IzKC4uLnBhcnRzLm1hcCh4ID0+ICt4KSkpO1xyXG5cclxuICAgICAgICAvL1RleGNvb3JkIC0gZXhhbXBsZTogdnQgMC41NDU0NTQgMC40NzIzODJcclxuICAgICAgICBlbHNlIGlmICghbGluZSB8fCBsaW5lLnN0YXJ0c1dpdGgoXCJ2dCBcIikpIHV2cy5wdXNoKG5ldyBWZWN0b3IyKC4uLnBhcnRzLm1hcCh4ID0+ICt4KSkpO1xyXG5cclxuICAgICAgICAvKkZhY2UgSW5kaWNlcyAtIGV4YW1wbGU6IGYgMS8xLzEgMi8yLzEgMy8zLzEgLS0+XHJcbiAgICAgICAgdmVydGV4MS90ZXhjb29yZDEvbm9ybWFsMSB2ZXJ0ZXgyL3RleGNvb3JkMi9ub3JtYWwyIHZlcnRleDMvdGV4Y29vcmQzL25vcm1hbDMqL1xyXG4gICAgICAgIGVsc2UgaWYgKCFsaW5lIHx8IGxpbmUuc3RhcnRzV2l0aChcImYgXCIpKVxyXG4gICAgICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IDM7IGkrKykge1xyXG4gICAgICAgICAgICBmYWNlSW5mby5wdXNoKHtcclxuICAgICAgICAgICAgICBpUG9zaXRpb246ICtwYXJ0c1tpXS5zcGxpdChcIi9cIilbMF0gLSAxLFxyXG4gICAgICAgICAgICAgIGlVVjogK3BhcnRzW2ldLnNwbGl0KFwiL1wiKVsxXSAtIDEsXHJcbiAgICAgICAgICAgICAgaU5vcm1hbDogK3BhcnRzW2ldLnNwbGl0KFwiL1wiKVsyXSAtIDFcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuY2xvdWQgPSBuZXcgVmVydGljZXMoLi4ucG9zaXRpb25zLm1hcCgoX3A6IFZlY3RvcjMpID0+IG5ldyBWZXJ0ZXgoX3ApKSk7XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBmYWNlSW5mby5sZW5ndGg7IGkgKz0gMykge1xyXG4gICAgICAgIGxldCBpbmRpY2VzOiBudW1iZXJbXSA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IHY6IG51bWJlciA9IDA7IHYgPCAzOyB2KyspIHtcclxuICAgICAgICAgIGxldCBpbmZvOiBGYWNlSW5mbyA9IGZhY2VJbmZvW2kgKyB2XTtcclxuICAgICAgICAgIGxldCBpbmRleDogbnVtYmVyID0gaW5mby5pUG9zaXRpb247XHJcbiAgICAgICAgICBpZiAodGhpcy5jbG91ZFtpbmRleF0udXYpIHtcclxuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmNsb3VkLmxlbmd0aDtcclxuICAgICAgICAgICAgdGhpcy5jbG91ZC5wdXNoKG5ldyBWZXJ0ZXgoaW5mby5pUG9zaXRpb24pKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRoaXMuY2xvdWRbaW5kZXhdLnV2ID0gdXZzW2luZm8uaVVWXTtcclxuICAgICAgICAgIGluZGljZXMucHVzaChpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZmFjZXMucHVzaChuZXcgRmFjZSh0aGlzLmNsb3VkLCBpbmRpY2VzWzBdLCBpbmRpY2VzWzFdLCBpbmRpY2VzWzJdKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24udXJsID0gdGhpcy51cmw7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICB0aGlzLmxvYWQoX3NlcmlhbGl6YXRpb24udXJsKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBzdXBlci5tdXRhdGUoX211dGF0b3IpO1xyXG4gICAgICB0aGlzLmxvYWQoX211dGF0b3IudXJsKTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlIGEgc2ltcGxlIHB5cmFtaWQgd2l0aCBlZGdlcyBhdCB0aGUgYmFzZSBvZiBsZW5ndGggMSBhbmQgYSBoZWlnaHQgb2YgMS4gVGhlIHNpZGVzIGNvbnNpc3Rpbmcgb2Ygb25lLCB0aGUgYmFzZSBvZiB0d28gdHJpZ29uc1xyXG4gICAqIGBgYHBsYWludGV4dFxyXG4gICAqICAgICAgICAgICAgICAgNFxyXG4gICAqICAgICAgICAgICAgICAvXFxgLlxyXG4gICAqICAgICAgICAgICAgMy9fX1xcX1xcIDJcclxuICAgKiAgICAgICAgICAgMC9fX19fXFwvMVxyXG4gICAqIGBgYFxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE1lc2hQeXJhbWlkIGV4dGVuZHMgTWVzaCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gTWVzaC5yZWdpc3RlclN1YmNsYXNzKE1lc2hQeXJhbWlkKTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX25hbWU6IHN0cmluZyA9IFwiTWVzaFB5cmFtaWRcIikge1xyXG4gICAgICBzdXBlcihfbmFtZSk7XHJcbiAgICAgIC8vIHRoaXMuY3JlYXRlKCk7XHJcblxyXG4gICAgICB0aGlzLmNsb3VkID0gbmV3IFZlcnRpY2VzKFxyXG4gICAgICAgIC8vIGdyb3VuZCB2ZXJ0aWNlc1xyXG4gICAgICAgIG5ldyBWZXJ0ZXgobmV3IFZlY3RvcjMoLTAuNSwgMC4wLCAwLjUpLCBuZXcgVmVjdG9yMigwLCAxKSksXHJcbiAgICAgICAgbmV3IFZlcnRleChuZXcgVmVjdG9yMygwLjUsIDAuMCwgMC41KSwgbmV3IFZlY3RvcjIoMSwgMSkpLFxyXG4gICAgICAgIG5ldyBWZXJ0ZXgobmV3IFZlY3RvcjMoMC41LCAwLjAsIC0wLjUpLCBuZXcgVmVjdG9yMigxLCAwKSksXHJcbiAgICAgICAgbmV3IFZlcnRleChuZXcgVmVjdG9yMygtMC41LCAwLjAsIC0wLjUpLCBuZXcgVmVjdG9yMigwLCAwKSksXHJcbiAgICAgICAgLy8gdGlwICh2ZXJ0ZXggIzQpXHJcbiAgICAgICAgbmV3IFZlcnRleChuZXcgVmVjdG9yMygwLjAsIDEuMCwgMC4wKSwgbmV3IFZlY3RvcjIoMC41LCAwLjUpKSxcclxuICAgICAgICAvLyBmbG9vciBhZ2FpbiBmb3IgZG93bnNpZGUgdGV4dHVyZVxyXG4gICAgICAgIG5ldyBWZXJ0ZXgoMCwgbmV3IFZlY3RvcjIoMCwgMCkpLFxyXG4gICAgICAgIG5ldyBWZXJ0ZXgoMSwgbmV3IFZlY3RvcjIoMSwgMCkpLFxyXG4gICAgICAgIG5ldyBWZXJ0ZXgoMiwgbmV3IFZlY3RvcjIoMSwgMSkpLFxyXG4gICAgICAgIG5ldyBWZXJ0ZXgoMywgbmV3IFZlY3RvcjIoMCwgMSkpXHJcbiAgICAgICk7XHJcbiAgICAgIHRoaXMuZmFjZXMgPSBbXHJcbiAgICAgICAgbmV3IEZhY2UodGhpcy5jbG91ZCwgNCwgMCwgMSksXHJcbiAgICAgICAgbmV3IEZhY2UodGhpcy5jbG91ZCwgNCwgMSwgMiksXHJcbiAgICAgICAgbmV3IEZhY2UodGhpcy5jbG91ZCwgNCwgMiwgMyksXHJcbiAgICAgICAgbmV3IEZhY2UodGhpcy5jbG91ZCwgNCwgMywgMCksXHJcbiAgICAgICAgbmV3IEZhY2UodGhpcy5jbG91ZCwgNSArIDAsIDUgKyAyLCA1ICsgMSksXHJcbiAgICAgICAgbmV3IEZhY2UodGhpcy5jbG91ZCwgNSArIDAsIDUgKyAzLCA1ICsgMilcclxuICAgICAgXTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBHZW5lcmF0ZSBhIHNpbXBsZSBxdWFkIHdpdGggZWRnZXMgb2YgbGVuZ3RoIDEsIHRoZSBmYWNlIGNvbnNpc3Rpbmcgb2YgdHdvIHRyaWdvbnNcclxuICAgKiBgYGBwbGFpbnRleHRcclxuICAgKiAgICAgICAgMCBfXyAzXHJcbiAgICogICAgICAgICB8X1xcfFxyXG4gICAqICAgICAgICAxICAgIDIgICAgICAgICAgICAgXHJcbiAgICogYGBgIFxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5LTIwMjJcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgTWVzaFF1YWQgZXh0ZW5kcyBNZXNoUG9seWdvbiB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gTWVzaC5yZWdpc3RlclN1YmNsYXNzKE1lc2hRdWFkKTtcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgc2hhcGU6IFZlY3RvcjJbXSA9IFtcclxuICAgICAgbmV3IFZlY3RvcjIoLTAuNSwgMC41KSwgbmV3IFZlY3RvcjIoLTAuNSwgLTAuNSksIG5ldyBWZWN0b3IyKDAuNSwgLTAuNSksIG5ldyBWZWN0b3IyKDAuNSwgMC41KVxyXG4gICAgXTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX25hbWU6IHN0cmluZyA9IFwiTWVzaFF1YWRcIikge1xyXG4gICAgICBzdXBlcihfbmFtZSwgTWVzaFF1YWQuc2hhcGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIC8vIGZsYXQgZXF1YWxzIHNtb290aFxyXG4gICAgLy8gcHVibGljIGdldCB2ZXJ0aWNlc0ZsYXQoKTogRmxvYXQzMkFycmF5IHsgcmV0dXJuIHRoaXMudmVydGljZXM7IH1cclxuICAgIC8vIHB1YmxpYyBnZXQgaW5kaWNlc0ZsYXQoKTogVWludDE2QXJyYXkgeyByZXR1cm4gdGhpcy5pbmRpY2VzOyB9XHJcbiAgICAvLyBwdWJsaWMgZ2V0IG5vcm1hbHNGbGF0KCk6IEZsb2F0MzJBcnJheSB7IHJldHVybiB0aGlzLm5vcm1hbHNWZXJ0ZXg7IH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNnZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gdGhpcy5nZXRNdXRhdG9yKCk7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICB0aGlzLmNyZWF0ZShNZXNoUXVhZC5zaGFwZSwgdHJ1ZSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgc3VwZXIucmVkdWNlTXV0YXRvcihfbXV0YXRvcik7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5zaGFwZTtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLmZpdFRleHR1cmU7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIC8qKiBcclxuICAgKiBUaGlzIGZ1bmN0aW9uIHR5cGUgdGFrZXMgeCBhbmQgeiBhcyBQYXJhbWV0ZXJzIGFuZCByZXR1cm5zIGEgbnVtYmVyIGJldHdlZW4gLTEgYW5kIDEgdG8gYmUgdXNlZCBhcyBhIGhlaWdodG1hcC4gXHJcbiAgICogeCAqIHogKiAyIHJlcHJlc2VudCB0aGUgYW1vdXQgb2YgZmFjZXMgd2hpY2ggYXJlIGNyZWF0ZWQuIEFzIGEgcmVzdWx0IHlvdSBnZXQgMSB2ZXJ0ZXggbW9yZSBpbiBlYWNoIGRpcmVjdGlvbiAoeCBhbmQgeiBheGlzKVxyXG4gICAqIFRoZSB5LWNvbXBvbmVudCBvZiB0aGUgcmVzdWx0aW5nIG1lc2ggbWF5IGJlIG1vdmVkIHRvIHZhbHVlcyBiZXR3ZWVuIDAgYW5kIGEgbWF4aW11bSBoZWlnaHQuXHJcbiAgICogQGF1dGhvcnMgU2ltb24gU3RvcmwtU2NodWxrZSwgSEZVLCAyMDIwIHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjEtMjAyMlxyXG4gICAqL1xyXG4gIGV4cG9ydCB0eXBlIEhlaWdodE1hcEZ1bmN0aW9uID0gKHg6IG51bWJlciwgejogbnVtYmVyKSA9PiBudW1iZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIEluZm9ybWF0aW9uIGFib3V0IHRoZSB2ZXJ0aWNhbCBwcm9qZWN0aW9uIG9mIGEgZ2l2ZW4gcG9zaXRpb24gb250byB0aGUgdGVycmFpblxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBUZXJyYWluSW5mbyB7XHJcbiAgICAvKiogdGhlIHBvc2l0aW9uIG9mIHRoZSBwb2ludCB2ZXJ0aWNhbGx5IHByb2plY3RlZCBvbiB0aGUgdGVycmFpbiBpbiB3b3JsZCBjb29yZGluYXRlcyAqL1xyXG4gICAgcG9zaXRpb246IFZlY3RvcjM7XHJcbiAgICAvKiogdGhlIG5vcm1hbCBvZiB0aGUgZmFjZSBvZiB0aGUgdGVycmFpbiB1bmRlciB0aGUgcG9pbnQgaW4gd29ybGQgY29vcmRpbmF0ZXMgKi9cclxuICAgIG5vcm1hbDogVmVjdG9yMztcclxuICAgIC8qKiB2ZXJ0aWNhbCBkaXN0YW5jZSBvZiB0aGUgcG9pbnQgdG8gdGhlIHRlcnJhaW4sIG5lZ2F0aXZlIGlmIGJlbG93ICovXHJcbiAgICBkaXN0YW5jZTogbnVtYmVyO1xyXG4gICAgLyoqIHRoZSBwb3NpdGlvbiBpbiBmYWNlIGNvb3JkaW5hdGVzICovXHJcbiAgICBwb3NpdGlvbkZhY2U6IFZlY3RvcjM7XHJcbiAgICAvKiogdGhlIGluZGV4IG9mIHRoZSBmYWNlIHRoZSBwb3NpdGlvbiBpcyBpbnNpZGUgKi9cclxuICAgIGluZGV4OiBudW1iZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBIHRlcnJhaW4gc3ByZWFkcyBvdXQgaW4gdGhlIHgtei1wbGFuZSwgeSBpcyB0aGUgaGVpZ2h0IGRlcml2ZWQgZnJvbSB0aGUgaGVpZ2h0bWFwIGZ1bmN0aW9uLiBcclxuICAgKiBUaGUgdGVycmFpbiBpcyBhbHdheXMgMSBpbiBzaXplIGluIGFsbCBkaW1lbnNpb25zLCBmaXR0aW5nIGludG8gdGhlIHVuaXQtY3ViZS4gXHJcbiAgICogUmVzb2x1dGlvbiBkZXRlcm1pbmVzIHRoZSBudW1iZXIgb2YgcXVhZHMgaW4geCBhbmQgeiBkaW1lbnNpb24sIHNjYWxlIHRoZSBmYWN0b3IgYXBwbGllZCB0byB0aGUgeCx6LWNvb3JkaW5hdGVzIHBhc3NlZCB0byB0aGUgaGVpZ2h0bWFwIGZ1bmN0aW9uLlxyXG4gICAqIFN0YW5kYXJkIGZ1bmN0aW9uIGlzIHRoZSBzaW1wbGV4IG5vaXNlIGltcGxlbWVudGVkIHdpdGggRlVER0UsIGJ1dCBhbm90aGVyIGZ1bmN0aW9uIGNhbiBiZSBnaXZlbi5cclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMS0yMDIyIHwgU2ltb24gU3RvcmwtU2NodWxrZSwgSEZVLCAyMDIwIHwgTW9yaXR6IEJlYXVncmFuZCwgSEZVLCAyMDIxXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE1lc2hUZXJyYWluIGV4dGVuZHMgTWVzaCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gTWVzaC5yZWdpc3RlclN1YmNsYXNzKE1lc2hUZXJyYWluKTtcclxuICAgIHByb3RlY3RlZCByZXNvbHV0aW9uOiBWZWN0b3IyO1xyXG4gICAgcHJvdGVjdGVkIHNjYWxlOiBWZWN0b3IyO1xyXG4gICAgcHJvdGVjdGVkIHNlZWQ6IG51bWJlcjtcclxuICAgIHByb3RlY3RlZCBoZWlnaHRNYXBGdW5jdGlvbjogSGVpZ2h0TWFwRnVuY3Rpb24gPSBudWxsO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nID0gXCJNZXNoVGVycmFpblwiLCBfcmVzb2x1dGlvbjogVmVjdG9yMiA9IFZlY3RvcjIuT05FKDIpLCBfc2NhbGVJbnB1dDogVmVjdG9yMiA9IFZlY3RvcjIuT05FKCksIF9mdW5jdGlvbk9yU2VlZDogSGVpZ2h0TWFwRnVuY3Rpb24gfCBudW1iZXIgPSAwKSB7XHJcbiAgICAgIHN1cGVyKF9uYW1lKTtcclxuICAgICAgdGhpcy5jcmVhdGUoX3Jlc29sdXRpb24sIF9zY2FsZUlucHV0LCBfZnVuY3Rpb25PclNlZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBjcmVhdGUoX3Jlc29sdXRpb246IFZlY3RvcjIgPSBWZWN0b3IyLk9ORSgyKSwgX3NjYWxlSW5wdXQ6IFZlY3RvcjIgPSBWZWN0b3IyLk9ORSgpLCBfZnVuY3Rpb25PclNlZWQ6IEhlaWdodE1hcEZ1bmN0aW9uIHwgbnVtYmVyID0gMCk6IHZvaWQge1xyXG4gICAgICB0aGlzLmNsZWFyKCk7XHJcbiAgICAgIHRoaXMuc2VlZCA9IHVuZGVmaW5lZDtcclxuICAgICAgdGhpcy5yZXNvbHV0aW9uID0gbmV3IFZlY3RvcjIoTWF0aC5yb3VuZChfcmVzb2x1dGlvbi54KSwgTWF0aC5yb3VuZChfcmVzb2x1dGlvbi55KSk7XHJcbiAgICAgIHRoaXMuc2NhbGUgPSBfc2NhbGVJbnB1dC5jbG9uZTtcclxuXHJcbiAgICAgIGlmIChfZnVuY3Rpb25PclNlZWQgaW5zdGFuY2VvZiBGdW5jdGlvbilcclxuICAgICAgICB0aGlzLmhlaWdodE1hcEZ1bmN0aW9uID0gX2Z1bmN0aW9uT3JTZWVkO1xyXG4gICAgICBlbHNlIGlmICh0eXBlb2YgKF9mdW5jdGlvbk9yU2VlZCkgPT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgIHRoaXMuc2VlZCA9IF9mdW5jdGlvbk9yU2VlZDtcclxuICAgICAgICBsZXQgcHJuZzogUmFuZG9tID0gbmV3IFJhbmRvbSh0aGlzLnNlZWQpO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0TWFwRnVuY3Rpb24gPSBuZXcgTm9pc2UyKCgpID0+IHBybmcuZ2V0Tm9ybSgpKS5zYW1wbGU7IC8vIFRPRE8gY2FsbCBQUk5HXHJcbiAgICAgIH1cclxuICAgICAgZWxzZVxyXG4gICAgICAgIHRoaXMuaGVpZ2h0TWFwRnVuY3Rpb24gPSBuZXcgTm9pc2UyKCkuc2FtcGxlO1xyXG5cclxuICAgICAgdGhpcy5jbG91ZCA9IG5ldyBWZXJ0aWNlcygpO1xyXG4gICAgICAvL0l0ZXJhdGUgb3ZlciBlYWNoIGNlbGwgdG8gZ2VuZXJhdGUgZ3JpZCBvZiB2ZXJ0aWNlc1xyXG4gICAgICBmb3IgKGxldCB6OiBudW1iZXIgPSAwOyB6IDw9IHRoaXMucmVzb2x1dGlvbi55OyB6KyspIHtcclxuICAgICAgICBmb3IgKGxldCB4OiBudW1iZXIgPSAwOyB4IDw9IHRoaXMucmVzb2x1dGlvbi54OyB4KyspIHtcclxuICAgICAgICAgIGxldCB4Tm9ybTogbnVtYmVyID0geCAvIHRoaXMucmVzb2x1dGlvbi54O1xyXG4gICAgICAgICAgbGV0IHpOb3JtOiBudW1iZXIgPSB6IC8gdGhpcy5yZXNvbHV0aW9uLnk7XHJcbiAgICAgICAgICB0aGlzLmNsb3VkLnB1c2gobmV3IFZlcnRleChcclxuICAgICAgICAgICAgbmV3IFZlY3RvcjMoeE5vcm0gLSAwLjUsIHRoaXMuaGVpZ2h0TWFwRnVuY3Rpb24oeE5vcm0gKiB0aGlzLnNjYWxlLngsIHpOb3JtICogdGhpcy5zY2FsZS55KSwgek5vcm0gLSAwLjUpLFxyXG4gICAgICAgICAgICBuZXcgVmVjdG9yMih4Tm9ybSwgek5vcm0pXHJcbiAgICAgICAgICApKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBxdWFkczogUXVhZFtdID0gW107XHJcbiAgICAgIGxldCBzcGxpdDogUVVBRFNQTElUID0gUVVBRFNQTElULkFUXzA7XHJcbiAgICAgIGZvciAobGV0IHo6IG51bWJlciA9IDA7IHogPCB0aGlzLnJlc29sdXRpb24ueTsgeisrKSB7XHJcbiAgICAgICAgZm9yIChsZXQgeDogbnVtYmVyID0gMDsgeCA8IHRoaXMucmVzb2x1dGlvbi54OyB4KyspIHtcclxuICAgICAgICAgIHF1YWRzLnB1c2gobmV3IFF1YWQoXHJcbiAgICAgICAgICAgIHRoaXMuY2xvdWQsXHJcbiAgICAgICAgICAgICh4ICsgMCkgKyAoeiArIDApICogKHRoaXMucmVzb2x1dGlvbi54ICsgMSksXHJcbiAgICAgICAgICAgICh4ICsgMCkgKyAoeiArIDEpICogKHRoaXMucmVzb2x1dGlvbi54ICsgMSksXHJcbiAgICAgICAgICAgICh4ICsgMSkgKyAoeiArIDEpICogKHRoaXMucmVzb2x1dGlvbi54ICsgMSksXHJcbiAgICAgICAgICAgICh4ICsgMSkgKyAoeiArIDApICogKHRoaXMucmVzb2x1dGlvbi54ICsgMSksXHJcbiAgICAgICAgICAgIHNwbGl0XHJcbiAgICAgICAgICApKTtcclxuICAgICAgICAgIHNwbGl0ID0gKHNwbGl0ID09IFFVQURTUExJVC5BVF8wKSA/IFFVQURTUExJVC5BVF8xIDogUVVBRFNQTElULkFUXzA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnJlc29sdXRpb24ueCAlIDIgPT0gMCkgLy8gcmV2ZXJzZSBsYXN0IHNwbGl0IGNoYW5nZSBpZiB4LXJlc29sdXRpb24gaXMgZXZlblxyXG4gICAgICAgICAgc3BsaXQgPSAoc3BsaXQgPT0gUVVBRFNQTElULkFUXzApID8gUVVBRFNQTElULkFUXzEgOiBRVUFEU1BMSVQuQVRfMDtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmZhY2VzID0gcXVhZHMuZmxhdE1hcCgocXVhZDogUXVhZCkgPT4gcXVhZC5mYWNlcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSB2ZXJ0aWNhbCBwcm9qZWN0aW9uIG9mIHRoZSBnaXZlbiBwb3NpdGlvbiBvbnRvIHRoZSB0ZXJyYWluLlxyXG4gICAgICogUGFzcyB0aGUgb3ZlcmFsbCB3b3JsZCB0cmFuc2Zvcm1hdGlvbiBvZiB0aGUgdGVycmFpbiBpZiB0aGUgcG9zaXRpb24gaXMgZ2l2ZW4gaW4gd29ybGQgY29vcmRpbmF0ZXMuXHJcbiAgICAgKiBJZiBhdCBoYW5kLCBwYXNzIHRoZSBpbnZlcnNlIHRvbyB0byBhdm9pZCB1bm5lY2Vzc2FyeSBjYWxjdWxhdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFRlcnJhaW5JbmZvKF9wb3NpdGlvbjogVmVjdG9yMywgX210eFdvcmxkOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKSwgX210eEludmVyc2U/OiBNYXRyaXg0eDQpOiBUZXJyYWluSW5mbyB7XHJcbiAgICAgIGlmICghX210eEludmVyc2UpXHJcbiAgICAgICAgX210eEludmVyc2UgPSBNYXRyaXg0eDQuSU5WRVJTSU9OKF9tdHhXb3JsZCk7XHJcblxyXG4gICAgICBsZXQgdGVycmFpbkluZm86IFRlcnJhaW5JbmZvID0gbmV3IFRlcnJhaW5JbmZvO1xyXG5cclxuICAgICAgbGV0IHBvc0xvY2FsOiBWZWN0b3IzID0gVmVjdG9yMy5UUkFOU0ZPUk1BVElPTihfcG9zaXRpb24sIF9tdHhJbnZlcnNlLCB0cnVlKTtcclxuXHJcblxyXG4gICAgICBsZXQgejogbnVtYmVyID0gTWF0aC5mbG9vcigocG9zTG9jYWwueiArIDAuNSkgKiB0aGlzLnJlc29sdXRpb24ueSk7XHJcbiAgICAgIGxldCB4OiBudW1iZXIgPSBNYXRoLmZsb29yKChwb3NMb2NhbC54ICsgMC41KSAqIHRoaXMucmVzb2x1dGlvbi54KTtcclxuICAgICAgaWYgKHogPCAwIHx8IHogPiB0aGlzLnJlc29sdXRpb24ueSAtIDEgfHwgeCA8IDAgfHwgeCA+IHRoaXMucmVzb2x1dGlvbi54IC0gMSlcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgIGxldCBpbmRleDogbnVtYmVyID0gKHogKiB0aGlzLnJlc29sdXRpb24ueCArIHgpICogMjtcclxuICAgICAgbGV0IGZhY2U6IEZhY2UgPSB0aGlzLmZhY2VzW2luZGV4XTtcclxuXHJcbiAgICAgIGxldCByYXk6IFJheSA9IG5ldyBSYXkoVmVjdG9yMy5ZKCksIHBvc0xvY2FsKTtcclxuICAgICAgbGV0IHBvaW50OiBWZWN0b3IzID0gcmF5LmludGVyc2VjdEZhY2VQbGFuZShmYWNlKTtcclxuICAgICAgaWYgKCFmYWNlLmlzSW5zaWRlKHBvaW50KSkge1xyXG4gICAgICAgIGluZGV4Kys7XHJcbiAgICAgICAgZmFjZSA9IHRoaXMuZmFjZXNbaW5kZXhdO1xyXG4gICAgICAgIHBvaW50ID0gcmF5LmludGVyc2VjdEZhY2VQbGFuZShmYWNlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGVycmFpbkluZm8uaW5kZXggPSBpbmRleDtcclxuICAgICAgdGVycmFpbkluZm8ucG9zaXRpb25GYWNlID0gcG9pbnQ7XHJcbiAgICAgIHRlcnJhaW5JbmZvLnBvc2l0aW9uID0gVmVjdG9yMy5UUkFOU0ZPUk1BVElPTihwb2ludCwgX210eFdvcmxkLCB0cnVlKTtcclxuICAgICAgdGVycmFpbkluZm8ubm9ybWFsID0gVmVjdG9yMy5UUkFOU0ZPUk1BVElPTihmYWNlLm5vcm1hbCwgTWF0cml4NHg0LlRSQU5TUE9TRShfbXR4SW52ZXJzZSksIGZhbHNlKTtcclxuICAgICAgdGVycmFpbkluZm8uZGlzdGFuY2UgPSBfcG9zaXRpb24ueSAtIHRlcnJhaW5JbmZvLnBvc2l0aW9uLnk7XHJcblxyXG4gICAgICByZXR1cm4gdGVycmFpbkluZm87XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnNlZWQgPSB0aGlzLnNlZWQ7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24uc2NhbGUgPSB0aGlzLnNjYWxlLnNlcmlhbGl6ZSgpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb24uc2VyaWFsaXplKCk7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICBhd2FpdCB0aGlzLnJlc29sdXRpb24uZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24ucmVzb2x1dGlvbik7XHJcbiAgICAgIGF3YWl0IHRoaXMuc2NhbGUuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24uc2NhbGUpO1xyXG4gICAgICB0aGlzLnNlZWQgPSBfc2VyaWFsaXphdGlvbi5zZWVkO1xyXG4gICAgICB0aGlzLmNyZWF0ZSh0aGlzLnJlc29sdXRpb24sIHRoaXMuc2NhbGUsIHRoaXMuc2VlZCk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgc3VwZXIubXV0YXRlKF9tdXRhdG9yKTtcclxuICAgICAgdGhpcy5jcmVhdGUoXHJcbiAgICAgICAgbmV3IFZlY3RvcjIoX211dGF0b3IucmVzb2x1dGlvbi54LCBfbXV0YXRvci5yZXNvbHV0aW9uLnkpLFxyXG4gICAgICAgIG5ldyBWZWN0b3IyKF9tdXRhdG9yLnNjYWxlLngsIF9tdXRhdG9yLnNjYWxlLnkpLFxyXG4gICAgICAgIF9tdXRhdG9yLnNlZWRcclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gIH1cclxufSIsIi8vLzxyZWZlcmVuY2UgcGF0aD1cIk1lc2hUZXJyYWluLnRzXCIvPlxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBHZW5lcmF0ZXMgYSBwbGFuYXIgR3JpZCBhbmQgYXBwbGllcyBhIEhlaWdodG1hcC1GdW5jdGlvbiB0byBpdC5cclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMSB8IE1vcml0eiBCZWF1Z3JhbmQsIEhGVSwgMjAyMFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBNZXNoUmVsaWVmIGV4dGVuZHMgTWVzaFRlcnJhaW4ge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IE1lc2gucmVnaXN0ZXJTdWJjbGFzcyhNZXNoUmVsaWVmKTtcclxuICAgIHByaXZhdGUgdGV4dHVyZTogVGV4dHVyZUltYWdlID0gbnVsbDtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX25hbWU6IHN0cmluZyA9IFwiTWVzaFJlbGllZlwiLCBfdGV4dHVyZTogVGV4dHVyZUltYWdlID0gbnVsbCkge1xyXG4gICAgICBzdXBlcihfbmFtZSwgVmVjdG9yMi5PTkUoMiksIHVuZGVmaW5lZCwgKF94OiBudW1iZXIsIF96OiBudW1iZXIpID0+IDApO1xyXG4gICAgICB0aGlzLnNldFRleHR1cmUoX3RleHR1cmUpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGNyZWF0ZUhlaWdodE1hcEZ1bmN0aW9uKF90ZXh0dXJlOiBUZXh0dXJlSW1hZ2UpOiBIZWlnaHRNYXBGdW5jdGlvbiB7XHJcbiAgICAgIGxldCBhcnJheTogVWludDhDbGFtcGVkQXJyYXkgPSBNZXNoUmVsaWVmLnRleHR1cmVUb0NsYW1wZWRBcnJheShfdGV4dHVyZSk7XHJcbiAgICAgIGxldCBoZWlnaHRNYXBGdW5jdGlvbjogSGVpZ2h0TWFwRnVuY3Rpb24gPSAoX3g6IG51bWJlciwgX3o6IG51bWJlcikgPT4ge1xyXG4gICAgICAgIGxldCBwaXhlbDogbnVtYmVyID0gTWF0aC5yb3VuZChfeiAqIF90ZXh0dXJlLmltYWdlLndpZHRoICsgX3gpO1xyXG4gICAgICAgIHJldHVybiBhcnJheVtwaXhlbCAqIDRdIC8gMjU1O1xyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gaGVpZ2h0TWFwRnVuY3Rpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgdGV4dHVyZVRvQ2xhbXBlZEFycmF5KF90ZXh0dXJlOiBUZXh0dXJlSW1hZ2UpOiBVaW50OENsYW1wZWRBcnJheSB7XHJcbiAgICAgIGxldCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcclxuICAgICAgY2FudmFzLndpZHRoID0gX3RleHR1cmUuaW1hZ2Uud2lkdGg7XHJcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBfdGV4dHVyZS5pbWFnZS5oZWlnaHQ7XHJcblxyXG4gICAgICBsZXQgY3JjOiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgICBjcmMuaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgIGNyYy5kcmF3SW1hZ2UoX3RleHR1cmUuaW1hZ2UsIDAsIDApO1xyXG5cclxuICAgICAgcmV0dXJuIGNyYy5nZXRJbWFnZURhdGEoMCwgMCwgX3RleHR1cmUuaW1hZ2Uud2lkdGgsIF90ZXh0dXJlLmltYWdlLmhlaWdodCkuZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0VGV4dHVyZShfdGV4dHVyZTogVGV4dHVyZUltYWdlID0gbnVsbCk6IHZvaWQge1xyXG4gICAgICBpZiAoIV90ZXh0dXJlKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgdGhpcy50ZXh0dXJlID0gX3RleHR1cmU7XHJcbiAgICAgIGxldCByZXNvbHV0aW9uOiBWZWN0b3IyID0gX3RleHR1cmUgPyBuZXcgVmVjdG9yMihfdGV4dHVyZS5pbWFnZS53aWR0aCAtIDEsIF90ZXh0dXJlLmltYWdlLmhlaWdodCAtIDEpIDogdW5kZWZpbmVkO1xyXG4gICAgICBzdXBlci5jcmVhdGUocmVzb2x1dGlvbiwgcmVzb2x1dGlvbiwgTWVzaFJlbGllZi5jcmVhdGVIZWlnaHRNYXBGdW5jdGlvbihfdGV4dHVyZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgZGVsZXRlIHNlcmlhbGl6YXRpb24uc2VlZDtcclxuICAgICAgZGVsZXRlIHNlcmlhbGl6YXRpb24uc2NhbGU7XHJcbiAgICAgIGRlbGV0ZSBzZXJpYWxpemF0aW9uLnJlc29sdXRpb247XHJcblxyXG4gICAgICBpZiAodGhpcy50ZXh0dXJlKVxyXG4gICAgICAgIHNlcmlhbGl6YXRpb24uaWRUZXh0dXJlID0gdGhpcy50ZXh0dXJlLmlkUmVzb3VyY2U7XHJcblxyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgaWYgKF9zZXJpYWxpemF0aW9uLmlkVGV4dHVyZSkge1xyXG4gICAgICAgIHRoaXMudGV4dHVyZSA9IDxUZXh0dXJlSW1hZ2U+YXdhaXQgUHJvamVjdC5nZXRSZXNvdXJjZShfc2VyaWFsaXphdGlvbi5pZFRleHR1cmUpO1xyXG4gICAgICAgIHRoaXMuc2V0VGV4dHVyZSh0aGlzLnRleHR1cmUpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgdGhpcy5zZXRUZXh0dXJlKF9tdXRhdG9yLnRleHR1cmUpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIHN1cGVyLnJlZHVjZU11dGF0b3IoX211dGF0b3IpO1xyXG4gICAgICBkZWxldGUgX211dGF0b3Iuc2VlZDtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLnNjYWxlO1xyXG4gICAgICBkZWxldGUgX211dGF0b3IucmVzb2x1dGlvbjtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vIHByb3RlY3RlZCBjcmVhdGVWZXJ0aWNlcygpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgLy8gICBsZXQgdmVydGljZXM6IFZlY3RvcjNbXSA9IFtdO1xyXG4gICAgLy8gICAvLyBsZXQgdmVydGljZXM6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoKHRoaXMucmVzb2x1dGlvbi54ICsgMSkgKiAodGhpcy5yZXNvbHV0aW9uLnkgKyAxKSAqIDMpO1xyXG4gICAgLy8gICAvL0l0ZXJhdGUgb3ZlciBlYWNoIGNlbGwgdG8gZ2VuZXJhdGUgZ3JpZCBvZiB2ZXJ0aWNlc1xyXG4gICAgLy8gICBsZXQgcm93OiBWZWN0b3IzW107XHJcbiAgICAvLyAgIGZvciAobGV0IHo6IG51bWJlciA9IDA7IHogPD0gdGhpcy5yZXNvbHV0aW9uLnk7IHorKykge1xyXG4gICAgLy8gICAgIHJvdyA9IFtdO1xyXG4gICAgLy8gICAgIGZvciAobGV0IHg6IG51bWJlciA9IDA7IHggPD0gdGhpcy5yZXNvbHV0aW9uLng7IHgrKykge1xyXG4gICAgLy8gICAgICAgbGV0IHhOb3JtOiBudW1iZXIgPSB4IC8gdGhpcy5yZXNvbHV0aW9uLng7XHJcbiAgICAvLyAgICAgICBsZXQgek5vcm06IG51bWJlciA9IHogLyB0aGlzLnJlc29sdXRpb24ueTtcclxuICAgIC8vICAgICAgIHJvdy5wdXNoKG5ldyBWZWN0b3IzKFxyXG4gICAgLy8gICAgICAgICB4Tm9ybSAtIDAuNSxcclxuICAgIC8vICAgICAgICAgdGhpcy5oZWlnaHRNYXBGdW5jdGlvbih4LCB6KSxcclxuICAgIC8vICAgICAgICAgek5vcm0gLSAwLjVcclxuICAgIC8vICAgICAgICkpO1xyXG4gICAgLy8gICAgIH1cclxuICAgIC8vICAgICB2ZXJ0aWNlcy5wdXNoKC4uLnJvdyk7XHJcbiAgICAvLyAgICAgaWYgKHogPiAwICYmIHogPD0gdGhpcy5yZXNvbHV0aW9uLnkgLSAxKSAvLyBkdXBsaWNhdGUgcm93IHRvIHNlcGFyYXRlIHZlcnRleC0gYW5kIGZhY2Utbm9ybWFsc1xyXG4gICAgLy8gICAgICAgdmVydGljZXMucHVzaCguLi5yb3cpO1xyXG4gICAgLy8gICB9XHJcbiAgICAvLyAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KHZlcnRpY2VzLm1hcCgoX3Y6IFZlY3RvcjMpID0+IFtfdi54LCBfdi55LCBfdi56XSkuZmxhdCgpKTtcclxuICAgIC8vIH1cclxuICB9XHJcbn0iLCIvLyAvPHJlZmVyZW5jZSBwYXRoPVwiTWVzaFBvbHlnb24udHNcIi8+XHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlcyBhIHJvdGF0aW9uIG9mIGEgcG9seWdvbiBhcm91bmQgdGhlIHktYXhpc1xyXG4gICAqIGBgYHBsYWludGV4dCAgICAgICBcclxuICAgKiAgICAgICAgICAgICAgICAgICAgIHlcclxuICAgKiAgICAgICAgICAgICAgICAgIF8gIOKGkSAwXzFcclxuICAgKiAgICAgICAgICAgICAgICAg4pSCICAg4pSC4oaSeCDilIIyICAgICAgICAgXHJcbiAgICogICAgICAgICAgICAgICAgICDilbIgIOKUgiAg4pWxMyAgICAgICAgIFxyXG4gICAqICAgICAgICAgICAgICAgICAg4pWxICDilIIgIOKVsiAgIFxyXG4gICAqICAgICAgICAgICAgICAgICDilbFfX1/ilIJfX1/ilbI0IFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgIDVcclxuICAgKiBgYGBcclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMS0yMDIyXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE1lc2hSb3RhdGlvbiBleHRlbmRzIE1lc2gge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IE1lc2gucmVnaXN0ZXJTdWJjbGFzcyhNZXNoUm90YXRpb24pO1xyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyB2ZXJ0aWNlc0RlZmF1bHQ6IFZlY3RvcjJbXSA9IFsgLy8gbGluZSBpcyB0aGUgbWluaW1hbCBzaGFwZVxyXG4gICAgICBuZXcgVmVjdG9yMigwLjUsIDAuNSksXHJcbiAgICAgIG5ldyBWZWN0b3IyKDAuNSwgLTAuNSlcclxuICAgIF07XHJcbiAgICBwcm90ZWN0ZWQgc2hhcGU6IE11dGFibGVBcnJheTxWZWN0b3IyPiA9IG5ldyBNdXRhYmxlQXJyYXk8VmVjdG9yMj4oKTtcclxuICAgIHByb3RlY3RlZCBsb25naXR1ZGVzOiBudW1iZXI7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9uYW1lOiBzdHJpbmcgPSBcIk1lc2hSb3RhdGlvblwiLCBfc2hhcGU6IFZlY3RvcjJbXSA9IE1lc2hSb3RhdGlvbi52ZXJ0aWNlc0RlZmF1bHQsIF9sb25naXR1ZGVzOiBudW1iZXIgPSAzKSB7XHJcbiAgICAgIHN1cGVyKF9uYW1lKTtcclxuICAgICAgdGhpcy5yb3RhdGUoX3NoYXBlLCBfbG9uZ2l0dWRlcyk7XHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiTXV0YXRvclwiLCB0aGlzLmdldE11dGF0b3IoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGdldCBtaW5WZXJ0aWNlcygpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gMjtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24uc2hhcGUgPSBTZXJpYWxpemVyLnNlcmlhbGl6ZUFycmF5KFZlY3RvcjIsIHRoaXMuc2hhcGUpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLmxvbmdpdHVkZXMgPSB0aGlzLmxvbmdpdHVkZXM7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgbGV0IHNoYXBlOiBWZWN0b3IyW10gPSA8VmVjdG9yMltdPmF3YWl0IFNlcmlhbGl6ZXIuZGVzZXJpYWxpemVBcnJheShfc2VyaWFsaXphdGlvbi5zaGFwZSk7XHJcbiAgICAgIHRoaXMubG9uZ2l0dWRlcyA9IF9zZXJpYWxpemF0aW9uLmxvbmdpdHVkZXM7XHJcbiAgICAgIHRoaXMucm90YXRlKHNoYXBlLCB0aGlzLmxvbmdpdHVkZXMpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIGF3YWl0IHN1cGVyLm11dGF0ZShfbXV0YXRvcik7XHJcbiAgICAgIHRoaXMucm90YXRlKHRoaXMuc2hhcGUsIHRoaXMubG9uZ2l0dWRlcyk7XHJcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuTVVUQVRFKSk7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICBwcm90ZWN0ZWQgcm90YXRlKF9zaGFwZTogVmVjdG9yMltdLCBfbG9uZ2l0dWRlczogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgICAgdGhpcy5zaGFwZSA9IDxNdXRhYmxlQXJyYXk8VmVjdG9yMj4+TXV0YWJsZUFycmF5LmZyb20oX3NoYXBlLm1hcChfdmVydGV4ID0+IF92ZXJ0ZXguY2xvbmUpKTtcclxuICAgICAgdGhpcy5sb25naXR1ZGVzID0gTWF0aC5yb3VuZChfbG9uZ2l0dWRlcyk7XHJcbiAgICAgIGxldCBhbmdsZTogbnVtYmVyID0gMzYwIC8gdGhpcy5sb25naXR1ZGVzO1xyXG4gICAgICBsZXQgbXR4Um90YXRlOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuUk9UQVRJT05fWShhbmdsZSk7XHJcbiAgICAgIC8vIGNvcHkgb3JpZ2luYWwgcG9seWdvbiBhcyBWZWN0b3IzIGFycmF5XHJcbiAgICAgIGxldCBwb2x5Z29uOiBWZWN0b3IzW10gPSBbXTtcclxuICAgICAgbGV0IGRpc3RhbmNlczogbnVtYmVyW10gPSBbMF07XHJcbiAgICAgIGxldCB0b3RhbDogbnVtYmVyID0gMDtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMuc2hhcGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBwb2x5Z29uLnB1c2godGhpcy5zaGFwZVtpXS50b1ZlY3RvcjMoKSk7XHJcbiAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICBsZXQgZGlzdGFuY2U6IG51bWJlciA9IFZlY3RvcjIuRElGRkVSRU5DRSh0aGlzLnNoYXBlW2ldLCB0aGlzLnNoYXBlW2kgLSAxXSkubWFnbml0dWRlO1xyXG4gICAgICAgICAgdG90YWwgKz0gZGlzdGFuY2U7XHJcbiAgICAgICAgICBkaXN0YW5jZXMucHVzaCh0b3RhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGRpc3RhbmNlcy5mb3JFYWNoKChlbnRyeSwgaW5kZXgpID0+IHsgZGlzdGFuY2VzW2luZGV4XSA9IGVudHJ5IC8gdG90YWw7IH0pO1xyXG5cclxuICAgICAgbGV0IG5WZXJ0aWNlc1BvbHlnb246IG51bWJlciA9IHBvbHlnb24ubGVuZ3RoO1xyXG5cclxuICAgICAgbGV0IGNsb3VkOiBWZXJ0aWNlcyA9IG5ldyBWZXJ0aWNlcygpO1xyXG4gICAgICBmb3IgKGxldCBsb25naXR1ZGU6IG51bWJlciA9IDA7IGxvbmdpdHVkZSA8PSB0aGlzLmxvbmdpdHVkZXM7IGxvbmdpdHVkZSsrKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IG5WZXJ0aWNlc1BvbHlnb247IGkrKykge1xyXG4gICAgICAgICAgbGV0IHV2OiBWZWN0b3IyID0gbmV3IFZlY3RvcjIobG9uZ2l0dWRlIC8gdGhpcy5sb25naXR1ZGVzLCBkaXN0YW5jZXNbaV0pO1xyXG4gICAgICAgICAgLy8gVE9ETzogbGFzdCBzZWN0b3Igc2hvdWxkIG9ubHkgYmUgcmVmZXJlbmNlcyB0byB0aGUgZmlyc3QgbWVyaWRpYW5cclxuICAgICAgICAgIGlmIChsb25naXR1ZGUgPT0gdGhpcy5sb25naXR1ZGVzKVxyXG4gICAgICAgICAgICBjbG91ZC5wdXNoKG5ldyBWZXJ0ZXgoaSwgdXYpKTtcclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAobG9uZ2l0dWRlID4gMCAmJiB0aGlzLnNoYXBlW2ldLnggPT0gMCkgLy8gdXNlIGEgc2luZ2xlIHZlcnRleCB3aGVuIGl0J3Mgb24gdGhlIHJvdGF0aW9uIGF4aXNcclxuICAgICAgICAgICAgICBjbG91ZC5wdXNoKG5ldyBWZXJ0ZXgoaSwgdXYpKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgIGNsb3VkLnB1c2gobmV3IFZlcnRleChwb2x5Z29uW2ldLmNsb25lLCB1dikpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBwb2x5Z29uLmZvckVhY2goKF92ZWN0b3I6IFZlY3RvcjMpID0+IF92ZWN0b3IudHJhbnNmb3JtKG10eFJvdGF0ZSkpO1xyXG4gICAgICB9XHJcblxyXG5cclxuICAgICAgLy8gY29weSBpbmRpY2VzIHRvIG5ldyBpbmRleCBhcnJheVxyXG4gICAgICBsZXQgZmFjZXM6IEZhY2VbXSA9IFtdO1xyXG5cclxuICAgICAgZm9yIChsZXQgbG9uZ2l0dWRlOiBudW1iZXIgPSAwOyBsb25naXR1ZGUgPCB0aGlzLmxvbmdpdHVkZXM7IGxvbmdpdHVkZSsrKSB7XHJcbiAgICAgICAgZm9yIChsZXQgbGF0aXR1ZGU6IG51bWJlciA9IDA7IGxhdGl0dWRlIDwgblZlcnRpY2VzUG9seWdvbiAtIDE7IGxhdGl0dWRlKyspIHtcclxuICAgICAgICAgIGxldCBzdGFydDogbnVtYmVyID0gbG9uZ2l0dWRlICogblZlcnRpY2VzUG9seWdvbiArIGxhdGl0dWRlO1xyXG4gICAgICAgICAgbGV0IHF1YWQ6IFF1YWQgPSBuZXcgUXVhZChjbG91ZCwgc3RhcnQgKyAxLCBzdGFydCArIDEgKyBuVmVydGljZXNQb2x5Z29uLCBzdGFydCArIG5WZXJ0aWNlc1BvbHlnb24sIHN0YXJ0KTtcclxuICAgICAgICAgIGZhY2VzLnB1c2goLi4ucXVhZC5mYWNlcyk7XHJcbiAgICAgICAgICAvLyBUT0RPOiBjYXRjaCBpbnZhbGlkIGZhY2VzIHJpZ2h0IGhlcmUuLi5cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuY2xvdWQgPSBjbG91ZDtcclxuICAgICAgdGhpcy5mYWNlcyA9IGZhY2VzO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlIGEgVVYgU3BoZXJlIHdpdGggYSBnaXZlbiBudW1iZXIgb2Ygc2VjdG9ycyBhbmQgc3RhY2tzIChjbGFtcGVkIGF0IDEyOCoxMjgpXHJcbiAgICogSW1wbGVtZW50YXRpb24gYmFzZWQgb24gaHR0cDovL3d3dy5zb25naG8uY2Evb3BlbmdsL2dsX3NwaGVyZS5odG1sXHJcbiAgICogQGF1dGhvcnMgU2ltb24gU3RvcmwtU2NodWxrZSwgSEZVLCAyMDIwIHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjBcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgTWVzaFNwaGVyZSBleHRlbmRzIE1lc2hSb3RhdGlvbiB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gTWVzaC5yZWdpc3RlclN1YmNsYXNzKE1lc2hTcGhlcmUpO1xyXG4gICAgcHJpdmF0ZSBsYXRpdHVkZXM6IG51bWJlcjtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX25hbWU6IHN0cmluZyA9IFwiTWVzaFNwaGVyZVwiLCBfbG9uZ2l0dWRlczogbnVtYmVyID0gOCwgX2xhdGl0dWRlczogbnVtYmVyID0gOCkge1xyXG4gICAgICBzdXBlcihfbmFtZSk7XHJcbiAgICAgIHRoaXMuY3JlYXRlKF9sb25naXR1ZGVzLCBfbGF0aXR1ZGVzKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgY3JlYXRlKF9sb25naXR1ZGVzOiBudW1iZXIgPSAzLCBfbGF0aXR1ZGVzOiBudW1iZXIgPSAyKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgICAgLy9DbGFtcCByZXNvbHV0aW9uIHRvIHByZXZlbnQgcGVyZm9ybWFuY2UgaXNzdWVzXHJcbiAgICAgIHRoaXMubG9uZ2l0dWRlcyA9IE1hdGgubWluKE1hdGgucm91bmQoX2xvbmdpdHVkZXMpLCAxMjgpO1xyXG4gICAgICB0aGlzLmxhdGl0dWRlcyA9IE1hdGgubWluKE1hdGgucm91bmQoX2xhdGl0dWRlcyksIDEyOCk7XHJcblxyXG4gICAgICBpZiAoX2xvbmdpdHVkZXMgPCAzIHx8IF9sYXRpdHVkZXMgPCAyKSB7XHJcbiAgICAgICAgRGVidWcud2FybihcIlVWIFNwaGVyZSBtdXN0IGhhdmUgYXQgbGVhc3QgMyBsb25naXR1ZGVzIGFuZCAyIGxhdGl0dWRlcyB0byBmb3JtIGEgMy1kaW1lbnNpb25hbCBzaGFwZS5cIik7XHJcbiAgICAgICAgdGhpcy5sb25naXR1ZGVzID0gTWF0aC5tYXgoMywgX2xvbmdpdHVkZXMpO1xyXG4gICAgICAgIHRoaXMubGF0aXR1ZGVzID0gTWF0aC5tYXgoMiwgX2xhdGl0dWRlcyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBzaGFwZTogVmVjdG9yMltdID0gW107XHJcbiAgICAgIGxldCBzdGVwOiBudW1iZXIgPSBNYXRoLlBJIC8gdGhpcy5sYXRpdHVkZXM7XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPD0gdGhpcy5sYXRpdHVkZXM7ICsraSkge1xyXG4gICAgICAgIGxldCBhbmdsZTogbnVtYmVyID0gTWF0aC5QSSAvIDIgLSBpICogc3RlcDtcclxuICAgICAgICBsZXQgeDogbnVtYmVyID0gTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgICAgIGxldCB5OiBudW1iZXIgPSBNYXRoLnNpbihhbmdsZSk7XHJcblxyXG4gICAgICAgIHNoYXBlLnB1c2gobmV3IFZlY3RvcjIoeCAvIDIsIHkgLyAyKSk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gcGxhY2UgZmlyc3QgYW5kIGxhc3QgdmVydGV4IGV4YWN0bHkgb24gcm90YXRpb24gYXhpc1xyXG4gICAgICBzaGFwZVswXS54ID0gMDtcclxuICAgICAgc2hhcGVbc2hhcGUubGVuZ3RoIC0gMV0ueCA9IDA7XHJcblxyXG4gICAgICBzdXBlci5yb3RhdGUoc2hhcGUsIF9sb25naXR1ZGVzKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLmxhdGl0dWRlcyA9IHRoaXMubGF0aXR1ZGVzO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIHRoaXMuY3JlYXRlKF9zZXJpYWxpemF0aW9uLmxvbmdpdHVkZXMsIF9zZXJpYWxpemF0aW9uLmxhdGl0dWRlcyk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgc3VwZXIubXV0YXRlKF9tdXRhdG9yKTtcclxuICAgICAgdGhpcy5jcmVhdGUoX211dGF0b3IubG9uZ2l0dWRlcywgX211dGF0b3IubGF0aXR1ZGVzKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICBzdXBlci5yZWR1Y2VNdXRhdG9yKF9tdXRhdG9yKTtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLnNoYXBlO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogR2VuZXJhdGUgdHdvIHF1YWRzIHBsYWNlZCBiYWNrIHRvIGJhY2ssIHRoZSBvbmUgZmFjaW5nIGluIG5lZ2F0aXZlIFotZGlyZWN0aW9uIGlzIHRleHR1cmVkIHJldmVyc2VkXHJcbiAgICogYGBgcGxhaW50ZXh0XHJcbiAgICogICAgICAgIDAgX18gM1xyXG4gICAqICAgICAgICAgfF9ffFxyXG4gICAqICAgICAgICAxICAgIDIgICAgICAgICAgICAgXHJcbiAgICogYGBgIFxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIwXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE1lc2hTcHJpdGUgZXh0ZW5kcyBNZXNoIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBNZXNoLnJlZ2lzdGVyU3ViY2xhc3MoTWVzaFNwcml0ZSk7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9uYW1lOiBzdHJpbmcgPSBcIk1lc2hTcHJpdGVcIikge1xyXG4gICAgICBzdXBlcihfbmFtZSk7XHJcbiAgICAgIHRoaXMuY2xvdWQgPSBuZXcgVmVydGljZXMoXHJcbiAgICAgICAgbmV3IFZlcnRleChuZXcgVmVjdG9yMygtMC41LCAwLjUsIDApLCBuZXcgVmVjdG9yMigwLCAwKSksXHJcbiAgICAgICAgbmV3IFZlcnRleChuZXcgVmVjdG9yMygtMC41LCAtMC41LCAwKSwgbmV3IFZlY3RvcjIoMCwgMSkpLFxyXG4gICAgICAgIG5ldyBWZXJ0ZXgobmV3IFZlY3RvcjMoMC41LCAtMC41LCAwKSwgbmV3IFZlY3RvcjIoMSwgMSkpLFxyXG4gICAgICAgIG5ldyBWZXJ0ZXgobmV3IFZlY3RvcjMoMC41LCAwLjUsIDApLCBuZXcgVmVjdG9yMigxLCAwKSlcclxuICAgICAgKTtcclxuICAgICAgdGhpcy5mYWNlcyA9IFtcclxuICAgICAgICBuZXcgRmFjZSh0aGlzLmNsb3VkLCAxLCAyLCAwKSxcclxuICAgICAgICBuZXcgRmFjZSh0aGlzLmNsb3VkLCAyLCAzLCAwKSxcclxuICAgICAgICBuZXcgRmFjZSh0aGlzLmNsb3VkLCAwLCAzLCAxKSxcclxuICAgICAgICBuZXcgRmFjZSh0aGlzLmNsb3VkLCAzLCAyLCAxKVxyXG4gICAgICBdO1xyXG5cclxuICAgICAgY29uc29sZS5sb2codGhpcy5ub3JtYWxzVmVydGV4KTsgXHJcbiAgICB9XHJcblxyXG4gICAgLy8gZmxhdCBpcyBzdGFuZGFyZCBoZXJlXHJcbiAgICBwdWJsaWMgZ2V0IHZlcnRpY2VzRmxhdCgpOiBGbG9hdDMyQXJyYXkgeyByZXR1cm4gc3VwZXIudmVydGljZXM7IH1cclxuICAgIHB1YmxpYyBnZXQgaW5kaWNlc0ZsYXQoKTogVWludDE2QXJyYXkgeyByZXR1cm4gc3VwZXIuaW5kaWNlczsgfVxyXG5cclxuICAgIC8vIGluc3RlYWQsIHNtb290aCBzaGFkaW5nIHdvdWxkIG5lZWQgZXh0cmEgYXR0ZW50aW9uIGJ1dCBpcyBub3QgcmVsZXZhbnQuLi5cclxuXHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogR2VuZXJhdGUgYSBUb3J1cyB3aXRoIGEgZ2l2ZW4gdGhpY2tuZXNzIGFuZCB0aGUgbnVtYmVyIG9mIG1ham9yLSBhbmQgbWlub3Igc2VnbWVudHNcclxuICAgKiBAYXV0aG9ycyBTaW1vbiBTdG9ybC1TY2h1bGtlLCBIRlUsIDIwMjAgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBNZXNoVG9ydXMgZXh0ZW5kcyBNZXNoUm90YXRpb24ge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IE1lc2gucmVnaXN0ZXJTdWJjbGFzcyhNZXNoVG9ydXMpO1xyXG4gICAgcHJpdmF0ZSBzaXplOiBudW1iZXIgPSAwLjI1O1xyXG4gICAgcHJpdmF0ZSBsYXRpdHVkZXM6IG51bWJlciA9IDEyO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nID0gXCJNZXNoVG9ydXNcIiwgX3NpemU6IG51bWJlciA9IDAuMjUsIF9sb25naXR1ZGVzOiBudW1iZXIgPSA4LCBfbGF0aXR1ZGVzOiBudW1iZXIgPSA2KSB7XHJcbiAgICAgIHN1cGVyKF9uYW1lLCBNZXNoVG9ydXMuZ2V0U2hhcGUoX3NpemUsIE1hdGgubWF4KDMsIF9sYXRpdHVkZXMpKSwgX2xvbmdpdHVkZXMpO1xyXG4gICAgICB0aGlzLnNpemUgPSBfc2l6ZTtcclxuICAgICAgdGhpcy5sb25naXR1ZGVzID0gX2xvbmdpdHVkZXM7XHJcbiAgICAgIHRoaXMubGF0aXR1ZGVzID0gTWF0aC5tYXgoMywgX2xhdGl0dWRlcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0U2hhcGUoX3NpemU6IG51bWJlciwgX2xhdGl0dWRlczogbnVtYmVyKTogVmVjdG9yMltdIHtcclxuICAgICAgbGV0IHNoYXBlOiBWZWN0b3IyW10gPSBbXTtcclxuICAgICAgbGV0IHJhZGl1czogbnVtYmVyID0gX3NpemUgLyAyO1xyXG4gICAgICBsZXQgY2VudGVyOiBWZWN0b3IyID0gbmV3IFZlY3RvcjIoMC4yNSArIHJhZGl1cywgMCk7XHJcbiAgICAgIGZvciAobGV0IGxhdGl0dWRlOiBudW1iZXIgPSAwOyBsYXRpdHVkZSA8PSBfbGF0aXR1ZGVzOyBsYXRpdHVkZSsrKSB7XHJcbiAgICAgICAgbGV0IGFuZ2xlOiBudW1iZXIgPSAyICogTWF0aC5QSSAqIGxhdGl0dWRlIC8gX2xhdGl0dWRlcztcclxuICAgICAgICBzaGFwZS5wdXNoKFZlY3RvcjIuU1VNKGNlbnRlciwgbmV3IFZlY3RvcjIocmFkaXVzICogLU1hdGguY29zKGFuZ2xlKSwgcmFkaXVzICogTWF0aC5zaW4oYW5nbGUpKSkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBzaGFwZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgY3JlYXRlKF9zaXplOiBudW1iZXIgPSAwLjI1LCBfbG9uZ2l0dWRlczogbnVtYmVyID0gOCwgX2xhdGl0dWRlczogbnVtYmVyID0gNik6IHZvaWQge1xyXG4gICAgICB0aGlzLnNpemUgPSBfc2l6ZTtcclxuICAgICAgdGhpcy5sYXRpdHVkZXMgPSBNYXRoLm1heCgzLCBfbGF0aXR1ZGVzKTtcclxuICAgICAgc3VwZXIucm90YXRlKE1lc2hUb3J1cy5nZXRTaGFwZShfc2l6ZSwgX2xhdGl0dWRlcyksIF9sb25naXR1ZGVzKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLmxhdGl0dWRlcyA9IHRoaXMubGF0aXR1ZGVzO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnNpemUgPSB0aGlzLnNpemU7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgdGhpcy5jcmVhdGUoX3NlcmlhbGl6YXRpb24uc2l6ZSwgX3NlcmlhbGl6YXRpb24ubG9uZ2l0dWRlcywgX3NlcmlhbGl6YXRpb24ubGF0aXR1ZGVzKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBzdXBlci5tdXRhdGUoX211dGF0b3IpO1xyXG4gICAgICB0aGlzLmNyZWF0ZShfbXV0YXRvci5zaXplLCBfbXV0YXRvci5sb25naXR1ZGVzLCBfbXV0YXRvci5sYXRpdHVkZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIHN1cGVyLnJlZHVjZU11dGF0b3IoX211dGF0b3IpO1xyXG4gICAgICBkZWxldGUgX211dGF0b3Iuc2hhcGU7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgZW51bSBRVUFEU1BMSVQge1xyXG4gICAgUExBTkFSLCBBVF8wLCBBVF8xXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBIHN1cmZhY2UgY3JlYXRlZCB3aXRoIGZvdXIgdmVydGljZXMgd2hpY2ggaW1tZWRpYXRlbHkgY3JlYXRlcyBub25lLCBvbmUgb3IgdHdvIHtAbGluayBGYWNlfXMgZGVwZW5kaW5nIG9uIHZlcnRpY2VzIGF0IGlkZW50aWNhbCBwb3NpdGlvbnMuXHJcbiAgICogYGBgcGxhaW50ZXh0XHJcbiAgICogUVVBRFNQTElUOiAgUExBTkFSICAgICAgICAgICAgICAgICAgQVRfMCAgICAgICAgICAgICAgICAgICAgIEFUXzFcclxuICAgKiAgICAgICAgICAgICAwIF8gMyAgICAgICAgICAgICAgICAgICAwIF8gMyAgICAgICAgICAgICAgICAgICAgMCBfIDMgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICogICAgICAgICAgICAgIHxcXHwgICAgICAgICAgICAgICAgICAgICB8XFx8ICAgICAgICAgICAgICAgICAgICAgIHwvfCAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgKiAgICAgICAgICAgICAxIOKAviAyICAgICAgICAgICAgICAgICAgIDEg4oC+IDIgICAgICAgICAgICAgICAgICAgIDEg4oC+IDIgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgKiAgc2hhcmVkIGxhc3QgdmVydGV4IDIgICAgICBsYXN0IHZlcnRpY2VzIDIgKyAzICAgICAgbGFzdCB2ZXJ0aWNlcyAzICsgMCBcclxuICAgKiAgICAgIFxyXG4gICAqIGBgYCBcclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMlxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBRdWFkIHtcclxuICAgIHB1YmxpYyBmYWNlczogRmFjZVtdO1xyXG4gICAgI3NwbGl0OiBRVUFEU1BMSVQ7XHJcblxyXG4gICAgY29uc3RydWN0b3IoX3ZlcnRpY2VzOiBWZXJ0aWNlcywgX2luZGV4MDogbnVtYmVyLCBfaW5kZXgxOiBudW1iZXIsIF9pbmRleDI6IG51bWJlciwgX2luZGV4MzogbnVtYmVyLCBfc3BsaXQ6IFFVQURTUExJVCA9IFFVQURTUExJVC5QTEFOQVIpIHtcclxuICAgICAgdGhpcy5mYWNlcyA9IFtdO1xyXG4gICAgICB0aGlzLiNzcGxpdCA9IF9zcGxpdDtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBpZiAoX3NwbGl0ICE9IFFVQURTUExJVC5BVF8xKVxyXG4gICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKG5ldyBGYWNlKF92ZXJ0aWNlcywgX2luZGV4MCwgX2luZGV4MSwgX2luZGV4MikpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIHRoaXMuZmFjZXMucHVzaChuZXcgRmFjZShfdmVydGljZXMsIF9pbmRleDEsIF9pbmRleDIsIF9pbmRleDMpKTtcclxuICAgICAgfSBjYXRjaCAoX2U6IHVua25vd24pIHtcclxuICAgICAgICBEZWJ1Zy5mdWRnZShcIkZhY2UgZXhjbHVkZWRcIiwgKDxFcnJvcj5fZSkubWVzc2FnZSk7XHJcbiAgICAgIH1cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBpZiAoX3NwbGl0ID09IFFVQURTUExJVC5QTEFOQVIpXHJcbiAgICAgICAgICB0aGlzLmZhY2VzLnB1c2gobmV3IEZhY2UoX3ZlcnRpY2VzLCBfaW5kZXgzLCBfaW5kZXgwLCBfaW5kZXgyKSk7XHJcbiAgICAgICAgZWxzZSBpZiAoX3NwbGl0ID09IFFVQURTUExJVC5BVF8wKVxyXG4gICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKG5ldyBGYWNlKF92ZXJ0aWNlcywgX2luZGV4MCwgX2luZGV4MiwgX2luZGV4MykpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIHRoaXMuZmFjZXMucHVzaChuZXcgRmFjZShfdmVydGljZXMsIF9pbmRleDEsIF9pbmRleDMsIF9pbmRleDApKTtcclxuICAgICAgfSBjYXRjaCAoX2U6IHVua25vd24pIHtcclxuICAgICAgICBEZWJ1Zy5mdWRnZShcIkZhY2UgZXhjbHVkZWRcIiwgKDxFcnJvcj5fZSkubWVzc2FnZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHNwbGl0KCk6IFFVQURTUExJVCB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNzcGxpdDtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgY2xhc3MgVmVydGV4IHtcclxuICAgIHB1YmxpYyBwb3NpdGlvbjogVmVjdG9yMztcclxuICAgIHB1YmxpYyB1djogVmVjdG9yMjtcclxuICAgIHB1YmxpYyBub3JtYWw6IFZlY3RvcjM7XHJcbiAgICBwdWJsaWMgcmVmZXJUbzogbnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVwcmVzZW50cyBhIHZlcnRleCBvZiBhIG1lc2ggd2l0aCBleHRlbmRlZCBpbmZvcm1hdGlvbiBzdWNoIGFzIHRoZSB1diBjb29yZGluYXRlcyBhbmQgdGhlIHZlcnRleCBub3JtYWwuXHJcbiAgICAgKiBJdCBtYXkgcmVmZXIgdG8gYW5vdGhlciB2ZXJ0ZXggdmlhIGFuIGluZGV4IGludG8gc29tZSBhcnJheSwgaW4gd2hpY2ggY2FzZSB0aGUgcG9zaXRpb24gYW5kIHRoZSBub3JtYWwgYXJlIHN0b3JlZCB0aGVyZS5cclxuICAgICAqIFRoaXMgd2F5LCB2ZXJ0ZXggcG9zaXRpb24gYW5kIG5vcm1hbCBpcyBhIDE6MSBhc3NvY2lhdGlvbiwgdmVydGV4IHRvIHRleHR1cmUgY29vcmRpbmF0ZXMgYSAxOm4gYXNzb2NpYXRpb24uXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9wb3NpdGlvbk9ySW5kZXg6IFZlY3RvcjMgfCBudW1iZXIsIF91djogVmVjdG9yMiA9IG51bGwsIF9ub3JtYWw6IFZlY3RvcjMgPSBWZWN0b3IzLlpFUk8oKSkge1xyXG4gICAgICBpZiAoX3Bvc2l0aW9uT3JJbmRleCBpbnN0YW5jZW9mIFZlY3RvcjMpXHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IF9wb3NpdGlvbk9ySW5kZXg7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICB0aGlzLnJlZmVyVG8gPSBfcG9zaXRpb25PckluZGV4O1xyXG5cclxuICAgICAgdGhpcy51diA9IF91djtcclxuICAgICAgdGhpcy5ub3JtYWwgPSBfbm9ybWFsO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEFycmF5IHdpdGggZXh0ZW5kZWQgZnVuY3Rpb25hbGl0eSB0byBzZXJ2ZSBhcyBhIHtAbGluayBWZXJ0ZXh9LWNsb3VkLiBcclxuICAgKiBBY2Nlc3NvcnMgeWllbGQgcG9zaXRpb24gb3Igbm9ybWFsIGFsc28gZm9yIHZlcnRpY2VzIHJlZmVyZW5jaW5nIG90aGVyIHZlcnRpY2VzXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjJcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgVmVydGljZXMgZXh0ZW5kcyBBcnJheTxWZXJ0ZXg+IHtcclxuICAgIC8vIFRPRE86IHRoaXMgY2xhc3MgbWF5IGJlY29tZSBtb3JlIHBvd2VyZnVsIGJ5IGhpZGluZyB0aGUgYXJyYXkgYW5kIGFkZCBtb3JlIHNlcnZpY2UgbWV0aG9kcyBsaWtlIGNhbGN1bGF0aW5nIGJvdW5kaW5nIGJveCwgcmFkaXVzIGV0Yy5cclxuICAgIC8vIHNlZSBpZiBhIHByb3h5IG9mIHRoZSBhcnJheSBpbnRlcmZhY2luZyBbXSB3b3VsZCBkbyBhIGdvb2Qgam9iXHJcbiAgICAvKipcclxuICAgICAqIHJldHVybnMgdGhlIHBvc2l0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgdmVydGV4IGFkZHJlc3NlZCwgcmVzb2x2aW5nIHJlZmVyZW5jZXMgYmV0d2VlbiB2ZXJ0aWNlcyBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHBvc2l0aW9uKF9pbmRleDogbnVtYmVyKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCB2ZXJ0ZXg6IFZlcnRleCA9IHRoaXNbX2luZGV4XTtcclxuICAgICAgcmV0dXJuICh2ZXJ0ZXgucmVmZXJUbyA9PSB1bmRlZmluZWQpID8gdmVydGV4LnBvc2l0aW9uIDogdGhpc1t2ZXJ0ZXgucmVmZXJUb10ucG9zaXRpb247XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogcmV0dXJucyB0aGUgbm9ybWFsIGFzc29jaWF0ZWQgd2l0aCB0aGUgdmVydGV4IGFkZHJlc3NlZCwgcmVzb2x2aW5nIHJlZmVyZW5jZXMgYmV0d2VlbiB2ZXJ0aWNlcyBcclxuICAgICAqL1xyXG4gICAgcHVibGljIG5vcm1hbChfaW5kZXg6IG51bWJlcik6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgdmVydGV4OiBWZXJ0ZXggPSB0aGlzW19pbmRleF07XHJcbiAgICAgIHJldHVybiAodmVydGV4LnJlZmVyVG8gPT0gdW5kZWZpbmVkKSA/IHZlcnRleC5ub3JtYWwgOiB0aGlzW3ZlcnRleC5yZWZlclRvXS5ub3JtYWw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiByZXR1cm5zIHRoZSB1di1jb29yZGluYXRlcyBhc3NvY2lhdGVkIHdpdGggdGhlIHZlcnRleCBhZGRyZXNzZWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHV2KF9pbmRleDogbnVtYmVyKTogVmVjdG9yMiB7XHJcbiAgICAgIHJldHVybiB0aGlzW19pbmRleF0udXY7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogRGVmaW5lcyBhdXRvbWF0aWMgYWRqdXN0bWVudCBvZiB0aGUgY29sbGlkZXJcclxuICAgKi9cclxuICBleHBvcnQgZW51bSBCT0RZX0lOSVQge1xyXG4gICAgLyoqIENvbGxpZGVyIHVzZXMgdGhlIHBpdm90IG9mIHRoZSBtZXNoIGZvciBpbml0aWxpYWxpemF0aW9uICovXHJcbiAgICBUT19NRVNILFxyXG4gICAgLyoqIENvbGxpZGVyIHVzZXMgdGhlIHRyYW5zZm9ybSBvZiB0aGUgbm9kZSBmb3IgaW5pdGlsaWFsaXphdGlvbiAqL1xyXG4gICAgVE9fTk9ERSxcclxuICAgIC8qKiBDb2xsaWRlciB1c2VzIGl0cyBvd24gcGl2b3QgZm9yIGluaXRpbGlhbGl6YXRpb24gKi9cclxuICAgIFRPX1BJVk9UXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgICAqIEFjdHMgYXMgdGhlIHBoeXNpY2FsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB7QGxpbmsgTm9kZX0gaXQncyBhdHRhY2hlZCB0by5cclxuICAgICAqIEl0J3MgdGhlIGNvbm5lY3Rpb24gYmV0d2VlbiB0aGUgRnVkZ2UgcmVuZGVyZWQgd29ybGQgYW5kIHRoZSBQaHlzaWNzIHdvcmxkLlxyXG4gICAgICogRm9yIHRoZSBwaHlzaWNzIHRvIGNvcnJlY3RseSBnZXQgdGhlIHRyYW5zZm9ybWF0aW9ucyByb3RhdGlvbnMgbmVlZCB0byBiZSBhcHBsaWVkIHdpdGggZnJvbSBsZWZ0ID0gdHJ1ZS5cclxuICAgICAqIE9yIHJvdGF0aW9ucyBuZWVkIHRvIGhhcHBlbiBiZWZvcmUgc2NhbGluZy5cclxuICAgICAqIEBhdXRob3IgTWFya28gRmVocmVuYmFjaCwgSEZVLCAyMDIwIHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuICAgICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb21wb25lbnRSaWdpZGJvZHkgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IENvbXBvbmVudC5yZWdpc3RlclN1YmNsYXNzKENvbXBvbmVudFJpZ2lkYm9keSk7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBtYXBCb2R5VHlwZTogeyBbdHlwZTogbnVtYmVyXTogbnVtYmVyIH0gPSAodHlwZW9mIE9JTU8gPT0gXCJ1bmRlZmluZWRcIikgP1xyXG4gICAgICB7XHJcbiAgICAgICAgW0JPRFlfVFlQRS5EWU5BTUlDXTogMCwgW0JPRFlfVFlQRS5TVEFUSUNdOiAxLCBbQk9EWV9UWVBFLktJTkVNQVRJQ106IDJcclxuICAgICAgfSA6IHtcclxuICAgICAgICBbQk9EWV9UWVBFLkRZTkFNSUNdOiBPSU1PLlJpZ2lkQm9keVR5cGUuRFlOQU1JQywgW0JPRFlfVFlQRS5TVEFUSUNdOiBPSU1PLlJpZ2lkQm9keVR5cGUuU1RBVElDLCBbQk9EWV9UWVBFLktJTkVNQVRJQ106IE9JTU8uUmlnaWRCb2R5VHlwZS5LSU5FTUFUSUNcclxuICAgICAgfTtcclxuXHJcbiAgICAvKiogVHJhbnNmb3JtYXRpb24gb2YgdGhlIGNvbGxpZGVyIHJlbGF0aXZlIHRvIHRoZSBub2RlJ3MgdHJhbnNmb3JtLiBPbmNlIHNldCBtb3N0bHkgcmVtYWlucyBjb25zdGFudC4gXHJcbiAgICAgKiBJZiBhbHRlcmVkLCB7QGxpbmsgaXNJbml0aWFsaXplZH0gbXVzdCBiZSByZXNldCB0byBmYWxzZSB0byByZWNyZWF0ZSB0aGUgY29sbGlkZXIgaW4gdGhlIG5leHQge0BsaW5rIFJlbmRlci5wcmVwYXJlfVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbXR4UGl2b3Q6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIFZlcnRpY2VzIHRoYXQgYnVpbGQgYSBjb252ZXggbWVzaCAoZm9ybSB0aGF0IGlzIGluIGl0c2VsZiBjbG9zZWQpLiBOZWVkcyB0byBzZXQgaW4gdGhlIGNvbnN0cnVjdGlvbiBvZiB0aGUgcmIgaWYgbm9uZSBvZiB0aGUgc3RhbmRhcmQgY29sbGlkZXJzIGlzIHVzZWQuIFxyXG4gICAgICogVW50ZXN0ZWQgYW5kIG5vdCB5ZXQgZnVsbHkgc3VwcG9ydGVkIGJ5IHNlcmlhbGl6YXRpb24gYW5kIG11dGF0aW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29udmV4TWVzaDogRmxvYXQzMkFycmF5ID0gbnVsbDtcclxuXHJcbiAgICAvKiogQ29sbGlzaW9ucyB3aXRoIHJpZ2lkYm9kaWVzIGhhcHBlbmluZyB0byB0aGlzIGJvZHksIGNhbiBiZSB1c2VkIHRvIGJ1aWxkIGEgY3VzdG9tIG9uQ29sbGlzaW9uU3RheSBmdW5jdGlvbmFsaXR5LiAqL1xyXG4gICAgcHVibGljIGNvbGxpc2lvbnM6IENvbXBvbmVudFJpZ2lkYm9keVtdID0gbmV3IEFycmF5KCk7XHJcbiAgICAvKiogVHJpZ2dlcnMgdGhhdCBhcmUgY3VycmVudGx5IHRyaWdnZXJpbmcgdGhpcyBib2R5ICovXHJcbiAgICBwdWJsaWMgdHJpZ2dlcmluZ3M6IENvbXBvbmVudFJpZ2lkYm9keVtdID0gbmV3IEFycmF5KCk7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogVGhlIGdyb3VwcyB0aGlzIG9iamVjdCBjb2xsaWRlcyB3aXRoLiBHcm91cHMgbXVzdCBiZSB3cml0ZW4gaW4gZm9ybSBvZlxyXG4gICAgICogIGUuZy4gY29sbGlzaW9uTWFzayA9IHtAbGluayBDT0xMSVNJT05fR1JPVVAuREVGQVVMVH0gfCB7QGxpbmsgQ09MTElTSU9OX0dST1VQfS4uLi4gYW5kIHNvIG9uIHRvIGNvbGxpZGUgd2l0aCBtdWx0aXBsZSBncm91cHMuIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29sbGlzaW9uTWFzazogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEF1dG9tYXRpYyBhZGp1c3RtZW50IG9mIHRoZSBwaXZvdCB3aGVuIHtAbGluayBSZW5kZXIucHJlcGFyZX0gaXMgY2FsbGVkIGFjY29yZGluZyB0byB7QGxpbmsgQk9EWV9JTklUfVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaW5pdGlhbGl6YXRpb246IEJPRFlfSU5JVCA9IEJPRFlfSU5JVC5UT19QSVZPVDtcclxuICAgIC8qKiBNYXJrcyBpZiBjb2xsaWRlciB3YXMgaW5pdGlhbGl6ZWQuIFJlc2V0IHRvIGZhbHNlIHRvIGluaXRpYWxpemUgYWdhaW4gZS5nLiBhZnRlciBtYW5pcHVsYXRpb24gb2YgbXR4UGl2b3QgKi9cclxuICAgIHB1YmxpYyBpc0luaXRpYWxpemVkOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgLyoqIElEIHRvIHJlZmVyZW5jZSB0aGlzIHNwZWNpZmljIENvbXBvbmVudFJpZ2lkYm9keSAqL1xyXG4gICAgI2lkOiBudW1iZXIgPSAwO1xyXG5cclxuICAgIC8vUHJpdmF0ZSBpbmZvcm1hdGlvbnMgLSBNb3N0bHkgT2ltb1BoeXNpY3MgdmFyaWFibGVzIHRoYXQgc2hvdWxkIG5vdCBiZSBleHBvc2VkIHRvIHRoZSBGdWRnZSBVc2VyIGFuZCBtYW5pcHVsYXRlZCBieSB0aGVtXHJcbiAgICAjY29sbGlkZXI6IE9JTU8uU2hhcGU7XHJcbiAgICAjY29sbGlkZXJJbmZvOiBPSU1PLlNoYXBlQ29uZmlnO1xyXG4gICAgI2NvbGxpc2lvbkdyb3VwOiBDT0xMSVNJT05fR1JPVVAgPSBDT0xMSVNJT05fR1JPVVAuREVGQVVMVDtcclxuICAgICN0eXBlQ29sbGlkZXI6IENPTExJREVSX1RZUEUgPSBDT0xMSURFUl9UWVBFLkNVQkU7XHJcblxyXG4gICAgI3JpZ2lkYm9keTogT0lNTy5SaWdpZEJvZHk7XHJcbiAgICAjcmlnaWRib2R5SW5mbzogT0lNTy5SaWdpZEJvZHlDb25maWcgPSBuZXcgT0lNTy5SaWdpZEJvZHlDb25maWcoKTtcclxuICAgICN0eXBlQm9keTogQk9EWV9UWVBFID0gQk9EWV9UWVBFLkRZTkFNSUM7XHJcblxyXG4gICAgI21hc3NEYXRhOiBPSU1PLk1hc3NEYXRhID0gbmV3IE9JTU8uTWFzc0RhdGEoKTtcclxuICAgICNyZXN0aXR1dGlvbjogbnVtYmVyO1xyXG4gICAgI2ZyaWN0aW9uOiBudW1iZXI7XHJcbiAgICAjZGFtcGluZ0xpbmVhcjogbnVtYmVyID0gMC4xO1xyXG4gICAgI2RhbXBpbmdBbmd1bGFyOiBudW1iZXIgPSAwLjE7XHJcbiAgICAjZWZmZWN0Um90YXRpb246IFZlY3RvcjMgPSBWZWN0b3IzLk9ORSgpO1xyXG4gICAgI2VmZmVjdEdyYXZpdHk6IG51bWJlciA9IDE7XHJcbiAgICAjaXNUcmlnZ2VyOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICAjbXR4UGl2b3RVbnNjYWxlZDogTWF0cml4NHg0ID0gTWF0cml4NHg0LklERU5USVRZKCk7XHJcbiAgICAjbXR4UGl2b3RJbnZlcnNlOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKTtcclxuXHJcbiAgICAjY2FsbGJhY2tzOiBPSU1PLkNvbnRhY3RDYWxsYmFjazsgLy9DYWxsYmFjayBNZXRob2RzIHdoZW4gd2l0aGluIHRoZSBvaW1vU3lzdGVtIGEgZXZlbnQgaXMgaGFwcGVuaW5nXHJcblxyXG4gICAgLy8gI3BoeXNpY3M6IFBoeXNpY3M7IC8vVE9ETzoga2VlcCBhIHBvaW50ZXIgdG8gdGhlIHBoeXNpY3MgaW5zdGFuY2UgdXNlZCBieSB0aGlzIGNvbXBvbmVudFxyXG5cclxuICAgIC8qKiBDcmVhdGluZyBhIG5ldyByaWdpZGJvZHkgd2l0aCBhIHdlaWdodCBpbiBrZywgYSBwaHlzaWNzIHR5cGUgKGRlZmF1bHQgPSBkeW5hbWljKSwgYSBjb2xsaWRlciB0eXBlIHdoYXQgcGh5c2ljYWwgZm9ybSBoYXMgdGhlIGNvbGxpZGVyLCB0byB3aGF0IGdyb3VwIGRvZXMgaXQgYmVsb25nLCBpcyB0aGVyZSBhIHRyYW5zZm9ybSBNYXRyaXggdGhhdCBzaG91bGQgYmUgdXNlZCwgYW5kIGlzIHRoZSBjb2xsaWRlciBkZWZpbmVkIGFzIGEgZ3JvdXAgb2YgcG9pbnRzIHRoYXQgcmVwcmVzZW50IGEgY29udmV4IG1lc2guICovXHJcbiAgICBjb25zdHJ1Y3RvcihfbWFzczogbnVtYmVyID0gMSwgX3R5cGU6IEJPRFlfVFlQRSA9IEJPRFlfVFlQRS5EWU5BTUlDLCBfY29sbGlkZXJUeXBlOiBDT0xMSURFUl9UWVBFID0gQ09MTElERVJfVFlQRS5DVUJFLCBfZ3JvdXA6IENPTExJU0lPTl9HUk9VUCA9IFBoeXNpY3Muc2V0dGluZ3MuZGVmYXVsdENvbGxpc2lvbkdyb3VwLCBfbXR4VHJhbnNmb3JtOiBNYXRyaXg0eDQgPSBudWxsLCBfY29udmV4TWVzaDogRmxvYXQzMkFycmF5ID0gbnVsbCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLmNyZWF0ZShfbWFzcywgX3R5cGUsIF9jb2xsaWRlclR5cGUsIF9ncm91cCwgX210eFRyYW5zZm9ybSwgX2NvbnZleE1lc2gpO1xyXG5cclxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULkNPTVBPTkVOVF9BREQsIHRoaXMuaG5kRXZlbnQpO1xyXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuQ09NUE9ORU5UX1JFTU9WRSwgdGhpcy5obmRFdmVudCk7XHJcbiAgICAgIC8vIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5OT0RFX0RFU0VSSUFMSVpFRCwgdGhpcy5obmRFdmVudCk7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICAvLyNyZWdpb24gQWNjZXNzb3JzXHJcbiAgICBwdWJsaWMgZ2V0IGlkKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNpZDtcclxuICAgIH1cclxuXHJcbiAgICAvKiogVXNlZCBmb3IgY2FsY3VsYXRpb24gb2YgdGhlIGdlb21ldHJpY2FsIHJlbGF0aW9uc2hpcCBvZiBub2RlIGFuZCBjb2xsaWRlciBieSB7QGxpbmsgUmVuZGVyfSovXHJcbiAgICBwdWJsaWMgZ2V0IG10eFBpdm90SW52ZXJzZSgpOiBNYXRyaXg0eDQge1xyXG4gICAgICByZXR1cm4gdGhpcy4jbXR4UGl2b3RJbnZlcnNlO1xyXG4gICAgfVxyXG4gICAgLyoqIFVzZWQgZm9yIGNhbGN1bGF0aW9uIG9mIHRoZSBnZW9tZXRyaWNhbCByZWxhdGlvbnNoaXAgb2Ygbm9kZSBhbmQgY29sbGlkZXIgYnkge0BsaW5rIFJlbmRlcn0qL1xyXG4gICAgcHVibGljIGdldCBtdHhQaXZvdFVuc2NhbGVkKCk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNtdHhQaXZvdFVuc2NhbGVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSZXRyaWV2ZSB0aGUgYm9keSB0eXBlLiBTZWUge0BsaW5rIEJPRFlfVFlQRX0gKi9cclxuICAgIHB1YmxpYyBnZXQgdHlwZUJvZHkoKTogQk9EWV9UWVBFIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3R5cGVCb2R5O1xyXG4gICAgfVxyXG4gICAgLyoqIFNldCB0aGUgYm9keSB0eXBlLiBTZWUge0BsaW5rIEJPRFlfVFlQRX0gKi9cclxuICAgIHB1YmxpYyBzZXQgdHlwZUJvZHkoX3ZhbHVlOiBCT0RZX1RZUEUpIHtcclxuICAgICAgdGhpcy4jdHlwZUJvZHkgPSBfdmFsdWU7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5zZXRUeXBlKENvbXBvbmVudFJpZ2lkYm9keS5tYXBCb2R5VHlwZVt0aGlzLiN0eXBlQm9keV0pO1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuc2V0TWFzc0RhdGEodGhpcy4jbWFzc0RhdGEpOyAvL2hhdmUgdG8gcmVzZXQgbWFzcyBhZnRlciBjaGFuZ2luZyB0aGUgdHlwZSwgc2luY2UgT2ltbyBpcyBoYW5kbGluZyBtYXNzIGludGVybmFsbHkgd3Jvbmcgd2hlbiBzd2l0Y2hpbmcgdHlwZXNcclxuICAgIH1cclxuXHJcbiAgICAvKiogVGhlIHNoYXBlIHRoYXQgcmVwcmVzZW50cyB0aGUge0BsaW5rIE5vZGV9IGluIHRoZSBwaHlzaWNhbCB3b3JsZC4gRGVmYXVsdCBpcyBhIEN1YmUuICovXHJcbiAgICBwdWJsaWMgZ2V0IHR5cGVDb2xsaWRlcigpOiBDT0xMSURFUl9UWVBFIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3R5cGVDb2xsaWRlcjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgdHlwZUNvbGxpZGVyKF92YWx1ZTogQ09MTElERVJfVFlQRSkge1xyXG4gICAgICBpZiAoX3ZhbHVlICE9IHRoaXMuI3R5cGVDb2xsaWRlciAmJiB0aGlzLiNyaWdpZGJvZHkgIT0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMuI3R5cGVDb2xsaWRlciA9IF92YWx1ZTtcclxuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUaGUgY29sbGlzaW9uIGdyb3VwIHRoaXMge0BsaW5rIE5vZGV9IGJlbG9uZ3MgdG8gaXQncyB0aGUgZGVmYXVsdCBncm91cCBub3JtYWxseSB3aGljaCBtZWFucyBpdCBwaHlzaWNhbGx5IGNvbGxpZGVzIHdpdGggZXZlcnkgZ3JvdXAgYmVzaWRlcyB0cmlnZ2VyLiAqL1xyXG4gICAgcHVibGljIGdldCBjb2xsaXNpb25Hcm91cCgpOiBDT0xMSVNJT05fR1JPVVAge1xyXG4gICAgICByZXR1cm4gdGhpcy4jY29sbGlzaW9uR3JvdXA7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IGNvbGxpc2lvbkdyb3VwKF92YWx1ZTogQ09MTElTSU9OX0dST1VQKSB7XHJcbiAgICAgIHRoaXMuI2NvbGxpc2lvbkdyb3VwID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy4jcmlnaWRib2R5ICE9IG51bGwpXHJcbiAgICAgICAgdGhpcy4jcmlnaWRib2R5LmdldFNoYXBlTGlzdCgpLnNldENvbGxpc2lvbkdyb3VwKHRoaXMuI2NvbGxpc2lvbkdyb3VwKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogTWFya2luZyB0aGUgQm9keSBhcyBhIHRyaWdnZXIgdGhlcmVmb3JlIG5vdCBpbmZsdWVuY2luZyB0aGUgY29sbGlzaW9uIHN5c3RlbSBidXQgb25seSBzZW5kaW5nIHRyaWdnZXJFdmVudHMgKi9cclxuICAgIHB1YmxpYyBnZXQgaXNUcmlnZ2VyKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy4jaXNUcmlnZ2VyO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBpc1RyaWdnZXIoX3ZhbHVlOiBib29sZWFuKSB7XHJcbiAgICAgIHRoaXMuI2lzVHJpZ2dlciA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuZ2V0T2ltb1JpZ2lkYm9keSgpICE9IG51bGwpIHtcclxuICAgICAgICB0aGlzLmdldE9pbW9SaWdpZGJvZHkoKS5faXNUcmlnZ2VyID0gdGhpcy4jaXNUcmlnZ2VyO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBwaHlzaWNhbCB3ZWlnaHQgb2YgdGhlIHtAbGluayBOb2RlfVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG1hc3MoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3JpZ2lkYm9keS5nZXRNYXNzKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHRpbmcgdGhlIHBoeXNpY2FsIHdlaWdodCBvZiB0aGUge0BsaW5rIE5vZGV9IGluIGtnXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQgbWFzcyhfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNtYXNzRGF0YS5tYXNzID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5ub2RlICE9IG51bGwpXHJcbiAgICAgICAgaWYgKHRoaXMuI3JpZ2lkYm9keSAhPSBudWxsKVxyXG4gICAgICAgICAgdGhpcy4jcmlnaWRib2R5LnNldE1hc3NEYXRhKHRoaXMuI21hc3NEYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogRHJhZyBvZiBsaW5lYXIgbW92ZW1lbnQuIEEgQm9keSBkb2VzIHNsb3cgZG93biBldmVuIG9uIGEgc3VyZmFjZSB3aXRob3V0IGZyaWN0aW9uLiAqL1xyXG4gICAgcHVibGljIGdldCBkYW1wVHJhbnNsYXRpb24oKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3JpZ2lkYm9keS5nZXRMaW5lYXJEYW1waW5nKCk7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IGRhbXBUcmFuc2xhdGlvbihfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNkYW1waW5nTGluZWFyID0gX3ZhbHVlO1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuc2V0TGluZWFyRGFtcGluZyhfdmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBEcmFnIG9mIHJvdGF0aW9uLiAqL1xyXG4gICAgcHVibGljIGdldCBkYW1wUm90YXRpb24oKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3JpZ2lkYm9keS5nZXRBbmd1bGFyRGFtcGluZygpO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBkYW1wUm90YXRpb24oX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jZGFtcGluZ0FuZ3VsYXIgPSBfdmFsdWU7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5zZXRBbmd1bGFyRGFtcGluZyhfdmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUaGUgZmFjdG9yIHRoaXMgcmlnaWRib2R5IHJlYWN0cyByb3RhdGlvbnMgdGhhdCBoYXBwZW4gaW4gdGhlIHBoeXNpY2FsIHdvcmxkLiAwIHRvIGxvY2sgcm90YXRpb24gdGhpcyBheGlzLiAqL1xyXG4gICAgcHVibGljIGdldCBlZmZlY3RSb3RhdGlvbigpOiBWZWN0b3IzIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI2VmZmVjdFJvdGF0aW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBlZmZlY3RSb3RhdGlvbihfZWZmZWN0OiBWZWN0b3IzKSB7XHJcbiAgICAgIHRoaXMuI2VmZmVjdFJvdGF0aW9uID0gX2VmZmVjdDtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LnNldFJvdGF0aW9uRmFjdG9yKG5ldyBPSU1PLlZlYzModGhpcy4jZWZmZWN0Um90YXRpb24ueCwgdGhpcy4jZWZmZWN0Um90YXRpb24ueSwgdGhpcy4jZWZmZWN0Um90YXRpb24ueikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUaGUgZmFjdG9yIHRoaXMgcmlnaWRib2R5IHJlYWN0cyB0byB3b3JsZCBncmF2aXR5LiBEZWZhdWx0ID0gMSBlLmcuIDEqOS44MSBtL3MuICovXHJcbiAgICBwdWJsaWMgZ2V0IGVmZmVjdEdyYXZpdHkoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI2VmZmVjdEdyYXZpdHk7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IGVmZmVjdEdyYXZpdHkoX2VmZmVjdDogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI2VmZmVjdEdyYXZpdHkgPSBfZWZmZWN0O1xyXG4gICAgICBpZiAodGhpcy4jcmlnaWRib2R5ICE9IG51bGwpIHRoaXMuI3JpZ2lkYm9keS5zZXRHcmF2aXR5U2NhbGUodGhpcy4jZWZmZWN0R3Jhdml0eSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGZyaWN0aW9uIG9mIHRoZSByaWdpZGJvZHksIHdoaWNoIGlzIHRoZSBmYWN0b3Igb2Ygc2xpZGluZyByZXNpc3RhbmNlIG9mIHRoaXMgcmlnaWRib2R5IG9uIHN1cmZhY2VzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgZnJpY3Rpb24oKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI2ZyaWN0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBmcmljdGlvbiBvZiB0aGUgcmlnaWRib2R5LCB3aGljaCBpcyB0aGUgZmFjdG9yIG9mICBzbGlkaW5nIHJlc2lzdGFuY2Ugb2YgdGhpcyByaWdpZGJvZHkgb24gc3VyZmFjZXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldCBmcmljdGlvbihfZnJpY3Rpb246IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNmcmljdGlvbiA9IF9mcmljdGlvbjtcclxuICAgICAgaWYgKHRoaXMuI3JpZ2lkYm9keS5nZXRTaGFwZUxpc3QoKSAhPSBudWxsKVxyXG4gICAgICAgIHRoaXMuI3JpZ2lkYm9keS5nZXRTaGFwZUxpc3QoKS5zZXRGcmljdGlvbih0aGlzLiNmcmljdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHJlc3RpdHV0aW9uIG9mIHRoZSByaWdpZGJvZHksIHdoaWNoIGlzIHRoZSBmYWN0b3Igb2YgYm91bmNpbmVzcyBvZiB0aGlzIHJpZ2lkYm9keSBvbiBzdXJmYWNlc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHJlc3RpdHV0aW9uKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNyZXN0aXR1dGlvbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgcmVzdGl0dXRpb24gb2YgdGhlIHJpZ2lkYm9keSwgd2hpY2ggaXMgdGhlIGZhY3RvciBvZiBib3VuY2luZXNzIG9mIHRoaXMgcmlnaWRib2R5IG9uIHN1cmZhY2VzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQgcmVzdGl0dXRpb24oX3Jlc3RpdHV0aW9uOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jcmVzdGl0dXRpb24gPSBfcmVzdGl0dXRpb247XHJcbiAgICAgIGlmICh0aGlzLiNyaWdpZGJvZHkuZ2V0U2hhcGVMaXN0KCkgIT0gbnVsbClcclxuICAgICAgICB0aGlzLiNyaWdpZGJvZHkuZ2V0U2hhcGVMaXN0KCkuc2V0UmVzdGl0dXRpb24odGhpcy4jcmVzdGl0dXRpb24pO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8gQWN0aXZhdGUgdGhlIGZ1bmN0aW9ucyBvZiB0aGlzIGNvbXBvbmVudCBhcyByZXNwb25zZSB0byBldmVudHNcclxuICAgIHB1YmxpYyBobmRFdmVudCA9IChfZXZlbnQ6IEV2ZW50KTogdm9pZCA9PiB7XHJcbiAgICAgIHN3aXRjaCAoX2V2ZW50LnR5cGUpIHtcclxuICAgICAgICBjYXNlIEVWRU5ULkNPTVBPTkVOVF9BREQ6XHJcbiAgICAgICAgICAvLyB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuQ09NUE9ORU5UX0FDVElWQVRFLCB0aGlzLmFkZFJpZ2lkYm9keVRvV29ybGQpO1xyXG4gICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULkNPTVBPTkVOVF9ERUFDVElWQVRFLCB0aGlzLnJlbW92ZVJpZ2lkYm9keUZyb21Xb3JsZCk7XHJcbiAgICAgICAgICAvLyB0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5OT0RFX0FDVElWQVRFLCB0aGlzLmFkZFJpZ2lkYm9keVRvV29ybGQsIHRydWUpOyAvLyB1c2UgY2FwdHVyZSB0byByZWFjdCB0byBicm9hZGNhc3QhXHJcbiAgICAgICAgICB0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5OT0RFX0RFQUNUSVZBVEUsIHRoaXMucmVtb3ZlUmlnaWRib2R5RnJvbVdvcmxkLCB0cnVlKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgRVZFTlQuQ09NUE9ORU5UX1JFTU9WRTpcclxuICAgICAgICAgIC8vIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVC5DT01QT05FTlRfQURELCB0aGlzLmFkZFJpZ2lkYm9keVRvV29ybGQpO1xyXG4gICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5ULkNPTVBPTkVOVF9SRU1PVkUsIHRoaXMucmVtb3ZlUmlnaWRib2R5RnJvbVdvcmxkKTtcclxuICAgICAgICAgIC8vIHRoaXMubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5ULk5PREVfQUNUSVZBVEUsIHRoaXMuYWRkUmlnaWRib2R5VG9Xb3JsZCwgdHJ1ZSk7IC8vIHVzZSBjYXB0dXJlIHRvIHJlYWN0IHRvIGJyb2FkY2FzdCFcclxuICAgICAgICAgIHRoaXMubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5ULk5PREVfREVBQ1RJVkFURSwgdGhpcy5yZW1vdmVSaWdpZGJvZHlGcm9tV29ybGQsIHRydWUpO1xyXG4gICAgICAgICAgdGhpcy5yZW1vdmVSaWdpZGJvZHlGcm9tV29ybGQoKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIC8vIGNhc2UgRVZFTlQuTk9ERV9ERVNFUklBTElaRUQ6XHJcbiAgICAgICAgLy8gICAvLyBpZiBkZXNlcmlhbGl6ZWQgdGhlIG5vZGUgaXMgbm93IGZ1bGx5IHJlY29uc3RydWN0ZWQgYW5kIGFjY2VzcyB0byBhbGwgaXRzIGNvbXBvbmVudHMgYW5kIGNoaWxkcmVuIGlzIHBvc3NpYmxlXHJcbiAgICAgICAgLy8gICB0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5OT0RFX0FDVElWQVRFLCB0aGlzLmFkZFJpZ2lkYm9keVRvV29ybGQpO1xyXG4gICAgICAgIC8vICAgdGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuTk9ERV9ERUFDVElWQVRFLCB0aGlzLnJlbW92ZVJpZ2lkYm9keUZyb21Xb3JsZCk7XHJcbiAgICAgICAgLy8gICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2Zvcm1hdGlvblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSByaWdpZGJvZHkgaW4gdGhlIGZvcm0gdGhlIHBoeXNpY3MgZW5naW5lIGlzIHVzaW5nIGl0LCBzaG91bGQgbm90IGJlIHVzZWQgdW5sZXNzIGEgZnVuY3Rpb25hbGl0eVxyXG4gICAgICogaXMgbm90IHByb3ZpZGVkIHRocm91Z2ggdGhlIEZVREdFIEludGVncmF0aW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0T2ltb1JpZ2lkYm9keSgpOiBPSU1PLlJpZ2lkQm9keSB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNyaWdpZGJvZHk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFJvdGF0aW5nIHRoZSByaWdpZGJvZHkgdGhlcmVmb3JlIGNoYW5naW5nIGl0J3Mgcm90YXRpb24gb3ZlciB0aW1lIGRpcmVjdGx5IGluIHBoeXNpY3MuIFRoaXMgd2F5IHBoeXNpY3MgaXMgY2hhbmdpbmcgaW5zdGVhZCBvZiB0cmFuc2Zvcm0uIFxyXG4gICAgICogIEJ1dCB5b3UgYXJlIGFibGUgdG8gaW5jcmVtZW50YWwgY2hhbmdpbmcgaXQgaW5zdGVhZCBvZiBhIGRpcmVjdCByb3RhdGlvbi4gIEFsdGhvdWdoIGl0J3MgYWx3YXlzIHByZWZlcmVkIHRvIHVzZSBmb3JjZXMgaW4gcGh5c2ljcy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJvdGF0ZUJvZHkoX3JvdGF0aW9uQ2hhbmdlOiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5yb3RhdGVYeXoobmV3IE9JTU8uVmVjMyhfcm90YXRpb25DaGFuZ2UueCAqIE1hdGguUEkgLyAxODAsIF9yb3RhdGlvbkNoYW5nZS55ICogTWF0aC5QSSAvIDE4MCwgX3JvdGF0aW9uQ2hhbmdlLnogKiBNYXRoLlBJIC8gMTgwKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFRyYW5zbGF0aW5nIHRoZSByaWdpZGJvZHkgdGhlcmVmb3JlIGNoYW5naW5nIGl0J3MgcGxhY2Ugb3ZlciB0aW1lIGRpcmVjdGx5IGluIHBoeXNpY3MuIFRoaXMgd2F5IHBoeXNpY3MgaXMgY2hhbmdpbmcgaW5zdGVhZCBvZiB0cmFuc2Zvcm0uIFxyXG4gICAgICogIEJ1dCB5b3UgYXJlIGFibGUgdG8gaW5jcmVtZW50YWxseSBjaGFuZ2luZyBpdCBpbnN0ZWFkIG9mIGEgZGlyZWN0IHBvc2l0aW9uLiBBbHRob3VnaCBpdCdzIGFsd2F5cyBwcmVmZXJlZCB0byB1c2UgZm9yY2VzIGluIHBoeXNpY3MuIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdHJhbnNsYXRlQm9keShfdHJhbnNsYXRpb25DaGFuZ2U6IFZlY3RvcjMpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LnRyYW5zbGF0ZShuZXcgT0lNTy5WZWMzKF90cmFuc2xhdGlvbkNoYW5nZS54LCBfdHJhbnNsYXRpb25DaGFuZ2UueSwgX3RyYW5zbGF0aW9uQ2hhbmdlLnopKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgY3VycmVudCBQT1NJVElPTiBvZiB0aGUge0BsaW5rIE5vZGV9IGluIHRoZSBwaHlzaWNhbCBzcGFjZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0UG9zaXRpb24oKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCB0bXBQb3M6IE9JTU8uVmVjMyA9IHRoaXMuI3JpZ2lkYm9keS5nZXRQb3NpdGlvbigpO1xyXG4gICAgICByZXR1cm4gbmV3IFZlY3RvcjModG1wUG9zLngsIHRtcFBvcy55LCB0bXBQb3Mueik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IFBPU0lUSU9OIG9mIHRoZSB7QGxpbmsgTm9kZX0gaW4gdGhlIHBoeXNpY2FsIHNwYWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRQb3NpdGlvbihfdmFsdWU6IFZlY3RvcjMpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LnNldFBvc2l0aW9uKG5ldyBPSU1PLlZlYzMoX3ZhbHVlLngsIF92YWx1ZS55LCBfdmFsdWUueikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBjdXJyZW50IFJPVEFUSU9OIG9mIHRoZSB7QGxpbmsgTm9kZX0gaW4gdGhlIHBoeXNpY2FsIHNwYWNlLiBOb3RlIHRoaXMgcmFuZ2UgZnJvbSAtcGkgdG8gcGksIHNvIC05MCB0byA5MC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFJvdGF0aW9uKCk6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgb3JpZW50YXRpb246IE9JTU8uUXVhdCA9IHRoaXMuI3JpZ2lkYm9keS5nZXRPcmllbnRhdGlvbigpO1xyXG4gICAgICBsZXQgdG1wUXVhdDogUXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKG9yaWVudGF0aW9uLngsIG9yaWVudGF0aW9uLnksIG9yaWVudGF0aW9uLnosIG9yaWVudGF0aW9uLncpO1xyXG4gICAgICByZXR1cm4gdG1wUXVhdC50b0RlZ3JlZXMoKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IFJPVEFUSU9OIG9mIHRoZSB7QGxpbmsgTm9kZX0gaW4gdGhlIHBoeXNpY2FsIHNwYWNlLCBpbiBkZWdyZWUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRSb3RhdGlvbihfdmFsdWU6IFZlY3RvcjMpOiB2b2lkIHtcclxuICAgICAgbGV0IHF1YXQ6IE9JTU8uUXVhdCA9IG5ldyBPSU1PLlF1YXQoKTtcclxuICAgICAgbGV0IG10eFJvdDogTWF0cml4NHg0ID0gTWF0cml4NHg0LklERU5USVRZKCk7XHJcbiAgICAgIG10eFJvdC5yb3RhdGUobmV3IFZlY3RvcjMoX3ZhbHVlLngsIF92YWx1ZS55LCBfdmFsdWUueikpO1xyXG4gICAgICBsZXQgYXJyYXk6IEZsb2F0MzJBcnJheSA9IG10eFJvdC5nZXQoKTtcclxuICAgICAgbGV0IHJvdDogT0lNTy5NYXQzID0gbmV3IE9JTU8uTWF0MyhhcnJheVswXSwgYXJyYXlbNF0sIGFycmF5WzhdLCBhcnJheVsxXSwgYXJyYXlbNV0sIGFycmF5WzldLCBhcnJheVsyXSwgYXJyYXlbNl0sIGFycmF5WzEwXSk7XHJcbiAgICAgIHF1YXQuZnJvbU1hdDMocm90KTtcclxuICAgICAgLy8gcXVhdC5ub3JtYWxpemUoKTtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LnNldE9yaWVudGF0aW9uKHF1YXQpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKiogR2V0IHRoZSBjdXJyZW50IFNDQUxJTkcgaW4gdGhlIHBoeXNpY2FsIHNwYWNlLiAqL1xyXG4gICAgcHVibGljIGdldFNjYWxpbmcoKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCBzY2FsaW5nOiBWZWN0b3IzID0gdGhpcy5ub2RlLm10eFdvcmxkLnNjYWxpbmcuY2xvbmU7XHJcbiAgICAgIHNjYWxpbmcueCAqPSB0aGlzLm10eFBpdm90LnNjYWxpbmcueDtcclxuICAgICAgc2NhbGluZy55ICo9IHRoaXMubXR4UGl2b3Quc2NhbGluZy55O1xyXG4gICAgICBzY2FsaW5nLnogKj0gdGhpcy5tdHhQaXZvdC5zY2FsaW5nLno7XHJcbiAgICAgIHJldHVybiBzY2FsaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBTY2FsaW5nIHJlcXVpcmVzIHRoZSBjb2xsaWRlciB0byBiZSBjb21wbGV0ZWx5IHJlY3JlYXRlZCBhbmV3ICovXHJcbiAgICBwdWJsaWMgc2V0U2NhbGluZyhfdmFsdWU6IFZlY3RvcjMpOiB2b2lkIHtcclxuICAgICAgLy8gbGV0IHNjYWxpbmc6IFZlY3RvcjMgPSBfdmFsdWUuY2xvbmU7ICAgXHJcbiAgICAgIHRoaXMuY3JlYXRlQ29sbGlkZXIobmV3IE9JTU8uVmVjMyhfdmFsdWUueCAvIDIsIF92YWx1ZS55IC8gMiwgX3ZhbHVlLnogLyAyKSwgdGhpcy4jdHlwZUNvbGxpZGVyKTsgLy9yZWNyZWF0ZSB0aGUgY29sbGlkZXJcclxuICAgICAgdGhpcy4jY29sbGlkZXIgPSBuZXcgT0lNTy5TaGFwZSh0aGlzLiNjb2xsaWRlckluZm8pO1xyXG4gICAgICBsZXQgb2xkQ29sbGlkZXI6IE9JTU8uU2hhcGUgPSB0aGlzLiNyaWdpZGJvZHkuZ2V0U2hhcGVMaXN0KCk7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5hZGRTaGFwZSh0aGlzLiNjb2xsaWRlcik7IC8vYWRkIG5ldyBjb2xsaWRlciwgYmVmb3JlIHJlbW92aW5nIHRoZSBvbGQsIHNvIHRoZSByYiBpcyBuZXZlciBhY3RpdmUgd2l0aCAwIGNvbGxpZGVyc1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkucmVtb3ZlU2hhcGUob2xkQ29sbGlkZXIpOyAvL3JlbW92ZSB0aGUgb2xkIGNvbGxpZGVyXHJcbiAgICAgIHRoaXMuI2NvbGxpZGVyLnVzZXJEYXRhID0gdGhpczsgLy9yZXNldCB0aGUgZXh0cmEgaW5mb3JtYXRpb24gc28gdGhhdCB0aGlzIGNvbGxpZGVyIGtub3dzIHRvIHdoaWNoIEZ1ZGdlIENvbXBvbmVudCBpdCdzIGNvbm5lY3RlZFxyXG4gICAgICB0aGlzLiNjb2xsaWRlci5zZXRDb2xsaXNpb25Hcm91cCh0aGlzLmNvbGxpc2lvbkdyb3VwKTtcclxuICAgICAgdGhpcy4jY29sbGlkZXIuc2V0Q29sbGlzaW9uTWFzayh0aGlzLmNvbGxpc2lvbk1hc2spO1xyXG5cclxuICAgICAgdGhpcy4jY29sbGlkZXIuc2V0UmVzdGl0dXRpb24odGhpcy4jcmVzdGl0dXRpb24pO1xyXG4gICAgICB0aGlzLiNjb2xsaWRlci5zZXRGcmljdGlvbih0aGlzLiNmcmljdGlvbik7XHJcbiAgICAgIHRoaXMuI2NvbGxpZGVyLnNldENvbnRhY3RDYWxsYmFjayh0aGlzLiNjYWxsYmFja3MpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIHJpZ2lkYm9keSBhY2NvcmRpbmcgdG8gaXRzIGluaXRpYWxpemF0aW9uIHNldHRpbmcgdG8gbWF0Y2ggdGhlIG1lc2gsIHRoZSBub2RlIG9yIGl0cyBvd24gcGl2b3QgbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpbml0aWFsaXplKCk6IHZvaWQge1xyXG4gICAgICBpZiAoIXRoaXMubm9kZSkgLy8gZGVsYXkgaW5pdGlhbGl6YXRpb24gdW50aWwgdGhpcyByaWdpZGJvZHkgaXMgYXR0YWNoZWQgdG8gYSBub2RlXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBzd2l0Y2ggKHRoaXMuaW5pdGlhbGl6YXRpb24pIHtcclxuICAgICAgICBjYXNlIEJPRFlfSU5JVC5UT19OT0RFOlxyXG4gICAgICAgICAgdGhpcy5tdHhQaXZvdCA9IE1hdHJpeDR4NC5JREVOVElUWSgpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBCT0RZX0lOSVQuVE9fTUVTSDpcclxuICAgICAgICAgIGxldCBjbXBNZXNoOiBDb21wb25lbnRNZXNoID0gdGhpcy5ub2RlLmdldENvbXBvbmVudChDb21wb25lbnRNZXNoKTtcclxuICAgICAgICAgIGlmIChjbXBNZXNoKVxyXG4gICAgICAgICAgICB0aGlzLm10eFBpdm90ID0gY21wTWVzaC5tdHhQaXZvdC5jbG9uZTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQk9EWV9JTklULlRPX1BJVk9UOlxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgbGV0IG10eFdvcmxkOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuTVVMVElQTElDQVRJT04odGhpcy5ub2RlLm10eFdvcmxkLCB0aGlzLm10eFBpdm90KTtcclxuXHJcbiAgICAgIGxldCBwb3NpdGlvbjogVmVjdG9yMyA9IG10eFdvcmxkLnRyYW5zbGF0aW9uOyAvL0FkZGluZyB0aGUgb2Zmc2V0cyBmcm9tIHRoZSBwaXZvdFxyXG4gICAgICBsZXQgcm90YXRpb246IFZlY3RvcjMgPSBtdHhXb3JsZC5nZXRFdWxlckFuZ2xlcygpO1xyXG4gICAgICBsZXQgc2NhbGluZzogVmVjdG9yMyA9IG10eFdvcmxkLnNjYWxpbmc7XHJcbiAgICAgIC8vc2NhbGluZyByZXF1aXJlcyBjb2xsaWRlciB0byBiZSByZWNyZWF0ZWRcclxuICAgICAgdGhpcy5zZXRTY2FsaW5nKHNjYWxpbmcpO1xyXG5cclxuICAgICAgdGhpcy4jcmlnaWRib2R5LnNldE1hc3NEYXRhKHRoaXMuI21hc3NEYXRhKTtcclxuICAgICAgdGhpcy5zZXRQb3NpdGlvbihwb3NpdGlvbik7IC8vc2V0IHRoZSBhY3R1YWwgbmV3IHJvdGF0aW9uL3Bvc2l0aW9uIGZvciB0aGlzIFJiIGFnYWluIHNpbmNlIGl0J3Mgbm93IHVwZGF0ZWRcclxuICAgICAgdGhpcy5zZXRSb3RhdGlvbihyb3RhdGlvbik7XHJcblxyXG4gICAgICB0aGlzLiNtdHhQaXZvdFVuc2NhbGVkID0gTWF0cml4NHg0LkNPTlNUUlVDVElPTih7IHRyYW5zbGF0aW9uOiB0aGlzLm10eFBpdm90LnRyYW5zbGF0aW9uLCByb3RhdGlvbjogdGhpcy5tdHhQaXZvdC5yb3RhdGlvbiwgc2NhbGluZzogVmVjdG9yMy5PTkUoKSB9KTtcclxuICAgICAgdGhpcy4jbXR4UGl2b3RJbnZlcnNlID0gTWF0cml4NHg0LklOVkVSU0lPTih0aGlzLiNtdHhQaXZvdFVuc2NhbGVkKTtcclxuXHJcbiAgICAgIHRoaXMuYWRkUmlnaWRib2R5VG9Xb3JsZCgpO1xyXG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIFZlbG9jaXR5IGFuZCBGb3JjZXNcclxuICAgIC8qKlxyXG4gICAgKiBHZXQgdGhlIGN1cnJlbnQgVkVMT0NJVFkgb2YgdGhlIHtAbGluayBOb2RlfVxyXG4gICAgKi9cclxuICAgIHB1YmxpYyBnZXRWZWxvY2l0eSgpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHZlbG9jaXR5OiBPSU1PLlZlYzMgPSB0aGlzLiNyaWdpZGJvZHkuZ2V0TGluZWFyVmVsb2NpdHkoKTtcclxuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKHZlbG9jaXR5LngsIHZlbG9jaXR5LnksIHZlbG9jaXR5LnopO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGN1cnJlbnQgVkVMT0NJVFkgb2YgdGhlIHtAbGluayBOb2RlfVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0VmVsb2NpdHkoX3ZhbHVlOiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIGxldCB2ZWxvY2l0eTogT0lNTy5WZWMzID0gbmV3IE9JTU8uVmVjMyhfdmFsdWUueCwgX3ZhbHVlLnksIF92YWx1ZS56KTtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LnNldExpbmVhclZlbG9jaXR5KHZlbG9jaXR5KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgY3VycmVudCBBTkdVTEFSIC0gVkVMT0NJVFkgb2YgdGhlIHtAbGluayBOb2RlfVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0QW5ndWxhclZlbG9jaXR5KCk6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgdmVsb2NpdHk6IE9JTU8uVmVjMyA9IHRoaXMuI3JpZ2lkYm9keS5nZXRBbmd1bGFyVmVsb2NpdHkoKTtcclxuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKHZlbG9jaXR5LngsIHZlbG9jaXR5LnksIHZlbG9jaXR5LnopO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGN1cnJlbnQgQU5HVUxBUiAtIFZFTE9DSVRZIG9mIHRoZSB7QGxpbmsgTm9kZX1cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldEFuZ3VsYXJWZWxvY2l0eShfdmFsdWU6IFZlY3RvcjMpOiB2b2lkIHtcclxuICAgICAgbGV0IHZlbG9jaXR5OiBPSU1PLlZlYzMgPSBuZXcgT0lNTy5WZWMzKF92YWx1ZS54LCBfdmFsdWUueSwgX3ZhbHVlLnopO1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuc2V0QW5ndWxhclZlbG9jaXR5KHZlbG9jaXR5KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEFwcGxpZXMgYSBjb250aW5vdXMgRk9SQ0UgYXQgdGhlIGNlbnRlciBvZiB0aGUgUklHSURCT0RZIGluIHRoZSB0aHJlZSBkaW1lbnNpb25zLiBDb25zaWRlcmluZyB0aGUgcmlnaWRib2R5J3MgTUFTUy5cclxuICAgICogVGhlIGZvcmNlIGlzIG1lYXN1cmVkIGluIG5ld3RvbiwgMWtnIG5lZWRzIGFib3V0IDEwIE5ld3RvbiB0byBmaWdodCBhZ2FpbnN0IGdyYXZpdHkuXHJcbiAgICAqL1xyXG4gICAgcHVibGljIGFwcGx5Rm9yY2UoX2ZvcmNlOiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5hcHBseUZvcmNlVG9DZW50ZXIobmV3IE9JTU8uVmVjMyhfZm9yY2UueCwgX2ZvcmNlLnksIF9mb3JjZS56KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEFwcGxpZXMgYSBjb250aW5vdXMgRk9SQ0UgYXQgYSBzcGVjaWZpYyBwb2ludCBpbiB0aGUgd29ybGQgdG8gdGhlIFJJR0lEQk9EWSBpbiB0aGUgdGhyZWUgZGltZW5zaW9ucy4gQ29uc2lkZXJpbmcgdGhlIHJpZ2lkYm9keSdzIE1BU1NcclxuICAgICovXHJcbiAgICBwdWJsaWMgYXBwbHlGb3JjZUF0UG9pbnQoX2ZvcmNlOiBWZWN0b3IzLCBfd29ybGRQb2ludDogVmVjdG9yMyk6IHZvaWQge1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuYXBwbHlGb3JjZShuZXcgT0lNTy5WZWMzKF9mb3JjZS54LCBfZm9yY2UueSwgX2ZvcmNlLnopLCBuZXcgT0lNTy5WZWMzKF93b3JsZFBvaW50LngsIF93b3JsZFBvaW50LnksIF93b3JsZFBvaW50LnopKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogQXBwbGllcyBhIGNvbnRpbm91cyBST1RBVElPTkFMIEZPUkNFIChUb3JxdWUpIHRvIHRoZSBSSUdJREJPRFkgaW4gdGhlIHRocmVlIGRpbWVuc2lvbnMuIENvbnNpZGVyaW5nIHRoZSByaWdpZGJvZHkncyBNQVNTXHJcbiAgICAqL1xyXG4gICAgcHVibGljIGFwcGx5VG9ycXVlKF9yb3RhdGlvbmFsRm9yY2U6IFZlY3RvcjMpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LmFwcGx5VG9ycXVlKG5ldyBPSU1PLlZlYzMoX3JvdGF0aW9uYWxGb3JjZS54LCBfcm90YXRpb25hbEZvcmNlLnksIF9yb3RhdGlvbmFsRm9yY2UueikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBBcHBsaWVzIGEgaW5zdGFudCBGT1JDRSBhdCBhIHBvaW50L3JpZ2lkYm9keWNlbnRlciB0byB0aGUgUklHSURCT0RZIGluIHRoZSB0aHJlZSBkaW1lbnNpb25zLiBDb25zaWRlcmluZyB0aGUgcmlnaWRib2QncyBNQVNTXHJcbiAgICAqIEluZmx1ZW5jaW5nIHRoZSBhbmd1bGFyIHNwZWVkIGFuZCB0aGUgbGluZWFyIHNwZWVkLiBcclxuICAgICovXHJcbiAgICBwdWJsaWMgYXBwbHlJbXB1bHNlQXRQb2ludChfaW1wdWxzZTogVmVjdG9yMywgX3dvcmxkUG9pbnQ6IFZlY3RvcjMgPSBudWxsKTogdm9pZCB7XHJcbiAgICAgIF93b3JsZFBvaW50ID0gX3dvcmxkUG9pbnQgIT0gbnVsbCA/IF93b3JsZFBvaW50IDogdGhpcy5nZXRQb3NpdGlvbigpO1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuYXBwbHlJbXB1bHNlKG5ldyBPSU1PLlZlYzMoX2ltcHVsc2UueCwgX2ltcHVsc2UueSwgX2ltcHVsc2UueiksIG5ldyBPSU1PLlZlYzMoX3dvcmxkUG9pbnQueCwgX3dvcmxkUG9pbnQueSwgX3dvcmxkUG9pbnQueikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBBcHBsaWVzIGEgaW5zdGFudCBGT1JDRSB0byB0aGUgUklHSURCT0RZIGluIHRoZSB0aHJlZSBkaW1lbnNpb25zLiBDb25zaWRlcmluZyB0aGUgcmlnaWRib2R5J3MgTUFTU1xyXG4gICAgKiBPbmx5IGluZmx1ZW5jaW5nIGl0J3Mgc3BlZWQgbm90IHJvdGF0aW9uLlxyXG4gICAgKi9cclxuICAgIHB1YmxpYyBhcHBseUxpbmVhckltcHVsc2UoX2ltcHVsc2U6IFZlY3RvcjMpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LmFwcGx5TGluZWFySW1wdWxzZShuZXcgT0lNTy5WZWMzKF9pbXB1bHNlLngsIF9pbXB1bHNlLnksIF9pbXB1bHNlLnopKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgKiBBcHBsaWVzIGEgaW5zdGFudCBST1RBVElPTkFMLUZPUkNFIHRvIHRoZSBSSUdJREJPRFkgaW4gdGhlIHRocmVlIGRpbWVuc2lvbnMuIENvbnNpZGVyaW5nIHRoZSByaWdpZGJvZHkncyBNQVNTXHJcbiAgICogT25seSBpbmZsdWVuY2luZyBpdCdzIHJvdGF0aW9uLlxyXG4gICAqL1xyXG4gICAgcHVibGljIGFwcGx5QW5ndWxhckltcHVsc2UoX3JvdGF0aW9uYWxJbXB1bHNlOiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5hcHBseUFuZ3VsYXJJbXB1bHNlKG5ldyBPSU1PLlZlYzMoX3JvdGF0aW9uYWxJbXB1bHNlLngsIF9yb3RhdGlvbmFsSW1wdWxzZS55LCBfcm90YXRpb25hbEltcHVsc2UueikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAqIENoYW5naW5nIHRoZSBWRUxPQ0lUWSBvZiB0aGUgUklHSURCT0RZLiBPbmx5IGluZmx1ZW5jaW5nIHRoZSBsaW5lYXIgc3BlZWQgbm90IGFuZ3VsYXJcclxuICAgKi9cclxuICAgIHB1YmxpYyBhZGRWZWxvY2l0eShfdmFsdWU6IFZlY3RvcjMpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LmFkZExpbmVhclZlbG9jaXR5KG5ldyBPSU1PLlZlYzMoX3ZhbHVlLngsIF92YWx1ZS55LCBfdmFsdWUueikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAqIENoYW5naW5nIHRoZSBWRUxPQ0lUWSBvZiB0aGUgUklHSURCT0RZLiBPbmx5IGluZmx1ZW5jaW5nIHRoZSBhbmd1bGFyIHNwZWVkIG5vdCB0aGUgbGluZWFyXHJcbiAgICovXHJcbiAgICBwdWJsaWMgYWRkQW5ndWxhclZlbG9jaXR5KF92YWx1ZTogVmVjdG9yMyk6IHZvaWQge1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuYWRkQW5ndWxhclZlbG9jaXR5KG5ldyBPSU1PLlZlYzMoX3ZhbHVlLngsIF92YWx1ZS55LCBfdmFsdWUueikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBTdG9wcyB0aGUgcmlnaWRib2R5IGZyb20gc2xlZXBpbmcgd2hlbiBtb3ZlbWVudCBpcyB0b28gbWluaW1hbC4gRGVjcmVhc2luZyBwZXJmb3JtYW5jZSwgZm9yIHJhcmVseSBtb3JlIHByZWNpc2UgcGh5c2ljcyByZXN1bHRzICovXHJcbiAgICBwdWJsaWMgZGVhY3RpdmF0ZUF1dG9TbGVlcCgpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LnNldEF1dG9TbGVlcChmYWxzZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFjdGl2YXRlQXV0b1NsZWVwKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuc2V0QXV0b1NsZWVwKHRydWUpO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIENvbGxpc2lvblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja2luZyBmb3IgQ29sbGlzaW9uIHdpdGggb3RoZXIgQ29sbGlkZXJzIGFuZCBkaXNwYXRjaGVzIGEgY3VzdG9tIGV2ZW50IHdpdGggaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNvbGxpZGVyLlxyXG4gICAgICogQXV0b21hdGljYWxseSBjYWxsZWQgaW4gdGhlIFJlbmRlck1hbmFnZXIsIG5vIGludGVyYWN0aW9uIG5lZWRlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGNoZWNrQ29sbGlzaW9uRXZlbnRzKCk6IHZvaWQge1xyXG4gICAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkgLy8gY2hlY2sgY29sbGlzaW9ucyBvbmx5IGlmIGludGlhbGl6YXRpb24gY29tcGxldGVkXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBsZXQgbGlzdDogT0lNTy5Db250YWN0TGluayA9IHRoaXMuI3JpZ2lkYm9keS5nZXRDb250YWN0TGlua0xpc3QoKTsgLy9hbGwgcGh5c2ljYWwgY29udGFjdHMgYmV0d2VlbiBjb2xsaWRpbmcgYm9kaWVzIG9uIHRoaXMgcmJcclxuICAgICAgbGV0IG9iakhpdDogQ29tcG9uZW50UmlnaWRib2R5OyAvL2NvbGxpc2lvbiBjb25zaXN0aW5nIG9mIDIgYm9kaWVzLCBzbyBIaXQxLzJcclxuICAgICAgbGV0IG9iakhpdDI6IENvbXBvbmVudFJpZ2lkYm9keTtcclxuICAgICAgbGV0IGV2ZW50OiBFdmVudFBoeXNpY3M7ICAvL1RoZSBldmVudCB0aGF0IHdpbGwgYmUgc2VuZCBhbmQgdGhlIGluZm9ybWF0aW9ucyBhZGRlZCB0byBpdFxyXG4gICAgICBsZXQgbm9ybWFsSW1wdWxzZTogbnVtYmVyID0gMDtcclxuICAgICAgbGV0IGJpbm9ybWFsSW1wdWxzZTogbnVtYmVyID0gMDtcclxuICAgICAgbGV0IHRhbmdlbnRJbXB1bHNlOiBudW1iZXIgPSAwO1xyXG4gICAgICBsZXQgY29sUG9pbnQ6IFZlY3RvcjM7XHJcbiAgICAgIC8vQUREIE5FVyBDb2xsaXNpb24gLSBUaGF0IGp1c3QgaGFwcGVuZWRcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMuI3JpZ2lkYm9keS5nZXROdW1Db250YWN0TGlua3MoKTsgaSsrKSB7XHJcbiAgICAgICAgbGV0IGNvbGxpc2lvbk1hbmlmb2xkOiBPSU1PLk1hbmlmb2xkID0gbGlzdC5nZXRDb250YWN0KCkuZ2V0TWFuaWZvbGQoKTsgLy9NYW5pZm9sZCA9IEFkZGl0aW9uYWwgaW5mb3JtYXRpb25zIGFib3V0IHRoZSBjb250YWN0XHJcbiAgICAgICAgb2JqSGl0ID0gbGlzdC5nZXRDb250YWN0KCkuZ2V0U2hhcGUxKCkudXNlckRhdGE7ICAvL1VzZXJkYXRhIGlzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIMaSLkNvbXBvbmVudFJpZ2lkYm9keSwgaXQncyBhbiBlbXB0eSBPaW1vUGh5c2ljcyBWYXJpYWJsZVxyXG4gICAgICAgIC8vT25seSByZWdpc3RlciB0aGUgY29sbGlzaW9uIG9uIHRoZSBhY3R1YWwgdG91Y2gsIG5vdCBvbiBcInNoYWRvd0NvbGxpZGVcIiwgdG8gcmVnaXN0ZXIgaW4gdGhlIG1vbWVudCBvZiBpbXB1bHNlIGNhbGN1bGF0aW9uXHJcbiAgICAgICAgaWYgKCFvYmpIaXQuaXNJbml0aWFsaXplZClcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIGlmIChvYmpIaXQgPT0gbnVsbCB8fCBsaXN0LmdldENvbnRhY3QoKS5pc1RvdWNoaW5nKCkgPT0gZmFsc2UpIC8vIG9ubHkgYWN0IGlmIHRoZSBjb2xsaXNpb24gaXMgYWN0dWFsIHRvdWNoaW5nLCBzbyByaWdodCBhdCB0aGUgbW9tZW50IHdoZW4gYSBpbXB1bHNlIGlzIGhhcHBlbmluZywgbm90IHdoZW4gc2hhcGVzIG92ZXJsYXBcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBvYmpIaXQyID0gbGlzdC5nZXRDb250YWN0KCkuZ2V0U2hhcGUyKCkudXNlckRhdGE7XHJcbiAgICAgICAgaWYgKCFvYmpIaXQyLmlzSW5pdGlhbGl6ZWQpXHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICBpZiAob2JqSGl0MiA9PSBudWxsIHx8IGxpc3QuZ2V0Q29udGFjdCgpLmlzVG91Y2hpbmcoKSA9PSBmYWxzZSlcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBsZXQgcG9pbnRzOiBPSU1PLk1hbmlmb2xkUG9pbnRbXSA9IGNvbGxpc2lvbk1hbmlmb2xkLmdldFBvaW50cygpOyAvL0FsbCBwb2ludHMgaW4gdGhlIGNvbGxpc2lvbiB3aGVyZSB0aGUgdHdvIGJvZGllcyBhcmUgdG91Y2hpbmcsIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBmdWxsIGltcGFjdFxyXG4gICAgICAgIGxldCBub3JtYWw6IE9JTU8uVmVjMyA9IGNvbGxpc2lvbk1hbmlmb2xkLmdldE5vcm1hbCgpO1xyXG4gICAgICAgIGlmIChvYmpIaXQuZ2V0T2ltb1JpZ2lkYm9keSgpICE9IHRoaXMuZ2V0T2ltb1JpZ2lkYm9keSgpICYmIHRoaXMuY29sbGlzaW9ucy5pbmRleE9mKG9iakhpdCkgPT0gLTEpIHsgLy9GaXJlLCBpZiB0aGUgaGl0IG9iamVjdCBpcyBub3QgdGhlIEJvZHkgaXRzZWxmIGJ1dCBhbm90aGVyIGFuZCBpdCdzIG5vdCBhbHJlYWR5IGZpcmVkLlxyXG4gICAgICAgICAgbGV0IGNvbFBvczogT0lNTy5WZWMzID0gdGhpcy5jb2xsaXNpb25DZW50ZXJQb2ludChwb2ludHMsIGNvbGxpc2lvbk1hbmlmb2xkLmdldE51bVBvaW50cygpKTsgLy9USEUgcG9pbnQgb2YgY29sbGlzaW9uIGlzIHRoZSBmaXJzdCB0b3VjaGluZyBwb2ludCAoRVhURU5TSU9OOiBjb3VsZCBiZSB0aGUgY2VudGVyIG9mIGFsbCB0b3VjaGluZyBwb2ludHMgY29tYmluZWQpXHJcbiAgICAgICAgICBjb2xQb2ludCA9IG5ldyBWZWN0b3IzKGNvbFBvcy54LCBjb2xQb3MueSwgY29sUG9zLnopO1xyXG4gICAgICAgICAgcG9pbnRzLmZvckVhY2goKHZhbHVlOiBPSU1PLk1hbmlmb2xkUG9pbnQpOiB2b2lkID0+IHsgLy9UaGUgaW1wYWN0IG9mIHRoZSBjb2xsaXNpb24gaW52b2x2aW5nIGFsbCB0b3VjaGluZyBwb2ludHNcclxuICAgICAgICAgICAgbm9ybWFsSW1wdWxzZSArPSB2YWx1ZS5nZXROb3JtYWxJbXB1bHNlKCk7XHJcbiAgICAgICAgICAgIGJpbm9ybWFsSW1wdWxzZSArPSB2YWx1ZS5nZXRCaW5vcm1hbEltcHVsc2UoKTtcclxuICAgICAgICAgICAgdGFuZ2VudEltcHVsc2UgKz0gdmFsdWUuZ2V0VGFuZ2VudEltcHVsc2UoKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgdGhpcy5jb2xsaXNpb25zLnB1c2gob2JqSGl0KTsgLy9UZWxsIHRoZSBvYmplY3QgdGhhdCB0aGUgZXZlbnQgZm9yIHRoaXMgb2JqZWN0IGRvZXMgbm90IG5lZWQgdG8gYmUgZmlyZWQgYWdhaW5cclxuICAgICAgICAgIGV2ZW50ID0gbmV3IEV2ZW50UGh5c2ljcyhFVkVOVF9QSFlTSUNTLkNPTExJU0lPTl9FTlRFUiwgb2JqSGl0LCBub3JtYWxJbXB1bHNlLCB0YW5nZW50SW1wdWxzZSwgYmlub3JtYWxJbXB1bHNlLCBjb2xQb2ludCwgbmV3IFZlY3RvcjMobm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueikpOyAvL0J1aWxkaW5nIHRoZSBhY3R1YWwgZXZlbnQsIHdpdGggd2hhdCBvYmplY3QgZGlkIGNvbGxpZGUgYW5kIGluZm9ybWF0aW9ucyBhYm91dCBpdFxyXG4gICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTsgLy9TZW5kaW5nIHRoZSBnaXZlbiBldmVudFxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob2JqSGl0MiAhPSB0aGlzICYmIHRoaXMuY29sbGlzaW9ucy5pbmRleE9mKG9iakhpdDIpID09IC0xKSB7IC8vU2FtZSBhcyB0aGUgYWJvdmUgYnV0IGZvciB0aGUgY2FzZSB0aGUgU0VDT05EIGhpdCBvYmplY3QgaXMgbm90IHRoZSBib2R5IGl0c2VsZlxyXG4gICAgICAgICAgbGV0IGNvbFBvczogT0lNTy5WZWMzID0gdGhpcy5jb2xsaXNpb25DZW50ZXJQb2ludChwb2ludHMsIGNvbGxpc2lvbk1hbmlmb2xkLmdldE51bVBvaW50cygpKTtcclxuICAgICAgICAgIGNvbFBvaW50ID0gbmV3IFZlY3RvcjMoY29sUG9zLngsIGNvbFBvcy55LCBjb2xQb3Mueik7XHJcbiAgICAgICAgICBwb2ludHMuZm9yRWFjaCgodmFsdWU6IE9JTU8uTWFuaWZvbGRQb2ludCk6IHZvaWQgPT4ge1xyXG4gICAgICAgICAgICBub3JtYWxJbXB1bHNlICs9IHZhbHVlLmdldE5vcm1hbEltcHVsc2UoKTtcclxuICAgICAgICAgICAgYmlub3JtYWxJbXB1bHNlICs9IHZhbHVlLmdldEJpbm9ybWFsSW1wdWxzZSgpO1xyXG4gICAgICAgICAgICB0YW5nZW50SW1wdWxzZSArPSB2YWx1ZS5nZXRUYW5nZW50SW1wdWxzZSgpO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgdGhpcy5jb2xsaXNpb25zLnB1c2gob2JqSGl0Mik7XHJcbiAgICAgICAgICBldmVudCA9IG5ldyBFdmVudFBoeXNpY3MoRVZFTlRfUEhZU0lDUy5DT0xMSVNJT05fRU5URVIsIG9iakhpdDIsIG5vcm1hbEltcHVsc2UsIHRhbmdlbnRJbXB1bHNlLCBiaW5vcm1hbEltcHVsc2UsIGNvbFBvaW50LCBuZXcgVmVjdG9yMyhub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56KSk7XHJcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsaXN0ID0gbGlzdC5nZXROZXh0KCk7IC8vU3RhcnQgdGhlIHNhbWUgcm91dGluZSB3aXRoIHRoZSBuZXh0IGNvbGxpc2lvbiBpbiB0aGUgbGlzdFxyXG4gICAgICB9XHJcbiAgICAgIC8vUkVNT1ZFIE9MRCBDb2xsaXNpb25zIC0gVGhhdCBkbyBub3QgaGFwcGVuIGFueW1vcmVcclxuICAgICAgdGhpcy5jb2xsaXNpb25zLmZvckVhY2goKHZhbHVlOiBDb21wb25lbnRSaWdpZGJvZHkpID0+IHsgLy9FdmVyeSBDb2xsaWRlciBpbiB0aGUgbGlzdCBpcyBjaGVja2VkIGlmIHRoZSBjb2xsaXNpb24gaXMgc3RpbGwgaGFwcGVuaW5nXHJcbiAgICAgICAgbGV0IGlzQ29sbGlkaW5nOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICAgICAgbGlzdCA9IHRoaXMuI3JpZ2lkYm9keS5nZXRDb250YWN0TGlua0xpc3QoKTtcclxuICAgICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy4jcmlnaWRib2R5LmdldE51bUNvbnRhY3RMaW5rcygpOyBpKyspIHtcclxuICAgICAgICAgIG9iakhpdCA9IGxpc3QuZ2V0Q29udGFjdCgpLmdldFNoYXBlMSgpLnVzZXJEYXRhO1xyXG4gICAgICAgICAgb2JqSGl0MiA9IGxpc3QuZ2V0Q29udGFjdCgpLmdldFNoYXBlMigpLnVzZXJEYXRhO1xyXG4gICAgICAgICAgaWYgKHZhbHVlID09IG9iakhpdCB8fCB2YWx1ZSA9PSBvYmpIaXQyKSB7IC8vSWYgdGhlIGdpdmVuIG9iamVjdCBpbiB0aGUgY29sbGlzaW9ucyBsaXN0IGlzIHN0aWxsIG9uZSBvZiB0aGUgb2JqSGl0IHRoZSBjb2xsaXNpb24gaXMgbm90IENvbGxpc2lvbkVYSVRcclxuICAgICAgICAgICAgaXNDb2xsaWRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbGlzdCA9IGxpc3QuZ2V0TmV4dCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNDb2xsaWRpbmcgPT0gZmFsc2UpIHsgLy9UaGUgY29sbGlzaW9uIGlzIGV4aXRpbmcgYnV0IHdhcyBpbiB0aGUgY29sbGlzaW9uIGxpc3QsIHRoZW4gRVhJVCBFdmVudCBuZWVkcyB0byBiZSBmaXJlZFxyXG4gICAgICAgICAgbGV0IGluZGV4OiBudW1iZXIgPSB0aGlzLmNvbGxpc2lvbnMuaW5kZXhPZih2YWx1ZSk7IC8vRmluZCBvYmplY3QgaW4gdGhlIGFycmF5XHJcbiAgICAgICAgICB0aGlzLmNvbGxpc2lvbnMuc3BsaWNlKGluZGV4KTsgLy9yZW1vdmUgaXQgZnJvbSB0aGUgYXJyYXlcclxuICAgICAgICAgIGV2ZW50ID0gbmV3IEV2ZW50UGh5c2ljcyhFVkVOVF9QSFlTSUNTLkNPTExJU0lPTl9FWElULCB2YWx1ZSwgMCwgMCwgMCk7XHJcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZW5kcyBhIHJheSB0aHJvdWdoIHRoaXMgc3BlY2lmaWMgYm9keSBpZ25vcmluZyB0aGUgcmVzdCBvZiB0aGUgd29ybGQgYW5kIGNoZWNrcyBpZiB0aGlzIGJvZHkgd2FzIGhpdCBieSB0aGUgcmF5LFxyXG4gICAgICogcmV0dXJuaW5nIGluZm8gYWJvdXQgdGhlIGhpdC4gUHJvdmlkZXMgdGhlIHNhbWUgZnVuY3Rpb25hbGl0eSBhbmQgaW5mb3JtYXRpb24gYSByZWd1bGFyIHJheWNhc3QgZG9lcyBidXQgdGhlIHJheSBpcyBvbmx5IHRlc3RpbmcgYWdhaW5zdCB0aGlzIHNwZWNpZmljIGJvZHkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByYXljYXN0VGhpc0JvZHkoX29yaWdpbjogVmVjdG9yMywgX2RpcmVjdGlvbjogVmVjdG9yMywgX2xlbmd0aDogbnVtYmVyLCBfZGVidWdEcmF3OiBib29sZWFuID0gZmFsc2UpOiBSYXlIaXRJbmZvIHtcclxuICAgICAgbGV0IGhpdEluZm86IFJheUhpdEluZm8gPSBuZXcgUmF5SGl0SW5mbygpO1xyXG4gICAgICBsZXQgZ2VvbWV0cnk6IE9JTU8uR2VvbWV0cnkgPSB0aGlzLiNyaWdpZGJvZHkuZ2V0U2hhcGVMaXN0KCkuZ2V0R2VvbWV0cnkoKTtcclxuICAgICAgbGV0IHRyYW5zZm9ybTogT0lNTy5UcmFuc2Zvcm0gPSB0aGlzLiNyaWdpZGJvZHkuZ2V0VHJhbnNmb3JtKCk7XHJcbiAgICAgIGxldCBzY2FsZWREaXJlY3Rpb246IFZlY3RvcjMgPSBfZGlyZWN0aW9uLmNsb25lO1xyXG4gICAgICBzY2FsZWREaXJlY3Rpb24uc2NhbGUoX2xlbmd0aCk7XHJcbiAgICAgIGxldCBlbmRwb2ludDogVmVjdG9yMyA9IFZlY3RvcjMuU1VNKHNjYWxlZERpcmVjdGlvbiwgX29yaWdpbi5jbG9uZSk7XHJcbiAgICAgIGxldCBvaW1vUmF5OiBPSU1PLlJheUNhc3RIaXQgPSBuZXcgT0lNTy5SYXlDYXN0SGl0KCk7XHJcbiAgICAgIGxldCBoaXQ6IGJvb2xlYW4gPSBnZW9tZXRyeS5yYXlDYXN0KG5ldyBPSU1PLlZlYzMoX29yaWdpbi54LCBfb3JpZ2luLnksIF9vcmlnaW4ueiksIG5ldyBPSU1PLlZlYzMoZW5kcG9pbnQueCwgZW5kcG9pbnQueSwgZW5kcG9pbnQueiksIHRyYW5zZm9ybSwgb2ltb1JheSk7IC8vdGhlIGFjdHVhbCBPaW1vUGh5c2ljcyBSYXljYXN0XHJcbiAgICAgIGlmIChoaXQpIHsgIC8vSWYgaGl0IHJldHVybiBhIGJ1bmNoIG9mIGluZm9ybWF0aW9ucyBhYm91dCB0aGUgaGl0XHJcbiAgICAgICAgaGl0SW5mby5oaXQgPSB0cnVlO1xyXG4gICAgICAgIGhpdEluZm8uaGl0UG9pbnQgPSBuZXcgVmVjdG9yMyhvaW1vUmF5LnBvc2l0aW9uLngsIG9pbW9SYXkucG9zaXRpb24ueSwgb2ltb1JheS5wb3NpdGlvbi56KTtcclxuICAgICAgICBoaXRJbmZvLmhpdE5vcm1hbCA9IG5ldyBWZWN0b3IzKG9pbW9SYXkubm9ybWFsLngsIG9pbW9SYXkubm9ybWFsLnksIG9pbW9SYXkubm9ybWFsLnopO1xyXG4gICAgICAgIGxldCBkeDogbnVtYmVyID0gX29yaWdpbi54IC0gaGl0SW5mby5oaXRQb2ludC54OyAgLy9jYWxjdWxhdGUgaGl0IGRpc3RhbmNlXHJcbiAgICAgICAgbGV0IGR5OiBudW1iZXIgPSBfb3JpZ2luLnkgLSBoaXRJbmZvLmhpdFBvaW50Lnk7XHJcbiAgICAgICAgbGV0IGR6OiBudW1iZXIgPSBfb3JpZ2luLnogLSBoaXRJbmZvLmhpdFBvaW50Lno7XHJcbiAgICAgICAgaGl0SW5mby5oaXREaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSArIGR6ICogZHopO1xyXG4gICAgICAgIGhpdEluZm8ucmlnaWRib2R5Q29tcG9uZW50ID0gdGhpcztcclxuICAgICAgICBoaXRJbmZvLnJheU9yaWdpbiA9IF9vcmlnaW47XHJcbiAgICAgICAgaGl0SW5mby5yYXlFbmQgPSBlbmRwb2ludDtcclxuICAgICAgfSBlbHNlIHsgLy9Pbmx5IHRlbGwgdGhlIG9yaWdpbiwgYW5kIHRoZSBoaXQgcG9pbnQgaXMgdGhlIGVuZCBvZiB0aGUgcmF5LlxyXG4gICAgICAgIGhpdEluZm8ucmF5T3JpZ2luID0gX29yaWdpbjtcclxuICAgICAgICBoaXRJbmZvLmhpdFBvaW50ID0gbmV3IFZlY3RvcjMoZW5kcG9pbnQueCwgZW5kcG9pbnQueSwgZW5kcG9pbnQueik7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKF9kZWJ1Z0RyYXcpIHtcclxuICAgICAgICBQaHlzaWNzLmRlYnVnRHJhdy5kZWJ1Z1JheShoaXRJbmZvLnJheU9yaWdpbiwgaGl0SW5mby5oaXRQb2ludCwgbmV3IENvbG9yKDAsIDEsIDAsIDEpKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gaGl0SW5mbztcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuXHJcbiAgICAvLyNyZWdpb24gU2F2aW5nL0xvYWRpbmcgLSBTb21lIHByb3BlcnRpZXMgbWlnaHQgYmUgbWlzc2luZywgZS5nLiBjb252ZXhNZXNoIChGbG9hdDMyQXJyYXkpXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHRoaXMuZ2V0TXV0YXRvcigpO1xyXG5cclxuICAgICAgZGVsZXRlIHNlcmlhbGl6YXRpb24ubXR4UGl2b3Q7XHJcbiAgICAgIGRlbGV0ZSBzZXJpYWxpemF0aW9uLmFjdGl2ZTtcclxuXHJcbiAgICAgIHNlcmlhbGl6YXRpb24udHlwZUJvZHkgPSBCT0RZX1RZUEVbdGhpcy4jdHlwZUJvZHldO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnR5cGVDb2xsaWRlciA9IENPTExJREVSX1RZUEVbdGhpcy4jdHlwZUNvbGxpZGVyXTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5pbml0aWFsaXphdGlvbiA9IEJPRFlfSU5JVFt0aGlzLmluaXRpYWxpemF0aW9uXTtcclxuXHJcbiAgICAgIHNlcmlhbGl6YXRpb24uaWQgPSB0aGlzLiNpZDtcclxuICAgICAgc2VyaWFsaXphdGlvbi5waXZvdCA9IHRoaXMubXR4UGl2b3Quc2VyaWFsaXplKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xyXG4gICAgICB0aGlzLm10eFBpdm90LmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLnBpdm90KTtcclxuICAgICAgdGhpcy4jaWQgPSBfc2VyaWFsaXphdGlvbi5pZDtcclxuICAgICAgdGhpcy5tYXNzID0gaWZOdW1iZXIoX3NlcmlhbGl6YXRpb24ubWFzcywgdGhpcy5tYXNzKTtcclxuICAgICAgdGhpcy5kYW1wVHJhbnNsYXRpb24gPSBpZk51bWJlcihfc2VyaWFsaXphdGlvbi5kYW1wVHJhbnNsYXRpb24sIHRoaXMuZGFtcFRyYW5zbGF0aW9uKTtcclxuICAgICAgdGhpcy5kYW1wUm90YXRpb24gPSBpZk51bWJlcihfc2VyaWFsaXphdGlvbi5kYW1wUm90YXRpb24sIHRoaXMuZGFtcFJvdGF0aW9uKTtcclxuICAgICAgdGhpcy5jb2xsaXNpb25Hcm91cCA9IGlmTnVtYmVyKF9zZXJpYWxpemF0aW9uLmNvbGxpc2lvbkdyb3VwLCB0aGlzLmNvbGxpc2lvbkdyb3VwKTtcclxuICAgICAgdGhpcy5lZmZlY3RSb3RhdGlvbiA9IF9zZXJpYWxpemF0aW9uLmVmZmVjdFJvdGF0aW9uIHx8IHRoaXMuZWZmZWN0Um90YXRpb247XHJcbiAgICAgIHRoaXMuZWZmZWN0R3Jhdml0eSA9IGlmTnVtYmVyKF9zZXJpYWxpemF0aW9uLmVmZmVjdEdyYXZpdHksIHRoaXMuZWZmZWN0R3Jhdml0eSk7XHJcbiAgICAgIHRoaXMuZnJpY3Rpb24gPSBpZk51bWJlcihfc2VyaWFsaXphdGlvbi5mcmljdGlvbiwgdGhpcy5mcmljdGlvbik7XHJcbiAgICAgIHRoaXMucmVzdGl0dXRpb24gPSBpZk51bWJlcihfc2VyaWFsaXphdGlvbi5yZXN0aXR1dGlvbiwgdGhpcy5yZXN0aXR1dGlvbik7XHJcbiAgICAgIHRoaXMuaXNUcmlnZ2VyID0gX3NlcmlhbGl6YXRpb24uaXNUcmlnZ2VyIHx8IHRoaXMuaXNUcmlnZ2VyO1xyXG4gICAgICB0aGlzLmluaXRpYWxpemF0aW9uID0gX3NlcmlhbGl6YXRpb24uaW5pdGlhbGl6YXRpb247XHJcblxyXG4gICAgICB0aGlzLmluaXRpYWxpemF0aW9uID0gPG51bWJlcj48dW5rbm93bj5CT0RZX0lOSVRbX3NlcmlhbGl6YXRpb24uaW5pdGlhbGl6YXRpb25dO1xyXG4gICAgICB0aGlzLnR5cGVCb2R5ID0gPG51bWJlcj48dW5rbm93bj5CT0RZX1RZUEVbX3NlcmlhbGl6YXRpb24udHlwZUJvZHldO1xyXG4gICAgICB0aGlzLnR5cGVDb2xsaWRlciA9IDxudW1iZXI+PHVua25vd24+Q09MTElERVJfVFlQRVtfc2VyaWFsaXphdGlvbi50eXBlQ29sbGlkZXJdO1xyXG4gICAgICAvLyB0aGlzLmNyZWF0ZSh0aGlzLm1hc3MsIHRoaXMuI3R5cGVCb2R5LCB0aGlzLiN0eXBlQ29sbGlkZXIsIHRoaXMuY29sbGlzaW9uR3JvdXAsIG51bGwsIHRoaXMuY29udmV4TWVzaCk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBDaGFuZ2UgcHJvcGVydGllcyBieSBhbiBhc3NvY2lhdGl2ZSBhcnJheSAqL1xyXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBzdXBlci5tdXRhdGUoX211dGF0b3IpO1xyXG5cclxuICAgICAgbGV0IGNhbGxJZkV4aXN0OiBGdW5jdGlvbiA9IChfa2V5OiBzdHJpbmcsIF9zZXR0ZXI6IEZ1bmN0aW9uKSA9PiB7XHJcbiAgICAgICAgaWYgKF9tdXRhdG9yW19rZXldKVxyXG4gICAgICAgICAgX3NldHRlcihfbXV0YXRvcltfa2V5XSk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjYWxsSWZFeGlzdChcImZyaWN0aW9uXCIsIChfdmFsdWU6IG51bWJlcikgPT4gdGhpcy5mcmljdGlvbiA9IF92YWx1ZSk7XHJcbiAgICAgIGNhbGxJZkV4aXN0KFwicmVzdGl0dXRpb25cIiwgKF92YWx1ZTogbnVtYmVyKSA9PiB0aGlzLnJlc3RpdHV0aW9uID0gX3ZhbHVlKTtcclxuICAgICAgY2FsbElmRXhpc3QoXCJtYXNzXCIsIChfdmFsdWU6IG51bWJlcikgPT4gdGhpcy5tYXNzID0gX3ZhbHVlKTtcclxuICAgICAgY2FsbElmRXhpc3QoXCJkYW1wVHJhbnNsYXRpb25cIiwgKF92YWx1ZTogbnVtYmVyKSA9PiB0aGlzLmRhbXBUcmFuc2xhdGlvbiA9IF92YWx1ZSk7XHJcbiAgICAgIGNhbGxJZkV4aXN0KFwiZGFtcFJvdGF0aW9uXCIsIChfdmFsdWU6IG51bWJlcikgPT4gdGhpcy5kYW1wUm90YXRpb24gPSBfdmFsdWUpO1xyXG4gICAgICBjYWxsSWZFeGlzdChcImVmZmVjdEdyYXZpdHlcIiwgKF92YWx1ZTogbnVtYmVyKSA9PiB0aGlzLmVmZmVjdEdyYXZpdHkgPSBfdmFsdWUpO1xyXG4gICAgICBjYWxsSWZFeGlzdChcImNvbGxpc2lvbkdyb3VwXCIsIChfdmFsdWU6IENPTExJU0lPTl9HUk9VUCkgPT4gdGhpcy5jb2xsaXNpb25Hcm91cCA9IF92YWx1ZSk7XHJcbiAgICAgIGNhbGxJZkV4aXN0KFwidHlwZUJvZHlcIiwgKF92YWx1ZTogc3RyaW5nKSA9PiB0aGlzLnR5cGVCb2R5ID0gcGFyc2VJbnQoX3ZhbHVlKSk7XHJcbiAgICAgIGNhbGxJZkV4aXN0KFwidHlwZUNvbGxpZGVyXCIsIChfdmFsdWU6IHN0cmluZykgPT4gdGhpcy50eXBlQ29sbGlkZXIgPSBwYXJzZUludChfdmFsdWUpKTtcclxuXHJcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuTVVUQVRFKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0gc3VwZXIuZ2V0TXV0YXRvcih0cnVlKTtcclxuXHJcbiAgICAgIG11dGF0b3IuZnJpY3Rpb24gPSB0aGlzLmZyaWN0aW9uO1xyXG4gICAgICBtdXRhdG9yLnJlc3RpdHV0aW9uID0gdGhpcy5yZXN0aXR1dGlvbjtcclxuICAgICAgbXV0YXRvci5tYXNzID0gdGhpcy5tYXNzO1xyXG4gICAgICBtdXRhdG9yLmRhbXBUcmFuc2xhdGlvbiA9IHRoaXMuZGFtcFRyYW5zbGF0aW9uO1xyXG4gICAgICBtdXRhdG9yLmRhbXBSb3RhdGlvbiA9IHRoaXMuZGFtcFJvdGF0aW9uO1xyXG4gICAgICBtdXRhdG9yLmVmZmVjdEdyYXZpdHkgPSB0aGlzLmVmZmVjdEdyYXZpdHk7XHJcbiAgICAgIG11dGF0b3IudHlwZUJvZHkgPSB0aGlzLiN0eXBlQm9keTtcclxuICAgICAgbXV0YXRvci50eXBlQ29sbGlkZXIgPSB0aGlzLiN0eXBlQ29sbGlkZXI7XHJcbiAgICAgIG11dGF0b3IuaXNUcmlnZ2VyID0gdGhpcy4jaXNUcmlnZ2VyO1xyXG5cclxuICAgICAgLy8gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKG11dGF0b3IpO1xyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvckF0dHJpYnV0ZVR5cGVzKF9tdXRhdG9yOiBNdXRhdG9yKTogTXV0YXRvckF0dHJpYnV0ZVR5cGVzIHtcclxuICAgICAgbGV0IHR5cGVzOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMgPSBzdXBlci5nZXRNdXRhdG9yQXR0cmlidXRlVHlwZXMoX211dGF0b3IpO1xyXG4gICAgICBpZiAodHlwZXMudHlwZUJvZHkpXHJcbiAgICAgICAgdHlwZXMudHlwZUJvZHkgPSBCT0RZX1RZUEU7XHJcbiAgICAgIGlmICh0eXBlcy50eXBlQ29sbGlkZXIpXHJcbiAgICAgICAgdHlwZXMudHlwZUNvbGxpZGVyID0gQ09MTElERVJfVFlQRTtcclxuICAgICAgaWYgKHR5cGVzLmluaXRpYWxpemF0aW9uKVxyXG4gICAgICAgIHR5cGVzLmluaXRpYWxpemF0aW9uID0gQk9EWV9JTklUO1xyXG4gICAgICByZXR1cm4gdHlwZXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgc3VwZXIucmVkdWNlTXV0YXRvcihfbXV0YXRvcik7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5jb252ZXhNZXNoOyAvL0NvbnZleCBNZXNoIGNhbid0IGJlIHNob3duIGluIHRoZSBlZGl0b3IgYmVjYXVzZSBmbG9hdDMyQXJyYXkgaXMgbm90IGEgdmlhYmxlIG11dGF0b3JcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLmNvbGxpc2lvbk1hc2s7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5pc0luaXRpYWxpemVkO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIENyZWF0aW9uXHJcbiAgICBwcml2YXRlIGNyZWF0ZShfbWFzczogbnVtYmVyID0gMSwgX3R5cGU6IEJPRFlfVFlQRSA9IEJPRFlfVFlQRS5EWU5BTUlDLCBfY29sbGlkZXJUeXBlOiBDT0xMSURFUl9UWVBFID0gQ09MTElERVJfVFlQRS5DVUJFLCBfZ3JvdXA6IENPTExJU0lPTl9HUk9VUCA9IFBoeXNpY3Muc2V0dGluZ3MuZGVmYXVsdENvbGxpc2lvbkdyb3VwLCBfbXR4VHJhbnNmb3JtOiBNYXRyaXg0eDQgPSBudWxsLCBfY29udmV4TWVzaDogRmxvYXQzMkFycmF5ID0gbnVsbCk6IHZvaWQge1xyXG4gICAgICAvL1NldHRpbmcgdXAgYWxsIGluY29taW5nIHZhbHVlcyB0byBiZSBpbnRlcm5hbCB2YWx1ZXNcclxuICAgICAgdGhpcy5jb252ZXhNZXNoID0gX2NvbnZleE1lc2g7XHJcbiAgICAgIHRoaXMuI3R5cGVCb2R5ID0gX3R5cGU7XHJcbiAgICAgIHRoaXMuI2NvbGxpc2lvbkdyb3VwID0gX2dyb3VwO1xyXG4gICAgICB0aGlzLiN0eXBlQ29sbGlkZXIgPSBfY29sbGlkZXJUeXBlO1xyXG4gICAgICB0aGlzLm1hc3MgPSBfbWFzcztcclxuICAgICAgdGhpcy4jcmVzdGl0dXRpb24gPSBQaHlzaWNzLnNldHRpbmdzLmRlZmF1bHRSZXN0aXR1dGlvbjtcclxuICAgICAgdGhpcy4jZnJpY3Rpb24gPSBQaHlzaWNzLnNldHRpbmdzLmRlZmF1bHRGcmljdGlvbjtcclxuICAgICAgdGhpcy5jb2xsaXNpb25NYXNrID0gUGh5c2ljcy5zZXR0aW5ncy5kZWZhdWx0Q29sbGlzaW9uTWFzaztcclxuICAgICAgLy9DcmVhdGUgdGhlIGFjdHVhbCByaWdpZGJvZHkgaW4gdGhlIE9pbW9QaHlzaWNzIFNwYWNlXHJcbiAgICAgIHRoaXMuY3JlYXRlUmlnaWRib2R5KF9tYXNzLCBfdHlwZSwgdGhpcy4jdHlwZUNvbGxpZGVyLCBfbXR4VHJhbnNmb3JtLCB0aGlzLiNjb2xsaXNpb25Hcm91cCk7XHJcbiAgICAgIHRoaXMuI2lkID0gUGh5c2ljcy5kaXN0cmlidXRlQm9keUlEKCk7XHJcblxyXG4gICAgICAvLyBFdmVudCBDYWxsYmFja3MgZGlyZWN0bHkgZnJvbSBPSU1PIFBoeXNpY3NcclxuICAgICAgdGhpcy4jY2FsbGJhY2tzID0gbmV3IE9JTU8uQ29udGFjdENhbGxiYWNrKCk7IC8vZmVobVxyXG4gICAgICB0aGlzLiNjYWxsYmFja3MuYmVnaW5UcmlnZ2VyQ29udGFjdCA9IHRoaXMudHJpZ2dlckVudGVyO1xyXG4gICAgICB0aGlzLiNjYWxsYmFja3MuZW5kVHJpZ2dlckNvbnRhY3QgPSB0aGlzLnRyaWdnZXJFeGl0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBDcmVhdGVzIHRoZSBhY3R1YWwgT2ltb1BoeXNpY3MgUmlnaWRib2R5IG91dCBvZiBpbmZvcm1hdGlvbnMgdGhlIEZ1ZGdlIENvbXBvbmVudCBoYXMuICovXHJcbiAgICBwcml2YXRlIGNyZWF0ZVJpZ2lkYm9keShfbWFzczogbnVtYmVyLCBfdHlwZTogQk9EWV9UWVBFLCBfY29sbGlkZXJUeXBlOiBDT0xMSURFUl9UWVBFLCBfbXR4VHJhbnNmb3JtOiBNYXRyaXg0eDQsIF9jb2xsaXNpb25Hcm91cDogQ09MTElTSU9OX0dST1VQID0gQ09MTElTSU9OX0dST1VQLkRFRkFVTFQpOiB2b2lkIHtcclxuICAgICAgbGV0IG9pbW9UeXBlOiBudW1iZXI7IC8vTmVlZCB0aGUgY29udmVyc2lvbiBmcm9tIHNpbXBsZSBlbnVtIHRvIG51bWJlciBiZWNhdXNlIGlmIGVudW0gaXMgZGVmaW5lZCBhcyBPaW1vLlJpZ2lkeUJvZHlUeXBlIHlvdSBoYXZlIHRvIGluY2x1ZGUgT2ltbyB0byB1c2UgRlVER0UgYXQgYWxsXHJcbiAgICAgIHN3aXRjaCAoX3R5cGUpIHtcclxuICAgICAgICBjYXNlIEJPRFlfVFlQRS5EWU5BTUlDOlxyXG4gICAgICAgICAgb2ltb1R5cGUgPSBPSU1PLlJpZ2lkQm9keVR5cGUuRFlOQU1JQztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQk9EWV9UWVBFLlNUQVRJQzpcclxuICAgICAgICAgIG9pbW9UeXBlID0gT0lNTy5SaWdpZEJvZHlUeXBlLlNUQVRJQztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQk9EWV9UWVBFLktJTkVNQVRJQzpcclxuICAgICAgICAgIG9pbW9UeXBlID0gT0lNTy5SaWdpZEJvZHlUeXBlLktJTkVNQVRJQztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBvaW1vVHlwZSA9IE9JTU8uUmlnaWRCb2R5VHlwZS5EWU5BTUlDO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHJlbW92ZSBhbGwgcHJldmlvdXMgc2hhcGVzIGZyb20gd29ybGQuIE5lY2Vzc2FyeT9cclxuICAgICAgLy8gd2hpbGUgKHRoaXMuI3JpZ2lkYm9keSAmJiB0aGlzLiNyaWdpZGJvZHkuZ2V0U2hhcGVMaXN0KCkgIT0gbnVsbClcclxuICAgICAgLy8gICB0aGlzLiNyaWdpZGJvZHkucmVtb3ZlU2hhcGUodGhpcy4jcmlnaWRib2R5LmdldFNoYXBlTGlzdCgpKTtcclxuXHJcbiAgICAgIGxldCB0bXBUcmFuc2Zvcm06IE1hdHJpeDR4NCA9IF9tdHhUcmFuc2Zvcm0gPT0gbnVsbCA/IHN1cGVyLm5vZGUgIT0gbnVsbCA/IHN1cGVyLm5vZGUubXR4V29ybGQgOiBNYXRyaXg0eDQuSURFTlRJVFkoKSA6IF9tdHhUcmFuc2Zvcm07IC8vR2V0IHRyYW5zZm9ybSBpbmZvcm1hdGlvbnMgZnJvbSB0aGUgd29ybGQsIHNpbmNlIHBoeXNpY3MgZG9lcyBub3QgY2FyZSBhYm91dCBoaWVyYXJjaHlcclxuICAgICAgLy9Db252ZXJ0IGluZm9ybWF0aW9ucyBmcm9tIEZ1ZGdlIHRvIE9pbW9QaHlzaWNzIGFuZCBjcmVhdGluZyBhIGNvbGxpZGVyIHdpdGggaXQsIHdoaWxlIGFsc28gYWRkaW5nIGEgcGl2b3QgdG8gZGVyaXZhdGUgZnJvbSB0aGUgdHJhbnNmb3JtIGluZm9ybWF0aW9ucyBpZiBuZWVkZWRcclxuICAgICAgbGV0IHNjYWxlOiBPSU1PLlZlYzMgPSBuZXcgT0lNTy5WZWMzKCh0bXBUcmFuc2Zvcm0uc2NhbGluZy54ICogdGhpcy5tdHhQaXZvdC5zY2FsaW5nLngpIC8gMiwgKHRtcFRyYW5zZm9ybS5zY2FsaW5nLnkgKiB0aGlzLm10eFBpdm90LnNjYWxpbmcueSkgLyAyLCAodG1wVHJhbnNmb3JtLnNjYWxpbmcueiAqIHRoaXMubXR4UGl2b3Quc2NhbGluZy56KSAvIDIpO1xyXG4gICAgICBsZXQgcG9zaXRpb246IE9JTU8uVmVjMyA9IG5ldyBPSU1PLlZlYzModG1wVHJhbnNmb3JtLnRyYW5zbGF0aW9uLnggKyB0aGlzLm10eFBpdm90LnRyYW5zbGF0aW9uLngsIHRtcFRyYW5zZm9ybS50cmFuc2xhdGlvbi55ICsgdGhpcy5tdHhQaXZvdC50cmFuc2xhdGlvbi55LCB0bXBUcmFuc2Zvcm0udHJhbnNsYXRpb24ueiArIHRoaXMubXR4UGl2b3QudHJhbnNsYXRpb24ueik7XHJcbiAgICAgIGxldCByb3RhdGlvbjogT0lNTy5WZWMzID0gbmV3IE9JTU8uVmVjMyh0bXBUcmFuc2Zvcm0ucm90YXRpb24ueCArIHRoaXMubXR4UGl2b3Qucm90YXRpb24ueCwgdG1wVHJhbnNmb3JtLnJvdGF0aW9uLnkgKyB0aGlzLm10eFBpdm90LnJvdGF0aW9uLnksIHRtcFRyYW5zZm9ybS5yb3RhdGlvbi56ICsgdGhpcy5tdHhQaXZvdC5yb3RhdGlvbi56KTtcclxuICAgICAgdGhpcy5jcmVhdGVDb2xsaWRlcihzY2FsZSwgX2NvbGxpZGVyVHlwZSk7XHJcbiAgICAgIC8vU2V0dGluZyBpbmZvcm1hdGlvbnMgYWJvdXQgbWFzcywgcG9zaXRpb24vcm90YXRpb24gYW5kIHBoeXNpY2FsIHJlYWN0aW9uIHR5cGVcclxuICAgICAgdGhpcy4jbWFzc0RhdGEubWFzcyA9IF9tYXNzOyAvL190eXBlICE9IFBIWVNJQ1NfVFlQRS5TVEFUSUMgPyBfbWFzcyA6IDA7IC8vSWYgYSBvYmplY3QgaXMgc3RhdGljIGl0IGFjdHMgYXMgaWYgaXQgaGFzIG5vIG1hc3NcclxuICAgICAgdGhpcy4jcmlnaWRib2R5SW5mby50eXBlID0gb2ltb1R5cGU7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keUluZm8ucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5SW5mby5yb3RhdGlvbi5mcm9tRXVsZXJYeXoobmV3IE9JTU8uVmVjMyhyb3RhdGlvbi54LCByb3RhdGlvbi55LCByb3RhdGlvbi56KSk7IC8vQ29udmVydCBldWxlckFuZ2xlcyBpbiBkZWdyZWUgdG8gdGhlIGludGVybmFsbHkgdXNlZCBxdWF0ZXJuaW9uc1xyXG4gICAgICAvL0NyZWF0aW5nIHRoZSBhY3R1YWwgcmlnaWRib2R5IGFuZCBpdCdzIGNvbGxpZGVyXHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keSA9IG5ldyBPSU1PLlJpZ2lkQm9keSh0aGlzLiNyaWdpZGJvZHlJbmZvKTtcclxuICAgICAgdGhpcy4jY29sbGlkZXIgPSBuZXcgT0lNTy5TaGFwZSh0aGlzLiNjb2xsaWRlckluZm8pO1xyXG4gICAgICAvL0ZpbGxpbmcgdGhlIGFkZGl0aW9uYWwgc2V0dGluZ3MgYW5kIGluZm9ybWF0aW9ucyB0aGUgcmlnaWRib2R5IG5lZWRzLiBXaG8gaXMgY29sbGlkaW5nLCBob3cgaXMgdGhlIGNvbGxpc2lvbiBoYW5kbGVkIChkYW1waW5nLCBpbmZsdWVuY2UgZmFjdG9ycylcclxuICAgICAgdGhpcy4jY29sbGlkZXIudXNlckRhdGEgPSB0aGlzO1xyXG4gICAgICB0aGlzLiNjb2xsaWRlci5zZXRDb2xsaXNpb25Hcm91cChfY29sbGlzaW9uR3JvdXApO1xyXG4gICAgICB0aGlzLiNjb2xsaWRlci5zZXRDb2xsaXNpb25NYXNrKHRoaXMuY29sbGlzaW9uTWFzayk7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5hZGRTaGFwZSh0aGlzLiNjb2xsaWRlcik7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5zZXRNYXNzRGF0YSh0aGlzLiNtYXNzRGF0YSk7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5nZXRTaGFwZUxpc3QoKS5zZXRSZXN0aXR1dGlvbih0aGlzLiNyZXN0aXR1dGlvbik7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5nZXRTaGFwZUxpc3QoKS5zZXRGcmljdGlvbih0aGlzLiNmcmljdGlvbik7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5nZXRTaGFwZUxpc3QoKS5zZXRDb250YWN0Q2FsbGJhY2sodGhpcy4jY2FsbGJhY2tzKTtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LnNldExpbmVhckRhbXBpbmcodGhpcy4jZGFtcGluZ0xpbmVhcik7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5zZXRBbmd1bGFyRGFtcGluZyh0aGlzLiNkYW1waW5nQW5ndWxhcik7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5zZXRHcmF2aXR5U2NhbGUodGhpcy4jZWZmZWN0R3Jhdml0eSk7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5zZXRSb3RhdGlvbkZhY3RvcihuZXcgT0lNTy5WZWMzKHRoaXMuI2VmZmVjdFJvdGF0aW9uLngsIHRoaXMuI2VmZmVjdFJvdGF0aW9uLnksIHRoaXMuI2VmZmVjdFJvdGF0aW9uLnopKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQ3JlYXRlcyBhIGNvbGxpZGVyIGEgc2hhcGUgdGhhdCByZXByZXNlbnRzIHRoZSBvYmplY3QgaW4gdGhlIHBoeXNpY2FsIHdvcmxkLiAgKi9cclxuICAgIHByaXZhdGUgY3JlYXRlQ29sbGlkZXIoX3NjYWxlOiBPSU1PLlZlYzMsIF9jb2xsaWRlclR5cGU6IENPTExJREVSX1RZUEUpOiB2b2lkIHtcclxuICAgICAgbGV0IHNoYXBlQ29uZjogT0lNTy5TaGFwZUNvbmZpZyA9IG5ldyBPSU1PLlNoYXBlQ29uZmlnKCk7IC8vQ29sbGlkZXIgd2l0aCBnZW9tZXRyeSBhbmQgaW5mb3MgbGlrZSBmcmljdGlvbi9yZXN0aXR1dGlvbiBhbmQgbW9yZVxyXG4gICAgICBsZXQgZ2VvbWV0cnk6IE9JTU8uR2VvbWV0cnk7XHJcbiAgICAgIGlmICh0aGlzLnR5cGVDb2xsaWRlciAhPSBfY29sbGlkZXJUeXBlKSAvL0lmIHRoZSBjb2xsaWRlciB0eXBlIHdhcyBjaGFuZ2VkIHNldCB0aGUgaW50ZXJuYWwgb25lIG5ldywgZWxzZSBkb24ndCBzbyB0aGVyZSBpcyBub3QgaW5maW5pdGUgc2V0IGNhbGxzXHJcbiAgICAgICAgdGhpcy50eXBlQ29sbGlkZXIgPSBfY29sbGlkZXJUeXBlO1xyXG4gICAgICBzd2l0Y2ggKF9jb2xsaWRlclR5cGUpIHsgIC8vQ3JlYXRlIGEgZGlmZmVyZW50IE9pbW9QaHlzaWNzIGdlb21ldHJ5IGJhc2VkIG9uIHRoZSBnaXZlbiB0eXBlLiBUaGF0IGlzIG9ubHkgdGhlIG1hdGhlbWF0aWNhbCBzaGFwZSBvZiB0aGUgY29sbGlkZXJcclxuICAgICAgICBjYXNlIENPTExJREVSX1RZUEUuQ1VCRTpcclxuICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IE9JTU8uQm94R2VvbWV0cnkoX3NjYWxlKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQ09MTElERVJfVFlQRS5TUEhFUkU6XHJcbiAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBPSU1PLlNwaGVyZUdlb21ldHJ5KF9zY2FsZS54KTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQ09MTElERVJfVFlQRS5DQVBTVUxFOlxyXG4gICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgT0lNTy5DYXBzdWxlR2VvbWV0cnkoX3NjYWxlLngsIF9zY2FsZS55KTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQ09MTElERVJfVFlQRS5DWUxJTkRFUjpcclxuICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IE9JTU8uQ3lsaW5kZXJHZW9tZXRyeShfc2NhbGUueCwgX3NjYWxlLnkpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBDT0xMSURFUl9UWVBFLkNPTkU6XHJcbiAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBPSU1PLkNvbmVHZW9tZXRyeShfc2NhbGUueCwgX3NjYWxlLnkpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBDT0xMSURFUl9UWVBFLlBZUkFNSUQ6XHJcbiAgICAgICAgICBnZW9tZXRyeSA9IHRoaXMuY3JlYXRlQ29udmV4R2VvbWV0cnlDb2xsaWRlcih0aGlzLmNyZWF0ZVB5cmFtaWRWZXJ0aWNlcygpLCBfc2NhbGUpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBDT0xMSURFUl9UWVBFLkNPTlZFWDpcclxuICAgICAgICAgIGdlb21ldHJ5ID0gdGhpcy5jcmVhdGVDb252ZXhHZW9tZXRyeUNvbGxpZGVyKHRoaXMuY29udmV4TWVzaCwgX3NjYWxlKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIHNoYXBlQ29uZi5nZW9tZXRyeSA9IGdlb21ldHJ5O1xyXG4gICAgICB0aGlzLiNjb2xsaWRlckluZm8gPSBzaGFwZUNvbmY7IC8vdGhlIGNvbmZpZ3VyYXRpb24gaW5mb3JtYXRpb25zIHRoYXQgYXJlIHVzZWQgdG8gYWRkIGFuIGFjdHVhbCBjb2xsaWRlciB0byB0aGUgcmlnaWRib2R5IGluIGNyZWF0ZVJpZ2lkYm9keVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBDcmVhdGluZyBhIHNoYXBlIHRoYXQgcmVwcmVzZW50cyBhIGluIGl0c2VsZiBjbG9zZWQgZm9ybSwgb3V0IG9mIHRoZSBnaXZlbiB2ZXJ0aWNlcy4gKi9cclxuICAgIHByaXZhdGUgY3JlYXRlQ29udmV4R2VvbWV0cnlDb2xsaWRlcihfdmVydGljZXM6IEZsb2F0MzJBcnJheSwgX3NjYWxlOiBPSU1PLlZlYzMpOiBPSU1PLkNvbnZleEh1bGxHZW9tZXRyeSB7XHJcbiAgICAgIGxldCB2ZXJ0aWNlc0FzVmVjMzogT0lNTy5WZWMzW10gPSBuZXcgQXJyYXkoKTsgLy9Db252ZXJ0IEZ1ZGdlIFZlY3RvcjMgdG8gT2ltb1ZlYzNcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IF92ZXJ0aWNlcy5sZW5ndGg7IGkgKz0gMykgeyAvLzMgVmFsdWVzIGZvciBvbmUgcG9pbnRcclxuICAgICAgICB2ZXJ0aWNlc0FzVmVjMy5wdXNoKG5ldyBPSU1PLlZlYzMoX3ZlcnRpY2VzW2ldICogX3NjYWxlLngsIF92ZXJ0aWNlc1tpICsgMV0gKiBfc2NhbGUueSwgX3ZlcnRpY2VzW2kgKyAyXSAqIF9zY2FsZS56KSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG5ldyBPSU1PLkNvbnZleEh1bGxHZW9tZXRyeSh2ZXJ0aWNlc0FzVmVjMyk7IC8vVGVsbCBPaW1vUGh5c2ljcyB0byBjcmVhdGUgYSBodWxsIHRoYXQgaW52b2x2ZXMgYWxsIHBvaW50cyBidXQgY2xvc2UgaXQgb2YuIEEgY29udmV4IHNoYXBlIGNhbiBub3QgaGF2ZSBhIGhvbGUgaW4gaXQuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEludGVybmFsIGltcGxlbWVudGF0aW9uIG9mIHZlcnRpY2VzIHRoYXQgY29uc3RydWN0IGEgcHlyYW1pZC4gVGhlIHZlcnRpY2VzIG9mIHRoZSBpbXBsZW1lbnRlZCBweXJhbWlkIG1lc2ggY2FuIGJlIHVzZWQgdG9vLiBCdXQgdGhleSBhcmUgaGFsZmVkIGFuZCBkb3VibGUgc2lkZWQsIHNvIGl0J3MgbW9yZSBwZXJmb3JtYW50IHRvIHVzZSB0aGlzLiAqL1xyXG4gICAgcHJpdmF0ZSBjcmVhdGVQeXJhbWlkVmVydGljZXMoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgbGV0IHZlcnRpY2VzOiBGbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KFtcclxuICAgICAgICAvKjAqLy0xLCAwLCAxLCAvKjEqLyAxLCAwLCAxLCAgLyoyKi8gMSwgMCwgLTEsIC8qMyovIC0xLCAwLCAtMSxcclxuICAgICAgICAvKjQqLyAwLCAyLCAwXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gdmVydGljZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEFkZGluZyB0aGlzIENvbXBvbmVudFJpZ2lkYm9keSB0byB0aGUgUGh5c2lzY3Mud29ybGQgZ2l2aW5nIHRoZSBvaW1vUGh5c2ljcyBzeXN0ZW0gdGhlIGluZm9ybWF0aW9uIG5lZWRlZCAqL1xyXG4gICAgcHJpdmF0ZSBhZGRSaWdpZGJvZHlUb1dvcmxkID0gKCk6IHZvaWQgPT4ge1xyXG4gICAgICBpZiAoIXRoaXMuI3JpZ2lkYm9keS5fd29ybGQpXHJcbiAgICAgICAgUGh5c2ljcy5hZGRSaWdpZGJvZHkodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFJlbW92aW5nIHRoaXMgQ29tcG9uZW50UmlnaWRib2R5IGZyb20gdGhlIFBoeXNpc2NzLndvcmxkIHRha2luZyB0aGUgaW5mb3JtYXRpb25zIGZyb20gdGhlIG9pbW9QaHlzaWNzIHN5c3RlbSAqL1xyXG4gICAgcHJpdmF0ZSByZW1vdmVSaWdpZGJvZHlGcm9tV29ybGQgPSAoKTogdm9pZCA9PiB7XHJcbiAgICAgIFBoeXNpY3MucmVtb3ZlUmlnaWRib2R5KHRoaXMpO1xyXG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8jcmVnaW9uIHByaXZhdGUgRVZFTlQgZnVuY3Rpb25zXHJcbiAgICAvL0NhbGN1bGF0aW5nIHRoZSBjZW50ZXIgb2YgYSBjb2xsaXNpb24gYXMgYSBzaW5ndWxhciBwb2ludCAtIGluIGNhc2UgdGhlcmUgaXMgbW9yZSB0aGFuIG9uZSBwb2ludCAtIGJ5IGdldHRpbmcgdGhlIGdlb21ldHJpY2FsIGNlbnRlciBvZiBhbGwgY29sbGlkaW5nIHBvaW50c1xyXG4gICAgcHJpdmF0ZSBjb2xsaXNpb25DZW50ZXJQb2ludChfY29sUG9pbnRzOiBPSU1PLk1hbmlmb2xkUG9pbnRbXSwgX251bVBvaW50czogbnVtYmVyKTogT0lNTy5WZWMzIHtcclxuICAgICAgbGV0IGNlbnRlcjogT0lNTy5WZWMzO1xyXG4gICAgICBsZXQgdG90YWxQb2ludHM6IG51bWJlciA9IDA7XHJcbiAgICAgIGxldCB0b3RhbFg6IG51bWJlciA9IDA7XHJcbiAgICAgIGxldCB0b3RhbFk6IG51bWJlciA9IDA7XHJcbiAgICAgIGxldCB0b3RhbFo6IG51bWJlciA9IDA7XHJcbiAgICAgIF9jb2xQb2ludHMuZm9yRWFjaCgodmFsdWU6IE9JTU8uTWFuaWZvbGRQb2ludCk6IHZvaWQgPT4ge1xyXG4gICAgICAgIGlmICh0b3RhbFBvaW50cyA8IF9udW1Qb2ludHMpIHtcclxuICAgICAgICAgIHRvdGFsUG9pbnRzKys7XHJcbiAgICAgICAgICB0b3RhbFggKz0gdmFsdWUuZ2V0UG9zaXRpb24yKCkueDtcclxuICAgICAgICAgIHRvdGFsWSArPSB2YWx1ZS5nZXRQb3NpdGlvbjIoKS55O1xyXG4gICAgICAgICAgdG90YWxaICs9IHZhbHVlLmdldFBvc2l0aW9uMigpLno7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgY2VudGVyID0gbmV3IE9JTU8uVmVjMyh0b3RhbFggLyBfbnVtUG9pbnRzLCB0b3RhbFkgLyBfbnVtUG9pbnRzLCB0b3RhbFogLyBfbnVtUG9pbnRzKTtcclxuICAgICAgcmV0dXJuIGNlbnRlcjtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICogVHJpZ2dlciBFbnRlcmluZ0V2ZW50IENhbGxiYWNrLCBhdXRvbWF0aWNhbGx5IGNhbGxlZCBieSBPSU1PIFBoeXNpY3Mgd2l0aGluIHRoZWlyIGNhbGN1bGF0aW9ucy5cclxuICAgICogU2luY2UgdGhlIGV2ZW50IGRvZXMgbm90IGtub3cgd2hpY2ggYm9keSBpcyB0aGUgdHJpZ2dlciBpbmlhdG9yLCB0aGUgZXZlbnQgY2FuIGJlIGxpc3RlbmVkIHRvXHJcbiAgICAqIG9uIGVpdGhlciB0aGUgdHJpZ2dlciBvciB0aGUgdHJpZ2dlcmVkLiAoVGhpcyBpcyBvbmx5IHBvc3NpYmxlIHdpdGggdGhlIEZ1ZGdlIE9JTU8gRm9yayEpXHJcbiAgICAqL1xyXG4gICAgcHJpdmF0ZSB0cmlnZ2VyRW50ZXIoY29udGFjdDogT0lNTy5Db250YWN0KTogdm9pZCB7XHJcbiAgICAgIGxldCBvYmpIaXQ6IENvbXBvbmVudFJpZ2lkYm9keTsgLy9jb2xsaXNpb24gY29uc2lzdGluZyBvZiAyIGJvZGllcywgc28gSGl0MS8yXHJcbiAgICAgIGxldCBvYmpIaXQyOiBDb21wb25lbnRSaWdpZGJvZHk7XHJcbiAgICAgIGxldCBldmVudDogRXZlbnRQaHlzaWNzOyAgLy9UaGUgZXZlbnQgdGhhdCB3aWxsIGJlIHNlbmQgYW5kIHRoZSBpbmZvcm1hdGlvbnMgYWRkZWQgdG8gaXRcclxuICAgICAgbGV0IGNvbFBvaW50OiBWZWN0b3IzO1xyXG5cclxuICAgICAgLy9BREQgTkVXIFRyaWdnZXJpbmcgLSBUaGF0IGp1c3QgaGFwcGVuZWRcclxuICAgICAgbGV0IGNvbGxpc2lvbk1hbmlmb2xkOiBPSU1PLk1hbmlmb2xkID0gY29udGFjdC5nZXRNYW5pZm9sZCgpOyAvL01hbmlmb2xkID0gQWRkaXRpb25hbCBpbmZvcm1hdGlvbnMgYWJvdXQgdGhlIGNvbnRhY3RcclxuICAgICAgb2JqSGl0ID0gY29udGFjdC5nZXRTaGFwZTEoKS51c2VyRGF0YTsgIC8vVXNlcmRhdGEgaXMgdXNlZCB0byB0cmFuc2ZlciB0aGUgxpIuQ29tcG9uZW50UmlnaWRib2R5LCBpdCdzIGFuIGVtcHR5IE9pbW9QaHlzaWNzIFZhcmlhYmxlXHJcbiAgICAgIC8vT25seSByZWdpc3RlciB0aGUgY29sbGlzaW9uIG9uIHRoZSBhY3R1YWwgdG91Y2gsIG5vdCBvbiBcInNoYWRvd0NvbGxpZGVcIiwgdG8gcmVnaXN0ZXIgaW4gdGhlIG1vbWVudCBvZiBpbXB1bHNlIGNhbGN1bGF0aW9uXHJcbiAgICAgIGlmIChvYmpIaXQgPT0gbnVsbCB8fCBjb250YWN0LmlzVG91Y2hpbmcoKSA9PSBmYWxzZSkgLy8gb25seSBhY3QgaWYgdGhlIGNvbGxpc2lvbiBpcyBhY3R1YWwgdG91Y2hpbmcsIHNvIHJpZ2h0IGF0IHRoZSBtb21lbnQgd2hlbiBhIGltcHVsc2UgaXMgaGFwcGVuaW5nLCBub3Qgd2hlbiBzaGFwZXMgb3ZlcmxhcFxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgb2JqSGl0MiA9IGNvbnRhY3QuZ2V0U2hhcGUyKCkudXNlckRhdGE7XHJcbiAgICAgIGlmIChvYmpIaXQyID09IG51bGwgfHwgY29udGFjdC5pc1RvdWNoaW5nKCkgPT0gZmFsc2UpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBsZXQgcG9pbnRzOiBPSU1PLk1hbmlmb2xkUG9pbnRbXSA9IGNvbGxpc2lvbk1hbmlmb2xkLmdldFBvaW50cygpOyAvL0FsbCBwb2ludHMgaW4gdGhlIGNvbGxpc2lvbiB3aGVyZSB0aGUgdHdvIGJvZGllcyBhcmUgdG91Y2hpbmcsIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBmdWxsIGltcGFjdFxyXG4gICAgICBsZXQgbm9ybWFsOiBPSU1PLlZlYzMgPSBjb2xsaXNpb25NYW5pZm9sZC5nZXROb3JtYWwoKTtcclxuICAgICAgaWYgKG9iakhpdDIudHJpZ2dlcmluZ3MuaW5kZXhPZihvYmpIaXQpID09IC0xKSB7IC8vRmlyZSwgaWYgdGhlIGhpdCBvYmplY3QgaXMgbm90IHRoZSBCb2R5IGl0c2VsZiBidXQgYW5vdGhlciBhbmQgaXQncyBub3QgYWxyZWFkeSBmaXJlZC5cclxuICAgICAgICBsZXQgY29sUG9zOiBPSU1PLlZlYzMgPSBvYmpIaXQyLmNvbGxpc2lvbkNlbnRlclBvaW50KHBvaW50cywgY29sbGlzaW9uTWFuaWZvbGQuZ2V0TnVtUG9pbnRzKCkpOyAvL1RIRSBwb2ludCBvZiBjb2xsaXNpb24gaXMgdGhlIGZpcnN0IHRvdWNoaW5nIHBvaW50IChFWFRFTlNJT046IGNvdWxkIGJlIHRoZSBjZW50ZXIgb2YgYWxsIHRvdWNoaW5nIHBvaW50cyBjb21iaW5lZClcclxuICAgICAgICBjb2xQb2ludCA9IG5ldyBWZWN0b3IzKGNvbFBvcy54LCBjb2xQb3MueSwgY29sUG9zLnopO1xyXG4gICAgICAgIC8vIEltcHVsc2VzIGFyZSAwIHNpbmNlLCB0aGVyZSBhcmUgbm8gZm9yY2VzL2ltcHVsc2VzIGF0IHdvcmssIGVsc2UgdGhpcyB3b3VsZCBub3QgYmUgYSB0cmlnZ2VyLCBidXQgYSBjb2xsaXNpb25cclxuICAgICAgICBvYmpIaXQyLnRyaWdnZXJpbmdzLnB1c2gob2JqSGl0KTsgLy9UZWxsIHRoZSBvYmplY3QgdGhhdCB0aGUgZXZlbnQgZm9yIHRoaXMgb2JqZWN0IGRvZXMgbm90IG5lZWQgdG8gYmUgZmlyZWQgYWdhaW5cclxuICAgICAgICBldmVudCA9IG5ldyBFdmVudFBoeXNpY3MoRVZFTlRfUEhZU0lDUy5UUklHR0VSX0VOVEVSLCBvYmpIaXQsIDAsIDAsIDAsIGNvbFBvaW50LCBuZXcgVmVjdG9yMyhub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56KSk7IC8vQnVpbGRpbmcgdGhlIGFjdHVhbCBldmVudCwgd2l0aCB3aGF0IG9iamVjdCBkaWQgY29sbGlkZSBhbmQgaW5mb3JtYXRpb25zIGFib3V0IGl0XHJcbiAgICAgICAgb2JqSGl0Mi5kaXNwYXRjaEV2ZW50KGV2ZW50KTsgLy9TZW5kaW5nIHRoZSBnaXZlbiBldmVudFxyXG4gICAgICB9XHJcbiAgICAgIGlmIChvYmpIaXQudHJpZ2dlcmluZ3MuaW5kZXhPZihvYmpIaXQyKSA9PSAtMSkgeyAvL1NhbWUgYXMgdGhlIGFib3ZlIGJ1dCBmb3IgdGhlIGNhc2UgdGhlIFNFQ09ORCBoaXQgb2JqZWN0IGlzIG5vdCB0aGUgYm9keSBpdHNlbGZcclxuICAgICAgICBsZXQgY29sUG9zOiBPSU1PLlZlYzMgPSBvYmpIaXQuY29sbGlzaW9uQ2VudGVyUG9pbnQocG9pbnRzLCBjb2xsaXNpb25NYW5pZm9sZC5nZXROdW1Qb2ludHMoKSk7XHJcbiAgICAgICAgY29sUG9pbnQgPSBuZXcgVmVjdG9yMyhjb2xQb3MueCwgY29sUG9zLnksIGNvbFBvcy56KTtcclxuICAgICAgICAvLyBJbXB1bHNlcyBhcmUgMCBzaW5jZSwgdGhlcmUgYXJlIG5vIGZvcmNlcy9pbXB1bHNlcyBhdCB3b3JrLCBlbHNlIHRoaXMgd291bGQgbm90IGJlIGEgdHJpZ2dlciwgYnV0IGEgY29sbGlzaW9uLFxyXG4gICAgICAgIC8vIGFsc28gdGhlIGV2ZW50IGlzIGhhbmRsZWQgYmVmb3JlIHRoZSBhY3R1YWwgc29sdmluZyBpbXB1bHNlIHN0ZXAgaW4gT0lNT1xyXG4gICAgICAgIG9iakhpdC50cmlnZ2VyaW5ncy5wdXNoKG9iakhpdDIpO1xyXG4gICAgICAgIGV2ZW50ID0gbmV3IEV2ZW50UGh5c2ljcyhFVkVOVF9QSFlTSUNTLlRSSUdHRVJfRU5URVIsIG9iakhpdDIsIDAsIDAsIDAsIGNvbFBvaW50LCBuZXcgVmVjdG9yMyhub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56KSk7XHJcbiAgICAgICAgb2JqSGl0LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFRyaWdnZXIgTGVhdmluZ0V2ZW50IENhbGxiYWNrLCBhdXRvbWF0aWNhbGx5IGNhbGxlZCBieSBPSU1PIFBoeXNpY3Mgd2l0aGluIHRoZWlyIGNhbGN1bGF0aW9ucy5cclxuICAgICogU2luY2UgdGhlIGV2ZW50IGRvZXMgbm90IGtub3cgd2hpY2ggYm9keSBpcyB0aGUgdHJpZ2dlciBpbmlhdG9yLCB0aGUgZXZlbnQgY2FuIGJlIGxpc3RlbmVkIHRvXHJcbiAgICAqIG9uIGVpdGhlciB0aGUgdHJpZ2dlciBvciB0aGUgdHJpZ2dlcmVkLiAoVGhpcyBpcyBvbmx5IHBvc3NpYmxlIHdpdGggdGhlIEZ1ZGdlIE9JTU8gRm9yayEpXHJcbiAgICAqL1xyXG4gICAgcHJpdmF0ZSB0cmlnZ2VyRXhpdChjb250YWN0OiBPSU1PLkNvbnRhY3QpOiB2b2lkIHtcclxuICAgICAgLy9SRU1PVkUgT0xEIFRyaWdnZXJpbmcgQm9keVxyXG4gICAgICBsZXQgb2JqSGl0OiBDb21wb25lbnRSaWdpZGJvZHk7IC8vY29sbGlzaW9uIGNvbnNpc3Rpbmcgb2YgMiBib2RpZXMsIHNvIEhpdDEvMlxyXG4gICAgICBsZXQgb2JqSGl0MjogQ29tcG9uZW50UmlnaWRib2R5O1xyXG4gICAgICBsZXQgZXZlbnQ6IEV2ZW50UGh5c2ljczsgIC8vVGhlIGV2ZW50IHRoYXQgd2lsbCBiZSBzZW5kIGFuZCB0aGUgaW5mb3JtYXRpb25zIGFkZGVkIHRvIGl0XHJcbiAgICAgIG9iakhpdCA9IGNvbnRhY3QuZ2V0U2hhcGUxKCkudXNlckRhdGE7XHJcbiAgICAgIG9iakhpdDIgPSBjb250YWN0LmdldFNoYXBlMigpLnVzZXJEYXRhO1xyXG5cclxuICAgICAgLy8gUmVtb3ZlIGJvdGggYm9kaWVzIGluIGJvdGggY2FzZXMsIG9mIHNlbGYgYW5kIG90aGVyXHJcbiAgICAgIGxldCBpbmRleDogbnVtYmVyID0gb2JqSGl0LnRyaWdnZXJpbmdzLmluZGV4T2Yob2JqSGl0Mik7IC8vRmluZCBvYmplY3QgaW4gdGhlIGFycmF5XHJcbiAgICAgIGlmIChpbmRleCAhPSAtMSkge1xyXG4gICAgICAgIG9iakhpdC50cmlnZ2VyaW5ncy5zcGxpY2UoaW5kZXgpOyAvL3JlbW92ZSBpdCBmcm9tIHRoZSBhcnJheVxyXG4gICAgICAgIGV2ZW50ID0gbmV3IEV2ZW50UGh5c2ljcyhFVkVOVF9QSFlTSUNTLlRSSUdHRVJfRVhJVCwgb2JqSGl0MiwgMCwgMCwgMCk7XHJcbiAgICAgICAgb2JqSGl0LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgICB9XHJcbiAgICAgIGluZGV4ID0gb2JqSGl0Mi50cmlnZ2VyaW5ncy5pbmRleE9mKG9iakhpdCk7IC8vRmluZCBvYmplY3QgaW4gdGhlIGFycmF5XHJcbiAgICAgIGlmIChpbmRleCAhPSAtMSkge1xyXG4gICAgICAgIG9iakhpdDIudHJpZ2dlcmluZ3Muc3BsaWNlKGluZGV4KTsgLy9yZW1vdmUgaXQgZnJvbSB0aGUgYXJyYXlcclxuICAgICAgICBldmVudCA9IG5ldyBFdmVudFBoeXNpY3MoRVZFTlRfUEhZU0lDUy5UUklHR0VSX0VYSVQsIG9iakhpdCwgMCwgMCwgMCk7XHJcbiAgICAgICAgb2JqSGl0Mi5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59XHJcbiIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKiBJbnRlcm5hbCBjbGFzcyBmb3IgaG9sZGluZyBkYXRhIGFib3V0IHBoeXNpY3MgZGVidWcgdmVydGljZXMuKi9cclxuICBleHBvcnQgY2xhc3MgUGh5c2ljc0RlYnVnVmVydGV4QnVmZmVyIHtcclxuICAgIHB1YmxpYyBnbDogV2ViR0wyUmVuZGVyaW5nQ29udGV4dDtcclxuICAgIHB1YmxpYyBudW1WZXJ0aWNlczogbnVtYmVyID0gMDtcclxuICAgIHB1YmxpYyBhdHRyaWJzOiBBcnJheTxQaHlzaWNzRGVidWdWZXJ0ZXhBdHRyaWJ1dGU+O1xyXG4gICAgcHVibGljIGluZGljZXM6IEFycmF5PG51bWJlcj47XHJcbiAgICBwdWJsaWMgb2Zmc2V0czogQXJyYXk8bnVtYmVyPjtcclxuICAgIHB1YmxpYyBzdHJpZGU6IG51bWJlcjtcclxuICAgIHB1YmxpYyBidWZmZXI6IFdlYkdMQnVmZmVyO1xyXG4gICAgcHVibGljIGRhdGFMZW5ndGg6IG51bWJlcjtcclxuXHJcbiAgICAvKiogU2V0dXAgdGhlIHJlbmRlcmluZyBjb250ZXh0IGZvciB0aGlzIGJ1ZmZlciBhbmQgY3JlYXRlIHRoZSBhY3R1YWwgYnVmZmVyIGZvciB0aGlzIGNvbnRleHQuICovXHJcbiAgICBjb25zdHJ1Y3RvcihfcmVuZGVyaW5nQ29udGV4dDogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCkge1xyXG4gICAgICB0aGlzLmdsID0gX3JlbmRlcmluZ0NvbnRleHQ7XHJcbiAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5nbC5jcmVhdGVCdWZmZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogRmlsbCB0aGUgYm91bmQgYnVmZmVyIHdpdGggZGF0YS4gVXNlZCBhdCBidWZmZXIgaW5pdGlhbGl6YXRpb24gKi9cclxuICAgIHB1YmxpYyBzZXREYXRhKGFycmF5OiBBcnJheTxudW1iZXI+KTogdm9pZCB7XHJcbiAgICAgIGlmICh0aGlzLmF0dHJpYnMgPT0gbnVsbCkgdGhyb3cgXCJzZXQgYXR0cmlidXRlcyBmaXJzdFwiO1xyXG4gICAgICB0aGlzLm51bVZlcnRpY2VzID0gYXJyYXkubGVuZ3RoIC8gKHRoaXMuc3RyaWRlIC8gNCk7XHJcbiAgICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXIpO1xyXG4gICAgICB0aGlzLmdsLmJ1ZmZlckRhdGEodGhpcy5nbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkoYXJyYXkpLCB0aGlzLmdsLkRZTkFNSUNfRFJBVyk7XHJcbiAgICAgIC8vbm90IG5lY2Vzc2FyeSBhbiBpbiB3ZWJnbDIgYW55bW9yZSB0byByZWJpbmQgdGhlIHNhbWUgbGFzdCBidWZmZXIgKHdoaWNoIGlzIGFjaGlldmVkIGJ5IGdpdmluZyBhIG51bGwgYnVmZmVyKSwgYWZ0ZXIgYnVmZmVyIGlzIGNoYW5nZWQuIFJlbW92ZWQgaXQgb24gYWxsIG90aGVyIG9jY2FzaW9uc1xyXG4gICAgICAvLyB0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsIG51bGwpOyBcclxuICAgIH1cclxuXHJcbiAgICAvKiogU2V0IFNoYWRlciBBdHRyaWJ1dGVzIGluZm9ybWF0aW9ucyBieSBnZXR0aW5nIHRoZWlyIHBvc2l0aW9uIGluIHRoZSBzaGFkZXIsIHNldHRpbmcgdGhlIG9mZnNldCwgc3RyaWRlIGFuZCBzaXplLiBGb3IgbGF0ZXIgdXNlIGluIHRoZSBiaW5kaW5nIHByb2Nlc3MgKi9cclxuICAgIHB1YmxpYyBzZXRBdHRyaWJzKGF0dHJpYnM6IEFycmF5PFBoeXNpY3NEZWJ1Z1ZlcnRleEF0dHJpYnV0ZT4pOiB2b2lkIHtcclxuICAgICAgdGhpcy5hdHRyaWJzID0gYXR0cmlicztcclxuICAgICAgdGhpcy5vZmZzZXRzID0gW107XHJcbiAgICAgIHRoaXMuc3RyaWRlID0gMDtcclxuICAgICAgbGV0IG46IG51bWJlciA9IGF0dHJpYnMubGVuZ3RoO1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgdGhpcy5vZmZzZXRzLnB1c2godGhpcy5zdHJpZGUpO1xyXG4gICAgICAgIHRoaXMuc3RyaWRlICs9IGF0dHJpYnNbaV0uZmxvYXQzMkNvdW50ICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UOyAvLyAzMmJpdCBmbG9hdCBCeXRlcyBhcmUgYSBjb25zdGFudCBvZiA0XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKiogR2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgYXR0cmlidXRlIGluIHRoZSBzaGFkZXIgKi9cclxuICAgIHB1YmxpYyBsb2FkQXR0cmliSW5kaWNlcyhfcHJvZ3JhbTogUGh5c2ljc0RlYnVnU2hhZGVyKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuaW5kaWNlcyA9IF9wcm9ncmFtLmdldEF0dHJpYkluZGljZXModGhpcy5hdHRyaWJzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogRW5hYmxlIGEgYXR0cmlidXRlIGluIGEgc2hhZGVyIGZvciB0aGlzIGNvbnRleHQsICovXHJcbiAgICBwdWJsaWMgYmluZEF0dHJpYnMoKTogdm9pZCB7XHJcbiAgICAgIGlmICh0aGlzLmluZGljZXMgPT0gbnVsbCkgdGhyb3cgXCJpbmRpY2VzIGFyZSBub3QgbG9hZGVkXCI7XHJcbiAgICAgIGxldCBuOiBudW1iZXIgPSB0aGlzLmF0dHJpYnMubGVuZ3RoO1xyXG4gICAgICB0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyKTsgLy9tYWtpbmcgdGhlIGJ1ZmZlciBvZiB0aGlzIGNsYXNzIHRoZSBjdXJyZW50IGJ1ZmZlclxyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgdGhpcy5nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLmluZGljZXNbaV0pOyAvL2VuYWJsZSB0aGUgQXR0cmlidXRlXHJcbiAgICAgICAgdGhpcy5nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuaW5kaWNlc1tpXSwgdGhpcy5hdHRyaWJzW2ldLmZsb2F0MzJDb3VudCwgdGhpcy5nbC5GTE9BVCwgZmFsc2UsIHRoaXMuc3RyaWRlLCB0aGlzLm9mZnNldHNbaV0pOyAvL2NyZWF0ZXMgYSBwb2ludGVyIGFuZCBzdHJ1Y3R1cmUgZm9yIHRoaXMgYXR0cmlidXRlXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKiBJbnRlcm5hbCBjbGFzcyBmb3IgaG9sZGluZyBkYXRhIGFib3V0IFBoeXNpY3NEZWJ1Z1ZlcnRleEJ1ZmZlcnMgKi9cclxuICBleHBvcnQgY2xhc3MgUGh5c2ljc0RlYnVnSW5kZXhCdWZmZXIge1xyXG4gICAgcHVibGljIGdsOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0O1xyXG4gICAgcHVibGljIGJ1ZmZlcjogV2ViR0xCdWZmZXI7XHJcbiAgICBwdWJsaWMgY291bnQ6IG51bWJlcjtcclxuXHJcbiAgICAvKiogU2V0dXAgdGhlIHJlbmRlcmluZyBjb250ZXh0IGZvciB0aGlzIGJ1ZmZlciBhbmQgY3JlYXRlIHRoZSBhY3R1YWwgYnVmZmVyIGZvciB0aGlzIGNvbnRleHQuICovXHJcbiAgICBjb25zdHJ1Y3RvcihfcmVuZGVyaW5nQ29udGV4dDogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCkge1xyXG4gICAgICB0aGlzLmdsID0gX3JlbmRlcmluZ0NvbnRleHQ7XHJcbiAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5nbC5jcmVhdGVCdWZmZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogRmlsbCB0aGUgYm91bmQgYnVmZmVyIHdpdGggZGF0YSBhbW91bnQuIFVzZWQgYXQgYnVmZmVyIGluaXRpYWxpemF0aW9uICovXHJcbiAgICBwdWJsaWMgc2V0RGF0YShhcnJheTogQXJyYXk8bnVtYmVyPik6IHZvaWQge1xyXG4gICAgICB0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy5nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXIpO1xyXG4gICAgICB0aGlzLmdsLmJ1ZmZlckRhdGEodGhpcy5nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbmV3IEludDE2QXJyYXkoYXJyYXkpLCB0aGlzLmdsLkRZTkFNSUNfRFJBVyk7XHJcbiAgICAgIHRoaXMuY291bnQgPSBhcnJheS5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFRoZSBhY3R1YWwgRHJhd0NhbGwgZm9yIHBoeXNpY3NEZWJ1Z0RyYXcgQnVmZmVycy4gVGhpcyBpcyB3aGVyZSB0aGUgaW5mb3JtYXRpb24gZnJvbSB0aGUgZGVidWcgaXMgYWN0dWFsbHkgZHJhd24uICovXHJcbiAgICBwdWJsaWMgZHJhdyhfbW9kZTogbnVtYmVyID0gdGhpcy5nbC5UUklBTkdMRVMsIF9jb3VudDogbnVtYmVyID0gLTEpOiB2b2lkIHtcclxuICAgICAgdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyKTtcclxuICAgICAgdGhpcy5nbC5kcmF3RWxlbWVudHMoX21vZGUsIF9jb3VudCA+PSAwID8gX2NvdW50IDogdGhpcy5jb3VudCwgdGhpcy5nbC5VTlNJR05FRF9TSE9SVCwgMCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogSW50ZXJuYWwgY2xhc3MgZm9yIG1hbmFnaW5nIGRhdGEgYWJvdXQgd2ViR0wgQXR0cmlidXRlcyAqL1xyXG4gIGV4cG9ydCBjbGFzcyBQaHlzaWNzRGVidWdWZXJ0ZXhBdHRyaWJ1dGUge1xyXG4gICAgcHVibGljIGZsb2F0MzJDb3VudDogbnVtYmVyO1xyXG4gICAgcHVibGljIG5hbWU6IHN0cmluZztcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihfZmxvYXQzMkNvdW50OiBudW1iZXIsIF9uYW1lOiBzdHJpbmcpIHtcclxuICAgICAgdGhpcy5uYW1lID0gX25hbWU7XHJcbiAgICAgIHRoaXMuZmxvYXQzMkNvdW50ID0gX2Zsb2F0MzJDb3VudDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKiBJbnRlcm5hbCBjbGFzcyBmb3IgU2hhZGVycyB1c2VkIG9ubHkgYnkgdGhlIHBoeXNpY3MgZGVidWdEcmF3ICovXHJcbiAgZXhwb3J0IGNsYXNzIFBoeXNpY3NEZWJ1Z1NoYWRlciB7XHJcbiAgICBwdWJsaWMgZ2w6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ7XHJcbiAgICBwdWJsaWMgcHJvZ3JhbTogV2ViR0xQcm9ncmFtO1xyXG4gICAgcHVibGljIHZlcnRleFNoYWRlcjogV2ViR0xTaGFkZXI7XHJcbiAgICBwdWJsaWMgZnJhZ21lbnRTaGFkZXI6IFdlYkdMU2hhZGVyO1xyXG4gICAgcHVibGljIHVuaWZvcm1Mb2NhdGlvbk1hcDogTWFwPHN0cmluZywgV2ViR0xVbmlmb3JtTG9jYXRpb24+O1xyXG5cclxuICAgIC8qKiBJbnRyb2R1Y2UgdGhlIEZ1ZGdlIFJlbmRlcmluZyBDb250ZXh0IHRvIHRoaXMgY2xhc3MsIGNyZWF0aW5nIGEgcHJvZ3JhbSBhbmQgdmVydGV4L2ZyYWdtZW50IHNoYWRlciBpbiB0aGlzIGNvbnRleHQgKi9cclxuICAgIGNvbnN0cnVjdG9yKF9yZW5kZXJpbmdDb250ZXh0OiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0KSB7XHJcbiAgICAgIHRoaXMuZ2wgPSBfcmVuZGVyaW5nQ29udGV4dDtcclxuICAgICAgdGhpcy5wcm9ncmFtID0gdGhpcy5nbC5jcmVhdGVQcm9ncmFtKCk7XHJcbiAgICAgIHRoaXMudmVydGV4U2hhZGVyID0gdGhpcy5nbC5jcmVhdGVTaGFkZXIodGhpcy5nbC5WRVJURVhfU0hBREVSKTtcclxuICAgICAgdGhpcy5mcmFnbWVudFNoYWRlciA9IHRoaXMuZ2wuY3JlYXRlU2hhZGVyKHRoaXMuZ2wuRlJBR01FTlRfU0hBREVSKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogVGFrZSBnbHNsIHNoYWRlcnMgYXMgc3RyaW5ncyBhbmQgY29tcGlsZSB0aGVtLCBhdHRhY2hpbmcgdGhlIGNvbXBpbGVkIHNoYWRlcnMgdG8gYSBwcm9ncmFtIHRoYXRzIHVzZWQgYnkgdGhpcyByZW5kZXJpbmcgY29udGV4dC4gKi9cclxuICAgIHB1YmxpYyBjb21waWxlKHZlcnRleFNvdXJjZTogc3RyaW5nLCBmcmFnbWVudFNvdXJjZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgIHRoaXMudW5pZm9ybUxvY2F0aW9uTWFwID0gbmV3IE1hcDxzdHJpbmcsIFdlYkdMVW5pZm9ybUxvY2F0aW9uPigpO1xyXG4gICAgICB0aGlzLmNvbXBpbGVTaGFkZXIodGhpcy52ZXJ0ZXhTaGFkZXIsIHZlcnRleFNvdXJjZSk7XHJcbiAgICAgIHRoaXMuY29tcGlsZVNoYWRlcih0aGlzLmZyYWdtZW50U2hhZGVyLCBmcmFnbWVudFNvdXJjZSk7XHJcbiAgICAgIHRoaXMuZ2wuYXR0YWNoU2hhZGVyKHRoaXMucHJvZ3JhbSwgdGhpcy52ZXJ0ZXhTaGFkZXIpO1xyXG4gICAgICB0aGlzLmdsLmF0dGFjaFNoYWRlcih0aGlzLnByb2dyYW0sIHRoaXMuZnJhZ21lbnRTaGFkZXIpO1xyXG4gICAgICB0aGlzLmdsLmxpbmtQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XHJcbiAgICAgIGlmICghdGhpcy5nbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHRoaXMucHJvZ3JhbSwgdGhpcy5nbC5MSU5LX1NUQVRVUykpIHsgIC8vbWFrZSBzdXJlIHRoZSBsaW5raW5nIHdvcmtlZCwgc28gdGhlIHByb2dyYW0gaXMgdmFsaWQsIGFuZCBzaGFkZXJzIGFyZSB3b3JraW5nXHJcbiAgICAgICAgRGVidWcubG9nKHRoaXMuZ2wuZ2V0UHJvZ3JhbUluZm9Mb2codGhpcy5wcm9ncmFtKSk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5nbC52YWxpZGF0ZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcclxuICAgICAgaWYgKCF0aGlzLmdsLmdldFByb2dyYW1QYXJhbWV0ZXIodGhpcy5wcm9ncmFtLCB0aGlzLmdsLlZBTElEQVRFX1NUQVRVUykpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiRVJST1IgdmFsaWRhdGluZyBwcm9ncmFtIVwiLCB0aGlzLmdsLmdldFByb2dyYW1JbmZvTG9nKHRoaXMucHJvZ3JhbSkpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBHZXQgaW5kZXggb2YgYSBhdHRyaWJ1dGUgaW4gYSBzaGFkZXIgaW4gdGhpcyBwcm9ncmFtICovXHJcbiAgICBwdWJsaWMgZ2V0QXR0cmliSW5kZXgoX25hbWU6IHN0cmluZyk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgX25hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBHZXQgdGhlIGxvY2F0aW9uIG9mIGEgdW5pZm9ybSBpbiBhIHNoYWRlciBpbiB0aGlzIHByb2dyYW0gKi9cclxuICAgIHB1YmxpYyBnZXRVbmlmb3JtTG9jYXRpb24oX25hbWU6IHN0cmluZyk6IFdlYkdMVW5pZm9ybUxvY2F0aW9uIHtcclxuICAgICAgaWYgKHRoaXMudW5pZm9ybUxvY2F0aW9uTWFwLmhhcyhfbmFtZSkpIHJldHVybiB0aGlzLnVuaWZvcm1Mb2NhdGlvbk1hcC5nZXQoX25hbWUpO1xyXG4gICAgICBsZXQgbG9jYXRpb246IFdlYkdMVW5pZm9ybUxvY2F0aW9uID0gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBfbmFtZSk7XHJcbiAgICAgIHRoaXMudW5pZm9ybUxvY2F0aW9uTWFwLnNldChfbmFtZSwgbG9jYXRpb24pO1xyXG4gICAgICByZXR1cm4gbG9jYXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEdldCBhbGwgaW5kaWNlcyBmb3IgZXZlcnkgYXR0cmlidXRlIGluIHRoZSBzaGFkZXJzIG9mIHRoaXMgcHJvZ3JhbSAqL1xyXG4gICAgcHVibGljIGdldEF0dHJpYkluZGljZXMoX2F0dHJpYnM6IEFycmF5PFBoeXNpY3NEZWJ1Z1ZlcnRleEF0dHJpYnV0ZT4pOiBBcnJheTxudW1iZXI+IHtcclxuICAgICAgbGV0IGluZGljZXM6IEFycmF5PG51bWJlcj4gPSBbXTtcclxuICAgICAgX2F0dHJpYnMuZm9yRWFjaCh2YWx1ZSA9PiB7XHJcbiAgICAgICAgaW5kaWNlcy5wdXNoKHRoaXMuZ2V0QXR0cmliSW5kZXgodmFsdWUubmFtZSkpO1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIGluZGljZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFRlbGwgdGhlIEZ1ZGdlIFJlbmRlcmluZyBDb250ZXh0IHRvIHVzZSB0aGlzIHByb2dyYW0gdG8gZHJhdy4gKi9cclxuICAgIHB1YmxpYyB1c2UoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBDb21waWxlIGEgc2hhZGVyIG91dCBvZiBhIHN0cmluZyBhbmQgdmFsaWRhdGUgaXQuICovXHJcbiAgICBwdWJsaWMgY29tcGlsZVNoYWRlcihzaGFkZXI6IFdlYkdMU2hhZGVyLCBzb3VyY2U6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICB0aGlzLmdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNvdXJjZSk7XHJcbiAgICAgIHRoaXMuZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xyXG4gICAgICBpZiAoIXRoaXMuZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgdGhpcy5nbC5DT01QSUxFX1NUQVRVUykpIHtcclxuICAgICAgICBEZWJ1Zy5sb2codGhpcy5nbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcikpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogSW50ZXJuYWwgQ2xhc3MgdXNlZCB0byBkcmF3IGRlYnVnSW5mb3JtYXRpb25zIGFib3V0IHRoZSBwaHlzaWNzIHNpbXVsYXRpb24gb250byB0aGUgcmVuZGVyQ29udGV4dC4gTm8gdXNlciBpbnRlcmFjdGlvbiBuZWVkZWQuIFxyXG4gICAqIEBhdXRob3IgTWFya28gRmVocmVuYmFjaCwgSEZVIDIwMjAgLy9CYXNlZCBvbiBPaW1vUGh5c2ljcyBIYXhlIERlYnVnRHJhd0RlbW8gXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFBoeXNpY3NEZWJ1Z0RyYXcgZXh0ZW5kcyBSZW5kZXJXZWJHTCB7XHJcbiAgICBwdWJsaWMgb2ltb0RlYnVnRHJhdzogT0lNTy5EZWJ1Z0RyYXc7IC8vdGhlIG9yaWdpbmFsIHBoeXNpY3MgZW5naW5lIGRlYnVnRHJhdyBjbGFzcyByZWNlaXZpbmcgY2FsbHMgZnJvbSB0aGUgb2ltb1BoeXNpY3MuV29ybGQsIGFuZCBwcm92aWRpbmcgaW5mb3JtYXRpb25zIGluIGZvcm0gb2YgcG9pbnRzL2xpbmVzL3RyaWFuZ2xlcyB3aGF0IHRoZSBwaHlzaWNzIHdvcmxkIGxvb2tzIGxpa2VcclxuICAgIHB1YmxpYyBzdHlsZTogT0lNTy5EZWJ1Z0RyYXdTdHlsZTsgLy9jb2xvcnMgb2YgdGhlIGRlYnVnIGluZm9ybWF0aW9ucywgdW5jaGFuZ2VkIGluIEZ1ZGdlIGludGVncmF0aW9uLCBiYXNpY2FsbHkgY29sb3JpbmcgdGhpbmdzIGxpa2Ugc2xlZXBpbmcvYWN0aXZlIHJiJ3MgZGlmZmVyZW50bHksIGpvaW50cyB3aGl0ZSBhbmQgc3VjaC4gTm8gbmVlZCB0byBoYXZlIHVzZXJzIGNoYW5nZSBhbnl0aGluZy5cclxuICAgIHB1YmxpYyBnbDogV2ViR0wyUmVuZGVyaW5nQ29udGV4dDtcclxuXHJcbiAgICBwdWJsaWMgcHJvZ3JhbTogV2ViR0xQcm9ncmFtOyAvL3Byb2dyYW0gdGhhdCBpcyB1c2VkIGluIHRoZSBGdWRnZSByZW5kZXJpbmcgY29udGV4dCBjb250YWluaW5nIHNoYWRlcnMgYW5kIHVzZSBpbmZvcm1hdGlvbnMgZm9yIHRoZSBjb250ZXh0IHRvIGtub3cgaG93IHRvIGRyYXdcclxuICAgIHB1YmxpYyBzaGFkZXI6IFBoeXNpY3NEZWJ1Z1NoYWRlcjtcclxuXHJcbiAgICAvL0J1ZmZlcnMgZm9yIHBvaW50cy9saW5lcy90cmlhbmdsZXMuIEluZGV4IEJ1ZmZlciBmb3IgdGhlIGFtb3VudCBvZiBkcmF3Q2FsbHMgYW5kIFZlcnRleCBCdWZmZXIgZm9yIHRoZSBpbmZvcm1hdGlvbnNcclxuICAgIHB1YmxpYyBwb2ludFZCTzogUGh5c2ljc0RlYnVnVmVydGV4QnVmZmVyO1xyXG4gICAgcHVibGljIHBvaW50SUJPOiBQaHlzaWNzRGVidWdJbmRleEJ1ZmZlcjtcclxuXHJcbiAgICBwdWJsaWMgbGluZVZCTzogUGh5c2ljc0RlYnVnVmVydGV4QnVmZmVyO1xyXG4gICAgcHVibGljIGxpbmVJQk86IFBoeXNpY3NEZWJ1Z0luZGV4QnVmZmVyO1xyXG5cclxuICAgIHB1YmxpYyB0cmlWQk86IFBoeXNpY3NEZWJ1Z1ZlcnRleEJ1ZmZlcjtcclxuICAgIHB1YmxpYyB0cmlJQk86IFBoeXNpY3NEZWJ1Z0luZGV4QnVmZmVyO1xyXG5cclxuICAgIHB1YmxpYyBwb2ludERhdGE6IEFycmF5PG51bWJlcj47XHJcbiAgICBwdWJsaWMgcG9pbnRJYm9EYXRhOiBBcnJheTxudW1iZXI+O1xyXG4gICAgcHVibGljIG51bVBvaW50RGF0YTogbnVtYmVyO1xyXG5cclxuICAgIHB1YmxpYyBsaW5lRGF0YTogQXJyYXk8bnVtYmVyPjtcclxuICAgIHB1YmxpYyBsaW5lSWJvRGF0YTogQXJyYXk8bnVtYmVyPjtcclxuICAgIHB1YmxpYyBudW1MaW5lRGF0YTogbnVtYmVyO1xyXG5cclxuICAgIHB1YmxpYyB0cmlEYXRhOiBBcnJheTxudW1iZXI+O1xyXG4gICAgcHVibGljIHRyaUlib0RhdGE6IEFycmF5PG51bWJlcj47XHJcbiAgICBwdWJsaWMgbnVtVHJpRGF0YTogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBDcmVhdGluZyB0aGUgZGVidWcgZm9yIHBoeXNpY3MgaW4gRnVkZ2UuIFRlbGwgaXQgdG8gZHJhdyBvbmx5IHdpcmVmcmFtZSBvYmplY3RzLCBzaW5jZSBGdWRnZSBpcyBoYW5kbGluZyByZW5kZXJpbmcgb2YgdGhlIG9iamVjdHMgYmVzaWRlcyBwaHlzaWNzLiBcclxuICAgICAqIE92ZXJyaWRlIE9pbW9QaHlzaWNzIEZ1bmN0aW9ucyB3aXRoIG93biByZW5kZXJpbmcuIEluaXRpYWxpemUgYnVmZmVycyBhbmQgY29ubmVjdCB0aGVtIHdpdGggdGhlIGNvbnRleHQgZm9yIGxhdGVyIHVzZS4gKi9cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICBzdXBlcigpO1xyXG5cclxuICAgICAgdGhpcy5zdHlsZSA9IG5ldyBPSU1PLkRlYnVnRHJhd1N0eWxlKCk7XHJcbiAgICAgIHRoaXMub2ltb0RlYnVnRHJhdyA9IG5ldyBPSU1PLkRlYnVnRHJhdygpO1xyXG4gICAgICB0aGlzLm9pbW9EZWJ1Z0RyYXcud2lyZWZyYW1lID0gdHJ1ZTsgLy9UcmlhbmdsZSBSZW5kZXJpbmcgaXMgaGFuZGxlZCBieSBGVURHRSBzbywgb25seSB0aGUgcGh5c2ljcyBsaW5lcy9wb2ludHMgbmVlZCB0byBiZSByZW5kZXJlZCwgYWx0aG91Z2ggdHJpYW5nbGUgaXMgc3RpbGwgaW1wbGVtZW50ZWRcclxuXHJcbiAgICAgIHRoaXMuZ2wgPSBSZW5kZXJXZWJHTC5jcmMzO1xyXG4gICAgICB0aGlzLmluaXRpYWxpemVPdmVycmlkZSgpO1xyXG4gICAgICB0aGlzLnNoYWRlciA9IG5ldyBQaHlzaWNzRGVidWdTaGFkZXIodGhpcy5nbCk7XHJcbiAgICAgIHRoaXMuc2hhZGVyLmNvbXBpbGUodGhpcy52ZXJ0ZXhTaGFkZXJTb3VyY2UoKSwgdGhpcy5mcmFnbWVudFNoYWRlclNvdXJjZSgpKTtcclxuXHJcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZUJ1ZmZlcnMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogUmVjZWl2ZSB0aGUgY3VycmVudCBEZWJ1Z01vZGUgZnJvbSB0aGUgcGh5c2ljcyBzZXR0aW5ncyBhbmQgc2V0IHRoZSBPaW1vUGh5c2ljcy5EZWJ1Z0RyYXcgYm9vbGVhbnMgdG8gc2hvdyBvbmx5IGNlcnRhaW4gaW5mb3JtYXRpb25zLlxyXG4gICAgICogTmVlZGVkIHNpbmNlIHNvbWUgZGVidWcgaW5mb3JtYXRpb25zIGV4Y2x1ZGUgb3RoZXJzLCBhbmQgY2FuJ3QgYmUgZHJhd24gYXQgdGhlIHNhbWUgdGltZSwgYnkgT2ltb1BoeXNpY3MuIEFuZCBmb3IgdXNlcnMgaXQgcHJvdmlkZXMgbW9yZSByZWFkYWJpbGl0eVxyXG4gICAgICogdG8gZGVidWcgb25seSB3aGF0IHRoZXkgbmVlZCBhbmQgaXMgY29tbW9ubHkgZGVidWdnZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXREZWJ1Z01vZGUoX21vZGU6IFBIWVNJQ1NfREVCVUdNT0RFID0gUEhZU0lDU19ERUJVR01PREUuTk9ORSk6IHZvaWQge1xyXG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgICAgbGV0IGRyYXcgPSB7IGRyYXdBYWJiczogZmFsc2UsIGRyYXdCYXNlczogZmFsc2UsIGRyYXdCdmg6IGZhbHNlLCBkcmF3Q29udGFjdEJhc2VzOiBmYWxzZSwgZHJhd0NvbnRhY3RzOiBmYWxzZSwgZHJhd0pvaW50TGltaXRzOiBmYWxzZSwgZHJhd0pvaW50czogZmFsc2UsIGRyYXdQYWlyczogZmFsc2UsIGRyYXdTaGFwZXM6IGZhbHNlIH07XHJcblxyXG4gICAgICBzd2l0Y2ggKF9tb2RlKSB7XHJcbiAgICAgICAgY2FzZSBQSFlTSUNTX0RFQlVHTU9ERS5DT0xMSURFUlM6IC8vQ29sbGlkZXJzIGFuZCBCYXNlc1xyXG4gICAgICAgICAgZHJhdy5kcmF3QmFzZXMgPSBkcmF3LmRyYXdTaGFwZXMgPSB0cnVlO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBQSFlTSUNTX0RFQlVHTU9ERS5KT0lOVFNfQU5EX0NPTExJREVSOiAvL0NvbGxpZGVycyBhbmQgam9pbnRzXHJcbiAgICAgICAgICBkcmF3LmRyYXdKb2ludHMgPSBkcmF3LmRyYXdKb2ludExpbWl0cyA9IGRyYXcuZHJhd1NoYXBlcyA9IHRydWU7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFBIWVNJQ1NfREVCVUdNT0RFLlBIWVNJQ19PQkpFQ1RTX09OTFk6IC8vUGh5c2ljcyBPYmplY3RzIG9ubHksIHNob3dzIHNhbWUgYXMgQ29sbGlkZXIgLyBKb2ludHMgYnV0IGFsc28gaGlkaW5nIGV2ZXJ5IG90aGVyIGZ1ZGdlIG9iamVjdFxyXG4gICAgICAgICAgZHJhdy5kcmF3QmFzZXMgPSBkcmF3LmRyYXdKb2ludExpbWl0cyA9IGRyYXcuZHJhd0pvaW50cyA9IGRyYXcuZHJhd1NoYXBlcyA9IHRydWU7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFBIWVNJQ1NfREVCVUdNT0RFLkNPTlRBQ1RTOiAvL0NvbnRhY3RzXHJcbiAgICAgICAgICBkcmF3LmRyYXdCYXNlcyA9IGRyYXcuZHJhd0NvbnRhY3RCYXNlcyA9IGRyYXcuZHJhd0NvbnRhY3RzID0gZHJhdy5kcmF3UGFpcnMgPSBkcmF3LmRyYXdTaGFwZXMgPSB0cnVlO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBQSFlTSUNTX0RFQlVHTU9ERS5CT1VORElOR19CT1hFUzogLy9Cb3VuZGluZyBCb3ggLyBCcm9hZHBoYXNlIEJ2aCAvIEJhc2VzXHJcbiAgICAgICAgICBkcmF3LmRyYXdBYWJicyA9IGRyYXcuZHJhd0Jhc2VzID0gZHJhdy5kcmF3QnZoID0gdHJ1ZTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5vaW1vRGVidWdEcmF3LCBkcmF3KTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQ3JlYXRpbmcgdGhlIGVtcHR5IHJlbmRlciBidWZmZXJzLiBEZWZpbmluZyB0aGUgYXR0cmlidXRlcyB1c2VkIGluIHNoYWRlcnMuXHJcbiAgICAgKiBOZWVkcyB0byBjcmVhdGUgZW1wdHkgYnVmZmVycyB0byBhbHJlYWR5IGhhdmUgdGhlbSByZWFkeSB0byBkcmF3IGxhdGVyIG9uLCBsaW5raW5nIGlzIG9ubHkgcG9zc2libGUgd2l0aCBleGlzdGluZyBidWZmZXJzLiAqL1xyXG4gICAgcHVibGljIGluaXRpYWxpemVCdWZmZXJzKCk6IHZvaWQge1xyXG4gICAgICBsZXQgYXR0cmliczogQXJyYXk8UGh5c2ljc0RlYnVnVmVydGV4QXR0cmlidXRlPiA9IFtcclxuICAgICAgICBuZXcgUGh5c2ljc0RlYnVnVmVydGV4QXR0cmlidXRlKDMsIFwiYVBvc2l0aW9uXCIpLFxyXG4gICAgICAgIG5ldyBQaHlzaWNzRGVidWdWZXJ0ZXhBdHRyaWJ1dGUoMywgXCJhTm9ybWFsXCIpLFxyXG4gICAgICAgIG5ldyBQaHlzaWNzRGVidWdWZXJ0ZXhBdHRyaWJ1dGUoMywgXCJhQ29sb3JcIilcclxuICAgICAgXTtcclxuXHJcbiAgICAgIHRoaXMucG9pbnRWQk8gPSBuZXcgUGh5c2ljc0RlYnVnVmVydGV4QnVmZmVyKHRoaXMuZ2wpO1xyXG4gICAgICB0aGlzLnBvaW50SUJPID0gbmV3IFBoeXNpY3NEZWJ1Z0luZGV4QnVmZmVyKHRoaXMuZ2wpO1xyXG4gICAgICB0aGlzLnBvaW50VkJPLnNldEF0dHJpYnMoYXR0cmlicyk7XHJcbiAgICAgIHRoaXMucG9pbnRWQk8ubG9hZEF0dHJpYkluZGljZXModGhpcy5zaGFkZXIpO1xyXG4gICAgICB0aGlzLmxpbmVWQk8gPSBuZXcgUGh5c2ljc0RlYnVnVmVydGV4QnVmZmVyKHRoaXMuZ2wpO1xyXG4gICAgICB0aGlzLmxpbmVJQk8gPSBuZXcgUGh5c2ljc0RlYnVnSW5kZXhCdWZmZXIodGhpcy5nbCk7XHJcbiAgICAgIHRoaXMubGluZVZCTy5zZXRBdHRyaWJzKGF0dHJpYnMpO1xyXG4gICAgICB0aGlzLmxpbmVWQk8ubG9hZEF0dHJpYkluZGljZXModGhpcy5zaGFkZXIpO1xyXG4gICAgICB0aGlzLnRyaVZCTyA9IG5ldyBQaHlzaWNzRGVidWdWZXJ0ZXhCdWZmZXIodGhpcy5nbCk7XHJcbiAgICAgIHRoaXMudHJpSUJPID0gbmV3IFBoeXNpY3NEZWJ1Z0luZGV4QnVmZmVyKHRoaXMuZ2wpO1xyXG4gICAgICB0aGlzLnRyaVZCTy5zZXRBdHRyaWJzKGF0dHJpYnMpO1xyXG4gICAgICB0aGlzLnRyaVZCTy5sb2FkQXR0cmliSW5kaWNlcyh0aGlzLnNoYWRlcik7XHJcblxyXG4gICAgICB0aGlzLmNsZWFyQnVmZmVycygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBCZWZvcmUgT2ltb1BoeXNpY3Mud29ybGQgaXMgZmlsbGluZyB0aGUgZGVidWcuIE1ha2Ugc3VyZSB0aGUgYnVmZmVycyBhcmUgcmVzZXQuIEFsc28gcmVjZWl2aW5nIHRoZSBkZWJ1Z01vZGUgZnJvbSBzZXR0aW5ncyBhbmQgdXBkYXRpbmcgdGhlIGN1cnJlbnQgcHJvamVjdGlvbiBmb3IgdGhlIHZlcnRleFNoYWRlci4gKi9cclxuICAgIHB1YmxpYyBjbGVhckJ1ZmZlcnMoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuZ2wubGluZVdpZHRoKDIuMCk7IC8vRG9lcyBub3QgYWZmZWN0IGFueXRoaW5nIGJlY2F1c2UgbGluZVdpZHRoIGlzIGN1cnJlbnRseSBvbmx5IHN1cHBvcnRlZCBieSBNaWNyb3NvZnQgRWRnZSBhbmQgRnVkZ2UgaXMgb3B0aW1pemVkIGZvciBDaHJvbWVcclxuXHJcbiAgICAgIHRoaXMucG9pbnREYXRhID0gW107IC8vUmVzZXR0aW5nIHRoZSBkYXRhIHRvIGJlIGZpbGxlZCBhZ2FpblxyXG4gICAgICB0aGlzLmxpbmVEYXRhID0gW107XHJcbiAgICAgIHRoaXMudHJpRGF0YSA9IFtdO1xyXG5cclxuICAgICAgdGhpcy5udW1Qb2ludERhdGEgPSAwOyAvL1Jlc2V0dGluZyB0aGUgYW1vdW50IG9mIGRhdGEgY2FsbHNcclxuICAgICAgdGhpcy5udW1MaW5lRGF0YSA9IDA7XHJcbiAgICAgIHRoaXMubnVtVHJpRGF0YSA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEFmdGVyIE9pbW9QaHlzaWNzLndvcmxkIGZpbGxlZCB0aGUgZGVidWcuIFJlbmRlcmluZyBjYWxscy4gU2V0dGluZyB0aGlzIHByb2dyYW0gdG8gYmUgdXNlZCBieSB0aGUgRnVkZ2UgcmVuZGVyaW5nIGNvbnRleHQuIEFuZCBkcmF3IGVhY2ggdXBkYXRlZCBidWZmZXIgYW5kIHJlc2V0dGluZyB0aGVtLiAqL1xyXG4gICAgcHVibGljIGRyYXdCdWZmZXJzKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLnNoYWRlci51c2UoKTtcclxuICAgICAgbGV0IHByb2plY3Rpb246IEZsb2F0MzJBcnJheSA9IFBoeXNpY3MubWFpbkNhbS5tdHhXb3JsZFRvVmlldy5nZXQoKTtcclxuICAgICAgdGhpcy5nbC51bmlmb3JtTWF0cml4NGZ2KHRoaXMuc2hhZGVyLmdldFVuaWZvcm1Mb2NhdGlvbihcInVfbXR4TWVzaFRvVmlld1wiKSwgZmFsc2UsIHByb2plY3Rpb24pO1xyXG5cclxuXHJcbiAgICAgIGlmICh0aGlzLm51bVBvaW50RGF0YSA+IDApIHtcclxuICAgICAgICB0aGlzLnBvaW50SWJvRGF0YSA9IFtdOyAgLy9CdWZmZXIgc2l6ZSBtYXRjaGluZyB0byB3aGF0cyBuZWVkZWRcclxuICAgICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5udW1Qb2ludERhdGE7IGkrKykge1xyXG4gICAgICAgICAgdGhpcy5wb2ludElib0RhdGEucHVzaChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wb2ludElCTy5zZXREYXRhKHRoaXMucG9pbnRJYm9EYXRhKTsgLy9TZXQgSW5kZXggYnVmZmVyIHRvIGNvcnJlY3Qgc2l6ZVxyXG4gICAgICAgIHRoaXMucG9pbnRWQk8uc2V0RGF0YSh0aGlzLnBvaW50RGF0YSk7IC8vU2V0IFZlcnRleCBCdWZmZXIgdG8gY3VycmVudCBEYXRhXHJcbiAgICAgICAgdGhpcy5wb2ludFZCTy5iaW5kQXR0cmlicygpO1xyXG4gICAgICAgIHRoaXMucG9pbnRJQk8uZHJhdyh0aGlzLmdsLlBPSU5UUywgdGhpcy5udW1Qb2ludERhdGEpOyAvL1RoZSBhY3R1YWwgZHJhdyBjYWxsIGZvciBlYWNoIGluZGV4IGluIGlib1xyXG4gICAgICAgIHRoaXMubnVtUG9pbnREYXRhID0gMDtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5udW1MaW5lRGF0YSA+IDApIHtcclxuICAgICAgICB0aGlzLmxpbmVJYm9EYXRhID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubnVtTGluZURhdGE7IGkrKykge1xyXG4gICAgICAgICAgdGhpcy5saW5lSWJvRGF0YS5wdXNoKGkgKiAyKTtcclxuICAgICAgICAgIHRoaXMubGluZUlib0RhdGEucHVzaChpICogMiArIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxpbmVJQk8uc2V0RGF0YSh0aGlzLmxpbmVJYm9EYXRhKTtcclxuICAgICAgICB0aGlzLmxpbmVWQk8uc2V0RGF0YSh0aGlzLmxpbmVEYXRhKTtcclxuICAgICAgICB0aGlzLmxpbmVWQk8uYmluZEF0dHJpYnMoKTtcclxuICAgICAgICB0aGlzLmxpbmVJQk8uZHJhdyh0aGlzLmdsLkxJTkVTLCB0aGlzLm51bUxpbmVEYXRhICogMik7XHJcbiAgICAgICAgdGhpcy5udW1MaW5lRGF0YSA9IDA7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMubnVtVHJpRGF0YSA+IDApIHtcclxuICAgICAgICB0aGlzLnRyaUlib0RhdGEgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5udW1UcmlEYXRhOyBpKyspIHtcclxuICAgICAgICAgIHRoaXMudHJpSWJvRGF0YS5wdXNoKGkgKiAzKTtcclxuICAgICAgICAgIHRoaXMudHJpSWJvRGF0YS5wdXNoKGkgKiAzICsgMSk7XHJcbiAgICAgICAgICB0aGlzLnRyaUlib0RhdGEucHVzaChpICogMyArIDIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRyaUlCTy5zZXREYXRhKHRoaXMudHJpSWJvRGF0YSk7XHJcbiAgICAgICAgdGhpcy50cmlWQk8uc2V0RGF0YSh0aGlzLnRyaURhdGEpO1xyXG4gICAgICAgIHRoaXMudHJpVkJPLmJpbmRBdHRyaWJzKCk7XHJcbiAgICAgICAgdGhpcy50cmlJQk8uZHJhdyh0aGlzLmdsLlRSSUFOR0xFUywgdGhpcy5udW1UcmlEYXRhICogMyk7XHJcbiAgICAgICAgdGhpcy5udW1UcmlEYXRhID0gMDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBEcmF3aW5nIHRoZSByYXkgaW50byB0aGUgZGVidWdEcmF3IENhbGwuIEJ5IHVzaW5nIHRoZSBvdmVyd3JpdHRlbiBsaW5lIHJlbmRlcmluZyBmdW5jdGlvbnMgYW5kIGRyYXdpbmcgYSBwb2ludCAocG9pbnRTaXplIGRlZmluZWQgaW4gdGhlIHNoYWRlcikgYXQgdGhlIGVuZCBvZiB0aGUgcmF5LiAqL1xyXG4gICAgcHVibGljIGRlYnVnUmF5KF9vcmlnaW46IFZlY3RvcjMsIF9lbmQ6IFZlY3RvcjMsIF9jb2xvcjogQ29sb3IpOiB2b2lkIHtcclxuICAgICAgdGhpcy5vaW1vRGVidWdEcmF3LmxpbmUobmV3IE9JTU8uVmVjMyhfb3JpZ2luLngsIF9vcmlnaW4ueSwgX29yaWdpbi56KSwgbmV3IE9JTU8uVmVjMyhfZW5kLngsIF9lbmQueSwgX2VuZC56KSwgbmV3IE9JTU8uVmVjMyhfY29sb3IuciwgX2NvbG9yLmcsIF9jb2xvci5iKSk7XHJcbiAgICAgIHRoaXMub2ltb0RlYnVnRHJhdy5wb2ludChuZXcgT0lNTy5WZWMzKF9lbmQueCwgX2VuZC55LCBfZW5kLnopLCBuZXcgT0lNTy5WZWMzKF9jb2xvci5yLCBfY29sb3IuZywgX2NvbG9yLmIpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogT3ZlcnJpZGluZyB0aGUgZXhpc3RpbmcgZnVuY3Rpb25zIGZyb20gT2ltb1BoeXNpY3MuRGVidWdEcmF3IHdpdGhvdXQgYWN0dWFsbHkgaW5oZXJpdCBmcm9tIHRoZSBjbGFzcywgdG8gYXZvaWQgY29tcGlsZXIgcHJvYmxlbXMuIFxyXG4gICAgICogT3ZlcnJpZGluZyB0aGVtIHRvIHJlY2VpdmUgZGVidWdJbmZvcm1hdGlvbnMgaW4gdGhlIGZvcm1hdCB0aGUgcGh5c2ljIGVuZ2luZSBwcm92aWRlcyB0aGVtIGJ1dCBoYW5kbGluZyB0aGUgcmVuZGVyaW5nIGluIHRoZSBmdWRnZSBjb250ZXh0LiAqL1xyXG4gICAgcHJpdmF0ZSBpbml0aWFsaXplT3ZlcnJpZGUoKTogdm9pZCB7XHJcbiAgICAgIC8vT3ZlcnJpZGUgcG9pbnQvbGluZS90cmlhbmdsZSBmdW5jdGlvbnMgb2YgT2ltb1BoeXNpY3Mgd2hpY2ggYXJlIHVzZWQgdG8gZHJhdyB3aXJlZnJhbWVzIG9mIG9iamVjdHMsIGxpbmVzIG9mIHJheWNhc3RzIG9yIHRyaWFuZ2xlcyB3aGVuIHRoZSBvYmplY3RzIGFyZSByZW5kZXJlZCBieSB0aGUgcGh5c2ljcyBub3QgRlVER0UgKHVudXNlZClcclxuXHJcbiAgICAgIE9JTU8uRGVidWdEcmF3LnByb3RvdHlwZS5wb2ludCA9IGZ1bmN0aW9uIChfdjogT0lNTy5WZWMzLCBfY29sb3I6IE9JTU8uVmVjMyk6IHZvaWQge1xyXG4gICAgICAgIGxldCBkZWJ1Z1dyYXBwZXI6IFBoeXNpY3NEZWJ1Z0RyYXcgPSBQaHlzaWNzLmRlYnVnRHJhdzsgLy9HZXQgdGhlIGN1c3RvbSBwaHlzaWNzIGRlYnVnIGNsYXNzIHRvIGhhdmUgYWNjZXNzIHRvIHRoZSBkYXRhLlxyXG4gICAgICAgIGlmIChQaHlzaWNzLm1haW5DYW0gIT0gbnVsbCkgeyAvL29ubHkgYWN0IHdoZW4gdGhlcmUgaXMgYSBjYW1lcmEgdGhhdCBpcyByZW5kZXJpbmdcclxuICAgICAgICAgIGxldCBkYXRhOiBBcnJheTxOdW1iZXI+ID0gZGVidWdXcmFwcGVyLnBvaW50RGF0YTsgLy9nZXQgdGhlIGFscmVhZHkgd3JpdHRlbiBidWZmZXIgaW5mb3JtYXRpb25zXHJcbiAgICAgICAgICBkYXRhLnB1c2goX3YueCwgX3YueSwgX3Yueik7IC8vQ29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50XHJcbiAgICAgICAgICBkYXRhLnB1c2goMCwgMCwgMCk7IC8vUG9pbnQgTm9ybWFscyAtIEVtcHR5IHNpbmNlIGl0J3Mgbm90IGEgcG9seWdvblxyXG4gICAgICAgICAgZGF0YS5wdXNoKF9jb2xvci54LCBfY29sb3IueSwgX2NvbG9yLnopOyAvL0NvbG9yIG9mIHRoZSBwb2ludFxyXG4gICAgICAgICAgZGVidWdXcmFwcGVyLm51bVBvaW50RGF0YSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIE9JTU8uRGVidWdEcmF3LnByb3RvdHlwZS5saW5lID0gZnVuY3Rpb24gKF92MTogT0lNTy5WZWMzLCBfdjI6IE9JTU8uVmVjMywgX2NvbG9yOiBPSU1PLlZlYzMpOiB2b2lkIHtcclxuICAgICAgICBsZXQgZGVidWdXcmFwcGVyOiBQaHlzaWNzRGVidWdEcmF3ID0gUGh5c2ljcy5kZWJ1Z0RyYXc7XHJcbiAgICAgICAgaWYgKFBoeXNpY3MubWFpbkNhbSAhPSBudWxsKSB7XHJcbiAgICAgICAgICBsZXQgZGF0YTogQXJyYXk8bnVtYmVyPiA9IGRlYnVnV3JhcHBlci5saW5lRGF0YTtcclxuICAgICAgICAgIGRhdGEucHVzaChfdjEueCwgX3YxLnksIF92MS56KTsgLy9Qb2ludCAxIENvb3JkaW5hdGVzXHJcbiAgICAgICAgICBkYXRhLnB1c2goMCwgMCwgMCk7IC8vUDEgTm9ybWFscyAtIEVtcHR5IHNpbmNlIGl0J3Mgbm90IGEgcG9seWdvblxyXG4gICAgICAgICAgZGF0YS5wdXNoKF9jb2xvci54LCBfY29sb3IueSwgX2NvbG9yLnopOyAvL1AxIENvbG9yXHJcbiAgICAgICAgICBkYXRhLnB1c2goX3YyLngsIF92Mi55LCBfdjIueik7IC8vUG9pbnQgMiBDb29yZGluYXRlc1xyXG4gICAgICAgICAgZGF0YS5wdXNoKDAsIDAsIDApO1xyXG4gICAgICAgICAgZGF0YS5wdXNoKF9jb2xvci54LCBfY29sb3IueSwgX2NvbG9yLnopO1xyXG4gICAgICAgICAgZGVidWdXcmFwcGVyLm51bUxpbmVEYXRhKys7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgT0lNTy5EZWJ1Z0RyYXcucHJvdG90eXBlLnRyaWFuZ2xlID0gZnVuY3Rpb24gKF92MTogT0lNTy5WZWMzLCBfdjI6IE9JTU8uVmVjMywgX3YzOiBPSU1PLlZlYzMsIF9uMTogT0lNTy5WZWMzLCBfbjI6IE9JTU8uVmVjMywgX24zOiBPSU1PLlZlYzMsIF9jb2xvcjogT0lNTy5WZWMzKTogdm9pZCB7XHJcbiAgICAgICAgbGV0IGRlYnVnV3JhcHBlcjogUGh5c2ljc0RlYnVnRHJhdyA9IFBoeXNpY3MuZGVidWdEcmF3O1xyXG4gICAgICAgIGlmIChQaHlzaWNzLm1haW5DYW0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgbGV0IGRhdGE6IEFycmF5PG51bWJlcj4gPSBkZWJ1Z1dyYXBwZXIudHJpRGF0YTtcclxuICAgICAgICAgIGRhdGEucHVzaChfdjEueCwgX3YxLnksIF92MS56KTtcclxuICAgICAgICAgIGRhdGEucHVzaChfbjEueCwgX24xLnksIF9uMS56KTtcclxuICAgICAgICAgIGRhdGEucHVzaChfY29sb3IueCwgX2NvbG9yLnksIF9jb2xvci56KTtcclxuICAgICAgICAgIGRhdGEucHVzaChfdjIueCwgX3YyLnksIF92Mi56KTtcclxuICAgICAgICAgIGRhdGEucHVzaChfbjIueCwgX24yLnksIF9uMi56KTtcclxuICAgICAgICAgIGRhdGEucHVzaChfY29sb3IueCwgX2NvbG9yLnksIF9jb2xvci56KTtcclxuICAgICAgICAgIGRhdGEucHVzaChfdjMueCwgX3YzLnksIF92My56KTtcclxuICAgICAgICAgIGRhdGEucHVzaChfbjMueCwgX24zLnksIF9uMy56KTtcclxuICAgICAgICAgIGRhdGEucHVzaChfY29sb3IueCwgX2NvbG9yLnksIF9jb2xvci56KTtcclxuICAgICAgICAgIGRlYnVnV3JhcHBlci5udW1UcmlEYXRhKys7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUaGUgc291cmNlIGNvZGUgKHN0cmluZykgb2YgdGhlIGluIHBoeXNpY3NEZWJ1ZyB1c2VkIHZlcnkgc2ltcGxlIHZlcnRleFNoYWRlci5cclxuICAgICAqICBIYW5kbGluZyB0aGUgcHJvamVjdGlvbiAod2hpY2ggaW5jbHVkZXMsIHZpZXcvd29ybGRbaXMgYWx3YXlzIGlkZW50aXR5IGluIHRoaXMgY2FzZV0vcHJvamVjdGlvbiBpbiBGdWRnZSkuIEluY3JlYXNpbmcgdGhlIHNpemUgb2Ygc2luZ2xlIHBvaW50cyBkcmF3bi5cclxuICAgICAqICBBbmQgdHJhbnNmZXIgcG9zaXRpb24gY29sb3IgdG8gdGhlIGZyYWdtZW50U2hhZGVyLiAqL1xyXG4gICAgcHJpdmF0ZSB2ZXJ0ZXhTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIGBcclxuXHRcdFx0cHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XHJcblx0XHRcdGF0dHJpYnV0ZSB2ZWMzIGFQb3NpdGlvbjtcclxuXHRcdFx0YXR0cmlidXRlIHZlYzMgYUNvbG9yO1xyXG5cdFx0XHRhdHRyaWJ1dGUgdmVjMyBhTm9ybWFsO1xyXG5cdFx0XHR2YXJ5aW5nIHZlYzMgdlBvc2l0aW9uO1xyXG5cdFx0XHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcclxuXHRcdFx0dmFyeWluZyB2ZWMzIHZDb2xvcjtcclxuXHRcdFx0dW5pZm9ybSBtYXQ0IHVfbXR4TWVzaFRvVmlldztcclxuXHJcblx0XHRcdHZvaWQgbWFpbigpIHtcclxuXHRcdFx0XHR2UG9zaXRpb24gPSBhUG9zaXRpb247XHJcblx0XHRcdFx0dkNvbG9yID0gYUNvbG9yO1xyXG5cdFx0XHRcdHZOb3JtYWwgPSBhTm9ybWFsO1xyXG5cdFx0XHRcdGdsX1Bvc2l0aW9uID0gdV9tdHhNZXNoVG9WaWV3ICogdmVjNChhUG9zaXRpb24sMS4wKTtcclxuXHRcdFx0XHRnbF9Qb2ludFNpemUgPSA2LjA7XHJcblx0XHRcdH1gO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUaGUgc291cmNlIGNvZGUgKHN0cmluZykgb2YgdGhlIGluIHBoeXNpY3NEZWJ1ZyB1c2VkIHN1cGVyIHNpbXBsZSBmcmFnbWVudFNoYWRlci4gVW5saXQgLSBvbmx5IGNvbG9yaXppbmcgdGhlIGRyYXduIHBpeGVscywgbm9ybWFscy9wb3NpdGlvbiBhcmUgZ2l2ZW4gdG8gbWFrZSBpdCBleHBhbmRhYmxlICovXHJcbiAgICBwcml2YXRlIGZyYWdtZW50U2hhZGVyU291cmNlKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiBgXHJcbiAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG5cdFx0XHR2YXJ5aW5nIHZlYzMgdlBvc2l0aW9uO1xyXG5cdFx0XHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcclxuXHRcdFx0dmFyeWluZyB2ZWMzIHZDb2xvcjtcclxuXHJcblx0XHRcdHZvaWQgbWFpbigpIHtcclxuXHRcdFx0XHRnbF9GcmFnQ29sb3IgPSB2ZWM0KHZDb2xvciwgMS4wKTtcclxuXHRcdFx0fWA7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxufSIsIlxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBBIHBoeXNpY2FsIGNvbm5lY3Rpb24gYmV0d2VlbiB0d28gYm9kaWVzIHdpdGggYSBkZWZpbmVkIGF4ZSBvZiB0cmFuc2xhdGlvbiBhbmQgcm90YXRpb24uIFR3byBEZWdyZWVzIG9mIEZyZWVkb20gaW4gdGhlIGRlZmluZWQgYXhpcy5cclxuICAgKiBUd28gUmlnaWRCb2RpZXMgbmVlZCB0byBiZSBkZWZpbmVkIHRvIHVzZSBpdC4gQSBtb3RvciBjYW4gYmUgZGVmaW5lZCBmb3Igcm90YXRpb24gYW5kIHRyYW5zbGF0aW9uLCBhbG9uZyB3aXRoIHNwcmluZyBzZXR0aW5ncy5cclxuICAgKiBcclxuICAgKiBgYGBwbGFpbnRleHRcclxuICAgKiAgICAgICAgICBKb2ludEhvbGRlciAtIGJvZHlBbmNob3JcclxuICAgKiAgICAgICAgICAgICAgICAgICAg4pSM4pSA4pSA4pSA4pSQXHJcbiAgICogICAgICAgICAgICAgICAgICAgIOKUgiAgIOKUglxyXG4gICAqICAgICAgICAgICA84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSCICAg4pSC4pSA4pSA4pSA4pSA4pSA4pSAPiB0aWVkIGJvZHksIHNsaWRpbmcgb24gYXhpcyA9IDFzdCBkZWdyZWUgb2YgZnJlZWRvbVxyXG4gICAqICAgICAgICAgICAgICAgICAgICDilIIgICDilIIgICAgICAgIHJvdGF0aW5nIGFyb3VuZCBheGlzID0gMm5kIGRlZ3JlZSBvZiBmcmVlZG9tIFxyXG4gICAqICAgICAgICAgICAgICAgICAgICDilJTilIDilIDilIDilJhcclxuICAgKiBgYGAgIFxyXG4gICAqIEBhdXRob3IgTWFya28gRmVocmVuYmFjaCwgSEZVLCAyMDIwIHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgSm9pbnRDeWxpbmRyaWNhbCBleHRlbmRzIEpvaW50QXhpYWwge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IEpvaW50LnJlZ2lzdGVyU3ViY2xhc3MoSm9pbnRDeWxpbmRyaWNhbCk7XHJcbiAgICAjc3ByaW5nRGFtcGluZ1JvdGF0aW9uOiBudW1iZXIgPSAwO1xyXG4gICAgI3NwcmluZ0ZyZXF1ZW5jeVJvdGF0aW9uOiBudW1iZXIgPSAwO1xyXG5cclxuICAgICNtb3RvckZvcmNlOiBudW1iZXIgPSAwO1xyXG5cclxuICAgICNtYXhSb3RvcjogbnVtYmVyID0gMzYwO1xyXG4gICAgI21pblJvdG9yOiBudW1iZXIgPSAwO1xyXG4gICAgI3JvdG9yVG9ycXVlOiBudW1iZXIgPSAwO1xyXG4gICAgI3JvdG9yU3BlZWQ6IG51bWJlciA9IDA7XHJcblxyXG4gICAgI3JvdG9yOiBPSU1PLlJvdGF0aW9uYWxMaW1pdE1vdG9yO1xyXG4gICAgI3JvdG9yU3ByaW5nRGFtcGVyOiBPSU1PLlNwcmluZ0RhbXBlcjtcclxuXHJcbiAgICBwcm90ZWN0ZWQgam9pbnQ6IE9JTU8uQ3lsaW5kcmljYWxKb2ludDtcclxuICAgIHByb3RlY3RlZCBjb25maWc6IE9JTU8uQ3lsaW5kcmljYWxKb2ludENvbmZpZyA9IG5ldyBPSU1PLkN5bGluZHJpY2FsSm9pbnRDb25maWcoKTtcclxuICAgIHByb3RlY3RlZCBtb3RvcjogT0lNTy5UcmFuc2xhdGlvbmFsTGltaXRNb3RvcjtcclxuXHJcblxyXG4gICAgLyoqIENyZWF0aW5nIGEgY3lsaW5kcmljYWwgam9pbnQgYmV0d2VlbiB0d28gQ29tcG9uZW50UmlnaWRib2RpZXMgbW92aW5nIG9uIG9uZSBheGlzIGFuZCByb3RhdGluZyBhcm91bmQgYW5vdGhlciBib3VuZCBvbiBhIGxvY2FsIGFuY2hvcnBvaW50LiAqL1xyXG4gICAgY29uc3RydWN0b3IoX2JvZHlBbmNob3I6IENvbXBvbmVudFJpZ2lkYm9keSA9IG51bGwsIF9ib2R5VGllZDogQ29tcG9uZW50UmlnaWRib2R5ID0gbnVsbCwgX2F4aXM6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygwLCAxLCAwKSwgX2xvY2FsQW5jaG9yOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMCwgMCwgMCkpIHtcclxuICAgICAgc3VwZXIoX2JvZHlBbmNob3IsIF9ib2R5VGllZCwgX2F4aXMsIF9sb2NhbEFuY2hvcik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIEdldC9TZXQgdHJhbnNmb3Igb2YgZnVkZ2UgcHJvcGVydGllcyB0byB0aGUgcGh5c2ljcyBlbmdpbmVcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkYW1waW5nIG9mIHRoZSBzcHJpbmcuIDEgZXF1YWxzIGNvbXBsZXRseSBkYW1wZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQgc3ByaW5nRGFtcGluZyhfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICBzdXBlci5zcHJpbmdEYW1waW5nID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldFRyYW5zbGF0aW9uYWxTcHJpbmdEYW1wZXIoKS5kYW1waW5nUmF0aW8gPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZnJlcXVlbmN5IG9mIHRoZSBzcHJpbmcgaW4gSHouIEF0IDAgdGhlIHNwcmluZyBpcyByaWdpZCwgZXF1YWxzIG5vIHNwcmluZy4gVGhlIHNtYWxsZXIgdGhlIHZhbHVlIHRoZSBsZXNzIHJlc3RyaWN0aXZlIGlzIHRoZSBzcHJpbmcuXHJcbiAgICAqL1xyXG4gICAgcHVibGljIHNldCBzcHJpbmdGcmVxdWVuY3koX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgc3VwZXIuc3ByaW5nRnJlcXVlbmN5ID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldFRyYW5zbGF0aW9uYWxTcHJpbmdEYW1wZXIoKS5mcmVxdWVuY3kgPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFRoZSBkYW1waW5nIG9mIHRoZSBzcHJpbmcuIDEgZXF1YWxzIGNvbXBsZXRseSBkYW1wZWQuIEluZmx1ZW5jaW5nIFRPUlFVRSAvIFJPVEFUSU9OXHJcbiAgICAqL1xyXG4gICAgZ2V0IHNwcmluZ0RhbXBpbmdSb3RhdGlvbigpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jc3ByaW5nRGFtcGluZ1JvdGF0aW9uO1xyXG4gICAgfVxyXG4gICAgc2V0IHNwcmluZ0RhbXBpbmdSb3RhdGlvbihfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNzcHJpbmdEYW1waW5nUm90YXRpb24gPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0Um90YXRpb25hbFNwcmluZ0RhbXBlcigpLmRhbXBpbmdSYXRpbyA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmcmVxdWVuY3kgb2YgdGhlIHNwcmluZyBpbiBIei4gQXQgMCB0aGUgc3ByaW5nIGlzIHJpZ2lkLCBlcXVhbHMgbm8gc3ByaW5nLiBJbmZsdWVuY2luZyBUT1JRVUUgLyBST1RBVElPTlxyXG4gICAgKi9cclxuICAgIGdldCBzcHJpbmdGcmVxdWVuY3lSb3RhdGlvbigpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jc3ByaW5nRnJlcXVlbmN5Um90YXRpb247XHJcbiAgICB9XHJcbiAgICBzZXQgc3ByaW5nRnJlcXVlbmN5Um90YXRpb24oX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jc3ByaW5nRnJlcXVlbmN5Um90YXRpb24gPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0Um90YXRpb25hbFNwcmluZ0RhbXBlcigpLmZyZXF1ZW5jeSA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgICogVGhlIFVwcGVyIExpbWl0IG9mIG1vdmVtZW50IGFsb25nIHRoZSBheGlzIG9mIHRoaXMgam9pbnQuIFRoZSBsaW1pdGVyIGlzIGRpc2FibGUgaWYgbG93ZXJMaW1pdCA+IHVwcGVyTGltaXQuIEF4aXMtQW5nbGUgbWVhc3VyZWQgaW4gRGVncmVlLlxyXG4gICAgICovXHJcbiAgICBnZXQgbWF4Um90b3IoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI21heFJvdG9yO1xyXG4gICAgfVxyXG4gICAgc2V0IG1heFJvdG9yKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI21heFJvdG9yID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldFJvdGF0aW9uYWxMaW1pdE1vdG9yKCkudXBwZXJMaW1pdCA9IF92YWx1ZSAqIE1hdGguUEkgLyAxODA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAgKiBUaGUgTG93ZXIgTGltaXQgb2YgbW92ZW1lbnQgYWxvbmcgdGhlIGF4aXMgb2YgdGhpcyBqb2ludC4gVGhlIGxpbWl0ZXIgaXMgZGlzYWJsZSBpZiBsb3dlckxpbWl0ID4gdXBwZXJMaW1pdC4gQXhpcyBBbmdsZSBtZWFzdXJlZCBpbiBEZWdyZWUuXHJcbiAgICAgKi9cclxuICAgIGdldCBtaW5Sb3RvcigpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jbWluUm90b3I7XHJcbiAgICB9XHJcbiAgICBzZXQgbWluUm90b3IoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jbWluUm90b3IgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0Um90YXRpb25hbExpbWl0TW90b3IoKS5sb3dlckxpbWl0ID0gX3ZhbHVlICogTWF0aC5QSSAvIDE4MDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICAqIFRoZSB0YXJnZXQgcm90YXRpb25hbCBzcGVlZCBvZiB0aGUgbW90b3IgaW4gbS9zLiBcclxuICAgICAqL1xyXG4gICAgZ2V0IHJvdG9yU3BlZWQoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3JvdG9yU3BlZWQ7XHJcbiAgICB9XHJcbiAgICBzZXQgcm90b3JTcGVlZChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNyb3RvclNwZWVkID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldFJvdGF0aW9uYWxMaW1pdE1vdG9yKCkubW90b3JTcGVlZCA9IF92YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICAqIFRoZSBtYXhpbXVtIG1vdG9yIHRvcnF1ZSBpbiBOZXd0b24uIGZvcmNlIDw9IDAgZXF1YWxzIGRpc2FibGVkLiBcclxuICAgICAqL1xyXG4gICAgZ2V0IHJvdG9yVG9ycXVlKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNyb3RvclRvcnF1ZTtcclxuICAgIH1cclxuICAgIHNldCByb3RvclRvcnF1ZShfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNyb3RvclRvcnF1ZSA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRSb3RhdGlvbmFsTGltaXRNb3RvcigpLm1vdG9yVG9ycXVlID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIFRoZSBVcHBlciBMaW1pdCBvZiBtb3ZlbWVudCBhbG9uZyB0aGUgYXhpcyBvZiB0aGlzIGpvaW50LiBUaGUgbGltaXRlciBpcyBkaXNhYmxlIGlmIGxvd2VyTGltaXQgPiB1cHBlckxpbWl0LiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldCBtYXhNb3RvcihfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICBzdXBlci5tYXhNb3RvciA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbClcclxuICAgICAgICB0aGlzLmpvaW50LmdldFRyYW5zbGF0aW9uYWxMaW1pdE1vdG9yKCkudXBwZXJMaW1pdCA9IF92YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICAqIFRoZSBMb3dlciBMaW1pdCBvZiBtb3ZlbWVudCBhbG9uZyB0aGUgYXhpcyBvZiB0aGlzIGpvaW50LiBUaGUgbGltaXRlciBpcyBkaXNhYmxlIGlmIGxvd2VyTGltaXQgPiB1cHBlckxpbWl0LiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldCBtaW5Nb3RvcihfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICBzdXBlci5taW5Nb3RvciA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbClcclxuICAgICAgICB0aGlzLmpvaW50LmdldFRyYW5zbGF0aW9uYWxMaW1pdE1vdG9yKCkubG93ZXJMaW1pdCA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IG1vdG9yU3BlZWQoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgc3VwZXIubW90b3JTcGVlZCA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbClcclxuICAgICAgICB0aGlzLmpvaW50LmdldFRyYW5zbGF0aW9uYWxMaW1pdE1vdG9yKCkubW90b3JTcGVlZCA9IF92YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICAqIFRoZSBtYXhpbXVtIG1vdG9yIGZvcmNlIGluIE5ld3Rvbi4gZm9yY2UgPD0gMCBlcXVhbHMgZGlzYWJsZWQuIFxyXG4gICAgICovXHJcbiAgICBnZXQgbW90b3JGb3JjZSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jbW90b3JGb3JjZTtcclxuICAgIH1cclxuICAgIHNldCBtb3RvckZvcmNlKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI21vdG9yRm9yY2UgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0VHJhbnNsYXRpb25hbExpbWl0TW90b3IoKS5tb3RvckZvcmNlID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBTYXZpbmcvTG9hZGluZ1xyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB0aGlzLiNnZXRNdXRhdG9yKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgdGhpcy4jbXV0YXRlKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIFxyXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICB0aGlzLiNtdXRhdGUoX211dGF0b3IpO1xyXG4gICAgICB0aGlzLmRlbGV0ZUZyb21NdXRhdG9yKF9tdXRhdG9yLCB0aGlzLiNnZXRNdXRhdG9yKCkpO1xyXG4gICAgICBzdXBlci5tdXRhdGUoX211dGF0b3IpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSBzdXBlci5nZXRNdXRhdG9yKCk7XHJcbiAgICAgIE9iamVjdC5hc3NpZ24obXV0YXRvciwgdGhpcy4jZ2V0TXV0YXRvcigpKTtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgI2dldE11dGF0b3IgPSAoKTogTXV0YXRvciA9PiB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0ge1xyXG4gICAgICAgIG1vdG9yRm9yY2U6IHRoaXMubW90b3JGb3JjZSxcclxuICAgICAgICBzcHJpbmdEYW1waW5nUm90YXRpb246IHRoaXMuc3ByaW5nRGFtcGluZ1JvdGF0aW9uLFxyXG4gICAgICAgIHNwcmluZ0ZyZXF1ZW5jeVJvdGF0aW9uOiB0aGlzLnNwcmluZ0ZyZXF1ZW5jeVJvdGF0aW9uLFxyXG4gICAgICAgIG1heFJvdG9yOiB0aGlzLm1heFJvdG9yLFxyXG4gICAgICAgIG1pblJvdG9yOiB0aGlzLm1pblJvdG9yLFxyXG4gICAgICAgIHJvdG9yVG9ycXVlOiB0aGlzLnJvdG9yVG9ycXVlLFxyXG4gICAgICAgIHJvdG9yU3BlZWQ6IHRoaXMucm90b3JTcGVlZFxyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgI211dGF0ZSA9IChfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQgPT4ge1xyXG4gICAgICB0aGlzLm1vdG9yRm9yY2UgPSBfbXV0YXRvci5tb3RvckZvcmNlO1xyXG4gICAgICB0aGlzLnJvdG9yVG9ycXVlID0gX211dGF0b3Iucm90b3JUb3JxdWU7XHJcbiAgICAgIHRoaXMucm90b3JTcGVlZCA9IF9tdXRhdG9yLnJvdG9yU3BlZWQ7XHJcbiAgICAgIHRoaXMubWF4Um90b3IgPSBfbXV0YXRvci5tYXhSb3RvcjtcclxuICAgICAgdGhpcy5taW5Sb3RvciA9IF9tdXRhdG9yLm1pblJvdG9yO1xyXG4gICAgICB0aGlzLnNwcmluZ0RhbXBpbmdSb3RhdGlvbiA9IF9tdXRhdG9yLnNwcmluZ0RhbXBpbmdSb3RhdGlvbjtcclxuICAgICAgdGhpcy5zcHJpbmdGcmVxdWVuY3lSb3RhdGlvbiA9IF9tdXRhdG9yLnNwcmluZ0ZyZXF1ZW5jeVJvdGF0aW9uO1xyXG4gICAgICB0aGlzLnNwcmluZ0ZyZXF1ZW5jeSA9IF9tdXRhdG9yLnNwcmluZ0ZyZXF1ZW5jeTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIHByb3RlY3RlZCBjb25zdHJ1Y3RKb2ludCgpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jcm90b3JTcHJpbmdEYW1wZXIgPSBuZXcgT0lNTy5TcHJpbmdEYW1wZXIoKS5zZXRTcHJpbmcodGhpcy5zcHJpbmdGcmVxdWVuY3lSb3RhdGlvbiwgdGhpcy5zcHJpbmdEYW1waW5nUm90YXRpb24pO1xyXG5cclxuICAgICAgdGhpcy5tb3RvciA9IG5ldyBPSU1PLlRyYW5zbGF0aW9uYWxMaW1pdE1vdG9yKCkuc2V0TGltaXRzKHN1cGVyLm1pbk1vdG9yLCBzdXBlci5tYXhNb3Rvcik7XHJcbiAgICAgIHRoaXMubW90b3Iuc2V0TW90b3Ioc3VwZXIubW90b3JTcGVlZCwgdGhpcy5tb3RvckZvcmNlKTtcclxuICAgICAgdGhpcy4jcm90b3IgPSBuZXcgT0lNTy5Sb3RhdGlvbmFsTGltaXRNb3RvcigpLnNldExpbWl0cyh0aGlzLm1pblJvdG9yICogTWF0aC5QSSAvIDE4MCwgdGhpcy5tYXhSb3RvciAqIE1hdGguUEkgLyAxODApO1xyXG4gICAgICB0aGlzLiNyb3Rvci5zZXRNb3Rvcih0aGlzLnJvdG9yU3BlZWQsIHRoaXMucm90b3JUb3JxdWUpO1xyXG5cclxuICAgICAgdGhpcy5jb25maWcgPSBuZXcgT0lNTy5DeWxpbmRyaWNhbEpvaW50Q29uZmlnKCk7XHJcbiAgICAgIHN1cGVyLmNvbnN0cnVjdEpvaW50KCk7XHJcblxyXG4gICAgICB0aGlzLmNvbmZpZy50cmFuc2xhdGlvbmFsU3ByaW5nRGFtcGVyID0gdGhpcy5zcHJpbmdEYW1wZXI7XHJcbiAgICAgIHRoaXMuY29uZmlnLnRyYW5zbGF0aW9uYWxMaW1pdE1vdG9yID0gdGhpcy5tb3RvcjtcclxuICAgICAgdGhpcy5jb25maWcucm90YXRpb25hbExpbWl0TW90b3IgPSB0aGlzLiNyb3RvcjtcclxuICAgICAgdGhpcy5jb25maWcucm90YXRpb25hbFNwcmluZ0RhbXBlciA9IHRoaXMuI3JvdG9yU3ByaW5nRGFtcGVyO1xyXG5cclxuICAgICAgdGhpcy5qb2ludCA9IG5ldyBPSU1PLkN5bGluZHJpY2FsSm9pbnQodGhpcy5jb25maWcpO1xyXG4gICAgICB0aGlzLmNvbmZpZ3VyZUpvaW50KCk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICAgKiBBIHBoeXNpY2FsIGNvbm5lY3Rpb24gYmV0d2VlbiB0d28gYm9kaWVzIHdpdGggYSBkZWZpbmVkIGF4ZSBtb3ZlbWVudC5cclxuICAgICAqIFVzZWQgdG8gY3JlYXRlIGEgc2xpZGluZyBqb2ludCBhbG9uZyBvbmUgYXhpcy4gVHdvIFJpZ2lkQm9kaWVzIG5lZWQgdG8gYmUgZGVmaW5lZCB0byB1c2UgaXQuXHJcbiAgICAgKiBBIG1vdG9yIGNhbiBiZSBkZWZpbmVkIHRvIG1vdmUgdGhlIGNvbm5lY3RlZCBhbG9uZyB0aGUgZGVmaW5lZCBheGlzLiBHcmVhdCB0byBjb25zdHJ1Y3Qgc3RhbmRhcmQgc3ByaW5ncyBvciBwaHlzaWNhbCBzbGlkZXJzLlxyXG4gICAgICogXHJcbiAgICAgKiBgYGBwbGFpbnRleHRcclxuICAgICAqICAgICAgICAgIEpvaW50SG9sZGVyIC0gYm9keUFuY2hvclxyXG4gICAgICogICAgICAgICAgICAgICAgICAgIOKUjOKUgOKUgOKUgOKUkFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgIOKUgiAgIOKUglxyXG4gICAgICogICAgICAgICAgIDzilIDilIDilIDilIDilIDilIDilIDilIDilIIgICDilILilIDilIDilIDilIDilIDilIA+IHRpZWQgYm9keSwgc2xpZGluZyBvbiBvbmUgQXhpcywgMSBEZWdyZWUgb2YgRnJlZWRvbVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgIOKUgiAgIOKUglxyXG4gICAgICogICAgICAgICAgICAgICAgICAgIOKUlOKUgOKUgOKUgOKUmFxyXG4gICAgICogYGBgXHJcbiAgICAgKiBAYXV0aG9yIE1hcmtvIEZlaHJlbmJhY2gsIEhGVSwgMjAyMCB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxXHJcbiAgICAgKi9cclxuICBleHBvcnQgY2xhc3MgSm9pbnRQcmlzbWF0aWMgZXh0ZW5kcyBKb2ludEF4aWFsIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBKb2ludC5yZWdpc3RlclN1YmNsYXNzKEpvaW50UHJpc21hdGljKTtcclxuXHJcbiAgICAjbW90b3JGb3JjZTogbnVtYmVyID0gMDtcclxuXHJcbiAgICBwcm90ZWN0ZWQgam9pbnQ6IE9JTU8uUHJpc21hdGljSm9pbnQ7XHJcbiAgICBwcm90ZWN0ZWQgY29uZmlnOiBPSU1PLlByaXNtYXRpY0pvaW50Q29uZmlnID0gbmV3IE9JTU8uUHJpc21hdGljSm9pbnRDb25maWcoKTtcclxuICAgIHByb3RlY3RlZCBtb3RvcjogT0lNTy5UcmFuc2xhdGlvbmFsTGltaXRNb3RvcjtcclxuICAgIC8vSW50ZXJuYWxseSB1c2VkIHZhcmlhYmxlcyAtIEpvaW50IFByb3BlcnRpZXMgdGhhdCBhcmUgdXNlZCBldmVuIHdoZW4gbm8gYWN0dWFsIGpvaW50IGlzIGN1cnJlbnRseSBleGlzdGVuZFxyXG5cclxuICAgIC8qKiBDcmVhdGluZyBhIHByaXNtYXRpYyBqb2ludCBiZXR3ZWVuIHR3byBDb21wb25lbnRSaWdpZGJvZGllcyBvbmx5IG1vdmluZyBvbiBvbmUgYXhpcyBib3VuZCBvbiBhIGxvY2FsIGFuY2hvcnBvaW50LiAqL1xyXG4gICAgY29uc3RydWN0b3IoX2JvZHlBbmNob3I6IENvbXBvbmVudFJpZ2lkYm9keSA9IG51bGwsIF9ib2R5VGllZDogQ29tcG9uZW50UmlnaWRib2R5ID0gbnVsbCwgX2F4aXM6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygwLCAxLCAwKSwgX2xvY2FsQW5jaG9yOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMCwgMCwgMCkpIHtcclxuICAgICAgc3VwZXIoX2JvZHlBbmNob3IsIF9ib2R5VGllZCwgX2F4aXMsIF9sb2NhbEFuY2hvcik7XHJcblxyXG4gICAgICB0aGlzLm1heE1vdG9yID0gMTA7XHJcbiAgICAgIHRoaXMubWluTW90b3IgPSAtMTA7XHJcbiAgICB9XHJcbiAgICAvLyNyZWdpb24gR2V0L1NldCB0cmFuc2ZvciBvZiBmdWRnZSBwcm9wZXJ0aWVzIHRvIHRoZSBwaHlzaWNzIGVuZ2luZVxyXG4gICAgLyoqXHJcbiAgICAgICogVGhlIG1heGltdW0gbW90b3IgZm9yY2UgaW4gTmV3dG9uLiBmb3JjZSA8PSAwIGVxdWFscyBkaXNhYmxlZC4gVGhpcyBpcyB0aGUgZm9yY2UgdGhhdCB0aGUgbW90b3IgaXMgdXNpbmcgdG8gaG9sZCB0aGUgcG9zaXRpb24sIG9yIHJlYWNoIGl0IGlmIGEgbW90b3JTcGVlZCBpcyBkZWZpbmVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG1vdG9yRm9yY2UoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI21vdG9yRm9yY2U7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IG1vdG9yRm9yY2UoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jbW90b3JGb3JjZSA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRMaW1pdE1vdG9yKCkubW90b3JGb3JjZSA9IF92YWx1ZTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBTYXZpbmcvTG9hZGluZ1xyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgbW90b3JGb3JjZTogdGhpcy5tb3RvckZvcmNlLFxyXG4gICAgICAgIFtzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXTogc3VwZXIuc2VyaWFsaXplKClcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgdGhpcy5tb3RvckZvcmNlID0gX3NlcmlhbGl6YXRpb24ubW90b3JGb3JjZTtcclxuICAgICAgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSBzdXBlci5nZXRNdXRhdG9yKCk7XHJcbiAgICAgIG11dGF0b3IubW90b3JGb3JjZSA9IHRoaXMubW90b3JGb3JjZTtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IFByb21pc2U8dm9pZD4geyBcclxuICAgICAgdGhpcy5tb3RvckZvcmNlID0gX211dGF0b3IubW90b3JGb3JjZTtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLm1vdG9yRm9yY2U7XHJcbiAgICAgIHN1cGVyLm11dGF0ZShfbXV0YXRvcik7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvKiogQWN0dWFsIGNyZWF0aW9uIG9mIGEgam9pbnQgaW4gdGhlIE9pbW9QaHlzaWNzIHN5c3RlbSAqL1xyXG4gICAgcHJvdGVjdGVkIGNvbnN0cnVjdEpvaW50KCk6IHZvaWQge1xyXG4gICAgICB0aGlzLm1vdG9yID0gbmV3IE9JTU8uVHJhbnNsYXRpb25hbExpbWl0TW90b3IoKS5zZXRMaW1pdHModGhpcy5taW5Nb3RvciwgdGhpcy5tYXhNb3Rvcik7IC8vQ3JlYXRlIG1vdG9yIHNldHRpbmdzLCB0byBob2xkIHBvc2l0aW9ucywgc2V0IGNvbnN0cmFpbnQgbWluL21heFxyXG4gICAgICB0aGlzLm1vdG9yLnNldE1vdG9yKHRoaXMubW90b3JTcGVlZCwgdGhpcy5tb3RvckZvcmNlKTtcclxuXHJcbiAgICAgIHRoaXMuY29uZmlnID0gbmV3IE9JTU8uUHJpc21hdGljSm9pbnRDb25maWcoKTsgLy9DcmVhdGUgYSBzcGVjaWZpYyBjb25maWcgZm9yIHRoaXMgam9pbnQgdHlwZSB0aGF0IGlzIGNhbGN1bGF0aW5nIHRoZSBsb2NhbCBheGlzIGZvciBib3RoIGJvZGllc1xyXG4gICAgICBzdXBlci5jb25zdHJ1Y3RKb2ludCgpO1xyXG5cclxuICAgICAgdGhpcy5jb25maWcuc3ByaW5nRGFtcGVyID0gdGhpcy5zcHJpbmdEYW1wZXI7IC8vVGVsbGluZyB0aGUgY29uZmlnIHRvIHVzZSB0aGUgbW90b3Ivc3ByaW5nIG9mIHRoZSBGdWRnZSBDb21wb25lbnRcclxuICAgICAgdGhpcy5jb25maWcubGltaXRNb3RvciA9IHRoaXMubW90b3I7XHJcblxyXG4gICAgICB0aGlzLmpvaW50ID0gbmV3IE9JTU8uUHJpc21hdGljSm9pbnQodGhpcy5jb25maWcpO1xyXG4gICAgICB0aGlzLmNvbmZpZ3VyZUpvaW50KCk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICAqIEEgcGh5c2ljYWwgY29ubmVjdGlvbiBiZXR3ZWVuIHR3byBib2RpZXMsIGRlc2lnbmVkIHRvIHNpbXVsYXRlIGJlaGF2aW91ciB3aXRoaW4gYSByZWFsIGJvZHkuIEl0IGhhcyB0d28gYXhpcywgYSBzd2luZyBhbmQgdHdpc3QgYXhpcywgYW5kIGFsc28gdGhlIHBlcnBlbmRpY3VsYXIgYXhpcywgXHJcbiAgICAqIHNpbWlsYXIgdG8gYSBTcGhlcmljYWwgam9pbnQsIGJ1dCBtb3JlIHJlc3RyaWN0aXZlIGluIGl0J3MgYW5nbGVzIGFuZCBvbmx5IHR3byBkZWdyZWVzIG9mIGZyZWVkb20uIFR3byBSaWdpZEJvZGllcyBuZWVkIHRvIGJlIGRlZmluZWQgdG8gdXNlIGl0LiBNb3N0bHkgdXNlZCB0byBjcmVhdGUgaHVtYW5saWtlIGpvaW50cyB0aGF0IGJlaGF2ZSBsaWtlIGEgXHJcbiAgICAqIGxpZmVsZXNzIGJvZHkuXHJcbiAgICAqIGBgYHBsYWludGV4dCAgICAgICAgXHJcbiAgICAqICAgICAgICAgICAgICAgICAgXHJcbiAgICAqICAgICAgICAgICAgICAgICAgICAgIGFuY2hvciAtIGl0IGNhbiB0d2lzdCBvbiBvbmUgYXhpcyBhbmQgc3dpbmcgb24gYW5vdGhlclxyXG4gICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcclxuICAgICogICAgICAgICB6ICAgICAgICAgICAg4pSM4pSA4pSA4pSA4pSQIOKUgiDilIzilIDilIDilIDilJBcclxuICAgICogICAgICAgICDihpEgICAgICAgICAgICDilIIgICDilIIg4oaTIOKUgiAgIOKUgiAgICAgICAgZS5nLiB6ID0gVHdpc3RBeGlzLCBpdCBjYW4gcm90YXRlIGluLWl0c2VsZiBhcm91bmQgdGhpcyBheGlzIFxyXG4gICAgKiAgICAteCDihpDilIDilLzilIDihpIgeCAgICAgICAg4pSCICAg4pSCIHgg4pSCICAg4pSCICAgICAgICBlLmcuIHggPSBTd2luZ0F4aXMsIGl0IGNhbiByb3RhdGUgYW5jaG9yZWQgYXJvdW5kIHRoZSBiYXNlIG9uIHRoaXMgYXhpcyAgIFxyXG4gICAgKiAgICAgICAgIOKGkyAgICAgICAgICAgIOKUgiAgIOKUgiAgIOKUgiAgIOKUgiAgICAgICAgICAgXHJcbiAgICAqICAgICAgICAteiAgICAgICAgICAgIOKUlOKUgOKUgOKUgOKUmCAgIOKUlOKUgOKUgOKUgOKUmCAgICAgICAgIGUuZy4geW91IGNhbiB0d2lzdCB0aGUgbGVnIGluLWl0c2VsZiB0byBhIGNlcnRhaW4gZGVncmVlLFxyXG4gICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0IGFsc28gcm90YXRlIGl0IGZvcndhcmQvYmFja3dhcmQvbGVmdC9yaWdodCB0byBhIGNlcnRhaW4gZGVncmVlXHJcbiAgICAqICAgICAgICAgICAgICAgIGJvZHlBbmNob3IgICAgICAgICAgYm9keVRpZWRcclxuICAgICogICAgICAgICAgICAgIChlLmcuIHBlbHZpcykgICAgICAgICAoZS5nLiB1cHBlci1sZWcpXHJcbiAgICAqIFxyXG4gICAgKiBgYGBcclxuICAgICogVHdpc3QgZXF1YWxzIGEgcm90YXRpb24gYXJvdW5kIGEgcG9pbnQgd2l0aG91dCBtb3Zpbmcgb24gYW4gYXhpcy5cclxuICAgICogU3dpbmcgZXF1YWxzIGEgcm90YXRpb24gb24gYSBwb2ludCB3aXRoIGEgbW92aW5nIGxvY2FsIGF4aXMuXHJcbiAgICAgKiBAYXV0aG9yIE1hcmtvIEZlaHJlbmJhY2gsIEhGVSwgMjAyMCB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxXHJcbiAgICAqL1xyXG5cclxuICBleHBvcnQgY2xhc3MgSm9pbnRSYWdkb2xsIGV4dGVuZHMgSm9pbnQge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IEpvaW50LnJlZ2lzdGVyU3ViY2xhc3MoSm9pbnRSYWdkb2xsKTtcclxuXHJcblxyXG4gICAgI3NwcmluZ0RhbXBpbmdUd2lzdDogbnVtYmVyID0gMDtcclxuICAgICNzcHJpbmdGcmVxdWVuY3lUd2lzdDogbnVtYmVyID0gMDtcclxuXHJcbiAgICAjc3ByaW5nRGFtcGluZ1N3aW5nOiBudW1iZXIgPSAwO1xyXG4gICAgI3NwcmluZ0ZyZXF1ZW5jeVN3aW5nOiBudW1iZXIgPSAwO1xyXG5cclxuICAgICNtYXhNb3RvclR3aXN0OiBudW1iZXIgPSAzNjA7XHJcbiAgICAjbWluTW90b3JUd2lzdDogbnVtYmVyID0gMDtcclxuICAgICNtb3RvclRvcnF1ZVR3aXN0OiBudW1iZXIgPSAwO1xyXG4gICAgI21vdG9yU3BlZWRUd2lzdDogbnVtYmVyID0gMDtcclxuXHJcbiAgICAjbW90b3JUd2lzdDogT0lNTy5Sb3RhdGlvbmFsTGltaXRNb3RvcjtcclxuICAgICNzcHJpbmdEYW1wZXJUd2lzdDogT0lNTy5TcHJpbmdEYW1wZXI7XHJcbiAgICAjc3ByaW5nRGFtcGVyU3dpbmc6IE9JTU8uU3ByaW5nRGFtcGVyO1xyXG4gICAgI2F4aXNGaXJzdDogT0lNTy5WZWMzO1xyXG4gICAgI2F4aXNTZWNvbmQ6IE9JTU8uVmVjMztcclxuXHJcblxyXG4gICAgI21heEFuZ2xlRmlyc3Q6IG51bWJlciA9IDA7XHJcbiAgICAjbWF4QW5nbGVTZWNvbmQ6IG51bWJlciA9IDA7XHJcblxyXG4gICAgcHJvdGVjdGVkIGpvaW50OiBPSU1PLlJhZ2RvbGxKb2ludDtcclxuICAgIHByb3RlY3RlZCBjb25maWc6IE9JTU8uUmFnZG9sbEpvaW50Q29uZmlnID0gbmV3IE9JTU8uUmFnZG9sbEpvaW50Q29uZmlnKCk7XHJcblxyXG4gICAgY29uc3RydWN0b3IoX2JvZHlBbmNob3I6IENvbXBvbmVudFJpZ2lkYm9keSA9IG51bGwsIF9ib2R5VGllZDogQ29tcG9uZW50UmlnaWRib2R5ID0gbnVsbCwgX2F4aXNGaXJzdDogVmVjdG9yMyA9IG5ldyBWZWN0b3IzKDEsIDAsIDApLCBfYXhpc1NlY29uZDogVmVjdG9yMyA9IG5ldyBWZWN0b3IzKDAsIDAsIDEpLCBfbG9jYWxBbmNob3I6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygwLCAwLCAwKSkge1xyXG4gICAgICBzdXBlcihfYm9keUFuY2hvciwgX2JvZHlUaWVkKTtcclxuICAgICAgdGhpcy5heGlzRmlyc3QgPSBfYXhpc0ZpcnN0O1xyXG4gICAgICB0aGlzLmF4aXNTZWNvbmQgPSBfYXhpc1NlY29uZDtcclxuICAgICAgdGhpcy5hbmNob3IgPSBfbG9jYWxBbmNob3I7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIEdldC9TZXQgdHJhbnNmb3Igb2YgZnVkZ2UgcHJvcGVydGllcyB0byB0aGUgcGh5c2ljcyBlbmdpbmVcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGF4aXMgY29ubmVjdGluZyB0aGUgdGhlIHR3byB7QGxpbmsgTm9kZX1zIGUuZy4gVmVjdG9yMygwLDEsMCkgdG8gaGF2ZSBhIHVwd2FyZCBjb25uZWN0aW9uLlxyXG4gICAgICogIFdoZW4gY2hhbmdlZCBhZnRlciBpbml0aWFsaXphdGlvbiB0aGUgam9pbnQgbmVlZHMgdG8gYmUgcmVjb25uZWN0ZWQuXHJcbiAgICAgKi9cclxuICAgIGdldCBheGlzRmlyc3QoKTogVmVjdG9yMyB7XHJcbiAgICAgIHJldHVybiBuZXcgVmVjdG9yMyh0aGlzLiNheGlzRmlyc3QueCwgdGhpcy4jYXhpc0ZpcnN0LnksIHRoaXMuI2F4aXNGaXJzdC56KTtcclxuICAgIH1cclxuICAgIHNldCBheGlzRmlyc3QoX3ZhbHVlOiBWZWN0b3IzKSB7XHJcbiAgICAgIHRoaXMuI2F4aXNGaXJzdCA9IG5ldyBPSU1PLlZlYzMoX3ZhbHVlLngsIF92YWx1ZS55LCBfdmFsdWUueik7XHJcbiAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xyXG4gICAgICB0aGlzLmRpcnR5U3RhdHVzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFRoZSBheGlzIGNvbm5lY3RpbmcgdGhlIHRoZSB0d28ge0BsaW5rIE5vZGV9cyBlLmcuIFZlY3RvcjMoMCwxLDApIHRvIGhhdmUgYSB1cHdhcmQgY29ubmVjdGlvbi5cclxuICAgICogIFdoZW4gY2hhbmdlZCBhZnRlciBpbml0aWFsaXphdGlvbiB0aGUgam9pbnQgbmVlZHMgdG8gYmUgcmVjb25uZWN0ZWQuXHJcbiAgICAqL1xyXG4gICAgZ2V0IGF4aXNTZWNvbmQoKTogVmVjdG9yMyB7XHJcbiAgICAgIHJldHVybiBuZXcgVmVjdG9yMyh0aGlzLiNheGlzU2Vjb25kLngsIHRoaXMuI2F4aXNTZWNvbmQueSwgdGhpcy4jYXhpc1NlY29uZC56KTtcclxuICAgIH1cclxuICAgIHNldCBheGlzU2Vjb25kKF92YWx1ZTogVmVjdG9yMykge1xyXG4gICAgICB0aGlzLiNheGlzU2Vjb25kID0gbmV3IE9JTU8uVmVjMyhfdmFsdWUueCwgX3ZhbHVlLnksIF92YWx1ZS56KTtcclxuICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XHJcbiAgICAgIHRoaXMuZGlydHlTdGF0dXMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtYXhpbXVtIGFuZ2xlIG9mIHJvdGF0aW9uIGFsb25nIHRoZSBmaXJzdCBheGlzLiBWYWx1ZSBuZWVkcyB0byBiZSBwb3NpdGl2ZS4gQ2hhbmdlcyBkbyByZWJ1aWxkIHRoZSBqb2ludFxyXG4gICAgICovXHJcbiAgICBnZXQgbWF4QW5nbGVGaXJzdEF4aXMoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI21heEFuZ2xlRmlyc3QgKiAxODAgLyBNYXRoLlBJO1xyXG4gICAgfVxyXG4gICAgc2V0IG1heEFuZ2xlRmlyc3RBeGlzKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI21heEFuZ2xlRmlyc3QgPSBfdmFsdWUgKiBNYXRoLlBJIC8gMTgwO1xyXG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgdGhpcy5kaXJ0eVN0YXR1cygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1heGltdW0gYW5nbGUgb2Ygcm90YXRpb24gYWxvbmcgdGhlIHNlY29uZCBheGlzLiBWYWx1ZSBuZWVkcyB0byBiZSBwb3NpdGl2ZS4gQ2hhbmdlcyBkbyByZWJ1aWxkIHRoZSBqb2ludFxyXG4gICAgICovXHJcbiAgICBnZXQgbWF4QW5nbGVTZWNvbmRBeGlzKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNtYXhBbmdsZVNlY29uZCAqIDE4MCAvIE1hdGguUEk7XHJcbiAgICB9XHJcbiAgICBzZXQgbWF4QW5nbGVTZWNvbmRBeGlzKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI21heEFuZ2xlU2Vjb25kID0gX3ZhbHVlICogTWF0aC5QSSAvIDE4MDtcclxuICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XHJcbiAgICAgIHRoaXMuZGlydHlTdGF0dXMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkYW1waW5nIG9mIHRoZSBzcHJpbmcuIDEgZXF1YWxzIGNvbXBsZXRseSBkYW1wZWQuXHJcbiAgICAgKi9cclxuICAgIGdldCBzcHJpbmdEYW1waW5nVHdpc3QoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3NwcmluZ0RhbXBpbmdUd2lzdDtcclxuICAgIH1cclxuICAgIHNldCBzcHJpbmdEYW1waW5nVHdpc3QoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jc3ByaW5nRGFtcGluZ1R3aXN0ID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldFR3aXN0U3ByaW5nRGFtcGVyKCkuZGFtcGluZ1JhdGlvID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZyZXF1ZW5jeSBvZiB0aGUgc3ByaW5nIGluIEh6LiBBdCAwIHRoZSBzcHJpbmcgaXMgcmlnaWQsIGVxdWFscyBubyBzcHJpbmcuIFRoZSBzbWFsbGVyIHRoZSB2YWx1ZSB0aGUgbGVzcyByZXN0cmljdGl2ZSBpcyB0aGUgc3ByaW5nLlxyXG4gICAgKi9cclxuICAgIGdldCBzcHJpbmdGcmVxdWVuY3lUd2lzdCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jc3ByaW5nRnJlcXVlbmN5VHdpc3Q7XHJcbiAgICB9XHJcbiAgICBzZXQgc3ByaW5nRnJlcXVlbmN5VHdpc3QoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jc3ByaW5nRnJlcXVlbmN5VHdpc3QgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0VHdpc3RTcHJpbmdEYW1wZXIoKS5mcmVxdWVuY3kgPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZGFtcGluZyBvZiB0aGUgc3ByaW5nLiAxIGVxdWFscyBjb21wbGV0bHkgZGFtcGVkLlxyXG4gICAgICovXHJcbiAgICBnZXQgc3ByaW5nRGFtcGluZ1N3aW5nKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNzcHJpbmdEYW1waW5nU3dpbmc7XHJcbiAgICB9XHJcbiAgICBzZXQgc3ByaW5nRGFtcGluZ1N3aW5nKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI3NwcmluZ0RhbXBpbmdTd2luZyA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRTd2luZ1NwcmluZ0RhbXBlcigpLmRhbXBpbmdSYXRpbyA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmcmVxdWVuY3kgb2YgdGhlIHNwcmluZyBpbiBIei4gQXQgMCB0aGUgc3ByaW5nIGlzIHJpZ2lkLCBlcXVhbHMgbm8gc3ByaW5nLiBUaGUgc21hbGxlciB0aGUgdmFsdWUgdGhlIGxlc3MgcmVzdHJpY3RpdmUgaXMgdGhlIHNwcmluZy5cclxuICAgICovXHJcbiAgICBnZXQgc3ByaW5nRnJlcXVlbmN5U3dpbmcoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3NwcmluZ0ZyZXF1ZW5jeVN3aW5nO1xyXG4gICAgfVxyXG4gICAgc2V0IHNwcmluZ0ZyZXF1ZW5jeVN3aW5nKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI3NwcmluZ0ZyZXF1ZW5jeVN3aW5nID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldFN3aW5nU3ByaW5nRGFtcGVyKCkuZnJlcXVlbmN5ID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIFRoZSBVcHBlciBMaW1pdCBvZiBtb3ZlbWVudCBhbG9uZyB0aGUgYXhpcyBvZiB0aGlzIGpvaW50LiBUaGUgbGltaXRlciBpcyBkaXNhYmxlIGlmIGxvd2VyTGltaXQgPiB1cHBlckxpbWl0LiBBeGlzLUFuZ2xlIG1lYXN1cmVkIGluIERlZ3JlZS5cclxuICAgICAqL1xyXG4gICAgZ2V0IG1heE1vdG9yVHdpc3QoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI21heE1vdG9yVHdpc3QgKiAxODAgLyBNYXRoLlBJO1xyXG4gICAgfVxyXG4gICAgc2V0IG1heE1vdG9yVHdpc3QoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgX3ZhbHVlICo9IE1hdGguUEkgLyAxODA7XHJcbiAgICAgIHRoaXMuI21heE1vdG9yVHdpc3QgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0VHdpc3RMaW1pdE1vdG9yKCkudXBwZXJMaW1pdCA9IF92YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIExvd2VyIExpbWl0IG9mIG1vdmVtZW50IGFsb25nIHRoZSBheGlzIG9mIHRoaXMgam9pbnQuIFRoZSBsaW1pdGVyIGlzIGRpc2FibGUgaWYgbG93ZXJMaW1pdCA+IHVwcGVyTGltaXQuIEF4aXMgQW5nbGUgbWVhc3VyZWQgaW4gRGVncmVlLlxyXG4gICAgICovXHJcbiAgICBnZXQgbWluTW90b3JUd2lzdCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jbWluTW90b3JUd2lzdCAqIDE4MCAvIE1hdGguUEk7XHJcbiAgICB9XHJcbiAgICBzZXQgbWluTW90b3JUd2lzdChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICBfdmFsdWUgKj0gTWF0aC5QSSAvIDE4MDtcclxuICAgICAgdGhpcy4jbWluTW90b3JUd2lzdCA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRUd2lzdExpbWl0TW90b3IoKS5sb3dlckxpbWl0ID0gX3ZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgICogVGhlIHRhcmdldCByb3RhdGlvbmFsIHNwZWVkIG9mIHRoZSBtb3RvciBpbiBtL3MuIFxyXG4gICAgICovXHJcbiAgICBnZXQgbW90b3JTcGVlZFR3aXN0KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNtb3RvclNwZWVkVHdpc3Q7XHJcbiAgICB9XHJcbiAgICBzZXQgbW90b3JTcGVlZFR3aXN0KF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI21vdG9yU3BlZWRUd2lzdCA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRUd2lzdExpbWl0TW90b3IoKS5tb3RvclNwZWVkID0gX3ZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgICogVGhlIG1heGltdW0gbW90b3IgdG9ycXVlIGluIE5ld3Rvbi4gZm9yY2UgPD0gMCBlcXVhbHMgZGlzYWJsZWQuIFxyXG4gICAgICovXHJcbiAgICBnZXQgbW90b3JUb3JxdWVUd2lzdCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jbW90b3JUb3JxdWVUd2lzdDtcclxuICAgIH1cclxuICAgIHNldCBtb3RvclRvcnF1ZVR3aXN0KF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI21vdG9yVG9ycXVlVHdpc3QgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0VHdpc3RMaW1pdE1vdG9yKCkubW90b3JUb3JxdWUgPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICogSWYgdGhlIHR3byBjb25uZWN0ZWQgUmlnaWRCb2RpZXMgY29sbGlkZSB3aXRoIGVhdGggb3RoZXIuIChEZWZhdWx0ID0gZmFsc2UpXHJcbiAgICAgKi9cclxuXHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gU2F2aW5nL0xvYWRpbmdcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gdGhpcy4jZ2V0TXV0YXRvcigpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLmF4aXNGaXJzdCA9IHRoaXMuYXhpc0ZpcnN0LnNlcmlhbGl6ZSgpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLmF4aXNTZWNvbmQgPSB0aGlzLmF4aXNTZWNvbmQuc2VyaWFsaXplKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgYXdhaXQgdGhpcy5heGlzRmlyc3QuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24uYXhpc0ZpcnN0KTtcclxuICAgICAgYXdhaXQgdGhpcy5heGlzU2Vjb25kLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLmF4aXNTZWNvbmQpO1xyXG4gICAgICB0aGlzLiNtdXRhdGUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgdGhpcy5heGlzRmlyc3QgPSBuZXcgVmVjdG9yMyguLi48bnVtYmVyW10+KE9iamVjdC52YWx1ZXMoX211dGF0b3IuYXhpc0ZpcnN0KSkpO1xyXG4gICAgICB0aGlzLmF4aXNTZWNvbmQgPSBuZXcgVmVjdG9yMyguLi48bnVtYmVyW10+KE9iamVjdC52YWx1ZXMoX211dGF0b3IuYXhpc1NlY29uZCkpKTtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLmF4aXNGaXJzdDtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLmF4aXNTZWNvbmQ7XHJcbiAgICAgIHRoaXMuI211dGF0ZShfbXV0YXRvcik7XHJcbiAgICAgIHRoaXMuZGVsZXRlRnJvbU11dGF0b3IoX211dGF0b3IsIHRoaXMuI2dldE11dGF0b3IoKSk7XHJcbiAgICAgIHN1cGVyLm11dGF0ZShfbXV0YXRvcik7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0gc3VwZXIuZ2V0TXV0YXRvcigpO1xyXG4gICAgICBPYmplY3QuYXNzaWduKG11dGF0b3IsIHRoaXMuI2dldE11dGF0b3IoKSk7XHJcbiAgICAgIG11dGF0b3IuYXhpc0ZpcnN0ID0gdGhpcy5heGlzRmlyc3QuZ2V0TXV0YXRvcigpO1xyXG4gICAgICBtdXRhdG9yLmF4aXNTZWNvbmQgPSB0aGlzLmF4aXNTZWNvbmQuZ2V0TXV0YXRvcigpO1xyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuXHJcbiAgICAjZ2V0TXV0YXRvciA9ICgpOiBNdXRhdG9yID0+IHtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSB7XHJcbiAgICAgICAgbWF4QW5nbGVGaXJzdDogdGhpcy4jbWF4QW5nbGVGaXJzdCxcclxuICAgICAgICBtYXhBbmdsZVNlY29uZDogdGhpcy4jbWF4QW5nbGVTZWNvbmQsXHJcbiAgICAgICAgc3ByaW5nRGFtcGluZ1R3aXN0OiB0aGlzLnNwcmluZ0RhbXBpbmdUd2lzdCxcclxuICAgICAgICBzcHJpbmdGcmVxdWVuY3lUd2lzdDogdGhpcy5zcHJpbmdGcmVxdWVuY3lUd2lzdCxcclxuICAgICAgICBzcHJpbmdEYW1waW5nU3dpbmc6IHRoaXMuc3ByaW5nRGFtcGluZ1N3aW5nLFxyXG4gICAgICAgIHNwcmluZ0ZyZXF1ZW5jeVN3aW5nOiB0aGlzLnNwcmluZ0ZyZXF1ZW5jeVN3aW5nLFxyXG4gICAgICAgIG1heE1vdG9yVHdpc3Q6IHRoaXMuI21heE1vdG9yVHdpc3QsXHJcbiAgICAgICAgbWluTW90b3JUd2lzdDogdGhpcy4jbWluTW90b3JUd2lzdCxcclxuICAgICAgICBtb3RvclNwZWVkVHdpc3Q6IHRoaXMubW90b3JTcGVlZFR3aXN0LFxyXG4gICAgICAgIG1vdG9yVG9ycXVlVHdpc3Q6IHRoaXMubW90b3JUb3JxdWVUd2lzdFxyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuXHJcbiAgICAjbXV0YXRlID0gKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCA9PiB7XHJcbiAgICAgIHRoaXMuI21heEFuZ2xlRmlyc3QgPSBfbXV0YXRvci5tYXhBbmdsZUZpcnN0O1xyXG4gICAgICB0aGlzLiNtYXhBbmdsZVNlY29uZCA9IF9tdXRhdG9yLm1heEFuZ2xlU2Vjb25kO1xyXG4gICAgICB0aGlzLnNwcmluZ0RhbXBpbmdUd2lzdCA9IF9tdXRhdG9yLnNwcmluZ0RhbXBpbmdUd2lzdDtcclxuICAgICAgdGhpcy5zcHJpbmdGcmVxdWVuY3lUd2lzdCA9IF9tdXRhdG9yLnNwcmluZ0ZyZXF1ZW5jeVR3aXN0O1xyXG4gICAgICB0aGlzLnNwcmluZ0RhbXBpbmdTd2luZyA9IF9tdXRhdG9yLnNwcmluZ0RhbXBpbmdTd2luZztcclxuICAgICAgdGhpcy5zcHJpbmdGcmVxdWVuY3lTd2luZyA9IF9tdXRhdG9yLnNwcmluZ0ZyZXF1ZW5jeVN3aW5nO1xyXG4gICAgICB0aGlzLm1heE1vdG9yVHdpc3QgPSBfbXV0YXRvci5tYXhNb3RvclR3aXN0O1xyXG4gICAgICB0aGlzLm1pbk1vdG9yVHdpc3QgPSBfbXV0YXRvci5taW5Nb3RvclR3aXN0O1xyXG4gICAgICB0aGlzLm1vdG9yU3BlZWRUd2lzdCA9IF9tdXRhdG9yLm1vdG9yU3BlZWRUd2lzdDtcclxuICAgICAgdGhpcy5tb3RvclRvcnF1ZVR3aXN0ID0gX211dGF0b3IubW90b3JUb3JxdWVUd2lzdDtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIHByb3RlY3RlZCBjb25zdHJ1Y3RKb2ludCgpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jc3ByaW5nRGFtcGVyVHdpc3QgPSBuZXcgT0lNTy5TcHJpbmdEYW1wZXIoKS5zZXRTcHJpbmcodGhpcy5zcHJpbmdGcmVxdWVuY3lUd2lzdCwgdGhpcy5zcHJpbmdEYW1waW5nVHdpc3QpO1xyXG4gICAgICB0aGlzLiNzcHJpbmdEYW1wZXJTd2luZyA9IG5ldyBPSU1PLlNwcmluZ0RhbXBlcigpLnNldFNwcmluZyh0aGlzLnNwcmluZ0ZyZXF1ZW5jeVN3aW5nLCB0aGlzLnNwcmluZ0RhbXBpbmdTd2luZyk7XHJcblxyXG4gICAgICB0aGlzLiNtb3RvclR3aXN0ID0gbmV3IE9JTU8uUm90YXRpb25hbExpbWl0TW90b3IoKS5zZXRMaW1pdHModGhpcy5taW5Nb3RvclR3aXN0LCB0aGlzLm1heE1vdG9yVHdpc3QpO1xyXG4gICAgICB0aGlzLiNtb3RvclR3aXN0LnNldE1vdG9yKHRoaXMubW90b3JTcGVlZFR3aXN0LCB0aGlzLm1vdG9yVG9ycXVlVHdpc3QpO1xyXG5cclxuICAgICAgdGhpcy5jb25maWcgPSBuZXcgT0lNTy5SYWdkb2xsSm9pbnRDb25maWcoKTtcclxuICAgICAgc3VwZXIuY29uc3RydWN0Sm9pbnQodGhpcy5heGlzRmlyc3QsIHRoaXMuYXhpc1NlY29uZCk7XHJcbiAgICAgIHRoaXMuY29uZmlnLnN3aW5nU3ByaW5nRGFtcGVyID0gdGhpcy4jc3ByaW5nRGFtcGVyU3dpbmc7XHJcbiAgICAgIHRoaXMuY29uZmlnLnR3aXN0U3ByaW5nRGFtcGVyID0gdGhpcy4jc3ByaW5nRGFtcGVyVHdpc3Q7XHJcbiAgICAgIHRoaXMuY29uZmlnLnR3aXN0TGltaXRNb3RvciA9IHRoaXMuI21vdG9yVHdpc3Q7XHJcbiAgICAgIHRoaXMuY29uZmlnLm1heFN3aW5nQW5nbGUxID0gdGhpcy4jbWF4QW5nbGVGaXJzdDtcclxuICAgICAgdGhpcy5jb25maWcubWF4U3dpbmdBbmdsZTIgPSB0aGlzLiNtYXhBbmdsZVNlY29uZDtcclxuXHJcbiAgICAgIHRoaXMuam9pbnQgPSBuZXcgT0lNTy5SYWdkb2xsSm9pbnQodGhpcy5jb25maWcpO1xyXG4gICAgICBzdXBlci5jb25maWd1cmVKb2ludCgpO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAgICogQSBwaHlzaWNhbCBjb25uZWN0aW9uIGJldHdlZW4gdHdvIGJvZGllcyB3aXRoIGEgZGVmaW5lZCBheGUgb2Ygcm90YXRpb24uIEFsc28ga25vd24gYXMgSElOR0Ugam9pbnQuXHJcbiAgICAgKiBUd28gUmlnaWRCb2RpZXMgbmVlZCB0byBiZSBkZWZpbmVkIHRvIHVzZSBpdC4gQSBtb3RvciBjYW4gYmUgZGVmaW5lZCB0byByb3RhdGUgdGhlIGNvbm5lY3RlZCBhbG9uZyB0aGUgZGVmaW5lZCBheGlzLlxyXG4gICAgICogXHJcbiAgICAgKiBgYGBwbGFpbnRleHQgICAgICAgIFxyXG4gICAgICogICAgICAgICAgICAgICAgICByb3RhdGlvbiBheGlzLCAxc3QgRGVncmVlIG9mIGZyZWVkb21cclxuICAgICAqICAgICAgICAgICAgICAgICAgICDihpFcclxuICAgICAqICAgICAgICAgICAgICAg4pSM4pSA4pSA4pSA4pSQ4pSC4pSM4pSA4pSA4pSA4pSA4pSQICAgICBcclxuICAgICAqICAgICAgICAgICAgICAg4pSCICAg4pSC4pSC4pSCICAgIOKUgiAgXHJcbiAgICAgKiAgICAgICAgICAgICAgIOKUgiAgIOKUguKUguKUgiAgICDilIIgXHJcbiAgICAgKiAgICAgICAgICAgICAgIOKUgiAgIOKUguKUguKUgiAgICDilIIgXHJcbiAgICAgKiAgICAgICAgICAgICAgIOKUlOKUgOKUgOKUgOKUmOKUguKUlOKUgOKUgOKUgOKUgOKUmFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgIOKUgiAgIFxyXG4gICAgICogICAgICBib2R5QW5jaG9yICAgICAgICAgYm9keVRpZWRcclxuICAgICAqICAgKGUuZy4gRG9vcmhpbmdlKSAgICAgICAoZS5nLiBEb29yKVxyXG4gICAgICogYGBgXHJcbiAgICAgKiBAYXV0aG9yIE1hcmtvIEZlaHJlbmJhY2gsIEhGVSwgMjAyMCB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxXHJcbiAgICAgKi9cclxuICBleHBvcnQgY2xhc3MgSm9pbnRSZXZvbHV0ZSBleHRlbmRzIEpvaW50QXhpYWwge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IEpvaW50LnJlZ2lzdGVyU3ViY2xhc3MoSm9pbnRSZXZvbHV0ZSk7XHJcblxyXG4gICAgI21vdG9yVG9ycXVlOiBudW1iZXIgPSAwO1xyXG4gICAgI3JvdG9yOiBPSU1PLlJvdGF0aW9uYWxMaW1pdE1vdG9yO1xyXG5cclxuICAgIHByb3RlY3RlZCBqb2ludDogT0lNTy5SZXZvbHV0ZUpvaW50O1xyXG4gICAgcHJvdGVjdGVkIGNvbmZpZzogT0lNTy5SZXZvbHV0ZUpvaW50Q29uZmlnID0gbmV3IE9JTU8uUmV2b2x1dGVKb2ludENvbmZpZygpO1xyXG5cclxuXHJcbiAgICBjb25zdHJ1Y3RvcihfYm9keUFuY2hvcjogQ29tcG9uZW50UmlnaWRib2R5ID0gbnVsbCwgX2JvZHlUaWVkOiBDb21wb25lbnRSaWdpZGJvZHkgPSBudWxsLCBfYXhpczogVmVjdG9yMyA9IG5ldyBWZWN0b3IzKDAsIDEsIDApLCBfbG9jYWxBbmNob3I6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygwLCAwLCAwKSkge1xyXG4gICAgICBzdXBlcihfYm9keUFuY2hvciwgX2JvZHlUaWVkLCBfYXhpcywgX2xvY2FsQW5jaG9yKTtcclxuXHJcbiAgICAgIHRoaXMubWF4TW90b3IgPSAzNjA7XHJcbiAgICAgIHRoaXMubWluTW90b3IgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIFRoZSBVcHBlciBMaW1pdCBvZiBtb3ZlbWVudCBhbG9uZyB0aGUgYXhpcyBvZiB0aGlzIGpvaW50LiBUaGUgbGltaXRlciBpcyBkaXNhYmxlIGlmIGxvd2VyTGltaXQgPiB1cHBlckxpbWl0LiBBeGlzLUFuZ2xlIG1lYXN1cmVkIGluIERlZ3JlZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldCBtYXhNb3RvcihfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICBzdXBlci5tYXhNb3RvciA9IF92YWx1ZTtcclxuICAgICAgX3ZhbHVlICo9IE1hdGguUEkgLyAxODA7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50KVxyXG4gICAgICAgIHRoaXMuam9pbnQuZ2V0TGltaXRNb3RvcigpLnVwcGVyTGltaXQgPSBfdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAgKiBUaGUgTG93ZXIgTGltaXQgb2YgbW92ZW1lbnQgYWxvbmcgdGhlIGF4aXMgb2YgdGhpcyBqb2ludC4gVGhlIGxpbWl0ZXIgaXMgZGlzYWJsZSBpZiBsb3dlckxpbWl0ID4gdXBwZXJMaW1pdC4gQXhpcyBBbmdsZSBtZWFzdXJlZCBpbiBEZWdyZWUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQgbWluTW90b3IoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgc3VwZXIubWluTW90b3IgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50KVxyXG4gICAgICAgIHRoaXMuam9pbnQuZ2V0TGltaXRNb3RvcigpLmxvd2VyTGltaXQgPSBfdmFsdWUgKiBNYXRoLlBJIC8gMTgwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIFRoZSBtYXhpbXVtIG1vdG9yIGZvcmNlIGluIE5ld3Rvbi4gZm9yY2UgPD0gMCBlcXVhbHMgZGlzYWJsZWQuIFxyXG4gICAgICovXHJcbiAgICBnZXQgbW90b3JUb3JxdWUoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI21vdG9yVG9ycXVlO1xyXG4gICAgfVxyXG4gICAgc2V0IG1vdG9yVG9ycXVlKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI21vdG9yVG9ycXVlID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldExpbWl0TW90b3IoKS5tb3RvclRvcnF1ZSA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgKiBJZiB0aGUgdHdvIGNvbm5lY3RlZCBSaWdpZEJvZGllcyBjb2xsaWRlIHdpdGggZWF0aCBvdGhlci4gKERlZmF1bHQgPSBmYWxzZSlcclxuICAgICAqL1xyXG5cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBTYXZpbmcvTG9hZGluZ1xyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgbW90b3JUb3JxdWU6IHRoaXMubW90b3JUb3JxdWUsXHJcbiAgICAgICAgW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdOiBzdXBlci5zZXJpYWxpemUoKVxyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICB0aGlzLm1vdG9yVG9ycXVlID0gX3NlcmlhbGl6YXRpb24ubW90b3JUb3JxdWU7XHJcbiAgICAgIHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0gc3VwZXIuZ2V0TXV0YXRvcigpO1xyXG4gICAgICBtdXRhdG9yLm1vdG9yVG9ycXVlID0gdGhpcy5tb3RvclRvcnF1ZTtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICB0aGlzLm1vdG9yVG9ycXVlID0gX211dGF0b3IubW90b3JUb3JxdWU7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5tb3RvclRvcnF1ZTtcclxuICAgICAgc3VwZXIubXV0YXRlKF9tdXRhdG9yKTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIHByb3RlY3RlZCBjb25zdHJ1Y3RKb2ludCgpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jcm90b3IgPSBuZXcgT0lNTy5Sb3RhdGlvbmFsTGltaXRNb3RvcigpLnNldExpbWl0cyhzdXBlci5taW5Nb3RvciAqIE1hdGguUEkgLyAxODAsIHN1cGVyLm1heE1vdG9yICogTWF0aC5QSSAvIDE4MCk7XHJcbiAgICAgIHRoaXMuI3JvdG9yLnNldE1vdG9yKHRoaXMubW90b3JTcGVlZCwgdGhpcy5tb3RvclRvcnF1ZSk7XHJcblxyXG4gICAgICB0aGlzLmNvbmZpZyA9IG5ldyBPSU1PLlJldm9sdXRlSm9pbnRDb25maWcoKTtcclxuICAgICAgc3VwZXIuY29uc3RydWN0Sm9pbnQoKTtcclxuXHJcbiAgICAgIHRoaXMuY29uZmlnLnNwcmluZ0RhbXBlciA9IHRoaXMuc3ByaW5nRGFtcGVyO1xyXG4gICAgICB0aGlzLmNvbmZpZy5saW1pdE1vdG9yID0gdGhpcy4jcm90b3I7XHJcblxyXG4gICAgICB0aGlzLmpvaW50ID0gbmV3IE9JTU8uUmV2b2x1dGVKb2ludCh0aGlzLmNvbmZpZyk7XHJcbiAgICAgIHRoaXMuY29uZmlndXJlSm9pbnQoKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgICAqIEEgcGh5c2ljYWwgY29ubmVjdGlvbiBiZXR3ZWVuIHR3byBib2RpZXMgd2l0aCB0aHJlZSBEZWdyZWVzIG9mIEZyZWVkb20sIGFsc28ga25vd24gYXMgYmFsbCBhbmQgc29ja2V0IGpvaW50LiBUd28gYm9kaWVzIGNvbm5lY3RlZCBhdCB0aGVpciBhbmNob3IgYnV0IGZyZWUgdG8gcm90YXRlLlxyXG4gICAgICogVXNlZCBmb3IgdGhpbmdzIGxpa2UgdGhlIGNvbm5lY3Rpb24gb2YgYm9uZXMgaW4gdGhlIGh1bWFuIHNob3VsZGVyIChpZiBzaW1wbGlmaWVkLCBlbHNlIGJldHRlciB1c2UgSm9pbnRSYWdkb2xsKS4gVHdvIFJpZ2lkQm9kaWVzIG5lZWQgdG8gYmUgZGVmaW5lZCB0byB1c2UgaXQuIE9ubHkgc3ByaW5nIHNldHRpbmdzIGNhbiBiZSBkZWZpbmVkLlxyXG4gICAgICogMyBEZWdyZWVzIGFyZSBzd2luZyBob3Jpem9udGFsLCBzd2luZyB2ZXJ0aWNhbCBhbmQgdHdpc3QuXHJcbiAgICAgKiBcclxuICAgICAqIGBgYHBsYWludGV4dFxyXG4gICAgICogICAgICAgICAgICAgIEpvaW50SG9sZGVyXHJcbiAgICAgKiAgICAgICAgIHogICAgICBib2R5QW5jaG9yIChlLmcuIEh1bWFuLVNob3VsZGVyKSAgICAgXHJcbiAgICAgKiAgICAgIHkgIOKGkSAgICAgICAgICBcclxuICAgICAqICAgICAgICBcXHwgICAgICAgICAg4pSA4pSA4pSAKOKXj+KUgOKUgOKUgFxyXG4gICAgICogIC14IDwtLS18LS0tPiB4ICAgICAgICAgICBib2R5VGllZCAgICAgICAgXHJcbiAgICAgKiAgICAgICAgIHxcXCAgICAgICAgICAgICAgICAoZS5nLiBVcHBlci1Bcm0pIFxyXG4gICAgICogICAgICAgICDihpMgLXkgICAgICAgXHJcbiAgICAgKiAgICAgICAgLXogICAgICAgICAgXHJcbiAgICAgKiBgYGBcclxuICAgICAqIEBhdXRob3IgTWFya28gRmVocmVuYmFjaCwgSEZVLCAyMDIwIHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuICAgICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBKb2ludFNwaGVyaWNhbCBleHRlbmRzIEpvaW50IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBKb2ludC5yZWdpc3RlclN1YmNsYXNzKEpvaW50U3BoZXJpY2FsKTtcclxuXHJcbiAgICAjc3ByaW5nRGFtcGluZzogbnVtYmVyID0gMDtcclxuICAgICNzcHJpbmdGcmVxdWVuY3k6IG51bWJlciA9IDA7XHJcbiAgICAjc3ByaW5nRGFtcGVyOiBPSU1PLlNwcmluZ0RhbXBlcjtcclxuXHJcbiAgICBwcm90ZWN0ZWQgam9pbnQ6IE9JTU8uU3BoZXJpY2FsSm9pbnQ7XHJcbiAgICBwcm90ZWN0ZWQgY29uZmlnOiBPSU1PLlNwaGVyaWNhbEpvaW50Q29uZmlnID0gbmV3IE9JTU8uU3BoZXJpY2FsSm9pbnRDb25maWcoKTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihfYm9keUFuY2hvcjogQ29tcG9uZW50UmlnaWRib2R5ID0gbnVsbCwgX2JvZHlUaWVkOiBDb21wb25lbnRSaWdpZGJvZHkgPSBudWxsLCBfbG9jYWxBbmNob3I6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygwLCAwLCAwKSkge1xyXG4gICAgICBzdXBlcihfYm9keUFuY2hvciwgX2JvZHlUaWVkKTtcclxuICAgICAgdGhpcy5hbmNob3IgPSBuZXcgVmVjdG9yMyhfbG9jYWxBbmNob3IueCwgX2xvY2FsQW5jaG9yLnksIF9sb2NhbEFuY2hvci56KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gR2V0L1NldCB0cmFuc2ZvciBvZiBmdWRnZSBwcm9wZXJ0aWVzIHRvIHRoZSBwaHlzaWNzIGVuZ2luZVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRhbXBpbmcgb2YgdGhlIHNwcmluZy4gMSBlcXVhbHMgY29tcGxldGx5IGRhbXBlZC5cclxuICAgICAqL1xyXG4gICAgZ2V0IHNwcmluZ0RhbXBpbmcoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3NwcmluZ0RhbXBpbmc7XHJcbiAgICB9XHJcbiAgICBzZXQgc3ByaW5nRGFtcGluZyhfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNzcHJpbmdEYW1waW5nID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldFNwcmluZ0RhbXBlcigpLmRhbXBpbmdSYXRpbyA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmcmVxdWVuY3kgb2YgdGhlIHNwcmluZyBpbiBIei4gQXQgMCB0aGUgc3ByaW5nIGlzIHJpZ2lkLCBlcXVhbHMgbm8gc3ByaW5nLiBUaGUgc21hbGxlciB0aGUgdmFsdWUgdGhlIGxlc3MgcmVzdHJpY3RpdmUgaXMgdGhlIHNwcmluZy5cclxuICAgICovXHJcbiAgICBnZXQgc3ByaW5nRnJlcXVlbmN5KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNzcHJpbmdGcmVxdWVuY3k7XHJcbiAgICB9XHJcbiAgICBzZXQgc3ByaW5nRnJlcXVlbmN5KF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI3NwcmluZ0ZyZXF1ZW5jeSA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRTcHJpbmdEYW1wZXIoKS5mcmVxdWVuY3kgPSBfdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gU2F2aW5nL0xvYWRpbmdcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge1xyXG4gICAgICAgIHNwcmluZ0RhbXBpbmc6IHRoaXMuc3ByaW5nRGFtcGluZyxcclxuICAgICAgICBzcHJpbmdGcmVxdWVuY3k6IHRoaXMuc3ByaW5nRnJlcXVlbmN5LFxyXG4gICAgICAgIFtzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXTogc3VwZXIuc2VyaWFsaXplKClcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgdGhpcy5zcHJpbmdEYW1waW5nID0gX3NlcmlhbGl6YXRpb24uc3ByaW5nRGFtcGluZztcclxuICAgICAgdGhpcy5zcHJpbmdGcmVxdWVuY3kgPSBfc2VyaWFsaXphdGlvbi5zcHJpbmdGcmVxdWVuY3k7XHJcbiAgICAgIHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0gc3VwZXIuZ2V0TXV0YXRvcigpO1xyXG4gICAgICBtdXRhdG9yLnNwcmluZ0RhbXBpbmcgPSB0aGlzLnNwcmluZ0RhbXBpbmc7XHJcbiAgICAgIG11dGF0b3Iuc3ByaW5nRnJlcXVlbmN5ID0gdGhpcy5zcHJpbmdGcmVxdWVuY3k7XHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgdGhpcy5zcHJpbmdEYW1waW5nID0gX211dGF0b3Iuc3ByaW5nRGFtcGluZztcclxuICAgICAgdGhpcy5zcHJpbmdGcmVxdWVuY3kgPSBfbXV0YXRvci5zcHJpbmdGcmVxdWVuY3k7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5zcHJpbmdEYW1waW5nO1xyXG4gICAgICBkZWxldGUgX211dGF0b3Iuc3ByaW5nRnJlcXVlbmN5O1xyXG4gICAgICBzdXBlci5tdXRhdGUoX211dGF0b3IpO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgcHJvdGVjdGVkIGNvbnN0cnVjdEpvaW50KCk6IHZvaWQge1xyXG4gICAgICB0aGlzLiNzcHJpbmdEYW1wZXIgPSBuZXcgT0lNTy5TcHJpbmdEYW1wZXIoKS5zZXRTcHJpbmcodGhpcy5zcHJpbmdGcmVxdWVuY3ksIHRoaXMuc3ByaW5nRGFtcGluZyk7XHJcbiAgICAgIHRoaXMuY29uZmlnID0gbmV3IE9JTU8uU3BoZXJpY2FsSm9pbnRDb25maWcoKTtcclxuICAgICAgc3VwZXIuY29uc3RydWN0Sm9pbnQoKTtcclxuICAgICAgdGhpcy5jb25maWcuc3ByaW5nRGFtcGVyID0gdGhpcy4jc3ByaW5nRGFtcGVyO1xyXG5cclxuICAgICAgdGhpcy5qb2ludCA9IG5ldyBPSU1PLlNwaGVyaWNhbEpvaW50KHRoaXMuY29uZmlnKTtcclxuICAgICAgc3VwZXIuY29uZmlndXJlSm9pbnQoKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgICAqIEEgcGh5c2ljYWwgY29ubmVjdGlvbiBiZXR3ZWVuIHR3byBib2RpZXMgd2l0aCB0d28gZGVmaW5lZCBheGlzIChub3JtYWxseSBlLmcuICgwLDAsMSkgYW5kIHJvdGF0aW9uKDEsMCwwKSksIHRoZXkgc2hhcmUgdGhlIHNhbWUgYW5jaG9yIGFuZCBoYXZlIGZyZWUgcm90YXRpb24sIGJ1dCB0cmFuc2ZlciB0aGUgdHdpc3QuXHJcbiAgICAgKiBJbiByZWFsaXR5IHVzZWQgaW4gY2FycyB0byB0cmFuc2ZlciB0aGUgbW9yZSBzdGFibGUgc3RhdGlvbmFyeSBmb3JjZSBvbiB0aGUgdmVsb2NpdHkgYXhpcyB0byB0aGUgYnVtcGluZywgZGFtcGVkIG1vdmluZyB3aGVlbC4gVHdvIFJpZ2lkQm9kaWVzIG5lZWQgdG8gYmUgZGVmaW5lZCB0byB1c2UgaXQuXHJcbiAgICAgKiBUaGUgdHdvIG1vdG9ycyBjYW4gYmUgZGVmaW5lZCBmb3IgdGhlIHR3byByb3RhdGlvbiBheGlzLCBhbG9uZyB3aXRoIHNwcmluZ3MuIFxyXG4gICAgICogYGBgcGxhaW50ZXh0ICAgICAgICBcclxuICAgICAqICAgICAgICAgICAgICAgICAgXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBhbmNob3IgLSB0d2lzdCBpcyB0cmFuc2ZlcmVkIGJldHdlZW4gYm9kaWVzXHJcbiAgICAgKiAgICAgICAgIHogICAgICAgICAgICAgICAgICAgfFxyXG4gICAgICogICAgICAgICDihpEgICAgICAgICAgICAtLS0tLSAgfCAgLS0tLS0tLS0tLS0tXHJcbiAgICAgKiAgICAgICAgIHwgICAgICAgICAgIHwgICAgIHwg4oaTIHwgICAgICAgICAgICB8IFxyXG4gICAgICogIC14IDwtLS18LS0tPiB4ICAgICB8ICAgICB8IHggfCAgICAgICAgICAgIHwgICAgICAgICAgIGUuZy4gd2hlZWwgY2FuIHN0aWxsIHR1cm4gdXAvZG93biwgXHJcbiAgICAgKiAgICAgICAgIHwgICAgICAgICAgIHwgICAgIHwgICB8ICAgICAgICAgICAgfCAgICAgICAgICAgbGVmdCByaWdodCBidXQgdHJhbnNmZXJpbmcgaXQncyByb3RhdGlvbiBvbiB0byB0aGUgd2hlZWwtYXhpcy5cclxuICAgICAqICAgICAgICAg4oaTICAgICAgICAgICAgLS0tLS0gICAgIC0tLS0tLS0tLS0tLVxyXG4gICAgICogICAgICAgIC16ICAgIFxyXG4gICAgICogICAgICAgICAgICAgICAgIGF0dGFjaGVkUkIgICAgICAgICAgY29ubmVjdGVkUkJcclxuICAgICAqICAgICAgICAgICAgICAgIChlLmcuIHdoZWVsKSAgICAgICAoZS5nLiB3aGVlbC1heGlzKVxyXG4gICAgICogYGBgXHJcbiAgICogQGF1dGhvciBNYXJrbyBGZWhyZW5iYWNoLCBIRlUsIDIwMjAgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxyXG4gICAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEpvaW50VW5pdmVyc2FsIGV4dGVuZHMgSm9pbnQge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IEpvaW50LnJlZ2lzdGVyU3ViY2xhc3MoSm9pbnRVbml2ZXJzYWwpO1xyXG5cclxuICAgICNzcHJpbmdEYW1waW5nRmlyc3Q6IG51bWJlciA9IDA7XHJcbiAgICAjc3ByaW5nRnJlcXVlbmN5Rmlyc3Q6IG51bWJlciA9IDA7XHJcblxyXG4gICAgI3NwcmluZ0RhbXBpbmdTZWNvbmQ6IG51bWJlciA9IDA7XHJcbiAgICAjc3ByaW5nRnJlcXVlbmN5U2Vjb25kOiBudW1iZXIgPSAwO1xyXG5cclxuICAgICNtYXhSb3RvckZpcnN0OiBudW1iZXIgPSAzNjA7XHJcbiAgICAjbWluUm90b3JGaXJzdDogbnVtYmVyID0gMDtcclxuICAgICNyb3RvclRvcnF1ZUZpcnN0OiBudW1iZXIgPSAwO1xyXG4gICAgI3JvdG9yU3BlZWRGaXJzdDogbnVtYmVyID0gMDtcclxuXHJcbiAgICAjbWF4Um90b3JTZWNvbmQ6IG51bWJlciA9IDM2MDtcclxuICAgICNtaW5Sb3RvclNlY29uZDogbnVtYmVyID0gMDtcclxuICAgICNyb3RvclRvcnF1ZVNlY29uZDogbnVtYmVyID0gMDtcclxuICAgICNyb3RvclNwZWVkU2Vjb25kOiBudW1iZXIgPSAwO1xyXG5cclxuICAgICNtb3RvckZpcnN0OiBPSU1PLlJvdGF0aW9uYWxMaW1pdE1vdG9yO1xyXG4gICAgI21vdG9yU2Vjb25kOiBPSU1PLlJvdGF0aW9uYWxMaW1pdE1vdG9yO1xyXG4gICAgI2F4aXNTcHJpbmdEYW1wZXJGaXJzdDogT0lNTy5TcHJpbmdEYW1wZXI7XHJcbiAgICAjYXhpc1NwcmluZ0RhbXBlclNlY29uZDogT0lNTy5TcHJpbmdEYW1wZXI7XHJcbiAgICAjYXhpc0ZpcnN0OiBPSU1PLlZlYzM7XHJcbiAgICAjYXhpc1NlY29uZDogT0lNTy5WZWMzO1xyXG5cclxuICAgIHByb3RlY3RlZCBqb2ludDogT0lNTy5Vbml2ZXJzYWxKb2ludDtcclxuICAgIHByb3RlY3RlZCBjb25maWc6IE9JTU8uVW5pdmVyc2FsSm9pbnRDb25maWcgPSBuZXcgT0lNTy5Vbml2ZXJzYWxKb2ludENvbmZpZygpO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKF9ib2R5QW5jaG9yOiBDb21wb25lbnRSaWdpZGJvZHkgPSBudWxsLCBfYm9keVRpZWQ6IENvbXBvbmVudFJpZ2lkYm9keSA9IG51bGwsIF9heGlzRmlyc3Q6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygxLCAwLCAwKSwgX2F4aXNTZWNvbmQ6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygwLCAwLCAxKSwgX2xvY2FsQW5jaG9yOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMCwgMCwgMCkpIHtcclxuICAgICAgc3VwZXIoX2JvZHlBbmNob3IsIF9ib2R5VGllZCk7XHJcbiAgICAgIHRoaXMuYXhpc0ZpcnN0ID0gX2F4aXNGaXJzdDtcclxuICAgICAgdGhpcy5heGlzU2Vjb25kID0gX2F4aXNTZWNvbmQ7XHJcbiAgICAgIHRoaXMuYW5jaG9yID0gX2xvY2FsQW5jaG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBHZXQvU2V0IHRyYW5zZm9yIG9mIGZ1ZGdlIHByb3BlcnRpZXMgdG8gdGhlIHBoeXNpY3MgZW5naW5lXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBheGlzIGNvbm5lY3RpbmcgdGhlIHRoZSB0d28ge0BsaW5rIE5vZGV9cyBlLmcuIFZlY3RvcjMoMCwxLDApIHRvIGhhdmUgYSB1cHdhcmQgY29ubmVjdGlvbi5cclxuICAgICAqICBXaGVuIGNoYW5nZWQgYWZ0ZXIgaW5pdGlhbGl6YXRpb24gdGhlIGpvaW50IG5lZWRzIHRvIGJlIHJlY29ubmVjdGVkLlxyXG4gICAgICovXHJcbiAgICBnZXQgYXhpc0ZpcnN0KCk6IFZlY3RvcjMge1xyXG4gICAgICByZXR1cm4gbmV3IFZlY3RvcjModGhpcy4jYXhpc0ZpcnN0LngsIHRoaXMuI2F4aXNGaXJzdC55LCB0aGlzLiNheGlzRmlyc3Queik7XHJcbiAgICB9XHJcbiAgICBzZXQgYXhpc0ZpcnN0KF92YWx1ZTogVmVjdG9yMykge1xyXG4gICAgICB0aGlzLiNheGlzRmlyc3QgPSBuZXcgT0lNTy5WZWMzKF92YWx1ZS54LCBfdmFsdWUueSwgX3ZhbHVlLnopO1xyXG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgdGhpcy5kaXJ0eVN0YXR1cygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAqIFRoZSBheGlzIGNvbm5lY3RpbmcgdGhlIHRoZSB0d28ge0BsaW5rIE5vZGV9cyBlLmcuIFZlY3RvcjMoMCwxLDApIHRvIGhhdmUgYSB1cHdhcmQgY29ubmVjdGlvbi5cclxuICAgICogIFdoZW4gY2hhbmdlZCBhZnRlciBpbml0aWFsaXphdGlvbiB0aGUgam9pbnQgbmVlZHMgdG8gYmUgcmVjb25uZWN0ZWQuXHJcbiAgICAqL1xyXG4gICAgZ2V0IGF4aXNTZWNvbmQoKTogVmVjdG9yMyB7XHJcbiAgICAgIHJldHVybiBuZXcgVmVjdG9yMyh0aGlzLiNheGlzU2Vjb25kLngsIHRoaXMuI2F4aXNTZWNvbmQueSwgdGhpcy4jYXhpc1NlY29uZC56KTtcclxuICAgIH1cclxuICAgIHNldCBheGlzU2Vjb25kKF92YWx1ZTogVmVjdG9yMykge1xyXG4gICAgICB0aGlzLiNheGlzU2Vjb25kID0gbmV3IE9JTU8uVmVjMyhfdmFsdWUueCwgX3ZhbHVlLnksIF92YWx1ZS56KTtcclxuICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XHJcbiAgICAgIHRoaXMuZGlydHlTdGF0dXMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkYW1waW5nIG9mIHRoZSBzcHJpbmcuIDEgZXF1YWxzIGNvbXBsZXRseSBkYW1wZWQuXHJcbiAgICAgKi9cclxuICAgIGdldCBzcHJpbmdEYW1waW5nRmlyc3QoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3NwcmluZ0RhbXBpbmdGaXJzdDtcclxuICAgIH1cclxuICAgIHNldCBzcHJpbmdEYW1waW5nRmlyc3QoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jc3ByaW5nRGFtcGluZ0ZpcnN0ID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldFNwcmluZ0RhbXBlcjEoKS5kYW1waW5nUmF0aW8gPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZnJlcXVlbmN5IG9mIHRoZSBzcHJpbmcgaW4gSHouIEF0IDAgdGhlIHNwcmluZyBpcyByaWdpZCwgZXF1YWxzIG5vIHNwcmluZy4gVGhlIHNtYWxsZXIgdGhlIHZhbHVlIHRoZSBsZXNzIHJlc3RyaWN0aXZlIGlzIHRoZSBzcHJpbmcuXHJcbiAgICAqL1xyXG4gICAgZ2V0IHNwcmluZ0ZyZXF1ZW5jeUZpcnN0KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNzcHJpbmdGcmVxdWVuY3lGaXJzdDtcclxuICAgIH1cclxuICAgIHNldCBzcHJpbmdGcmVxdWVuY3lGaXJzdChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNzcHJpbmdGcmVxdWVuY3lGaXJzdCA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRTcHJpbmdEYW1wZXIxKCkuZnJlcXVlbmN5ID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRhbXBpbmcgb2YgdGhlIHNwcmluZy4gMSBlcXVhbHMgY29tcGxldGx5IGRhbXBlZC5cclxuICAgICAqL1xyXG4gICAgZ2V0IHNwcmluZ0RhbXBpbmdTZWNvbmQoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3NwcmluZ0RhbXBpbmdTZWNvbmQ7XHJcbiAgICB9XHJcbiAgICBzZXQgc3ByaW5nRGFtcGluZ1NlY29uZChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNzcHJpbmdEYW1waW5nU2Vjb25kID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldFNwcmluZ0RhbXBlcjIoKS5kYW1waW5nUmF0aW8gPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZnJlcXVlbmN5IG9mIHRoZSBzcHJpbmcgaW4gSHouIEF0IDAgdGhlIHNwcmluZyBpcyByaWdpZCwgZXF1YWxzIG5vIHNwcmluZy4gVGhlIHNtYWxsZXIgdGhlIHZhbHVlIHRoZSBsZXNzIHJlc3RyaWN0aXZlIGlzIHRoZSBzcHJpbmcuXHJcbiAgICAqL1xyXG4gICAgZ2V0IHNwcmluZ0ZyZXF1ZW5jeVNlY29uZCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jc3ByaW5nRnJlcXVlbmN5U2Vjb25kO1xyXG4gICAgfVxyXG4gICAgc2V0IHNwcmluZ0ZyZXF1ZW5jeVNlY29uZChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNzcHJpbmdGcmVxdWVuY3lTZWNvbmQgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0U3ByaW5nRGFtcGVyMigpLmZyZXF1ZW5jeSA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAgKiBUaGUgVXBwZXIgTGltaXQgb2YgbW92ZW1lbnQgYWxvbmcgdGhlIGF4aXMgb2YgdGhpcyBqb2ludC4gVGhlIGxpbWl0ZXIgaXMgZGlzYWJsZSBpZiBsb3dlckxpbWl0ID4gdXBwZXJMaW1pdC4gQXhpcy1BbmdsZSBtZWFzdXJlZCBpbiBEZWdyZWUuXHJcbiAgICAgKi9cclxuICAgIGdldCBtYXhSb3RvckZpcnN0KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNtYXhSb3RvckZpcnN0O1xyXG4gICAgfVxyXG4gICAgc2V0IG1heFJvdG9yRmlyc3QoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jbWF4Um90b3JGaXJzdCA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRMaW1pdE1vdG9yMSgpLnVwcGVyTGltaXQgPSBfdmFsdWUgKiBNYXRoLlBJIC8gMTgwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgICogVGhlIExvd2VyIExpbWl0IG9mIG1vdmVtZW50IGFsb25nIHRoZSBheGlzIG9mIHRoaXMgam9pbnQuIFRoZSBsaW1pdGVyIGlzIGRpc2FibGUgaWYgbG93ZXJMaW1pdCA+IHVwcGVyTGltaXQuIEF4aXMgQW5nbGUgbWVhc3VyZWQgaW4gRGVncmVlLlxyXG4gICAgICovXHJcbiAgICBnZXQgbWluUm90b3JGaXJzdCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jbWluUm90b3JGaXJzdDtcclxuICAgIH1cclxuICAgIHNldCBtaW5Sb3RvckZpcnN0KF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI21pblJvdG9yRmlyc3QgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0TGltaXRNb3RvcjEoKS5sb3dlckxpbWl0ID0gX3ZhbHVlICogTWF0aC5QSSAvIDE4MDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICAqIFRoZSB0YXJnZXQgcm90YXRpb25hbCBzcGVlZCBvZiB0aGUgbW90b3IgaW4gbS9zLiBcclxuICAgICAqL1xyXG4gICAgZ2V0IHJvdG9yU3BlZWRGaXJzdCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jcm90b3JTcGVlZEZpcnN0O1xyXG4gICAgfVxyXG4gICAgc2V0IHJvdG9yU3BlZWRGaXJzdChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNyb3RvclNwZWVkRmlyc3QgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0TGltaXRNb3RvcjEoKS5tb3RvclNwZWVkID0gX3ZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgICogVGhlIG1heGltdW0gbW90b3IgdG9ycXVlIGluIE5ld3Rvbi4gZm9yY2UgPD0gMCBlcXVhbHMgZGlzYWJsZWQuIFxyXG4gICAgICovXHJcbiAgICBnZXQgcm90b3JUb3JxdWVGaXJzdCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jcm90b3JUb3JxdWVGaXJzdDtcclxuICAgIH1cclxuICAgIHNldCByb3RvclRvcnF1ZUZpcnN0KF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI3JvdG9yVG9ycXVlRmlyc3QgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0TGltaXRNb3RvcjEoKS5tb3RvclRvcnF1ZSA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogVGhlIFVwcGVyIExpbWl0IG9mIG1vdmVtZW50IGFsb25nIHRoZSBheGlzIG9mIHRoaXMgam9pbnQuIFRoZSBsaW1pdGVyIGlzIGRpc2FibGUgaWYgbG93ZXJMaW1pdCA+IHVwcGVyTGltaXQuIEF4aXMtQW5nbGUgbWVhc3VyZWQgaW4gRGVncmVlLlxyXG4gICAqL1xyXG4gICAgZ2V0IG1heFJvdG9yU2Vjb25kKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNtYXhSb3RvclNlY29uZDtcclxuICAgIH1cclxuICAgIHNldCBtYXhSb3RvclNlY29uZChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNtYXhSb3RvclNlY29uZCA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRMaW1pdE1vdG9yMigpLnVwcGVyTGltaXQgPSBfdmFsdWUgKiBNYXRoLlBJIC8gMTgwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgICogVGhlIExvd2VyIExpbWl0IG9mIG1vdmVtZW50IGFsb25nIHRoZSBheGlzIG9mIHRoaXMgam9pbnQuIFRoZSBsaW1pdGVyIGlzIGRpc2FibGUgaWYgbG93ZXJMaW1pdCA+IHVwcGVyTGltaXQuIEF4aXMgQW5nbGUgbWVhc3VyZWQgaW4gRGVncmVlLlxyXG4gICAgICovXHJcbiAgICBnZXQgbWluUm90b3JTZWNvbmQoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI21pblJvdG9yU2Vjb25kO1xyXG4gICAgfVxyXG4gICAgc2V0IG1pblJvdG9yU2Vjb25kKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI21pblJvdG9yU2Vjb25kID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldExpbWl0TW90b3IyKCkubG93ZXJMaW1pdCA9IF92YWx1ZSAqIE1hdGguUEkgLyAxODA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAgKiBUaGUgdGFyZ2V0IHJvdGF0aW9uYWwgc3BlZWQgb2YgdGhlIG1vdG9yIGluIG0vcy4gXHJcbiAgICAgKi9cclxuICAgIGdldCByb3RvclNwZWVkU2Vjb25kKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNyb3RvclNwZWVkU2Vjb25kO1xyXG4gICAgfVxyXG4gICAgc2V0IHJvdG9yU3BlZWRTZWNvbmQoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jcm90b3JTcGVlZFNlY29uZCA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRMaW1pdE1vdG9yMigpLm1vdG9yU3BlZWQgPSBfdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAgKiBUaGUgbWF4aW11bSBtb3RvciB0b3JxdWUgaW4gTmV3dG9uLiBmb3JjZSA8PSAwIGVxdWFscyBkaXNhYmxlZC4gXHJcbiAgICAgKi9cclxuICAgIGdldCByb3RvclRvcnF1ZVNlY29uZCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jcm90b3JUb3JxdWVTZWNvbmQ7XHJcbiAgICB9XHJcbiAgICBzZXQgcm90b3JUb3JxdWVTZWNvbmQoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jcm90b3JUb3JxdWVTZWNvbmQgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0TGltaXRNb3RvcjIoKS5tb3RvclRvcnF1ZSA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgKiBJZiB0aGUgdHdvIGNvbm5lY3RlZCBSaWdpZEJvZGllcyBjb2xsaWRlIHdpdGggZWF0aCBvdGhlci4gKERlZmF1bHQgPSBmYWxzZSlcclxuICAgICAqL1xyXG5cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBTYXZpbmcvTG9hZGluZ1xyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB0aGlzLiNnZXRNdXRhdG9yKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24uZmlyc3RBeGlzID0gdGhpcy5heGlzRmlyc3Quc2VyaWFsaXplKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24uc2Vjb25kQXhpcyA9IHRoaXMuYXhpc1NlY29uZC5zZXJpYWxpemUoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICB0aGlzLmF4aXNGaXJzdCA9IGF3YWl0IG5ldyBWZWN0b3IzKCkuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24uYXhpc0ZpcnN0KTtcclxuICAgICAgdGhpcy5heGlzU2Vjb25kID0gYXdhaXQgbmV3IFZlY3RvcjMoKS5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5heGlzU2Vjb25kKTtcclxuICAgICAgdGhpcy4jbXV0YXRlKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIHRoaXMuYXhpc0ZpcnN0ID0gbmV3IFZlY3RvcjMoLi4uPG51bWJlcltdPihPYmplY3QudmFsdWVzKF9tdXRhdG9yLmF4aXNGaXJzdCkpKTtcclxuICAgICAgdGhpcy5heGlzU2Vjb25kID0gbmV3IFZlY3RvcjMoLi4uPG51bWJlcltdPihPYmplY3QudmFsdWVzKF9tdXRhdG9yLmF4aXNTZWNvbmQpKSk7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5heGlzRmlyc3Q7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5heGlzU2Vjb25kO1xyXG4gICAgICB0aGlzLiNtdXRhdGUoX211dGF0b3IpO1xyXG4gICAgICB0aGlzLmRlbGV0ZUZyb21NdXRhdG9yKF9tdXRhdG9yLCB0aGlzLiNnZXRNdXRhdG9yKCkpO1xyXG4gICAgICBzdXBlci5tdXRhdGUoX211dGF0b3IpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHN1cGVyLmdldE11dGF0b3IoKTtcclxuICAgICAgT2JqZWN0LmFzc2lnbihtdXRhdG9yLCB0aGlzLiNnZXRNdXRhdG9yKCkpO1xyXG4gICAgICBtdXRhdG9yLmF4aXNGaXJzdCA9IHRoaXMuYXhpc0ZpcnN0LmdldE11dGF0b3IoKTtcclxuICAgICAgbXV0YXRvci5heGlzU2Vjb25kID0gdGhpcy5heGlzU2Vjb25kLmdldE11dGF0b3IoKTtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgI2dldE11dGF0b3IgPSAoKTogTXV0YXRvciA9PiB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0ge1xyXG4gICAgICAgIHNwcmluZ0RhbXBpbmdGaXJzdDogdGhpcy4jc3ByaW5nRGFtcGluZ0ZpcnN0LFxyXG4gICAgICAgIHNwcmluZ0ZyZXF1ZW5jeUZpcnN0OiB0aGlzLiNzcHJpbmdGcmVxdWVuY3lGaXJzdCxcclxuICAgICAgICBzcHJpbmdEYW1waW5nU2Vjb25kOiB0aGlzLiNzcHJpbmdEYW1waW5nU2Vjb25kLFxyXG4gICAgICAgIHNwcmluZ0ZyZXF1ZW5jeVNlY29uZDogdGhpcy4jc3ByaW5nRnJlcXVlbmN5U2Vjb25kLFxyXG4gICAgICAgIG1heFJvdG9yRmlyc3Q6IHRoaXMuI21heFJvdG9yRmlyc3QsXHJcbiAgICAgICAgbWluUm90b3JGaXJzdDogdGhpcy4jbWluUm90b3JGaXJzdCxcclxuICAgICAgICByb3RvclNwZWVkRmlyc3Q6IHRoaXMuI3JvdG9yU3BlZWRGaXJzdCxcclxuICAgICAgICByb3RvclRvcnF1ZUZpcnN0OiB0aGlzLiNyb3RvclRvcnF1ZUZpcnN0LFxyXG4gICAgICAgIG1heFJvdG9yU2Vjb25kOiB0aGlzLiNtYXhSb3RvclNlY29uZCxcclxuICAgICAgICBtaW5Sb3RvclNlY29uZDogdGhpcy4jbWluUm90b3JTZWNvbmQsXHJcbiAgICAgICAgcm90b3JTcGVlZFNlY29uZDogdGhpcy4jcm90b3JTcGVlZFNlY29uZCxcclxuICAgICAgICByb3RvclRvcnF1ZVNlY29uZDogdGhpcy4jcm90b3JUb3JxdWVTZWNvbmRcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgI211dGF0ZSA9IChfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQgPT4ge1xyXG4gICAgICB0aGlzLnNwcmluZ0RhbXBpbmdGaXJzdCA9IF9tdXRhdG9yLnNwcmluZ0RhbXBpbmdGaXJzdDtcclxuICAgICAgdGhpcy5zcHJpbmdGcmVxdWVuY3lGaXJzdCA9IF9tdXRhdG9yLnNwcmluZ0ZyZXF1ZW5jeUZpcnN0O1xyXG4gICAgICB0aGlzLnNwcmluZ0RhbXBpbmdTZWNvbmQgPSBfbXV0YXRvci5zcHJpbmdEYW1waW5nU2Vjb25kO1xyXG4gICAgICB0aGlzLnNwcmluZ0ZyZXF1ZW5jeVNlY29uZCA9IF9tdXRhdG9yLnNwcmluZ0ZyZXF1ZW5jeVNlY29uZDtcclxuICAgICAgdGhpcy5tYXhSb3RvckZpcnN0ID0gX211dGF0b3IubWF4Um90b3JGaXJzdDtcclxuICAgICAgdGhpcy5taW5Sb3RvckZpcnN0ID0gX211dGF0b3IubWluUm90b3JGaXJzdDtcclxuICAgICAgdGhpcy5yb3RvclNwZWVkRmlyc3QgPSBfbXV0YXRvci5yb3RvclNwZWVkRmlyc3Q7XHJcbiAgICAgIHRoaXMucm90b3JUb3JxdWVGaXJzdCA9IF9tdXRhdG9yLnJvdG9yVG9ycXVlRmlyc3Q7XHJcbiAgICAgIHRoaXMubWF4Um90b3JTZWNvbmQgPSBfbXV0YXRvci5tYXhSb3RvclNlY29uZDtcclxuICAgICAgdGhpcy5taW5Sb3RvclNlY29uZCA9IF9tdXRhdG9yLm1pblJvdG9yU2Vjb25kO1xyXG4gICAgICB0aGlzLnJvdG9yU3BlZWRTZWNvbmQgPSBfbXV0YXRvci5yb3RvclNwZWVkU2Vjb25kO1xyXG4gICAgICB0aGlzLnJvdG9yVG9ycXVlU2Vjb25kID0gX211dGF0b3Iucm90b3JUb3JxdWVTZWNvbmQ7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICBwcm90ZWN0ZWQgY29uc3RydWN0Sm9pbnQoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuI2F4aXNTcHJpbmdEYW1wZXJGaXJzdCA9IG5ldyBPSU1PLlNwcmluZ0RhbXBlcigpLnNldFNwcmluZyh0aGlzLiNzcHJpbmdGcmVxdWVuY3lGaXJzdCwgdGhpcy4jc3ByaW5nRGFtcGluZ0ZpcnN0KTtcclxuICAgICAgdGhpcy4jYXhpc1NwcmluZ0RhbXBlclNlY29uZCA9IG5ldyBPSU1PLlNwcmluZ0RhbXBlcigpLnNldFNwcmluZyh0aGlzLiNzcHJpbmdGcmVxdWVuY3lTZWNvbmQsIHRoaXMuI3NwcmluZ0RhbXBpbmdTZWNvbmQpO1xyXG5cclxuICAgICAgdGhpcy4jbW90b3JGaXJzdCA9IG5ldyBPSU1PLlJvdGF0aW9uYWxMaW1pdE1vdG9yKCkuc2V0TGltaXRzKHRoaXMuI21pblJvdG9yRmlyc3QgKiBNYXRoLlBJIC8gMTgwLCB0aGlzLiNtYXhSb3RvckZpcnN0ICogTWF0aC5QSSAvIDE4MCk7XHJcbiAgICAgIHRoaXMuI21vdG9yRmlyc3Quc2V0TW90b3IodGhpcy4jcm90b3JTcGVlZEZpcnN0LCB0aGlzLiNyb3RvclRvcnF1ZUZpcnN0KTtcclxuICAgICAgdGhpcy4jbW90b3JTZWNvbmQgPSBuZXcgT0lNTy5Sb3RhdGlvbmFsTGltaXRNb3RvcigpLnNldExpbWl0cyh0aGlzLiNtaW5Sb3RvckZpcnN0ICogTWF0aC5QSSAvIDE4MCwgdGhpcy4jbWF4Um90b3JGaXJzdCAqIE1hdGguUEkgLyAxODApO1xyXG4gICAgICB0aGlzLiNtb3RvclNlY29uZC5zZXRNb3Rvcih0aGlzLiNyb3RvclNwZWVkRmlyc3QsIHRoaXMuI3JvdG9yVG9ycXVlRmlyc3QpO1xyXG5cclxuICAgICAgdGhpcy5jb25maWcgPSBuZXcgT0lNTy5Vbml2ZXJzYWxKb2ludENvbmZpZygpO1xyXG4gICAgICBzdXBlci5jb25zdHJ1Y3RKb2ludCh0aGlzLiNheGlzRmlyc3QsIHRoaXMuI2F4aXNTZWNvbmQpO1xyXG4gICAgICB0aGlzLmNvbmZpZy5saW1pdE1vdG9yMSA9IHRoaXMuI21vdG9yRmlyc3Q7XHJcbiAgICAgIHRoaXMuY29uZmlnLmxpbWl0TW90b3IyID0gdGhpcy4jbW90b3JTZWNvbmQ7XHJcbiAgICAgIHRoaXMuY29uZmlnLnNwcmluZ0RhbXBlcjEgPSB0aGlzLiNheGlzU3ByaW5nRGFtcGVyRmlyc3Q7XHJcbiAgICAgIHRoaXMuY29uZmlnLnNwcmluZ0RhbXBlcjIgPSB0aGlzLiNheGlzU3ByaW5nRGFtcGVyU2Vjb25kO1xyXG5cclxuICAgICAgdGhpcy5qb2ludCA9IG5ldyBPSU1PLlVuaXZlcnNhbEpvaW50KHRoaXMuY29uZmlnKTtcclxuICAgICAgc3VwZXIuY29uZmlndXJlSm9pbnQoKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgICAqIEEgcGh5c2ljYWwgY29ubmVjdGlvbiBiZXR3ZWVuIHR3byBib2RpZXMgd2l0aCBubyBtb3ZlbWVudC4gXHJcbiAgICAgKiBCZXN0IHdheSB0byBzaW11bGF0ZSBjb252ZXggb2JqZWN0cyBsaWtlIGEgY2hhaXIgc2VhdCBjb25uZWN0ZWQgdG8gY2hhaXIgbGVncy5cclxuICAgICAqIFRoZSBhY3R1YWwgYW5jaG9yIHBvaW50IGRvZXMgbm90IG1hdHRlciB0aGF0IG11Y2gsIG9ubHkgaW4gdmVyeSBzcGVjaWZpYyBlZGdlIGNhc2VzLlxyXG4gICAgICogQmVjYXVzZSB3ZWxkaW5nIG1lYW5zIHRoZXkgc2ltcGx5IGRvIG5vdCBkaXNjb25uZWN0LiAodW5sZXNzIHlvdSBhZGQgQnJlYWthYmlsaXR5KVxyXG4gICAqIEBhdXRob3IgTWFya28gRmVocmVuYmFjaCwgSEZVLCAyMDIwIHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuICAgICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBKb2ludFdlbGRpbmcgZXh0ZW5kcyBKb2ludCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gSm9pbnQucmVnaXN0ZXJTdWJjbGFzcyhKb2ludFdlbGRpbmcpO1xyXG5cclxuICAgIHByb3RlY3RlZCBqb2ludDogT0lNTy5HZW5lcmljSm9pbnQ7XHJcbiAgICBwcm90ZWN0ZWQgY29uZmlnOiBPSU1PLkdlbmVyaWNKb2ludENvbmZpZyA9IG5ldyBPSU1PLkdlbmVyaWNKb2ludENvbmZpZygpO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKF9ib2R5QW5jaG9yOiBDb21wb25lbnRSaWdpZGJvZHkgPSBudWxsLCBfYm9keVRpZWQ6IENvbXBvbmVudFJpZ2lkYm9keSA9IG51bGwsIF9sb2NhbEFuY2hvcjogVmVjdG9yMyA9IG5ldyBWZWN0b3IzKDAsIDAsIDApKSB7XHJcbiAgICAgIHN1cGVyKF9ib2R5QW5jaG9yLCBfYm9keVRpZWQpO1xyXG5cclxuICAgICAgdGhpcy5hbmNob3IgPSBuZXcgVmVjdG9yMyhfbG9jYWxBbmNob3IueCwgX2xvY2FsQW5jaG9yLnksIF9sb2NhbEFuY2hvci56KTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuXHJcbiAgICAvLyNyZWdpb24gU2F2aW5nL0xvYWRpbmdcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge1xyXG4gICAgICAgIFtzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXTogc3VwZXIuc2VyaWFsaXplKClcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuXHJcbiAgICBwcm90ZWN0ZWQgY29uc3RydWN0Sm9pbnQoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuY29uZmlnID0gbmV3IE9JTU8uR2VuZXJpY0pvaW50Q29uZmlnKCk7XHJcbiAgICAgIHN1cGVyLmNvbnN0cnVjdEpvaW50KG5ldyBPSU1PLk1hdDMoKSwgbmV3IE9JTU8uTWF0MygpKTtcclxuXHJcbiAgICAgIHRoaXMuam9pbnQgPSBuZXcgT0lNTy5HZW5lcmljSm9pbnQodGhpcy5jb25maWcpO1xyXG4gICAgICB0aGlzLmpvaW50LnNldEFsbG93Q29sbGlzaW9uKHRoaXMuaW50ZXJuYWxDb2xsaXNpb24pO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIi8vLzxyZWZlcmVuY2UgcGF0aD1cIi4uLy4uLy4uL1BoeXNpY3MvT0lNT1BoeXNpY3MuZC50c1wiLz5cclxuXHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAgKiBNYW5hZ2VzIHRoZSBPSU1PIHBoeXNpY3MgZW5naW5lIGZvciBGVURHRS4gTXVsdGlwbGUgaW5zdGFuY2VzIG1heSBiZSBjcmVhdGVkLCBvbmUgaXMgYWN0aXZlIGF0IGEgdGltZS5cclxuICAgICogQWxsIG1ldGhvZHMgYXJlIHN0YXRpYyBhbmQgdXNlIHRoZSBjdXJyZW50bHkgYWN0aXZlIGluc3RhbmNlLiBBdCBzdGFydHVwLCBhIGRlZmF1bHQgaW5zdGFuY2UgaXMgY3JlYXRlZCBhbmQgYmVjb21lIHRoZSBhY3RpdmUgaW5zdGFuY2VcclxuICAgICogQXR0YWNoaW5nIGEge0BsaW5rIENvbXBvbmVudFJpZ2lkYm9keX0gdG8gYSB7QGxpbmsgTm9kZX0gcGxhY2VzIGEgcGh5c2ljcyBjb2xsaWRlciBpbiB0aGUgcGh5c2ljcyBpbnN0YW5jZSBhY3RpdmUgYXQgdGhhdCB0aW1lLlxyXG4gICAgKiBAYXV0aG9yIE1hcmtvIEZlaHJlbmJhY2gsIEhGVSAyMDIwXHJcbiAgICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBQaHlzaWNzIHtcclxuICAgIC8qKiBUaGUgU0VUVElOR1MgdGhhdCBhcHBseSB0byB0aGUgcGh5c2ljYWwgd29ybGQuIFJhbmdpbmcgZnJvbSB0aGluZ3MgbGlrZSBzbGVlcGluZywgY29sbGlzaW9uU2hhcGVUaGlja25lc3MgYW5kIG90aGVycyAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzZXR0aW5nczogUGh5c2ljc1NldHRpbmdzID0gbmV3IFBoeXNpY3NTZXR0aW5ncyhDT0xMSVNJT05fR1JPVVAuREVGQVVMVCwgKENPTExJU0lPTl9HUk9VUC5ERUZBVUxUIHwgQ09MTElTSU9OX0dST1VQLkdST1VQXzEgfCBDT0xMSVNJT05fR1JPVVAuR1JPVVBfMiB8IENPTExJU0lPTl9HUk9VUC5HUk9VUF8zIHwgQ09MTElTSU9OX0dST1VQLkdST1VQXzQpKTtcclxuICAgIHByaXZhdGUgc3RhdGljIMaSYWN0aXZlOiBQaHlzaWNzID0gbmV3IFBoeXNpY3MoKTtcclxuXHJcbiAgICAvKiogVGhlIHJlbmRlcmluZyBvZiBwaHlzaWNhbCBkZWJ1ZyBpbmZvcm1hdGlvbnMuIFVzZWQgaW50ZXJuYWxseSBubyBpbnRlcmFjdGlvbiBuZWVkZWQuKi9cclxuICAgICNkZWJ1Z0RyYXc6IFBoeXNpY3NEZWJ1Z0RyYXc7XHJcbiAgICAvKiogVGhlIGNhbWVyYS92aWV3cG9ydCB0aGUgcGh5c2ljcyBhcmUgZGVidWdnZWQgdG8uIFVzZWQgaW50ZXJuYWxseSBubyBpbnRlcmFjdGlvbiBuZWVkZWQuICovXHJcbiAgICAjbWFpbkNhbTogQ29tcG9uZW50Q2FtZXJhO1xyXG5cclxuICAgIHByaXZhdGUgb2ltb1dvcmxkOiBPSU1PLldvcmxkO1xyXG4gICAgcHJpdmF0ZSBib2R5TGlzdDogQ29tcG9uZW50UmlnaWRib2R5W10gPSBuZXcgQXJyYXkoKTtcclxuICAgIHByaXZhdGUgam9pbnRMaXN0OiBKb2ludFtdID0gbmV3IEFycmF5KCk7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICBpZiAodHlwZW9mIE9JTU8gPT0gXCJ1bmRlZmluZWRcIikgey8vIENoZWNrIGlmIE9JTU8gTmFtZXNwYWNlIHdhcyBsb2FkZWQsIGVsc2UgZG8gbm90IHVzZSBhbnkgcGh5c2ljcy4gQ2hlY2sgaXMgbmVlZGVkIHRvIGVuc3VyZSBGVURHRSBjYW4gYmUgdXNlZCB3aXRob3V0IFBoeXNpY3NcclxuICAgICAgICBEZWJ1Zy5lcnJvcihcIk9JTU8gcGh5c2ljcyBlbmdpbmUgbm90IGNvbm5lY3RlZCFcIik7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5vaW1vV29ybGQgPSBuZXcgT0lNTy5Xb3JsZCgpO1xyXG4gICAgICB0aGlzLiNkZWJ1Z0RyYXcgPSBuZXcgUGh5c2ljc0RlYnVnRHJhdygpOyAgLy9DcmVhdGUgYSBGdWRnZSBQaHlzaWNzIGRlYnVnZ2luZyBoYW5kbGluZyBvYmplY3RcclxuICAgICAgdGhpcy5vaW1vV29ybGQuc2V0RGVidWdEcmF3KHRoaXMuI2RlYnVnRHJhdy5vaW1vRGVidWdEcmF3KTsgLy9UZWxsIE9pbW9QaHlzaWNzIHdoZXJlIHRvIGRlYnVnIHRvIGFuZCBob3cgaXQgd2lsbCBiZSBoYW5kbGVkXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmUgdGhlIGN1cnJlbnRseSBhY3RpdmUgUGh5c2ljcyBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHNldCBhY3RpdmVJbnN0YW5jZShfcGh5c2ljczogUGh5c2ljcykge1xyXG4gICAgICBQaHlzaWNzLsaSYWN0aXZlID0gX3BoeXNpY3M7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXQgZGVidWdEcmF3KCk6IFBoeXNpY3NEZWJ1Z0RyYXcge1xyXG4gICAgICByZXR1cm4gUGh5c2ljcy7GkmFjdGl2ZS4jZGVidWdEcmF3O1xyXG4gICAgfVxyXG4gICAgcHVibGljIHN0YXRpYyBnZXQgbWFpbkNhbSgpOiBDb21wb25lbnRDYW1lcmEge1xyXG4gICAgICByZXR1cm4gUGh5c2ljcy7GkmFjdGl2ZS4jbWFpbkNhbTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogQ2FzdCBhIFJBWSBpbnRvIHRoZSBwaHlzaWNhbCB3b3JsZCBmcm9tIGEgb3JpZ2luIHBvaW50IGluIGEgY2VydGFpbiBkaXJlY3Rpb24uIFJlY2VpdmluZyBpbmZvcm1hdGlvbnMgYWJvdXQgdGhlIGhpdCBvYmplY3QgYW5kIHRoZVxyXG4gICAgKiBoaXQgcG9pbnQuIERvIG5vdCBzcGVjaWZ5IGEgX2dyb3VwIHRvIHJheWNhc3QgdGhlIHdob2xlIHdvcmxkLCBlbHNlIG9ubHkgYm9kaWVzIHdpdGhpbiB0aGUgc3BlY2lmaWMgZ3JvdXAgY2FuIGJlIGhpdC5cclxuICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJheWNhc3QoX29yaWdpbjogVmVjdG9yMywgX2RpcmVjdGlvbjogVmVjdG9yMywgX2xlbmd0aDogbnVtYmVyID0gMSwgX2RlYnVnRHJhdzogYm9vbGVhbiA9IGZhbHNlLCBfZ3JvdXA6IENPTExJU0lPTl9HUk9VUCA9IENPTExJU0lPTl9HUk9VUC5ERUZBVUxUKTogUmF5SGl0SW5mbyB7XHJcbiAgICAgIGxldCBoaXRJbmZvOiBSYXlIaXRJbmZvID0gbmV3IFJheUhpdEluZm8oKTtcclxuICAgICAgbGV0IHJheTogT0lNTy5SYXlDYXN0Q2xvc2VzdCA9IG5ldyBPSU1PLlJheUNhc3RDbG9zZXN0KCk7XHJcbiAgICAgIGxldCBiZWdpbjogT0lNTy5WZWMzID0gbmV3IE9JTU8uVmVjMyhfb3JpZ2luLngsIF9vcmlnaW4ueSwgX29yaWdpbi56KTtcclxuICAgICAgbGV0IGVuZDogT0lNTy5WZWMzID0gdGhpcy5nZXRSYXlFbmRQb2ludChiZWdpbiwgbmV3IFZlY3RvcjMoX2RpcmVjdGlvbi54LCBfZGlyZWN0aW9uLnksIF9kaXJlY3Rpb24ueiksIF9sZW5ndGgpO1xyXG4gICAgICByYXkuY2xlYXIoKTtcclxuICAgICAgaWYgKF9ncm91cCA9PSBDT0xMSVNJT05fR1JPVVAuREVGQVVMVCkgeyAvL0Nhc2UgMTogUmF5Y2FzdGluZyB0aGUgd2hvbGUgd29ybGQsIG5vcm1hbCBtb2RlXHJcbiAgICAgICAgUGh5c2ljcy7GkmFjdGl2ZS5vaW1vV29ybGQucmF5Q2FzdChiZWdpbiwgZW5kLCByYXkpO1xyXG4gICAgICB9IGVsc2UgeyAvL0Nhc2UyOiBSYXljYXN0aW5nIG9uIGVhY2ggYm9keSBpbiBhIHNwZWNpZmljIGdyb3VwXHJcbiAgICAgICAgbGV0IGFsbEhpdHM6IFJheUhpdEluZm9bXSA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIFBoeXNpY3MuxpJhY3RpdmUuYm9keUxpc3QuZm9yRWFjaChmdW5jdGlvbiAodmFsdWU6IENvbXBvbmVudFJpZ2lkYm9keSk6IHZvaWQge1xyXG4gICAgICAgICAgaWYgKHZhbHVlLmNvbGxpc2lvbkdyb3VwID09IF9ncm91cCkge1xyXG4gICAgICAgICAgICBoaXRJbmZvID0gdmFsdWUucmF5Y2FzdFRoaXNCb2R5KF9vcmlnaW4sIF9kaXJlY3Rpb24sIF9sZW5ndGgpO1xyXG4gICAgICAgICAgICBpZiAoaGl0SW5mby5oaXQgPT0gdHJ1ZSkgeyAvL0V2ZXJ5IGhpdCBpcyBjb3VsZCBwb3RlbnRpYWxseSBiZSB0aGUgY2xvc2VzdFxyXG4gICAgICAgICAgICAgIGFsbEhpdHMucHVzaChoaXRJbmZvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGFsbEhpdHMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWU6IFJheUhpdEluZm8pOiB2b2lkIHsgLy9nZXQgdGhlIGNsb3Nlc3QgaGl0SW5mb1xyXG4gICAgICAgICAgaWYgKHZhbHVlLmhpdERpc3RhbmNlIDwgaGl0SW5mby5oaXREaXN0YW5jZSB8fCBoaXRJbmZvLmhpdCA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBoaXRJbmZvID0gdmFsdWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHJheS5oaXQpIHsgLy9GaWxsIGluIGluZm9ybWF0aW9ucyBvbiB0aGUgaGl0XHJcbiAgICAgICAgaGl0SW5mby5oaXQgPSB0cnVlO1xyXG4gICAgICAgIGhpdEluZm8uaGl0UG9pbnQgPSBuZXcgVmVjdG9yMyhyYXkucG9zaXRpb24ueCwgcmF5LnBvc2l0aW9uLnksIHJheS5wb3NpdGlvbi56KTtcclxuICAgICAgICBoaXRJbmZvLmhpdE5vcm1hbCA9IG5ldyBWZWN0b3IzKHJheS5ub3JtYWwueCwgcmF5Lm5vcm1hbC55LCByYXkubm9ybWFsLnopO1xyXG4gICAgICAgIGhpdEluZm8uaGl0RGlzdGFuY2UgPSB0aGlzLmdldFJheURpc3RhbmNlKF9vcmlnaW4sIGhpdEluZm8uaGl0UG9pbnQpO1xyXG4gICAgICAgIGhpdEluZm8ucmlnaWRib2R5Q29tcG9uZW50ID0gcmF5LnNoYXBlLnVzZXJEYXRhO1xyXG4gICAgICAgIGhpdEluZm8ucmF5RW5kID0gbmV3IFZlY3RvcjMoZW5kLngsIGVuZC55LCBlbmQueik7XHJcbiAgICAgICAgaGl0SW5mby5yYXlPcmlnaW4gPSBfb3JpZ2luO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGhpdEluZm8ucmF5T3JpZ2luID0gX29yaWdpbjtcclxuICAgICAgICBoaXRJbmZvLmhpdFBvaW50ID0gbmV3IFZlY3RvcjMoZW5kLngsIGVuZC55LCBlbmQueik7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKF9kZWJ1Z0RyYXcpIHsgLy9IYW5kbGUgZGVidWdnaW5nXHJcbiAgICAgICAgUGh5c2ljcy7GkmFjdGl2ZS4jZGVidWdEcmF3LmRlYnVnUmF5KGhpdEluZm8ucmF5T3JpZ2luLCBoaXRJbmZvLmhpdFBvaW50LCBuZXcgQ29sb3IoMCwgMSwgMCwgMSkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBoaXRJbmZvO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICogU2ltdWxhdGVzIHRoZSBwaHlzaWNhbCB3b3JsZC4gX2RlbHRhVGltZSBpcyB0aGUgYW1vdW50IG9mIHRpbWUgYmV0d2VlbiBwaHlzaWNhbCBzdGVwcywgZGVmYXVsdCBpcyA2MCBmcmFtZXMgcGVyIHNlY29uZCB+MTdtcy5cclxuICAgICogQSBmcmFtZSB0aW1pbmcgY2FuJ3QgYmUgc21hbGxlciB0aGFuIDEvMzAgb2YgYSBzZWNvbmQsIG9yIGVsc2UgaXQgd2lsbCBiZSBzZXQgdG8gMzAgZnJhbWVzLCB0byBoYXZlIG1vcmUgY29uc2lzdGVudCBmcmFtZSBjYWxjdWxhdGlvbnMuXHJcbiAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzaW11bGF0ZShfZGVsdGFUaW1lOiBudW1iZXIgPSAxIC8gNjApOiB2b2lkIHtcclxuICAgICAgaWYgKFBoeXNpY3MuxpJhY3RpdmUuam9pbnRMaXN0Lmxlbmd0aCA+IDApXHJcbiAgICAgICAgUGh5c2ljcy5jb25uZWN0Sm9pbnRzKCk7IC8vQ29ubmVjdCBqb2ludHMgaWYgYW55dGhpbmcgaGFzIGhhcHBlbmVkIGJldHdlZW4gdGhlIGxhc3QgY2FsbCB0byBhbnkgb2YgdGhlIHR3byBwYWlyZWQgcmlnaWRib2RpZXNcclxuICAgICAgaWYgKFRpbWUuZ2FtZS5nZXRTY2FsZSgpICE9IDApIHsgLy9JZiB0aW1lIGlzIHN0b3BwZWQgZG8gbm90IHNpbXVsYXRlIHRvIGF2b2lkIG1pc2JlaGF2aW91clxyXG4gICAgICAgIF9kZWx0YVRpbWUgPSBfZGVsdGFUaW1lID4gMSAvIDMwID8gMSAvIDMwIDogX2RlbHRhVGltZTsgLy9JZiBpbnN0ZWFkIG9mIGEgZml4ZWQgcmF0ZSB0aGUgZ2FtZSBmcmFtZXJhdGUgaXMgdXNlZCwgbWFrZSBzdXJlIGlycmVndWxhciB0aW1pbmdzIGFyZSBmaXhlZCB0byAzMGZwc1xyXG4gICAgICAgIFBoeXNpY3MuxpJhY3RpdmUub2ltb1dvcmxkLnN0ZXAoX2RlbHRhVGltZSAqIFRpbWUuZ2FtZS5nZXRTY2FsZSgpKTsgIC8vVXBkYXRlIHRoZSBzaW11bGF0aW9uIGJ5IHRoZSBnaXZlbiBkZWx0YVRpbWUgYW5kIHRoZSBGdWRnZSBpbnRlcm5hbCBUaW1lU2NhbGVcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhdyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudGx5IGFjdGl2ZSBpbnN0YW5jZSB1c2luZyB0aGUge0BsaW5rIENvbXBvbmVudENhbWVyYX0gZ2l2ZW5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBkcmF3KF9jbXBDYW1lcmE6IENvbXBvbmVudENhbWVyYSwgX21vZGU/OiBQSFlTSUNTX0RFQlVHTU9ERSk6IHZvaWQge1xyXG4gICAgICBQaHlzaWNzLsaSYWN0aXZlLiNkZWJ1Z0RyYXcuc2V0RGVidWdNb2RlKF9tb2RlKTtcclxuICAgICAgUGh5c2ljcy7GkmFjdGl2ZS4jbWFpbkNhbSA9IF9jbXBDYW1lcmE7XHJcbiAgICAgIFBoeXNpY3MuxpJhY3RpdmUub2ltb1dvcmxkLmRlYnVnRHJhdygpOyAvL0ZpbGxpbmcgdGhlIHBoeXNpY3Mgd29ybGQgZGVidWcgaW5mb3JtYXRpb25zIGludG8gdGhlIGRlYnVnIHJlbmRlcmluZyBoYW5kbGVyXHJcbiAgICAgIFBoeXNpY3MuxpJhY3RpdmUuI2RlYnVnRHJhdy5kcmF3QnVmZmVycygpO1xyXG4gICAgICBQaHlzaWNzLsaSYWN0aXZlLiNkZWJ1Z0RyYXcuY2xlYXJCdWZmZXJzKCk7ICAvL1VwZGF0ZXMgaW5mbyBhYm91dCB0aGUgY3VycmVudCBwcm9qZWN0aW9uLCByZXNldHRpbmcgdGhlIHBvaW50cy9saW5lcy90cmlhbmdsZXMgdGhhdCBuZWVkIHRvIGJlIGRyYXduIGZyb20gZGVidWdcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgKiBBZGp1c3RzIHRoZSB0cmFuc2Zvcm1zIG9mIHRoZSB7QGxpbmsgQ29tcG9uZW50UmlnaWRib2R5fXMgaW4gdGhlIGdpdmVuIGJyYW5jaCB0byBtYXRjaCB0aGVpciBub2RlcyBvciBtZXNoZXNcclxuICAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgYWRqdXN0VHJhbnNmb3JtcyhfYnJhbmNoOiBOb2RlLCBfdG9NZXNoOiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcclxuICAgICAgUmVuZGVyLnByZXBhcmUoX2JyYW5jaCwgeyBpZ25vcmVQaHlzaWNzOiB0cnVlIH0pO1xyXG4gICAgICBmb3IgKGxldCBub2RlIG9mIFJlbmRlci5ub2Rlc1BoeXNpY3MpXHJcbiAgICAgICAgbm9kZS5nZXRDb21wb25lbnQoQ29tcG9uZW50UmlnaWRib2R5KS5pbml0aWFsaXplKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEdldCB0aGUgYXBwbGllZCBncmF2aXRhdGlvbmFsIGZvcmNlIG9mIHRoZSBhY3RpdmUgaW5zdGFuY2UuIERlZmF1bHQgZWFydGggZ3Jhdml0eSA9IDkuODEgbS9zXHJcbiAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXRHcmF2aXR5KCk6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgdG1wVmVjOiBPSU1PLlZlYzMgPSBQaHlzaWNzLsaSYWN0aXZlLm9pbW9Xb3JsZC5nZXRHcmF2aXR5KCk7XHJcbiAgICAgIHJldHVybiBuZXcgVmVjdG9yMyh0bXBWZWMueCwgdG1wVmVjLnksIHRtcFZlYy56KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogU2V0IHRoZSBhcHBsaWVkIGdyYXZpdGF0aW9uYWwgZm9yY2Ugb2YgdGhlIGFjdGl2ZSBpbnN0YW5jZS4gRGVmYXVsdCBlYXJ0aCBncmF2aXR5ID0gOS44MSBtL3NcclxuICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHNldEdyYXZpdHkoX3ZhbHVlOiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIGxldCB0bXBWZWM6IE9JTU8uVmVjMyA9IG5ldyBPSU1PLlZlYzMoX3ZhbHVlLngsIF92YWx1ZS55LCBfdmFsdWUueik7XHJcbiAgICAgIFBoeXNpY3MuxpJhY3RpdmUub2ltb1dvcmxkLnNldEdyYXZpdHkodG1wVmVjKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogQWRkIGEgbmV3IE9JTU8gUmlnaWRib2R5IHRvIHRoZSBhY3RpdmUgaW5zdGFuY2UsIGhhcHBlbnMgYXV0b21hdGljYWxseSB3aGVuIGFkZGluZyBhIEZVREdFIFJpZ2lkYm9keSBDb21wb25lbnQuXHJcbiAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBhZGRSaWdpZGJvZHkoX2NtcFJCOiBDb21wb25lbnRSaWdpZGJvZHkpOiB2b2lkIHtcclxuICAgICAgUGh5c2ljcy7GkmFjdGl2ZS5ib2R5TGlzdC5wdXNoKF9jbXBSQik7XHJcbiAgICAgIFBoeXNpY3MuxpJhY3RpdmUub2ltb1dvcmxkLmFkZFJpZ2lkQm9keShfY21wUkIuZ2V0T2ltb1JpZ2lkYm9keSgpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogUmVtb3ZlIHRoZSBPSU1PIFJpZ2lkYm9keSB0byB0aGUgYWN0aXZlIGluc3RhbmNlLCBoYXBwZW5zIGF1dG9tYXRpY2FsbHkgd2hlbiByZW1vdmluZyBhIEZVREdFIFJpZ2lkYm9keSBDb21wb25lbnRcclxuICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlbW92ZVJpZ2lkYm9keShfY21wUkI6IENvbXBvbmVudFJpZ2lkYm9keSk6IHZvaWQge1xyXG4gICAgICAvLyBUT0RPOiB0d28gbGlzdHMgYXJlIGJlaW5nIG1hbmFnZWQsIGluZm8gbWlnaHQgZGV2aWF0ZS4gQ2xlYW51cCFcclxuICAgICAgbGV0IG9pbW9SaWdpZEJvZHk6IE9JTU8uUmlnaWRCb2R5ID0gX2NtcFJCLmdldE9pbW9SaWdpZGJvZHkoKTtcclxuICAgICAgaWYgKG9pbW9SaWdpZEJvZHkuX3dvcmxkKVxyXG4gICAgICAgIG9pbW9SaWdpZEJvZHkuX3dvcmxkLnJlbW92ZVJpZ2lkQm9keShvaW1vUmlnaWRCb2R5KTtcclxuICAgICAgLy8gd2hhdCBpZiB0aGUgcmlnaWRib2R5cyBvaW1vLXdvcmxkIGRvZXMgbm90IGJlbG9uZyB0byB0aGUgYWN0aXZlIGluc3RhbmNlP1xyXG4gICAgICBsZXQgaWQ6IG51bWJlciA9IFBoeXNpY3MuxpJhY3RpdmUuYm9keUxpc3QuaW5kZXhPZihfY21wUkIpO1xyXG4gICAgICBQaHlzaWNzLsaSYWN0aXZlLmJvZHlMaXN0LnNwbGljZShpZCwgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEFkZCBhIG5ldyBPSU1PIEpvaW50L0NvbnN0cmFpbnQgdG8gdGhlIGFjdGl2ZSBpbnN0YW5jZSwgaGFwcGVucyBhdXRvbWF0aWNhbGx5IHdoZW4gYWRkaW5nIGEgRlVER0UgSm9pbnQgQ29tcG9uZW50XHJcbiAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBhZGRKb2ludChfY21wSm9pbnQ6IEpvaW50KTogdm9pZCB7XHJcbiAgICAgIFBoeXNpY3MuxpJhY3RpdmUub2ltb1dvcmxkLmFkZEpvaW50KF9jbXBKb2ludC5nZXRPaW1vSm9pbnQoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIENhbGxlZCBpbnRlcm5hbGx5IHRvIGluZm9ybSB0aGUgcGh5c2ljcyBzeXN0ZW0gdGhhdCBhIGpvaW50IGhhcyBhIGNoYW5nZSBvZiBjb3JlIHByb3BlcnRpZXMgYW5kIG5lZWRzIHRvIGJlIHJlY3JlYXRlZC5cclxuICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGNoYW5nZUpvaW50U3RhdHVzKF9jbXBKb2ludDogSm9pbnQpOiB2b2lkIHtcclxuICAgICAgaWYgKFBoeXNpY3MuxpJhY3RpdmUuam9pbnRMaXN0LmluZGV4T2YoX2NtcEpvaW50KSA8IDApXHJcbiAgICAgICAgUGh5c2ljcy7GkmFjdGl2ZS5qb2ludExpc3QucHVzaChfY21wSm9pbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIFJlbW92ZSB0aGUgT0lNTyBKb2ludC9Db25zdHJhaW50IHRvIHRoZSBhY3RpdmUgaW5zdGFuY2UsIGhhcHBlbnMgYXV0b21hdGljYWxseSB3aGVuIHJlbW92aW5nIGEgRlVER0UgSm9pbnQgQ29tcG9uZW50XHJcbiAgICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlbW92ZUpvaW50KF9jbXBKb2ludDogSm9pbnQpOiB2b2lkIHtcclxuICAgICAgUGh5c2ljcy7GkmFjdGl2ZS5vaW1vV29ybGQucmVtb3ZlSm9pbnQoX2NtcEpvaW50LmdldE9pbW9Kb2ludCgpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogUmV0dXJucyBhbGwgdGhlIENvbXBvbmVudFJpZ2lkYm9kaWVzIHRoYXQgYXJlIGtub3duIHRvIHRoZSBhY3RpdmUgaW5zdGFuY2UuICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldEJvZHlMaXN0KCk6IENvbXBvbmVudFJpZ2lkYm9keVtdIHtcclxuICAgICAgcmV0dXJuIFBoeXNpY3MuxpJhY3RpdmUuYm9keUxpc3Q7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEdpdmluZyBhIENvbXBvbmVudFJpZ2lkYm9keSBhIHNwZWNpZmljIGlkZW50aWZpY2F0aW9uIG51bWJlciBzbyBpdCBjYW4gYmUgcmVmZXJlbmNlZCBpbiB0aGUgbG9hZGluZyBwcm9jZXNzLiBBbmQgcmVtb3ZlZCByYidzIGNhbiByZWNlaXZlIGEgbmV3IGlkLiAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBkaXN0cmlidXRlQm9keUlEKCk6IG51bWJlciB7XHJcbiAgICAgIGxldCBmcmVlSWQ6IG51bWJlciA9IDA7XHJcbiAgICAgIGxldCBmcmVlOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICAgIFBoeXNpY3MuxpJhY3RpdmUuYm9keUxpc3QuZm9yRWFjaCgoX3ZhbHVlOiBDb21wb25lbnRSaWdpZGJvZHkpOiB2b2lkID0+IHtcclxuICAgICAgICBpZiAoX3ZhbHVlLmlkICE9IGZyZWVJZCkge1xyXG4gICAgICAgICAgZnJlZSA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGZyZWUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFmcmVlKSB7XHJcbiAgICAgICAgICBmcmVlSWQrKztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIGZyZWVJZDtcclxuICAgIH1cclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBDb25uZWN0IGFsbCBqb2ludHMgdGhhdCBhcmUgbm90IGNvbm5lY3RlZCB5ZXQuIFVzZWQgaW50ZXJuYWxseSBubyB1c2VyIGludGVyYWN0aW9uIG5lZWRlZC4gVGhpcyBmdW5jdGlvbmFsaXR5IGlzIGNhbGxlZCBhbmQgbmVlZGVkIHRvIG1ha2Ugc3VyZSBqb2ludHMgY29ubmVjdC9kaXNjb25uZWN0XHJcbiAgICAgKiBpZiBhbnkgb2YgdGhlIHR3byBwYWlyZWQgQ29tcG9uZW50UmlnaWRib2RpZXMgY2hhbmdlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGNvbm5lY3RKb2ludHMoKTogdm9pZCB7IC8vVHJ5IHRvIGNvbm5lY3QgZGlydHkgam9pbnRzIHVudGlsIHRoZXkgYXJlIGNvbm5lY3RlZFxyXG4gICAgICAvLyBsZXQgam9pbnRzVG9Db25uZWN0OiBDb21wb25lbnRKb2ludFtdID0gbmV3IEFycmF5KCk7IC8vQ29weSBvcmlnaW5hbCBBcnJheSBiZWNhdXNlIHJlbW92aW5nL3JlYWRkaW5nIGluIHRoZSBjb25uZWN0aW5nIHByb2Nlc3NcclxuICAgICAgLy8gdGhpcy5qb2ludExpc3QuZm9yRWFjaChmdW5jdGlvbiAodmFsdWU6IENvbXBvbmVudEpvaW50KTogdm9pZCB7XHJcbiAgICAgIC8vICAgam9pbnRzVG9Db25uZWN0LnB1c2godmFsdWUpO1xyXG4gICAgICAvLyB9KTtcclxuICAgICAgLy8gdGhpcy5qb2ludExpc3Quc3BsaWNlKDAsIHRoaXMuam9pbnRMaXN0Lmxlbmd0aCk7XHJcbiAgICAgIGxldCBqb2ludHNUb0Nvbm5lY3Q6IEpvaW50W10gPSBQaHlzaWNzLsaSYWN0aXZlLmpvaW50TGlzdDtcclxuICAgICAgUGh5c2ljcy7GkmFjdGl2ZS5qb2ludExpc3QgPSBbXTtcclxuICAgICAgam9pbnRzVG9Db25uZWN0LmZvckVhY2goKF9qb2ludDogSm9pbnQpOiB2b2lkID0+IHtcclxuICAgICAgICBpZiAoX2pvaW50LmlzQ29ubmVjdGVkKCkgPT0gZmFsc2UpIHtcclxuICAgICAgICAgIF9qb2ludC5jb25uZWN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogUmVtb3ZlIGFsbCBvaW1vIGpvaW50cyBhbmQgcmlnaWRib2RpZXMsIHNvIHRoYXQgdGhleSBjYW4gYmUgcmV1c2VkIGluIGFub3RoZXIgd29ybGQgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGNsZWFudXAoKTogdm9pZCB7XHJcbiAgICAgIGxldCBvaW1vV29ybGQ6IE9JTU8uV29ybGQgPSBQaHlzaWNzLsaSYWN0aXZlLm9pbW9Xb3JsZDtcclxuICAgICAgaWYgKG9pbW9Xb3JsZCAhPSBudWxsKSB7XHJcbiAgICAgICAgLy9SZXNldHRpbmcgdGhlIHdvcmxkIHNvIGEgbmV3IHdvcmxkIGNhbiBiZSBjcmVhdGVkLCBmaXggZm9yIHJlLW9wZW5pbmcgYSBwcm9qZWN0IGluIGVkaXRvciwgbWFraW5nIHN1cmUgdGhlcmUgYXJlIG5vIG9sZCB0aGluZ3MgY2FsY3VsYXRlZFxyXG4gICAgICAgIGxldCBqb2ludHNXb3JsZDogbnVtYmVyID0gb2ltb1dvcmxkLmdldE51bUpvaW50cygpO1xyXG4gICAgICAgIGxldCBib2RpZXNXb3JsZDogbnVtYmVyID0gb2ltb1dvcmxkLmdldE51bVJpZ2lkQm9kaWVzKCk7XHJcbiAgICAgICAgZm9yIChsZXQgYm9keSBvZiBQaHlzaWNzLsaSYWN0aXZlLmJvZHlMaXN0KVxyXG4gICAgICAgICAgYm9keS5pc0luaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgICAgICAgUGh5c2ljcy7GkmFjdGl2ZS5qb2ludExpc3QgPSBuZXcgQXJyYXkoKTsgLy8gVE9ETzogc2VlIGlmIGl0IHdvdWxkIGJlIHNtYXJ0ZXIsIGRvIHVzZSB0aGVzZSBhcnJheXMuIERlZmluaXRlbHkgbW9yZSBpbnR1aXRpdmUuLi5cclxuICAgICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgam9pbnRzV29ybGQ7IGkrKykge1xyXG4gICAgICAgICAgb2ltb1dvcmxkLnJlbW92ZUpvaW50KFBoeXNpY3MuxpJhY3RpdmUub2ltb1dvcmxkLmdldEpvaW50TGlzdCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IGJvZGllc1dvcmxkOyBpKyspIHtcclxuICAgICAgICAgIGxldCBvaW1vQm9keTogT0lNTy5SaWdpZEJvZHkgPSBvaW1vV29ybGQuZ2V0UmlnaWRCb2R5TGlzdCgpO1xyXG4gICAgICAgICAgb2ltb1dvcmxkLnJlbW92ZVJpZ2lkQm9keShvaW1vQm9keSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gLyoqIFJldHVybnMgdGhlIGFjdHVhbCB1c2VkIHdvcmxkIG9mIHRoZSBPSU1PIHBoeXNpY3MgZW5naW5lLiBObyB1c2VyIGludGVyYWN0aW9uIG5lZWRlZC4qL1xyXG4gICAgLy8gcHJpdmF0ZSBzdGF0aWMgZ2V0T2ltb1dvcmxkKCk6IE9JTU8uV29ybGQge1xyXG4gICAgLy8gICByZXR1cm4gUGh5c2ljcy4jYWN0aXZlUGh5c2ljcy5vaW1vV29ybGQ7XHJcbiAgICAvLyB9XHJcblxyXG4gICAgLy8gLyoqIFJldHVybnMgdGhlIENvbXBvbmVudFJpZ2lkYm9keSB3aXRoIHRoZSBnaXZlbiBpZC4gVXNlZCBpbnRlcm5hbGx5IHRvIHJlY29ubmVjdCBqb2ludHMgb24gbG9hZGluZyBpbiB0aGUgZWRpdG9yLiAqL1xyXG4gICAgLy8gcHJpdmF0ZSBzdGF0aWMgZ2V0Qm9keUJ5SUQoX2lkOiBudW1iZXIpOiBDb21wb25lbnRSaWdpZGJvZHkge1xyXG4gICAgLy8gICBsZXQgYm9keTogQ29tcG9uZW50UmlnaWRib2R5ID0gbnVsbDtcclxuICAgIC8vICAgUGh5c2ljcy4jYWN0aXZlUGh5c2ljcy5ib2R5TGlzdC5mb3JFYWNoKCh2YWx1ZTogQ29tcG9uZW50UmlnaWRib2R5KTogdm9pZCA9PiB7XHJcbiAgICAvLyAgICAgaWYgKHZhbHVlLmlkID09IF9pZCkge1xyXG4gICAgLy8gICAgICAgYm9keSA9IHZhbHVlO1xyXG4gICAgLy8gICAgIH1cclxuICAgIC8vICAgfSk7XHJcbiAgICAvLyAgIHJldHVybiBib2R5O1xyXG4gICAgLy8gfVxyXG5cclxuICAgIC8qKiBJbnRlcm5hbCBmdW5jdGlvbiB0byBjYWxjdWxhdGUgdGhlIGVuZHBvaW50IG9mIG1hdGhlbWF0aWNhbCByYXkuIEJ5IGFkZGluZyB0aGUgbXVsdGlwbGllZCBkaXJlY3Rpb24gdG8gdGhlIG9yaWdpbi4gXHJcbiAgICAgICAqIFVzZWQgYmVjYXVzZSBPaW1vUGh5c2ljcyBkZWZpbmVzIHJheSBieSBzdGFydC9lbmQuIEJ1dCBHYW1lRW5naW5lcyBjb21tb25seSB1c2Ugb3JpZ2luL2RpcmVjdGlvbi5cclxuICAgICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBnZXRSYXlFbmRQb2ludChzdGFydDogT0lNTy5WZWMzLCBkaXJlY3Rpb246IFZlY3RvcjMsIGxlbmd0aDogbnVtYmVyKTogT0lNTy5WZWMzIHtcclxuICAgICAgbGV0IG9yaWdpbjogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgb3JpZ2luLnNldChzdGFydC54LCBzdGFydC55LCBzdGFydC56KTtcclxuICAgICAgbGV0IHNjYWxlZERpcmVjdGlvbjogVmVjdG9yMyA9IGRpcmVjdGlvbi5jbG9uZTtcclxuICAgICAgc2NhbGVkRGlyZWN0aW9uLnNjYWxlKGxlbmd0aCk7XHJcbiAgICAgIGxldCBlbmRwb2ludDogVmVjdG9yMyA9IFZlY3RvcjMuU1VNKHNjYWxlZERpcmVjdGlvbiwgb3JpZ2luKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUoc2NhbGVkRGlyZWN0aW9uKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUoZW5kcG9pbnQpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShvcmlnaW4pO1xyXG4gICAgICByZXR1cm4gbmV3IE9JTU8uVmVjMyhlbmRwb2ludC54LCBlbmRwb2ludC55LCBlbmRwb2ludC56KTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogSW50ZXJuYWwgZnVuY3Rpb24gdG8gZ2V0IHRoZSBkaXN0YW5jZSBpbiB3aGljaCBhIHJheSBoaXQgYnkgc3VidHJhY3RpbmcgcG9pbnRzIGZyb20gZWFjaCBvdGhlciBhbmQgZ2V0IHRoZSBzcXVhcmUgcm9vdCBvZiB0aGUgc3F1YXJlZCBwcm9kdWN0IG9mIGVhY2ggY29tcG9uZW50LiAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0UmF5RGlzdGFuY2Uob3JpZ2luOiBWZWN0b3IzLCBoaXRQb2ludDogVmVjdG9yMyk6IG51bWJlciB7XHJcbiAgICAgIGxldCBkeDogbnVtYmVyID0gb3JpZ2luLnggLSBoaXRQb2ludC54O1xyXG4gICAgICBsZXQgZHk6IG51bWJlciA9IG9yaWdpbi55IC0gaGl0UG9pbnQueTtcclxuICAgICAgbGV0IGR6OiBudW1iZXIgPSBvcmlnaW4ueiAtIGhpdFBvaW50Lno7XHJcbiAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAvKipcclxuICAgIC8vICogR2V0dGluZyB0aGUgc29sdmVyIGl0ZXJhdGlvbnMgb2YgdGhlIHBoeXNpY3MgZW5naW5lLiBIaWdoZXIgaXRlcmF0aW9uIG51bWJlcnMgaW5jcmVhc2UgYWNjdXJhY3kgYnV0IGRlY3JlYXNlIHBlcmZvcm1hbmNlXHJcbiAgICAvLyAqL1xyXG4gICAgLy8gcHJpdmF0ZSBnZXRTb2x2ZXJJdGVyYXRpb25zKCk6IG51bWJlciB7XHJcbiAgICAvLyAgIHJldHVybiB0aGlzLm9pbW9Xb3JsZC5nZXROdW1Qb3NpdGlvbkl0ZXJhdGlvbnMoKTtcclxuICAgIC8vIH1cclxuXHJcbiAgICAvLyAvKipcclxuICAgIC8vICogU2V0dGluZyB0aGUgc29sdmVyIGl0ZXJhdGlvbnMgb2YgdGhlIHBoeXNpY3MgZW5naW5lLiBIaWdoZXIgaXRlcmF0aW9uIG51bWJlcnMgaW5jcmVhc2UgYWNjdXJhY3kgYnV0IGRlY3JlYXNlIHBlcmZvcm1hbmNlXHJcbiAgICAvLyAqL1xyXG4gICAgLy8gcHJpdmF0ZSBzZXRTb2x2ZXJJdGVyYXRpb25zKF92YWx1ZTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAvLyAgIHRoaXMub2ltb1dvcmxkLnNldE51bVBvc2l0aW9uSXRlcmF0aW9ucyhfdmFsdWUpO1xyXG4gICAgLy8gICB0aGlzLm9pbW9Xb3JsZC5zZXROdW1WZWxvY2l0eUl0ZXJhdGlvbnMoX3ZhbHVlKTtcclxuICAgIC8vIH1cclxuXHJcbiAgICAvLyAvKiogVXBkYXRlcyBhbGwge0BsaW5rIFJpZ2lkYm9kaWVzfSBrbm93biB0byB0aGUgUGh5c2ljcy53b3JsZCB0byBtYXRjaCB0aGVpciBjb250YWluZXJzIG9yIG1lc2hlcyB0cmFuc2Zvcm1hdGlvbnMgKi9cclxuICAgIC8vIHByaXZhdGUgdXBkYXRlV29ybGRGcm9tV29ybGRNYXRyaXgoX3RvTWVzaDogYm9vbGVhbiA9IGZhbHNlKTogdm9pZCB7XHJcbiAgICAvLyAgIGZvciAobGV0IGJvZHkgb2YgdGhpcy5ib2R5TGlzdClcclxuICAgIC8vICAgICBib2R5LnVwZGF0ZUZyb21Xb3JsZChfdG9NZXNoKTtcclxuICAgIC8vIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgICogU3RvcmluZyBhbmQgbWFuaXB1bGF0aW5nIHJvdGF0aW9ucyBpbiB0aGUgZm9ybSBvZiBxdWF0ZXJuaW9ucy5cclxuICAgICogQ29uc3RydWN0ZWQgb3V0IG9mIHRoZSA0IGNvbXBvbmVudHMgeCx5LHosdy4gQ29tbW9ubHkgdXNlZCB0byBjYWxjdWxhdGUgcm90YXRpb25zIGluIHBoeXNpY3MgZW5naW5lcy5cclxuICAgICogQ2xhc3MgbW9zdGx5IHVzZWQgaW50ZXJuYWxseSB0byBicmlkZ2UgdGhlIGluIEZVREdFIGNvbW1vbmx5IHVzZWQgYW5nbGVzIGluIGRlZ3JlZSB0byBPaW1vUGh5c2ljcyBxdWF0ZXJuaW9uIHN5c3RlbS5cclxuICAgICogQGF1dGhvcnMgTWFya28gRmVocmVuYmFjaCwgSEZVLCAyMDIwXHJcbiAgICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBRdWF0ZXJuaW9uIGV4dGVuZHMgTXV0YWJsZSB7XHJcbiAgICBwcml2YXRlIHg6IG51bWJlcjtcclxuICAgIHByaXZhdGUgeTogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSB6OiBudW1iZXI7XHJcbiAgICBwcml2YXRlIHc6IG51bWJlcjtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3g6IG51bWJlciA9IDAsIF95OiBudW1iZXIgPSAwLCBfejogbnVtYmVyID0gMCwgX3c6IG51bWJlciA9IDApIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy54ID0gX3g7XHJcbiAgICAgIHRoaXMueSA9IF95O1xyXG4gICAgICB0aGlzLnogPSBfejtcclxuICAgICAgdGhpcy53ID0gX3c7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEdldC9TZXQgdGhlIFggY29tcG9uZW50IG9mIHRoZSBRdWF0ZXJuaW9uLiBSZWFsIFBhcnQgKi9cclxuICAgIGdldCBYKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLng7XHJcbiAgICB9XHJcbiAgICBzZXQgWChfeDogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMueCA9IF94O1xyXG4gICAgfVxyXG4gICAgLyoqIEdldC9TZXQgdGhlIFkgY29tcG9uZW50IG9mIHRoZSBRdWF0ZXJuaW9uLiBSZWFsIFBhcnQgKi9cclxuICAgIGdldCBZKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLnk7XHJcbiAgICB9XHJcbiAgICBzZXQgWShfeTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMueSA9IF95O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBHZXQvU2V0IHRoZSBaIGNvbXBvbmVudCBvZiB0aGUgUXVhdGVybmlvbi4gUmVhbCBQYXJ0ICovXHJcbiAgICBnZXQgWigpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy56O1xyXG4gICAgfVxyXG4gICAgc2V0IFooX3o6IG51bWJlcikge1xyXG4gICAgICB0aGlzLnogPSBfejtcclxuICAgIH1cclxuXHJcbiAgICAvKiogR2V0L1NldCB0aGUgWSBjb21wb25lbnQgb2YgdGhlIFF1YXRlcm5pb24uIEltYWdpbmFyeSBQYXJ0ICovXHJcbiAgICBnZXQgVygpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy53O1xyXG4gICAgfVxyXG4gICAgc2V0IFcoX3c6IG51bWJlcikge1xyXG4gICAgICB0aGlzLncgPSBfdztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBxdWF0ZXJuaW9uIGZyb20gdmVjdG9yMyBhbmdsZXMgaW4gZGVncmVlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRGcm9tVmVjdG9yMyhyb2xsWDogbnVtYmVyLCBwaXRjaFk6IG51bWJlciwgeWF3WjogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIGxldCBjeTogbnVtYmVyID0gTWF0aC5jb3MoeWF3WiAqIDAuNSk7XHJcbiAgICAgIGxldCBzeTogbnVtYmVyID0gTWF0aC5zaW4oeWF3WiAqIDAuNSk7XHJcbiAgICAgIGxldCBjcDogbnVtYmVyID0gTWF0aC5jb3MocGl0Y2hZICogMC41KTtcclxuICAgICAgbGV0IHNwOiBudW1iZXIgPSBNYXRoLnNpbihwaXRjaFkgKiAwLjUpO1xyXG4gICAgICBsZXQgY3I6IG51bWJlciA9IE1hdGguY29zKHJvbGxYICogMC41KTtcclxuICAgICAgbGV0IHNyOiBudW1iZXIgPSBNYXRoLnNpbihyb2xsWCAqIDAuNSk7XHJcblxyXG4gICAgICB0aGlzLncgPSBjciAqIGNwICogY3kgKyBzciAqIHNwICogc3k7XHJcbiAgICAgIHRoaXMueCA9IHNyICogY3AgKiBjeSAtIGNyICogc3AgKiBzeTtcclxuICAgICAgdGhpcy55ID0gY3IgKiBzcCAqIGN5ICsgc3IgKiBjcCAqIHN5O1xyXG4gICAgICB0aGlzLnogPSBjciAqIGNwICogc3kgLSBzciAqIHNwICogY3k7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBldWxlciBhbmdsZXMgaW4gcmFkaWFucyBhcyBWZWN0b3IzIGZyb20gdGhpcyBxdWF0ZXJuaW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdG9FdWxlcmFuZ2xlcygpOiBWZWN0b3IzIHsgLy9TaW5ndWxhcml0aWVzIHBvc3NpYmxlXHJcbiAgICAgIGxldCBhbmdsZXM6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuICAgICAgLy8gcm9sbCAoeC1heGlzIHJvdGF0aW9uKVxyXG4gICAgICBsZXQgc2lucmNvc3A6IG51bWJlciA9IDIgKiAodGhpcy53ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy56KTtcclxuICAgICAgbGV0IGNvc3Jjb3NwOiBudW1iZXIgPSAxIC0gMiAqICh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkpO1xyXG4gICAgICBhbmdsZXMueCA9IE1hdGguYXRhbjIoc2lucmNvc3AsIGNvc3Jjb3NwKTtcclxuXHJcbiAgICAgIC8vIHBpdGNoICh5LWF4aXMgcm90YXRpb24pXHJcbiAgICAgIGxldCBzaW5wOiBudW1iZXIgPSAyICogKHRoaXMudyAqIHRoaXMueSAtIHRoaXMueiAqIHRoaXMueCk7XHJcbiAgICAgIGlmIChNYXRoLmFicyhzaW5wKSA+PSAxKVxyXG4gICAgICAgIGFuZ2xlcy55ID0gdGhpcy5jb3B5c2lnbihNYXRoLlBJIC8gMiwgc2lucCk7IC8vIHVzZSA5MCBkZWdyZWVzIGlmIG91dCBvZiByYW5nZVxyXG4gICAgICBlbHNlXHJcbiAgICAgICAgYW5nbGVzLnkgPSBNYXRoLmFzaW4oc2lucCk7XHJcblxyXG4gICAgICAvLyB5YXcgKHotYXhpcyByb3RhdGlvbilcclxuICAgICAgbGV0IHNpbnljb3NwOiBudW1iZXIgPSAyICogKHRoaXMudyAqIHRoaXMueiArIHRoaXMueCAqIHRoaXMueSk7XHJcbiAgICAgIGxldCBjb3N5Y29zcDogbnVtYmVyID0gMSAtIDIgKiAodGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56KTtcclxuICAgICAgYW5nbGVzLnogPSBNYXRoLmF0YW4yKHNpbnljb3NwLCBjb3N5Y29zcCk7XHJcblxyXG4gICAgICByZXR1cm4gYW5nbGVzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGFuZ2xlcyBpbiBkZWdyZWVzIGFzIHZlY3RvcjMgZnJvbSB0aGlzLiBxdWF0ZXJpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRvRGVncmVlcygpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IGFuZ2xlczogVmVjdG9yMyA9IHRoaXMudG9FdWxlcmFuZ2xlcygpO1xyXG4gICAgICBhbmdsZXMueCA9IGFuZ2xlcy54ICogKDE4MCAvIE1hdGguUEkpO1xyXG4gICAgICBhbmdsZXMueSA9IGFuZ2xlcy55ICogKDE4MCAvIE1hdGguUEkpO1xyXG4gICAgICBhbmdsZXMueiA9IGFuZ2xlcy56ICogKDE4MCAvIE1hdGguUEkpO1xyXG4gICAgICByZXR1cm4gYW5nbGVzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHtcclxuICAgICAgICB4OiB0aGlzLngsIHk6IHRoaXMueSwgejogdGhpcy56LCB3OiB0aGlzLndcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQgey8qKiAqLyB9XHJcblxyXG4gICAgLyoqIENvcHlpbmcgdGhlIHNpZ24gb2YgYSB0byBiICovXHJcbiAgICBwcml2YXRlIGNvcHlzaWduKGE6IG51bWJlciwgYjogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIGIgPCAwID8gLU1hdGguYWJzKGEpIDogTWF0aC5hYnMoYSk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogRGVmaW5lcyBhIHRocmVlZGltZW5zaW9uYWwgYm94IGJ5IHR3byBjb3JuZXItcG9pbnRzLCBvbmUgd2l0aCBtaW5pbWFsIHZhbHVlcyBhbmQgb25lIHdpdGggbWF4aW11bSB2YWx1ZXNcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQm94IGltcGxlbWVudHMgUmVjeWNhYmxlIHtcclxuICAgIHB1YmxpYyBtaW46IFZlY3RvcjM7XHJcbiAgICBwdWJsaWMgbWF4OiBWZWN0b3IzO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKF9taW46IFZlY3RvcjMgPSBWZWN0b3IzLk9ORShJbmZpbml0eSksIF9tYXg6IFZlY3RvcjMgPSBWZWN0b3IzLk9ORSgtSW5maW5pdHkpKSB7XHJcbiAgICAgIHRoaXMuc2V0KF9taW4sIF9tYXgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lIHRoZSBjb3JuZXJzIG9mIHRoaXMgYm94LCBzdGFuZGFyZCB2YWx1ZXMgYXJlIEluZmluaXR5IGZvciBtaW4sIGFuZCAtSW5maW5pdHkgZm9yIG1heCwgXHJcbiAgICAgKiBjcmVhdGluZyBhbiBpbXBvc3NpYmxlIGludmVydGVkIGJveCB0aGF0IGNhbiBub3QgY29udGFpbiBhbnkgcG9pbnRzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQoX21pbjogVmVjdG9yMyA9IFZlY3RvcjMuT05FKEluZmluaXR5KSwgX21heDogVmVjdG9yMyA9IFZlY3RvcjMuT05FKC1JbmZpbml0eSkpOiB2b2lkIHtcclxuICAgICAgdGhpcy5taW4gPSBfbWluO1xyXG4gICAgICB0aGlzLm1heCA9IF9tYXg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHBhbmQgdGhlIGJveCBpZiBuZWNlc3NhcnkgdG8gaW5jbHVkZSB0aGUgZ2l2ZW4gcG9pbnRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGV4cGFuZChfaW5jbHVkZTogVmVjdG9yMyk6IHZvaWQge1xyXG4gICAgICB0aGlzLm1pbi5taW4oX2luY2x1ZGUpO1xyXG4gICAgICB0aGlzLm1heC5tYXgoX2luY2x1ZGUpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBwdWJsaWMgcmVjeWNsZSgpOiB2b2lkIHtcclxuICAgICAgdGhpcy5taW4uc2V0KEluZmluaXR5LCBJbmZpbml0eSwgSW5maW5pdHkpO1xyXG4gICAgICB0aGlzLm1heC5zZXQoLUluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eSk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogU3RvcmVzIGluZm9ybWF0aW9uIHByb3ZpZGVkIGJ5IHtAbGluayBSZW5kZXJ9LXBpY2tpbmcgZS5nLiB1c2luZyB7QGxpbmsgUGlja2VyfSBhbmQgcHJvdmlkZXMgbWV0aG9kcyBmb3IgZnVydGhlciBjYWxjdWxhdGlvbiBvZiBwb3NpdGlvbnMgYW5kIG5vcm1hbHMgZXRjLlxyXG4gICAqIFxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFBpY2sge1xyXG4gICAgcHVibGljIG5vZGU6IE5vZGU7XHJcbiAgICBwdWJsaWMgekJ1ZmZlcjogbnVtYmVyO1xyXG4gICAgcHVibGljIGNvbG9yOiBDb2xvcjtcclxuICAgIHB1YmxpYyB0ZXh0dXJlVVY6IFZlY3RvcjI7XHJcbiAgICAjbXR4Vmlld1RvV29ybGQ6IE1hdHJpeDR4NDtcclxuICAgICNwb3NXb3JsZDogVmVjdG9yMztcclxuICAgICNwb3NNZXNoOiBWZWN0b3IzO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKF9ub2RlOiBOb2RlKSB7XHJcbiAgICAgIHRoaXMubm9kZSA9IF9ub2RlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWNjZXNzb3IgdG8gY2FsY3VsYXRlIGFuZCBzdG9yZSB3b3JsZCBwb3NpdGlvbiBvZiBpbnRlcnNlY3Rpb24gb2Yge0BsaW5rIFJheX0gYW5kIHtAbGluayBNZXNofSBvbmx5IHdoZW4gdXNlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBwb3NXb3JsZCgpOiBWZWN0b3IzIHtcclxuICAgICAgaWYgKHRoaXMuI3Bvc1dvcmxkKVxyXG4gICAgICAgIHJldHVybiB0aGlzLiNwb3NXb3JsZDtcclxuICAgICAgbGV0IHBvaW50SW5DbGlwU3BhY2U6IFZlY3RvcjMgPSBWZWN0b3IzLloodGhpcy56QnVmZmVyKTtcclxuICAgICAgbGV0IG06IEZsb2F0MzJBcnJheSA9IHRoaXMuI210eFZpZXdUb1dvcmxkLmdldCgpO1xyXG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IzID0gVmVjdG9yMy5UUkFOU0ZPUk1BVElPTihwb2ludEluQ2xpcFNwYWNlLCB0aGlzLiNtdHhWaWV3VG9Xb3JsZCwgdHJ1ZSk7XHJcbiAgICAgIGxldCB3OiBudW1iZXIgPSBtWzNdICogcG9pbnRJbkNsaXBTcGFjZS54ICsgbVs3XSAqIHBvaW50SW5DbGlwU3BhY2UueSArIG1bMTFdICogcG9pbnRJbkNsaXBTcGFjZS56ICsgbVsxNV07XHJcbiAgICAgIHJlc3VsdC5zY2FsZSgxIC8gdyk7XHJcblxyXG4gICAgICB0aGlzLiNwb3NXb3JsZCA9IHJlc3VsdDtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFjY2Vzc29yIHRvIGNhbGN1bGF0ZSBhbmQgc3RvcmUgcG9zaXRpb24gaW4gbWVzaC1zcGFjZSBvZiBpbnRlcnNlY3Rpb24gb2Yge0BsaW5rIFJheX0gYW5kIHtAbGluayBNZXNofSBvbmx5IHdoZW4gdXNlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBwb3NNZXNoKCk6IFZlY3RvcjMge1xyXG4gICAgICBpZiAodGhpcy4jcG9zTWVzaClcclxuICAgICAgICByZXR1cm4gdGhpcy4jcG9zTWVzaDtcclxuICAgICAgbGV0IG10eFdvcmxkVG9NZXNoOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSU5WRVJTSU9OKHRoaXMubm9kZS5nZXRDb21wb25lbnQoQ29tcG9uZW50TWVzaCkubXR4V29ybGQpO1xyXG4gICAgICBsZXQgcG9zTWVzaDogVmVjdG9yMyA9IFZlY3RvcjMuVFJBTlNGT1JNQVRJT04odGhpcy5wb3NXb3JsZCwgbXR4V29ybGRUb01lc2gpO1xyXG4gICAgICB0aGlzLiNwb3NNZXNoID0gcG9zTWVzaDtcclxuICAgICAgcmV0dXJuIHBvc01lc2g7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBY2Nlc3NvciB0byBjYWxjdWxhdGUgYW5kIHN0b3JlIHRoZSBmYWNlIG5vcm1hbCBpbiB3b3JsZC1zcGFjZSBhdCB0aGUgcG9pbnQgb2YgaW50ZXJzZWN0aW9uIG9mIHtAbGluayBSYXl9IGFuZCB7QGxpbmsgTWVzaH0gb25seSB3aGVuIHVzZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgbm9ybWFsKCk6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgY21wTWVzaDogQ29tcG9uZW50TWVzaCA9IHRoaXMubm9kZS5nZXRDb21wb25lbnQoQ29tcG9uZW50TWVzaCk7XHJcbiAgICAgIGxldCBtZXNoOiBNZXNoID0gY21wTWVzaC5tZXNoO1xyXG4gICAgICBsZXQgbm9ybWFsOiBWZWN0b3IzID0gVmVjdG9yMy5aRVJPKCk7XHJcbiAgICAgIGxldCB2ZXJ0ZXg6IFZlY3RvcjMgPSBWZWN0b3IzLlpFUk8oKTtcclxuICAgICAgbGV0IG1pbkRpc3RhbmNlOiBudW1iZXIgPSBJbmZpbml0eTtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMztcclxuXHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDI7IGkgPCBtZXNoLmluZGljZXMubGVuZ3RoOyBpICs9IDMpIHtcclxuICAgICAgICBsZXQgaVZlcnRleDogbnVtYmVyID0gbWVzaC5pbmRpY2VzW2ldO1xyXG4gICAgICAgIGxldCBbeCwgeSwgel0gPSBtZXNoLnZlcnRpY2VzLnN1YmFycmF5KGlWZXJ0ZXggKiAzLCAoaVZlcnRleCArIDEpICogMyk7XHJcbiAgICAgICAgdmVydGV4LnNldCh4LCB5LCB6KTtcclxuICAgICAgICBbeCwgeSwgel0gPSBtZXNoLm5vcm1hbHNGbGF0LnN1YmFycmF5KGlWZXJ0ZXggKiAzLCAoaVZlcnRleCArIDEpICogMyk7XHJcbiAgICAgICAgbm9ybWFsLnNldCh4LCB5LCB6KTtcclxuXHJcbiAgICAgICAgbGV0IGRpZmZlcmVuY2U6IFZlY3RvcjMgPSBWZWN0b3IzLkRJRkZFUkVOQ0UodGhpcy5wb3NNZXNoLCB2ZXJ0ZXgpO1xyXG4gICAgICAgIGxldCBkaXN0YW5jZTogbnVtYmVyID0gTWF0aC5hYnMoVmVjdG9yMy5ET1Qobm9ybWFsLCBkaWZmZXJlbmNlKSk7XHJcbiAgICAgICAgaWYgKGRpc3RhbmNlIDwgbWluRGlzdGFuY2UpIHtcclxuICAgICAgICAgIHJlc3VsdCA9IG5vcm1hbC5jbG9uZTtcclxuICAgICAgICAgIG1pbkRpc3RhbmNlID0gZGlzdGFuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXN1bHQudHJhbnNmb3JtKGNtcE1lc2gubXR4V29ybGQsIGZhbHNlKTtcclxuICAgICAgcmVzdWx0Lm5vcm1hbGl6ZSgpO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHNvbGVseSBieSB0aGUgcmVuZGVyZXIgdG8gZW5hYmxlIGNhbGN1bGF0aW9uIG9mIHRoZSB3b3JsZCBjb29yZGluYXRlcyBvZiB0aGlzIHtAbGluayBQaWNrfVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0IG10eFZpZXdUb1dvcmxkKF9tdHhWaWV3VG9Xb3JsZDogTWF0cml4NHg0KSB7XHJcbiAgICAgIHRoaXMuI210eFZpZXdUb1dvcmxkID0gX210eFZpZXdUb1dvcmxkO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFByb3ZpZGVzIHN0YXRpYyBtZXRob2RzIGZvciBwaWNraW5nIHVzaW5nIHtAbGluayBSZW5kZXJ9XHJcbiAgICogXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgUGlja2VyIHtcclxuICAgIC8qKlxyXG4gICAgICogVGFrZXMgYSByYXkgcGx1cyBtaW4gYW5kIG1heCB2YWx1ZXMgZm9yIHRoZSBuZWFyIGFuZCBmYXIgcGxhbmVzIHRvIGNvbnN0cnVjdCB0aGUgcGlja2VyLWNhbWVyYSxcclxuICAgICAqIHRoZW4gcmVuZGVycyB0aGUgcGljay10ZXh0dXJlIGFuZCByZXR1cm5zIGFuIHVuc29ydGVkIHtAbGluayBQaWNrfS1hcnJheSB3aXRoIGluZm9ybWF0aW9uIGFib3V0IHRoZSBoaXRzIG9mIHRoZSByYXkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcGlja1JheShfYnJhbmNoOiBOb2RlLCBfcmF5OiBSYXksIF9taW46IG51bWJlciwgX21heDogbnVtYmVyKTogUGlja1tdIHtcclxuICAgICAgbGV0IGNtcENhbWVyYVBpY2s6IENvbXBvbmVudENhbWVyYSA9IG5ldyBDb21wb25lbnRDYW1lcmEoKTtcclxuICAgICAgY21wQ2FtZXJhUGljay5tdHhQaXZvdC50cmFuc2xhdGlvbiA9IF9yYXkub3JpZ2luO1xyXG4gICAgICBjbXBDYW1lcmFQaWNrLm10eFBpdm90Lmxvb2tBdChfcmF5LmRpcmVjdGlvbik7XHJcbiAgICAgIGNtcENhbWVyYVBpY2sucHJvamVjdENlbnRyYWwoMSwgMC4wMDEsIEZJRUxEX09GX1ZJRVcuRElBR09OQUwsIF9taW4sIF9tYXgpO1xyXG5cclxuICAgICAgbGV0IHBpY2tzOiBQaWNrW10gPSBSZW5kZXIucGlja0JyYW5jaChfYnJhbmNoLCBjbXBDYW1lcmFQaWNrKTtcclxuICAgICAgcmV0dXJuIHBpY2tzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGFrZXMgYSBjYW1lcmEgYW5kIGEgcG9pbnQgb24gaXRzIHZpcnR1YWwgbm9ybWVkIHByb2plY3Rpb24gcGxhbmUgKGRpc3RhbmNlIDEpIHRvIGNvbnN0cnVjdCB0aGUgcGlja2VyLWNhbWVyYSxcclxuICAgICAqIHRoZW4gcmVuZGVycyB0aGUgcGljay10ZXh0dXJlIGFuZCByZXR1cm5zIGFuIHVuc29ydGVkIHtAbGluayBQaWNrfS1hcnJheSB3aXRoIGluZm9ybWF0aW9uIGFib3V0IHRoZSBoaXRzIG9mIHRoZSByYXkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcGlja0NhbWVyYShfYnJhbmNoOiBOb2RlLCBfY21wQ2FtZXJhOiBDb21wb25lbnRDYW1lcmEsIF9wb3NQcm9qZWN0aW9uOiBWZWN0b3IyKTogUGlja1tdIHtcclxuICAgICAgbGV0IHJheTogUmF5ID0gbmV3IFJheShuZXcgVmVjdG9yMygtX3Bvc1Byb2plY3Rpb24ueCwgX3Bvc1Byb2plY3Rpb24ueSwgMSkpO1xyXG4gICAgICBsZXQgbGVuZ3RoOiBudW1iZXIgPSByYXkuZGlyZWN0aW9uLm1hZ25pdHVkZTtcclxuXHJcbiAgICAgIGlmIChfY21wQ2FtZXJhLm5vZGUpIHtcclxuICAgICAgICBsZXQgbXR4Q2FtZXJhOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuTVVMVElQTElDQVRJT04oX2NtcENhbWVyYS5ub2RlLm10eFdvcmxkLCBfY21wQ2FtZXJhLm10eFBpdm90KTtcclxuICAgICAgICByYXkudHJhbnNmb3JtKG10eENhbWVyYSk7XHJcbiAgICAgICAgUmVjeWNsZXIuc3RvcmUobXR4Q2FtZXJhKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlXHJcbiAgICAgICAgcmF5LnRyYW5zZm9ybShfY21wQ2FtZXJhLm10eFBpdm90KTtcclxuXHJcblxyXG4gICAgICBsZXQgcGlja3M6IFBpY2tbXSA9IFBpY2tlci5waWNrUmF5KF9icmFuY2gsIHJheSwgbGVuZ3RoICogX2NtcENhbWVyYS5nZXROZWFyKCksIGxlbmd0aCAqIF9jbXBDYW1lcmEuZ2V0RmFyKCkpO1xyXG4gICAgICByZXR1cm4gcGlja3M7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUYWtlcyB0aGUgY2FtZXJhIG9mIHRoZSBnaXZlbiB2aWV3cG9ydCBhbmQgYSBwb2ludCB0aGUgY2xpZW50IHN1cmZhY2UgdG8gY29uc3RydWN0IHRoZSBwaWNrZXItY2FtZXJhLFxyXG4gICAgICogdGhlbiByZW5kZXJzIHRoZSBwaWNrLXRleHR1cmUgYW5kIHJldHVybnMgYW4gdW5zb3J0ZWQge0BsaW5rIFBpY2t9LWFycmF5IHdpdGggaW5mb3JtYXRpb24gYWJvdXQgdGhlIGhpdHMgb2YgdGhlIHJheS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBwaWNrVmlld3BvcnQoX3ZpZXdwb3J0OiBWaWV3cG9ydCwgX3Bvc0NsaWVudDogVmVjdG9yMik6IFBpY2tbXSB7XHJcbiAgICAgIGxldCBwb3NQcm9qZWN0aW9uOiBWZWN0b3IyID0gX3ZpZXdwb3J0LnBvaW50Q2xpZW50VG9Qcm9qZWN0aW9uKF9wb3NDbGllbnQpO1xyXG4gICAgICBsZXQgcGlja3M6IFBpY2tbXSA9IFBpY2tlci5waWNrQ2FtZXJhKF92aWV3cG9ydC5nZXRCcmFuY2goKSwgX3ZpZXdwb3J0LmNhbWVyYSwgcG9zUHJvamVjdGlvbik7XHJcbiAgICAgIHJldHVybiBwaWNrcztcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBEZWZpbmVkIGJ5IGFuIG9yaWdpbiBhbmQgYSBkaXJlY3Rpb24gb2YgdHlwZSB7QGxpbmsgUGlja30sIHJheXMgYXJlIHVzZWQgdG8gY2FsY3VsYXRlIHBpY2tpbmcgYW5kIGludGVyc2VjdGlvbnNcclxuICAgKiBcclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBSYXkge1xyXG4gICAgcHVibGljIG9yaWdpbjogVmVjdG9yMztcclxuICAgIHB1YmxpYyBkaXJlY3Rpb246IFZlY3RvcjM7XHJcbiAgICAvKiogVE9ETzogc3VwcG9ydCBsZW5ndGggKi9cclxuICAgIHB1YmxpYyBsZW5ndGg6IG51bWJlcjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihfZGlyZWN0aW9uOiBWZWN0b3IzID0gVmVjdG9yMy5aKDEpLCBfb3JpZ2luOiBWZWN0b3IzID0gVmVjdG9yMy5aRVJPKCksIF9sZW5ndGg6IG51bWJlciA9IDEpIHtcclxuICAgICAgdGhpcy5vcmlnaW4gPSBfb3JpZ2luO1xyXG4gICAgICB0aGlzLmRpcmVjdGlvbiA9IF9kaXJlY3Rpb247XHJcbiAgICAgIHRoaXMubGVuZ3RoID0gX2xlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHBvaW50IG9mIGludGVyc2VjdGlvbiBvZiB0aGlzIHJheSB3aXRoIGEgcGxhbmUgZGVmaW5lZCBieSBcclxuICAgICAqIHRoZSBnaXZlbiBwb2ludCBvZiBvcmlnaW4gYW5kIHRoZSBwbGFuZXMgbm9ybWFsLiBBbGwgdmFsdWVzIGFuZCBjYWxjdWxhdGlvbnNcclxuICAgICAqIG11c3QgYmUgcmVsYXRpdmUgdG8gdGhlIHNhbWUgY29vcmRpbmF0ZSBzeXN0ZW0sIHByZWZlcmFibHkgdGhlIHdvcmxkXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpbnRlcnNlY3RQbGFuZShfb3JpZ2luOiBWZWN0b3IzLCBfbm9ybWFsOiBWZWN0b3IzKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCBkaWZmZXJlbmNlOiBWZWN0b3IzID0gVmVjdG9yMy5ESUZGRVJFTkNFKF9vcmlnaW4sIHRoaXMub3JpZ2luKTtcclxuICAgICAgbGV0IGZhY3RvcjogbnVtYmVyID0gVmVjdG9yMy5ET1QoZGlmZmVyZW5jZSwgX25vcm1hbCkgLyBWZWN0b3IzLkRPVCh0aGlzLmRpcmVjdGlvbiwgX25vcm1hbCk7XHJcbiAgICAgIGxldCBpbnRlcnNlY3Q6IFZlY3RvcjMgPSBWZWN0b3IzLlNVTSh0aGlzLm9yaWdpbiwgVmVjdG9yMy5TQ0FMRSh0aGlzLmRpcmVjdGlvbiwgZmFjdG9yKSk7XHJcbiAgICAgIHJldHVybiBpbnRlcnNlY3Q7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBwb2ludCBvZiBpbnRlcnNlY3Rpb24gb2YgdGhpcyByYXkgd2l0aCBhIHBsYW5lIGRlZmluZWQgYnkgdGhlIGZhY2UuIFxyXG4gICAgICogQWxsIHZhbHVlcyBhbmQgY2FsY3VsYXRpb25zIG11c3QgYmUgcmVsYXRpdmUgdG8gdGhlIHNhbWUgY29vcmRpbmF0ZSBzeXN0ZW0sIHByZWZlcmFibHkgdGhlIHdvcmxkXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpbnRlcnNlY3RGYWNlUGxhbmUoX2ZhY2U6IEZhY2UpOiBWZWN0b3IzIHtcclxuICAgICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0UGxhbmUoX2ZhY2UuZ2V0UG9zaXRpb24oMCksIF9mYWNlLm5vcm1hbCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzaG9ydGVzdCBkaXN0YW5jZSBmcm9tIHRoZSByYXkgdG8gdGhlIGdpdmVuIHRhcmdldCBwb2ludC5cclxuICAgICAqIEFsbCB2YWx1ZXMgYW5kIGNhbGN1bGF0aW9ucyBtdXN0IGJlIHJlbGF0aXZlIHRvIHRoZSBzYW1lIGNvb3JkaW5hdGUgc3lzdGVtLCBwcmVmZXJhYmx5IHRoZSB3b3JsZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldERpc3RhbmNlKF90YXJnZXQ6IFZlY3RvcjMpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IG9yaWdpblRvVGFyZ2V0OiBWZWN0b3IzID0gVmVjdG9yMy5ESUZGRVJFTkNFKF90YXJnZXQsIHRoaXMub3JpZ2luKTtcclxuICAgICAgbGV0IHJheVNlY3Rpb246IFZlY3RvcjMgPSBWZWN0b3IzLk5PUk1BTElaQVRJT04odGhpcy5kaXJlY3Rpb24sIDEpO1xyXG4gICAgICBsZXQgcHJvamVjdGVkTGVuZ3RoOiBudW1iZXIgPSBWZWN0b3IzLkRPVChvcmlnaW5Ub1RhcmdldCwgcmF5U2VjdGlvbik7XHJcbiAgICAgIHJheVNlY3Rpb24uc2NhbGUocHJvamVjdGVkTGVuZ3RoKTtcclxuICAgICAgcmF5U2VjdGlvbi5hZGQodGhpcy5vcmlnaW4pO1xyXG4gICAgICBsZXQgZGlzdGFuY2U6IFZlY3RvcjMgPSBWZWN0b3IzLkRJRkZFUkVOQ0UoX3RhcmdldCwgcmF5U2VjdGlvbik7XHJcbiAgICAgIHJldHVybiBkaXN0YW5jZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zZm9ybSB0aGUgcmF5IGJ5IHRoZSBnaXZlbiBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgcHVibGljIHRyYW5zZm9ybShfbXR4VHJhbnNmb3JtOiBNYXRyaXg0eDQpOiB2b2lkIHtcclxuICAgICAgdGhpcy5kaXJlY3Rpb24udHJhbnNmb3JtKF9tdHhUcmFuc2Zvcm0pO1xyXG4gICAgICB0aGlzLm9yaWdpbi50cmFuc2Zvcm0oX210eFRyYW5zZm9ybSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcmVhZGFibGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcmF5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gYG9yaWdpbjogJHt0aGlzLm9yaWdpbi50b1N0cmluZygpfSwgZGlyZWN0aW9uOiAke3RoaXMuZGlyZWN0aW9uLnRvU3RyaW5nKCl9LCBsZW5ndGg6ICR7dGhpcy5sZW5ndGgudG9QcmVjaXNpb24oNSl9YDtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgdHlwZSBNYXBMaWdodFR5cGVUb0xpZ2h0TGlzdCA9IE1hcDxUeXBlT2ZMaWdodCwgQ29tcG9uZW50TGlnaHRbXT47XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgUmVuZGVyUHJlcGFyZU9wdGlvbnMge1xyXG4gICAgaWdub3JlUGh5c2ljcz86IGJvb2xlYW47XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgbWFpbiBpbnRlcmZhY2UgdG8gdGhlIHJlbmRlciBlbmdpbmUsIGhlcmUgV2ViR0wgKHNlZSBzdXBlcmNsYXNzIHtAbGluayBSZW5kZXJXZWJHTH0gYW5kIHRoZSBSZW5kZXJJbmplY3RvcnNcclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgUmVuZGVyIGV4dGVuZHMgUmVuZGVyV2ViR0wge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWN0Q2xpcDogUmVjdGFuZ2xlID0gbmV3IFJlY3RhbmdsZSgtMSwgMSwgMiwgLTIpO1xyXG4gICAgcHVibGljIHN0YXRpYyBwaWNrQnVmZmVyOiBJbnQzMkFycmF5O1xyXG4gICAgcHVibGljIHN0YXRpYyBub2Rlc1BoeXNpY3M6IFJlY3ljYWJsZUFycmF5PE5vZGU+ID0gbmV3IFJlY3ljYWJsZUFycmF5KCk7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBub2Rlc1NpbXBsZTogUmVjeWNhYmxlQXJyYXk8Tm9kZT4gPSBuZXcgUmVjeWNhYmxlQXJyYXkoKTtcclxuICAgIHByaXZhdGUgc3RhdGljIG5vZGVzQWxwaGE6IFJlY3ljYWJsZUFycmF5PE5vZGU+ID0gbmV3IFJlY3ljYWJsZUFycmF5KCk7XHJcbiAgICBwcml2YXRlIHN0YXRpYyB0aW1lc3RhbXBVcGRhdGU6IG51bWJlcjtcclxuXHJcbiAgICAvLyBUT0RPOiByZXNlYXJjaCBpZiBwaWNraW5nIHNob3VsZCBiZSBvcHRpbWl6ZWQgdXNpbmcgcmFkaXVzIHBpY2tpbmcgdG8gZmlsdGVyXHJcblxyXG4gICAgLy8jcmVnaW9uIFByZXBhcmVcclxuICAgIC8qKlxyXG4gICAgICogUmVjdXJzaXZlbHkgaXRlcmF0ZXMgb3ZlciB0aGUgYnJhbmNoIHN0YXJ0aW5nIHdpdGggdGhlIG5vZGUgZ2l2ZW4sIHJlY2FsY3VsYXRlcyBhbGwgd29ybGQgdHJhbnNmb3JtcywgXHJcbiAgICAgKiBjb2xsZWN0cyBhbGwgbGlnaHRzIGFuZCBmZWVkcyBhbGwgc2hhZGVycyB1c2VkIGluIHRoZSBncmFwaCB3aXRoIHRoZXNlIGxpZ2h0cy4gU29ydHMgbm9kZXMgZm9yIGRpZmZlcmVudFxyXG4gICAgICogcmVuZGVyIHBhc3Nlcy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBwcmVwYXJlKF9icmFuY2g6IE5vZGUsIF9vcHRpb25zOiBSZW5kZXJQcmVwYXJlT3B0aW9ucyA9IHt9LCBfbXR4V29ybGQ6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpLCBfbGlnaHRzOiBNYXBMaWdodFR5cGVUb0xpZ2h0TGlzdCA9IG5ldyBNYXAoKSwgX3NoYWRlcnNVc2VkOiAodHlwZW9mIFNoYWRlcilbXSA9IG51bGwpOiB2b2lkIHtcclxuICAgICAgbGV0IGZpcnN0TGV2ZWw6IGJvb2xlYW4gPSAoX3NoYWRlcnNVc2VkID09IG51bGwpO1xyXG4gICAgICBpZiAoZmlyc3RMZXZlbCkge1xyXG4gICAgICAgIF9zaGFkZXJzVXNlZCA9IFtdO1xyXG4gICAgICAgIFJlbmRlci50aW1lc3RhbXBVcGRhdGUgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICBSZW5kZXIubm9kZXNTaW1wbGUucmVzZXQoKTtcclxuICAgICAgICBSZW5kZXIubm9kZXNBbHBoYS5yZXNldCgpO1xyXG4gICAgICAgIFJlbmRlci5ub2Rlc1BoeXNpY3MucmVzZXQoKTtcclxuICAgICAgICBSZW5kZXIuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuUkVOREVSX1BSRVBBUkVfU1RBUlQpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFfYnJhbmNoLmlzQWN0aXZlKVxyXG4gICAgICAgIHJldHVybjsgLy8gZG9uJ3QgYWRkIGJyYW5jaCB0byByZW5kZXIgbGlzdCBpZiBub3QgYWN0aXZlXHJcblxyXG4gICAgICBfYnJhbmNoLm5Ob2Rlc0luQnJhbmNoID0gMTtcclxuICAgICAgX2JyYW5jaC5yYWRpdXMgPSAwO1xyXG5cclxuICAgICAgX2JyYW5jaC5kaXNwYXRjaEV2ZW50VG9UYXJnZXRPbmx5KG5ldyBFdmVudChFVkVOVC5SRU5ERVJfUFJFUEFSRSkpO1xyXG4gICAgICBfYnJhbmNoLnRpbWVzdGFtcFVwZGF0ZSA9IFJlbmRlci50aW1lc3RhbXBVcGRhdGU7XHJcblxyXG4gICAgICBpZiAoX2JyYW5jaC5jbXBUcmFuc2Zvcm0gJiYgX2JyYW5jaC5jbXBUcmFuc2Zvcm0uaXNBY3RpdmUpIHtcclxuICAgICAgICBsZXQgbXR4V29ybGRCcmFuY2g6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5NVUxUSVBMSUNBVElPTihfbXR4V29ybGQsIF9icmFuY2guY21wVHJhbnNmb3JtLm10eExvY2FsKTtcclxuICAgICAgICBfYnJhbmNoLm10eFdvcmxkLnNldChtdHhXb3JsZEJyYW5jaCk7XHJcbiAgICAgICAgUmVjeWNsZXIuc3RvcmUobXR4V29ybGRCcmFuY2gpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBfYnJhbmNoLm10eFdvcmxkLnNldChfbXR4V29ybGQpOyAvLyBvdmVyd3JpdGUgcmVhZG9ubHkgbXR4V29ybGQgb2YgdGhlIGN1cnJlbnQgbm9kZVxyXG5cclxuXHJcbiAgICAgIGxldCBjbXBSaWdpZGJvZHk6IENvbXBvbmVudFJpZ2lkYm9keSA9IF9icmFuY2guZ2V0Q29tcG9uZW50KENvbXBvbmVudFJpZ2lkYm9keSk7XHJcbiAgICAgIGlmIChjbXBSaWdpZGJvZHkgJiYgY21wUmlnaWRib2R5LmlzQWN0aXZlKSB7IC8vVE9ETzogc3VwcG9ydCBkZS0vYWN0aXZhdGlvbiB0aHJvdWdob3V0XHJcbiAgICAgICAgUmVuZGVyLm5vZGVzUGh5c2ljcy5wdXNoKF9icmFuY2gpOyAvLyBhZGQgdGhpcyBub2RlIHRvIHBoeXNpY3MgbGlzdFxyXG4gICAgICAgIGlmICghX29wdGlvbnM/Lmlnbm9yZVBoeXNpY3MpXHJcbiAgICAgICAgICB0aGlzLnRyYW5zZm9ybUJ5UGh5c2ljcyhfYnJhbmNoLCBjbXBSaWdpZGJvZHkpO1xyXG4gICAgICB9XHJcblxyXG5cclxuICAgICAgbGV0IGNtcExpZ2h0czogQ29tcG9uZW50TGlnaHRbXSA9IF9icmFuY2guZ2V0Q29tcG9uZW50cyhDb21wb25lbnRMaWdodCk7XHJcbiAgICAgIGZvciAobGV0IGNtcExpZ2h0IG9mIGNtcExpZ2h0cykge1xyXG4gICAgICAgIGlmICghY21wTGlnaHQuaXNBY3RpdmUpXHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICBsZXQgdHlwZTogVHlwZU9mTGlnaHQgPSBjbXBMaWdodC5saWdodC5nZXRUeXBlKCk7XHJcbiAgICAgICAgbGV0IGxpZ2h0c09mVHlwZTogQ29tcG9uZW50TGlnaHRbXSA9IF9saWdodHMuZ2V0KHR5cGUpO1xyXG4gICAgICAgIGlmICghbGlnaHRzT2ZUeXBlKSB7XHJcbiAgICAgICAgICBsaWdodHNPZlR5cGUgPSBbXTtcclxuICAgICAgICAgIF9saWdodHMuc2V0KHR5cGUsIGxpZ2h0c09mVHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxpZ2h0c09mVHlwZS5wdXNoKGNtcExpZ2h0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IGNtcE1lc2g6IENvbXBvbmVudE1lc2ggPSBfYnJhbmNoLmdldENvbXBvbmVudChDb21wb25lbnRNZXNoKTtcclxuICAgICAgbGV0IGNtcE1hdGVyaWFsOiBDb21wb25lbnRNYXRlcmlhbCA9IF9icmFuY2guZ2V0Q29tcG9uZW50KENvbXBvbmVudE1hdGVyaWFsKTtcclxuICAgICAgaWYgKGNtcE1lc2ggJiYgY21wTWVzaC5pc0FjdGl2ZSAmJiBjbXBNYXRlcmlhbCAmJiBjbXBNYXRlcmlhbC5pc0FjdGl2ZSkge1xyXG4gICAgICAgIC8vIFRPRE86IGNhcmVmdWwgd2hlbiB1c2luZyBwYXJ0aWNsZXN5c3RlbSwgcGl2b3QgbXVzdCBub3QgY2hhbmdlIG5vZGUgcG9zaXRpb25cclxuICAgICAgICBsZXQgbXR4V29ybGRNZXNoOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuTVVMVElQTElDQVRJT04oX2JyYW5jaC5tdHhXb3JsZCwgY21wTWVzaC5tdHhQaXZvdCk7XHJcbiAgICAgICAgY21wTWVzaC5tdHhXb3JsZC5zZXQobXR4V29ybGRNZXNoKTtcclxuICAgICAgICBSZWN5Y2xlci5zdG9yZShtdHhXb3JsZE1lc2gpOyAvLyBUT0RPOiBleGFtaW5lLCB3aHkgcmVjeWNsaW5nIHRoaXMgY2F1c2VzIG1lc2hlcyB0byBiZSBtaXNwbGFjZWQuLi5cclxuICAgICAgICBsZXQgc2hhZGVyOiB0eXBlb2YgU2hhZGVyID0gY21wTWF0ZXJpYWwubWF0ZXJpYWwuZ2V0U2hhZGVyKCk7XHJcbiAgICAgICAgaWYgKF9zaGFkZXJzVXNlZC5pbmRleE9mKHNoYWRlcikgPCAwKVxyXG4gICAgICAgICAgX3NoYWRlcnNVc2VkLnB1c2goc2hhZGVyKTtcclxuXHJcbiAgICAgICAgX2JyYW5jaC5yYWRpdXMgPSBjbXBNZXNoLnJhZGl1cztcclxuICAgICAgICBpZiAoY21wTWF0ZXJpYWwuc29ydEZvckFscGhhKVxyXG4gICAgICAgICAgUmVuZGVyLm5vZGVzQWxwaGEucHVzaChfYnJhbmNoKTsgLy8gYWRkIHRoaXMgbm9kZSB0byByZW5kZXIgbGlzdFxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIFJlbmRlci5ub2Rlc1NpbXBsZS5wdXNoKF9icmFuY2gpOyAvLyBhZGQgdGhpcyBub2RlIHRvIHJlbmRlciBsaXN0XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAobGV0IGNoaWxkIG9mIF9icmFuY2guZ2V0Q2hpbGRyZW4oKSkge1xyXG4gICAgICAgIFJlbmRlci5wcmVwYXJlKGNoaWxkLCBfb3B0aW9ucywgX2JyYW5jaC5tdHhXb3JsZCwgX2xpZ2h0cywgX3NoYWRlcnNVc2VkKTtcclxuXHJcbiAgICAgICAgX2JyYW5jaC5uTm9kZXNJbkJyYW5jaCArPSBjaGlsZC5uTm9kZXNJbkJyYW5jaDtcclxuICAgICAgICBsZXQgY21wTWVzaENoaWxkOiBDb21wb25lbnRNZXNoID0gY2hpbGQuZ2V0Q29tcG9uZW50KENvbXBvbmVudE1lc2gpO1xyXG4gICAgICAgIGxldCBwb3NpdGlvbjogVmVjdG9yMyA9IGNtcE1lc2hDaGlsZCA/IGNtcE1lc2hDaGlsZC5tdHhXb3JsZC50cmFuc2xhdGlvbiA6IGNoaWxkLm10eFdvcmxkLnRyYW5zbGF0aW9uO1xyXG4gICAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24uY2xvbmU7XHJcbiAgICAgICAgX2JyYW5jaC5yYWRpdXMgPSBNYXRoLm1heChfYnJhbmNoLnJhZGl1cywgcG9zaXRpb24uZ2V0RGlzdGFuY2UoX2JyYW5jaC5tdHhXb3JsZC50cmFuc2xhdGlvbikgKyBjaGlsZC5yYWRpdXMpO1xyXG4gICAgICAgIFJlY3ljbGVyLnN0b3JlKHBvc2l0aW9uKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGZpcnN0TGV2ZWwpIHtcclxuICAgICAgICBSZW5kZXIuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuUkVOREVSX1BSRVBBUkVfRU5EKSk7XHJcbiAgICAgICAgZm9yIChsZXQgc2hhZGVyIG9mIF9zaGFkZXJzVXNlZClcclxuICAgICAgICAgIFJlbmRlci5zZXRMaWdodHNJblNoYWRlcihzaGFkZXIsIF9saWdodHMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvL0NhbGN1bGF0ZSBQaHlzaWNzIGJhc2VkIG9uIGFsbCBwcmV2aW91cyBjYWxjdWxhdGlvbnMgICAgXHJcbiAgICAgIC8vIFJlbmRlci5zZXR1cFBoeXNpY2FsVHJhbnNmb3JtKF9icmFuY2gpO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIFBpY2tpbmdcclxuICAgIC8qKlxyXG4gICAgICogVXNlZCB3aXRoIGEge0BsaW5rIFBpY2tlcn0tY2FtZXJhLCB0aGlzIG1ldGhvZCByZW5kZXJzIG9uZSBwaXhlbCB3aXRoIHBpY2tpbmcgaW5mb3JtYXRpb24gXHJcbiAgICAgKiBmb3IgZWFjaCBub2RlIGluIHRoZSBsaW5lIG9mIHNpZ2h0IGFuZCByZXR1cm4gdGhhdCBhcyBhbiB1bnNvcnRlZCB7QGxpbmsgUGlja30tYXJyYXlcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBwaWNrQnJhbmNoKF9icmFuY2g6IE5vZGUsIF9jbXBDYW1lcmE6IENvbXBvbmVudENhbWVyYSk6IFBpY2tbXSB7IC8vIFRPRE86IHNlZSBpZiB0aGlyZCBwYXJhbWV0ZXIgX3dvcmxkPzogTWF0cml4NHg0IHdvdWxkIGJlIHVzZWZ1bGxcclxuICAgICAgUmVuZGVyLsaScGlja2VkID0gW107XHJcbiAgICAgIGxldCBzaXplOiBudW1iZXIgPSBNYXRoLmNlaWwoTWF0aC5zcXJ0KF9icmFuY2gubk5vZGVzSW5CcmFuY2gpKTtcclxuICAgICAgUmVuZGVyLmNyZWF0ZVBpY2tUZXh0dXJlKHNpemUpO1xyXG4gICAgICBSZW5kZXIuc2V0QmxlbmRNb2RlKEJMRU5ELk9QQVFVRSk7XHJcblxyXG4gICAgICBmb3IgKGxldCBub2RlIG9mIF9icmFuY2guZ2V0SXRlcmF0b3IodHJ1ZSkpIHtcclxuICAgICAgICBsZXQgY21wTWVzaDogQ29tcG9uZW50TWVzaCA9IG5vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudE1lc2gpO1xyXG4gICAgICAgIGxldCBjbXBNYXRlcmlhbDogQ29tcG9uZW50TWF0ZXJpYWwgPSBub2RlLmdldENvbXBvbmVudChDb21wb25lbnRNYXRlcmlhbCk7XHJcbiAgICAgICAgaWYgKGNtcE1lc2ggJiYgY21wTWVzaC5pc0FjdGl2ZSAmJiBjbXBNYXRlcmlhbCAmJiBjbXBNYXRlcmlhbC5pc0FjdGl2ZSkge1xyXG4gICAgICAgICAgbGV0IG10eE1lc2hUb1ZpZXc6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5NVUxUSVBMSUNBVElPTihfY21wQ2FtZXJhLm10eFdvcmxkVG9WaWV3LCBjbXBNZXNoLm10eFdvcmxkKTtcclxuICAgICAgICAgIFJlbmRlci5waWNrKG5vZGUsIG5vZGUubXR4V29ybGQsIG10eE1lc2hUb1ZpZXcpO1xyXG4gICAgICAgICAgLy8gUmVuZGVyUGFydGljbGVzLmRyYXdQYXJ0aWNsZXMoKTtcclxuICAgICAgICAgIFJlY3ljbGVyLnN0b3JlKG10eE1lc2hUb1ZpZXcpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgUmVuZGVyLnNldEJsZW5kTW9kZShCTEVORC5UUkFOU1BBUkVOVCk7XHJcblxyXG4gICAgICBsZXQgcGlja3M6IFBpY2tbXSA9IFJlbmRlci5nZXRQaWNrcyhzaXplLCBfY21wQ2FtZXJhKTtcclxuICAgICAgUmVuZGVyLnJlc2V0RnJhbWVCdWZmZXIoKTtcclxuICAgICAgcmV0dXJuIHBpY2tzO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIERyYXdpbmdcclxuICAgIHB1YmxpYyBzdGF0aWMgZHJhdyhfY21wQ2FtZXJhOiBDb21wb25lbnRDYW1lcmEpOiB2b2lkIHtcclxuICAgICAgX2NtcENhbWVyYS5yZXNldFdvcmxkVG9WaWV3KCk7XHJcbiAgICAgIFJlbmRlci5kcmF3TGlzdChfY21wQ2FtZXJhLCB0aGlzLm5vZGVzU2ltcGxlKTtcclxuICAgICAgUmVuZGVyLmRyYXdMaXN0QWxwaGEoX2NtcENhbWVyYSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZHJhd0xpc3RBbHBoYShfY21wQ2FtZXJhOiBDb21wb25lbnRDYW1lcmEpOiB2b2lkIHtcclxuICAgICAgZnVuY3Rpb24gc29ydChfYTogTm9kZSwgX2I6IE5vZGUpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiAoUmVmbGVjdC5nZXQoX2EsIFwiekNhbWVyYVwiKSA8IFJlZmxlY3QuZ2V0KF9iLCBcInpDYW1lcmFcIikpID8gMSA6IC0xO1xyXG4gICAgICB9XHJcbiAgICAgIGZvciAobGV0IG5vZGUgb2YgUmVuZGVyLm5vZGVzQWxwaGEpXHJcbiAgICAgICAgUmVmbGVjdC5zZXQobm9kZSwgXCJ6Q2FtZXJhXCIsIF9jbXBDYW1lcmEucG9pbnRXb3JsZFRvQ2xpcChub2RlLmdldENvbXBvbmVudChDb21wb25lbnRNZXNoKS5tdHhXb3JsZC50cmFuc2xhdGlvbikueik7XHJcblxyXG4gICAgICBsZXQgc29ydGVkOiBOb2RlW10gPSBSZW5kZXIubm9kZXNBbHBoYS5nZXRTb3J0ZWQoc29ydCk7XHJcbiAgICAgIFJlbmRlci5kcmF3TGlzdChfY21wQ2FtZXJhLCBzb3J0ZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGRyYXdMaXN0KF9jbXBDYW1lcmE6IENvbXBvbmVudENhbWVyYSwgX2xpc3Q6IFJlY3ljYWJsZUFycmF5PE5vZGU+IHwgQXJyYXk8Tm9kZT4pOiB2b2lkIHtcclxuICAgICAgZm9yIChsZXQgbm9kZSBvZiBfbGlzdCkge1xyXG4gICAgICAgIGxldCBjbXBNZXNoOiBDb21wb25lbnRNZXNoID0gbm9kZS5nZXRDb21wb25lbnQoQ29tcG9uZW50TWVzaCk7XHJcbiAgICAgICAgbGV0IGNtcE1hdGVyaWFsOiBDb21wb25lbnRNYXRlcmlhbCA9IG5vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudE1hdGVyaWFsKTtcclxuICAgICAgICBSZW5kZXIuZHJhd01lc2goY21wTWVzaCwgY21wTWF0ZXJpYWwsIF9jbXBDYW1lcmEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFBoeXNpY3NcclxuICAgIHByaXZhdGUgc3RhdGljIHRyYW5zZm9ybUJ5UGh5c2ljcyhfbm9kZTogTm9kZSwgX2NtcFJpZ2lkYm9keTogQ29tcG9uZW50UmlnaWRib2R5KTogdm9pZCB7XHJcbiAgICAgIGlmICghX2NtcFJpZ2lkYm9keS5pc0luaXRpYWxpemVkKSAvLyB8fCBQcm9qZWN0Lm1vZGUgPT0gTU9ERS5FRElUT1IpXHJcbiAgICAgICAgX2NtcFJpZ2lkYm9keS5pbml0aWFsaXplKCk7XHJcblxyXG4gICAgICBpZiAoIVBoeXNpY3MuZ2V0Qm9keUxpc3QoKS5sZW5ndGgpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgaWYgKCFfbm9kZS5tdHhMb2NhbCkge1xyXG4gICAgICAgIHRocm93IChuZXcgRXJyb3IoXCJDb21wb25lbnRSaWdpZGJvZHkgcmVxdWlyZXMgQ29tcG9uZW50VHJhbnNmb3JtIGF0IHRoZSBzYW1lIE5vZGVcIikpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBfY21wUmlnaWRib2R5LmNoZWNrQ29sbGlzaW9uRXZlbnRzKCk7XHJcblxyXG4gICAgICBpZiAoX2NtcFJpZ2lkYm9keS50eXBlQm9keSA9PSBCT0RZX1RZUEUuS0lORU1BVElDIHx8IFByb2plY3QubW9kZSA9PSBNT0RFLkVESVRPUikgeyAvL0Nhc2Ugb2YgS2luZW1hdGljIFJpZ2lkYm9keVxyXG4gICAgICAgIGxldCBtdHhQaXZvdFdvcmxkOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuTVVMVElQTElDQVRJT04oX25vZGUubXR4V29ybGQsIF9jbXBSaWdpZGJvZHkubXR4UGl2b3RVbnNjYWxlZCk7XHJcbiAgICAgICAgX2NtcFJpZ2lkYm9keS5zZXRQb3NpdGlvbihtdHhQaXZvdFdvcmxkLnRyYW5zbGF0aW9uKTtcclxuICAgICAgICBfY21wUmlnaWRib2R5LnNldFJvdGF0aW9uKG10eFBpdm90V29ybGQucm90YXRpb24pO1xyXG4gICAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFBpdm90V29ybGQpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IG10eFdvcmxkOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuQ09OU1RSVUNUSU9OKFxyXG4gICAgICAgIHsgdHJhbnNsYXRpb246IF9jbXBSaWdpZGJvZHkuZ2V0UG9zaXRpb24oKSwgcm90YXRpb246IF9jbXBSaWdpZGJvZHkuZ2V0Um90YXRpb24oKSwgc2NhbGluZzogbnVsbCB9XHJcbiAgICAgICk7XHJcbiAgICAgIG10eFdvcmxkLm11bHRpcGx5KF9jbXBSaWdpZGJvZHkubXR4UGl2b3RJbnZlcnNlKTtcclxuICAgICAgX25vZGUubXR4V29ybGQudHJhbnNsYXRpb24gPSBtdHhXb3JsZC50cmFuc2xhdGlvbjtcclxuICAgICAgX25vZGUubXR4V29ybGQucm90YXRpb24gPSBtdHhXb3JsZC5yb3RhdGlvbjtcclxuICAgICAgbGV0IG10eExvY2FsOiBNYXRyaXg0eDQgPSBfbm9kZS5nZXRQYXJlbnQoKSA/IE1hdHJpeDR4NC5SRUxBVElWRShfbm9kZS5tdHhXb3JsZCwgX25vZGUuZ2V0UGFyZW50KCkubXR4V29ybGQpIDogX25vZGUubXR4V29ybGQ7XHJcbiAgICAgIF9ub2RlLm10eExvY2FsLnNldChtdHhMb2NhbCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFdvcmxkKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUobXR4TG9jYWwpO1xyXG4gICAgfVxyXG4gIH1cclxuICAvLyNlbmRyZWdpb25cclxufVxyXG4iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgUmVuZGVyUGFydGljbGVzIGV4dGVuZHMgUmVuZGVyIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgZHJhd1BhcnRpY2xlcygpOiB2b2lkIHtcclxuICAgICAgLy8gY29uc29sZS5sb2coUmVuZGVyUGFydGljbGVzLmNyYzMpO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIENvbnRyb2xzIHRoZSByZW5kZXJpbmcgb2YgYSBicmFuY2gsIHVzaW5nIHRoZSBnaXZlbiB7QGxpbmsgQ29tcG9uZW50Q2FtZXJhfSxcclxuICAgKiBhbmQgdGhlIHByb3BhZ2F0aW9uIG9mIHRoZSByZW5kZXJlZCBpbWFnZSBmcm9tIHRoZSBvZmZzY3JlZW4gcmVuZGVyYnVmZmVyIHRvIHRoZSB0YXJnZXQgY2FudmFzXHJcbiAgICogdGhyb3VnaCBhIHNlcmllcyBvZiB7QGxpbmsgRnJhbWluZ30gb2JqZWN0cy4gVGhlIHN0YWdlcyBpbnZvbHZlZCBhcmUgaW4gb3JkZXIgb2YgcmVuZGVyaW5nXHJcbiAgICoge0BsaW5rIFJlbmRlcn0udmlld3BvcnQgLT4ge0BsaW5rIFZpZXdwb3J0fS5zb3VyY2UgLT4ge0BsaW5rIFZpZXdwb3J0fS5kZXN0aW5hdGlvbiAtPiBET00tQ2FudmFzIC0+IENsaWVudChDU1MpXHJcbiAgICogQGF1dGhvcnMgSmFzY2hhIEthcmFnw7ZsLCBIRlUsIDIwMTkgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBWaWV3cG9ydCBleHRlbmRzIEV2ZW50VGFyZ2V0xpIge1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZm9jdXM6IFZpZXdwb3J0O1xyXG5cclxuICAgIHB1YmxpYyBuYW1lOiBzdHJpbmcgPSBcIlZpZXdwb3J0XCI7IC8vIFRoZSBuYW1lIHRvIGNhbGwgdGhpcyB2aWV3cG9ydCBieS5cclxuICAgIHB1YmxpYyBjYW1lcmE6IENvbXBvbmVudENhbWVyYSA9IG51bGw7IC8vIFRoZSBjYW1lcmEgcmVwcmVzZW50aW5nIHRoZSB2aWV3IHBhcmFtZXRlcnMgdG8gcmVuZGVyIHRoZSBicmFuY2guXHJcblxyXG4gICAgcHVibGljIHJlY3RTb3VyY2U6IFJlY3RhbmdsZTtcclxuICAgIHB1YmxpYyByZWN0RGVzdGluYXRpb246IFJlY3RhbmdsZTtcclxuXHJcbiAgICAvLyBUT0RPOiB2ZXJpZnkgaWYgY2xpZW50IHRvIGNhbnZhcyBzaG91bGQgYmUgaW4gVmlld3BvcnQgb3Igc29tZXdoZXJlIGVsc2UgKFdpbmRvdywgQ29udGFpbmVyPylcclxuICAgIC8vIE11bHRpcGxlIHZpZXdwb3J0cyB1c2luZyB0aGUgc2FtZSBjYW52YXMgc2hvdWxkbid0IGRpZmZlciBoZXJlLi4uXHJcbiAgICAvLyBkaWZmZXJlbnQgZnJhbWluZyBtZXRob2RzIGNhbiBiZSB1c2VkLCB0aGlzIGlzIHRoZSBkZWZhdWx0XHJcbiAgICBwdWJsaWMgZnJhbWVDbGllbnRUb0NhbnZhczogRnJhbWluZ1NjYWxlZCA9IG5ldyBGcmFtaW5nU2NhbGVkKCk7XHJcbiAgICBwdWJsaWMgZnJhbWVDYW52YXNUb0Rlc3RpbmF0aW9uOiBGcmFtaW5nQ29tcGxleCA9IG5ldyBGcmFtaW5nQ29tcGxleCgpO1xyXG4gICAgcHVibGljIGZyYW1lRGVzdGluYXRpb25Ub1NvdXJjZTogRnJhbWluZ1NjYWxlZCA9IG5ldyBGcmFtaW5nU2NhbGVkKCk7XHJcbiAgICBwdWJsaWMgZnJhbWVTb3VyY2VUb1JlbmRlcjogRnJhbWluZ1NjYWxlZCA9IG5ldyBGcmFtaW5nU2NhbGVkKCk7XHJcblxyXG4gICAgcHVibGljIGFkanVzdGluZ0ZyYW1lczogYm9vbGVhbiA9IHRydWU7XHJcbiAgICBwdWJsaWMgYWRqdXN0aW5nQ2FtZXJhOiBib29sZWFuID0gdHJ1ZTtcclxuICAgIHB1YmxpYyBwaHlzaWNzRGVidWdNb2RlOiBQSFlTSUNTX0RFQlVHTU9ERSA9IFBIWVNJQ1NfREVCVUdNT0RFLk5PTkU7XHJcblxyXG5cclxuICAgICNicmFuY2g6IE5vZGUgPSBudWxsOyAvLyBUaGUgdG8gcmVuZGVyIHdpdGggYWxsIGl0cyBkZXNjZW5kYW50cy5cclxuICAgICNjcmMyOiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgPSBudWxsO1xyXG4gICAgI2NhbnZhczogSFRNTENhbnZhc0VsZW1lbnQgPSBudWxsO1xyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8gI3JlZ2lvbiBFdmVudHMgKHBhc3NpbmcgZnJvbSBjYW52YXMgdG8gdmlld3BvcnQgYW5kIGZyb20gdGhlcmUgaW50byBicmFuY2gpXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHZpZXdwb3J0IGN1cnJlbnRseSBoYXMgZm9jdXMgYW5kIHRodXMgcmVjZWl2ZXMga2V5Ym9hcmQgZXZlbnRzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgaGFzRm9jdXMoKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiAoVmlld3BvcnQuZm9jdXMgPT0gdGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25uZWN0cyB0aGUgdmlld3BvcnQgdG8gdGhlIGdpdmVuIGNhbnZhcyB0byByZW5kZXIgdGhlIGdpdmVuIGJyYW5jaCB0byB1c2luZyB0aGUgZ2l2ZW4gY2FtZXJhLWNvbXBvbmVudCwgYW5kIG5hbWVzIHRoZSB2aWV3cG9ydCBhcyBnaXZlbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGluaXRpYWxpemUoX25hbWU6IHN0cmluZywgX2JyYW5jaDogTm9kZSwgX2NhbWVyYTogQ29tcG9uZW50Q2FtZXJhLCBfY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCk6IHZvaWQge1xyXG4gICAgICB0aGlzLm5hbWUgPSBfbmFtZTtcclxuICAgICAgdGhpcy5jYW1lcmEgPSBfY2FtZXJhO1xyXG4gICAgICB0aGlzLiNjYW52YXMgPSBfY2FudmFzO1xyXG4gICAgICB0aGlzLiNjcmMyID0gX2NhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcblxyXG4gICAgICB0aGlzLnJlY3RTb3VyY2UgPSBSZW5kZXIuZ2V0Q2FudmFzUmVjdCgpO1xyXG4gICAgICB0aGlzLnJlY3REZXN0aW5hdGlvbiA9IHRoaXMuZ2V0Q2xpZW50UmVjdGFuZ2xlKCk7XHJcblxyXG4gICAgICB0aGlzLnNldEJyYW5jaChfYnJhbmNoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmUgdGhlIGRlc3RpbmF0aW9uIGNhbnZhc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Q2FudmFzKCk6IEhUTUxDYW52YXNFbGVtZW50IHtcclxuICAgICAgcmV0dXJuIHRoaXMuI2NhbnZhcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmUgdGhlIDJELWNvbnRleHQgYXR0YWNoZWQgdG8gdGhlIGRlc3RpbmF0aW9uIGNhbnZhc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Q29udGV4dCgpOiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQge1xyXG4gICAgICByZXR1cm4gdGhpcy4jY3JjMjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmUgdGhlIHNpemUgb2YgdGhlIGRlc3RpbmF0aW9uIGNhbnZhcyBhcyBhIHJlY3RhbmdsZSwgeCBhbmQgeSBhcmUgYWx3YXlzIDAgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRDYW52YXNSZWN0YW5nbGUoKTogUmVjdGFuZ2xlIHtcclxuICAgICAgcmV0dXJuIFJlY3RhbmdsZS5HRVQoMCwgMCwgdGhpcy4jY2FudmFzLndpZHRoLCB0aGlzLiNjYW52YXMuaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmUgdGhlIGNsaWVudCByZWN0YW5nbGUgdGhlIGNhbnZhcyBpcyBkaXNwbGF5ZWQgYW5kIGZpdCBpbiwgeCBhbmQgeSBhcmUgYWx3YXlzIDAgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRDbGllbnRSZWN0YW5nbGUoKTogUmVjdGFuZ2xlIHtcclxuICAgICAgLy8gRlVER0UgZG9lc24ndCBjYXJlIGFib3V0IHdoZXJlIHRoZSBjbGllbnQgcmVjdCBpcywgb25seSBhYm91dCB0aGUgc2l6ZSBtYXR0ZXJzLlxyXG4gICAgICAvLyByZXR1cm4gUmVjdGFuZ2xlLkdFVCh0aGlzLmNhbnZhcy5vZmZzZXRMZWZ0LCB0aGlzLmNhbnZhcy5vZmZzZXRUb3AsIHRoaXMuY2FudmFzLmNsaWVudFdpZHRoLCB0aGlzLmNhbnZhcy5jbGllbnRIZWlnaHQpO1xyXG4gICAgICByZXR1cm4gUmVjdGFuZ2xlLkdFVCgwLCAwLCB0aGlzLiNjYW52YXMuY2xpZW50V2lkdGgsIHRoaXMuI2NhbnZhcy5jbGllbnRIZWlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBicmFuY2ggdG8gYmUgZHJhd24gaW4gdGhlIHZpZXdwb3J0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0QnJhbmNoKF9icmFuY2g6IE5vZGUpOiB2b2lkIHtcclxuICAgICAgLy8gVE9ETzogZmlndXJlIG91dCB3aGF0IHRoZSBldmVudCBoYW5kbGluZyB3YXMgY3JlYXRlZCBmb3IuIERvZXNuJ3QgaGF2ZSBhbm90aGVyIGVmZmVjdCB0aGFuIGluZm9ybWF0aW9uIG9uIHRoZSBjb25zb2xlIChkZWFjdGl2YXRlZClcclxuICAgICAgaWYgKHRoaXMuI2JyYW5jaCkge1xyXG4gICAgICAgIHRoaXMuI2JyYW5jaC5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5ULkNPTVBPTkVOVF9BREQsIHRoaXMuaG5kQ29tcG9uZW50RXZlbnQpO1xyXG4gICAgICAgIHRoaXMuI2JyYW5jaC5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5ULkNPTVBPTkVOVF9SRU1PVkUsIHRoaXMuaG5kQ29tcG9uZW50RXZlbnQpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuI2JyYW5jaCA9IF9icmFuY2g7XHJcbiAgICAgIGlmICh0aGlzLiNicmFuY2gpIHtcclxuICAgICAgICB0aGlzLiNicmFuY2guYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5DT01QT05FTlRfQURELCB0aGlzLmhuZENvbXBvbmVudEV2ZW50KTtcclxuICAgICAgICB0aGlzLiNicmFuY2guYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5DT01QT05FTlRfUkVNT1ZFLCB0aGlzLmhuZENvbXBvbmVudEV2ZW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmUgdGhlIGJyYW5jaCB0aGlzIHZpZXdwb3J0IHJlbmRlcnNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEJyYW5jaCgpOiBOb2RlIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI2JyYW5jaDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvZ3MgdGhpcyB2aWV3cG9ydHMgc2NlbmVncmFwaCB0byB0aGUgY29uc29sZS5cclxuICAgICAqIFRPRE86IHJlbW92ZSB0aGlzIG1ldGhvZCwgc2luY2UgaXQncyBpbXBsZW1lbnRlZCBpbiBEZWJ1Z1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2hvd1NjZW5lR3JhcGgoKTogdm9pZCB7XHJcbiAgICAgIERlYnVnLmJyYW5jaCh0aGlzLiNicmFuY2gpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICNyZWdpb24gRHJhd2luZ1xyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IHRoaXMgdmlld3BvcnQgZGlzcGxheWluZyBpdHMgYnJhbmNoLiBCeSBkZWZhdWx0LCB0aGUgdHJhbnNmb3JtcyBpbiB0aGUgYnJhbmNoIGFyZSByZWNhbGN1bGF0ZWQgZmlyc3QuXHJcbiAgICAgKiBQYXNzIGBmYWxzZWAgaWYgY2FsY3VsYXRpb24gd2FzIGFscmVhZHkgZG9uZSBmb3IgdGhpcyBmcmFtZSBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGRyYXcoX2NhbGN1bGF0ZVRyYW5zZm9ybXM6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XHJcbiAgICAgIGlmICghdGhpcy4jYnJhbmNoKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgUmVuZGVyLnJlc2V0RnJhbWVCdWZmZXIoKTtcclxuICAgICAgaWYgKCF0aGlzLmNhbWVyYS5pc0FjdGl2ZSlcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIGlmICh0aGlzLmFkanVzdGluZ0ZyYW1lcylcclxuICAgICAgICB0aGlzLmFkanVzdEZyYW1lcygpO1xyXG4gICAgICBpZiAodGhpcy5hZGp1c3RpbmdDYW1lcmEpXHJcbiAgICAgICAgdGhpcy5hZGp1c3RDYW1lcmEoKTtcclxuXHJcbiAgICAgIGlmIChfY2FsY3VsYXRlVHJhbnNmb3JtcylcclxuICAgICAgICB0aGlzLmNhbGN1bGF0ZVRyYW5zZm9ybXMoKTtcclxuXHJcbiAgICAgIFJlbmRlci5jbGVhcih0aGlzLmNhbWVyYS5jbHJCYWNrZ3JvdW5kKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLnBoeXNpY3NEZWJ1Z01vZGUgIT0gUEhZU0lDU19ERUJVR01PREUuUEhZU0lDX09CSkVDVFNfT05MWSlcclxuICAgICAgICBSZW5kZXIuZHJhdyh0aGlzLmNhbWVyYSk7XHJcbiAgICAgIGlmICh0aGlzLnBoeXNpY3NEZWJ1Z01vZGUgIT0gUEhZU0lDU19ERUJVR01PREUuTk9ORSkge1xyXG4gICAgICAgIFBoeXNpY3MuZHJhdyh0aGlzLmNhbWVyYSwgdGhpcy5waHlzaWNzRGVidWdNb2RlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy4jY3JjMi5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgdGhpcy4jY3JjMi5kcmF3SW1hZ2UoXHJcbiAgICAgICAgUmVuZGVyLmdldENhbnZhcygpLFxyXG4gICAgICAgIHRoaXMucmVjdFNvdXJjZS54LCB0aGlzLnJlY3RTb3VyY2UueSwgdGhpcy5yZWN0U291cmNlLndpZHRoLCB0aGlzLnJlY3RTb3VyY2UuaGVpZ2h0LFxyXG4gICAgICAgIHRoaXMucmVjdERlc3RpbmF0aW9uLngsIHRoaXMucmVjdERlc3RpbmF0aW9uLnksIHRoaXMucmVjdERlc3RpbmF0aW9uLndpZHRoLCB0aGlzLnJlY3REZXN0aW5hdGlvbi5oZWlnaHRcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZSB0aGUgY2FzY2FkZSBvZiB0cmFuc2Zvcm1zIGluIHRoaXMgYnJhbmNoIGFuZCBzdG9yZSB0aGUgcmVzdWx0cyBhcyBtdHhXb3JsZCBpbiB0aGUge0BsaW5rIE5vZGV9cyBhbmQge0BsaW5rIENvbXBvbmVudE1lc2h9ZXMgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjYWxjdWxhdGVUcmFuc2Zvcm1zKCk6IHZvaWQge1xyXG4gICAgICBsZXQgbXR4Um9vdDogTWF0cml4NHg0ID0gTWF0cml4NHg0LklERU5USVRZKCk7XHJcbiAgICAgIGlmICh0aGlzLiNicmFuY2guZ2V0UGFyZW50KCkpXHJcbiAgICAgICAgbXR4Um9vdCA9IHRoaXMuI2JyYW5jaC5nZXRQYXJlbnQoKS5tdHhXb3JsZDtcclxuICAgICAgUmVuZGVyLnByZXBhcmUodGhpcy4jYnJhbmNoLCBudWxsLCBtdHhSb290KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGp1c3QgYWxsIGZyYW1lcyBpbnZvbHZlZCBpbiB0aGUgcmVuZGVyaW5nIHByb2Nlc3MgZnJvbSB0aGUgZGlzcGxheSBhcmVhIGluIHRoZSBjbGllbnQgdXAgdG8gdGhlIHJlbmRlcmVyIGNhbnZhc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWRqdXN0RnJhbWVzKCk6IHZvaWQge1xyXG4gICAgICAvLyBnZXQgdGhlIHJlY3RhbmdsZSBvZiB0aGUgY2FudmFzIGFyZWEgYXMgZGlzcGxheWVkIChjb25zaWRlciBjc3MpXHJcbiAgICAgIGxldCByZWN0Q2xpZW50OiBSZWN0YW5nbGUgPSB0aGlzLmdldENsaWVudFJlY3RhbmdsZSgpO1xyXG4gICAgICAvLyBhZGp1c3QgdGhlIGNhbnZhcyBzaXplIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gZnJhbWluZyBhcHBsaWVkIHRvIGNsaWVudFxyXG4gICAgICBsZXQgcmVjdENhbnZhczogUmVjdGFuZ2xlID0gdGhpcy5mcmFtZUNsaWVudFRvQ2FudmFzLmdldFJlY3QocmVjdENsaWVudCk7XHJcbiAgICAgIHRoaXMuI2NhbnZhcy53aWR0aCA9IHJlY3RDYW52YXMud2lkdGg7XHJcbiAgICAgIHRoaXMuI2NhbnZhcy5oZWlnaHQgPSByZWN0Q2FudmFzLmhlaWdodDtcclxuXHJcbiAgICAgIGxldCByZWN0VGVtcDogUmVjdGFuZ2xlO1xyXG4gICAgICAvLyBhZGp1c3QgdGhlIGRlc3RpbmF0aW9uIGFyZWEgb24gdGhlIHRhcmdldC1jYW52YXMgdG8gcmVuZGVyIHRvIGJ5IGFwcGx5aW5nIHRoZSBmcmFtaW5nIHRvIGNhbnZhc1xyXG4gICAgICByZWN0VGVtcCA9IHRoaXMuZnJhbWVDYW52YXNUb0Rlc3RpbmF0aW9uLmdldFJlY3QocmVjdENhbnZhcyk7XHJcbiAgICAgIHRoaXMucmVjdERlc3RpbmF0aW9uLmNvcHkocmVjdFRlbXApO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShyZWN0VGVtcCk7XHJcbiAgICAgIC8vIGFkanVzdCB0aGUgYXJlYSBvbiB0aGUgc291cmNlLWNhbnZhcyB0byByZW5kZXIgZnJvbSBieSBhcHBseWluZyB0aGUgZnJhbWluZyB0byBkZXN0aW5hdGlvbiBhcmVhXHJcbiAgICAgIHJlY3RUZW1wID0gdGhpcy5mcmFtZURlc3RpbmF0aW9uVG9Tb3VyY2UuZ2V0UmVjdCh0aGlzLnJlY3REZXN0aW5hdGlvbik7XHJcbiAgICAgIHRoaXMucmVjdFNvdXJjZS5jb3B5KHJlY3RUZW1wKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUocmVjdFRlbXApO1xyXG5cclxuICAgICAgLy8gaGF2aW5nIGFuIG9mZnNldCBzb3VyY2UgZG9lcyBtYWtlIHNlbnNlIG9ubHkgd2hlbiBtdWx0aXBsZSB2aWV3cG9ydHMgZGlzcGxheSBwYXJ0cyBvZiB0aGUgc2FtZSByZW5kZXJpbmcuIEZvciBub3c6IHNoaWZ0IGl0IHRvIDAsMFxyXG4gICAgICB0aGlzLnJlY3RTb3VyY2UueCA9IHRoaXMucmVjdFNvdXJjZS55ID0gMDtcclxuICAgICAgLy8gc3RpbGwsIGEgcGFydGlhbCBpbWFnZSBvZiB0aGUgcmVuZGVyaW5nIG1heSBiZSByZXRyaWV2ZWQgYnkgbW92aW5nIGFuZCByZXNpemluZyB0aGUgcmVuZGVyIHZpZXdwb3J0LiBGb3Igbm93LCBpdCdzIGFsd2F5cyBhZGp1c3RlZCB0byB0aGUgY3VycmVudCB2aWV3cG9ydFxyXG4gICAgICBsZXQgcmVjdFJlbmRlcjogUmVjdGFuZ2xlID0gdGhpcy5mcmFtZVNvdXJjZVRvUmVuZGVyLmdldFJlY3QodGhpcy5yZWN0U291cmNlKTtcclxuICAgICAgUmVuZGVyLnNldFJlbmRlclJlY3RhbmdsZShyZWN0UmVuZGVyKTtcclxuICAgICAgLy8gbm8gbW9yZSB0cmFuc2Zvcm1hdGlvbiBhZnRlciB0aGlzIGZvciBub3csIG9mZnNjcmVlbiBjYW52YXMgYW5kIHJlbmRlci12aWV3cG9ydCBoYXZlIHRoZSBzYW1lIHNpemVcclxuICAgICAgUmVuZGVyLnNldENhbnZhc1NpemUocmVjdFJlbmRlci53aWR0aCwgcmVjdFJlbmRlci5oZWlnaHQpO1xyXG5cclxuICAgICAgUmVjeWNsZXIuc3RvcmUocmVjdENsaWVudCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKHJlY3RDYW52YXMpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShyZWN0UmVuZGVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRqdXN0IHRoZSBjYW1lcmEgcGFyYW1ldGVycyB0byBmaXQgdGhlIHJlbmRlcmluZyBpbnRvIHRoZSByZW5kZXIgdmllcG9ydFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWRqdXN0Q2FtZXJhKCk6IHZvaWQge1xyXG4gICAgICBsZXQgcmVjdDogUmVjdGFuZ2xlID0gUmVuZGVyLmdldFJlbmRlclJlY3RhbmdsZSgpO1xyXG4gICAgICB0aGlzLmNhbWVyYS5wcm9qZWN0Q2VudHJhbChcclxuICAgICAgICByZWN0LndpZHRoIC8gcmVjdC5oZWlnaHQsIHRoaXMuY2FtZXJhLmdldEZpZWxkT2ZWaWV3KCksIHRoaXMuY2FtZXJhLmdldERpcmVjdGlvbigpLCB0aGlzLmNhbWVyYS5nZXROZWFyKCksIHRoaXMuY2FtZXJhLmdldEZhcigpKTtcclxuICAgIH1cclxuICAgIC8vICNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gUG9pbnRzXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgUmF5fSBpbiB3b3JsZCBjb29yZGluYXRlcyBmcm9tIHRoaXMgY2FtZXJhIHRocm91Z2ggdGhlIHBvaW50IGdpdmVuIGluIGNsaWVudCBzcGFjZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0UmF5RnJvbUNsaWVudChfcG9pbnQ6IFZlY3RvcjIpOiBSYXkge1xyXG4gICAgICBsZXQgcG9zUHJvamVjdGlvbjogVmVjdG9yMiA9IHRoaXMucG9pbnRDbGllbnRUb1Byb2plY3Rpb24oX3BvaW50KTtcclxuICAgICAgbGV0IHJheTogUmF5ID0gbmV3IFJheShuZXcgVmVjdG9yMygtcG9zUHJvamVjdGlvbi54LCBwb3NQcm9qZWN0aW9uLnksIDEpKTtcclxuXHJcbiAgICAgIC8vIHJheS5kaXJlY3Rpb24uc2NhbGUoY2FtZXJhLmRpc3RhbmNlKTtcclxuICAgICAgcmF5Lm9yaWdpbi50cmFuc2Zvcm0odGhpcy5jYW1lcmEubXR4UGl2b3QpO1xyXG4gICAgICByYXkuZGlyZWN0aW9uLnRyYW5zZm9ybSh0aGlzLmNhbWVyYS5tdHhQaXZvdCwgZmFsc2UpO1xyXG4gICAgICBsZXQgY2FtZXJhTm9kZTogTm9kZSA9IHRoaXMuY2FtZXJhLm5vZGU7XHJcbiAgICAgIGlmIChjYW1lcmFOb2RlKSB7XHJcbiAgICAgICAgcmF5Lm9yaWdpbi50cmFuc2Zvcm0oY2FtZXJhTm9kZS5tdHhXb3JsZCk7XHJcbiAgICAgICAgcmF5LmRpcmVjdGlvbi50cmFuc2Zvcm0oY2FtZXJhTm9kZS5tdHhXb3JsZCwgZmFsc2UpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByYXk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcG9pbnQgb24gdGhlIGNsaWVudCByZWN0YW5nbGUgbWF0Y2hpbmcgdGhlIHByb2plY3Rpb24gb2YgdGhlIGdpdmVuIHBvaW50IGluIHdvcmxkIHNwYWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwb2ludFdvcmxkVG9DbGllbnQoX3Bvc2l0aW9uOiBWZWN0b3IzKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCBwcm9qZWN0aW9uOiBWZWN0b3IzID0gdGhpcy5jYW1lcmEucG9pbnRXb3JsZFRvQ2xpcChfcG9zaXRpb24pO1xyXG4gICAgICBsZXQgcG9zQ2xpZW50OiBWZWN0b3IyID0gdGhpcy5wb2ludENsaXBUb0NsaWVudChwcm9qZWN0aW9uLnRvVmVjdG9yMigpKTtcclxuICAgICAgcmV0dXJuIHBvc0NsaWVudDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBwb2ludCBvbiB0aGUgc291cmNlLXJlY3RhbmdsZSBtYXRjaGluZyB0aGUgZ2l2ZW4gcG9pbnQgb24gdGhlIGNsaWVudCByZWN0YW5nbGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHBvaW50Q2xpZW50VG9Tb3VyY2UoX2NsaWVudDogVmVjdG9yMik6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IyID0gdGhpcy5mcmFtZUNsaWVudFRvQ2FudmFzLmdldFBvaW50KF9jbGllbnQsIHRoaXMuZ2V0Q2xpZW50UmVjdGFuZ2xlKCkpO1xyXG4gICAgICByZXN1bHQgPSB0aGlzLmZyYW1lQ2FudmFzVG9EZXN0aW5hdGlvbi5nZXRQb2ludChyZXN1bHQsIHRoaXMuZ2V0Q2FudmFzUmVjdGFuZ2xlKCkpO1xyXG4gICAgICByZXN1bHQgPSB0aGlzLmZyYW1lRGVzdGluYXRpb25Ub1NvdXJjZS5nZXRQb2ludChyZXN1bHQsIHRoaXMucmVjdFNvdXJjZSk7XHJcbiAgICAgIC8vVE9ETzogd2hlbiBTb3VyY2UsIFJlbmRlciBhbmQgUmVuZGVyVmlld3BvcnQgZGV2aWF0ZSwgY29udGludWUgdHJhbnNmb3JtYXRpb24gXHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcG9pbnQgb24gdGhlIHJlbmRlci1yZWN0YW5nbGUgbWF0Y2hpbmcgdGhlIGdpdmVuIHBvaW50IG9uIHRoZSBzb3VyY2UgcmVjdGFuZ2xlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwb2ludFNvdXJjZVRvUmVuZGVyKF9zb3VyY2U6IFZlY3RvcjIpOiBWZWN0b3IyIHtcclxuICAgICAgbGV0IHByb2plY3Rpb25SZWN0YW5nbGU6IFJlY3RhbmdsZSA9IHRoaXMuY2FtZXJhLmdldFByb2plY3Rpb25SZWN0YW5nbGUoKTtcclxuICAgICAgbGV0IHBvaW50OiBWZWN0b3IyID0gdGhpcy5mcmFtZVNvdXJjZVRvUmVuZGVyLmdldFBvaW50KF9zb3VyY2UsIHByb2plY3Rpb25SZWN0YW5nbGUpO1xyXG4gICAgICAvLyBjb25zb2xlLmxvZyhwcm9qZWN0aW9uUmVjdGFuZ2xlLnRvU3RyaW5nKCkpO1xyXG4gICAgICByZXR1cm4gcG9pbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcG9pbnQgb24gdGhlIHJlbmRlci1yZWN0YW5nbGUgbWF0Y2hpbmcgdGhlIGdpdmVuIHBvaW50IG9uIHRoZSBjbGllbnQgcmVjdGFuZ2xlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwb2ludENsaWVudFRvUmVuZGVyKF9jbGllbnQ6IFZlY3RvcjIpOiBWZWN0b3IyIHtcclxuICAgICAgbGV0IHBvaW50OiBWZWN0b3IyID0gdGhpcy5wb2ludENsaWVudFRvU291cmNlKF9jbGllbnQpO1xyXG4gICAgICBwb2ludCA9IHRoaXMucG9pbnRTb3VyY2VUb1JlbmRlcihwb2ludCk7XHJcbiAgICAgIC8vVE9ETzogd2hlbiBSZW5kZXIgYW5kIFJlbmRlclZpZXdwb3J0IGRldmlhdGUsIGNvbnRpbnVlIHRyYW5zZm9ybWF0aW9uIFxyXG4gICAgICByZXR1cm4gcG9pbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcG9pbnQgb24gYSBwcm9qZWN0aW9uIHN1cmZhY2UgaW4gdGhlIGh5cG90aGV0aWNhbCBkaXN0YW5jZSBvZiAxIHRvIHRoZSBjYW1lcmEgIFxyXG4gICAgICogbWF0Y2hpbmcgdGhlIGdpdmVuIHBvaW50IG9uIHRoZSBjbGllbnQgcmVjdGFuZ2xlXHJcbiAgICAgKiBUT0RPOiBleGFtaW5lLCBpZiB0aGlzIHNob3VsZCBiZSBhIGNhbWVyYS1tZXRob2QuIEN1cnJlbnQgaW1wbGVtZW50YXRpb24gaXMgZm9yIGNlbnRyYWwtcHJvamVjdGlvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcG9pbnRDbGllbnRUb1Byb2plY3Rpb24oX2NsaWVudDogVmVjdG9yMik6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcG9zUmVuZGVyOiBWZWN0b3IyID0gdGhpcy5wb2ludENsaWVudFRvUmVuZGVyKF9jbGllbnQpO1xyXG4gICAgICBsZXQgcmVjdFJlbmRlcjogUmVjdGFuZ2xlID0gdGhpcy5mcmFtZVNvdXJjZVRvUmVuZGVyLmdldFJlY3QodGhpcy5yZWN0U291cmNlKTtcclxuICAgICAgbGV0IHJlY3RQcm9qZWN0aW9uOiBSZWN0YW5nbGUgPSB0aGlzLmNhbWVyYS5nZXRQcm9qZWN0aW9uUmVjdGFuZ2xlKCk7XHJcblxyXG4gICAgICBsZXQgcG9zUHJvamVjdGlvbjogVmVjdG9yMiA9IG5ldyBWZWN0b3IyKFxyXG4gICAgICAgIHJlY3RQcm9qZWN0aW9uLndpZHRoICogcG9zUmVuZGVyLnggLyByZWN0UmVuZGVyLndpZHRoLFxyXG4gICAgICAgIHJlY3RQcm9qZWN0aW9uLmhlaWdodCAqIHBvc1JlbmRlci55IC8gcmVjdFJlbmRlci5oZWlnaHRcclxuICAgICAgKTtcclxuXHJcbiAgICAgIHBvc1Byb2plY3Rpb24uc3VidHJhY3QobmV3IFZlY3RvcjIocmVjdFByb2plY3Rpb24ud2lkdGggLyAyLCByZWN0UHJvamVjdGlvbi5oZWlnaHQgLyAyKSk7XHJcbiAgICAgIHBvc1Byb2plY3Rpb24ueSAqPSAtMTtcclxuXHJcbiAgICAgIHJldHVybiBwb3NQcm9qZWN0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHBvaW50IGluIHRoZSBjbGllbnQgcmVjdGFuZ2xlIG1hdGNoaW5nIHRoZSBnaXZlbiBwb2ludCBpbiBub3JtZWQgY2xpcHNwYWNlIHJlY3RhbmdsZSwgXHJcbiAgICAgKiB3aGljaCBzdHJldGNoZXMgZnJvbSAtMSB0byAxIGluIGJvdGggZGltZW5zaW9ucywgeSBwb2ludGluZyB1cFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcG9pbnRDbGlwVG9DbGllbnQoX25vcm1lZDogVmVjdG9yMik6IFZlY3RvcjIge1xyXG4gICAgICAvLyBsZXQgcmVjdENsaWVudDogUmVjdGFuZ2xlID0gdGhpcy5nZXRDbGllbnRSZWN0YW5nbGUoKTtcclxuICAgICAgLy8gbGV0IHJlc3VsdDogVmVjdG9yMiA9IFZlY3RvcjIuT05FKDAuNSk7XHJcbiAgICAgIC8vIHJlc3VsdC54ICo9IChfbm9ybWVkLnggKyAxKSAqIHJlY3RDbGllbnQud2lkdGg7XHJcbiAgICAgIC8vIHJlc3VsdC55ICo9ICgxIC0gX25vcm1lZC55KSAqIHJlY3RDbGllbnQuaGVpZ2h0O1xyXG4gICAgICAvLyByZXN1bHQuYWRkKHJlY3RDbGllbnQucG9zaXRpb24pO1xyXG4gICAgICAvL1RPRE86IGNoZWNrIGlmIHJlY3REZXN0aW5hdGlvbiBjYW4gc2FmZWx5IChhbmQgbW9yZSBwZXJmb21hbnQpIGJlIHVzZWQgaW5zdGVhZCBnZXRDbGllbnRSZWN0YW5nbGVcclxuICAgICAgbGV0IHBvaW50Q2xpZW50OiBWZWN0b3IyID0gUmVuZGVyLnJlY3RDbGlwLnBvaW50VG9SZWN0KF9ub3JtZWQsIHRoaXMucmVjdERlc3RpbmF0aW9uKTtcclxuICAgICAgcmV0dXJuIHBvaW50Q2xpZW50O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHBvaW50IGluIHRoZSBjbGllbnQgcmVjdGFuZ2xlIG1hdGNoaW5nIHRoZSBnaXZlbiBwb2ludCBpbiBub3JtZWQgY2xpcHNwYWNlIHJlY3RhbmdsZSwgXHJcbiAgICAgKiB3aGljaCBzdHJldGNoZXMgZnJvbSAtMSB0byAxIGluIGJvdGggZGltZW5zaW9ucywgeSBwb2ludGluZyB1cFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcG9pbnRDbGlwVG9DYW52YXMoX25vcm1lZDogVmVjdG9yMik6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcG9pbnRDYW52YXM6IFZlY3RvcjIgPSBSZW5kZXIucmVjdENsaXAucG9pbnRUb1JlY3QoX25vcm1lZCwgdGhpcy5nZXRDYW52YXNSZWN0YW5nbGUoKSk7XHJcbiAgICAgIHJldHVybiBwb2ludENhbnZhcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBwb2ludCBpbiB0aGUgYnJvd3NlciBwYWdlIG1hdGNoaW5nIHRoZSBnaXZlbiBwb2ludCBvZiB0aGUgdmlld3BvcnRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHBvaW50Q2xpZW50VG9TY3JlZW4oX2NsaWVudDogVmVjdG9yMik6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgc2NyZWVuOiBWZWN0b3IyID0gbmV3IFZlY3RvcjIodGhpcy4jY2FudmFzLm9mZnNldExlZnQgKyBfY2xpZW50LngsIHRoaXMuI2NhbnZhcy5vZmZzZXRUb3AgKyBfY2xpZW50LnkpO1xyXG4gICAgICByZXR1cm4gc2NyZWVuO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3dpdGNoIHRoZSB2aWV3cG9ydHMgZm9jdXMgb24gb3Igb2ZmLiBPbmx5IG9uZSB2aWV3cG9ydCBpbiBvbmUgRlVER0UgaW5zdGFuY2UgY2FuIGhhdmUgdGhlIGZvY3VzLCB0aHVzIHJlY2VpdmluZyBrZXlib2FyZCBldmVudHMuIFxyXG4gICAgICogU28gYSB2aWV3cG9ydCBjdXJyZW50bHkgaGF2aW5nIHRoZSBmb2N1cyB3aWxsIGxvc2UgaXQsIHdoZW4gYW5vdGhlciBvbmUgcmVjZWl2ZXMgaXQuIFRoZSB2aWV3cG9ydHMgZmlyZSB7QGxpbmsgRXZlbnTGkn1zIGFjY29yZGluZ2x5LlxyXG4gICAgICogLy8gVE9ETzogZXhhbWluZSwgaWYgdGhpcyBjYW4gYmUgYWNoaWV2ZWQgYnkgcmVndWxhciBET00tRm9jdXMgYW5kIHRhYmluZGV4PTBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldEZvY3VzKF9vbjogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICBpZiAoX29uKSB7XHJcbiAgICAgICAgaWYgKFZpZXdwb3J0LmZvY3VzID09IHRoaXMpXHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgaWYgKFZpZXdwb3J0LmZvY3VzKVxyXG4gICAgICAgICAgVmlld3BvcnQuZm9jdXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuRk9DVVNfT1VUKSk7XHJcbiAgICAgICAgVmlld3BvcnQuZm9jdXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuRk9DVVNfSU4pKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBpZiAoVmlld3BvcnQuZm9jdXMgIT0gdGhpcylcclxuICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVC5GT0NVU19PVVQpKTtcclxuICAgICAgICBWaWV3cG9ydC5mb2N1cyA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlLSAvIEFjdGl2YXRlcyB0aGUgZ2l2ZW4gcG9pbnRlciBldmVudCB0byBiZSBwcm9wYWdhdGVkIGludG8gdGhlIHZpZXdwb3J0IGFzIEZVREdFLUV2ZW50IFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWN0aXZhdGVQb2ludGVyRXZlbnQoX3R5cGU6IEVWRU5UX1BPSU5URVIsIF9vbjogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICB0aGlzLmFjdGl2YXRlRXZlbnQodGhpcy4jY2FudmFzLCBfdHlwZSwgdGhpcy5obmRQb2ludGVyRXZlbnQsIF9vbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZS0gLyBBY3RpdmF0ZXMgdGhlIGdpdmVuIGtleWJvYXJkIGV2ZW50IHRvIGJlIHByb3BhZ2F0ZWQgaW50byB0aGUgdmlld3BvcnQgYXMgRlVER0UtRXZlbnRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFjdGl2YXRlS2V5Ym9hcmRFdmVudChfdHlwZTogRVZFTlRfS0VZQk9BUkQsIF9vbjogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICB0aGlzLmFjdGl2YXRlRXZlbnQodGhpcy4jY2FudmFzLm93bmVyRG9jdW1lbnQsIF90eXBlLCB0aGlzLmhuZEtleWJvYXJkRXZlbnQsIF9vbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZS0gLyBBY3RpdmF0ZXMgdGhlIGdpdmVuIGRyYWctZHJvcCBldmVudCB0byBiZSBwcm9wYWdhdGVkIGludG8gdGhlIHZpZXdwb3J0IGFzIEZVREdFLUV2ZW50XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhY3RpdmF0ZURyYWdEcm9wRXZlbnQoX3R5cGU6IEVWRU5UX0RSQUdEUk9QLCBfb246IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgaWYgKF90eXBlID09IEVWRU5UX0RSQUdEUk9QLlNUQVJUKVxyXG4gICAgICAgIHRoaXMuI2NhbnZhcy5kcmFnZ2FibGUgPSBfb247XHJcbiAgICAgIHRoaXMuYWN0aXZhdGVFdmVudCh0aGlzLiNjYW52YXMsIF90eXBlLCB0aGlzLmhuZERyYWdEcm9wRXZlbnQsIF9vbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZS0gLyBBY3RpdmF0ZXMgdGhlIHdoZWVsIGV2ZW50IHRvIGJlIHByb3BhZ2F0ZWQgaW50byB0aGUgdmlld3BvcnQgYXMgRlVER0UtRXZlbnRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFjdGl2YXRlV2hlZWxFdmVudChfdHlwZTogRVZFTlRfV0hFRUwsIF9vbjogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICB0aGlzLmFjdGl2YXRlRXZlbnQodGhpcy4jY2FudmFzLCBfdHlwZSwgdGhpcy5obmRXaGVlbEV2ZW50LCBfb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlIGRyYWctZHJvcCBldmVudHMgYW5kIGRpc3BhdGNoIHRvIHZpZXdwb3J0IGFzIEZVREdFLUV2ZW50XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgaG5kRHJhZ0Ryb3BFdmVudDogRXZlbnRMaXN0ZW5lciA9IChfZXZlbnQ6IEV2ZW50KSA9PiB7XHJcbiAgICAgIGxldCBfZHJhZ2V2ZW50OiBFdmVudERyYWdEcm9wID0gPEV2ZW50RHJhZ0Ryb3A+X2V2ZW50O1xyXG4gICAgICBzd2l0Y2ggKF9kcmFnZXZlbnQudHlwZSkge1xyXG4gICAgICAgIGNhc2UgXCJkcmFnb3ZlclwiOlxyXG4gICAgICAgIGNhc2UgXCJkcm9wXCI6XHJcbiAgICAgICAgICBfZHJhZ2V2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICBfZHJhZ2V2ZW50LmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gXCJub25lXCI7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwiZHJhZ3N0YXJ0XCI6XHJcbiAgICAgICAgICAvLyBqdXN0IGR1bW15IGRhdGEsICB2YWxpZCBkYXRhIHNob3VsZCBiZSBzZXQgaW4gaGFuZGxlciByZWdpc3RlcmVkIGJ5IHRoZSB1c2VyXHJcbiAgICAgICAgICBfZHJhZ2V2ZW50LmRhdGFUcmFuc2Zlci5zZXREYXRhKFwidGV4dFwiLCBcIkhhbGxvXCIpO1xyXG4gICAgICAgICAgLy8gVE9ETzogY2hlY2sgaWYgdGhlcmUgaXMgYSBiZXR0ZXIgc29sdXRpb24gdG8gaGlkZSB0aGUgZ2hvc3QgaW1hZ2Ugb2YgdGhlIGRyYWdnYWJsZSBvYmplY3RcclxuICAgICAgICAgIF9kcmFnZXZlbnQuZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZShuZXcgSW1hZ2UoKSwgMCwgMCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBsZXQgZXZlbnQ6IEV2ZW50RHJhZ0Ryb3AgPSBuZXcgRXZlbnREcmFnRHJvcChcIsaSXCIgKyBfZXZlbnQudHlwZSwgX2RyYWdldmVudCk7XHJcbiAgICAgIHRoaXMuYWRkQ2FudmFzUG9zaXRpb24oZXZlbnQpO1xyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIG1hcHBlZCB0byBjYW52YXMtY29vcmRpbmF0ZXMgYXMgY2FudmFzWCwgY2FudmFzWSB0byB0aGUgZXZlbnRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBhZGRDYW52YXNQb3NpdGlvbihldmVudDogRXZlbnRQb2ludGVyIHwgRXZlbnREcmFnRHJvcCk6IHZvaWQge1xyXG4gICAgICBldmVudC5jYW52YXNYID0gdGhpcy4jY2FudmFzLndpZHRoICogZXZlbnQucG9pbnRlclggLyBldmVudC5jbGllbnRSZWN0LndpZHRoO1xyXG4gICAgICBldmVudC5jYW52YXNZID0gdGhpcy4jY2FudmFzLmhlaWdodCAqIGV2ZW50LnBvaW50ZXJZIC8gZXZlbnQuY2xpZW50UmVjdC5oZWlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGUgcG9pbnRlciBldmVudHMgYW5kIGRpc3BhdGNoIHRvIHZpZXdwb3J0IGFzIEZVREdFLUV2ZW50XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgaG5kUG9pbnRlckV2ZW50OiBFdmVudExpc3RlbmVyID0gKF9ldmVudDogRXZlbnQpID0+IHtcclxuICAgICAgbGV0IGV2ZW50OiBFdmVudFBvaW50ZXIgPSBuZXcgRXZlbnRQb2ludGVyKFwixpJcIiArIF9ldmVudC50eXBlLCA8RXZlbnRQb2ludGVyPl9ldmVudCk7XHJcbiAgICAgIHRoaXMuYWRkQ2FudmFzUG9zaXRpb24oZXZlbnQpO1xyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlIGtleWJvYXJkIGV2ZW50cyBhbmQgZGlzcGF0Y2ggdG8gdmlld3BvcnQgYXMgRlVER0UtRXZlbnQsIGlmIHRoZSB2aWV3cG9ydCBoYXMgdGhlIGZvY3VzXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgaG5kS2V5Ym9hcmRFdmVudDogRXZlbnRMaXN0ZW5lciA9IChfZXZlbnQ6IEV2ZW50KSA9PiB7XHJcbiAgICAgIGlmICghdGhpcy5oYXNGb2N1cylcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIGxldCBldmVudDogRXZlbnRLZXlib2FyZCA9IG5ldyBFdmVudEtleWJvYXJkKFwixpJcIiArIF9ldmVudC50eXBlLCA8RXZlbnRLZXlib2FyZD5fZXZlbnQpO1xyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlIHdoZWVsIGV2ZW50IGFuZCBkaXNwYXRjaCB0byB2aWV3cG9ydCBhcyBGVURHRS1FdmVudFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGhuZFdoZWVsRXZlbnQ6IEV2ZW50TGlzdGVuZXIgPSAoX2V2ZW50OiBFdmVudCkgPT4ge1xyXG4gICAgICBsZXQgZXZlbnQ6IEV2ZW50V2hlZWwgPSBuZXcgRXZlbnRXaGVlbChcIsaSXCIgKyBfZXZlbnQudHlwZSwgPEV2ZW50V2hlZWw+X2V2ZW50KTtcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFjdGl2YXRlRXZlbnQoX3RhcmdldDogRXZlbnRUYXJnZXQsIF90eXBlOiBzdHJpbmcsIF9oYW5kbGVyOiBFdmVudExpc3RlbmVyLCBfb246IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgX3R5cGUgPSBfdHlwZS5zbGljZSgxKTsgLy8gY2hpcCB0aGUgxpJsb3JpblxyXG4gICAgICBpZiAoX29uKVxyXG4gICAgICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihfdHlwZSwgX2hhbmRsZXIpO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKF90eXBlLCBfaGFuZGxlcik7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBobmRDb21wb25lbnRFdmVudChfZXZlbnQ6IEV2ZW50KTogdm9pZCB7XHJcbiAgICAgIC8vIFRPRE86IGZpbmQgb3V0IHdoYXQgdGhlIGlkZWEgd2FzIGhlcmUuLi5cclxuICAgICAgLy8gRGVidWcuZnVkZ2UoX2V2ZW50KTtcclxuICAgIH1cclxuICAgIC8vICNlbmRyZWdpb25cclxuICB9XHJcbn1cclxuIiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGludGVyZmFjZSBNYXBGaWxlbmFtZVRvQ29udGVudCB7XHJcbiAgICBbZmlsZW5hbWU6IHN0cmluZ106IHN0cmluZztcclxuICB9XHJcbiAgLyoqXHJcbiAgICogSGFuZGxlcyBmaWxlIHRyYW5zZmVyIGZyb20gYSBGdWRnZS1Ccm93c2VyYXBwIHRvIHRoZSBsb2NhbCBmaWxlc3lzdGVtIHdpdGhvdXQgYSBsb2NhbCBzZXJ2ZXIuICBcclxuICAgKiBTYXZlcyB0byB0aGUgZG93bmxvYWQtcGF0aCBnaXZlbiBieSB0aGUgYnJvd3NlciwgbG9hZHMgZnJvbSB0aGUgcGxheWVyJ3MgY2hvaWNlLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBGaWxlSW9Ccm93c2VyTG9jYWwgZXh0ZW5kcyBFdmVudFRhcmdldFN0YXRpYyB7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBzZWxlY3RvcjogSFRNTElucHV0RWxlbWVudDtcclxuICAgIC8vIFRPRE86IHJlZmFjdG9yIHRvIGFzeW5jIGZ1bmN0aW9uIHRvIGJlIGhhbmRsZWQgdXNpbmcgcHJvbWlzZSwgaW5zdGVhZCBvZiB1c2luZyBldmVudCB0YXJnZXRcclxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgbG9hZChfbXVsdGlwbGU6IGJvb2xlYW4gPSBmYWxzZSk6IFByb21pc2U8TWFwRmlsZW5hbWVUb0NvbnRlbnQ+IHtcclxuICAgICAgRmlsZUlvQnJvd3NlckxvY2FsLnNlbGVjdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xyXG4gICAgICBGaWxlSW9Ccm93c2VyTG9jYWwuc2VsZWN0b3IudHlwZSA9IFwiZmlsZVwiO1xyXG4gICAgICBGaWxlSW9Ccm93c2VyTG9jYWwuc2VsZWN0b3IubXVsdGlwbGUgPSBfbXVsdGlwbGU7XHJcbiAgICAgIEZpbGVJb0Jyb3dzZXJMb2NhbC5zZWxlY3Rvci5oaWRkZW4gPSB0cnVlO1xyXG4gICAgICBGaWxlSW9Ccm93c2VyTG9jYWwuc2VsZWN0b3IuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBGaWxlSW9Ccm93c2VyTG9jYWwuaGFuZGxlRmlsZVNlbGVjdCk7XHJcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoRmlsZUlvQnJvd3NlckxvY2FsLnNlbGVjdG9yKTtcclxuXHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZTxNYXBGaWxlbmFtZVRvQ29udGVudD4oX3Jlc29sdmUgPT4ge1xyXG4gICAgICAgIGZ1bmN0aW9uIGhuZExvYWRlZChfZXZlbnQ6IEV2ZW50KTogdm9pZCB7XHJcbiAgICAgICAgICBGaWxlSW9Ccm93c2VyTG9jYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVC5GSUxFX0xPQURFRCwgaG5kTG9hZGVkKTtcclxuICAgICAgICAgIF9yZXNvbHZlKCg8Q3VzdG9tRXZlbnQ+X2V2ZW50KS5kZXRhaWwubWFwRmlsZW5hbWVUb0NvbnRlbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgRmlsZUlvQnJvd3NlckxvY2FsLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuRklMRV9MT0FERUQsIGhuZExvYWRlZCk7XHJcbiAgICAgICAgRmlsZUlvQnJvd3NlckxvY2FsLnNlbGVjdG9yLmNsaWNrKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE86IHJlZmFjdG9yIHRvIGFzeW5jIGZ1bmN0aW9uIHRvIGJlIGhhbmRsZWQgdXNpbmcgcHJvbWlzZSwgaW5zdGVhZCBvZiB1c2luZyBldmVudCB0YXJnZXRcclxuICAgIHB1YmxpYyBzdGF0aWMgc2F2ZShfdG9TYXZlOiBNYXBGaWxlbmFtZVRvQ29udGVudCwgX3R5cGU6IHN0cmluZyA9IFwidGV4dC9wbGFpblwiICk6IFByb21pc2U8TWFwRmlsZW5hbWVUb0NvbnRlbnQ+IHtcclxuICAgICAgZm9yIChsZXQgZmlsZW5hbWUgaW4gX3RvU2F2ZSkge1xyXG4gICAgICAgIGxldCBjb250ZW50OiBzdHJpbmcgPSBfdG9TYXZlW2ZpbGVuYW1lXTtcclxuICAgICAgICBsZXQgYmxvYjogQmxvYiA9IG5ldyBCbG9iKFtjb250ZW50XSwgeyB0eXBlOiBfdHlwZSB9KTtcclxuICAgICAgICBsZXQgdXJsOiBzdHJpbmcgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcclxuICAgICAgICAvLyovIHVzaW5nIGFuY2hvciBlbGVtZW50IGZvciBkb3dubG9hZFxyXG4gICAgICAgIGxldCBkb3dubG9hZGVyOiBIVE1MQW5jaG9yRWxlbWVudDtcclxuICAgICAgICBkb3dubG9hZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XHJcbiAgICAgICAgZG93bmxvYWRlci5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIHVybCk7XHJcbiAgICAgICAgZG93bmxvYWRlci5zZXRBdHRyaWJ1dGUoXCJkb3dubG9hZFwiLCBmaWxlbmFtZSk7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkb3dubG9hZGVyKTtcclxuICAgICAgICBkb3dubG9hZGVyLmNsaWNrKCk7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkb3dubG9hZGVyKTtcclxuICAgICAgICB3aW5kb3cuVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbmV3IFByb21pc2U8TWFwRmlsZW5hbWVUb0NvbnRlbnQ+KF9yZXNvbHZlID0+IHtcclxuICAgICAgICBfcmVzb2x2ZShfdG9TYXZlKTtcclxuICAgICAgICAvLyBmdW5jdGlvbiBobmRTYXZlZChfZXZlbnQ6IEV2ZW50KTogdm9pZCB7XHJcbiAgICAgICAgLy8gICBGaWxlSW9Ccm93c2VyTG9jYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVC5GSUxFX1NBVkVELCBobmRTYXZlZCk7XHJcbiAgICAgICAgLy8gICBfcmVzb2x2ZSgoPEN1c3RvbUV2ZW50Pl9ldmVudCkuZGV0YWlsKTtcclxuICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgIC8vIEZpbGVJb0Jyb3dzZXJMb2NhbC5hZGRFdmVudExpc3RlbmVyKEVWRU5ULkZJTEVfU0FWRUQsIGhuZFNhdmVkKTtcclxuICAgICAgICAvLyBsZXQgZXZlbnQ6IEN1c3RvbUV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KEVWRU5ULkZJTEVfU0FWRUQsIHsgZGV0YWlsOiB7IG1hcEZpbGVuYW1lVG9Db250ZW50OiBfdG9TYXZlIH0gfSk7XHJcbiAgICAgICAgLy8gRmlsZUlvQnJvd3NlckxvY2FsLnRhcmdldFN0YXRpYy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBhc3luYyBoYW5kbGVGaWxlU2VsZWN0KF9ldmVudDogRXZlbnQpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgRGVidWcuZnVkZ2UoXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBoYW5kbGVGaWxlU2VsZWN0XCIpO1xyXG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKEZpbGVJb0Jyb3dzZXJMb2NhbC5zZWxlY3Rvcik7XHJcbiAgICAgIGxldCBmaWxlTGlzdDogRmlsZUxpc3QgPSAoPEhUTUxJbnB1dEVsZW1lbnQ+X2V2ZW50LnRhcmdldCkuZmlsZXM7XHJcbiAgICAgIERlYnVnLmZ1ZGdlKGZpbGVMaXN0LCBmaWxlTGlzdC5sZW5ndGgpO1xyXG4gICAgICBpZiAoZmlsZUxpc3QubGVuZ3RoID09IDApXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgbGV0IGxvYWRlZDogTWFwRmlsZW5hbWVUb0NvbnRlbnQgPSB7fTtcclxuICAgICAgYXdhaXQgRmlsZUlvQnJvd3NlckxvY2FsLmxvYWRGaWxlcyhmaWxlTGlzdCwgbG9hZGVkKTtcclxuXHJcbiAgICAgIGxldCBldmVudDogQ3VzdG9tRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoRVZFTlQuRklMRV9MT0FERUQsIHsgZGV0YWlsOiB7IG1hcEZpbGVuYW1lVG9Db250ZW50OiBsb2FkZWQgfSB9KTtcclxuICAgICAgRmlsZUlvQnJvd3NlckxvY2FsLnRhcmdldFN0YXRpYy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIGxvYWRGaWxlcyhfZmlsZUxpc3Q6IEZpbGVMaXN0LCBfbG9hZGVkOiBNYXBGaWxlbmFtZVRvQ29udGVudCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBmb3IgKGxldCBmaWxlIG9mIF9maWxlTGlzdCkge1xyXG4gICAgICAgIGNvbnN0IGNvbnRlbnQ6IHN0cmluZyA9IGF3YWl0IG5ldyBSZXNwb25zZShmaWxlKS50ZXh0KCk7XHJcbiAgICAgICAgX2xvYWRlZFtmaWxlLm5hbWVdID0gY29udGVudDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufSAiLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBNdXRhYmxlIGFycmF5IG9mIHtAbGluayBNdXRhYmxlfXMuIFRoZSB7QGxpbmsgTXV0YXRvcn1zIG9mIHRoZSBlbnRyaWVzIGFyZSBpbmNsdWRlZCBhcyBhcnJheSBpbiB0aGUge0BsaW5rIE11dGF0b3J9XHJcbiAgICogQGF1dGhvciBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBNdXRhYmxlQXJyYXk8VCBleHRlbmRzIE11dGFibGU+IGV4dGVuZHMgQXJyYXk8VD4ge1xyXG4gICAgcHVibGljIHJlYXJyYW5nZShfc2VxdWVuY2U6IG51bWJlcltdKTogdm9pZCB7XHJcbiAgICAgIGxldCBsZW5ndGg6IG51bWJlciA9IHRoaXMubGVuZ3RoO1xyXG4gICAgICBmb3IgKGxldCBpbmRleCBvZiBfc2VxdWVuY2UpIHtcclxuICAgICAgICBsZXQgb3JpZ2luYWw6IFQgPSB0aGlzW2luZGV4XTtcclxuICAgICAgICAvLyBUT0RPOiBvcHRpbWl6ZSwgY29weSBvbmx5IGRvdWJsZSBlbnRyaWVzXHJcbiAgICAgICAgLy9AdHMtaWdub3JlXHJcbiAgICAgICAgbGV0IGNvcHk6IFQgPSBuZXcgb3JpZ2luYWwuY29uc3RydWN0b3IoKTtcclxuICAgICAgICBjb3B5Lm11dGF0ZShvcmlnaW5hbC5nZXRNdXRhdG9yKCkpO1xyXG4gICAgICAgIHRoaXMucHVzaChjb3B5KTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnNwbGljZSgwLCBsZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGdldE11dGF0b3JBdHRyaWJ1dGVUeXBlcyhfbXV0YXRvcjogTXV0YXRvcik6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyB7XHJcbiAgICAgIGxldCB0eXBlczogTXV0YXRvckF0dHJpYnV0ZVR5cGVzID0ge307XHJcbiAgICAgIGZvciAobGV0IGVudHJ5IGluIHRoaXMpXHJcbiAgICAgICAgdHlwZXNbZW50cnldID0gdGhpc1tlbnRyeV0uY29uc3RydWN0b3IubmFtZTtcclxuXHJcbiAgICAgIHJldHVybiB0eXBlcztcclxuICAgIH1cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xyXG4gICAgICByZXR1cm4gdGhpcy5tYXAoKF92YWx1ZSkgPT4gX3ZhbHVlLmdldE11dGF0b3IoKSk7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvckZvclVzZXJJbnRlcmZhY2UoKTogTXV0YXRvciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldE11dGF0b3IoKTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgZm9yIChsZXQgZW50cnkgaW4gdGhpcylcclxuICAgICAgICBhd2FpdCB0aGlzW2VudHJ5XS5tdXRhdGUoX211dGF0b3JbZW50cnldKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gbXV0YXRvciBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB1cGRhdGVNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIGZvciAobGV0IGVudHJ5IGluIHRoaXMpIHtcclxuICAgICAgICBsZXQgbXV0YXRvclZhbHVlOiBPYmplY3QgPSBfbXV0YXRvcltlbnRyeV07XHJcbiAgICAgICAgaWYgKCFtdXRhdG9yVmFsdWUpXHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICBpZiAodGhpc1tlbnRyeV0gaW5zdGFuY2VvZiBNdXRhYmxlKVxyXG4gICAgICAgICAgX211dGF0b3JbZW50cnldID0gdGhpc1tlbnRyeV0uZ2V0TXV0YXRvcigpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIF9tdXRhdG9yW2VudHJ5XSA9IHRoaXNbZW50cnldO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGVudW0gTU9ERSB7XHJcbiAgICBFRElUT1IsIFJVTlRJTUVcclxuICB9XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgU2VyaWFsaXphYmxlUmVzb3VyY2UgZXh0ZW5kcyBTZXJpYWxpemFibGUge1xyXG4gICAgbmFtZTogc3RyaW5nO1xyXG4gICAgdHlwZTogc3RyaW5nO1xyXG4gICAgaWRSZXNvdXJjZTogc3RyaW5nO1xyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGludGVyZmFjZSBSZXNvdXJjZXMge1xyXG4gICAgW2lkUmVzb3VyY2U6IHN0cmluZ106IFNlcmlhbGl6YWJsZVJlc291cmNlO1xyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGludGVyZmFjZSBTZXJpYWxpemF0aW9uT2ZSZXNvdXJjZXMge1xyXG4gICAgW2lkUmVzb3VyY2U6IHN0cmluZ106IFNlcmlhbGl6YXRpb247XHJcbiAgfVxyXG5cclxuICBleHBvcnQgaW50ZXJmYWNlIFNjcmlwdE5hbWVzcGFjZXMge1xyXG4gICAgW25hbWU6IHN0cmluZ106IE9iamVjdDtcclxuICB9XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgQ29tcG9uZW50U2NyaXB0cyB7XHJcbiAgICBbbmFtZXNwYWNlOiBzdHJpbmddOiBDb21wb25lbnRTY3JpcHRbXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXRpYyBjbGFzcyBoYW5kbGluZyB0aGUgcmVzb3VyY2VzIHVzZWQgd2l0aCB0aGUgY3VycmVudCBGVURHRS1pbnN0YW5jZS4gIFxyXG4gICAqIEtlZXBzIGEgbGlzdCBvZiB0aGUgcmVzb3VyY2VzIGFuZCBnZW5lcmF0ZXMgaWRzIHRvIHJldHJpZXZlIHRoZW0uICBcclxuICAgKiBSZXNvdXJjZXMgYXJlIG9iamVjdHMgcmVmZXJlbmNlZCBtdWx0aXBsZSB0aW1lcyBidXQgc3VwcG9zZWQgdG8gYmUgc3RvcmVkIG9ubHkgb25jZVxyXG4gICAqL1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBQcm9qZWN0IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVzb3VyY2VzOiBSZXNvdXJjZXMgPSB7fTtcclxuICAgIHB1YmxpYyBzdGF0aWMgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbk9mUmVzb3VyY2VzID0ge307XHJcbiAgICBwdWJsaWMgc3RhdGljIHNjcmlwdE5hbWVzcGFjZXM6IFNjcmlwdE5hbWVzcGFjZXMgPSB7fTtcclxuICAgIHB1YmxpYyBzdGF0aWMgYmFzZVVSTDogVVJMID0gbmV3IFVSTChsb2NhdGlvbi50b1N0cmluZygpKTtcclxuICAgIHB1YmxpYyBzdGF0aWMgbW9kZTogTU9ERSA9IE1PREUuUlVOVElNRTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVycyB0aGUgcmVzb3VyY2UgYW5kIGdlbmVyYXRlcyBhbiBpZCBmb3IgaXQgYnkgZGVmYXVsdC4gIFxyXG4gICAgICogSWYgdGhlIHJlc291cmNlIGFscmVhZHkgaGFzIGFuIGlkLCB0aHVzIGhhdmluZyBiZWVuIHJlZ2lzdGVyZWQsIGl0cyBkZWxldGVkIGZyb20gdGhlIGxpc3QgYW5kIHJlZ2lzdGVyZWQgYW5ldy5cclxuICAgICAqIEl0J3MgcG9zc2libGUgdG8gcGFzcyBhbiBpZCwgYnV0IHNob3VsZCBub3QgYmUgZG9uZSBleGNlcHQgYnkgdGhlIFNlcmlhbGl6ZXIuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVnaXN0ZXIoX3Jlc291cmNlOiBTZXJpYWxpemFibGVSZXNvdXJjZSwgX2lkUmVzb3VyY2U/OiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgaWYgKF9yZXNvdXJjZS5pZFJlc291cmNlKVxyXG4gICAgICAgIGlmIChfcmVzb3VyY2UuaWRSZXNvdXJjZSA9PSBfaWRSZXNvdXJjZSlcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICB0aGlzLmRlcmVnaXN0ZXIoX3Jlc291cmNlKTtcclxuICAgICAgX3Jlc291cmNlLmlkUmVzb3VyY2UgPSBfaWRSZXNvdXJjZSB8fCBQcm9qZWN0LmdlbmVyYXRlSWQoX3Jlc291cmNlKTtcclxuICAgICAgUHJvamVjdC5yZXNvdXJjZXNbX3Jlc291cmNlLmlkUmVzb3VyY2VdID0gX3Jlc291cmNlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZGVyZWdpc3RlcihfcmVzb3VyY2U6IFNlcmlhbGl6YWJsZVJlc291cmNlKTogdm9pZCB7XHJcbiAgICAgIGRlbGV0ZSAoUHJvamVjdC5yZXNvdXJjZXNbX3Jlc291cmNlLmlkUmVzb3VyY2VdKTtcclxuICAgICAgZGVsZXRlIChQcm9qZWN0LnNlcmlhbGl6YXRpb25bX3Jlc291cmNlLmlkUmVzb3VyY2VdKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGNsZWFyKCk6IHZvaWQge1xyXG4gICAgICBQcm9qZWN0LnJlc291cmNlcyA9IHt9O1xyXG4gICAgICBQcm9qZWN0LnNlcmlhbGl6YXRpb24gPSB7fTtcclxuICAgICAgUHJvamVjdC5zY3JpcHROYW1lc3BhY2VzID0ge307XHJcbiAgICB9XHJcblxyXG4gICAgLy8gPFQgZXh0ZW5kcyBDb21wb25lbnQ+KF9jbGFzczogbmV3ICgpID0+IFQpOiBUW10ge1xyXG4gICAgLy8gICByZXR1cm4gPFRbXT4odGhpcy5jb21wb25lbnRzW19jbGFzcy5uYW1lXSB8fCBbXSkuc2xpY2UoMCk7XHJcbiAgICAvLyB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRSZXNvdXJjZXNPZlR5cGU8VD4oX3R5cGU6IG5ldyAoX2FyZ3M6IEdlbmVyYWwpID0+IFQpOiBSZXNvdXJjZXMge1xyXG4gICAgICBsZXQgZm91bmQ6IFJlc291cmNlcyA9IHt9O1xyXG4gICAgICBmb3IgKGxldCByZXNvdXJjZUlkIGluIFByb2plY3QucmVzb3VyY2VzKSB7XHJcbiAgICAgICAgbGV0IHJlc291cmNlOiBTZXJpYWxpemFibGVSZXNvdXJjZSA9IFByb2plY3QucmVzb3VyY2VzW3Jlc291cmNlSWRdO1xyXG4gICAgICAgIGlmIChyZXNvdXJjZSBpbnN0YW5jZW9mIF90eXBlKVxyXG4gICAgICAgICAgZm91bmRbcmVzb3VyY2VJZF0gPSByZXNvdXJjZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZm91bmQ7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGUgYSB1c2VyIHJlYWRhYmxlIGFuZCB1bmlxdWUgaWQgdXNpbmcgdGhlIHR5cGUgb2YgdGhlIHJlc291cmNlLCB0aGUgZGF0ZSBhbmQgcmFuZG9tIG51bWJlcnNcclxuICAgICAqIEBwYXJhbSBfcmVzb3VyY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZW5lcmF0ZUlkKF9yZXNvdXJjZTogU2VyaWFsaXphYmxlUmVzb3VyY2UpOiBzdHJpbmcge1xyXG4gICAgICAvLyBUT0RPOiBidWlsZCBpZCBhbmQgaW50ZWdyYXRlIGluZm8gZnJvbSByZXNvdXJjZSwgbm90IGp1c3QgZGF0ZVxyXG4gICAgICBsZXQgaWRSZXNvdXJjZTogc3RyaW5nO1xyXG4gICAgICBkb1xyXG4gICAgICAgIGlkUmVzb3VyY2UgPSBfcmVzb3VyY2UuY29uc3RydWN0b3IubmFtZSArIFwifFwiICsgbmV3IERhdGUoKS50b0lTT1N0cmluZygpICsgXCJ8XCIgKyBNYXRoLnJhbmRvbSgpLnRvUHJlY2lzaW9uKDUpLnN1YnN0cigyLCA1KTtcclxuICAgICAgd2hpbGUgKFByb2plY3QucmVzb3VyY2VzW2lkUmVzb3VyY2VdKTtcclxuICAgICAgcmV0dXJuIGlkUmVzb3VyY2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cywgaWYgYW4gb2JqZWN0IGlzIGEge0BsaW5rIFNlcmlhbGl6YWJsZVJlc291cmNlfVxyXG4gICAgICogQHBhcmFtIF9vYmplY3QgVGhlIG9iamVjdCB0byBleGFtaW5lXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgaXNSZXNvdXJjZShfb2JqZWN0OiBTZXJpYWxpemFibGUpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIChSZWZsZWN0Lmhhcyhfb2JqZWN0LCBcImlkUmVzb3VyY2VcIikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIHRoZSByZXNvdXJjZSBzdG9yZWQgd2l0aCB0aGUgZ2l2ZW4gaWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBhc3luYyBnZXRSZXNvdXJjZShfaWRSZXNvdXJjZTogc3RyaW5nKTogUHJvbWlzZTxTZXJpYWxpemFibGVSZXNvdXJjZT4ge1xyXG4gICAgICBsZXQgcmVzb3VyY2U6IFNlcmlhbGl6YWJsZVJlc291cmNlID0gUHJvamVjdC5yZXNvdXJjZXNbX2lkUmVzb3VyY2VdO1xyXG4gICAgICBpZiAoIXJlc291cmNlKSB7XHJcbiAgICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSBQcm9qZWN0LnNlcmlhbGl6YXRpb25bX2lkUmVzb3VyY2VdO1xyXG4gICAgICAgIGlmICghc2VyaWFsaXphdGlvbikge1xyXG4gICAgICAgICAgRGVidWcuZXJyb3IoXCJSZXNvdXJjZSBub3QgZm91bmRcIiwgX2lkUmVzb3VyY2UpO1xyXG4gICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc291cmNlID0gYXdhaXQgUHJvamVjdC5kZXNlcmlhbGl6ZVJlc291cmNlKHNlcmlhbGl6YXRpb24pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXNvdXJjZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW5kIHJlZ2lzdGVycyBhIHJlc291cmNlIGZyb20gYSB7QGxpbmsgTm9kZX0sIGNvcHlpbmcgdGhlIGNvbXBsZXRlIGdyYXBoIHN0YXJ0aW5nIHdpdGggaXRcclxuICAgICAqIEBwYXJhbSBfbm9kZSBBIG5vZGUgdG8gY3JlYXRlIHRoZSByZXNvdXJjZSBmcm9tXHJcbiAgICAgKiBAcGFyYW0gX3JlcGxhY2VXaXRoSW5zdGFuY2UgaWYgdHJ1ZSAoZGVmYXVsdCksIHRoZSBub2RlIHVzZWQgYXMgb3JpZ2luIGlzIHJlcGxhY2VkIGJ5IGEge0BsaW5rIEdyYXBoSW5zdGFuY2V9IG9mIHRoZSB7QGxpbmsgR3JhcGh9IGNyZWF0ZWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBhc3luYyByZWdpc3RlckFzR3JhcGgoX25vZGU6IE5vZGUsIF9yZXBsYWNlV2l0aEluc3RhbmNlOiBib29sZWFuID0gdHJ1ZSk6IFByb21pc2U8R3JhcGg+IHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSBfbm9kZS5zZXJpYWxpemUoKTtcclxuICAgICAgbGV0IGdyYXBoOiBHcmFwaCA9IG5ldyBHcmFwaChfbm9kZS5uYW1lKTtcclxuICAgICAgYXdhaXQgZ3JhcGguZGVzZXJpYWxpemUoc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIFByb2plY3QucmVnaXN0ZXIoZ3JhcGgpO1xyXG5cclxuICAgICAgaWYgKF9yZXBsYWNlV2l0aEluc3RhbmNlICYmIF9ub2RlLmdldFBhcmVudCgpKSB7XHJcbiAgICAgICAgbGV0IGluc3RhbmNlOiBHcmFwaEluc3RhbmNlID0gYXdhaXQgUHJvamVjdC5jcmVhdGVHcmFwaEluc3RhbmNlKGdyYXBoKTtcclxuICAgICAgICBfbm9kZS5nZXRQYXJlbnQoKS5yZXBsYWNlQ2hpbGQoX25vZGUsIGluc3RhbmNlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGdyYXBoO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgY3JlYXRlR3JhcGhJbnN0YW5jZShfZ3JhcGg6IEdyYXBoKTogUHJvbWlzZTxHcmFwaEluc3RhbmNlPiB7XHJcbiAgICAgIGxldCBpbnN0YW5jZTogR3JhcGhJbnN0YW5jZSA9IG5ldyBHcmFwaEluc3RhbmNlKCk7IC8vIFRPRE86IGNsZWFudXAgc2luY2UgY3JlYXRpb24gbW92ZWQgaGVyZVxyXG4gICAgICBhd2FpdCBpbnN0YW5jZS5zZXQoX2dyYXBoKTtcclxuICAgICAgcmV0dXJuIGluc3RhbmNlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVnaXN0ZXJTY3JpcHROYW1lc3BhY2UoX25hbWVzcGFjZTogT2JqZWN0KTogdm9pZCB7XHJcbiAgICAgIGxldCBuYW1lOiBzdHJpbmcgPSBTZXJpYWxpemVyLnJlZ2lzdGVyTmFtZXNwYWNlKF9uYW1lc3BhY2UpO1xyXG4gICAgICBpZiAoIVByb2plY3Quc2NyaXB0TmFtZXNwYWNlc1tuYW1lXSlcclxuICAgICAgICBQcm9qZWN0LnNjcmlwdE5hbWVzcGFjZXNbbmFtZV0gPSBfbmFtZXNwYWNlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0Q29tcG9uZW50U2NyaXB0cygpOiBDb21wb25lbnRTY3JpcHRzIHtcclxuICAgICAgbGV0IGNvbXBvbWVudHM6IENvbXBvbmVudFNjcmlwdHMgPSB7fTtcclxuICAgICAgZm9yIChsZXQgbmFtZXNwYWNlIGluIFByb2plY3Quc2NyaXB0TmFtZXNwYWNlcykge1xyXG4gICAgICAgIGNvbXBvbWVudHNbbmFtZXNwYWNlXSA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gUHJvamVjdC5zY3JpcHROYW1lc3BhY2VzW25hbWVzcGFjZV0pIHtcclxuICAgICAgICAgIGxldCBzY3JpcHQ6IENvbXBvbmVudFNjcmlwdCA9IFJlZmxlY3QuZ2V0KFByb2plY3Quc2NyaXB0TmFtZXNwYWNlc1tuYW1lc3BhY2VdLCBuYW1lKTtcclxuXHJcbiAgICAgICAgICAvLyBpcyBzY3JpcHQgYSBzdWJjbGFzcyBvZiBDb21wb25lbnRTY3JpcHQ/IGluc3RhbmNlb2YgZG9lc24ndCB3b3JrLCBzaW5jZSBubyBpbnN0YW5jZSBpcyBjcmVhdGVkXHJcblxyXG4gICAgICAgICAgLy8gbGV0IHN1cGVyY2xhc3M6IE9iamVjdCA9IHNjcmlwdDtcclxuICAgICAgICAgIC8vIHdoaWxlIChzdXBlcmNsYXNzKSB7XHJcbiAgICAgICAgICAvLyAgIHN1cGVyY2xhc3MgPSBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHN1cGVyY2xhc3MpO1xyXG4gICAgICAgICAgLy8gICBpZiAoc3VwZXJjbGFzcyA9PSBDb21wb25lbnRTY3JpcHQpIHtcclxuICAgICAgICAgIC8vICAgICBzY3JpcHRzLnB1c2goc2NyaXB0KTtcclxuICAgICAgICAgIC8vICAgICBicmVhaztcclxuICAgICAgICAgIC8vICAgfVxyXG4gICAgICAgICAgLy8gfVxyXG5cclxuICAgICAgICAgIC8vIFVzaW5nIE9iamVjdC5jcmVhdGUgZG9lc24ndCBjYWxsIHRoZSBjb25zdHJ1Y3RvciwgYnV0IGluc3RhbmNlb2YgY2FuIGJlIHVzZWQuIE1vcmUgZWxlZ2FudCB0aGFuIHRoZSBsb29wIGFib3ZlLCB0aG91Z2ggbWF5YmUgbm90IGFzIHBlcmZvcm1hbnQuIFxyXG4gICAgICAgICAgbGV0IG86IEdlbmVyYWwgPSBPYmplY3QuY3JlYXRlKHNjcmlwdCk7XHJcbiAgICAgICAgICBpZiAoby5wcm90b3R5cGUgaW5zdGFuY2VvZiBDb21wb25lbnRTY3JpcHQpXHJcbiAgICAgICAgICAgIGNvbXBvbWVudHNbbmFtZXNwYWNlXS5wdXNoKHNjcmlwdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBjb21wb21lbnRzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgbG9hZFNjcmlwdChfdXJsOiBSZXF1ZXN0SW5mbyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBsZXQgc2NyaXB0OiBIVE1MU2NyaXB0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XHJcbiAgICAgIHNjcmlwdC50eXBlID0gXCJ0ZXh0L2phdmFzY3JpcHRcIjtcclxuICAgICAgLy8gc2NyaXB0LnR5cGUgPSBcIm1vZHVsZVwiO1xyXG4gICAgICBzY3JpcHQuYXN5bmMgPSBmYWxzZTtcclxuICAgICAgLy8gc2NyaXB0LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGhhbmRsZUxvYWRlZFNjcmlwdClcclxuICAgICAgbGV0IGhlYWQ6IEhUTUxIZWFkRWxlbWVudCA9IGRvY3VtZW50LmhlYWQ7XHJcbiAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcclxuICAgICAgRGVidWcubG9nKFwiTG9hZGluZzogXCIsIF91cmwpO1xyXG5cclxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICBzY3JpcHQuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKCkgPT4gcmVzb2x2ZSgpKTtcclxuICAgICAgICBzY3JpcHQuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsICgpID0+IHtcclxuICAgICAgICAgIERlYnVnLmVycm9yKFwiTG9hZGluZyBzY3JpcHRcIiwgX3VybCk7XHJcbiAgICAgICAgICByZWplY3QoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBzY3JpcHQuc3JjID0gX3VybC50b1N0cmluZygpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIGxvYWRSZXNvdXJjZXMoX3VybDogUmVxdWVzdEluZm8pOiBQcm9taXNlPFJlc291cmNlcz4ge1xyXG4gICAgICBjb25zdCByZXNwb25zZTogUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChfdXJsKTtcclxuICAgICAgY29uc3QgcmVzb3VyY2VGaWxlQ29udGVudDogc3RyaW5nID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xyXG5cclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSBTZXJpYWxpemVyLnBhcnNlKHJlc291cmNlRmlsZUNvbnRlbnQpO1xyXG4gICAgICBsZXQgcmVjb25zdHJ1Y3Rpb246IFJlc291cmNlcyA9IGF3YWl0IFByb2plY3QuZGVzZXJpYWxpemUoc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIHJldHVybiByZWNvbnN0cnVjdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIGxvYWRSZXNvdXJjZXNGcm9tSFRNTCgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgY29uc3QgaGVhZDogSFRNTEhlYWRFbGVtZW50ID0gZG9jdW1lbnQuaGVhZDtcclxuICAgICAgbGV0IGxpbmtzOiBOb2RlTGlzdE9mPEhUTUxMaW5rRWxlbWVudD4gPSBoZWFkLnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rW3R5cGU9cmVzb3VyY2VzXVwiKTtcclxuICAgICAgZm9yIChsZXQgbGluayBvZiBsaW5rcykge1xyXG4gICAgICAgIGxldCB1cmw6IFJlcXVlc3RJbmZvID0gbGluay5nZXRBdHRyaWJ1dGUoXCJzcmNcIik7XHJcbiAgICAgICAgYXdhaXQgUHJvamVjdC5sb2FkUmVzb3VyY2VzKHVybCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlcmlhbGl6ZSBhbGwgcmVzb3VyY2VzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb25PZlJlc291cmNlcyB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uT2ZSZXNvdXJjZXMgPSB7fTtcclxuICAgICAgZm9yIChsZXQgaWRSZXNvdXJjZSBpbiBQcm9qZWN0LnJlc291cmNlcykge1xyXG4gICAgICAgIGxldCByZXNvdXJjZTogU2VyaWFsaXphYmxlUmVzb3VyY2UgPSBQcm9qZWN0LnJlc291cmNlc1tpZFJlc291cmNlXTtcclxuICAgICAgICBpZiAoaWRSZXNvdXJjZSAhPSByZXNvdXJjZS5pZFJlc291cmNlKVxyXG4gICAgICAgICAgRGVidWcuZXJyb3IoXCJSZXNvdXJjZS1pZCBtaXNtYXRjaFwiLCByZXNvdXJjZSk7XHJcbiAgICAgICAgc2VyaWFsaXphdGlvbltpZFJlc291cmNlXSA9IFNlcmlhbGl6ZXIuc2VyaWFsaXplKHJlc291cmNlKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSByZXNvdXJjZXMgZnJvbSBhIHNlcmlhbGl6YXRpb24sIGRlbGV0aW5nIGFsbCByZXNvdXJjZXMgcHJldmlvdXNseSByZWdpc3RlcmVkXHJcbiAgICAgKiBAcGFyYW0gX3NlcmlhbGl6YXRpb24gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb25PZlJlc291cmNlcyk6IFByb21pc2U8UmVzb3VyY2VzPiB7XHJcbiAgICAgIFByb2plY3Quc2VyaWFsaXphdGlvbiA9IF9zZXJpYWxpemF0aW9uO1xyXG4gICAgICBQcm9qZWN0LnJlc291cmNlcyA9IHt9O1xyXG4gICAgICBmb3IgKGxldCBpZFJlc291cmNlIGluIF9zZXJpYWxpemF0aW9uKSB7XHJcbiAgICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSBfc2VyaWFsaXphdGlvbltpZFJlc291cmNlXTtcclxuICAgICAgICBsZXQgcmVzb3VyY2U6IFNlcmlhbGl6YWJsZVJlc291cmNlID0gYXdhaXQgUHJvamVjdC5kZXNlcmlhbGl6ZVJlc291cmNlKHNlcmlhbGl6YXRpb24pO1xyXG4gICAgICAgIGlmIChyZXNvdXJjZSlcclxuICAgICAgICAgIFByb2plY3QucmVzb3VyY2VzW2lkUmVzb3VyY2VdID0gcmVzb3VyY2U7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIFByb2plY3QucmVzb3VyY2VzO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplUmVzb3VyY2UoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZVJlc291cmNlPiB7XHJcbiAgICAgIHJldHVybiA8UHJvbWlzZTxTZXJpYWxpemFibGVSZXNvdXJjZT4+U2VyaWFsaXplci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwiLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9Db2F0L0NvYXQudHNcIi8+XHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFN0YXRpYyBzdXBlcmNsYXNzIGZvciB0aGUgcmVwcmVzZW50YXRpb24gb2YgV2ViR2wgc2hhZGVycHJvZ3JhbXMuIFxyXG4gICAqIEBhdXRob3JzIEphc2NoYSBLYXJhZ8O2bCwgSEZVLCAyMDE5IHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuXHJcbiAgLy8gVE9ETzogZGVmaW5lIGF0dHJpYnV0ZS91bmlmb3JtcyBhcyBsYXlvdXQgYW5kIHVzZSB0aG9zZSBjb25zaXN0ZW50bHkgaW4gc2hhZGVyc1xyXG4gIEBSZW5kZXJJbmplY3RvclNoYWRlci5kZWNvcmF0ZVxyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXIge1xyXG4gICAgLyoqIHJlZmVycyBiYWNrIHRvIHRoaXMgY2xhc3MgZnJvbSBhbnkgc3ViY2xhc3MgZS5nLiBpbiBvcmRlciB0byBmaW5kIGNvbXBhdGlibGUgb3RoZXIgcmVzb3VyY2VzKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgYmFzZUNsYXNzOiB0eXBlb2YgU2hhZGVyID0gU2hhZGVyO1xyXG4gICAgLyoqIGxpc3Qgb2YgYWxsIHRoZSBzdWJjbGFzc2VzIGRlcml2ZWQgZnJvbSB0aGlzIGNsYXNzLCBpZiB0aGV5IHJlZ2lzdGVyZWQgcHJvcGVybHkqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBzdWJjbGFzc2VzOiB0eXBlb2YgU2hhZGVyW10gPSBbXTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIHZlcnRleFNoYWRlclNvdXJjZTogc3RyaW5nO1xyXG4gICAgcHVibGljIHN0YXRpYyBmcmFnbWVudFNoYWRlclNvdXJjZTogc3RyaW5nO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgcHJvZ3JhbTogV2ViR0xQcm9ncmFtO1xyXG4gICAgcHVibGljIHN0YXRpYyBhdHRyaWJ1dGVzOiB7IFtuYW1lOiBzdHJpbmddOiBudW1iZXIgfTtcclxuICAgIHB1YmxpYyBzdGF0aWMgdW5pZm9ybXM6IHsgW25hbWU6IHN0cmluZ106IFdlYkdMVW5pZm9ybUxvY2F0aW9uIH07XHJcblxyXG4gICAgLyoqIFRoZSB0eXBlIG9mIGNvYXQgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIHRoaXMgc2hhZGVyIHRvIGNyZWF0ZSBhIG1hdGVyaWFsICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQgeyByZXR1cm4gQ29hdENvbG9yZWQ7IH1cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0VmVydGV4U2hhZGVyU291cmNlKCk6IHN0cmluZyB7IHJldHVybiB0aGlzLnZlcnRleFNoYWRlclNvdXJjZTsgfVxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpOiBzdHJpbmcgeyByZXR1cm4gdGhpcy5mcmFnbWVudFNoYWRlclNvdXJjZTsgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZGVsZXRlUHJvZ3JhbSh0aGlzOiB0eXBlb2YgU2hhZGVyKTogdm9pZCB7LyogaW5qZWN0ZWQgYnkgZGVjb3JhdG9yICovIH1cclxuICAgIHB1YmxpYyBzdGF0aWMgdXNlUHJvZ3JhbSh0aGlzOiB0eXBlb2YgU2hhZGVyKTogdm9pZCB7LyogaW5qZWN0ZWQgYnkgZGVjb3JhdG9yICovIH1cclxuICAgIHB1YmxpYyBzdGF0aWMgY3JlYXRlUHJvZ3JhbSh0aGlzOiB0eXBlb2YgU2hhZGVyKTogdm9pZCB7LyogaW5qZWN0ZWQgYnkgZGVjb3JhdG9yICovIH0gXHJcbiAgICBcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVnaXN0ZXJTdWJjbGFzcyhfc3ViY2xhc3M6IHR5cGVvZiBTaGFkZXIpOiBudW1iZXIgeyByZXR1cm4gU2hhZGVyLnN1YmNsYXNzZXMucHVzaChfc3ViY2xhc3MpIC0gMTsgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuLyoqIENvZGUgZ2VuZXJhdGVkIGJ5IENvbXBpbGVTaGFkZXJzLm1qcyB1c2luZyB0aGUgaW5mb3JtYXRpb24gaW4gQ29tcGlsZVNoYWRlcnMuanNvbiAqL1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyRmxhdCBleHRlbmRzIFNoYWRlciB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBTaGFkZXIucmVnaXN0ZXJTdWJjbGFzcyhTaGFkZXJGbGF0KTtcblxuICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQgeyByZXR1cm4gQ29hdENvbG9yZWQ7IH1cblxuICBwdWJsaWMgc3RhdGljIGdldFZlcnRleFNoYWRlclNvdXJjZSgpOiBzdHJpbmcgeyBcbnJldHVybiBgI3ZlcnNpb24gMzAwIGVzXG4jZGVmaW5lIExJR0hUXG4jZGVmaW5lIEZMQVRcbiNkZWZpbmUgQ0FNRVJBXG5cclxuLyoqXHJcbiogVW5pdmVyc2FsIFNoYWRlciBhcyBiYXNlIGZvciBtYW55IG90aGVycy4gQ29udHJvbGxlZCBieSBjb21waWxlciBkaXJlY3RpdmVzXHJcbiogQGF1dGhvcnMgMjAyMSwgTHVpcyBLZWNrLCBIRlUsIDIwMjEgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxyXG4qL1xyXG5cclxuICAvLyBNSU5JTUFMIChubyBkZWZpbmUgbmVlZGVkKTogYnVmZmVycyBmb3IgdHJhbnNmb3JtYXRpb25cclxudW5pZm9ybSBtYXQ0IHVfbXR4TWVzaFRvVmlldztcclxuXHJcbiAgLy8gRkxBVDogb2ZmZXIgYnVmZmVycyBmb3IgZmFjZSBub3JtYWxzIGFuZCB0aGVpciB0cmFuc2Zvcm1hdGlvblxyXG4gICNpZiBkZWZpbmVkKEZMQVQpXHJcbmluIHZlYzMgYV92Y3RQb3NpdGlvbkZsYXQ7XHJcbmluIHZlYzMgYV92Y3ROb3JtYWxGYWNlO1xyXG51bmlmb3JtIG1hdDQgdV9tdHhOb3JtYWxNZXNoVG9Xb3JsZDtcclxuZmxhdCBvdXQgdmVjNCB2X3ZjdENvbG9yO1xyXG4gICNlbHNlXHJcbiAgLy8gcmVndWxhciBpZiBub3QgRkxBVFxyXG5pbiB2ZWMzIGFfdmN0UG9zaXRpb247XHJcbm91dCB2ZWM0IHZfdmN0Q29sb3I7XHJcbiAgI2VuZGlmXHJcblxyXG4gIC8vIExJR0hUOiBvZmZlciBidWZmZXJzIGZvciBsaWdodGluZyB2ZXJ0aWNlcyB3aXRoIGRpZmZlcmVudCBsaWdodCB0eXBlc1xyXG4gICNpZiBkZWZpbmVkKExJR0hUKVxyXG5zdHJ1Y3QgTGlnaHRBbWJpZW50IHtcclxuICB2ZWM0IHZjdENvbG9yO1xyXG59O1xyXG5zdHJ1Y3QgTGlnaHREaXJlY3Rpb25hbCB7XHJcbiAgdmVjNCB2Y3RDb2xvcjtcclxuICB2ZWMzIHZjdERpcmVjdGlvbjtcclxufTtcclxuXHJcbmNvbnN0IHVpbnQgTUFYX0xJR0hUU19ESVJFQ1RJT05BTCA9IDEwMHU7XHJcblxyXG51bmlmb3JtIExpZ2h0QW1iaWVudCB1X2FtYmllbnQ7XHJcbnVuaWZvcm0gdWludCB1X25MaWdodHNEaXJlY3Rpb25hbDtcclxudW5pZm9ybSBMaWdodERpcmVjdGlvbmFsIHVfZGlyZWN0aW9uYWxbTUFYX0xJR0hUU19ESVJFQ1RJT05BTF07XHJcbiAgI2VuZGlmIFxyXG5cclxuICAvLyBURVhUVVJFOiBvZmZlciBidWZmZXJzIGZvciBVVnMgYW5kIHBpdm90IG1hdHJpeFxyXG4gICNpZiBkZWZpbmVkKFRFWFRVUkUpXHJcbnVuaWZvcm0gbWF0MyB1X210eFBpdm90O1xyXG5pbiB2ZWMyIGFfdmN0VGV4dHVyZTtcclxub3V0IHZlYzIgdl92Y3RUZXh0dXJlO1xyXG4gICNlbmRpZlxyXG5cclxuICAjaWYgZGVmaW5lZChNQVRDQVApIC8vIE1hdENhcC1zaGFkZXIgZ2VuZXJhdGVzIHRleHR1cmUgY29vcmRpbmF0ZXMgZnJvbSBzdXJmYWNlIG5vcm1hbHNcclxub3V0IHZlYzIgdl92Y3RUZXh0dXJlO1xyXG4gICNlbmRpZlxyXG5cclxuICAvLyBHT1VSQVVEOiBvZmZlciBidWZmZXJzIGZvciB2ZXJ0ZXggbm9ybWFscywgdGhlaXIgdHJhbnNmb3JtYXRpb24gYW5kIHRoZSBzaGluaW5lc3NcclxuICAjaWYgZGVmaW5lZChHT1VSQVVEKXx8ZGVmaW5lZChNQVRDQVApXHJcbmluIHZlYzMgYV92Y3ROb3JtYWxWZXJ0ZXg7XHJcbnVuaWZvcm0gbWF0NCB1X210eE5vcm1hbE1lc2hUb1dvcmxkO1xyXG4gICNlbmRpZlxyXG5cclxuICAvLyBDQU1FUkE6IG9mZmVyIGJ1ZmZlciBhbmQgZnVuY3Rpb25hbGl0eSBmb3Igc3BlY3VsYXIgcmVmbGVjdGlvbiBkZXBlbmRpbmcgb24gdGhlIGNhbWVyYS1wb3NpdGlvblxyXG4gICNpZiBkZWZpbmVkKENBTUVSQSlcclxudW5pZm9ybSBmbG9hdCB1X2ZTaGluaW5lc3M7XHJcbnVuaWZvcm0gbWF0NCB1X210eE1lc2hUb1dvcmxkO1xyXG51bmlmb3JtIG1hdDQgdV9tdHhXb3JsZFRvVmlldztcclxudW5pZm9ybSB2ZWMzIHVfdmN0Q2FtZXJhO1xyXG5cclxuZmxvYXQgY2FsY3VsYXRlUmVmbGVjdGlvbih2ZWMzIF92Y3RMaWdodCwgdmVjMyBfdmN0VmlldywgdmVjMyBfdmN0Tm9ybWFsLCBmbG9hdCBfZlNoaW5pbmVzcykge1xyXG4gIGlmKF9mU2hpbmluZXNzIDw9IDAuMClcclxuICAgIHJldHVybiAwLjA7XHJcbiAgdmVjMyB2Y3RSZWZsZWN0aW9uID0gbm9ybWFsaXplKHJlZmxlY3QoLV92Y3RMaWdodCwgX3ZjdE5vcm1hbCkpO1xyXG4gIGZsb2F0IGZTY3BlY3VsYXIgPSBkb3QodmN0UmVmbGVjdGlvbiwgX3ZjdFZpZXcpO1xyXG4gIHJldHVybiBwb3cobWF4KGZTY3BlY3VsYXIsIDAuMCksIF9mU2hpbmluZXNzICogMTAuMCkgKiBfZlNoaW5pbmVzcztcclxuICAvLyByZXR1cm4gbWF4KHNwZWNfZG90LCAwLjApICogc2hpbmluZXNzO1xyXG59XHJcbiAgI2VuZGlmXHJcblxyXG52b2lkIG1haW4oKSB7XHJcbiAgdmVjNCB2Y3RQb3NpdGlvbjtcclxuXHJcbiAgICAjaWYgZGVmaW5lZChGTEFUKVxyXG4gICAgLy8gRkxBVDogdXNlIHRoZSBzcGVjaWFsIHZlcnRleCBhbmQgbm9ybWFsIGJ1ZmZlcnMgZm9yIGZsYXQgc2hhZGluZ1xyXG4gIHZjdFBvc2l0aW9uID0gdmVjNChhX3ZjdFBvc2l0aW9uRmxhdCwgMS4wKTtcclxuICB2ZWMzIHZjdE5vcm1hbCA9IG5vcm1hbGl6ZShtYXQzKHVfbXR4Tm9ybWFsTWVzaFRvV29ybGQpICogYV92Y3ROb3JtYWxGYWNlKTtcclxuICB2X3ZjdENvbG9yID0gdV9hbWJpZW50LnZjdENvbG9yO1xyXG4gICAgI2Vsc2UgXHJcbiAgdmN0UG9zaXRpb24gPSB2ZWM0KGFfdmN0UG9zaXRpb24sIDEuMCk7XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAvLyB1c2UgdGhlIHJlZ3VsYXIgdmVydGV4IGJ1ZmZlclxyXG4gIGdsX1Bvc2l0aW9uID0gdV9tdHhNZXNoVG9WaWV3ICogdmN0UG9zaXRpb247XHJcblxyXG4gICAgLy8gR09VUkFVRDogdXNlIHRoZSB2ZXJ0ZXggbm9ybWFsc1xyXG4gICAgI2lmIGRlZmluZWQoR09VUkFVRClcclxuICB2X3ZjdENvbG9yID0gdV9hbWJpZW50LnZjdENvbG9yO1xyXG4gIHZlYzMgdmN0Tm9ybWFsID0gbm9ybWFsaXplKG1hdDModV9tdHhOb3JtYWxNZXNoVG9Xb3JsZCkgKiBhX3ZjdE5vcm1hbFZlcnRleCk7XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAjaWYgZGVmaW5lZChDQU1FUkEpXHJcbiAgLy8gdmlldyB2ZWN0b3IgbmVlZGVkXHJcbiAgLy8gdmVjNCBwb3NXb3JsZDQgPSB1X210eE1lc2hUb1dvcmxkICogdmN0UG9zaXRpb247XHJcbiAgLy8gdmVjMyB2Y3RWaWV3ID0gbm9ybWFsaXplKHBvc1dvcmxkNC54eXovcG9zV29ybGQ0LncgLSB1X3ZjdENhbWVyYSk7XHJcbiAgdmVjMyB2Y3RWaWV3ID0gbm9ybWFsaXplKHZlYzModV9tdHhNZXNoVG9Xb3JsZCAqIHZjdFBvc2l0aW9uKSAtIHVfdmN0Q2FtZXJhKTtcclxuICAgICNlbmRpZlxyXG5cclxuICAgICNpZiBkZWZpbmVkKExJR0hUKVxyXG4gIC8vIGNhbGN1bGF0ZSB0aGUgZGlyZWN0aW9uYWwgbGlnaHRpbmcgZWZmZWN0XHJcbiAgZm9yKHVpbnQgaSA9IDB1OyBpIDwgdV9uTGlnaHRzRGlyZWN0aW9uYWw7IGkrKykge1xyXG4gICAgZmxvYXQgZklsbHVtaW5hdGlvbiA9IC1kb3QodmN0Tm9ybWFsLCB1X2RpcmVjdGlvbmFsW2ldLnZjdERpcmVjdGlvbik7XHJcbiAgICBpZihmSWxsdW1pbmF0aW9uID4gMC4wZikge1xyXG4gICAgICB2X3ZjdENvbG9yICs9IGZJbGx1bWluYXRpb24gKiB1X2RpcmVjdGlvbmFsW2ldLnZjdENvbG9yO1xyXG4gICAgICAgICNpZiBkZWZpbmVkKENBTUVSQSlcclxuICAgICAgZmxvYXQgZlJlZmxlY3Rpb24gPSBjYWxjdWxhdGVSZWZsZWN0aW9uKHVfZGlyZWN0aW9uYWxbaV0udmN0RGlyZWN0aW9uLCB2Y3RWaWV3LCB2Y3ROb3JtYWwsIHVfZlNoaW5pbmVzcyk7XHJcbiAgICAgIHZfdmN0Q29sb3IgKz0gZlJlZmxlY3Rpb24gKiB1X2RpcmVjdGlvbmFsW2ldLnZjdENvbG9yO1xyXG4gICAgICAgICNlbmRpZlxyXG4gICAgfVxyXG4gIH1cclxuICAgICNlbmRpZlxyXG5cclxuICAgIC8vIFRFWFRVUkU6IHRyYW5zZm9ybSBVVnNcclxuICAgICNpZiBkZWZpbmVkKFRFWFRVUkUpXHJcbiAgdl92Y3RUZXh0dXJlID0gdmVjMih1X210eFBpdm90ICogdmVjMyhhX3ZjdFRleHR1cmUsIDEuMCkpLnh5O1xyXG4gICAgI2VuZGlmXHJcblxyXG4gICAgI2lmIGRlZmluZWQoTUFUQ0FQKVxyXG4gIHZlYzMgdmN0Tm9ybWFsID0gbm9ybWFsaXplKG1hdDModV9tdHhOb3JtYWxNZXNoVG9Xb3JsZCkgKiBhX3ZjdE5vcm1hbFZlcnRleCk7XHJcbiAgdmN0Tm9ybWFsID0gbWF0Myh1X210eFdvcmxkVG9WaWV3KSAqIHZjdE5vcm1hbDtcclxuICB2X3ZjdFRleHR1cmUgPSAwLjUgKiB2Y3ROb3JtYWwueHkgLyBsZW5ndGgodmN0Tm9ybWFsKSArIDAuNTtcclxuICB2X3ZjdFRleHR1cmUueSAqPSAtMS4wO1xyXG4gICAgI2VuZGlmXHJcblxyXG4gICAgLy8gYWx3YXlzIGZ1bGwgb3BhY2l0eSBmb3Igbm93Li4uXHJcbiAgdl92Y3RDb2xvci5hID0gMS4wO1xyXG59XG5gOyB9XG5cbiAgcHVibGljIHN0YXRpYyBnZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpOiBzdHJpbmcgeyBcbnJldHVybiBgI3ZlcnNpb24gMzAwIGVzXG4jZGVmaW5lIExJR0hUXG4jZGVmaW5lIEZMQVRcbiNkZWZpbmUgQ0FNRVJBXG5cclxuLyoqXHJcbiogVW5pdmVyc2FsIFNoYWRlciBhcyBiYXNlIGZvciBtYW55IG90aGVycy4gQ29udHJvbGxlZCBieSBjb21waWxlciBkaXJlY3RpdmVzXHJcbiogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuKi9cclxuXHJcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG5cclxuICAvLyBNSU5JTUFMIChubyBkZWZpbmUgbmVlZGVkKTogaW5jbHVkZSBiYXNlIGNvbG9yXHJcbnVuaWZvcm0gdmVjNCB1X3ZjdENvbG9yO1xyXG5cclxuICAvLyBGTEFUOiBpbnB1dCB2ZXJ0ZXggY29sb3JzIGZsYXQsIHNvIHRoZSB0aGlyZCBvZiBhIHRyaWFuZ2xlIGRldGVybWluZXMgdGhlIGNvbG9yXHJcbiAgI2lmIGRlZmluZWQoRkxBVCkgXHJcbmZsYXQgaW4gdmVjNCB2X3ZjdENvbG9yO1xyXG4gIC8vIExJR0hUOiBpbnB1dCB2ZXJ0ZXggY29sb3JzIGZvciBlYWNoIHZlcnRleCBmb3IgaW50ZXJwb2xhdGlvbiBvdmVyIHRoZSBmYWNlXHJcbiAgI2VsaWYgZGVmaW5lZChMSUdIVClcclxuaW4gdmVjNCB2X3ZjdENvbG9yO1xyXG4gICNlbmRpZlxyXG5cclxuICAvLyBURVhUVVJFOiBpbnB1dCBVVnMgYW5kIHRleHR1cmVcclxuICAjaWYgZGVmaW5lZChURVhUVVJFKSB8fCBkZWZpbmVkKE1BVENBUClcclxuaW4gdmVjMiB2X3ZjdFRleHR1cmU7XHJcbnVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcclxuICAjZW5kaWZcclxuXHJcbm91dCB2ZWM0IHZjdEZyYWc7XHJcblxyXG52b2lkIG1haW4oKSB7XHJcbiAgICAvLyBNSU5JTUFMOiBzZXQgdGhlIGJhc2UgY29sb3JcclxuICB2Y3RGcmFnID0gdV92Y3RDb2xvcjtcclxuXHJcbiAgICAvLyBWRVJURVg6IG11bHRpcGx5IHdpdGggdmVydGV4IGNvbG9yXHJcbiAgICAjaWYgZGVmaW5lZChGTEFUKSB8fCBkZWZpbmVkKExJR0hUKVxyXG4gIHZjdEZyYWcgKj0gdl92Y3RDb2xvcjtcclxuICAgICNlbmRpZlxyXG5cclxuICAgIC8vIFRFWFRVUkU6IG11bHRpcGx5IHdpdGggdGV4ZWwgY29sb3JcclxuICAgICNpZiBkZWZpbmVkKFRFWFRVUkUpIHx8IGRlZmluZWQoTUFUQ0FQKVxyXG4gIHZlYzQgdmN0Q29sb3JUZXh0dXJlID0gdGV4dHVyZSh1X3RleHR1cmUsIHZfdmN0VGV4dHVyZSk7XHJcbiAgdmN0RnJhZyAqPSB2Y3RDb2xvclRleHR1cmU7XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAvLyBkaXNjYXJkIHBpeGVsIGFsbHRvZ2V0aGVyIHdoZW4gdHJhbnNwYXJlbnQ6IGRvbid0IHNob3cgaW4gWi1CdWZmZXJcclxuICBpZih2Y3RGcmFnLmEgPCAwLjAxKVxyXG4gICAgZGlzY2FyZDtcclxufVxuYDsgfVxufVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuLyoqIENvZGUgZ2VuZXJhdGVkIGJ5IENvbXBpbGVTaGFkZXJzLm1qcyB1c2luZyB0aGUgaW5mb3JtYXRpb24gaW4gQ29tcGlsZVNoYWRlcnMuanNvbiAqL1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyRmxhdFRleHR1cmVkIGV4dGVuZHMgU2hhZGVyIHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IFNoYWRlci5yZWdpc3RlclN1YmNsYXNzKFNoYWRlckZsYXRUZXh0dXJlZCk7XG5cbiAgcHVibGljIHN0YXRpYyBnZXRDb2F0KCk6IHR5cGVvZiBDb2F0IHsgcmV0dXJuIENvYXRUZXh0dXJlZDsgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZ2V0VmVydGV4U2hhZGVyU291cmNlKCk6IHN0cmluZyB7IFxucmV0dXJuIGAjdmVyc2lvbiAzMDAgZXNcbiNkZWZpbmUgTElHSFRcbiNkZWZpbmUgRkxBVFxuI2RlZmluZSBURVhUVVJFXG4jZGVmaW5lIENBTUVSQVxuXHJcbi8qKlxyXG4qIFVuaXZlcnNhbCBTaGFkZXIgYXMgYmFzZSBmb3IgbWFueSBvdGhlcnMuIENvbnRyb2xsZWQgYnkgY29tcGlsZXIgZGlyZWN0aXZlc1xyXG4qIEBhdXRob3JzIDIwMjEsIEx1aXMgS2VjaywgSEZVLCAyMDIxIHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuKi9cclxuXHJcbiAgLy8gTUlOSU1BTCAobm8gZGVmaW5lIG5lZWRlZCk6IGJ1ZmZlcnMgZm9yIHRyYW5zZm9ybWF0aW9uXHJcbnVuaWZvcm0gbWF0NCB1X210eE1lc2hUb1ZpZXc7XHJcblxyXG4gIC8vIEZMQVQ6IG9mZmVyIGJ1ZmZlcnMgZm9yIGZhY2Ugbm9ybWFscyBhbmQgdGhlaXIgdHJhbnNmb3JtYXRpb25cclxuICAjaWYgZGVmaW5lZChGTEFUKVxyXG5pbiB2ZWMzIGFfdmN0UG9zaXRpb25GbGF0O1xyXG5pbiB2ZWMzIGFfdmN0Tm9ybWFsRmFjZTtcclxudW5pZm9ybSBtYXQ0IHVfbXR4Tm9ybWFsTWVzaFRvV29ybGQ7XHJcbmZsYXQgb3V0IHZlYzQgdl92Y3RDb2xvcjtcclxuICAjZWxzZVxyXG4gIC8vIHJlZ3VsYXIgaWYgbm90IEZMQVRcclxuaW4gdmVjMyBhX3ZjdFBvc2l0aW9uO1xyXG5vdXQgdmVjNCB2X3ZjdENvbG9yO1xyXG4gICNlbmRpZlxyXG5cclxuICAvLyBMSUdIVDogb2ZmZXIgYnVmZmVycyBmb3IgbGlnaHRpbmcgdmVydGljZXMgd2l0aCBkaWZmZXJlbnQgbGlnaHQgdHlwZXNcclxuICAjaWYgZGVmaW5lZChMSUdIVClcclxuc3RydWN0IExpZ2h0QW1iaWVudCB7XHJcbiAgdmVjNCB2Y3RDb2xvcjtcclxufTtcclxuc3RydWN0IExpZ2h0RGlyZWN0aW9uYWwge1xyXG4gIHZlYzQgdmN0Q29sb3I7XHJcbiAgdmVjMyB2Y3REaXJlY3Rpb247XHJcbn07XHJcblxyXG5jb25zdCB1aW50IE1BWF9MSUdIVFNfRElSRUNUSU9OQUwgPSAxMDB1O1xyXG5cclxudW5pZm9ybSBMaWdodEFtYmllbnQgdV9hbWJpZW50O1xyXG51bmlmb3JtIHVpbnQgdV9uTGlnaHRzRGlyZWN0aW9uYWw7XHJcbnVuaWZvcm0gTGlnaHREaXJlY3Rpb25hbCB1X2RpcmVjdGlvbmFsW01BWF9MSUdIVFNfRElSRUNUSU9OQUxdO1xyXG4gICNlbmRpZiBcclxuXHJcbiAgLy8gVEVYVFVSRTogb2ZmZXIgYnVmZmVycyBmb3IgVVZzIGFuZCBwaXZvdCBtYXRyaXhcclxuICAjaWYgZGVmaW5lZChURVhUVVJFKVxyXG51bmlmb3JtIG1hdDMgdV9tdHhQaXZvdDtcclxuaW4gdmVjMiBhX3ZjdFRleHR1cmU7XHJcbm91dCB2ZWMyIHZfdmN0VGV4dHVyZTtcclxuICAjZW5kaWZcclxuXHJcbiAgI2lmIGRlZmluZWQoTUFUQ0FQKSAvLyBNYXRDYXAtc2hhZGVyIGdlbmVyYXRlcyB0ZXh0dXJlIGNvb3JkaW5hdGVzIGZyb20gc3VyZmFjZSBub3JtYWxzXHJcbm91dCB2ZWMyIHZfdmN0VGV4dHVyZTtcclxuICAjZW5kaWZcclxuXHJcbiAgLy8gR09VUkFVRDogb2ZmZXIgYnVmZmVycyBmb3IgdmVydGV4IG5vcm1hbHMsIHRoZWlyIHRyYW5zZm9ybWF0aW9uIGFuZCB0aGUgc2hpbmluZXNzXHJcbiAgI2lmIGRlZmluZWQoR09VUkFVRCl8fGRlZmluZWQoTUFUQ0FQKVxyXG5pbiB2ZWMzIGFfdmN0Tm9ybWFsVmVydGV4O1xyXG51bmlmb3JtIG1hdDQgdV9tdHhOb3JtYWxNZXNoVG9Xb3JsZDtcclxuICAjZW5kaWZcclxuXHJcbiAgLy8gQ0FNRVJBOiBvZmZlciBidWZmZXIgYW5kIGZ1bmN0aW9uYWxpdHkgZm9yIHNwZWN1bGFyIHJlZmxlY3Rpb24gZGVwZW5kaW5nIG9uIHRoZSBjYW1lcmEtcG9zaXRpb25cclxuICAjaWYgZGVmaW5lZChDQU1FUkEpXHJcbnVuaWZvcm0gZmxvYXQgdV9mU2hpbmluZXNzO1xyXG51bmlmb3JtIG1hdDQgdV9tdHhNZXNoVG9Xb3JsZDtcclxudW5pZm9ybSBtYXQ0IHVfbXR4V29ybGRUb1ZpZXc7XHJcbnVuaWZvcm0gdmVjMyB1X3ZjdENhbWVyYTtcclxuXHJcbmZsb2F0IGNhbGN1bGF0ZVJlZmxlY3Rpb24odmVjMyBfdmN0TGlnaHQsIHZlYzMgX3ZjdFZpZXcsIHZlYzMgX3ZjdE5vcm1hbCwgZmxvYXQgX2ZTaGluaW5lc3MpIHtcclxuICBpZihfZlNoaW5pbmVzcyA8PSAwLjApXHJcbiAgICByZXR1cm4gMC4wO1xyXG4gIHZlYzMgdmN0UmVmbGVjdGlvbiA9IG5vcm1hbGl6ZShyZWZsZWN0KC1fdmN0TGlnaHQsIF92Y3ROb3JtYWwpKTtcclxuICBmbG9hdCBmU2NwZWN1bGFyID0gZG90KHZjdFJlZmxlY3Rpb24sIF92Y3RWaWV3KTtcclxuICByZXR1cm4gcG93KG1heChmU2NwZWN1bGFyLCAwLjApLCBfZlNoaW5pbmVzcyAqIDEwLjApICogX2ZTaGluaW5lc3M7XHJcbiAgLy8gcmV0dXJuIG1heChzcGVjX2RvdCwgMC4wKSAqIHNoaW5pbmVzcztcclxufVxyXG4gICNlbmRpZlxyXG5cclxudm9pZCBtYWluKCkge1xyXG4gIHZlYzQgdmN0UG9zaXRpb247XHJcblxyXG4gICAgI2lmIGRlZmluZWQoRkxBVClcclxuICAgIC8vIEZMQVQ6IHVzZSB0aGUgc3BlY2lhbCB2ZXJ0ZXggYW5kIG5vcm1hbCBidWZmZXJzIGZvciBmbGF0IHNoYWRpbmdcclxuICB2Y3RQb3NpdGlvbiA9IHZlYzQoYV92Y3RQb3NpdGlvbkZsYXQsIDEuMCk7XHJcbiAgdmVjMyB2Y3ROb3JtYWwgPSBub3JtYWxpemUobWF0Myh1X210eE5vcm1hbE1lc2hUb1dvcmxkKSAqIGFfdmN0Tm9ybWFsRmFjZSk7XHJcbiAgdl92Y3RDb2xvciA9IHVfYW1iaWVudC52Y3RDb2xvcjtcclxuICAgICNlbHNlIFxyXG4gIHZjdFBvc2l0aW9uID0gdmVjNChhX3ZjdFBvc2l0aW9uLCAxLjApO1xyXG4gICAgI2VuZGlmXHJcblxyXG4gICAgLy8gdXNlIHRoZSByZWd1bGFyIHZlcnRleCBidWZmZXJcclxuICBnbF9Qb3NpdGlvbiA9IHVfbXR4TWVzaFRvVmlldyAqIHZjdFBvc2l0aW9uO1xyXG5cclxuICAgIC8vIEdPVVJBVUQ6IHVzZSB0aGUgdmVydGV4IG5vcm1hbHNcclxuICAgICNpZiBkZWZpbmVkKEdPVVJBVUQpXHJcbiAgdl92Y3RDb2xvciA9IHVfYW1iaWVudC52Y3RDb2xvcjtcclxuICB2ZWMzIHZjdE5vcm1hbCA9IG5vcm1hbGl6ZShtYXQzKHVfbXR4Tm9ybWFsTWVzaFRvV29ybGQpICogYV92Y3ROb3JtYWxWZXJ0ZXgpO1xyXG4gICAgI2VuZGlmXHJcblxyXG4gICAgI2lmIGRlZmluZWQoQ0FNRVJBKVxyXG4gIC8vIHZpZXcgdmVjdG9yIG5lZWRlZFxyXG4gIC8vIHZlYzQgcG9zV29ybGQ0ID0gdV9tdHhNZXNoVG9Xb3JsZCAqIHZjdFBvc2l0aW9uO1xyXG4gIC8vIHZlYzMgdmN0VmlldyA9IG5vcm1hbGl6ZShwb3NXb3JsZDQueHl6L3Bvc1dvcmxkNC53IC0gdV92Y3RDYW1lcmEpO1xyXG4gIHZlYzMgdmN0VmlldyA9IG5vcm1hbGl6ZSh2ZWMzKHVfbXR4TWVzaFRvV29ybGQgKiB2Y3RQb3NpdGlvbikgLSB1X3ZjdENhbWVyYSk7XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAjaWYgZGVmaW5lZChMSUdIVClcclxuICAvLyBjYWxjdWxhdGUgdGhlIGRpcmVjdGlvbmFsIGxpZ2h0aW5nIGVmZmVjdFxyXG4gIGZvcih1aW50IGkgPSAwdTsgaSA8IHVfbkxpZ2h0c0RpcmVjdGlvbmFsOyBpKyspIHtcclxuICAgIGZsb2F0IGZJbGx1bWluYXRpb24gPSAtZG90KHZjdE5vcm1hbCwgdV9kaXJlY3Rpb25hbFtpXS52Y3REaXJlY3Rpb24pO1xyXG4gICAgaWYoZklsbHVtaW5hdGlvbiA+IDAuMGYpIHtcclxuICAgICAgdl92Y3RDb2xvciArPSBmSWxsdW1pbmF0aW9uICogdV9kaXJlY3Rpb25hbFtpXS52Y3RDb2xvcjtcclxuICAgICAgICAjaWYgZGVmaW5lZChDQU1FUkEpXHJcbiAgICAgIGZsb2F0IGZSZWZsZWN0aW9uID0gY2FsY3VsYXRlUmVmbGVjdGlvbih1X2RpcmVjdGlvbmFsW2ldLnZjdERpcmVjdGlvbiwgdmN0VmlldywgdmN0Tm9ybWFsLCB1X2ZTaGluaW5lc3MpO1xyXG4gICAgICB2X3ZjdENvbG9yICs9IGZSZWZsZWN0aW9uICogdV9kaXJlY3Rpb25hbFtpXS52Y3RDb2xvcjtcclxuICAgICAgICAjZW5kaWZcclxuICAgIH1cclxuICB9XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAvLyBURVhUVVJFOiB0cmFuc2Zvcm0gVVZzXHJcbiAgICAjaWYgZGVmaW5lZChURVhUVVJFKVxyXG4gIHZfdmN0VGV4dHVyZSA9IHZlYzIodV9tdHhQaXZvdCAqIHZlYzMoYV92Y3RUZXh0dXJlLCAxLjApKS54eTtcclxuICAgICNlbmRpZlxyXG5cclxuICAgICNpZiBkZWZpbmVkKE1BVENBUClcclxuICB2ZWMzIHZjdE5vcm1hbCA9IG5vcm1hbGl6ZShtYXQzKHVfbXR4Tm9ybWFsTWVzaFRvV29ybGQpICogYV92Y3ROb3JtYWxWZXJ0ZXgpO1xyXG4gIHZjdE5vcm1hbCA9IG1hdDModV9tdHhXb3JsZFRvVmlldykgKiB2Y3ROb3JtYWw7XHJcbiAgdl92Y3RUZXh0dXJlID0gMC41ICogdmN0Tm9ybWFsLnh5IC8gbGVuZ3RoKHZjdE5vcm1hbCkgKyAwLjU7XHJcbiAgdl92Y3RUZXh0dXJlLnkgKj0gLTEuMDtcclxuICAgICNlbmRpZlxyXG5cclxuICAgIC8vIGFsd2F5cyBmdWxsIG9wYWNpdHkgZm9yIG5vdy4uLlxyXG4gIHZfdmN0Q29sb3IuYSA9IDEuMDtcclxufVxuYDsgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHsgXG5yZXR1cm4gYCN2ZXJzaW9uIDMwMCBlc1xuI2RlZmluZSBMSUdIVFxuI2RlZmluZSBGTEFUXG4jZGVmaW5lIFRFWFRVUkVcbiNkZWZpbmUgQ0FNRVJBXG5cclxuLyoqXHJcbiogVW5pdmVyc2FsIFNoYWRlciBhcyBiYXNlIGZvciBtYW55IG90aGVycy4gQ29udHJvbGxlZCBieSBjb21waWxlciBkaXJlY3RpdmVzXHJcbiogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuKi9cclxuXHJcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG5cclxuICAvLyBNSU5JTUFMIChubyBkZWZpbmUgbmVlZGVkKTogaW5jbHVkZSBiYXNlIGNvbG9yXHJcbnVuaWZvcm0gdmVjNCB1X3ZjdENvbG9yO1xyXG5cclxuICAvLyBGTEFUOiBpbnB1dCB2ZXJ0ZXggY29sb3JzIGZsYXQsIHNvIHRoZSB0aGlyZCBvZiBhIHRyaWFuZ2xlIGRldGVybWluZXMgdGhlIGNvbG9yXHJcbiAgI2lmIGRlZmluZWQoRkxBVCkgXHJcbmZsYXQgaW4gdmVjNCB2X3ZjdENvbG9yO1xyXG4gIC8vIExJR0hUOiBpbnB1dCB2ZXJ0ZXggY29sb3JzIGZvciBlYWNoIHZlcnRleCBmb3IgaW50ZXJwb2xhdGlvbiBvdmVyIHRoZSBmYWNlXHJcbiAgI2VsaWYgZGVmaW5lZChMSUdIVClcclxuaW4gdmVjNCB2X3ZjdENvbG9yO1xyXG4gICNlbmRpZlxyXG5cclxuICAvLyBURVhUVVJFOiBpbnB1dCBVVnMgYW5kIHRleHR1cmVcclxuICAjaWYgZGVmaW5lZChURVhUVVJFKSB8fCBkZWZpbmVkKE1BVENBUClcclxuaW4gdmVjMiB2X3ZjdFRleHR1cmU7XHJcbnVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcclxuICAjZW5kaWZcclxuXHJcbm91dCB2ZWM0IHZjdEZyYWc7XHJcblxyXG52b2lkIG1haW4oKSB7XHJcbiAgICAvLyBNSU5JTUFMOiBzZXQgdGhlIGJhc2UgY29sb3JcclxuICB2Y3RGcmFnID0gdV92Y3RDb2xvcjtcclxuXHJcbiAgICAvLyBWRVJURVg6IG11bHRpcGx5IHdpdGggdmVydGV4IGNvbG9yXHJcbiAgICAjaWYgZGVmaW5lZChGTEFUKSB8fCBkZWZpbmVkKExJR0hUKVxyXG4gIHZjdEZyYWcgKj0gdl92Y3RDb2xvcjtcclxuICAgICNlbmRpZlxyXG5cclxuICAgIC8vIFRFWFRVUkU6IG11bHRpcGx5IHdpdGggdGV4ZWwgY29sb3JcclxuICAgICNpZiBkZWZpbmVkKFRFWFRVUkUpIHx8IGRlZmluZWQoTUFUQ0FQKVxyXG4gIHZlYzQgdmN0Q29sb3JUZXh0dXJlID0gdGV4dHVyZSh1X3RleHR1cmUsIHZfdmN0VGV4dHVyZSk7XHJcbiAgdmN0RnJhZyAqPSB2Y3RDb2xvclRleHR1cmU7XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAvLyBkaXNjYXJkIHBpeGVsIGFsbHRvZ2V0aGVyIHdoZW4gdHJhbnNwYXJlbnQ6IGRvbid0IHNob3cgaW4gWi1CdWZmZXJcclxuICBpZih2Y3RGcmFnLmEgPCAwLjAxKVxyXG4gICAgZGlzY2FyZDtcclxufVxuYDsgfVxufVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuLyoqIENvZGUgZ2VuZXJhdGVkIGJ5IENvbXBpbGVTaGFkZXJzLm1qcyB1c2luZyB0aGUgaW5mb3JtYXRpb24gaW4gQ29tcGlsZVNoYWRlcnMuanNvbiAqL1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyR291cmF1ZCBleHRlbmRzIFNoYWRlciB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBTaGFkZXIucmVnaXN0ZXJTdWJjbGFzcyhTaGFkZXJHb3VyYXVkKTtcblxuICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQgeyByZXR1cm4gQ29hdENvbG9yZWQ7IH1cblxuICBwdWJsaWMgc3RhdGljIGdldFZlcnRleFNoYWRlclNvdXJjZSgpOiBzdHJpbmcgeyBcbnJldHVybiBgI3ZlcnNpb24gMzAwIGVzXG4jZGVmaW5lIExJR0hUXG4jZGVmaW5lIEdPVVJBVURcbiNkZWZpbmUgQ0FNRVJBXG5cclxuLyoqXHJcbiogVW5pdmVyc2FsIFNoYWRlciBhcyBiYXNlIGZvciBtYW55IG90aGVycy4gQ29udHJvbGxlZCBieSBjb21waWxlciBkaXJlY3RpdmVzXHJcbiogQGF1dGhvcnMgMjAyMSwgTHVpcyBLZWNrLCBIRlUsIDIwMjEgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxyXG4qL1xyXG5cclxuICAvLyBNSU5JTUFMIChubyBkZWZpbmUgbmVlZGVkKTogYnVmZmVycyBmb3IgdHJhbnNmb3JtYXRpb25cclxudW5pZm9ybSBtYXQ0IHVfbXR4TWVzaFRvVmlldztcclxuXHJcbiAgLy8gRkxBVDogb2ZmZXIgYnVmZmVycyBmb3IgZmFjZSBub3JtYWxzIGFuZCB0aGVpciB0cmFuc2Zvcm1hdGlvblxyXG4gICNpZiBkZWZpbmVkKEZMQVQpXHJcbmluIHZlYzMgYV92Y3RQb3NpdGlvbkZsYXQ7XHJcbmluIHZlYzMgYV92Y3ROb3JtYWxGYWNlO1xyXG51bmlmb3JtIG1hdDQgdV9tdHhOb3JtYWxNZXNoVG9Xb3JsZDtcclxuZmxhdCBvdXQgdmVjNCB2X3ZjdENvbG9yO1xyXG4gICNlbHNlXHJcbiAgLy8gcmVndWxhciBpZiBub3QgRkxBVFxyXG5pbiB2ZWMzIGFfdmN0UG9zaXRpb247XHJcbm91dCB2ZWM0IHZfdmN0Q29sb3I7XHJcbiAgI2VuZGlmXHJcblxyXG4gIC8vIExJR0hUOiBvZmZlciBidWZmZXJzIGZvciBsaWdodGluZyB2ZXJ0aWNlcyB3aXRoIGRpZmZlcmVudCBsaWdodCB0eXBlc1xyXG4gICNpZiBkZWZpbmVkKExJR0hUKVxyXG5zdHJ1Y3QgTGlnaHRBbWJpZW50IHtcclxuICB2ZWM0IHZjdENvbG9yO1xyXG59O1xyXG5zdHJ1Y3QgTGlnaHREaXJlY3Rpb25hbCB7XHJcbiAgdmVjNCB2Y3RDb2xvcjtcclxuICB2ZWMzIHZjdERpcmVjdGlvbjtcclxufTtcclxuXHJcbmNvbnN0IHVpbnQgTUFYX0xJR0hUU19ESVJFQ1RJT05BTCA9IDEwMHU7XHJcblxyXG51bmlmb3JtIExpZ2h0QW1iaWVudCB1X2FtYmllbnQ7XHJcbnVuaWZvcm0gdWludCB1X25MaWdodHNEaXJlY3Rpb25hbDtcclxudW5pZm9ybSBMaWdodERpcmVjdGlvbmFsIHVfZGlyZWN0aW9uYWxbTUFYX0xJR0hUU19ESVJFQ1RJT05BTF07XHJcbiAgI2VuZGlmIFxyXG5cclxuICAvLyBURVhUVVJFOiBvZmZlciBidWZmZXJzIGZvciBVVnMgYW5kIHBpdm90IG1hdHJpeFxyXG4gICNpZiBkZWZpbmVkKFRFWFRVUkUpXHJcbnVuaWZvcm0gbWF0MyB1X210eFBpdm90O1xyXG5pbiB2ZWMyIGFfdmN0VGV4dHVyZTtcclxub3V0IHZlYzIgdl92Y3RUZXh0dXJlO1xyXG4gICNlbmRpZlxyXG5cclxuICAjaWYgZGVmaW5lZChNQVRDQVApIC8vIE1hdENhcC1zaGFkZXIgZ2VuZXJhdGVzIHRleHR1cmUgY29vcmRpbmF0ZXMgZnJvbSBzdXJmYWNlIG5vcm1hbHNcclxub3V0IHZlYzIgdl92Y3RUZXh0dXJlO1xyXG4gICNlbmRpZlxyXG5cclxuICAvLyBHT1VSQVVEOiBvZmZlciBidWZmZXJzIGZvciB2ZXJ0ZXggbm9ybWFscywgdGhlaXIgdHJhbnNmb3JtYXRpb24gYW5kIHRoZSBzaGluaW5lc3NcclxuICAjaWYgZGVmaW5lZChHT1VSQVVEKXx8ZGVmaW5lZChNQVRDQVApXHJcbmluIHZlYzMgYV92Y3ROb3JtYWxWZXJ0ZXg7XHJcbnVuaWZvcm0gbWF0NCB1X210eE5vcm1hbE1lc2hUb1dvcmxkO1xyXG4gICNlbmRpZlxyXG5cclxuICAvLyBDQU1FUkE6IG9mZmVyIGJ1ZmZlciBhbmQgZnVuY3Rpb25hbGl0eSBmb3Igc3BlY3VsYXIgcmVmbGVjdGlvbiBkZXBlbmRpbmcgb24gdGhlIGNhbWVyYS1wb3NpdGlvblxyXG4gICNpZiBkZWZpbmVkKENBTUVSQSlcclxudW5pZm9ybSBmbG9hdCB1X2ZTaGluaW5lc3M7XHJcbnVuaWZvcm0gbWF0NCB1X210eE1lc2hUb1dvcmxkO1xyXG51bmlmb3JtIG1hdDQgdV9tdHhXb3JsZFRvVmlldztcclxudW5pZm9ybSB2ZWMzIHVfdmN0Q2FtZXJhO1xyXG5cclxuZmxvYXQgY2FsY3VsYXRlUmVmbGVjdGlvbih2ZWMzIF92Y3RMaWdodCwgdmVjMyBfdmN0VmlldywgdmVjMyBfdmN0Tm9ybWFsLCBmbG9hdCBfZlNoaW5pbmVzcykge1xyXG4gIGlmKF9mU2hpbmluZXNzIDw9IDAuMClcclxuICAgIHJldHVybiAwLjA7XHJcbiAgdmVjMyB2Y3RSZWZsZWN0aW9uID0gbm9ybWFsaXplKHJlZmxlY3QoLV92Y3RMaWdodCwgX3ZjdE5vcm1hbCkpO1xyXG4gIGZsb2F0IGZTY3BlY3VsYXIgPSBkb3QodmN0UmVmbGVjdGlvbiwgX3ZjdFZpZXcpO1xyXG4gIHJldHVybiBwb3cobWF4KGZTY3BlY3VsYXIsIDAuMCksIF9mU2hpbmluZXNzICogMTAuMCkgKiBfZlNoaW5pbmVzcztcclxuICAvLyByZXR1cm4gbWF4KHNwZWNfZG90LCAwLjApICogc2hpbmluZXNzO1xyXG59XHJcbiAgI2VuZGlmXHJcblxyXG52b2lkIG1haW4oKSB7XHJcbiAgdmVjNCB2Y3RQb3NpdGlvbjtcclxuXHJcbiAgICAjaWYgZGVmaW5lZChGTEFUKVxyXG4gICAgLy8gRkxBVDogdXNlIHRoZSBzcGVjaWFsIHZlcnRleCBhbmQgbm9ybWFsIGJ1ZmZlcnMgZm9yIGZsYXQgc2hhZGluZ1xyXG4gIHZjdFBvc2l0aW9uID0gdmVjNChhX3ZjdFBvc2l0aW9uRmxhdCwgMS4wKTtcclxuICB2ZWMzIHZjdE5vcm1hbCA9IG5vcm1hbGl6ZShtYXQzKHVfbXR4Tm9ybWFsTWVzaFRvV29ybGQpICogYV92Y3ROb3JtYWxGYWNlKTtcclxuICB2X3ZjdENvbG9yID0gdV9hbWJpZW50LnZjdENvbG9yO1xyXG4gICAgI2Vsc2UgXHJcbiAgdmN0UG9zaXRpb24gPSB2ZWM0KGFfdmN0UG9zaXRpb24sIDEuMCk7XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAvLyB1c2UgdGhlIHJlZ3VsYXIgdmVydGV4IGJ1ZmZlclxyXG4gIGdsX1Bvc2l0aW9uID0gdV9tdHhNZXNoVG9WaWV3ICogdmN0UG9zaXRpb247XHJcblxyXG4gICAgLy8gR09VUkFVRDogdXNlIHRoZSB2ZXJ0ZXggbm9ybWFsc1xyXG4gICAgI2lmIGRlZmluZWQoR09VUkFVRClcclxuICB2X3ZjdENvbG9yID0gdV9hbWJpZW50LnZjdENvbG9yO1xyXG4gIHZlYzMgdmN0Tm9ybWFsID0gbm9ybWFsaXplKG1hdDModV9tdHhOb3JtYWxNZXNoVG9Xb3JsZCkgKiBhX3ZjdE5vcm1hbFZlcnRleCk7XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAjaWYgZGVmaW5lZChDQU1FUkEpXHJcbiAgLy8gdmlldyB2ZWN0b3IgbmVlZGVkXHJcbiAgLy8gdmVjNCBwb3NXb3JsZDQgPSB1X210eE1lc2hUb1dvcmxkICogdmN0UG9zaXRpb247XHJcbiAgLy8gdmVjMyB2Y3RWaWV3ID0gbm9ybWFsaXplKHBvc1dvcmxkNC54eXovcG9zV29ybGQ0LncgLSB1X3ZjdENhbWVyYSk7XHJcbiAgdmVjMyB2Y3RWaWV3ID0gbm9ybWFsaXplKHZlYzModV9tdHhNZXNoVG9Xb3JsZCAqIHZjdFBvc2l0aW9uKSAtIHVfdmN0Q2FtZXJhKTtcclxuICAgICNlbmRpZlxyXG5cclxuICAgICNpZiBkZWZpbmVkKExJR0hUKVxyXG4gIC8vIGNhbGN1bGF0ZSB0aGUgZGlyZWN0aW9uYWwgbGlnaHRpbmcgZWZmZWN0XHJcbiAgZm9yKHVpbnQgaSA9IDB1OyBpIDwgdV9uTGlnaHRzRGlyZWN0aW9uYWw7IGkrKykge1xyXG4gICAgZmxvYXQgZklsbHVtaW5hdGlvbiA9IC1kb3QodmN0Tm9ybWFsLCB1X2RpcmVjdGlvbmFsW2ldLnZjdERpcmVjdGlvbik7XHJcbiAgICBpZihmSWxsdW1pbmF0aW9uID4gMC4wZikge1xyXG4gICAgICB2X3ZjdENvbG9yICs9IGZJbGx1bWluYXRpb24gKiB1X2RpcmVjdGlvbmFsW2ldLnZjdENvbG9yO1xyXG4gICAgICAgICNpZiBkZWZpbmVkKENBTUVSQSlcclxuICAgICAgZmxvYXQgZlJlZmxlY3Rpb24gPSBjYWxjdWxhdGVSZWZsZWN0aW9uKHVfZGlyZWN0aW9uYWxbaV0udmN0RGlyZWN0aW9uLCB2Y3RWaWV3LCB2Y3ROb3JtYWwsIHVfZlNoaW5pbmVzcyk7XHJcbiAgICAgIHZfdmN0Q29sb3IgKz0gZlJlZmxlY3Rpb24gKiB1X2RpcmVjdGlvbmFsW2ldLnZjdENvbG9yO1xyXG4gICAgICAgICNlbmRpZlxyXG4gICAgfVxyXG4gIH1cclxuICAgICNlbmRpZlxyXG5cclxuICAgIC8vIFRFWFRVUkU6IHRyYW5zZm9ybSBVVnNcclxuICAgICNpZiBkZWZpbmVkKFRFWFRVUkUpXHJcbiAgdl92Y3RUZXh0dXJlID0gdmVjMih1X210eFBpdm90ICogdmVjMyhhX3ZjdFRleHR1cmUsIDEuMCkpLnh5O1xyXG4gICAgI2VuZGlmXHJcblxyXG4gICAgI2lmIGRlZmluZWQoTUFUQ0FQKVxyXG4gIHZlYzMgdmN0Tm9ybWFsID0gbm9ybWFsaXplKG1hdDModV9tdHhOb3JtYWxNZXNoVG9Xb3JsZCkgKiBhX3ZjdE5vcm1hbFZlcnRleCk7XHJcbiAgdmN0Tm9ybWFsID0gbWF0Myh1X210eFdvcmxkVG9WaWV3KSAqIHZjdE5vcm1hbDtcclxuICB2X3ZjdFRleHR1cmUgPSAwLjUgKiB2Y3ROb3JtYWwueHkgLyBsZW5ndGgodmN0Tm9ybWFsKSArIDAuNTtcclxuICB2X3ZjdFRleHR1cmUueSAqPSAtMS4wO1xyXG4gICAgI2VuZGlmXHJcblxyXG4gICAgLy8gYWx3YXlzIGZ1bGwgb3BhY2l0eSBmb3Igbm93Li4uXHJcbiAgdl92Y3RDb2xvci5hID0gMS4wO1xyXG59XG5gOyB9XG5cbiAgcHVibGljIHN0YXRpYyBnZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpOiBzdHJpbmcgeyBcbnJldHVybiBgI3ZlcnNpb24gMzAwIGVzXG4jZGVmaW5lIExJR0hUXG4jZGVmaW5lIEdPVVJBVURcbiNkZWZpbmUgQ0FNRVJBXG5cclxuLyoqXHJcbiogVW5pdmVyc2FsIFNoYWRlciBhcyBiYXNlIGZvciBtYW55IG90aGVycy4gQ29udHJvbGxlZCBieSBjb21waWxlciBkaXJlY3RpdmVzXHJcbiogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuKi9cclxuXHJcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG5cclxuICAvLyBNSU5JTUFMIChubyBkZWZpbmUgbmVlZGVkKTogaW5jbHVkZSBiYXNlIGNvbG9yXHJcbnVuaWZvcm0gdmVjNCB1X3ZjdENvbG9yO1xyXG5cclxuICAvLyBGTEFUOiBpbnB1dCB2ZXJ0ZXggY29sb3JzIGZsYXQsIHNvIHRoZSB0aGlyZCBvZiBhIHRyaWFuZ2xlIGRldGVybWluZXMgdGhlIGNvbG9yXHJcbiAgI2lmIGRlZmluZWQoRkxBVCkgXHJcbmZsYXQgaW4gdmVjNCB2X3ZjdENvbG9yO1xyXG4gIC8vIExJR0hUOiBpbnB1dCB2ZXJ0ZXggY29sb3JzIGZvciBlYWNoIHZlcnRleCBmb3IgaW50ZXJwb2xhdGlvbiBvdmVyIHRoZSBmYWNlXHJcbiAgI2VsaWYgZGVmaW5lZChMSUdIVClcclxuaW4gdmVjNCB2X3ZjdENvbG9yO1xyXG4gICNlbmRpZlxyXG5cclxuICAvLyBURVhUVVJFOiBpbnB1dCBVVnMgYW5kIHRleHR1cmVcclxuICAjaWYgZGVmaW5lZChURVhUVVJFKSB8fCBkZWZpbmVkKE1BVENBUClcclxuaW4gdmVjMiB2X3ZjdFRleHR1cmU7XHJcbnVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcclxuICAjZW5kaWZcclxuXHJcbm91dCB2ZWM0IHZjdEZyYWc7XHJcblxyXG52b2lkIG1haW4oKSB7XHJcbiAgICAvLyBNSU5JTUFMOiBzZXQgdGhlIGJhc2UgY29sb3JcclxuICB2Y3RGcmFnID0gdV92Y3RDb2xvcjtcclxuXHJcbiAgICAvLyBWRVJURVg6IG11bHRpcGx5IHdpdGggdmVydGV4IGNvbG9yXHJcbiAgICAjaWYgZGVmaW5lZChGTEFUKSB8fCBkZWZpbmVkKExJR0hUKVxyXG4gIHZjdEZyYWcgKj0gdl92Y3RDb2xvcjtcclxuICAgICNlbmRpZlxyXG5cclxuICAgIC8vIFRFWFRVUkU6IG11bHRpcGx5IHdpdGggdGV4ZWwgY29sb3JcclxuICAgICNpZiBkZWZpbmVkKFRFWFRVUkUpIHx8IGRlZmluZWQoTUFUQ0FQKVxyXG4gIHZlYzQgdmN0Q29sb3JUZXh0dXJlID0gdGV4dHVyZSh1X3RleHR1cmUsIHZfdmN0VGV4dHVyZSk7XHJcbiAgdmN0RnJhZyAqPSB2Y3RDb2xvclRleHR1cmU7XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAvLyBkaXNjYXJkIHBpeGVsIGFsbHRvZ2V0aGVyIHdoZW4gdHJhbnNwYXJlbnQ6IGRvbid0IHNob3cgaW4gWi1CdWZmZXJcclxuICBpZih2Y3RGcmFnLmEgPCAwLjAxKVxyXG4gICAgZGlzY2FyZDtcclxufVxuYDsgfVxufVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuLyoqIENvZGUgZ2VuZXJhdGVkIGJ5IENvbXBpbGVTaGFkZXJzLm1qcyB1c2luZyB0aGUgaW5mb3JtYXRpb24gaW4gQ29tcGlsZVNoYWRlcnMuanNvbiAqL1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyR291cmF1ZFRleHR1cmVkIGV4dGVuZHMgU2hhZGVyIHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IFNoYWRlci5yZWdpc3RlclN1YmNsYXNzKFNoYWRlckdvdXJhdWRUZXh0dXJlZCk7XG5cbiAgcHVibGljIHN0YXRpYyBnZXRDb2F0KCk6IHR5cGVvZiBDb2F0IHsgcmV0dXJuIENvYXRUZXh0dXJlZDsgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZ2V0VmVydGV4U2hhZGVyU291cmNlKCk6IHN0cmluZyB7IFxucmV0dXJuIGAjdmVyc2lvbiAzMDAgZXNcbiNkZWZpbmUgTElHSFRcbiNkZWZpbmUgR09VUkFVRFxuI2RlZmluZSBURVhUVVJFXG4jZGVmaW5lIENBTUVSQVxuXHJcbi8qKlxyXG4qIFVuaXZlcnNhbCBTaGFkZXIgYXMgYmFzZSBmb3IgbWFueSBvdGhlcnMuIENvbnRyb2xsZWQgYnkgY29tcGlsZXIgZGlyZWN0aXZlc1xyXG4qIEBhdXRob3JzIDIwMjEsIEx1aXMgS2VjaywgSEZVLCAyMDIxIHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuKi9cclxuXHJcbiAgLy8gTUlOSU1BTCAobm8gZGVmaW5lIG5lZWRlZCk6IGJ1ZmZlcnMgZm9yIHRyYW5zZm9ybWF0aW9uXHJcbnVuaWZvcm0gbWF0NCB1X210eE1lc2hUb1ZpZXc7XHJcblxyXG4gIC8vIEZMQVQ6IG9mZmVyIGJ1ZmZlcnMgZm9yIGZhY2Ugbm9ybWFscyBhbmQgdGhlaXIgdHJhbnNmb3JtYXRpb25cclxuICAjaWYgZGVmaW5lZChGTEFUKVxyXG5pbiB2ZWMzIGFfdmN0UG9zaXRpb25GbGF0O1xyXG5pbiB2ZWMzIGFfdmN0Tm9ybWFsRmFjZTtcclxudW5pZm9ybSBtYXQ0IHVfbXR4Tm9ybWFsTWVzaFRvV29ybGQ7XHJcbmZsYXQgb3V0IHZlYzQgdl92Y3RDb2xvcjtcclxuICAjZWxzZVxyXG4gIC8vIHJlZ3VsYXIgaWYgbm90IEZMQVRcclxuaW4gdmVjMyBhX3ZjdFBvc2l0aW9uO1xyXG5vdXQgdmVjNCB2X3ZjdENvbG9yO1xyXG4gICNlbmRpZlxyXG5cclxuICAvLyBMSUdIVDogb2ZmZXIgYnVmZmVycyBmb3IgbGlnaHRpbmcgdmVydGljZXMgd2l0aCBkaWZmZXJlbnQgbGlnaHQgdHlwZXNcclxuICAjaWYgZGVmaW5lZChMSUdIVClcclxuc3RydWN0IExpZ2h0QW1iaWVudCB7XHJcbiAgdmVjNCB2Y3RDb2xvcjtcclxufTtcclxuc3RydWN0IExpZ2h0RGlyZWN0aW9uYWwge1xyXG4gIHZlYzQgdmN0Q29sb3I7XHJcbiAgdmVjMyB2Y3REaXJlY3Rpb247XHJcbn07XHJcblxyXG5jb25zdCB1aW50IE1BWF9MSUdIVFNfRElSRUNUSU9OQUwgPSAxMDB1O1xyXG5cclxudW5pZm9ybSBMaWdodEFtYmllbnQgdV9hbWJpZW50O1xyXG51bmlmb3JtIHVpbnQgdV9uTGlnaHRzRGlyZWN0aW9uYWw7XHJcbnVuaWZvcm0gTGlnaHREaXJlY3Rpb25hbCB1X2RpcmVjdGlvbmFsW01BWF9MSUdIVFNfRElSRUNUSU9OQUxdO1xyXG4gICNlbmRpZiBcclxuXHJcbiAgLy8gVEVYVFVSRTogb2ZmZXIgYnVmZmVycyBmb3IgVVZzIGFuZCBwaXZvdCBtYXRyaXhcclxuICAjaWYgZGVmaW5lZChURVhUVVJFKVxyXG51bmlmb3JtIG1hdDMgdV9tdHhQaXZvdDtcclxuaW4gdmVjMiBhX3ZjdFRleHR1cmU7XHJcbm91dCB2ZWMyIHZfdmN0VGV4dHVyZTtcclxuICAjZW5kaWZcclxuXHJcbiAgI2lmIGRlZmluZWQoTUFUQ0FQKSAvLyBNYXRDYXAtc2hhZGVyIGdlbmVyYXRlcyB0ZXh0dXJlIGNvb3JkaW5hdGVzIGZyb20gc3VyZmFjZSBub3JtYWxzXHJcbm91dCB2ZWMyIHZfdmN0VGV4dHVyZTtcclxuICAjZW5kaWZcclxuXHJcbiAgLy8gR09VUkFVRDogb2ZmZXIgYnVmZmVycyBmb3IgdmVydGV4IG5vcm1hbHMsIHRoZWlyIHRyYW5zZm9ybWF0aW9uIGFuZCB0aGUgc2hpbmluZXNzXHJcbiAgI2lmIGRlZmluZWQoR09VUkFVRCl8fGRlZmluZWQoTUFUQ0FQKVxyXG5pbiB2ZWMzIGFfdmN0Tm9ybWFsVmVydGV4O1xyXG51bmlmb3JtIG1hdDQgdV9tdHhOb3JtYWxNZXNoVG9Xb3JsZDtcclxuICAjZW5kaWZcclxuXHJcbiAgLy8gQ0FNRVJBOiBvZmZlciBidWZmZXIgYW5kIGZ1bmN0aW9uYWxpdHkgZm9yIHNwZWN1bGFyIHJlZmxlY3Rpb24gZGVwZW5kaW5nIG9uIHRoZSBjYW1lcmEtcG9zaXRpb25cclxuICAjaWYgZGVmaW5lZChDQU1FUkEpXHJcbnVuaWZvcm0gZmxvYXQgdV9mU2hpbmluZXNzO1xyXG51bmlmb3JtIG1hdDQgdV9tdHhNZXNoVG9Xb3JsZDtcclxudW5pZm9ybSBtYXQ0IHVfbXR4V29ybGRUb1ZpZXc7XHJcbnVuaWZvcm0gdmVjMyB1X3ZjdENhbWVyYTtcclxuXHJcbmZsb2F0IGNhbGN1bGF0ZVJlZmxlY3Rpb24odmVjMyBfdmN0TGlnaHQsIHZlYzMgX3ZjdFZpZXcsIHZlYzMgX3ZjdE5vcm1hbCwgZmxvYXQgX2ZTaGluaW5lc3MpIHtcclxuICBpZihfZlNoaW5pbmVzcyA8PSAwLjApXHJcbiAgICByZXR1cm4gMC4wO1xyXG4gIHZlYzMgdmN0UmVmbGVjdGlvbiA9IG5vcm1hbGl6ZShyZWZsZWN0KC1fdmN0TGlnaHQsIF92Y3ROb3JtYWwpKTtcclxuICBmbG9hdCBmU2NwZWN1bGFyID0gZG90KHZjdFJlZmxlY3Rpb24sIF92Y3RWaWV3KTtcclxuICByZXR1cm4gcG93KG1heChmU2NwZWN1bGFyLCAwLjApLCBfZlNoaW5pbmVzcyAqIDEwLjApICogX2ZTaGluaW5lc3M7XHJcbiAgLy8gcmV0dXJuIG1heChzcGVjX2RvdCwgMC4wKSAqIHNoaW5pbmVzcztcclxufVxyXG4gICNlbmRpZlxyXG5cclxudm9pZCBtYWluKCkge1xyXG4gIHZlYzQgdmN0UG9zaXRpb247XHJcblxyXG4gICAgI2lmIGRlZmluZWQoRkxBVClcclxuICAgIC8vIEZMQVQ6IHVzZSB0aGUgc3BlY2lhbCB2ZXJ0ZXggYW5kIG5vcm1hbCBidWZmZXJzIGZvciBmbGF0IHNoYWRpbmdcclxuICB2Y3RQb3NpdGlvbiA9IHZlYzQoYV92Y3RQb3NpdGlvbkZsYXQsIDEuMCk7XHJcbiAgdmVjMyB2Y3ROb3JtYWwgPSBub3JtYWxpemUobWF0Myh1X210eE5vcm1hbE1lc2hUb1dvcmxkKSAqIGFfdmN0Tm9ybWFsRmFjZSk7XHJcbiAgdl92Y3RDb2xvciA9IHVfYW1iaWVudC52Y3RDb2xvcjtcclxuICAgICNlbHNlIFxyXG4gIHZjdFBvc2l0aW9uID0gdmVjNChhX3ZjdFBvc2l0aW9uLCAxLjApO1xyXG4gICAgI2VuZGlmXHJcblxyXG4gICAgLy8gdXNlIHRoZSByZWd1bGFyIHZlcnRleCBidWZmZXJcclxuICBnbF9Qb3NpdGlvbiA9IHVfbXR4TWVzaFRvVmlldyAqIHZjdFBvc2l0aW9uO1xyXG5cclxuICAgIC8vIEdPVVJBVUQ6IHVzZSB0aGUgdmVydGV4IG5vcm1hbHNcclxuICAgICNpZiBkZWZpbmVkKEdPVVJBVUQpXHJcbiAgdl92Y3RDb2xvciA9IHVfYW1iaWVudC52Y3RDb2xvcjtcclxuICB2ZWMzIHZjdE5vcm1hbCA9IG5vcm1hbGl6ZShtYXQzKHVfbXR4Tm9ybWFsTWVzaFRvV29ybGQpICogYV92Y3ROb3JtYWxWZXJ0ZXgpO1xyXG4gICAgI2VuZGlmXHJcblxyXG4gICAgI2lmIGRlZmluZWQoQ0FNRVJBKVxyXG4gIC8vIHZpZXcgdmVjdG9yIG5lZWRlZFxyXG4gIC8vIHZlYzQgcG9zV29ybGQ0ID0gdV9tdHhNZXNoVG9Xb3JsZCAqIHZjdFBvc2l0aW9uO1xyXG4gIC8vIHZlYzMgdmN0VmlldyA9IG5vcm1hbGl6ZShwb3NXb3JsZDQueHl6L3Bvc1dvcmxkNC53IC0gdV92Y3RDYW1lcmEpO1xyXG4gIHZlYzMgdmN0VmlldyA9IG5vcm1hbGl6ZSh2ZWMzKHVfbXR4TWVzaFRvV29ybGQgKiB2Y3RQb3NpdGlvbikgLSB1X3ZjdENhbWVyYSk7XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAjaWYgZGVmaW5lZChMSUdIVClcclxuICAvLyBjYWxjdWxhdGUgdGhlIGRpcmVjdGlvbmFsIGxpZ2h0aW5nIGVmZmVjdFxyXG4gIGZvcih1aW50IGkgPSAwdTsgaSA8IHVfbkxpZ2h0c0RpcmVjdGlvbmFsOyBpKyspIHtcclxuICAgIGZsb2F0IGZJbGx1bWluYXRpb24gPSAtZG90KHZjdE5vcm1hbCwgdV9kaXJlY3Rpb25hbFtpXS52Y3REaXJlY3Rpb24pO1xyXG4gICAgaWYoZklsbHVtaW5hdGlvbiA+IDAuMGYpIHtcclxuICAgICAgdl92Y3RDb2xvciArPSBmSWxsdW1pbmF0aW9uICogdV9kaXJlY3Rpb25hbFtpXS52Y3RDb2xvcjtcclxuICAgICAgICAjaWYgZGVmaW5lZChDQU1FUkEpXHJcbiAgICAgIGZsb2F0IGZSZWZsZWN0aW9uID0gY2FsY3VsYXRlUmVmbGVjdGlvbih1X2RpcmVjdGlvbmFsW2ldLnZjdERpcmVjdGlvbiwgdmN0VmlldywgdmN0Tm9ybWFsLCB1X2ZTaGluaW5lc3MpO1xyXG4gICAgICB2X3ZjdENvbG9yICs9IGZSZWZsZWN0aW9uICogdV9kaXJlY3Rpb25hbFtpXS52Y3RDb2xvcjtcclxuICAgICAgICAjZW5kaWZcclxuICAgIH1cclxuICB9XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAvLyBURVhUVVJFOiB0cmFuc2Zvcm0gVVZzXHJcbiAgICAjaWYgZGVmaW5lZChURVhUVVJFKVxyXG4gIHZfdmN0VGV4dHVyZSA9IHZlYzIodV9tdHhQaXZvdCAqIHZlYzMoYV92Y3RUZXh0dXJlLCAxLjApKS54eTtcclxuICAgICNlbmRpZlxyXG5cclxuICAgICNpZiBkZWZpbmVkKE1BVENBUClcclxuICB2ZWMzIHZjdE5vcm1hbCA9IG5vcm1hbGl6ZShtYXQzKHVfbXR4Tm9ybWFsTWVzaFRvV29ybGQpICogYV92Y3ROb3JtYWxWZXJ0ZXgpO1xyXG4gIHZjdE5vcm1hbCA9IG1hdDModV9tdHhXb3JsZFRvVmlldykgKiB2Y3ROb3JtYWw7XHJcbiAgdl92Y3RUZXh0dXJlID0gMC41ICogdmN0Tm9ybWFsLnh5IC8gbGVuZ3RoKHZjdE5vcm1hbCkgKyAwLjU7XHJcbiAgdl92Y3RUZXh0dXJlLnkgKj0gLTEuMDtcclxuICAgICNlbmRpZlxyXG5cclxuICAgIC8vIGFsd2F5cyBmdWxsIG9wYWNpdHkgZm9yIG5vdy4uLlxyXG4gIHZfdmN0Q29sb3IuYSA9IDEuMDtcclxufVxuYDsgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHsgXG5yZXR1cm4gYCN2ZXJzaW9uIDMwMCBlc1xuI2RlZmluZSBMSUdIVFxuI2RlZmluZSBHT1VSQVVEXG4jZGVmaW5lIFRFWFRVUkVcbiNkZWZpbmUgQ0FNRVJBXG5cclxuLyoqXHJcbiogVW5pdmVyc2FsIFNoYWRlciBhcyBiYXNlIGZvciBtYW55IG90aGVycy4gQ29udHJvbGxlZCBieSBjb21waWxlciBkaXJlY3RpdmVzXHJcbiogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuKi9cclxuXHJcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG5cclxuICAvLyBNSU5JTUFMIChubyBkZWZpbmUgbmVlZGVkKTogaW5jbHVkZSBiYXNlIGNvbG9yXHJcbnVuaWZvcm0gdmVjNCB1X3ZjdENvbG9yO1xyXG5cclxuICAvLyBGTEFUOiBpbnB1dCB2ZXJ0ZXggY29sb3JzIGZsYXQsIHNvIHRoZSB0aGlyZCBvZiBhIHRyaWFuZ2xlIGRldGVybWluZXMgdGhlIGNvbG9yXHJcbiAgI2lmIGRlZmluZWQoRkxBVCkgXHJcbmZsYXQgaW4gdmVjNCB2X3ZjdENvbG9yO1xyXG4gIC8vIExJR0hUOiBpbnB1dCB2ZXJ0ZXggY29sb3JzIGZvciBlYWNoIHZlcnRleCBmb3IgaW50ZXJwb2xhdGlvbiBvdmVyIHRoZSBmYWNlXHJcbiAgI2VsaWYgZGVmaW5lZChMSUdIVClcclxuaW4gdmVjNCB2X3ZjdENvbG9yO1xyXG4gICNlbmRpZlxyXG5cclxuICAvLyBURVhUVVJFOiBpbnB1dCBVVnMgYW5kIHRleHR1cmVcclxuICAjaWYgZGVmaW5lZChURVhUVVJFKSB8fCBkZWZpbmVkKE1BVENBUClcclxuaW4gdmVjMiB2X3ZjdFRleHR1cmU7XHJcbnVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcclxuICAjZW5kaWZcclxuXHJcbm91dCB2ZWM0IHZjdEZyYWc7XHJcblxyXG52b2lkIG1haW4oKSB7XHJcbiAgICAvLyBNSU5JTUFMOiBzZXQgdGhlIGJhc2UgY29sb3JcclxuICB2Y3RGcmFnID0gdV92Y3RDb2xvcjtcclxuXHJcbiAgICAvLyBWRVJURVg6IG11bHRpcGx5IHdpdGggdmVydGV4IGNvbG9yXHJcbiAgICAjaWYgZGVmaW5lZChGTEFUKSB8fCBkZWZpbmVkKExJR0hUKVxyXG4gIHZjdEZyYWcgKj0gdl92Y3RDb2xvcjtcclxuICAgICNlbmRpZlxyXG5cclxuICAgIC8vIFRFWFRVUkU6IG11bHRpcGx5IHdpdGggdGV4ZWwgY29sb3JcclxuICAgICNpZiBkZWZpbmVkKFRFWFRVUkUpIHx8IGRlZmluZWQoTUFUQ0FQKVxyXG4gIHZlYzQgdmN0Q29sb3JUZXh0dXJlID0gdGV4dHVyZSh1X3RleHR1cmUsIHZfdmN0VGV4dHVyZSk7XHJcbiAgdmN0RnJhZyAqPSB2Y3RDb2xvclRleHR1cmU7XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAvLyBkaXNjYXJkIHBpeGVsIGFsbHRvZ2V0aGVyIHdoZW4gdHJhbnNwYXJlbnQ6IGRvbid0IHNob3cgaW4gWi1CdWZmZXJcclxuICBpZih2Y3RGcmFnLmEgPCAwLjAxKVxyXG4gICAgZGlzY2FyZDtcclxufVxuYDsgfVxufVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuLyoqIENvZGUgZ2VuZXJhdGVkIGJ5IENvbXBpbGVTaGFkZXJzLm1qcyB1c2luZyB0aGUgaW5mb3JtYXRpb24gaW4gQ29tcGlsZVNoYWRlcnMuanNvbiAqL1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyTGl0IGV4dGVuZHMgU2hhZGVyIHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IFNoYWRlci5yZWdpc3RlclN1YmNsYXNzKFNoYWRlckxpdCk7XG5cbiAgcHVibGljIHN0YXRpYyBnZXRDb2F0KCk6IHR5cGVvZiBDb2F0IHsgcmV0dXJuIENvYXRDb2xvcmVkOyB9XG5cbiAgcHVibGljIHN0YXRpYyBnZXRWZXJ0ZXhTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHsgXG5yZXR1cm4gYCN2ZXJzaW9uIDMwMCBlc1xyXG4vKipcclxuKiBVbml2ZXJzYWwgU2hhZGVyIGFzIGJhc2UgZm9yIG1hbnkgb3RoZXJzLiBDb250cm9sbGVkIGJ5IGNvbXBpbGVyIGRpcmVjdGl2ZXNcclxuKiBAYXV0aG9ycyAyMDIxLCBMdWlzIEtlY2ssIEhGVSwgMjAyMSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxXHJcbiovXHJcblxyXG4gIC8vIE1JTklNQUwgKG5vIGRlZmluZSBuZWVkZWQpOiBidWZmZXJzIGZvciB0cmFuc2Zvcm1hdGlvblxyXG51bmlmb3JtIG1hdDQgdV9tdHhNZXNoVG9WaWV3O1xyXG5cclxuICAvLyBGTEFUOiBvZmZlciBidWZmZXJzIGZvciBmYWNlIG5vcm1hbHMgYW5kIHRoZWlyIHRyYW5zZm9ybWF0aW9uXHJcbiAgI2lmIGRlZmluZWQoRkxBVClcclxuaW4gdmVjMyBhX3ZjdFBvc2l0aW9uRmxhdDtcclxuaW4gdmVjMyBhX3ZjdE5vcm1hbEZhY2U7XHJcbnVuaWZvcm0gbWF0NCB1X210eE5vcm1hbE1lc2hUb1dvcmxkO1xyXG5mbGF0IG91dCB2ZWM0IHZfdmN0Q29sb3I7XHJcbiAgI2Vsc2VcclxuICAvLyByZWd1bGFyIGlmIG5vdCBGTEFUXHJcbmluIHZlYzMgYV92Y3RQb3NpdGlvbjtcclxub3V0IHZlYzQgdl92Y3RDb2xvcjtcclxuICAjZW5kaWZcclxuXHJcbiAgLy8gTElHSFQ6IG9mZmVyIGJ1ZmZlcnMgZm9yIGxpZ2h0aW5nIHZlcnRpY2VzIHdpdGggZGlmZmVyZW50IGxpZ2h0IHR5cGVzXHJcbiAgI2lmIGRlZmluZWQoTElHSFQpXHJcbnN0cnVjdCBMaWdodEFtYmllbnQge1xyXG4gIHZlYzQgdmN0Q29sb3I7XHJcbn07XHJcbnN0cnVjdCBMaWdodERpcmVjdGlvbmFsIHtcclxuICB2ZWM0IHZjdENvbG9yO1xyXG4gIHZlYzMgdmN0RGlyZWN0aW9uO1xyXG59O1xyXG5cclxuY29uc3QgdWludCBNQVhfTElHSFRTX0RJUkVDVElPTkFMID0gMTAwdTtcclxuXHJcbnVuaWZvcm0gTGlnaHRBbWJpZW50IHVfYW1iaWVudDtcclxudW5pZm9ybSB1aW50IHVfbkxpZ2h0c0RpcmVjdGlvbmFsO1xyXG51bmlmb3JtIExpZ2h0RGlyZWN0aW9uYWwgdV9kaXJlY3Rpb25hbFtNQVhfTElHSFRTX0RJUkVDVElPTkFMXTtcclxuICAjZW5kaWYgXHJcblxyXG4gIC8vIFRFWFRVUkU6IG9mZmVyIGJ1ZmZlcnMgZm9yIFVWcyBhbmQgcGl2b3QgbWF0cml4XHJcbiAgI2lmIGRlZmluZWQoVEVYVFVSRSlcclxudW5pZm9ybSBtYXQzIHVfbXR4UGl2b3Q7XHJcbmluIHZlYzIgYV92Y3RUZXh0dXJlO1xyXG5vdXQgdmVjMiB2X3ZjdFRleHR1cmU7XHJcbiAgI2VuZGlmXHJcblxyXG4gICNpZiBkZWZpbmVkKE1BVENBUCkgLy8gTWF0Q2FwLXNoYWRlciBnZW5lcmF0ZXMgdGV4dHVyZSBjb29yZGluYXRlcyBmcm9tIHN1cmZhY2Ugbm9ybWFsc1xyXG5vdXQgdmVjMiB2X3ZjdFRleHR1cmU7XHJcbiAgI2VuZGlmXHJcblxyXG4gIC8vIEdPVVJBVUQ6IG9mZmVyIGJ1ZmZlcnMgZm9yIHZlcnRleCBub3JtYWxzLCB0aGVpciB0cmFuc2Zvcm1hdGlvbiBhbmQgdGhlIHNoaW5pbmVzc1xyXG4gICNpZiBkZWZpbmVkKEdPVVJBVUQpfHxkZWZpbmVkKE1BVENBUClcclxuaW4gdmVjMyBhX3ZjdE5vcm1hbFZlcnRleDtcclxudW5pZm9ybSBtYXQ0IHVfbXR4Tm9ybWFsTWVzaFRvV29ybGQ7XHJcbiAgI2VuZGlmXHJcblxyXG4gIC8vIENBTUVSQTogb2ZmZXIgYnVmZmVyIGFuZCBmdW5jdGlvbmFsaXR5IGZvciBzcGVjdWxhciByZWZsZWN0aW9uIGRlcGVuZGluZyBvbiB0aGUgY2FtZXJhLXBvc2l0aW9uXHJcbiAgI2lmIGRlZmluZWQoQ0FNRVJBKVxyXG51bmlmb3JtIGZsb2F0IHVfZlNoaW5pbmVzcztcclxudW5pZm9ybSBtYXQ0IHVfbXR4TWVzaFRvV29ybGQ7XHJcbnVuaWZvcm0gbWF0NCB1X210eFdvcmxkVG9WaWV3O1xyXG51bmlmb3JtIHZlYzMgdV92Y3RDYW1lcmE7XHJcblxyXG5mbG9hdCBjYWxjdWxhdGVSZWZsZWN0aW9uKHZlYzMgX3ZjdExpZ2h0LCB2ZWMzIF92Y3RWaWV3LCB2ZWMzIF92Y3ROb3JtYWwsIGZsb2F0IF9mU2hpbmluZXNzKSB7XHJcbiAgaWYoX2ZTaGluaW5lc3MgPD0gMC4wKVxyXG4gICAgcmV0dXJuIDAuMDtcclxuICB2ZWMzIHZjdFJlZmxlY3Rpb24gPSBub3JtYWxpemUocmVmbGVjdCgtX3ZjdExpZ2h0LCBfdmN0Tm9ybWFsKSk7XHJcbiAgZmxvYXQgZlNjcGVjdWxhciA9IGRvdCh2Y3RSZWZsZWN0aW9uLCBfdmN0Vmlldyk7XHJcbiAgcmV0dXJuIHBvdyhtYXgoZlNjcGVjdWxhciwgMC4wKSwgX2ZTaGluaW5lc3MgKiAxMC4wKSAqIF9mU2hpbmluZXNzO1xyXG4gIC8vIHJldHVybiBtYXgoc3BlY19kb3QsIDAuMCkgKiBzaGluaW5lc3M7XHJcbn1cclxuICAjZW5kaWZcclxuXHJcbnZvaWQgbWFpbigpIHtcclxuICB2ZWM0IHZjdFBvc2l0aW9uO1xyXG5cclxuICAgICNpZiBkZWZpbmVkKEZMQVQpXHJcbiAgICAvLyBGTEFUOiB1c2UgdGhlIHNwZWNpYWwgdmVydGV4IGFuZCBub3JtYWwgYnVmZmVycyBmb3IgZmxhdCBzaGFkaW5nXHJcbiAgdmN0UG9zaXRpb24gPSB2ZWM0KGFfdmN0UG9zaXRpb25GbGF0LCAxLjApO1xyXG4gIHZlYzMgdmN0Tm9ybWFsID0gbm9ybWFsaXplKG1hdDModV9tdHhOb3JtYWxNZXNoVG9Xb3JsZCkgKiBhX3ZjdE5vcm1hbEZhY2UpO1xyXG4gIHZfdmN0Q29sb3IgPSB1X2FtYmllbnQudmN0Q29sb3I7XHJcbiAgICAjZWxzZSBcclxuICB2Y3RQb3NpdGlvbiA9IHZlYzQoYV92Y3RQb3NpdGlvbiwgMS4wKTtcclxuICAgICNlbmRpZlxyXG5cclxuICAgIC8vIHVzZSB0aGUgcmVndWxhciB2ZXJ0ZXggYnVmZmVyXHJcbiAgZ2xfUG9zaXRpb24gPSB1X210eE1lc2hUb1ZpZXcgKiB2Y3RQb3NpdGlvbjtcclxuXHJcbiAgICAvLyBHT1VSQVVEOiB1c2UgdGhlIHZlcnRleCBub3JtYWxzXHJcbiAgICAjaWYgZGVmaW5lZChHT1VSQVVEKVxyXG4gIHZfdmN0Q29sb3IgPSB1X2FtYmllbnQudmN0Q29sb3I7XHJcbiAgdmVjMyB2Y3ROb3JtYWwgPSBub3JtYWxpemUobWF0Myh1X210eE5vcm1hbE1lc2hUb1dvcmxkKSAqIGFfdmN0Tm9ybWFsVmVydGV4KTtcclxuICAgICNlbmRpZlxyXG5cclxuICAgICNpZiBkZWZpbmVkKENBTUVSQSlcclxuICAvLyB2aWV3IHZlY3RvciBuZWVkZWRcclxuICAvLyB2ZWM0IHBvc1dvcmxkNCA9IHVfbXR4TWVzaFRvV29ybGQgKiB2Y3RQb3NpdGlvbjtcclxuICAvLyB2ZWMzIHZjdFZpZXcgPSBub3JtYWxpemUocG9zV29ybGQ0Lnh5ei9wb3NXb3JsZDQudyAtIHVfdmN0Q2FtZXJhKTtcclxuICB2ZWMzIHZjdFZpZXcgPSBub3JtYWxpemUodmVjMyh1X210eE1lc2hUb1dvcmxkICogdmN0UG9zaXRpb24pIC0gdV92Y3RDYW1lcmEpO1xyXG4gICAgI2VuZGlmXHJcblxyXG4gICAgI2lmIGRlZmluZWQoTElHSFQpXHJcbiAgLy8gY2FsY3VsYXRlIHRoZSBkaXJlY3Rpb25hbCBsaWdodGluZyBlZmZlY3RcclxuICBmb3IodWludCBpID0gMHU7IGkgPCB1X25MaWdodHNEaXJlY3Rpb25hbDsgaSsrKSB7XHJcbiAgICBmbG9hdCBmSWxsdW1pbmF0aW9uID0gLWRvdCh2Y3ROb3JtYWwsIHVfZGlyZWN0aW9uYWxbaV0udmN0RGlyZWN0aW9uKTtcclxuICAgIGlmKGZJbGx1bWluYXRpb24gPiAwLjBmKSB7XHJcbiAgICAgIHZfdmN0Q29sb3IgKz0gZklsbHVtaW5hdGlvbiAqIHVfZGlyZWN0aW9uYWxbaV0udmN0Q29sb3I7XHJcbiAgICAgICAgI2lmIGRlZmluZWQoQ0FNRVJBKVxyXG4gICAgICBmbG9hdCBmUmVmbGVjdGlvbiA9IGNhbGN1bGF0ZVJlZmxlY3Rpb24odV9kaXJlY3Rpb25hbFtpXS52Y3REaXJlY3Rpb24sIHZjdFZpZXcsIHZjdE5vcm1hbCwgdV9mU2hpbmluZXNzKTtcclxuICAgICAgdl92Y3RDb2xvciArPSBmUmVmbGVjdGlvbiAqIHVfZGlyZWN0aW9uYWxbaV0udmN0Q29sb3I7XHJcbiAgICAgICAgI2VuZGlmXHJcbiAgICB9XHJcbiAgfVxyXG4gICAgI2VuZGlmXHJcblxyXG4gICAgLy8gVEVYVFVSRTogdHJhbnNmb3JtIFVWc1xyXG4gICAgI2lmIGRlZmluZWQoVEVYVFVSRSlcclxuICB2X3ZjdFRleHR1cmUgPSB2ZWMyKHVfbXR4UGl2b3QgKiB2ZWMzKGFfdmN0VGV4dHVyZSwgMS4wKSkueHk7XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAjaWYgZGVmaW5lZChNQVRDQVApXHJcbiAgdmVjMyB2Y3ROb3JtYWwgPSBub3JtYWxpemUobWF0Myh1X210eE5vcm1hbE1lc2hUb1dvcmxkKSAqIGFfdmN0Tm9ybWFsVmVydGV4KTtcclxuICB2Y3ROb3JtYWwgPSBtYXQzKHVfbXR4V29ybGRUb1ZpZXcpICogdmN0Tm9ybWFsO1xyXG4gIHZfdmN0VGV4dHVyZSA9IDAuNSAqIHZjdE5vcm1hbC54eSAvIGxlbmd0aCh2Y3ROb3JtYWwpICsgMC41O1xyXG4gIHZfdmN0VGV4dHVyZS55ICo9IC0xLjA7XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAvLyBhbHdheXMgZnVsbCBvcGFjaXR5IGZvciBub3cuLi5cclxuICB2X3ZjdENvbG9yLmEgPSAxLjA7XHJcbn1cbmA7IH1cblxuICBwdWJsaWMgc3RhdGljIGdldEZyYWdtZW50U2hhZGVyU291cmNlKCk6IHN0cmluZyB7IFxucmV0dXJuIGAjdmVyc2lvbiAzMDAgZXNcclxuLyoqXHJcbiogVW5pdmVyc2FsIFNoYWRlciBhcyBiYXNlIGZvciBtYW55IG90aGVycy4gQ29udHJvbGxlZCBieSBjb21waWxlciBkaXJlY3RpdmVzXHJcbiogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuKi9cclxuXHJcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG5cclxuICAvLyBNSU5JTUFMIChubyBkZWZpbmUgbmVlZGVkKTogaW5jbHVkZSBiYXNlIGNvbG9yXHJcbnVuaWZvcm0gdmVjNCB1X3ZjdENvbG9yO1xyXG5cclxuICAvLyBGTEFUOiBpbnB1dCB2ZXJ0ZXggY29sb3JzIGZsYXQsIHNvIHRoZSB0aGlyZCBvZiBhIHRyaWFuZ2xlIGRldGVybWluZXMgdGhlIGNvbG9yXHJcbiAgI2lmIGRlZmluZWQoRkxBVCkgXHJcbmZsYXQgaW4gdmVjNCB2X3ZjdENvbG9yO1xyXG4gIC8vIExJR0hUOiBpbnB1dCB2ZXJ0ZXggY29sb3JzIGZvciBlYWNoIHZlcnRleCBmb3IgaW50ZXJwb2xhdGlvbiBvdmVyIHRoZSBmYWNlXHJcbiAgI2VsaWYgZGVmaW5lZChMSUdIVClcclxuaW4gdmVjNCB2X3ZjdENvbG9yO1xyXG4gICNlbmRpZlxyXG5cclxuICAvLyBURVhUVVJFOiBpbnB1dCBVVnMgYW5kIHRleHR1cmVcclxuICAjaWYgZGVmaW5lZChURVhUVVJFKSB8fCBkZWZpbmVkKE1BVENBUClcclxuaW4gdmVjMiB2X3ZjdFRleHR1cmU7XHJcbnVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcclxuICAjZW5kaWZcclxuXHJcbm91dCB2ZWM0IHZjdEZyYWc7XHJcblxyXG52b2lkIG1haW4oKSB7XHJcbiAgICAvLyBNSU5JTUFMOiBzZXQgdGhlIGJhc2UgY29sb3JcclxuICB2Y3RGcmFnID0gdV92Y3RDb2xvcjtcclxuXHJcbiAgICAvLyBWRVJURVg6IG11bHRpcGx5IHdpdGggdmVydGV4IGNvbG9yXHJcbiAgICAjaWYgZGVmaW5lZChGTEFUKSB8fCBkZWZpbmVkKExJR0hUKVxyXG4gIHZjdEZyYWcgKj0gdl92Y3RDb2xvcjtcclxuICAgICNlbmRpZlxyXG5cclxuICAgIC8vIFRFWFRVUkU6IG11bHRpcGx5IHdpdGggdGV4ZWwgY29sb3JcclxuICAgICNpZiBkZWZpbmVkKFRFWFRVUkUpIHx8IGRlZmluZWQoTUFUQ0FQKVxyXG4gIHZlYzQgdmN0Q29sb3JUZXh0dXJlID0gdGV4dHVyZSh1X3RleHR1cmUsIHZfdmN0VGV4dHVyZSk7XHJcbiAgdmN0RnJhZyAqPSB2Y3RDb2xvclRleHR1cmU7XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAvLyBkaXNjYXJkIHBpeGVsIGFsbHRvZ2V0aGVyIHdoZW4gdHJhbnNwYXJlbnQ6IGRvbid0IHNob3cgaW4gWi1CdWZmZXJcclxuICBpZih2Y3RGcmFnLmEgPCAwLjAxKVxyXG4gICAgZGlzY2FyZDtcclxufVxuYDsgfVxufVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuLyoqIENvZGUgZ2VuZXJhdGVkIGJ5IENvbXBpbGVTaGFkZXJzLm1qcyB1c2luZyB0aGUgaW5mb3JtYXRpb24gaW4gQ29tcGlsZVNoYWRlcnMuanNvbiAqL1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyTGl0VGV4dHVyZWQgZXh0ZW5kcyBTaGFkZXIge1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gU2hhZGVyLnJlZ2lzdGVyU3ViY2xhc3MoU2hhZGVyTGl0VGV4dHVyZWQpO1xuXG4gIHB1YmxpYyBzdGF0aWMgZ2V0Q29hdCgpOiB0eXBlb2YgQ29hdCB7IHJldHVybiBDb2F0VGV4dHVyZWQ7IH1cblxuICBwdWJsaWMgc3RhdGljIGdldFZlcnRleFNoYWRlclNvdXJjZSgpOiBzdHJpbmcgeyBcbnJldHVybiBgI3ZlcnNpb24gMzAwIGVzXG4jZGVmaW5lIFRFWFRVUkVcblxyXG4vKipcclxuKiBVbml2ZXJzYWwgU2hhZGVyIGFzIGJhc2UgZm9yIG1hbnkgb3RoZXJzLiBDb250cm9sbGVkIGJ5IGNvbXBpbGVyIGRpcmVjdGl2ZXNcclxuKiBAYXV0aG9ycyAyMDIxLCBMdWlzIEtlY2ssIEhGVSwgMjAyMSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxXHJcbiovXHJcblxyXG4gIC8vIE1JTklNQUwgKG5vIGRlZmluZSBuZWVkZWQpOiBidWZmZXJzIGZvciB0cmFuc2Zvcm1hdGlvblxyXG51bmlmb3JtIG1hdDQgdV9tdHhNZXNoVG9WaWV3O1xyXG5cclxuICAvLyBGTEFUOiBvZmZlciBidWZmZXJzIGZvciBmYWNlIG5vcm1hbHMgYW5kIHRoZWlyIHRyYW5zZm9ybWF0aW9uXHJcbiAgI2lmIGRlZmluZWQoRkxBVClcclxuaW4gdmVjMyBhX3ZjdFBvc2l0aW9uRmxhdDtcclxuaW4gdmVjMyBhX3ZjdE5vcm1hbEZhY2U7XHJcbnVuaWZvcm0gbWF0NCB1X210eE5vcm1hbE1lc2hUb1dvcmxkO1xyXG5mbGF0IG91dCB2ZWM0IHZfdmN0Q29sb3I7XHJcbiAgI2Vsc2VcclxuICAvLyByZWd1bGFyIGlmIG5vdCBGTEFUXHJcbmluIHZlYzMgYV92Y3RQb3NpdGlvbjtcclxub3V0IHZlYzQgdl92Y3RDb2xvcjtcclxuICAjZW5kaWZcclxuXHJcbiAgLy8gTElHSFQ6IG9mZmVyIGJ1ZmZlcnMgZm9yIGxpZ2h0aW5nIHZlcnRpY2VzIHdpdGggZGlmZmVyZW50IGxpZ2h0IHR5cGVzXHJcbiAgI2lmIGRlZmluZWQoTElHSFQpXHJcbnN0cnVjdCBMaWdodEFtYmllbnQge1xyXG4gIHZlYzQgdmN0Q29sb3I7XHJcbn07XHJcbnN0cnVjdCBMaWdodERpcmVjdGlvbmFsIHtcclxuICB2ZWM0IHZjdENvbG9yO1xyXG4gIHZlYzMgdmN0RGlyZWN0aW9uO1xyXG59O1xyXG5cclxuY29uc3QgdWludCBNQVhfTElHSFRTX0RJUkVDVElPTkFMID0gMTAwdTtcclxuXHJcbnVuaWZvcm0gTGlnaHRBbWJpZW50IHVfYW1iaWVudDtcclxudW5pZm9ybSB1aW50IHVfbkxpZ2h0c0RpcmVjdGlvbmFsO1xyXG51bmlmb3JtIExpZ2h0RGlyZWN0aW9uYWwgdV9kaXJlY3Rpb25hbFtNQVhfTElHSFRTX0RJUkVDVElPTkFMXTtcclxuICAjZW5kaWYgXHJcblxyXG4gIC8vIFRFWFRVUkU6IG9mZmVyIGJ1ZmZlcnMgZm9yIFVWcyBhbmQgcGl2b3QgbWF0cml4XHJcbiAgI2lmIGRlZmluZWQoVEVYVFVSRSlcclxudW5pZm9ybSBtYXQzIHVfbXR4UGl2b3Q7XHJcbmluIHZlYzIgYV92Y3RUZXh0dXJlO1xyXG5vdXQgdmVjMiB2X3ZjdFRleHR1cmU7XHJcbiAgI2VuZGlmXHJcblxyXG4gICNpZiBkZWZpbmVkKE1BVENBUCkgLy8gTWF0Q2FwLXNoYWRlciBnZW5lcmF0ZXMgdGV4dHVyZSBjb29yZGluYXRlcyBmcm9tIHN1cmZhY2Ugbm9ybWFsc1xyXG5vdXQgdmVjMiB2X3ZjdFRleHR1cmU7XHJcbiAgI2VuZGlmXHJcblxyXG4gIC8vIEdPVVJBVUQ6IG9mZmVyIGJ1ZmZlcnMgZm9yIHZlcnRleCBub3JtYWxzLCB0aGVpciB0cmFuc2Zvcm1hdGlvbiBhbmQgdGhlIHNoaW5pbmVzc1xyXG4gICNpZiBkZWZpbmVkKEdPVVJBVUQpfHxkZWZpbmVkKE1BVENBUClcclxuaW4gdmVjMyBhX3ZjdE5vcm1hbFZlcnRleDtcclxudW5pZm9ybSBtYXQ0IHVfbXR4Tm9ybWFsTWVzaFRvV29ybGQ7XHJcbiAgI2VuZGlmXHJcblxyXG4gIC8vIENBTUVSQTogb2ZmZXIgYnVmZmVyIGFuZCBmdW5jdGlvbmFsaXR5IGZvciBzcGVjdWxhciByZWZsZWN0aW9uIGRlcGVuZGluZyBvbiB0aGUgY2FtZXJhLXBvc2l0aW9uXHJcbiAgI2lmIGRlZmluZWQoQ0FNRVJBKVxyXG51bmlmb3JtIGZsb2F0IHVfZlNoaW5pbmVzcztcclxudW5pZm9ybSBtYXQ0IHVfbXR4TWVzaFRvV29ybGQ7XHJcbnVuaWZvcm0gbWF0NCB1X210eFdvcmxkVG9WaWV3O1xyXG51bmlmb3JtIHZlYzMgdV92Y3RDYW1lcmE7XHJcblxyXG5mbG9hdCBjYWxjdWxhdGVSZWZsZWN0aW9uKHZlYzMgX3ZjdExpZ2h0LCB2ZWMzIF92Y3RWaWV3LCB2ZWMzIF92Y3ROb3JtYWwsIGZsb2F0IF9mU2hpbmluZXNzKSB7XHJcbiAgaWYoX2ZTaGluaW5lc3MgPD0gMC4wKVxyXG4gICAgcmV0dXJuIDAuMDtcclxuICB2ZWMzIHZjdFJlZmxlY3Rpb24gPSBub3JtYWxpemUocmVmbGVjdCgtX3ZjdExpZ2h0LCBfdmN0Tm9ybWFsKSk7XHJcbiAgZmxvYXQgZlNjcGVjdWxhciA9IGRvdCh2Y3RSZWZsZWN0aW9uLCBfdmN0Vmlldyk7XHJcbiAgcmV0dXJuIHBvdyhtYXgoZlNjcGVjdWxhciwgMC4wKSwgX2ZTaGluaW5lc3MgKiAxMC4wKSAqIF9mU2hpbmluZXNzO1xyXG4gIC8vIHJldHVybiBtYXgoc3BlY19kb3QsIDAuMCkgKiBzaGluaW5lc3M7XHJcbn1cclxuICAjZW5kaWZcclxuXHJcbnZvaWQgbWFpbigpIHtcclxuICB2ZWM0IHZjdFBvc2l0aW9uO1xyXG5cclxuICAgICNpZiBkZWZpbmVkKEZMQVQpXHJcbiAgICAvLyBGTEFUOiB1c2UgdGhlIHNwZWNpYWwgdmVydGV4IGFuZCBub3JtYWwgYnVmZmVycyBmb3IgZmxhdCBzaGFkaW5nXHJcbiAgdmN0UG9zaXRpb24gPSB2ZWM0KGFfdmN0UG9zaXRpb25GbGF0LCAxLjApO1xyXG4gIHZlYzMgdmN0Tm9ybWFsID0gbm9ybWFsaXplKG1hdDModV9tdHhOb3JtYWxNZXNoVG9Xb3JsZCkgKiBhX3ZjdE5vcm1hbEZhY2UpO1xyXG4gIHZfdmN0Q29sb3IgPSB1X2FtYmllbnQudmN0Q29sb3I7XHJcbiAgICAjZWxzZSBcclxuICB2Y3RQb3NpdGlvbiA9IHZlYzQoYV92Y3RQb3NpdGlvbiwgMS4wKTtcclxuICAgICNlbmRpZlxyXG5cclxuICAgIC8vIHVzZSB0aGUgcmVndWxhciB2ZXJ0ZXggYnVmZmVyXHJcbiAgZ2xfUG9zaXRpb24gPSB1X210eE1lc2hUb1ZpZXcgKiB2Y3RQb3NpdGlvbjtcclxuXHJcbiAgICAvLyBHT1VSQVVEOiB1c2UgdGhlIHZlcnRleCBub3JtYWxzXHJcbiAgICAjaWYgZGVmaW5lZChHT1VSQVVEKVxyXG4gIHZfdmN0Q29sb3IgPSB1X2FtYmllbnQudmN0Q29sb3I7XHJcbiAgdmVjMyB2Y3ROb3JtYWwgPSBub3JtYWxpemUobWF0Myh1X210eE5vcm1hbE1lc2hUb1dvcmxkKSAqIGFfdmN0Tm9ybWFsVmVydGV4KTtcclxuICAgICNlbmRpZlxyXG5cclxuICAgICNpZiBkZWZpbmVkKENBTUVSQSlcclxuICAvLyB2aWV3IHZlY3RvciBuZWVkZWRcclxuICAvLyB2ZWM0IHBvc1dvcmxkNCA9IHVfbXR4TWVzaFRvV29ybGQgKiB2Y3RQb3NpdGlvbjtcclxuICAvLyB2ZWMzIHZjdFZpZXcgPSBub3JtYWxpemUocG9zV29ybGQ0Lnh5ei9wb3NXb3JsZDQudyAtIHVfdmN0Q2FtZXJhKTtcclxuICB2ZWMzIHZjdFZpZXcgPSBub3JtYWxpemUodmVjMyh1X210eE1lc2hUb1dvcmxkICogdmN0UG9zaXRpb24pIC0gdV92Y3RDYW1lcmEpO1xyXG4gICAgI2VuZGlmXHJcblxyXG4gICAgI2lmIGRlZmluZWQoTElHSFQpXHJcbiAgLy8gY2FsY3VsYXRlIHRoZSBkaXJlY3Rpb25hbCBsaWdodGluZyBlZmZlY3RcclxuICBmb3IodWludCBpID0gMHU7IGkgPCB1X25MaWdodHNEaXJlY3Rpb25hbDsgaSsrKSB7XHJcbiAgICBmbG9hdCBmSWxsdW1pbmF0aW9uID0gLWRvdCh2Y3ROb3JtYWwsIHVfZGlyZWN0aW9uYWxbaV0udmN0RGlyZWN0aW9uKTtcclxuICAgIGlmKGZJbGx1bWluYXRpb24gPiAwLjBmKSB7XHJcbiAgICAgIHZfdmN0Q29sb3IgKz0gZklsbHVtaW5hdGlvbiAqIHVfZGlyZWN0aW9uYWxbaV0udmN0Q29sb3I7XHJcbiAgICAgICAgI2lmIGRlZmluZWQoQ0FNRVJBKVxyXG4gICAgICBmbG9hdCBmUmVmbGVjdGlvbiA9IGNhbGN1bGF0ZVJlZmxlY3Rpb24odV9kaXJlY3Rpb25hbFtpXS52Y3REaXJlY3Rpb24sIHZjdFZpZXcsIHZjdE5vcm1hbCwgdV9mU2hpbmluZXNzKTtcclxuICAgICAgdl92Y3RDb2xvciArPSBmUmVmbGVjdGlvbiAqIHVfZGlyZWN0aW9uYWxbaV0udmN0Q29sb3I7XHJcbiAgICAgICAgI2VuZGlmXHJcbiAgICB9XHJcbiAgfVxyXG4gICAgI2VuZGlmXHJcblxyXG4gICAgLy8gVEVYVFVSRTogdHJhbnNmb3JtIFVWc1xyXG4gICAgI2lmIGRlZmluZWQoVEVYVFVSRSlcclxuICB2X3ZjdFRleHR1cmUgPSB2ZWMyKHVfbXR4UGl2b3QgKiB2ZWMzKGFfdmN0VGV4dHVyZSwgMS4wKSkueHk7XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAjaWYgZGVmaW5lZChNQVRDQVApXHJcbiAgdmVjMyB2Y3ROb3JtYWwgPSBub3JtYWxpemUobWF0Myh1X210eE5vcm1hbE1lc2hUb1dvcmxkKSAqIGFfdmN0Tm9ybWFsVmVydGV4KTtcclxuICB2Y3ROb3JtYWwgPSBtYXQzKHVfbXR4V29ybGRUb1ZpZXcpICogdmN0Tm9ybWFsO1xyXG4gIHZfdmN0VGV4dHVyZSA9IDAuNSAqIHZjdE5vcm1hbC54eSAvIGxlbmd0aCh2Y3ROb3JtYWwpICsgMC41O1xyXG4gIHZfdmN0VGV4dHVyZS55ICo9IC0xLjA7XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAvLyBhbHdheXMgZnVsbCBvcGFjaXR5IGZvciBub3cuLi5cclxuICB2X3ZjdENvbG9yLmEgPSAxLjA7XHJcbn1cbmA7IH1cblxuICBwdWJsaWMgc3RhdGljIGdldEZyYWdtZW50U2hhZGVyU291cmNlKCk6IHN0cmluZyB7IFxucmV0dXJuIGAjdmVyc2lvbiAzMDAgZXNcbiNkZWZpbmUgVEVYVFVSRVxuXHJcbi8qKlxyXG4qIFVuaXZlcnNhbCBTaGFkZXIgYXMgYmFzZSBmb3IgbWFueSBvdGhlcnMuIENvbnRyb2xsZWQgYnkgY29tcGlsZXIgZGlyZWN0aXZlc1xyXG4qIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxXHJcbiovXHJcblxyXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcclxuXHJcbiAgLy8gTUlOSU1BTCAobm8gZGVmaW5lIG5lZWRlZCk6IGluY2x1ZGUgYmFzZSBjb2xvclxyXG51bmlmb3JtIHZlYzQgdV92Y3RDb2xvcjtcclxuXHJcbiAgLy8gRkxBVDogaW5wdXQgdmVydGV4IGNvbG9ycyBmbGF0LCBzbyB0aGUgdGhpcmQgb2YgYSB0cmlhbmdsZSBkZXRlcm1pbmVzIHRoZSBjb2xvclxyXG4gICNpZiBkZWZpbmVkKEZMQVQpIFxyXG5mbGF0IGluIHZlYzQgdl92Y3RDb2xvcjtcclxuICAvLyBMSUdIVDogaW5wdXQgdmVydGV4IGNvbG9ycyBmb3IgZWFjaCB2ZXJ0ZXggZm9yIGludGVycG9sYXRpb24gb3ZlciB0aGUgZmFjZVxyXG4gICNlbGlmIGRlZmluZWQoTElHSFQpXHJcbmluIHZlYzQgdl92Y3RDb2xvcjtcclxuICAjZW5kaWZcclxuXHJcbiAgLy8gVEVYVFVSRTogaW5wdXQgVVZzIGFuZCB0ZXh0dXJlXHJcbiAgI2lmIGRlZmluZWQoVEVYVFVSRSkgfHwgZGVmaW5lZChNQVRDQVApXHJcbmluIHZlYzIgdl92Y3RUZXh0dXJlO1xyXG51bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XHJcbiAgI2VuZGlmXHJcblxyXG5vdXQgdmVjNCB2Y3RGcmFnO1xyXG5cclxudm9pZCBtYWluKCkge1xyXG4gICAgLy8gTUlOSU1BTDogc2V0IHRoZSBiYXNlIGNvbG9yXHJcbiAgdmN0RnJhZyA9IHVfdmN0Q29sb3I7XHJcblxyXG4gICAgLy8gVkVSVEVYOiBtdWx0aXBseSB3aXRoIHZlcnRleCBjb2xvclxyXG4gICAgI2lmIGRlZmluZWQoRkxBVCkgfHwgZGVmaW5lZChMSUdIVClcclxuICB2Y3RGcmFnICo9IHZfdmN0Q29sb3I7XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAvLyBURVhUVVJFOiBtdWx0aXBseSB3aXRoIHRleGVsIGNvbG9yXHJcbiAgICAjaWYgZGVmaW5lZChURVhUVVJFKSB8fCBkZWZpbmVkKE1BVENBUClcclxuICB2ZWM0IHZjdENvbG9yVGV4dHVyZSA9IHRleHR1cmUodV90ZXh0dXJlLCB2X3ZjdFRleHR1cmUpO1xyXG4gIHZjdEZyYWcgKj0gdmN0Q29sb3JUZXh0dXJlO1xyXG4gICAgI2VuZGlmXHJcblxyXG4gICAgLy8gZGlzY2FyZCBwaXhlbCBhbGx0b2dldGhlciB3aGVuIHRyYW5zcGFyZW50OiBkb24ndCBzaG93IGluIFotQnVmZmVyXHJcbiAgaWYodmN0RnJhZy5hIDwgMC4wMSlcclxuICAgIGRpc2NhcmQ7XHJcbn1cbmA7IH1cbn1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbi8qKiBDb2RlIGdlbmVyYXRlZCBieSBDb21waWxlU2hhZGVycy5tanMgdXNpbmcgdGhlIGluZm9ybWF0aW9uIGluIENvbXBpbGVTaGFkZXJzLmpzb24gKi9cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYWRlck1hdENhcCBleHRlbmRzIFNoYWRlciB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBTaGFkZXIucmVnaXN0ZXJTdWJjbGFzcyhTaGFkZXJNYXRDYXApO1xuXG4gIHB1YmxpYyBzdGF0aWMgZ2V0Q29hdCgpOiB0eXBlb2YgQ29hdCB7IHJldHVybiBDb2F0VGV4dHVyZWQ7IH1cblxuICBwdWJsaWMgc3RhdGljIGdldFZlcnRleFNoYWRlclNvdXJjZSgpOiBzdHJpbmcgeyBcbnJldHVybiBgI3ZlcnNpb24gMzAwIGVzXG4jZGVmaW5lIENBTUVSQVxuI2RlZmluZSBNQVRDQVBcblxyXG4vKipcclxuKiBVbml2ZXJzYWwgU2hhZGVyIGFzIGJhc2UgZm9yIG1hbnkgb3RoZXJzLiBDb250cm9sbGVkIGJ5IGNvbXBpbGVyIGRpcmVjdGl2ZXNcclxuKiBAYXV0aG9ycyAyMDIxLCBMdWlzIEtlY2ssIEhGVSwgMjAyMSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxXHJcbiovXHJcblxyXG4gIC8vIE1JTklNQUwgKG5vIGRlZmluZSBuZWVkZWQpOiBidWZmZXJzIGZvciB0cmFuc2Zvcm1hdGlvblxyXG51bmlmb3JtIG1hdDQgdV9tdHhNZXNoVG9WaWV3O1xyXG5cclxuICAvLyBGTEFUOiBvZmZlciBidWZmZXJzIGZvciBmYWNlIG5vcm1hbHMgYW5kIHRoZWlyIHRyYW5zZm9ybWF0aW9uXHJcbiAgI2lmIGRlZmluZWQoRkxBVClcclxuaW4gdmVjMyBhX3ZjdFBvc2l0aW9uRmxhdDtcclxuaW4gdmVjMyBhX3ZjdE5vcm1hbEZhY2U7XHJcbnVuaWZvcm0gbWF0NCB1X210eE5vcm1hbE1lc2hUb1dvcmxkO1xyXG5mbGF0IG91dCB2ZWM0IHZfdmN0Q29sb3I7XHJcbiAgI2Vsc2VcclxuICAvLyByZWd1bGFyIGlmIG5vdCBGTEFUXHJcbmluIHZlYzMgYV92Y3RQb3NpdGlvbjtcclxub3V0IHZlYzQgdl92Y3RDb2xvcjtcclxuICAjZW5kaWZcclxuXHJcbiAgLy8gTElHSFQ6IG9mZmVyIGJ1ZmZlcnMgZm9yIGxpZ2h0aW5nIHZlcnRpY2VzIHdpdGggZGlmZmVyZW50IGxpZ2h0IHR5cGVzXHJcbiAgI2lmIGRlZmluZWQoTElHSFQpXHJcbnN0cnVjdCBMaWdodEFtYmllbnQge1xyXG4gIHZlYzQgdmN0Q29sb3I7XHJcbn07XHJcbnN0cnVjdCBMaWdodERpcmVjdGlvbmFsIHtcclxuICB2ZWM0IHZjdENvbG9yO1xyXG4gIHZlYzMgdmN0RGlyZWN0aW9uO1xyXG59O1xyXG5cclxuY29uc3QgdWludCBNQVhfTElHSFRTX0RJUkVDVElPTkFMID0gMTAwdTtcclxuXHJcbnVuaWZvcm0gTGlnaHRBbWJpZW50IHVfYW1iaWVudDtcclxudW5pZm9ybSB1aW50IHVfbkxpZ2h0c0RpcmVjdGlvbmFsO1xyXG51bmlmb3JtIExpZ2h0RGlyZWN0aW9uYWwgdV9kaXJlY3Rpb25hbFtNQVhfTElHSFRTX0RJUkVDVElPTkFMXTtcclxuICAjZW5kaWYgXHJcblxyXG4gIC8vIFRFWFRVUkU6IG9mZmVyIGJ1ZmZlcnMgZm9yIFVWcyBhbmQgcGl2b3QgbWF0cml4XHJcbiAgI2lmIGRlZmluZWQoVEVYVFVSRSlcclxudW5pZm9ybSBtYXQzIHVfbXR4UGl2b3Q7XHJcbmluIHZlYzIgYV92Y3RUZXh0dXJlO1xyXG5vdXQgdmVjMiB2X3ZjdFRleHR1cmU7XHJcbiAgI2VuZGlmXHJcblxyXG4gICNpZiBkZWZpbmVkKE1BVENBUCkgLy8gTWF0Q2FwLXNoYWRlciBnZW5lcmF0ZXMgdGV4dHVyZSBjb29yZGluYXRlcyBmcm9tIHN1cmZhY2Ugbm9ybWFsc1xyXG5vdXQgdmVjMiB2X3ZjdFRleHR1cmU7XHJcbiAgI2VuZGlmXHJcblxyXG4gIC8vIEdPVVJBVUQ6IG9mZmVyIGJ1ZmZlcnMgZm9yIHZlcnRleCBub3JtYWxzLCB0aGVpciB0cmFuc2Zvcm1hdGlvbiBhbmQgdGhlIHNoaW5pbmVzc1xyXG4gICNpZiBkZWZpbmVkKEdPVVJBVUQpfHxkZWZpbmVkKE1BVENBUClcclxuaW4gdmVjMyBhX3ZjdE5vcm1hbFZlcnRleDtcclxudW5pZm9ybSBtYXQ0IHVfbXR4Tm9ybWFsTWVzaFRvV29ybGQ7XHJcbiAgI2VuZGlmXHJcblxyXG4gIC8vIENBTUVSQTogb2ZmZXIgYnVmZmVyIGFuZCBmdW5jdGlvbmFsaXR5IGZvciBzcGVjdWxhciByZWZsZWN0aW9uIGRlcGVuZGluZyBvbiB0aGUgY2FtZXJhLXBvc2l0aW9uXHJcbiAgI2lmIGRlZmluZWQoQ0FNRVJBKVxyXG51bmlmb3JtIGZsb2F0IHVfZlNoaW5pbmVzcztcclxudW5pZm9ybSBtYXQ0IHVfbXR4TWVzaFRvV29ybGQ7XHJcbnVuaWZvcm0gbWF0NCB1X210eFdvcmxkVG9WaWV3O1xyXG51bmlmb3JtIHZlYzMgdV92Y3RDYW1lcmE7XHJcblxyXG5mbG9hdCBjYWxjdWxhdGVSZWZsZWN0aW9uKHZlYzMgX3ZjdExpZ2h0LCB2ZWMzIF92Y3RWaWV3LCB2ZWMzIF92Y3ROb3JtYWwsIGZsb2F0IF9mU2hpbmluZXNzKSB7XHJcbiAgaWYoX2ZTaGluaW5lc3MgPD0gMC4wKVxyXG4gICAgcmV0dXJuIDAuMDtcclxuICB2ZWMzIHZjdFJlZmxlY3Rpb24gPSBub3JtYWxpemUocmVmbGVjdCgtX3ZjdExpZ2h0LCBfdmN0Tm9ybWFsKSk7XHJcbiAgZmxvYXQgZlNjcGVjdWxhciA9IGRvdCh2Y3RSZWZsZWN0aW9uLCBfdmN0Vmlldyk7XHJcbiAgcmV0dXJuIHBvdyhtYXgoZlNjcGVjdWxhciwgMC4wKSwgX2ZTaGluaW5lc3MgKiAxMC4wKSAqIF9mU2hpbmluZXNzO1xyXG4gIC8vIHJldHVybiBtYXgoc3BlY19kb3QsIDAuMCkgKiBzaGluaW5lc3M7XHJcbn1cclxuICAjZW5kaWZcclxuXHJcbnZvaWQgbWFpbigpIHtcclxuICB2ZWM0IHZjdFBvc2l0aW9uO1xyXG5cclxuICAgICNpZiBkZWZpbmVkKEZMQVQpXHJcbiAgICAvLyBGTEFUOiB1c2UgdGhlIHNwZWNpYWwgdmVydGV4IGFuZCBub3JtYWwgYnVmZmVycyBmb3IgZmxhdCBzaGFkaW5nXHJcbiAgdmN0UG9zaXRpb24gPSB2ZWM0KGFfdmN0UG9zaXRpb25GbGF0LCAxLjApO1xyXG4gIHZlYzMgdmN0Tm9ybWFsID0gbm9ybWFsaXplKG1hdDModV9tdHhOb3JtYWxNZXNoVG9Xb3JsZCkgKiBhX3ZjdE5vcm1hbEZhY2UpO1xyXG4gIHZfdmN0Q29sb3IgPSB1X2FtYmllbnQudmN0Q29sb3I7XHJcbiAgICAjZWxzZSBcclxuICB2Y3RQb3NpdGlvbiA9IHZlYzQoYV92Y3RQb3NpdGlvbiwgMS4wKTtcclxuICAgICNlbmRpZlxyXG5cclxuICAgIC8vIHVzZSB0aGUgcmVndWxhciB2ZXJ0ZXggYnVmZmVyXHJcbiAgZ2xfUG9zaXRpb24gPSB1X210eE1lc2hUb1ZpZXcgKiB2Y3RQb3NpdGlvbjtcclxuXHJcbiAgICAvLyBHT1VSQVVEOiB1c2UgdGhlIHZlcnRleCBub3JtYWxzXHJcbiAgICAjaWYgZGVmaW5lZChHT1VSQVVEKVxyXG4gIHZfdmN0Q29sb3IgPSB1X2FtYmllbnQudmN0Q29sb3I7XHJcbiAgdmVjMyB2Y3ROb3JtYWwgPSBub3JtYWxpemUobWF0Myh1X210eE5vcm1hbE1lc2hUb1dvcmxkKSAqIGFfdmN0Tm9ybWFsVmVydGV4KTtcclxuICAgICNlbmRpZlxyXG5cclxuICAgICNpZiBkZWZpbmVkKENBTUVSQSlcclxuICAvLyB2aWV3IHZlY3RvciBuZWVkZWRcclxuICAvLyB2ZWM0IHBvc1dvcmxkNCA9IHVfbXR4TWVzaFRvV29ybGQgKiB2Y3RQb3NpdGlvbjtcclxuICAvLyB2ZWMzIHZjdFZpZXcgPSBub3JtYWxpemUocG9zV29ybGQ0Lnh5ei9wb3NXb3JsZDQudyAtIHVfdmN0Q2FtZXJhKTtcclxuICB2ZWMzIHZjdFZpZXcgPSBub3JtYWxpemUodmVjMyh1X210eE1lc2hUb1dvcmxkICogdmN0UG9zaXRpb24pIC0gdV92Y3RDYW1lcmEpO1xyXG4gICAgI2VuZGlmXHJcblxyXG4gICAgI2lmIGRlZmluZWQoTElHSFQpXHJcbiAgLy8gY2FsY3VsYXRlIHRoZSBkaXJlY3Rpb25hbCBsaWdodGluZyBlZmZlY3RcclxuICBmb3IodWludCBpID0gMHU7IGkgPCB1X25MaWdodHNEaXJlY3Rpb25hbDsgaSsrKSB7XHJcbiAgICBmbG9hdCBmSWxsdW1pbmF0aW9uID0gLWRvdCh2Y3ROb3JtYWwsIHVfZGlyZWN0aW9uYWxbaV0udmN0RGlyZWN0aW9uKTtcclxuICAgIGlmKGZJbGx1bWluYXRpb24gPiAwLjBmKSB7XHJcbiAgICAgIHZfdmN0Q29sb3IgKz0gZklsbHVtaW5hdGlvbiAqIHVfZGlyZWN0aW9uYWxbaV0udmN0Q29sb3I7XHJcbiAgICAgICAgI2lmIGRlZmluZWQoQ0FNRVJBKVxyXG4gICAgICBmbG9hdCBmUmVmbGVjdGlvbiA9IGNhbGN1bGF0ZVJlZmxlY3Rpb24odV9kaXJlY3Rpb25hbFtpXS52Y3REaXJlY3Rpb24sIHZjdFZpZXcsIHZjdE5vcm1hbCwgdV9mU2hpbmluZXNzKTtcclxuICAgICAgdl92Y3RDb2xvciArPSBmUmVmbGVjdGlvbiAqIHVfZGlyZWN0aW9uYWxbaV0udmN0Q29sb3I7XHJcbiAgICAgICAgI2VuZGlmXHJcbiAgICB9XHJcbiAgfVxyXG4gICAgI2VuZGlmXHJcblxyXG4gICAgLy8gVEVYVFVSRTogdHJhbnNmb3JtIFVWc1xyXG4gICAgI2lmIGRlZmluZWQoVEVYVFVSRSlcclxuICB2X3ZjdFRleHR1cmUgPSB2ZWMyKHVfbXR4UGl2b3QgKiB2ZWMzKGFfdmN0VGV4dHVyZSwgMS4wKSkueHk7XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAjaWYgZGVmaW5lZChNQVRDQVApXHJcbiAgdmVjMyB2Y3ROb3JtYWwgPSBub3JtYWxpemUobWF0Myh1X210eE5vcm1hbE1lc2hUb1dvcmxkKSAqIGFfdmN0Tm9ybWFsVmVydGV4KTtcclxuICB2Y3ROb3JtYWwgPSBtYXQzKHVfbXR4V29ybGRUb1ZpZXcpICogdmN0Tm9ybWFsO1xyXG4gIHZfdmN0VGV4dHVyZSA9IDAuNSAqIHZjdE5vcm1hbC54eSAvIGxlbmd0aCh2Y3ROb3JtYWwpICsgMC41O1xyXG4gIHZfdmN0VGV4dHVyZS55ICo9IC0xLjA7XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAvLyBhbHdheXMgZnVsbCBvcGFjaXR5IGZvciBub3cuLi5cclxuICB2X3ZjdENvbG9yLmEgPSAxLjA7XHJcbn1cbmA7IH1cblxuICBwdWJsaWMgc3RhdGljIGdldEZyYWdtZW50U2hhZGVyU291cmNlKCk6IHN0cmluZyB7IFxucmV0dXJuIGAjdmVyc2lvbiAzMDAgZXNcbiNkZWZpbmUgQ0FNRVJBXG4jZGVmaW5lIE1BVENBUFxuXHJcbi8qKlxyXG4qIFVuaXZlcnNhbCBTaGFkZXIgYXMgYmFzZSBmb3IgbWFueSBvdGhlcnMuIENvbnRyb2xsZWQgYnkgY29tcGlsZXIgZGlyZWN0aXZlc1xyXG4qIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxXHJcbiovXHJcblxyXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcclxuXHJcbiAgLy8gTUlOSU1BTCAobm8gZGVmaW5lIG5lZWRlZCk6IGluY2x1ZGUgYmFzZSBjb2xvclxyXG51bmlmb3JtIHZlYzQgdV92Y3RDb2xvcjtcclxuXHJcbiAgLy8gRkxBVDogaW5wdXQgdmVydGV4IGNvbG9ycyBmbGF0LCBzbyB0aGUgdGhpcmQgb2YgYSB0cmlhbmdsZSBkZXRlcm1pbmVzIHRoZSBjb2xvclxyXG4gICNpZiBkZWZpbmVkKEZMQVQpIFxyXG5mbGF0IGluIHZlYzQgdl92Y3RDb2xvcjtcclxuICAvLyBMSUdIVDogaW5wdXQgdmVydGV4IGNvbG9ycyBmb3IgZWFjaCB2ZXJ0ZXggZm9yIGludGVycG9sYXRpb24gb3ZlciB0aGUgZmFjZVxyXG4gICNlbGlmIGRlZmluZWQoTElHSFQpXHJcbmluIHZlYzQgdl92Y3RDb2xvcjtcclxuICAjZW5kaWZcclxuXHJcbiAgLy8gVEVYVFVSRTogaW5wdXQgVVZzIGFuZCB0ZXh0dXJlXHJcbiAgI2lmIGRlZmluZWQoVEVYVFVSRSkgfHwgZGVmaW5lZChNQVRDQVApXHJcbmluIHZlYzIgdl92Y3RUZXh0dXJlO1xyXG51bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XHJcbiAgI2VuZGlmXHJcblxyXG5vdXQgdmVjNCB2Y3RGcmFnO1xyXG5cclxudm9pZCBtYWluKCkge1xyXG4gICAgLy8gTUlOSU1BTDogc2V0IHRoZSBiYXNlIGNvbG9yXHJcbiAgdmN0RnJhZyA9IHVfdmN0Q29sb3I7XHJcblxyXG4gICAgLy8gVkVSVEVYOiBtdWx0aXBseSB3aXRoIHZlcnRleCBjb2xvclxyXG4gICAgI2lmIGRlZmluZWQoRkxBVCkgfHwgZGVmaW5lZChMSUdIVClcclxuICB2Y3RGcmFnICo9IHZfdmN0Q29sb3I7XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAvLyBURVhUVVJFOiBtdWx0aXBseSB3aXRoIHRleGVsIGNvbG9yXHJcbiAgICAjaWYgZGVmaW5lZChURVhUVVJFKSB8fCBkZWZpbmVkKE1BVENBUClcclxuICB2ZWM0IHZjdENvbG9yVGV4dHVyZSA9IHRleHR1cmUodV90ZXh0dXJlLCB2X3ZjdFRleHR1cmUpO1xyXG4gIHZjdEZyYWcgKj0gdmN0Q29sb3JUZXh0dXJlO1xyXG4gICAgI2VuZGlmXHJcblxyXG4gICAgLy8gZGlzY2FyZCBwaXhlbCBhbGx0b2dldGhlciB3aGVuIHRyYW5zcGFyZW50OiBkb24ndCBzaG93IGluIFotQnVmZmVyXHJcbiAgaWYodmN0RnJhZy5hIDwgMC4wMSlcclxuICAgIGRpc2NhcmQ7XHJcbn1cbmA7IH1cbn1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbi8qKiBDb2RlIGdlbmVyYXRlZCBieSBDb21waWxlU2hhZGVycy5tanMgdXNpbmcgdGhlIGluZm9ybWF0aW9uIGluIENvbXBpbGVTaGFkZXJzLmpzb24gKi9cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYWRlclBob25nIGV4dGVuZHMgU2hhZGVyIHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IFNoYWRlci5yZWdpc3RlclN1YmNsYXNzKFNoYWRlclBob25nKTtcblxuICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQgeyByZXR1cm4gQ29hdENvbG9yZWQ7IH1cblxuICBwdWJsaWMgc3RhdGljIGdldFZlcnRleFNoYWRlclNvdXJjZSgpOiBzdHJpbmcgeyBcbnJldHVybiBgI3ZlcnNpb24gMzAwIGVzXHJcbi8qKlxyXG4qIFBob25nIHNoYWRpbmdcclxuKiBJbXBsZW1lbnRhdGlvbiBiYXNlZCBvbiBodHRwczovL3d3dy5nc24tbGliLm9yZy9kb2NzL25vZGVzL1NoYWRlclBsdWdpbk5vZGUucGhwXHJcbiogQGF1dGhvcnMgTHVpcyBLZWNrLCBIRlUsIDIwMjFcclxuKi9cclxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xyXG5cclxuaW4gdmVjMyBhX3ZjdFBvc2l0aW9uO1xyXG5pbiB2ZWMzIGFfdmN0Tm9ybWFsVmVydGV4O1xyXG51bmlmb3JtIG1hdDQgdV9tdHhNZXNoVG9Xb3JsZDtcclxudW5pZm9ybSBtYXQ0IHVfbXR4TWVzaFRvVmlldztcclxudW5pZm9ybSBtYXQ0IHVfbXR4Tm9ybWFsTWVzaFRvV29ybGQ7XHJcblxyXG5vdXQgdmVjMyBmX25vcm1hbDtcclxub3V0IHZlYzMgdl9wb3NpdGlvbjtcclxuXHJcbnZvaWQgbWFpbigpIHtcclxuICBmX25vcm1hbCA9IHZlYzModV9tdHhOb3JtYWxNZXNoVG9Xb3JsZCAqIHZlYzQoYV92Y3ROb3JtYWxWZXJ0ZXgsIDAuMCkpO1xyXG4gIHZlYzQgdl9wb3NpdGlvbjQgPSB1X210eE1lc2hUb1dvcmxkICogdmVjNChhX3ZjdFBvc2l0aW9uLCAxLjApO1xyXG4gIHZfcG9zaXRpb24gPSB2ZWMzKHZfcG9zaXRpb240KSAvIHZfcG9zaXRpb240Lnc7XHJcbiAgZ2xfUG9zaXRpb24gPSB1X210eE1lc2hUb1ZpZXcgKiB2ZWM0KGFfdmN0UG9zaXRpb24sIDEuMCk7XHJcbn1cclxuICAgICAgICBcbmA7IH1cblxuICBwdWJsaWMgc3RhdGljIGdldEZyYWdtZW50U2hhZGVyU291cmNlKCk6IHN0cmluZyB7IFxucmV0dXJuIGAjdmVyc2lvbiAzMDAgZXNcclxuLyoqXHJcbiogUGhvbmcgc2hhZGluZ1xyXG4qIEltcGxlbWVudGF0aW9uIGJhc2VkIG9uIGh0dHBzOi8vd3d3Lmdzbi1saWIub3JnL2RvY3Mvbm9kZXMvU2hhZGVyUGx1Z2luTm9kZS5waHBcclxuKiBAYXV0aG9ycyBMdWlzIEtlY2ssIEhGVSwgMjAyMVxyXG4qL1xyXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XHJcblxyXG5zdHJ1Y3QgTGlnaHRBbWJpZW50IHtcclxuICAgIHZlYzQgY29sb3I7XHJcbn07XHJcbnN0cnVjdCBMaWdodERpcmVjdGlvbmFsIHtcclxuICAgIHZlYzQgY29sb3I7XHJcbiAgICB2ZWMzIGRpcmVjdGlvbjtcclxufTtcclxuXHJcbmNvbnN0IHVpbnQgTUFYX0xJR0hUU19ESVJFQ1RJT05BTCA9IDEwMHU7XHJcbnVuaWZvcm0gTGlnaHRBbWJpZW50IHVfYW1iaWVudDtcclxudW5pZm9ybSB1aW50IHVfbkxpZ2h0c0RpcmVjdGlvbmFsO1xyXG51bmlmb3JtIExpZ2h0RGlyZWN0aW9uYWwgdV9kaXJlY3Rpb25hbFtNQVhfTElHSFRTX0RJUkVDVElPTkFMXTtcclxuXHJcbmluIHZlYzMgZl9ub3JtYWw7XHJcbmluIHZlYzMgdl9wb3NpdGlvbjtcclxudW5pZm9ybSB2ZWM0IHVfdmN0Q29sb3I7XHJcbnVuaWZvcm0gZmxvYXQgdV9mU2hpbmluZXNzO1xyXG5vdXQgdmVjNCB2Y3RGcmFnO1xyXG5cclxudmVjMyBjYWxjdWxhdGVSZWZsZWN0aW9uKHZlYzMgbGlnaHRfZGlyLCB2ZWMzIHZpZXdfZGlyLCB2ZWMzIG5vcm1hbCwgZmxvYXQgc2hpbmluZXNzKSB7XHJcbiAgICB2ZWMzIGNvbG9yID0gdmVjMygxKTtcclxuICAgIHZlYzMgUiA9IHJlZmxlY3QoLWxpZ2h0X2Rpciwgbm9ybWFsKTtcclxuICAgIGZsb2F0IHNwZWNfZG90ID0gbWF4KGRvdChSLCB2aWV3X2RpciksIDAuMCk7XHJcbiAgICBjb2xvciArPSBwb3coc3BlY19kb3QsIHNoaW5pbmVzcyk7XHJcbiAgICByZXR1cm4gY29sb3I7XHJcbn1cclxuXHJcbnZvaWQgbWFpbigpIHtcclxuICAgIHZjdEZyYWcgPSB1X2FtYmllbnQuY29sb3I7XHJcbiAgICBmb3IodWludCBpID0gMHU7IGkgPCB1X25MaWdodHNEaXJlY3Rpb25hbDsgaSsrKSB7XHJcbiAgICAgICAgdmVjMyBsaWdodF9kaXIgPSBub3JtYWxpemUoLXVfZGlyZWN0aW9uYWxbaV0uZGlyZWN0aW9uKTtcclxuICAgICAgICB2ZWMzIHZpZXdfZGlyID0gbm9ybWFsaXplKHZfcG9zaXRpb24pO1xyXG4gICAgICAgIHZlYzMgTiA9IG5vcm1hbGl6ZShmX25vcm1hbCk7XHJcblxyXG4gICAgICAgIGZsb2F0IGlsbHVtaW5hbmNlID0gZG90KGxpZ2h0X2RpciwgTik7XHJcbiAgICAgICAgaWYoaWxsdW1pbmFuY2UgPiAwLjApIHtcclxuICAgICAgICAgICAgdmVjMyByZWZsZWN0aW9uID0gY2FsY3VsYXRlUmVmbGVjdGlvbihsaWdodF9kaXIsIHZpZXdfZGlyLCBOLCB1X2ZTaGluaW5lc3MpO1xyXG4gICAgICAgICAgICB2Y3RGcmFnICs9IHZlYzQocmVmbGVjdGlvbiwgMS4wKSAqIGlsbHVtaW5hbmNlICogdV9kaXJlY3Rpb25hbFtpXS5jb2xvcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2Y3RGcmFnICo9IHVfdmN0Q29sb3I7XHJcbiAgICB2Y3RGcmFnLmEgPSAxLjA7XHJcbn0gICAgICAgXG5gOyB9XG59XG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4vKiogQ29kZSBnZW5lcmF0ZWQgYnkgQ29tcGlsZVNoYWRlcnMubWpzIHVzaW5nIHRoZSBpbmZvcm1hdGlvbiBpbiBDb21waWxlU2hhZGVycy5qc29uICovXG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJQaWNrIGV4dGVuZHMgU2hhZGVyIHtcbiAgcHVibGljIHN0YXRpYyBnZXRWZXJ0ZXhTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHsgXG5yZXR1cm4gYCN2ZXJzaW9uIDMwMCBlc1xyXG4vKipcclxuKiBSZW5kZXJzIGZvciBSYXljYXN0aW5nXHJcbiogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuKi9cclxuaW4gdmVjMyBhX3ZjdFBvc2l0aW9uOyAgICAgICBcclxudW5pZm9ybSBtYXQ0IHVfbXR4TWVzaFRvVmlldztcclxuXHJcbnZvaWQgbWFpbigpIHsgICBcclxuICAgIGdsX1Bvc2l0aW9uID0gdV9tdHhNZXNoVG9WaWV3ICogdmVjNChhX3ZjdFBvc2l0aW9uLCAxLjApO1xyXG59XG5gOyB9XG5cbiAgcHVibGljIHN0YXRpYyBnZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpOiBzdHJpbmcgeyBcbnJldHVybiBgI3ZlcnNpb24gMzAwIGVzXHJcbi8qKlxyXG4qIFJlbmRlcnMgZm9yIFJheWNhc3RpbmdcclxuKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4qL1xyXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcclxucHJlY2lzaW9uIGhpZ2hwIGludDtcclxuXHJcbnVuaWZvcm0gaW50IHVfaWQ7XHJcbnVuaWZvcm0gdmVjMiB1X3ZjdFNpemU7XHJcbnVuaWZvcm0gdmVjNCB1X3ZjdENvbG9yO1xyXG5vdXQgaXZlYzQgdmN0RnJhZztcclxuXHJcbnZvaWQgbWFpbigpIHtcclxuICAgIGZsb2F0IGlkID0gZmxvYXQodV9pZCk7IFxyXG4gICAgZmxvYXQgcGl4ZWwgPSB0cnVuYyhnbF9GcmFnQ29vcmQueCkgKyB1X3ZjdFNpemUueCAqIHRydW5jKGdsX0ZyYWdDb29yZC55KTtcclxuXHJcbiAgICBpZiAocGl4ZWwgIT0gaWQpXHJcbiAgICAgIGRpc2NhcmQ7XHJcblxyXG4gICAgdWludCBpY29sb3IgPSB1aW50KHVfdmN0Q29sb3IuciAqIDI1NS4wKSA8PCAyNCB8IHVpbnQodV92Y3RDb2xvci5nICogMjU1LjApIDw8IDE2IHwgdWludCh1X3ZjdENvbG9yLmIgKiAyNTUuMCkgPDwgOCB8IHVpbnQodV92Y3RDb2xvci5hICogMjU1LjApO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICB2Y3RGcmFnID0gaXZlYzQoZmxvYXRCaXRzVG9JbnQoZ2xfRnJhZ0Nvb3JkLnopLCBpY29sb3IsIDAsIDApO1xyXG59XG5gOyB9XG59XG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4vKiogQ29kZSBnZW5lcmF0ZWQgYnkgQ29tcGlsZVNoYWRlcnMubWpzIHVzaW5nIHRoZSBpbmZvcm1hdGlvbiBpbiBDb21waWxlU2hhZGVycy5qc29uICovXG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJQaWNrVGV4dHVyZWQgZXh0ZW5kcyBTaGFkZXIge1xuICBwdWJsaWMgc3RhdGljIGdldFZlcnRleFNoYWRlclNvdXJjZSgpOiBzdHJpbmcgeyBcbnJldHVybiBgI3ZlcnNpb24gMzAwIGVzXHJcbi8qKlxyXG4qIFJlbmRlcnMgZm9yIFJheWNhc3RpbmdcclxuKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4qL1xyXG5pbiB2ZWMzIGFfdmN0UG9zaXRpb247ICAgICAgIFxyXG5pbiB2ZWMyIGFfdmN0VGV4dHVyZTtcclxudW5pZm9ybSBtYXQ0IHVfbXR4TWVzaFRvVmlldztcclxudW5pZm9ybSBtYXQzIHVfbXR4UGl2b3Q7XHJcblxyXG5vdXQgdmVjMiB2X3ZjdFRleHR1cmU7XHJcblxyXG52b2lkIG1haW4oKSB7ICAgXHJcbiAgICBnbF9Qb3NpdGlvbiA9IHVfbXR4TWVzaFRvVmlldyAqIHZlYzQoYV92Y3RQb3NpdGlvbiwgMS4wKTtcclxuICAgIHZfdmN0VGV4dHVyZSA9IHZlYzIodV9tdHhQaXZvdCAqIHZlYzMoYV92Y3RUZXh0dXJlLCAxLjApKS54eTtcclxufVxuYDsgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHsgXG5yZXR1cm4gYCN2ZXJzaW9uIDMwMCBlc1xyXG4vKipcclxuKiBSZW5kZXJzIGZvciBSYXljYXN0aW5nXHJcbiogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuKi9cclxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XHJcbnByZWNpc2lvbiBoaWdocCBpbnQ7XHJcblxyXG51bmlmb3JtIGludCB1X2lkO1xyXG51bmlmb3JtIHZlYzIgdV92Y3RTaXplO1xyXG5pbiB2ZWMyIHZfdmN0VGV4dHVyZTtcclxudW5pZm9ybSB2ZWM0IHVfdmN0Q29sb3I7XHJcbnVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcclxuXHJcbm91dCBpdmVjNCB2Y3RGcmFnO1xyXG5cclxudm9pZCBtYWluKCkge1xyXG4gICAgZmxvYXQgaWQgPSBmbG9hdCh1X2lkKTsgXHJcbiAgICBmbG9hdCBwaXhlbCA9IHRydW5jKGdsX0ZyYWdDb29yZC54KSArIHVfdmN0U2l6ZS54ICogdHJ1bmMoZ2xfRnJhZ0Nvb3JkLnkpO1xyXG5cclxuICAgIGlmIChwaXhlbCAhPSBpZClcclxuICAgICAgZGlzY2FyZDtcclxuICAgIFxyXG4gICAgdmVjNCB2Y3RDb2xvciA9IHVfdmN0Q29sb3IgKiB0ZXh0dXJlKHVfdGV4dHVyZSwgdl92Y3RUZXh0dXJlKTtcclxuICAgIHVpbnQgaWNvbG9yID0gdWludCh2Y3RDb2xvci5yICogMjU1LjApIDw8IDI0IHwgdWludCh2Y3RDb2xvci5nICogMjU1LjApIDw8IDE2IHwgdWludCh2Y3RDb2xvci5iICogMjU1LjApIDw8IDggfCB1aW50KHZjdENvbG9yLmEgKiAyNTUuMCk7XHJcbiAgXHJcbiAgdmN0RnJhZyA9IGl2ZWM0KGZsb2F0Qml0c1RvSW50KGdsX0ZyYWdDb29yZC56KSwgaWNvbG9yLCBmbG9hdEJpdHNUb0ludCh2X3ZjdFRleHR1cmUueCksIGZsb2F0Qml0c1RvSW50KHZfdmN0VGV4dHVyZS55KSk7XHJcbn1cbmA7IH1cbn1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgZW51bSBNSVBNQVAge1xyXG4gICAgQ1JJU1AsIE1FRElVTSwgQkxVUlJZXHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEJhc2VjbGFzcyBmb3IgZGlmZmVyZW50IGtpbmRzIG9mIHRleHR1cmVzLiBcclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIEBSZW5kZXJJbmplY3RvclRleHR1cmUuZGVjb3JhdGVcclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgVGV4dHVyZSBleHRlbmRzIE11dGFibGUgaW1wbGVtZW50cyBTZXJpYWxpemFibGVSZXNvdXJjZSB7XHJcbiAgICBwdWJsaWMgbmFtZTogc3RyaW5nO1xyXG4gICAgcHVibGljIGlkUmVzb3VyY2U6IHN0cmluZyA9IHVuZGVmaW5lZDtcclxuICAgIHB1YmxpYyBtaXBtYXA6IE1JUE1BUCA9IE1JUE1BUC5DUklTUDtcclxuICAgIHByb3RlY3RlZCByZW5kZXJEYXRhOiB7IFtrZXk6IHN0cmluZ106IHVua25vd24gfTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nID0gXCJUZXh0dXJlXCIpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5uYW1lID0gX25hbWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFic3RyYWN0IGdldCB0ZXhJbWFnZVNvdXJjZSgpOiBUZXhJbWFnZVNvdXJjZTtcclxuICAgIHB1YmxpYyB1c2VSZW5kZXJEYXRhKCk6IHZvaWQgey8qIGluamVjdGVkIGJ5IFJlbmRlckluamVjdG9yKi8gfVxyXG5cclxuICAgIHB1YmxpYyByZWZyZXNoKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLnJlbmRlckRhdGEgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgaWRSZXNvdXJjZTogdGhpcy5pZFJlc291cmNlLFxyXG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICBtaXBtYXA6IE1JUE1BUFt0aGlzLm1pcG1hcF1cclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBQcm9qZWN0LnJlZ2lzdGVyKHRoaXMsIF9zZXJpYWxpemF0aW9uLmlkUmVzb3VyY2UpO1xyXG4gICAgICB0aGlzLm5hbWUgPSBfc2VyaWFsaXphdGlvbi5uYW1lO1xyXG4gICAgICB0aGlzLm1pcG1hcCA9IDxudW1iZXI+PHVua25vd24+TUlQTUFQW19zZXJpYWxpemF0aW9uLm1pcG1hcF07XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yQXR0cmlidXRlVHlwZXMoX211dGF0b3I6IE11dGF0b3IpOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMge1xyXG4gICAgICBsZXQgdHlwZXM6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyA9IHN1cGVyLmdldE11dGF0b3JBdHRyaWJ1dGVUeXBlcyhfbXV0YXRvcik7XHJcbiAgICAgIGlmICh0eXBlcy5taXBtYXApXHJcbiAgICAgICAgdHlwZXMubWlwbWFwID0gTUlQTUFQO1xyXG4gICAgICByZXR1cm4gdHlwZXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLmlkUmVzb3VyY2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUZXh0dXJlIGNyZWF0ZWQgZnJvbSBhbiBleGlzdGluZyBpbWFnZVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBUZXh0dXJlSW1hZ2UgZXh0ZW5kcyBUZXh0dXJlIHtcclxuICAgIHB1YmxpYyBpbWFnZTogSFRNTEltYWdlRWxlbWVudCA9IG51bGw7XHJcbiAgICBwdWJsaWMgdXJsOiBSZXF1ZXN0SW5mbztcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihfdXJsPzogUmVxdWVzdEluZm8pIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgaWYgKF91cmwpIHtcclxuICAgICAgICB0aGlzLmxvYWQoX3VybCk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gX3VybC50b1N0cmluZygpLnNwbGl0KFwiL1wiKS5wb3AoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgUHJvamVjdC5yZWdpc3Rlcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHRleEltYWdlU291cmNlKCk6IFRleEltYWdlU291cmNlIHtcclxuICAgICAgcmV0dXJuIHRoaXMuaW1hZ2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBc3luY2hyb25vdXNseSBsb2FkcyB0aGUgaW1hZ2UgZnJvbSB0aGUgZ2l2ZW4gdXJsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBsb2FkKF91cmw6IFJlcXVlc3RJbmZvKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIHRoaXMudXJsID0gX3VybDtcclxuICAgICAgdGhpcy5pbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAvLyBjb25zdCByZXNwb25zZTogUmVzcG9uc2UgPSBhd2FpdCB3aW5kb3cuZmV0Y2godGhpcy51cmwpO1xyXG4gICAgICAvLyBjb25zdCBibG9iOiBCbG9iID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xyXG4gICAgICAvLyBsZXQgb2JqZWN0VVJMOiBzdHJpbmcgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xyXG4gICAgICAvLyB0aGlzLmltYWdlLnNyYyA9IG9iamVjdFVSTDtcclxuXHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgdGhpcy5pbWFnZS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLnJlbmRlckRhdGEgPSBudWxsOyAvLyByZWZyZXNoIHJlbmRlciBkYXRhIG9uIG5leHQgZHJhdyBjYWxsXHJcbiAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5pbWFnZS5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgKCkgPT4gcmVqZWN0KCkpO1xyXG4gICAgICAgIHRoaXMuaW1hZ2Uuc3JjID0gbmV3IFVSTCh0aGlzLnVybC50b1N0cmluZygpLCBQcm9qZWN0LmJhc2VVUkwpLnRvU3RyaW5nKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB1cmw6IHRoaXMudXJsLFxyXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSwgLy8gc2VyaWFsaXplIGZvciBlZGl0b3Igdmlld3NcclxuICAgICAgICBbc3VwZXIuY29uc3RydWN0b3IubmFtZV06IHN1cGVyLnNlcmlhbGl6ZSgpXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XHJcbiAgICAgIGF3YWl0IHRoaXMubG9hZChfc2VyaWFsaXphdGlvbi51cmwpO1xyXG4gICAgICAvLyB0aGlzLnR5cGUgaXMgYW4gYWNjZXNzb3Igb2YgTXV0YWJsZSBkb2Vzbid0IG5lZWQgdG8gYmUgZGVzZXJpYWxpemVkXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgaWYgKF9tdXRhdG9yLnVybCAhPSB0aGlzLnVybC50b1N0cmluZygpKVxyXG4gICAgICAgIGF3YWl0IHRoaXMubG9hZChfbXV0YXRvci51cmwpO1xyXG4gICAgICAvLyBleGNlcHQgdXJsIGZyb20gbXV0YXRvciBmb3IgZnVydGhlciBwcm9jZXNzaW5nXHJcbiAgICAgIGRlbGV0ZSAoX211dGF0b3IudXJsKTtcclxuICAgICAgc3VwZXIubXV0YXRlKF9tdXRhdG9yKTtcclxuICAgICAgLy8gVE9ETzogZXhhbWluZSBuZWNlc3NpdHkgdG8gcmVjb25zdHJ1Y3QsIGlmIG11dGF0b3IgaXMga2VwdCBieSBjYWxsZXJcclxuICAgICAgLy8gX211dGF0b3IudXJsID0gdGhpcy51cmw7IFxyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUZXh0dXJlIGNyZWF0ZWQgZnJvbSBhIGNhbnZhc1xyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBUZXh0dXJlQmFzZTY0IGV4dGVuZHMgVGV4dHVyZSB7XHJcbiAgICBwdWJsaWMgaW1hZ2U6IEhUTUxJbWFnZUVsZW1lbnQgPSBuZXcgSW1hZ2UoKTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nLCBfYmFzZTY0OiBzdHJpbmcsIF9taXBtYXA6IE1JUE1BUCA9IE1JUE1BUC5DUklTUCkge1xyXG4gICAgICBzdXBlcihfbmFtZSk7XHJcbiAgICAgIHRoaXMuaW1hZ2Uuc3JjID0gX2Jhc2U2NDtcclxuICAgICAgdGhpcy5taXBtYXAgPSBfbWlwbWFwO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGdldCB0ZXhJbWFnZVNvdXJjZSgpOiBUZXhJbWFnZVNvdXJjZSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmltYWdlO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKipcclxuICAgKiBUZXh0dXJlIGNyZWF0ZWQgZnJvbSBhIGNhbnZhc1xyXG4gICAqL1xyXG4gIC8vIFRPRE86IHJlbW92ZSB0eXBlIGZpeGVzIHdoZW4gZXhwZXJpbWVudGFsIHRlY2hub2xvZ3kgaXMgc3RhbmRhcmRcclxuICB0eXBlIE9mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCA9IEdlbmVyYWw7XHJcbiAgdHlwZSBPZmZzY3JlZW5DYW52YXMgPSBHZW5lcmFsO1xyXG5cclxuICBleHBvcnQgY2xhc3MgVGV4dHVyZUNhbnZhcyBleHRlbmRzIFRleHR1cmUge1xyXG4gICAgcHVibGljIGNyYzI6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCB8IE9mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nLCBfY3JjMjogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIHwgT2Zmc2NyZWVuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XHJcbiAgICAgIHN1cGVyKF9uYW1lKTtcclxuICAgICAgdGhpcy5jcmMyID0gX2NyYzI7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgZ2V0IHRleEltYWdlU291cmNlKCk6IFRleEltYWdlU291cmNlIHtcclxuICAgICAgcmV0dXJuIDxPZmZzY3JlZW5DYW52YXM+dGhpcy5jcmMyLmNhbnZhcztcclxuICAgIH1cclxuICB9XHJcbiAgLyoqXHJcbiAgICogVGV4dHVyZSBjcmVhdGVkIGZyb20gYSBGVURHRS1Ta2V0Y2hcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgVGV4dHVyZVNrZXRjaCBleHRlbmRzIFRleHR1cmVDYW52YXMge1xyXG4gICAgcHVibGljIGdldCB0ZXhJbWFnZVNvdXJjZSgpOiBUZXhJbWFnZVNvdXJjZSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKipcclxuICAgKiBUZXh0dXJlIGNyZWF0ZWQgZnJvbSBhbiBIVE1MLXBhZ2VcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgVGV4dHVyZUhUTUwgZXh0ZW5kcyBUZXh0dXJlQ2FudmFzIHtcclxuICAgIHB1YmxpYyBnZXQgdGV4SW1hZ2VTb3VyY2UoKTogVGV4SW1hZ2VTb3VyY2Uge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgY2xhc3MgVGV4dHVyZURlZmF1bHQgZXh0ZW5kcyBUZXh0dXJlQmFzZTY0IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgdGV4dHVyZTogVGV4dHVyZUJhc2U2NCA9IG5ldyBUZXh0dXJlRGVmYXVsdChcIlRleHR1cmVEZWZhdWx0XCIsIFRleHR1cmVEZWZhdWx0LmdldCgpLCBNSVBNQVAuTUVESVVNKTtcclxuICAgIHByaXZhdGUgc3RhdGljIGdldCgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQVpBQUFBR1FDQVlBQUFDQXZ6Yk1BQUFBQVhOU1IwSUFyczRjNlFBQUFBUm5RVTFCQUFDeGp3djhZUVVBQUFBSmNFaFpjd0FBRHNNQUFBN0RBY2R2cUdRQUFEV0xTVVJCVkhoZTdkMEhuRlRsdmYveEg5dVhaWUdsOXlyU1JKcEVVZXhZc0pJYmE4UmU0OThXTmNaRWIrNDFlcE9Jc1dzME5peXhtMmcwZHV3YWV3TzdvcUpDQUduU3Q3SC84MzA0QjRkbGRwazVaM2Izek83bnpldTg1cHd6TTh2TXM3UFBiMzVQTzYxcVBCWmpyVnExOHZmaUtlYkZSL2xGUlBsRlEvbEZFL2Z5eS9GdkFRQklDd0VFQUJBS0FRUUFFQXA5SUJIUmhob041UmNONVJkTlN5Zy8vWXpDd2tKcjNicTFPMTY5ZXJYYk1vRUFFaEYvd05GUWZ0RlFmdEUwOS9MTHpjMjFMbDI2MkU5KzhoTWJQMzY4VlZkWDIrdXZ2MjdUcDA5M1FTVHEreWVBUk1RZmNEU1VYelNVWHpUTnRmeHljbktzcEtURUJnMGFaRWNlZWFRZGV1aWh0bUxGQ3Z2c3M4OXMzcng1OXZqamo5dkREejhjT1JPSkhFQ3FxcXBzOXV6WnRtelpNbHU1Y3FWTGxkcTFhMmQ5Ky9aMSsxSHhBWXlHOG91RzhvdUc4b3NtVFBubDUrZGI5KzdkYmZmZGQ3ZFRUejNWMWNYdnZ2dXV2Znp5eXk0RGtWV3JWdG1OTjk1b1M1WXNjY2RoaFE0ZzVlWGw5dXl6ejlxTUdUTnN6Wm8xL3RrZktRSXErdTI5OTk1V1dscnFuMDBmSDhCb0tMOW9LTDlvS0w5bzBpay9QYlpObXphMnhSWmIySEhISFdlVEowKzJoUXNYMnBOUFBtbUxGeS8ySDdYT2YvN3pIN3YxMWx0ZFBSNUZxQUN5WU1FQ3UrZWVlMUtLWG12WHJyWDk5dHZQUm84ZTdZSkt1dmdBUmtQNVJST1VuejY3K2lLVWw1ZG5sWldWdG56NThsaThkajUvMFRTbjhsT1QxYjc3N21zWFhIQ0JkZTdjMlY1NzdUVjc4ODAzazc3SGI3LzkxdTY0NHc2cnFLand6NFNUZGdCUnRxSFVKNGhvQ2hDZmZQS0pmZlhWVjY0OXJYMzc5alpnd0FDM0JaUXVUWm8weWJiYmJqdVhYcVdERDJBMGxGODBRZmwxN05qUmpqbm1HT3ZVcVpOOTg4MDM5c0FERDdndlVrMzkrdm44UmRPY3lxOXIxNjQyZGVwVTIzcnJyZTNSUng5MVgzSkVkYlNhc0lxTGkyM1lzR0h1WEtZQ1NOb3BnWHJ2ZytDaC9vLzc3cnZQdlZpOStKLy8vT2QyOU5GSDI5Q2hROTBMREdqNG1OSWxCWm00LzhMUXNzeWNPZE0xeGI3NjZxdEptMkpGMlVmUG5qM3QxNy8rdFUyWU1NRjIzWFZYTy9iWVkxMVFRZk0xZi81OHUrbW1tMXpmZ2ZwNDQwNzFzVjZ6UHN0QjhGQTlyQy84VHozMWxPc1h5YlMwTXBBZmZ2akJycjc2NnZVZE1VRWZpRkttL2ZmZjM4ckt5dGFuK01wR1ZQakJZL1hIcWV6anJMUE9jcDNzcWVJYlREU1VYLzMrOEljL3VNK3I2RXZRVDMvNlV6ZnNNU2czM1NxQXFGMzVtV2Vlc1d1dnZkYWRsNGNlZXNqZWUrODkvNmhwOFBtTHByN3kwNmlsSzYrODBsWE0wcjkvZnhzNWNxVDdnbHhRVU9ET05iUjB5aS80b25QRUVVZTRZNDIwZXVlZGQ5eGdwcU9PT3NwMjNIRkhOd3BMbWlRRCtlQ0REemJveFgvNzdiZGR4bkhnZ1FkYW56NTlyRzNidGk3YlVJRG8xcTJiNjBBUEZCVVYyWFBQUFJlTHRCOUlSbjlRTDczMFVzb2RpN1U3SnRHOHFFTjZsMTEyOFkvTXZ2NzZhL3ZuUC85cGYvN3puKzNCQngrMEw3LzhNbFoxbVpxcTVzNmQ2ejdIK3FLalppdlIrMURnQ3lZU1psSmFBZVNMTDc3dzk4dysvL3h6OThJVTdmVE5MVm1rSERGaXhBWWQ1M3E4M2xUVW5uK2dJU2pEMWxEMFZDdUY0TXNVbWkvMUo2aHpXcCtKWUZQR3FxWlBWZFNYWG5xcHkwdzEyaWtPOUpsVWRyRjA2ZEwxbjJOTkpteW9qQ25sQUtJWDg5MTMzL2xINWlLZDJvUFZycFlZSkJLcE9VdWpBUUxxZ0h6cnJiZnFiR3NHZ0RoUjNUWnUzTGlONnJpZ2N0WVhqbGRlZWNWOTQ3LysrdXZ0alRmZWNLMHpUU2w0YlkwaDVRQ2liMmRCVzZCb0NLK0c1cXBudno3S1RnSnEydnIwMDAvSlFBQmtEVFgvMUZjcEIvZXBBMXY5RG1yaXV2dnV1KzNqano5dTlsbHF5Z0drOXB3UFJWa04xZDNVc0Z3TjZ3Mm9qMFJESUlOT1N3Q0lPOVZoNlV5R1ZrQlJFLys5OTk1ckYxOThjU3o3U3pJbDVRQlNPeTFUNzcwS1Z1MXI5VWtNTU5wWGxLYnRHRUEyNmQyN2Q1MU45Y2tvV0toZldGK1dQL3p3UTlkZmN0VlZWN2xCR21yTmFTNVNIc2FyNFlvYWdSQzQvUExMM1dKYzIyNjdyZXZycUl0V2ZuemlpU2Y4STdNcnJyakNEUzNUa0xoVTFPNmNWMmVRUm56RnhXT1BQZWJ2eGROZWUrM2w3OFZUVTVXZnZzejA2dFhMVGJ3S01tTE5hZEtvd2ozMzNIUDlPbTRxUDFVY20yKyt1ZDEyMjIxdUdIdEE0K3MxOGtXZHJFMkZ6MTgwcVphZlJweHFDR3pVTENLb3ozcjA2T0c2QURROHZMNDFBOU1aeGxzWERVdlhjSFgxUVFmRHpqTTFqRGZsQUtJcDhZbUZyWGErRjE1NHdVYU5HbFZ2WkZhd2VPU1JSL3lqZFlGSEhVMzZnMHhGN1FKVW44b3ZmdkVML3dnSXAwT0hEaTVZNkZ0aEVFRFU1REI4K0hBYlBIandCcG16UG9QNkk1d3laWW9iZFJPNDVaWmIzRUNTVkQvTFFHMmEzdkNyWC8ycXpqcTAyUVNRMm9IZ3Nzc3Vjek1lTmFtbXZqZFpPL0JjY3NrbGJvMFdSZDVVMVA3WmFqWkxuRi9TMVBSdE5jNFNzNzg0YXFyeVUzL2NicnZ0NXI3UUJBRkU2N3RwM1AvWXNXUFhEM3RVK2VtUFd4TzB6ajMzWEpkQkJ6UlJkclBOTm5QM05SVStmOUdrV242TEZpMXlRMk16U2F2a2FvU1h2clRVcGRrRUVNMDRWMmRRUURNMGxZRW9FTlQzSmhWa05JMWUxUGVoQUtJM29XOTVxY2hFQVRha0ZJdXZ5VkIrOVV1Y2lmNzN2Ly9kclpSdzBFRUhyUjlkcVBKVFA1K2FHMVFaWG5QTk5lNjhxQWxyenB3NS9sSFQ0UE1YVGFybHArWjYxVnRoeTF1ZklkVi9XcTFqekpneHR1V1dXN292TVp1U2lmSnJ5QUNTY3E5UTdZa29tdFdvUDd4TkZXamlrTjFnT1pQRTVnR2dLU1gyMzZrdlEwUFZFei9UK2dQVzhITmxKZWwwb3FKNTBVV1kxTitWanFEeVZ4K0hnb2FXV0QvdHROTmNzMmNxd1NNYnBQd1hVWHNZbTJhVmE4R3VUUlZxNGlKa1d2cEJQMmRUSTdlQXhwTFlnYWtBb2hFeWlhTUU5WTFSRitaUjgxVmNaaHVqY2VsTGhRSklPdG1BSGp0dzRFQzN6SlA2T0RTWW9DbWJPaHRLeWdFa2NUNkg2UGo3NzcvZllISmhNb25yQldrdWlVYSsxRGRxQzJoTWlTdnFxajlEUVNMeE02M21yRC85NlU4dSswaHN3a1hMb1RrZG0ycHBDWUtMVnVaUXNGRFFPT3l3dzl6eTZjMzVDM1BLQVVSdHdvbUxjYW1ndExSSmZRRkVUVnhhOGlTZzltSU53YVVKQzNHaGpzeUFQdE1hcXBrNDUrbVBmL3lqYTRaVkIzdlU2MGNqTzJrcVFyTHNJMmpTVkwyb3p2Q1RUanJKVGpqaEJMZS9xUlU2R290ZWR6cVpVN3BTRGlBcXJNUzVHNXFGcnFuNjlhMXJwZG1YUVFlbGFEVkxkUjVwNkJvUUIxcW1JcEZHeEdnK2lCYkwwd1N3cDU5K2VuM3dVSWRqcGtmaUlONzBKWG4yN05uck01Q2dRbFlyaWhhTDFXS3laNTk5dHJ0Z1h1S3lUVTFCcjB0ZEM1cjBxQy9xd2FhbXMyUnpsZFN2cmZ2MGVIV3doNUZ5QUpFaFE0YjRlK3VHUWVvQ1VYVXRIS1lDMXlKakFmMFMxTDQ4ZnZ6NDJFUm5RSi9qYmJiWnhqOWE5MFZKL1hiLytNYy8zRlVIUC9yb0kvZFoxcUo1dDk5K2UxWmNXQWlab2Y1ZGpiNUtwQy9SdXRiNE9lZWM0MjUxM0pEZjhOT2hURWlYdEwzenpqdmRuS1pndStHR0cyeUhIWGJZNEhVR0NZRVdnTlRqenovL2ZMZndiYnJ2SmEwQW9qa2ZpZjBYbWtTb0licTFVM3Y5d1dtSll3MFZDMmp1aHg2dlNWYzBZU0ZPSms2YzZFWmFKY3VtVllrb0c5SHdYVjNMUmtNaUF5ekowN3hwM1Q3MTgyclNxVDRqdi96bEwrM3d3dzkzclNoeHJNUFVzcU02VnYzVEdxNnJTMmRvL3A0bWJtc1ZFVjE2UEtCZ29TdHJxcFZJMTNsU1A4M0pKNStjOXFvS2FWMlJVUFNDRkpXRFNLVW1LblUrYnJYVlZpNENxcU5jTHo1eDZYY2Rhd3k5Smg4cTVVdm5SY1lsdXRjbHplSnJkSlJmYW5UMU9hMmdxbTlzQ2d6Nm9xU01XWDkwd2VWQmRVN3psOVJNb005M1U4OEJFVDUvMGRSWGZycFA5WmtDU0ZOSnAveFVyeW9yMGtUcjRNcUQ2ZEk4UFdYYnFVbzdnSWpXdmxka1R1WE5hUVNETHYyNXh4NTd1Rm0vYW05THAxQ29BS09oL0ZLbklLTGhtbG85WWRhc1dhNjVTa3YySkw1R3BmNHFVNTFMZDE1QVErRHpGMDF6S3o5OXVUbjQ0SVBkYUZmMTJhWHovalJpVnMxZDZRZ1ZRTlR2b1d3aVNPK1NVV2VqL2hDMUNKa1dYTlRqTldzOTNTRnRmQUNqb2Z6U3B5WlpaZFlLRUpvSEVtZDgvcUpwYnVXbnh5c1RVWE5XN1RsTm02S3lTTGM4UWdVUTBiZXpKNTk4MGkwb3B6UlB6VmQ2OGZvV3AwaW1GRi9YUlQva2tFUGNvblVhdFJWbS9nY2Z3R2dvdjJnb3YyZ292MmppWG42aEE0am9tNXFDaFliejZrcURTdjgxTDBTVHN6UjhUQjA2Nm5UVVNKZGd6SFM2K0FCR1EvbEZRL2xGUS9sRjA2d0RTRURwdnRyYkZEejA0OVJNcFZFS1dpWWlhZ0h3QVl5RzhvdUc4b3VHOG9zbTd1V1hrUURTa1BnQVJrUDVSVVA1UlVQNVJSUDM4Z3ZYcmdRQWFQRUlJQUNBVUFnZ0FJQlExTUFXNzBiQWRhOFJJWTBkT3pidXY5OVllK3Z0dC8wOWhORXE1bjBNY1JmMzBpTURBUUNFUWdBQkFJUkNBQUVBaEVJQUFRQ0VRZ0FCQUlSQ0FBRUFoSktSQUtLckRPcEtYVnR2dmJWL0JnRFEzR1VrZ09oeW9BTUhEZ3g5WVhZQVFQYWhDUXNBRUVwR0FramNWN1FFQUdRZUdRZ0FJQlFDQ0FBZ0ZBSUlBQ0NVakFhUXVGODlDd0NRT1dRZ0FJQlFDQ0FBZ0ZBeUVrQVl4Z3NBTFE4WkNBQWdGQUlJQUNDVWpBWVFSbUVCUU10QkJnSUFDSVVBQWdBSWhRQUNBQWdsSXdHRVlid0EwUEtRZ1FBQVFpR0FBQUJDeVdnQVlSZ3ZBTFFjWkNBQWdGQUlJQUNBVUFnZ0FJQlFNaEpBR01ZTEFDMFBHUWdBSUJRQ0NBQWdsSXdHRUlieEFrRExRUVlDQUFpRkFBSUFDSVVBQWdBSUpTTUJoR0c4QU5EeWtJRUFBRUxKVWZZUWRaczJiWnI3WVVjZGRWVFMrNk5zQU5CU2FXUnJuTGVNWkNENlFRQ0Fsb1VtTEFCQUtBUVFBRUFvR1EwZzlGa0FRTXRCQmdJQUNJVUFBZ0FJaFFBQ0FBZ2xJd0dFWWJ3QTBQS1FnUUFBUWlHQUFBQkN5V2dBWVJndkFMUWNaQ0FBZ0ZBSUlBQ0FVQWdnQUlCUU1oSkFHTVlMQUMwUEdRZ0FJQlFDQ0FBZ2xJd0dFSWJ4QWtETFFRWUNBQWlGQUFJQUNJVUFBZ0FJSlNNQmhHRzhBTkR5a0lFQUFFSWhnQUFBUXNsb0FHRVlMd0MwSEdRZ0FJQlFDQ0FBZ0ZBeUVrQVloUVVBTFE4WkNBQWdGQUlJQUNBVUFnZ0FJSlNNQmhDRzhRSkF5MEVHQWdBSWhRQUNBQWdsSXdHRVlid0EwUEtRZ1FBQVFpR0FBQUJDSVlBQUFFTEphQUJoR0M4QXRCenEvWTVjNnc4Yk5zd09PdWdnKy9EREQrMysrKy8zejJhR0Y1UjI5bmNSd29rbm52aWN2NHNRYnZqckRmNGV3cWhweFpmS1NHSmVmRFJoQVFCQ3lVZ0FDWnF1R000TEFDMEhHUWdBSUJRQ0NBQWdGQUlJQUNBVUFnZ0FJQlFDQ0FBZ0ZBSUlBQ0NVakFRUWh2RUNRTXREQmdJQUNJVUFBZ0FJaFFBQ0FBaUZBQUlBQ0lVQUFnQUloUUFDQUFnbEl3R0VZYndBMFBLUWdRQUFRaUdBQUFCQ0lZQUFBRUloZ0FBQVFpR0FBQUJDSVlBQUFFTEpTQUJoR0M4QXREeGtJQUNBVUFnZ0FJQlFDQ0FBZ0ZBSUlBQ0FVQWdnQUlCUU1oSkFHSVVGQUMwUEdRZ0FJQlFDQ0FBZ0ZBSUlBQ0FVQWdnQUlCUUNDQUFnRkFJSUFDQ1VqQVFRaHZFQ1FNdERCZ0lBQ0lVQUFnQUloUUFDQUFnbFIvMFhVYmZISDMvYy9iQTk5OXd6NmYxUk5nQm9xZFN2SE9lTkRBUUFFQW9CQkFBUUNnRUVBQkFLQVFRQUVBb0JCQUFRQ2dFRUFCQktSZ0tJaG5NSncyNEJvT1VnQXdFQWhFSUFBUUNFUWdBQkFJUkNBQUVBaEVJQUFRQ0VrcEVBd2lnc0FHaDV5RUFBQUtFUVFBQUFvUkJBQUFDaEVFQUFBS0VRUUFBQW9SQkFBQUNoWkNTQU1Jd1hBRm9lTWhBQVFDZ0VFQUJBS0FRUUFFQW9CQkFBUUNnRUVBQkFLQVFRQUVBb0dRa2dET01GZ0phSERBUUFFRXBHQWtodWJxNjdyYTZ1ZHJjQWdPWXY1UUN5WXNVS3UrT09PK3pHRzIrMGUrNjV4NVl2WCs3ZlU3ODMzbmpEcGsyYlpqZmZmTE45L1BISC9sa0FRTFpMT1lBb3k1ZzllN2JOblR2WFB2MzBVN3Z3d2d2dDg4OC90N1ZyMS9xUDJKZ3lrbWVmZmRhKytlWWIrKzY3Nyt5cXE2N3k3d0VBWkx1VUEwaHhjYkgxNzkvZlB6SmJ2WHExM1gvLy9TNHpDUVNkNllFdnZ2akN5c3ZMM2I2Q3ljTVBQK3oyQVFEWkw2MCtrRkdqUnZsN1pwMDZkYkxubm51dTNxYXNtVE5uK250bVgzNzVwUzFidHN3L0FnQmt1N1FDeU9EQmc5ZDNtSXYyUC92c002dXFxdkxQL0VqbmxJRUVQdnJvSXhzM2JweC9CQURJZG1rRmtMeThQQnN5WkloL3RDNmdQUFBNTTdacTFTci96SS9VUHhJMFgxVlVWTGhnTW1uU0pIY01BTWgrYVFVUUdUTm1qTDluMXFGREIzdnR0ZGZXQjVERVBwQVBQL3pRM3pQWDZWNVFVR0FUSjA3MHp3QUFzbDNhQWFSZnYzNVdXRmpvSDVuYm56VnJsdXNrVjVDUXlzcEsxN1FWVUREWmZ2dnRyVWVQSHY0WkFFQzJTenVBNU9UazJKWmJidWtmbVd2U2V2SEZGMTJmaDVxNFJNRkRRVVEwU2t2RGVQZmVlMjhyTFMxMTV3QUEyUy90QUNKang0NzE5OHphdG0xck0yYk1jUE5CMnJScDQ4NGxObCtwODd5c3JNeTIyMjQ3TnhRWUFOQThxTk1pclJVUTI3ZHZiNmVjY29vTEhFSGZ4NXR2dm1tOWV2V3luWGJheVhiZmZYZTc3cnJyMW8vTXV1R0dHMnorL1BtaGx6bXBxYW01d045RkNGNzUvNCsvaXhCT1BQRUVmdzloMU5Sc09EY002WXIzQXJWcFp5QnFrcG8rZmJvTkh6N2NQMk0yZE9oUU4wdTlUNTgrYnI1SEVEeSsvLzU3TjNPZE5iSUFvUGxKTzRBb09HaFprc1FsVE5SMHRXVEpFbXZYcnAwYmNSWFFSTUxhczlNQkFNMURxRDRRelNoLzZxbW4zR3owUVBmdTNlMkREejZ3cjcvKzJoM3IyaURxR3dFQU5FK2hBb2lhc1RUeWF0Q2dRZjRaczgwMzM5eXR2QnMwWDZsSmErblNwVnhrQ2dDYXFWQUJSTTFYQ3hZc3NJVUxGNjV2b21yZHVyWGw1K2U3ZlZFMmtyanNDUUNnZVFrVlFDUm94dXJaczZkL1p0Mkt2YUlzUkVONXlUNEFvUGtLSFVBMGhGZk5XSW16MGdPYVNLamwzdXU3VmdnQUlMdUZEaURLTHRUUGNkRkZGN25GRW9OZ29mNFI5WVZveG5veWRaMEhBR1NYdENjUzFxWitqaEVqUnJpQW9pRzhhOWFzOGU5SlRvOVBaMTZJOTNPWlNCZ0JFd21qWVNKaE5Fd2tqS3FaVFNTc1RjRkFvNjAwQTMyZmZmYnh6OWFOU1lVQTBEeWtGRURVejZIT2NpMVgwclZyMS9XTEpnWVVGRXBLU3R4RXdvQ2FxclRjdTU2alZYZzFTZ3NBMEh5a0ZFQjBZYWc1YythNEdlaGExeXFZNjFFZjlZa3NYcnpZUFVmTG1TUzc2QlFBSUh2Um93MEFDQ1VqQVlUNUhnRFE4cENCQUFCQ0lZQUFBRUloZ0FBQVFzbG9BT0hhSHdEUWNwQ0JBQUJDSVlBQUFFTEpTQUJoR0M4QXREeGtJQUNBVUFnZ0FJQlFDQ0FBZ0ZBeUdrQVl4Z3NBTFFjWkNBQWdGQUlJQUNDVWpBUVFodkVDUU10REJnSUFDSVVBQWdBSWhRQUNBQWdsb3dHRVlid0EwSEtRZ1FBQVFpR0FBQUJDeVVnQVlSZ3ZBTFE4WkNBQWdGQUlJQUNBVURMYWhNVW9MQUJvT2NoQUFBQ2g1Q2g3aUxxOTg4NDc3b2VOSGowNjZmMVJOZ0JvcWRTcUUrZU5EQVFBRUVwR0FvZ2lrWkF4QUVETFFRWUNBQWlGQUFJQUNJVUFBZ0FJaFFBQ0FBaUZBQUlBQ0lVQUFnQUlKU01CaEdHOEFORHlrSUVBQUVJaGdBQUFRaUdBQUFCQ0lZQUFBRUloZ0FBQVFpR0FBQUJDeVVnQVlSZ3ZBTFE4WkNBQWdGQUlJQUNBVUFnZ0FJQlFDQ0FBZ0ZBSUlBQ0FVRElTUUJpRkJRQXREeGtJQUNBVUFnZ0FJQlFDQ0FBZ2xJejJnUUFBV2c0eUVBQkFLQVFRQUVBb0dRMGdET01GZ0phRERBUUFFQW9CQkFBUUNnRUVBQkJLUmdJSXczZ0JvT1VoQXdFQWhFSUFBUUNFa3RFQXdqQmVBR2c1eUVBQUFLRVFRQUFBb1dRa2dEQUtDd0JhSHRYOGtUc3VPbmJzYUtlZWVxb3RXclRJcnI3NmF2OXNadFRVMUx6Zzd5S0V0OTkrZTBkL0Z5R01IVHZXMzF1bjlwZWwydjErVFgxL2JiVWZYMXREUHgvTkcwMVlBSUJRQ0NBQVdoeGxUbTVidTNiOVB0S1hrUUJDNFFPSU05VlJWWldWdG1EZWQzYmpuODZ4dllZVWVGdSs3VFhVdi9XMnN3L2J5VDU2OTFXcnFDaTN0VjVnd2FhUmdRRDFVQjlBNGhaOFd3MjJwcjRmZFZNUVdMSm9nYjN5OUVOMjBqNGpiZDh0aXUzSUhmdlpQNlpkNXQyN2NkbDkrTmJMZHRZaDI5ditJMHJzb0syNzJEOXZ2OFlXelo5cjFkVlYvaU5RR3dFRVFMT2hvUEgxNXgvYXZYKzkyQVdCbjIvYnd5NDY1UUQ3NW91UC9FZWtadVd5cFhiOS81MWhVM2JvWXo4YjI5RnVudm9ibS9YeGUxNHdxZllmQWNsb0U1YStJUUZBWTFJL3hnZGU5bkRuTlJmWno4YVUyUys4Yk9QV3k4NXpRU0FUeWxldnRBZHV2c1JPbWJ5VisvbC91L3IzOXNHYkwvbjN0bXhrSUFDeVJ0QjB0M1p0dGMxODgwV2JkdWw1dHQrSUV2dlZZVHQ1RmZ2LzJocXZzbTlJNVd0V2VZSHE5L2FyS1R2YnZ0Ny9lK2MxRjlwbk05OXltVTlMYkZKVXloRDVYWmVWbGRucHA1OXVpeGN2dHF1dXVzby9teG5lTDRWNUlCRXdEeVNhdU04RDJaVGF6Njl0VXordm9aK2ZLdjJjNnFvcW0vM0ZSemI5d2R2dHlRZW0yZXFWeS94N20xNVpwMjYyNitURGJlOURUN0RPM1h0YlRrNXUycityYkVRR0FpQ1dncUF4NSt2UDdkb0xUclZqZHg5aXAwd2Vhdy9kZG1Xc2dvY3NXVGpQSHJqcEVqdDYxMEYyK3MrMnNUdXZ2Y2dXZnovUDFsWlhaeXlJeGhFQkJFQ3NxS1A2aHlVTDdiNGJwdHJwQjR5MzQvWVlhby9lZmIwdG1EdmJmMFM4cWJQOXpxc3ZzQ04yNm1mbkhyVzdQZit2ZTJ6bDhoK2FaU0FoZ0FDSWhWVXJsdGtMajkxblp4MjZnMDNadnJmckNKLzE4YnYrdlEwbko2ZVY1ZVhsdXZiOFRGTDJOUE9ORjJ6cTJZZTd6T1NDWDB5MlQ5OS93OHJYclBZZmtmMVVacEhESW4wZzhVVWZTRFJiYmJXVnY3ZE83VytSNmZaWk5QVDl0ZFYrZkcxTi9Yek5zVmd3NXh1NzY5cUw3TTBYSG5PWlIwTW9MQ2l3Zm4xNzJFNFR4bGxKU1pFN3A1ZGVYRnhzblR1VldWNXVycFZYVk5pc3I3NjFCeDZhYnZNWExIS1B5VFNWbC9wSWR2dXZvMjNQZzQ2eGpsMTZiTElNNDB5dnZQN2ZjQXJhdDI5dlo1eHhoaTFac3NTdXZQSksvMnhtZUI5QUFrZ0VCSkJvQ0NBTjgvektpbkkzOVBhNkMwKzNPYk0vZDMwRkRhVjN6NjcyMjdPUGQ0RmlVNjlYMUlRMjQ4UFA3ZkpyNzdDVkt4c3VXOGd2S0xTK2c0YmJLZjk3clcwMmJMVGw1dVg1OTJRUG1yQUFOQ3IxWlJ5ejIyRDc3ZEY3MkxkZmZ0S2d3U00vUDgvTytlVXgxcVZ6aDVTQ2grUjYyY2lvRVlQdDdGT1A5TTgwREFYUkx6NTh4ODQ0Y0ZzN1l1Zis5dkY3ci9uM1pBOENDSUJHTmZQWmgyek45M1A4bzRiVnl2dFhWVlcxeVV5cU5nV2JGU3RYK1VjTnJjYldMSnBuajE3NUcvODRleEJBZ0hxbzRrbmNWTEVrYm5HN3YvWlcrL0cxdDJUUFNkeVNQU2R4Uy9hY3hDMlpaUXZuV1k4MmhkYTNwTUNLYzFQTENzS3FxS3kwczM1N3FkMTIxeVAyM3N4UGJla1B5emU1VUtKZTk4TEZTKzNPK3g3MXp6UWN2ZjkrSmZuV3l5c1BWY1oxbFZsYzZiY1grUlhUQnhKZjlJRkV3d1dsb2owL21RY3VPY3RldXYrdi9wSFptcXBxVzdpbXlsWlZwLyt6d2lndUtyUlJXdzYyenAwNldOdlNFaXNveUhmblNsb1h1ODV6QlpyM1Avak1mM1RES01sclpaMEs4Nnd3TDljL1k5WnJ5R2c3NjlZWExDY25lNzdYazRFQWFGUlZsUlgrM2pwRlhpV3FiK0I5dlcvaXBWN0YydEJXcnltM1Y5K1lZUTgvOXJ6OTdkNUg3Wlk3SHJKcmI3elhwbDU1cTkxMjl5TU5HanphNXVkWXZ6WUYxck9rY0lQZ0lUVmE5VGRFUUc1S0JCQUFqYXE2c3RMZjI1QXExTzVleGRyZnEyQTdGR3hZdVdZemhjUk9oYmsyb0xUQXVyVXVzSUxjNU5XdVJuK0Z5ZWlhVWtZRHlLYlNYU0RiNkRPZHVPa1BQSEZyNnZ1elVlME1wTFo4cjRMdFdKUm5BMHNMcll0M202MFVBcnNWZSsramJhR1ZGZVpaM2lhYXBySngyUk15RUFDTnFycXEvZ0FpQ3BhNU9hMnN2VmZ4YnVaVndEMWI1MXQrbG53L0xmWmVkKy9XZVRiQWU5MXRDL0lzeHcvK20xS3pWc09aQ1NBQVVLZFdyZEtyZGxRQmwrVG5Xajh2STFIL1FadThITmNzRkNkNlIyWDVPZGEvdE1CNmU2K3pPRDh2cGFDeGdTeHN3TWxJQU1uV1ZCcEE0OHZOei9mMzBxTUtXZjBIM2Ixc1JCVjFwNEpjYTRRKzkzb1ZlRFZvOStJODcvVVVXdWZXQlpZZllRUlZ1b0UxRHJMdkZRT05LTEcvUVpzcXNjU3RxZS9mMUZiNytiVzNaTTlKM0pJOUozRkw5cHpFTFpuY3ZIQUJKS0NmcS82RXNxSThsNVgwOWdKSzYxenYvL1B2YjJpcU5OdDZXWkE2Ky91MktiVFNnanpYM0JaVksrOW4xRlZtY1VVQUFkQ29vZ2FRZ0NwYk5XOFY1K2RhejVJQ2YvUldUb1AxbFJSNUZYeFhMMmdwKyttcVBoa3ZHOHBraGI4dUF5R0FBRUNka2dXUWJqMjYyZW5ublc3SG4zNmNqZGw2dEJVVUZQajNwTVpsSlc3MFZyNlhGUlJZTDYrQ2I1TVhQU3RSRTFsN0x5aXA3NlczdDdVdHlQV3lqY3dHam9BTElOa1ZQekliUUxJdC9RTFErSkwxZ1J4dytNKzhJTkxWQm13K3dOcy93TTZmZXA1dHYrdjIvcjJwYzFtSlY4RzM5cktTN3EwTDNOeUxMa1c1VnBUbWtpbWE4S2NncE1EUjJRdEs2bnZSejI3SU9xNlZBaE1aQ05COEJKVkdzRzJxRDZDeDc4OUd5VEtRN2oyNyszdnJ5anpmQ3pLVGZycW4vZnpZUS8yejZkUFBVYmJRdmpEZmV2dE5YSnJRcDQ3dlpOcDVRYU5iVVo1dDVrLzRVeEJTTU5MUGlhcHp0ODYyNStROVhZQ3NTeWIrbjhaR0FBSFFxSklGa0VVTE43NkFreXJVTFVadllXUEhiN2dlV1JndUtIbFpSQWN2bStoWFdtUUR2U0RSb3pqZnVubWJPdUVWTkxwNlFhTnRZVjdHMTZLYWZNaGtPK084TTJ6SDNYYXdZMDg5eHIyblpGcmw1R1pkRU1sSVNXWHJOeUVBalM5WkFQbGs1aWYrM29aVW9VN2NhMWYvS0hPVW1iUXB5SFY5R3VxRWI0Z0ZEUFB5OHV5WVU0NjJuMHdZNS8zOGRZRkIvODlCUng3bzdxdk5YVkNxSlFZUUFFaFZzZ0R5ek9QUHVyV2drbWxYMXM3YWxMYnhqN0pEVVhHUm5may92N1JCUXdkdGxGV29lYTVuMzU3K1VhSjF6WlRaaEFBQzFLTjJuNFArd0JPM3VOMWZlNnY5K05wYnN1Y2tic21lazdnbGUwN2lsa3hPa2dCU3ZxYmMzbnpscmFUUDBmL1R0bjFiL3lnN0hIYjhZVmJXb2N3LzJwRGU0L0lmbHZ0SDJZMEFBcUJSRlJTMTl2YzI5TTk3LzJtelo4M2VLSWpvZUZXalhSMHdPbVZMQXdmVjNWbStjdmxLVzd4d3NYK1UzVExhQjZKdkNnQlFuNktTVW45dlkzKzkvQWFiL3VoMFc3bGk1ZnA2WmZhWDM5alN4VXZkZmpZWXNzVmdONnM4R1YwTjhaRUgvdVVmWlQ4eUVBQ05xcWlrL3Vhb1p4OS96aTc2OWYvWmY1LytPL3ZkTC8vSC9uclpqMWN2akQwdmJvejZ5U2ovWUdQUFBmRzh6WGg3aG4rVS9RZ2dRRDBTMi91MTZWdHg0dGJVOTJlajBsYXJyWDFCbGJkWC83WEoxYWxlV1pIODRsTnhsWnVUdThHY2xvQitWN08vbk8yeXE0MnR0VEt2UElhM0wvZVBzd2NCQkVDanFsdzYxNnNzSzIxNHV3b3J6TW0rYTJEVXAzcHR0YzM1ZHE1L3RDNXdxTm5xcVVlZXR1c3ZyWjFKMVZocFhyV045QUxITUs4OGNsdGxYemtRUUFBMHF2Smw2eVlOdGkrc3NURWRLMnhBU1lYbHVteWtHUVFTN3kxb01NQ3lINWE1d0xGdy9rS2JkdTJ0OXZ5VHovc1BrQm9yOGdMbjBMYmxOcUtzd3Rxa3QreFhyQkJBQURTcXRRbVh0RlZmYy9lU3RiWlZwM0xyMDdyU1dqV0RRTEpvd1NLNzVIZVgyTVgvUGRVdXUraHkrK0tUTC94N2FpeS8xVm9iVkZwaG96dFVXSWNpTlZINmQvbXlyVmt5SjJoTGpiTE5tVFBIL2JBZVBYb2t2VC9LQmpTbDRET1krRmxVWDBSdzI5VDNCN1NmN0ZqUFMzeHU3ZU5BUXowL21iWFZHMS9TTnMvN0t0dTdUYlZ0MWJIY3VoVlZlWUZrNC84am0xUlZWZHV5cGN1OEF0TlJqWmRoMWRpQU5oVTIxbnQvWFlyWFdyS0o3elZleHVJL1liMmdIT082WlNRRDBROENtaU45dGxWaHh2VTJHNjJ0cXJ0anZDRFhiR0RiS3U4YitocHJsNmVPOXV3T0pEbmU2Ky90WlZaak82NnhibDdneUsybnhsMWJXZTRIa2V4QkV4WlFqMVFxOGFhOERUWWRKNTZMeTNFeU5RbE5XSFVwempNYlhsWnBvOHZXV0VsdTluVzBleVZnWFF2WEJZN2VKZFdXN3dWR3IxanFWYlBXZTU5MWxGbGNFVUNBZWdTVllWeHZzOUhhNnRTRzVucHYwVnJubTQzc1VHRmp2SXhFSGM5NStYbldxVXNuNjlDcGcvK29PTkh2bzhiYTUxZlpPQzl3S0pOU1JxWDNrWXFhbXV6S1BpU2pBU1JiUDlCQVhlcXJ2T055Ryt6SDhUaVorcHF3a3RHUFVVYWlFVnRuL3VvNE8vTjN2N1N6Ly9jc08vYTBZOU8rY21IRHFiRTJlZFcyZGFjMWJraHVLaGxIYldxKzhrclBQOG9PWkNCQVBZSktNYTYzMldodDFhYWJzSkpwWGRiQnlucjJjZTlkMjJhREI5cXZMenJIaWxvWCtZOW9DbXZkWEk2eFhvWTBza09sR3d6Z3ZiUndhbWpDQXBxVlZDcnhwcndOTmgwbm5vdkxjVEtwTm1IVlZybHFwWnRia2FoMVNXczc0b1REL2FQR0ZFd0NyTEF0TzFSWTBjYVg5MGhidG5XZ0N3RUVxRWRRR2NiMU5odWwyNFFWcUtvb3R6a3ozdktQZnRTNVk2a05iUmQwdGplMEdtdWJYMlZidGwvakFrZWJnc3o5RGx3QXliTGZLUUVFcUVjcWxYaFQzd2I3Y1R4T3BpWmtCaUl6SHJuWGxzMy9jYWtRWlNUdlBYU1hkU2lzY1ozdHc3eEEwcnFCQW9tR0ZZOW9YMjVidEsrMDBnYnBlc20rTHdRcEJaQTFhOWJZeXBVci9hUHdGaTFhVk9kVng0QTRDaXJGdU41bW81eTg4TFd2dnFYL2U5clZOdi96ajZ4aXpXcDcrLzViYmVtM1g3bjd2Q0t4TWkrUWpOb2drRVF0SXpWVnJjczROS3k0clpkeDZQOXBDTG9tZW9QOThBYVNVZ0I1OXRsbjdZb3JyckJYWG5sbG96YklWS3hhdGNvZWV1Z2h1K2FhYSt5VFQ1SmYreGlJbzFRcThhYThEVFlkSjU2THkzRXlPZm5ST3Iycnl0ZlltM2ZkYUU5ZC9GdWIvOGxNLyt5UHZQOStmU0JSeHRCbS9ZVEVWSVBKdXNlMmRZRkQ2MVVwNDlCN1czZHZROG5KelhkbGwwMVNDaUFEQnc2MHFxb3FtejU5dWdza0w3LzhzcTFZc2NLL2Q5MjNOS245Z1ZIRzhjUVRUN2pudlAvKysrNXgvZnYzOSs4RjRpK29ET042bTQxeUN4cG4xSlJYUkM1ajJOSUxBQ1BMeXExOWZyVy9SRXBkNWVhVnE3ZHBIc2NvNy9GYk5GTGdDTFRLVlU5OGRnV1FWdDZIY0pPZlFtVWRsMXh5aVd2S2t1REQyNmxUSit2YnQ2OFZGUlc1N0tTd3NOREdqeDl2aXhjdnRxKysrc3FXTDE5dU9UazU3dm02M1d5enplelFRdzkxUHlNTkwvaTNDT0h0dDkvZTBkOUZDR1BIanQybzBvN2JyV2hmNG5xYzZNMnJUckN2bnJyWlAybzhlaWxycXMzbXJjNjE3OWZrV1dXTlhxTTJMWEpZWTUyTHFxeGJjYlVWTlZGTFVyditJMjIzSzk3ME1oSHZCZmlDY295cmxESVFWZjViYnJtbDVmcHZMUGhRTEZ5NDBONTk5MTE3OWRWWDNiRUN6SXN2dm1nelo4NTB3VU9DSmkvMWZZd2NPZEx0QTlsQ2Y4RDZ2TWYxTmh0RmJjSUt5eXN5TnlHeGYybTFqZWxZYnNQYWxWdlhva3AzcStOK2JhcmQvWHBjVThqMXlxVlZzbFVXWXl6bFZ6dHExS2lrSGVBS0VFR1EwSWRhKzhrKzJNcE9CZzhlN0I4QjJhRyt5anNPdDhHbTQ4UnpjVGxPcHJCdFIzK3Y2V2pDbi9wSk5tdGI1VzRqVFFETUZPLy9WOWxsazVRRFNQZnUzYTFqeC9SLzhmb1FLWE5KekdDQWJCRlVobkc5elVZZE5oL243eUZSNjg1OS9MM3NrVmErTkhyMGFQZkJUWWNlVC9NVnNsVXFsWGhUM3diN2NUeE9wdHVZM2EzWDlnZjZSOW1oYmJlZTFudjAxdFozcSswc3R3SFczMm8vWUxTTk8rMUcveWg3cEJWQWxFWG93NUVPUGI1ZHUzYldzMmRQL3d5UVBZSktNYTYzMlNnbk44L0duM08zYlhINFJWNEJwMVVGTmJxaTBuWTI3dWZIMjRUano3U1IreDFpSS9ZK3dIYjZmNy8xNzgyTW50djl6SGI5ODh1VzM3clVQNU05MHZydGxaYVd1bUc0K3ZDbVNoM3dZVElYSUE1U3FjU2I4amJZZEp4NExpN0hkZEZqaGgzOEc5dnBEODlZYm5GbUs4Nzg0aEpybFlIbWNtVWRPNTN5RytzNmFKaXJ4d0tGclVzeUZ2aUdUN25BdHYzMTNZMDJ0RG5UMGk0RkJZT2cwendWK2hBcGN3R3lVVkFaeHZVMjIzVVpzWVB0ZmRObjFtWFVSUDlNTk5zYy9ndmI0NXlMYk5KdnA5cjRvMDZ4amdNMjkrOUpqNXFwZm5MWUNaWlhVT2lmK1ZINXFwVmV4WmIraE9wRXVVVWx0dlBGTDlqd1E4NWZOd005UzZVZFFJWU9IWnJXR3Z5OWV2V3lzckl5L3dqSUxxbFU0azE5Ryt6SDhUZ1ZSZTI2Mkk2L2Y5ekduUEpYLzB3NEhmb01zRTUrd0ZERzBMSHZRTnRteWtsZUZ2RmJLeWhKTDh2cFBYcThGZGJ4bk1yeTFmNWVPRjFHVHJSOWIvM0dPZytmNEovSlhta0hrTHk4UEJzK2ZMajdCZW1Ec2luS1dJQnNGVlNLY2IxdExqVC9ZYk05ajdQOTdwaHJlY1Z0L2JQcDZUbHk0OUZkS3FjMkhUdmIxbE5PVFBtYnZoNDNlT2M5M1hPVEtTNXQ1KytsYjl3WnQ5aU9GejV1QlczYSsyZXlXNmlHUE0wSlVUTldYUVVjVUpBWk5teVlmd1JrbjFRcThhYThEVFlkSjU2THkzRzZpc3E2MnVTN0Y5alFnOC96anRMck42MXZkRlRicmoxczJHNzcrVWYxSyszYVBXblQxWS9TNzg4dDdUWEU5cjFqanZXZmVLUUxsczFGcUhmU3AwOGZON0txUHZvUURSa3l4QzF6QW1Tcm9ES002MjF6bEpPWGIxdE11Y0FtM2ZpcEZYVklmZlRtM0pudituc2JVM2wxN0w5WlNwVjNhZWZ1N3ZISlZKYXZzVmR1dnR3LzJyUld1Zm11bzN5UGE5NjNvdlpkL2JQTlI2Z0Fvc0xWdkk2NkNsbjA0V2J1QjdKZGZaVjNYRzZEL1RnZWg2WG50dWsyd1BhK1paWU5tSFNpZjdaK1M3NzcydGJXYzdtSVZKZExYN0Zvdm5zUGliU00vUGRmZlc1UFgvTGZ0bUxoQXY5cy9VcDdEN1ZKZi8zRWhublpWRTVlWHFUeWlLdlF1WlNDUSsxQ1RxVE1RNHNuQXRrc3FCVGpldHVjNlQzbWV0bkkySk92dFlsWHZHR3R1OVcva25mbHFoWDI5bjNUNml5WHZNSkN5MG1oSCtTSE9kL1lkelBlc3VxcVN2ZXpsc3o1MXA2NTh2ZjIrdTEvOFFLVWxvYXZuN0tPUWZ1ZjdtVWQ3M2xCc0o5N0g4MVZTcXZ4MXVYR0cyKzB1WE4vdkRwWVFFdVdqQnMzenZiWVl3Ly9UQ1NzeGhzQnEvRkdFL2ZWZUFNNmx1QmNYSTR6cVdadHRiMTM4em4yK2IrdU1hOTI5ODl1clB1d1VUWjh6OGx1RW1DaWxZc1gyZ3ZYWFd4cnF6WWRCRVRMcStjWEZsbUZGNWhTMVc3QUtOdjY3RHVzblpkOUJHVVJSU1orUmtPSzFKc3pac3dZZjI5RFdycUV1UjlvRHZRSHJNb3dycmN0aVpxZ1JoMzNaNXQ0Nld2V3R0OFcvdG1OL2VlajkyejZGYiszTDE1KzFxb3IxMTArVjAxYnMvNzlYTXJCUTJxOElKVnE4TkFLd3lPTy9wUHRmdVZiMXI3UE1QZjdhUWtpWlNEbDVlVTJkZXJValNZV2R1alF3VTQ5OVZUL0tESXlrQWpJUUtMaGVpQ1pPYzQwTlNWOTl0QVZOdU8yODd5RHVvTkNia0dodGUzZXk4cVgvMkNydkF5a0lYUWN0cDF0ZmVadDFtWVRUV3hoQk9VWVY1RXlFQzNScm9tRmlXOVMrM1ZsSmtDMjBlZFpsV0JjYjFzcXJhYzErTC9Pc2trM2ZHeGxtNDMxejI2c3VxTGNsc3llMVNEQlE5ZDIzK2FjdTJ5WGk1OXZrT0NSRFNJRkVLbTl3S0wyUjR3WTRSOEIyUzFacFIybjIyRFRjZUs1dUJ3M0pQMC9wZDBHMks2WC90dTJPZmNlMTNuZFdIcHRmNUR0KzdlNTFtZUhnNzNYRWJrYXpWcVIzN2xHV2lYTzlSZ3dZSUMxYlJ0dUppa1FOMEZsR05kYnJNdEcra3c0MFBhL2E0SDEyZWt3NzB6RE5mdmtGWmZheEN2ZnN2RmU1bEhZaGlXYUlnY1F6VGJYekhSOW9MVXg5d1BOU1NxVmVGUGZCdnR4UEc1TUJTVnRiWnV6YjdjOS9qTFQ4a3M3K0djelE4MVZZMDY1emliZi9iMTFHTWpxNG9HTTVGN0JuQkFGRTgwK0I1cUxvRktNNnkwMjFxN1BVTnYvem5rMitJQmZ1NG8vRXErYzJ3OGNhL3ZmdmRBRzduRzhteVdQSDJVa2dIVHIxczI2ZHUzcStqN1NXYWtYaUx0VUt2R212QTAySFNlZWk4dHhVOUdFd1pGSC9jSDI4d0pKeDJFVFhDQklseTR4dThzbEw5dHVWN3krN2hvaklYNUdjeGRwR0c4aURlblZTcjBOY04xemh2Rkd3RERlYUxiYWFxdjFGV05jYjBYN0VyZmp1SmozM2pQMjlqVW4yY3A1WC9wbjZwYlh1cTFidjJyemZVL3gzay9UZHBBSDVSbFhHU3NkRGVsdGdPQUJOQ2xWaFBvamp2TnRzQi9INDdqb05tcFhtM1Q5UjE1ZytMM2xGclh4ejliaXZkNStFNCsyL2Y4Mnp3YnZkNXAzMkxUQkl4dFFRa0E5Z2tveHJyZEluZm92aGg5eW5ydm15S0Q5ei9EUHJyUFozaWZiNUhzVzJVL091TWxOUGtScU10YUUxWUJvd29xQUpxeG9XQXNyMm5HY1ZhNWVibk5lL2FmMW1uQ0E1Y1gwbXVSQmVjWVZHUWhRRC8wQnF6S002eTNDeXk4dXRYNjdUSWx0OE1nR0NtK3gvaFRHL1k5RWY4aHhSdmxGUS9sRlEvbEZFL2Z5SXdNQkFJUkNBQUdBRmtEWnpJb1ZLOXhXbjRxS0NsdTZkS2xWcGJEMFBVMVlFWkVDUjBQNVJVUDVSZE9jeXUveHh4KzNOOTU0d3pwMzdtd25uM3l5ZjNhZGp6NzZ5SjU4OGtsYnRteVpPOVlsTi9iWlp4L3IzLy9IVllSWHJWcGwvL3JYdit5VFR6NXgvNittWldpWnFrbVRKdFU1UllNTUJBQ3kzSC8rOHg5Nzg4MDNyYXlzekdVUWlXYlBubTBQUFBDQTllM2IxMDQ4OFVRNy9QREQzYVR2dSsrKzIzNzQ0UWYvVVdiMzNYZWZlK3lCQng1b0o1MTBrazJZTUVHak9HMzY5T24rSXpZV09ZQW9NblhzMk5INjlPbmpOcjBCQUVEalVMYnc2S09QMnJCaHc2eFhyMTcrMlIrOStPS0wxcTVkTzVzOGViSmJka29ycHYvMHB6KzF5c3BLZStlZGQ5eGp2djc2YXhjOGR0OTlkM2VOSnkxTnRkTk9POW1nUVlQc3JiZmVxck01SzNRQVVlcFhVbEppVzJ5eGhaMXp6amwyenozMzJKMTMzbW1ubkhLS1M0L2luaG9DUUhQdy92dnYyNElGQzF6bFg1dXVGcXZnTUhEZ1FMZlliVUNCUkpmZCtPNjc3OXp4bDErdVcrSkZBU1BSNXB0djdvS0hmbjR5b1FLSTBwOGVQWHE0aUhiRERUZTR0RWpSN0lNUFBuQVp5SEhISGVjaUhnQ2c0V2dOUWpVeDdiREREa212dzZRT2N3VVJ0UkxWcHJwNjVjcVZibDk5SThYRnhkYTZkV3QzSEFoYWxPcnFlRThyZ0NpQzZVWHFrclhubjMrK1hYSEZGYTdEUm0xcHp6MzNuTTJmUDkrOUVMMnA2dXBxLzFrQWdJYWdlbGZyRUk0ZlA5NC9zNkVnUU9neHRlbWNPczVGajZ2ck1iSjY5V3AzVzF2S0FVVEJRMm5QbENsVGJOcTBhWGJ3d1FmYnUrKys2NXF0RkRnUzZVVXBpQUFBR3NiMzMzL3ZPczczM0hQUFRTNWtxeXdrbWNUbjFmZWxQL0lvTEdVZVJ4NTVwRjE0NFlVdW1OeDIyMjMyNzMvLzIvMm42c1JaczJhTi84aDFuVHJwREQ4REFLUkh3M0xWMmQybVRSczNDa3ViTWdYVnlkcFhuUncwU1NYV3p3R2RVeisycVBtcXJzZEk4TGphVWc0Z3VsQ1Vybi8rNFljZjJyMzMzcnQrK05laVJZdGNFNWJPQXdBYXg3eDU4MXlnVUQ5MHNIM3h4UmV1djBMN3I3MzJtZ3NnR3RDMGNPRkMvMW5yNkF1K3pyVnYzOTRkS3dpcEh6dVlKeEpRL1M1MTlXbW5IRUFVaVRSSlpjYU1HZTVZVFZSUFAvMjAvZVV2ZjdIbHk1ZmJ0dHR1Njg0REFCcWU1bXFjZHRwcEcyeURCdysyMHRKU3Q2OTVIUG41K2RhelowOFhXQktINHM2YU5jdDFOV2lVbFdpT2lIejY2YWZ1VmhSa1ZOOTM2dFRKamF4Tkp1VUFvc2lrb2JxYTBmanR0OSs2d1BIS0s2KzRUcGJqanovZVpTY0FnTWFockVHanBCSTN0UlNwaTBIN0dpMHIyMisvdmVza0QxcUtYbi85ZFh2d3dRZGRuN2FtWVlnQ2lZNDFvdXZWVjE5MWo5UEV3cmx6NTlyRWlSUGRZNUxSWkkyVU95dVVDZ1dwVHRCSnJ1RmhGMTEwa1hYdjN0MTFxb3ZHRnF1UFJJK0xLdTU5S2MxcEtZU21RUGxGUS9sRjA5ektUd0ZBbGY0UlJ4emhuMWxIVXl4ZWV1a2wxeVJWVkZUa0FvWUNRK0t3WFRWOVBmWFVVeTViVWQzZHBVc1hGM3lHREJuaVAySmphUVdRWlBTZnFHTmQwWXNBRWorVVh6U1VYelNVWHpSeEw3K1VtN0FBQUVoRUFBR0FaazdOVXBkZmZybnJlbEJXYzhzdHQyUms1Q3dCQkFDYU9RMXlVai8xODg4Lzd4WlFWRWU3RmwrTWlnQUNBQzNBWG52dFplKzk5NTViL21TLy9mYkxTUDhQQVFRQVdnQU44ZFdtbWVyQkVOK29DQ0FBMEFKb2lPNklFU05zNU1pUjd1cUZtVUFBQVlCbVR0Y0UwZXh6TGZ1Kzg4NDd1NmtXdW5SdFZBUVFBR2ptdEJqdVVVY2Q1WnF3dEhySTBVY2Y3UzdGRVJVQkJBQ2FBZlZ0TEZteVpQMDFQaEpwTFN2Tk90Y3lWTnEwWGxheWkweUpsb24vNnF1dmJQSGl4ZjZadXFrYlB0SlVSMmFpTTVNMUNzb3ZHc292bXVaVWZsb2xYYzFTV2dkTGl5a20wcVUzTlBvcVdGQlJtY2crKyt6aitrUUNDaGozMzMrL1crVTNvRXZoSG5qZ2dVa3ZOaVZrSUFDUTVUUlJVQ3ZwNmd0OTdhQ2pCWEMxY3ZvMjIyeGo1NTU3cnAxNjZxbnVrdVFQUGZUUSttWGVkY0VwTFpaYlVWSGhMbEgrbTkvOHhsMnlYTmRLZitLSko5eGpra2s3Z0dnQ1NyRHBLbFc2clN1S2IrcCtBRUEwYXJwU0pUOXUzRGdYUUdwVDlxSCtqbDEyMmNWbEVtck8ybmZmZlYzUUNGcU5Qdi84YzlkMHRmdnV1N3ZXSkdVb0dxMmx5WVphMGwyQkpabVVBNGdDZ2RhRkh6VnExQWFibGdOTzFwYW1LMWdOSHo3Y3ZRaWxRWG8rQUNDemRPRW9YWWxRbzZ0cVU1UFZuRGx6WEIyYytFVmVRVVFYazlJRnFXVDI3Tm51L243OStybmp3SUFCQTF5Z1VYQkpKdVZhWGIzNHh4NTdyRXVGSG52c3NmWGJYWGZkWlR2dXVLT0xnZ0ZOVWhrNmRLamRmdnZ0OXNnamo3aXJZMmtxUFVFRUFESkgxMmw2NFlVWDNOTHNXcWE5TmkzUkxzR1ZCeFBwbks0VElucWNPdGxyOTNVRVZ5SU1IbGRiV2htSXNvcjMzMy9mcnIvK2VyZGRkOTExN3NKUzExeHp6Zm9yRllwU29EMzIyTU8xc2QxMDAwMzI0b3N2MnBRcFUxelBQd0FnTS9TRlhzMVdhZzFLSnFqNGszV0M2MnFGeWx4RWoxT3pWVzNCODRMSDFaWnlBRkdFVXNieDhjY2YrMmZTb3pRb3VBZ1ZBQ0NhYjc3NXhxMm9PMm5TcEEyYXB4SUZyVDZKbDdNTnFMTmRRVVQwdUxvZUk4SGpha3M1Z0tnVFJSMHVEenp3Z0MxWXNNQm16cHpwamxQZE5JUk0xMVVIQUVTbnBVbTZkdTFxUC96d2d4dHBwVTM3cXF1MXYzVHAwdlZYSEV4Vzl5cXJVS3VTRkJjWEozMU1NS2RFVjZKTlJtRXJyWUhhU25QVTFwWnVOcUVNSk15OEVNYVJSMFA1UlVQNVJVUDVSVk5mK1YxMjJXVzJmUGx5LzJoanUrNjZxeHU2KzhjLy90SDFTUjl3d0FIK1BldnE0NmxUcDdyTDFXcTRyaTZGKzhvcnI3ajVJNXBIRXRCbGNKOTk5bGs3ODh3emszWkJwQjFBR2hzZndHZ292MmdvdjJnb3YyalNMYisvLy8zdmJpTDM2YWVmN3A4eE42bGJrd04xTHVob1Y1LzFndzgrYUljY2NvZ05IanpZelR6WG9DY0ZuUWtUSnJqSGFHQ1UrcmlWblJ4MzNISHVYRzBNaXdLQVprenpQOVNzTlczYU5KZGxhQ1hlaHg5KzJBM3QzWHp6emQxak5IeTNmLy8rcnF0Qjk3Lzg4c3QyODgwM3V5WXhEWWlxQ3hsSVJId0RqSWJ5aTRieWk2YTVsZCtycjc3cTVtem9nbEdKMU9HdUNZV0xGaTF5V1lnQ3g3YmJidXNtZXdmVXhhQW1LNjNhcTMyTjd0cHV1KzNjbFF6clFnQ0ppRC9nYUNpL2FDaS9hQ2kvYUdqQ0FnQ0VRZ0FCQUlSZzl2OEI0aE1PcEkrWGx0c0FBQUFBU1VWT1JLNUNZSUk9XCI7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwiLy8gLzxyZWZlcmVuY2UgcGF0aD1cIi4uL0V2ZW50L0V2ZW50LnRzXCIvPlxyXG4vLyAvPHJlZmVyZW5jZSBwYXRoPVwiLi4vVGltZS9UaW1lLnRzXCIvPlxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBEZXRlcm1pbmVzIHRoZSBtb2RlIGEgbG9vcCBydW5zIGluXHJcbiAgICovXHJcbiAgZXhwb3J0IGVudW0gTE9PUF9NT0RFIHtcclxuICAgIC8qKiBMb29wIGN5Y2xlcyBjb250cm9sbGVkIGJ5IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKi9cclxuICAgIEZSQU1FX1JFUVVFU1QgPSBcImZyYW1lUmVxdWVzdFwiLFxyXG4gICAgLyoqIExvb3AgY3ljbGVzIHdpdGggdGhlIGdpdmVuIGZyYW1lcmF0ZSBpbiB7QGxpbmsgVGltZS5nYW1lfSAqL1xyXG4gICAgVElNRV9HQU1FID0gXCJ0aW1lR2FtZVwiLFxyXG4gICAgLyoqIExvb3AgY3ljbGVzIHdpdGggdGhlIGdpdmVuIGZyYW1lcmF0ZSBpbiByZWFsdGltZSwgaW5kZXBlbmRlbnQgb2Yge0BsaW5rIFRpbWUuZ2FtZX0gKi9cclxuICAgIFRJTUVfUkVBTCA9IFwidGltZVJlYWxcIlxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29yZSBsb29wIG9mIGEgRnVkZ2UgYXBwbGljYXRpb24uIEluaXRpYWxpemVzIGF1dG9tYXRpY2FsbHkgYW5kIG11c3QgYmUgc3RhcnRlZCBleHBsaWNpdGx5LlxyXG4gICAqIEl0IHRoZW4gZmlyZXMge0BsaW5rIEVWRU5ULkxPT1BfRlJBTUV9IHRvIGFsbCBhZGRlZCBsaXN0ZW5lcnMgYXQgZWFjaCBmcmFtZVxyXG4gICAqIFxyXG4gICAqIEBhdXRob3IgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgTG9vcCBleHRlbmRzIEV2ZW50VGFyZ2V0U3RhdGljIHtcclxuICAgIHByaXZhdGUgc3RhdGljIMaSVGltZVN0YXJ0R2FtZTogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgc3RhdGljIMaSVGltZVN0YXJ0UmVhbDogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgc3RhdGljIMaSVGltZUZyYW1lR2FtZTogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgc3RhdGljIMaSVGltZUZyYW1lUmVhbDogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgc3RhdGljIMaSVGltZUZyYW1lU3RhcnRHYW1lOiBudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgxpJUaW1lRnJhbWVTdGFydFJlYWw6IG51bWJlciA9IDA7XHJcbiAgICBwcml2YXRlIHN0YXRpYyDGklRpbWVMYXN0RnJhbWVHYW1lQXZnOiBudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgxpJUaW1lTGFzdEZyYW1lUmVhbEF2ZzogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgc3RhdGljIMaSRnJhbWVzOiBudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcnVubmluZzogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgbW9kZTogTE9PUF9NT0RFID0gTE9PUF9NT0RFLkZSQU1FX1JFUVVFU1Q7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBpZEludGVydmFsbDogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgc3RhdGljIGlkUmVxdWVzdDogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgc3RhdGljIGZwc0Rlc2lyZWQ6IG51bWJlciA9IDMwO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZnJhbWVzVG9BdmVyYWdlOiBudW1iZXIgPSAzMDtcclxuICAgIHByaXZhdGUgc3RhdGljIHN5bmNXaXRoQW5pbWF0aW9uRnJhbWU6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICAvKiogVGhlIGdhbWV0aW1lIHRoZSBsb29wIHdhcyBzdGFydGVkLCBvdmVyd3JpdHRlbiBhdCBlYWNoIHN0YXJ0ICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldCB0aW1lU3RhcnRHYW1lKCk6IG51bWJlciB7IHJldHVybiBMb29wLsaSVGltZVN0YXJ0R2FtZTsgfVxyXG4gICAgLyoqIFRoZSByZWFsdGltZSB0aGUgbG9vcCB3YXMgc3RhcnRlZCwgb3ZlcndyaXR0ZW4gYXQgZWFjaCBzdGFydCAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXQgdGltZVN0YXJ0UmVhbCgpOiBudW1iZXIgeyByZXR1cm4gTG9vcC7GklRpbWVTdGFydFJlYWw7IH1cclxuICAgIC8qKiBUaGUgZ2FtZXRpbWUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCBsb29wIGN5Y2xlICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldCB0aW1lRnJhbWVHYW1lKCk6IG51bWJlciB7IHJldHVybiBMb29wLsaSVGltZUZyYW1lR2FtZTsgfVxyXG4gICAgLyoqIFRoZSByZWFsdGltZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IGxvb3AgY3ljbGUgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0IHRpbWVGcmFtZVJlYWwoKTogbnVtYmVyIHsgcmV0dXJuIExvb3AuxpJUaW1lRnJhbWVSZWFsOyB9XHJcbiAgICAvKiogVGhlIGdhbWV0aW1lIHRoZSBsYXN0IGxvb3AgY3ljbGUgc3RhcnRlZCovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldCB0aW1lRnJhbWVTdGFydEdhbWUoKTogbnVtYmVyIHsgcmV0dXJuIExvb3AuxpJUaW1lRnJhbWVTdGFydEdhbWU7IH1cclxuICAgIC8qKiBUaGUgcmVhbHRpbWUgdGhlIGxhc3QgbG9vcCBjeWNsZSBzdGFydGVkKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0IHRpbWVGcmFtZVN0YXJ0UmVhbCgpOiBudW1iZXIgeyByZXR1cm4gTG9vcC7GklRpbWVGcmFtZVN0YXJ0UmVhbDsgfVxyXG4gICAgLyoqIFRoZSBhdmVyYWdlIG51bWJlciBvZiBmcmFtZXMgcGVyIHNlY29uZCBpbiBnYW1ldGltZSAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXQgZnBzR2FtZUF2ZXJhZ2UoKTogbnVtYmVyIHsgcmV0dXJuIDEwMDAgLyBMb29wLsaSVGltZUxhc3RGcmFtZUdhbWVBdmc7IH1cclxuICAgIC8qKiBUaGUgYXZlcmFnZSBudW1iZXIgb2YgZnJhbWVzIHBlciBzZWNvbmQgaW4gcmVhbHRpbWUgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0IGZwc1JlYWxBdmVyYWdlKCk6IG51bWJlciB7IHJldHVybiAxMDAwIC8gTG9vcC7GklRpbWVMYXN0RnJhbWVSZWFsQXZnOyB9XHJcbiAgICAvKiogVGhlIG51bWJlciBvZiBmcmFtZXMgdHJpZ2dlcmVkIHNvIGZhciAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXQgZnJhbWVzKCk6IG51bWJlciB7IHJldHVybiBMb29wLsaSRnJhbWVzOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgdGhlIGxvb3Agd2l0aCB0aGUgZ2l2ZW4gbW9kZSBhbmQgZnBzLiAgXHJcbiAgICAgKiBUaGUgZGVmYXVsdCBmb3IgX21vZGUgaXMgRlJBTUVfUkVRVUVTVCwgc2VlIHtAbGluayBMT09QX01PREV9LCBob29raW5nIHRoZSBsb29wIHRvIHRoZSBicm93c2VyJ3MgYW5pbWF0aW9uIGZyYW1lLlxyXG4gICAgICogSXMgb25seSBhcHBsaWNhYmxlIGluIFRJTUUtbW9kZXMuXHJcbiAgICAgKiBfc3luY1dpdGhBbmltYXRpb25GcmFtZSBpcyBleHBlcmltZW50YWwgYW5kIG9ubHkgYXBwbGljYWJsZSBpbiBUSU1FLW1vZGVzLCBkZWZlcnJpbmcgdGhlIGxvb3AtY3ljbGUgdW50aWwgdGhlIG5leHQgcG9zc2libGUgYW5pbWF0aW9uIGZyYW1lLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHN0YXJ0KF9tb2RlOiBMT09QX01PREUgPSBMT09QX01PREUuRlJBTUVfUkVRVUVTVCwgX2ZwczogbnVtYmVyID0gNjAsIF9zeW5jV2l0aEFuaW1hdGlvbkZyYW1lOiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcclxuICAgICAgTG9vcC5zdG9wKCk7XHJcblxyXG4gICAgICBMb29wLsaSVGltZVN0YXJ0R2FtZSA9IFRpbWUuZ2FtZS5nZXQoKTtcclxuICAgICAgTG9vcC7GklRpbWVTdGFydFJlYWwgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgTG9vcC7GklRpbWVGcmFtZVN0YXJ0R2FtZSA9IExvb3AuxpJUaW1lU3RhcnRHYW1lO1xyXG4gICAgICBMb29wLsaSVGltZUZyYW1lU3RhcnRSZWFsID0gTG9vcC7GklRpbWVTdGFydFJlYWw7XHJcbiAgICAgIExvb3AuZnBzRGVzaXJlZCA9IChfbW9kZSA9PSBMT09QX01PREUuRlJBTUVfUkVRVUVTVCkgPyA2MCA6IF9mcHM7XHJcbiAgICAgIExvb3AuZnJhbWVzVG9BdmVyYWdlID0gTG9vcC5mcHNEZXNpcmVkO1xyXG4gICAgICBMb29wLsaSVGltZUxhc3RGcmFtZUdhbWVBdmcgPSBMb29wLsaSVGltZUxhc3RGcmFtZVJlYWxBdmcgPSAxMDAwIC8gTG9vcC5mcHNEZXNpcmVkO1xyXG4gICAgICBMb29wLm1vZGUgPSBfbW9kZTtcclxuICAgICAgTG9vcC5zeW5jV2l0aEFuaW1hdGlvbkZyYW1lID0gX3N5bmNXaXRoQW5pbWF0aW9uRnJhbWU7XHJcblxyXG4gICAgICBsZXQgbG9nOiBzdHJpbmcgPSBgTG9vcCBzdGFydGluZyBpbiBtb2RlICR7TG9vcC5tb2RlfWA7XHJcbiAgICAgIGlmIChMb29wLm1vZGUgIT0gTE9PUF9NT0RFLkZSQU1FX1JFUVVFU1QpXHJcbiAgICAgICAgbG9nICs9IGAgd2l0aCBhdHRlbXB0ZWQgJHtfZnBzfSBmcHNgO1xyXG4gICAgICBEZWJ1Zy5mdWRnZShsb2cpO1xyXG5cclxuICAgICAgc3dpdGNoIChfbW9kZSkge1xyXG4gICAgICAgIGNhc2UgTE9PUF9NT0RFLkZSQU1FX1JFUVVFU1Q6XHJcbiAgICAgICAgICBMb29wLmxvb3BGcmFtZSgpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBMT09QX01PREUuVElNRV9SRUFMOlxyXG4gICAgICAgICAgTG9vcC5pZEludGVydmFsbCA9IHdpbmRvdy5zZXRJbnRlcnZhbChMb29wLmxvb3BUaW1lLCAxMDAwIC8gTG9vcC5mcHNEZXNpcmVkKTtcclxuICAgICAgICAgIExvb3AubG9vcFRpbWUoKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgTE9PUF9NT0RFLlRJTUVfR0FNRTpcclxuICAgICAgICAgIExvb3AuaWRJbnRlcnZhbGwgPSBUaW1lLmdhbWUuc2V0VGltZXIoMTAwMCAvIExvb3AuZnBzRGVzaXJlZCwgMCwgTG9vcC5sb29wVGltZSk7XHJcbiAgICAgICAgICBMb29wLmxvb3BUaW1lKCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIExvb3AucnVubmluZyA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wcyB0aGUgbG9vcFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHN0b3AoKTogdm9pZCB7XHJcbiAgICAgIGlmICghTG9vcC5ydW5uaW5nKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIHN3aXRjaCAoTG9vcC5tb2RlKSB7XHJcbiAgICAgICAgY2FzZSBMT09QX01PREUuRlJBTUVfUkVRVUVTVDpcclxuICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShMb29wLmlkUmVxdWVzdCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIExPT1BfTU9ERS5USU1FX1JFQUw6XHJcbiAgICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbChMb29wLmlkSW50ZXJ2YWxsKTtcclxuICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShMb29wLmlkUmVxdWVzdCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIExPT1BfTU9ERS5USU1FX0dBTUU6XHJcbiAgICAgICAgICBUaW1lLmdhbWUuZGVsZXRlVGltZXIoTG9vcC5pZEludGVydmFsbCk7XHJcbiAgICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoTG9vcC5pZFJlcXVlc3QpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBMb29wLnJ1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgRGVidWcuZnVkZ2UoXCJMb29wIHN0b3BwZWQhXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgY29udGludWUoKTogdm9pZCB7XHJcbiAgICAgIGlmIChMb29wLnJ1bm5pbmcpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgTG9vcC5zdGFydChMb29wLm1vZGUsIExvb3AuZnBzRGVzaXJlZCwgTG9vcC5zeW5jV2l0aEFuaW1hdGlvbkZyYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBsb29wKCk6IHZvaWQge1xyXG4gICAgICBsZXQgdGltZTogbnVtYmVyO1xyXG4gICAgICB0aW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgIExvb3AuxpJUaW1lRnJhbWVSZWFsID0gdGltZSAtIExvb3AuxpJUaW1lRnJhbWVTdGFydFJlYWw7XHJcbiAgICAgIExvb3AuxpJUaW1lRnJhbWVTdGFydFJlYWwgPSB0aW1lO1xyXG5cclxuICAgICAgdGltZSA9IFRpbWUuZ2FtZS5nZXQoKTtcclxuICAgICAgTG9vcC7GklRpbWVGcmFtZUdhbWUgPSB0aW1lIC0gTG9vcC7GklRpbWVGcmFtZVN0YXJ0R2FtZTtcclxuICAgICAgTG9vcC7GklRpbWVGcmFtZVN0YXJ0R2FtZSA9IHRpbWU7XHJcblxyXG4gICAgICBMb29wLsaSVGltZUxhc3RGcmFtZUdhbWVBdmcgPSAoKExvb3AuZnJhbWVzVG9BdmVyYWdlIC0gMSkgKiBMb29wLsaSVGltZUxhc3RGcmFtZUdhbWVBdmcgKyBMb29wLsaSVGltZUZyYW1lR2FtZSkgLyBMb29wLmZyYW1lc1RvQXZlcmFnZTtcclxuICAgICAgTG9vcC7GklRpbWVMYXN0RnJhbWVSZWFsQXZnID0gKChMb29wLmZyYW1lc1RvQXZlcmFnZSAtIDEpICogTG9vcC7GklRpbWVMYXN0RnJhbWVSZWFsQXZnICsgTG9vcC7GklRpbWVGcmFtZVJlYWwpIC8gTG9vcC5mcmFtZXNUb0F2ZXJhZ2U7XHJcblxyXG4gICAgICAvLyBUT0RPOiBjb25zaWRlciBMb29wRXZlbnQgd2hpY2ggY29udmV5cyBpbmZvcm1hdGlvbiBzdWNoIGFzIHRpbWVFbGFwc2VkIGV0Yy4uLlxyXG4gICAgICBMb29wLsaSRnJhbWVzKys7XHJcbiAgICAgIGxldCBldmVudDogRXZlbnQgPSBuZXcgRXZlbnQoRVZFTlQuTE9PUF9GUkFNRSk7XHJcbiAgICAgIExvb3AudGFyZ2V0U3RhdGljLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGxvb3BGcmFtZSgpOiB2b2lkIHtcclxuICAgICAgTG9vcC5sb29wKCk7XHJcbiAgICAgIExvb3AuaWRSZXF1ZXN0ID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShMb29wLmxvb3BGcmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgbG9vcFRpbWUoKTogdm9pZCB7XHJcbiAgICAgIGlmIChMb29wLnN5bmNXaXRoQW5pbWF0aW9uRnJhbWUpXHJcbiAgICAgICAgTG9vcC5pZFJlcXVlc3QgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKExvb3AubG9vcCk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBMb29wLmxvb3AoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGludGVyZmFjZSBUaW1lVW5pdHMge1xyXG4gICAgaG91cnM/OiBudW1iZXI7XHJcbiAgICBtaW51dGVzPzogbnVtYmVyO1xyXG4gICAgc2Vjb25kcz86IG51bWJlcjtcclxuICAgIHRlbnRocz86IG51bWJlcjtcclxuICAgIGh1bmRyZWRzPzogbnVtYmVyO1xyXG4gICAgdGhvdXNhbmRzPzogbnVtYmVyO1xyXG4gICAgZnJhY3Rpb24/OiBudW1iZXI7XHJcbiAgICBhc0hvdXJzPzogbnVtYmVyO1xyXG4gICAgYXNNaW51dGVzPzogbnVtYmVyO1xyXG4gICAgYXNTZWNvbmRzPzogbnVtYmVyO1xyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGludGVyZmFjZSBUaW1lcnMgZXh0ZW5kcyBPYmplY3Qge1xyXG4gICAgW2lkOiBudW1iZXJdOiBUaW1lcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIGdlbmVyYXRlIGEgdGltZXN0YW1wIHRoYXQgY29ycmVsYXRlcyB3aXRoIHRoZSB0aW1lIGVsYXBzZWQgc2luY2UgdGhlIHN0YXJ0IG9mIHRoZSBwcm9ncmFtIGJ1dCBhbGxvd3MgZm9yIHJlc2V0dGluZyBhbmQgc2NhbGluZy4gIFxyXG4gICAqIFN1cHBvcnRzIHtAbGluayBUaW1lcn1zIHNpbWlsYXIgdG8gd2luZG93LnNldEludGVydmFsIGJ1dCB3aXRoIHJlc3BlY3QgdG8gdGhlIHNjYWxlZCB0aW1lLlxyXG4gICAqIEFsbCB0aW1lIHZhbHVlcyBhcmUgZ2l2ZW4gaW4gbWlsbGlzZWNvbmRzXHJcbiAgICogXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgVGltZSBleHRlbmRzIEV2ZW50VGFyZ2V0xpIge1xyXG4gICAgLyoqIFN0YW5kYXJkIGdhbWUgdGltZSBzdGFydGluZyBhdXRvbWF0aWNhbGx5IHdpdGggdGhlIGFwcGxpY2F0aW9uICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGdhbWU6IFRpbWUgPSBuZXcgVGltZSgpO1xyXG4gICAgcHJpdmF0ZSBzdGFydDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBzY2FsZTogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBvZmZzZXQ6IG51bWJlcjtcclxuICAgIHByaXZhdGUgbGFzdENhbGxUb0VsYXBzZWQ6IG51bWJlcjtcclxuICAgIHByaXZhdGUgdGltZXJzOiBUaW1lcnMgPSB7fTtcclxuICAgIHByaXZhdGUgaWRUaW1lckFkZGVkTGFzdDogbnVtYmVyID0gMDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5zdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICB0aGlzLnNjYWxlID0gMS4wO1xyXG4gICAgICB0aGlzLm9mZnNldCA9IDAuMDtcclxuICAgICAgdGhpcy5sYXN0Q2FsbFRvRWxhcHNlZCA9IDAuMDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGdhbWUtdGltZS1vYmplY3Qgd2hpY2ggc3RhcnRzIGF1dG9tYXRpY2FsbHkgYW5kIHNlcnZlcyBhcyBiYXNlIGZvciB2YXJpb3VzIGludGVybmFsIG9wZXJhdGlvbnMuIFxyXG4gICAgICovXHJcbiAgICAvLyBwdWJsaWMgc3RhdGljIGdldCBnYW1lKCk6IFRpbWUge1xyXG4gICAgLy8gICByZXR1cm4gVGltZS5nYW1lVGltZTtcclxuICAgIC8vIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldFVuaXRzKF9taWxsaXNlY29uZHM6IG51bWJlcik6IFRpbWVVbml0cyB7XHJcbiAgICAgIGxldCB1bml0czogVGltZVVuaXRzID0ge307XHJcblxyXG4gICAgICB1bml0cy5hc1NlY29uZHMgPSBfbWlsbGlzZWNvbmRzIC8gMTAwMDtcclxuICAgICAgdW5pdHMuYXNNaW51dGVzID0gdW5pdHMuYXNTZWNvbmRzIC8gNjA7XHJcbiAgICAgIHVuaXRzLmFzSG91cnMgPSB1bml0cy5hc01pbnV0ZXMgLyA2MDtcclxuXHJcbiAgICAgIHVuaXRzLmhvdXJzID0gTWF0aC5mbG9vcih1bml0cy5hc0hvdXJzKTtcclxuICAgICAgdW5pdHMubWludXRlcyA9IE1hdGguZmxvb3IodW5pdHMuYXNNaW51dGVzKSAlIDYwO1xyXG4gICAgICB1bml0cy5zZWNvbmRzID0gTWF0aC5mbG9vcih1bml0cy5hc1NlY29uZHMpICUgNjA7XHJcblxyXG4gICAgICB1bml0cy5mcmFjdGlvbiA9IF9taWxsaXNlY29uZHMgJSAxMDAwO1xyXG4gICAgICB1bml0cy50aG91c2FuZHMgPSBfbWlsbGlzZWNvbmRzICUgMTA7XHJcbiAgICAgIHVuaXRzLmh1bmRyZWRzID0gX21pbGxpc2Vjb25kcyAlIDEwMCAtIHVuaXRzLnRob3VzYW5kcztcclxuICAgICAgdW5pdHMudGVudGhzID0gdW5pdHMuZnJhY3Rpb24gLSB1bml0cy5odW5kcmVkcyAtIHVuaXRzLnRob3VzYW5kcztcclxuXHJcbiAgICAgIHJldHVybiB1bml0cztcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gR2V0L1NldCB0aW1lIGFuZCBzY2FsaW5nXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyB0aGUgY3VycmVudCBzY2FsZWQgdGltZXN0YW1wIG9mIHRoaXMgaW5zdGFuY2UgaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0ICsgdGhpcy5zY2FsZSAqIChwZXJmb3JtYW5jZS5ub3coKSAtIHRoaXMuc3RhcnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcmVtYWluaW5nIHRpbWUgdG8gdGhlIGdpdmVuIHBvaW50IG9mIHRpbWVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFJlbWFpbmRlcihfdG86IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiBfdG8gLSB0aGlzLmdldCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogKFJlLSkgU2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoaXMgaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSBfdGltZSBUaGUgdGltZXN0YW1wIHRvIHJlcHJlc2VudCB0aGUgY3VycmVudCB0aW1lIChkZWZhdWx0IDAuMClcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldChfdGltZTogbnVtYmVyID0gMCk6IHZvaWQge1xyXG4gICAgICB0aGlzLm9mZnNldCA9IF90aW1lO1xyXG4gICAgICB0aGlzLnN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgIHRoaXMuZ2V0RWxhcHNlZFNpbmNlUHJldmlvdXNDYWxsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBzY2FsaW5nIG9mIHRoaXMgdGltZSwgYWxsb3dpbmcgZm9yIHNsb3dtb3Rpb24gKDwxKSBvciBmYXN0Zm9yd2FyZCAoPjEpIFxyXG4gICAgICogQHBhcmFtIF9zY2FsZSBUaGUgZGVzaXJlZCBzY2FsaW5nIChkZWZhdWx0IDEuMClcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFNjYWxlKF9zY2FsZTogbnVtYmVyID0gMS4wKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuc2V0KHRoaXMuZ2V0KCkpO1xyXG4gICAgICB0aGlzLnNjYWxlID0gX3NjYWxlO1xyXG4gICAgICAvL1RPRE86IGNhdGNoIHNjYWxlPTBcclxuICAgICAgdGhpcy5yZXNjYWxlQWxsVGltZXJzKCk7XHJcbiAgICAgIHRoaXMuZ2V0RWxhcHNlZFNpbmNlUHJldmlvdXNDYWxsKCk7XHJcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuVElNRV9TQ0FMRUQpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyB0aGUgY3VycmVudCBzY2FsaW5nIG9mIHRoaXMgdGltZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0U2NhbGUoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc2NhbGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIG9mZnNldCBvZiB0aGlzIHRpbWVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldE9mZnNldCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5vZmZzZXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHNjYWxlZCB0aW1lIGluIG1pbGxpc2Vjb25kcyBwYXNzZWQgc2luY2UgdGhlIGxhc3QgY2FsbCB0byB0aGlzIG1ldGhvZFxyXG4gICAgICogQXV0b21hdGljYWxseSByZXNldCBhdCBldmVyeSBjYWxsIHRvIHNldCguLi4pIGFuZCBzZXRTY2FsZSguLi4pXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRFbGFwc2VkU2luY2VQcmV2aW91c0NhbGwoKTogbnVtYmVyIHtcclxuICAgICAgbGV0IGN1cnJlbnQ6IG51bWJlciA9IHRoaXMuZ2V0KCk7XHJcbiAgICAgIGxldCBlbGFwc2VkOiBudW1iZXIgPSBjdXJyZW50IC0gdGhpcy5sYXN0Q2FsbFRvRWxhcHNlZDtcclxuICAgICAgdGhpcy5sYXN0Q2FsbFRvRWxhcHNlZCA9IGN1cnJlbnQ7XHJcbiAgICAgIHJldHVybiBlbGFwc2VkO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG5cclxuICAgIC8vI3JlZ2lvbiBUaW1lcnNcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIFByb21pc2U8dm9pZD4gdG8gYmUgcmVzb2x2ZWQgYWZ0ZXIgdGhlIHRpbWUgZ2l2ZW4uIFRvIGJlIHVzZWQgd2l0aCBhc3luYy9hd2FpdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZGVsYXkoX2xhcHNlOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKF9yZXNvbHZlID0+IHRoaXMuc2V0VGltZXIoX2xhcHNlLCAxLCAoKSA9PiBfcmVzb2x2ZSgpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETzogZXhhbWluZSBpZiB3ZWItd29ya2VycyB3b3VsZCBlbmhhbmNlIHBlcmZvcm1hbmNlIGhlcmUhXHJcbiAgICAvKipcclxuICAgICAqIFN0b3BzIGFuZCBkZWxldGVzIGFsbCB7QGxpbmsgVGltZXJ9cyBhdHRhY2hlZC4gU2hvdWxkIGJlIGNhbGxlZCBiZWZvcmUgdGhpcyBUaW1lLW9iamVjdCBsZWF2ZXMgc2NvcGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGNsZWFyQWxsVGltZXJzKCk6IHZvaWQge1xyXG4gICAgICBmb3IgKGxldCBpZCBpbiB0aGlzLnRpbWVycykge1xyXG4gICAgICAgIHRoaXMuZGVsZXRlVGltZXIoTnVtYmVyKGlkKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZXMge0BsaW5rIFRpbWVyfSBmb3VuZCB1c2luZyB0aGUgaW50ZXJuYWwgaWQgb2YgdGhlIGNvbm5lY3RlZCBpbnRlcnZhbC1vYmplY3RcclxuICAgICAqIEBwYXJhbSBfaWQgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBkZWxldGVUaW1lckJ5SXRzSW50ZXJuYWxJZChfaWQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICBmb3IgKGxldCBpZCBpbiB0aGlzLnRpbWVycykge1xyXG4gICAgICAgIGxldCB0aW1lcjogVGltZXIgPSB0aGlzLnRpbWVyc1tpZF07XHJcbiAgICAgICAgaWYgKHRpbWVyLmlkID09IF9pZCkge1xyXG4gICAgICAgICAgdGltZXIuY2xlYXIoKTtcclxuICAgICAgICAgIGRlbGV0ZSB0aGlzLnRpbWVyc1tpZF07XHJcbiAgICAgICAgICAvLyBUT0RPOiBjaGVjayBpZiBhbiBlYXJseSBvdXQgaXMgT0sgaGVyZS4uLiBzaG91bGQgYmUhXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnN0YWxscyBhIHRpbWVyIGF0IHRoaXMgdGltZSBvYmplY3RcclxuICAgICAqIEBwYXJhbSBfbGFwc2UgVGhlIG9iamVjdC10aW1lIHRvIGVsYXBzZSBiZXR3ZWVuIHRoZSBjYWxscyB0byBfY2FsbGJhY2tcclxuICAgICAqIEBwYXJhbSBfY291bnQgVGhlIG51bWJlciBvZiBjYWxscyBkZXNpcmVkLCAwID0gSW5maW5pdGVcclxuICAgICAqIEBwYXJhbSBfaGFuZGxlciBUaGUgZnVuY3Rpb24gdG8gY2FsbCBlYWNoIHRoZSBnaXZlbiBsYXBzZSBoYXMgZWxhcHNlZFxyXG4gICAgICogQHBhcmFtIF9hcmd1bWVudHMgQWRkaXRpb25hbCBwYXJhbWV0ZXJzIHRvIHBhc3MgdG8gY2FsbGJhY2sgZnVuY3Rpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFRpbWVyKF9sYXBzZTogbnVtYmVyLCBfY291bnQ6IG51bWJlciwgX2hhbmRsZXI6IFRpbWVySGFuZGxlciwgLi4uX2FyZ3VtZW50czogT2JqZWN0W10pOiBudW1iZXIge1xyXG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLXVudXNlZC1leHByZXNzaW9uXHJcbiAgICAgIG5ldyBUaW1lcih0aGlzLCBfbGFwc2UsIF9jb3VudCwgX2hhbmRsZXIsIF9hcmd1bWVudHMpO1xyXG4gICAgICAvL3RoaXMuYWRkVGltZXIodGltZXIpO1xyXG4gICAgICByZXR1cm4gdGhpcy5pZFRpbWVyQWRkZWRMYXN0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGludGVybmFsbHkgYnkge0BsaW5rIFRpbWV9IGFuZCB7QGxpbmsgVGltZXJ9IGFuZCBtdXN0IG5vdCBiZSBjYWxsZWQgb3RoZXJ3aXNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhZGRUaW1lcihfdGltZXI6IFRpbWVyKTogbnVtYmVyIHtcclxuICAgICAgdGhpcy50aW1lcnNbKyt0aGlzLmlkVGltZXJBZGRlZExhc3RdID0gX3RpbWVyO1xyXG4gICAgICByZXR1cm4gdGhpcy5pZFRpbWVyQWRkZWRMYXN0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyB0aGUgdGltZXIgd2l0aCB0aGUgaWQgZ2l2ZW4gYnkgdGhpcyB0aW1lIG9iamVjdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZGVsZXRlVGltZXIoX2lkOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgbGV0IHRpbWVyOiBUaW1lciA9IHRoaXMudGltZXJzW19pZF07XHJcbiAgICAgIGlmICghdGltZXIpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB0aW1lci5jbGVhcigpO1xyXG4gICAgICBkZWxldGUgdGhpcy50aW1lcnNbX2lkXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIHRpbWVyIHdpdGggdGhlIGdpdmVuIGlkIG9yIG51bGwgaWYgbm90IGZvdW5kLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0VGltZXIoX2lkOiBudW1iZXIpOiBUaW1lciB7XHJcbiAgICAgIHJldHVybiB0aGlzLnRpbWVyc1tfaWRdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIGxpc3Qgb2YgdGltZXJzIGN1cnJlbnRseSBpbnN0YWxsZWQgb24gdGhpcyB0aW1lIG9iamVjdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0VGltZXJzKCk6IFRpbWVycyB7XHJcbiAgICAgIGxldCByZXN1bHQ6IFRpbWVycyA9IHt9O1xyXG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihyZXN1bHQsIHRoaXMudGltZXJzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGVyZSBhcmUge0BsaW5rIFRpbWVyc30gaW5zdGFsbGVkIHRvIHRoaXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGhhc1RpbWVycygpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIChPYmplY3Qua2V5cyh0aGlzLnRpbWVycykubGVuZ3RoID4gMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWNyZWF0ZXMge0BsaW5rIFRpbWVyfXMgd2hlbiBzY2FsaW5nIGNoYW5nZXNcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSByZXNjYWxlQWxsVGltZXJzKCk6IHZvaWQge1xyXG4gICAgICBmb3IgKGxldCBpZCBpbiB0aGlzLnRpbWVycykge1xyXG4gICAgICAgIGxldCB0aW1lcjogVGltZXIgPSB0aGlzLnRpbWVyc1tpZF07XHJcbiAgICAgICAgdGltZXIuY2xlYXIoKTtcclxuICAgICAgICBkZWxldGUgdGhpcy50aW1lcnNbaWRdO1xyXG4gICAgICAgIGlmICghdGhpcy5zY2FsZSlcclxuICAgICAgICAgIC8vIFRpbWUgaGFzIHN0b3BwZWQsIG5vIG5lZWQgdG8gcmVwbGFjZSBjbGVhcmVkIHRpbWVyc1xyXG4gICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgIC8qIHRoaXMudGltZXJzW2lkXSA9ICAqL1xyXG4gICAgICAgIHRpbWVyID0gdGltZXIuaW5zdGFsbENvcHkoKTsgLy8gdGhlIHRpbWVyIGlzIGF1dG9tYXRpY2FsbHkgYWRkZWQgdG8gdGhpcyB0aW1lIGluc3RhbmNlXHJcbiAgICAgICAgZGVsZXRlIHRoaXMudGltZXJzW3RoaXMuaWRUaW1lckFkZGVkTGFzdF07IC8vIHJlbW92ZSB0aGUgY29weSBhZ2FpbiAuLi5cclxuICAgICAgICB0aGlzLnRpbWVyc1tpZF0gPSB0aW1lcjsgLy8gLi4uIGFuZCBwbGFjZSBpdCBhdCB0aGUgaWQgb2YgdGhlIG9yaWdpbmFsXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgLy8jZW5kcmVnaW9uXHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBEZWZpbmVzIHRoZSBzaWduYXR1cmUgb2YgaGFuZGxlciBmdW5jdGlvbnMgZm9yIHtAbGluayBFdmVudFRpbWVyfXMsIHZlcnkgc2ltaWxhciB0byB1c3VhbCBldmVudCBoYW5kbGVyXHJcbiAgICovXHJcbiAgZXhwb3J0IHR5cGUgVGltZXJIYW5kbGVyID0gKF9ldmVudDogRXZlbnRUaW1lcikgPT4gdm9pZDtcclxuXHJcbiAgLyoqXHJcbiAgICogQSB7QGxpbmsgVGltZXJ9LWluc3RhbmNlIGludGVybmFsbHkgdXNlcyB3aW5kb3cuc2V0SW50ZXJ2YWwgdG8gY2FsbCBhIGdpdmVuIGhhbmRsZXIgd2l0aCBhIGdpdmVuIGZyZXF1ZW5jeSBhIGdpdmVuIG51bWJlciBvZiB0aW1lcyxcclxuICAgKiBwYXNzaW5nIGFuIHtAbGluayBFdmVudFRpbWVyfS1pbnN0YW5jZSB3aXRoIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYW5kIGdpdmVuIGFyZ3VtZW50cy4gXHJcbiAgICogVGhlIGZyZXF1ZW5jeSBzY2FsZXMgd2l0aCB0aGUge0BsaW5rIFRpbWV9LWluc3RhbmNlIHRoZSB7QGxpbmsgVGltZXJ9LWluc3RhbmNlIGlzIGF0dGFjaGVkIHRvLlxyXG4gICAqIFxyXG4gICAqIEBhdXRob3IgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgVGltZXIge1xyXG4gICAgcHVibGljIGFjdGl2ZTogYm9vbGVhbjtcclxuICAgIHB1YmxpYyBjb3VudDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBoYW5kbGVyOiBUaW1lckhhbmRsZXI7XHJcbiAgICBwcml2YXRlIHRpbWU6IFRpbWU7XHJcbiAgICBwcml2YXRlIGVsYXBzZTogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBldmVudDogRXZlbnRUaW1lcjtcclxuICAgIHByaXZhdGUgdGltZW91dFJlYWw6IG51bWJlcjtcclxuICAgIHByaXZhdGUgaWRXaW5kb3c6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSB7QGxpbmsgVGltZXJ9IGluc3RhbmNlLlxyXG4gICAgICogQHBhcmFtIF90aW1lIFRoZSB7QGxpbmsgVGltZX0gaW5zdGFuY2UsIHRoZSB0aW1lciBhdHRhY2hlcyB0b1xyXG4gICAgICogQHBhcmFtIF9lbGFwc2UgVGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHRvIGVsYXBzZSwgdG8gdGhlIG5leHQgY2FsbCBvZiBfaGFuZGxlciwgbWVhc3VyZWQgaW4gX3RpbWVcclxuICAgICAqIEBwYXJhbSBfY291bnQgVGhlIGRlc2lyZWQgbnVtYmVyIG9mIGNhbGxzIHRvIF9oYW5kbGVyLCBUaW1lciBkZWluc3RhbGxzIGF1dG9tYXRpY2FsbHkgYWZ0ZXIgbGFzdCBjYWxsLiBQYXNzaW5nIDAgaW52b2tlcyBpbmZpbml0ZSBjYWxsc1xyXG4gICAgICogQHBhcmFtIF9oYW5kbGVyIFRoZSB7QGxpbmsgVGltZXJIYW5kbGVyfSBpbnN0YW5jZSB0byBjYWxsXHJcbiAgICAgKiBAcGFyYW0gX2FyZ3VtZW50cyBBZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBwYXNzIHRvIF9oYW5kbGVyXHJcbiAgICAgKiBcclxuICAgICAqIFRPRE86IGZvciBwcm9wZXIgaGFuZGxpbmcgYW5kIGRlbGV0aW9uLCB1c2UgVGltZS5zZXRUaW1lciBpbnN0ZWFkIG9mIGluc3RhbnRpYXRpbmcgdGltZXJzIHlvdXJzZWxmLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihfdGltZTogVGltZSwgX2VsYXBzZTogbnVtYmVyLCBfY291bnQ6IG51bWJlciwgX2hhbmRsZXI6IFRpbWVySGFuZGxlciwgLi4uX2FyZ3VtZW50czogT2JqZWN0W10pIHtcclxuICAgICAgdGhpcy50aW1lID0gX3RpbWU7XHJcbiAgICAgIHRoaXMuZWxhcHNlID0gX2VsYXBzZTtcclxuICAgICAgdGhpcy5ldmVudCA9IG5ldyBFdmVudFRpbWVyKHRoaXMsIF9hcmd1bWVudHMpO1xyXG4gICAgICB0aGlzLmhhbmRsZXIgPSBfaGFuZGxlcjtcclxuICAgICAgdGhpcy5jb3VudCA9IF9jb3VudDtcclxuXHJcbiAgICAgIGxldCBzY2FsZTogbnVtYmVyID0gTWF0aC5hYnMoX3RpbWUuZ2V0U2NhbGUoKSk7XHJcblxyXG4gICAgICBpZiAoIXNjYWxlKSB7XHJcbiAgICAgICAgLy8gVGltZSBpcyBzdG9wcGVkLCB0aW1lciB3b24ndCBiZSBhY3RpdmVcclxuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy50aW1lb3V0UmVhbCA9IHRoaXMuZWxhcHNlIC8gc2NhbGU7XHJcblxyXG4gICAgICBsZXQgY2FsbGJhY2s6IEZ1bmN0aW9uID0gKCk6IHZvaWQgPT4ge1xyXG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUpXHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICBcclxuICAgICAgICB0aGlzLmV2ZW50LmNvdW50ID0gdGhpcy5jb3VudDtcclxuICAgICAgICB0aGlzLmV2ZW50Lmxhc3RDYWxsID0gKHRoaXMuY291bnQgPT0gMSk7XHJcbiAgICAgICAgX2hhbmRsZXIodGhpcy5ldmVudCk7XHJcbiAgICAgICAgdGhpcy5ldmVudC5maXJzdENhbGwgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY291bnQgPiAwKVxyXG4gICAgICAgICAgaWYgKC0tdGhpcy5jb3VudCA9PSAwKVxyXG4gICAgICAgICAgICBfdGltZS5kZWxldGVUaW1lckJ5SXRzSW50ZXJuYWxJZCh0aGlzLmlkV2luZG93KTtcclxuXHJcbiAgICAgIH07XHJcblxyXG4gICAgICB0aGlzLmlkV2luZG93ID0gd2luZG93LnNldEludGVydmFsKGNhbGxiYWNrLCB0aGlzLnRpbWVvdXRSZWFsLCBfYXJndW1lbnRzKTtcclxuICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICBfdGltZS5hZGRUaW1lcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHdpbmRvdy1pZCBvZiB0aGUgdGltZXIsIHdoaWNoIHdhcyByZXR1cm5lZCBieSBzZXRJbnRlcnZhbFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGlkKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmlkV2luZG93O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdGltZS1pbnRlcnZhbGwgZm9yIGNhbGxzIHRvIHRoZSBoYW5kbGVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgbGFwc2UoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZWxhcHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXR0YWNoZXMgYSBjb3B5IG9mIHRoaXMgYXQgaXRzIGN1cnJlbnQgc3RhdGUgdG8gdGhlIHNhbWUge0BsaW5rIFRpbWV9LWluc3RhbmNlLiBVc2VkIGludGVybmFsbHkgd2hlbiByZXNjYWxpbmcge0BsaW5rIFRpbWV9XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpbnN0YWxsQ29weSgpOiBUaW1lciB7XHJcbiAgICAgIHJldHVybiBuZXcgVGltZXIodGhpcy50aW1lLCB0aGlzLmVsYXBzZSwgdGhpcy5jb3VudCwgdGhpcy5oYW5kbGVyLCB0aGlzLmV2ZW50LmFyZ3VtZW50cyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgdGhlIHRpbWVyLCByZW1vdmluZyBpdCBmcm9tIHRoZSBpbnRlcnZhbC10aW1lcnMgaGFuZGxlZCBieSB3aW5kb3dcclxuICAgICAqL1xyXG4gICAgcHVibGljIGNsZWFyKCk6IHZvaWQge1xyXG4gICAgICAvLyBpZiAodGhpcy50eXBlID09IFRJTUVSX1RZUEUuVElNRU9VVCkge1xyXG4gICAgICAvLyAgICAgaWYgKHRoaXMuYWN0aXZlKVxyXG4gICAgICAvLyAgICAgICAgIC8vIHNhdmUgcmVtYWluaW5nIHRpbWUgdG8gdGltZW91dCBhcyBuZXcgdGltZW91dCBmb3IgcmVzdGFydFxyXG4gICAgICAvLyAgICAgICAgIHRoaXMudGltZW91dCA9IHRoaXMudGltZW91dCAqICgxIC0gKHBlcmZvcm1hbmNlLm5vdygpIC0gdGhpcy5zdGFydFRpbWVSZWFsKSAvIHRoaXMudGltZW91dFJlYWwpO1xyXG4gICAgICAvLyAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLmlkKTtcclxuICAgICAgLy8gfVxyXG4gICAgICAvLyBlbHNlXHJcbiAgICAgIC8vIFRPRE86IHJldXNpbmcgdGltZXIgc3RhcnRzIGludGVydmFsIGFuZXcuIFNob3VsZCBiZSByZW1haW5pbmcgaW50ZXJ2YWwgYXMgdGltZW91dCwgdGhlbiBzdGFydGluZyBpbnRlcnZhbCBhbmV3IFxyXG4gICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLmlkV2luZG93KTtcclxuICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcbn0iXX0=