"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var FudgeCore;
(function (FudgeCore) {
    /**
     * Base class for the different DebugTargets, mainly for technical purpose of inheritance
     */
    class DebugTarget {
        static mergeArguments(_message, ..._args) {
            let out = _message.toString(); //JSON.stringify(_message);
            for (let arg of _args)
                if (arg instanceof Number)
                    out += ", " + arg.toPrecision(2).toString(); //JSON.stringify(arg, null, 2);
                else
                    out += ", " + arg.toString(); //JSON.stringify(arg, null, 2);
            return out;
        }
    }
    FudgeCore.DebugTarget = DebugTarget;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class EventTargetƒ extends EventTarget {
        addEventListener(_type, _handler, _options) {
            super.addEventListener(_type, _handler, _options);
        }
        removeEventListener(_type, _handler, _options) {
            super.removeEventListener(_type, _handler, _options);
        }
        dispatchEvent(_event) {
            return super.dispatchEvent(_event);
        }
    }
    FudgeCore.EventTargetƒ = EventTargetƒ;
    /**
     * Base class for EventTarget singletons, which are fixed entities in the structure of Fudge, such as the core loop
     */
    class EventTargetStatic extends EventTargetƒ {
        constructor() {
            super();
        }
        static addEventListener(_type, _handler) {
            EventTargetStatic.targetStatic.addEventListener(_type, _handler);
        }
        static removeEventListener(_type, _handler) {
            EventTargetStatic.targetStatic.removeEventListener(_type, _handler);
        }
        static dispatchEvent(_event) {
            EventTargetStatic.targetStatic.dispatchEvent(_event);
            return true;
        }
    }
    EventTargetStatic.targetStatic = new EventTargetStatic();
    FudgeCore.EventTargetStatic = EventTargetStatic;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="../Event/Event.ts"/>
var FudgeCore;
// / <reference path="../Event/Event.ts"/>
(function (FudgeCore) {
    // export interface MutatorForComponent extends Mutator { readonly forUserComponent: null; }
    /**
     * Collect applicable attributes of the instance and copies of their values in a Mutator-object
     */
    function getMutatorOfArbitrary(_object) {
        let mutator = {};
        let attributes = Reflect.ownKeys(Reflect.getPrototypeOf(_object));
        for (let attribute of attributes) {
            let value = Reflect.get(_object, attribute);
            if (value instanceof Function)
                continue;
            // if (value instanceof Object && !(value instanceof Mutable))
            //   continue;
            mutator[attribute.toString()] = value;
        }
        return mutator;
    }
    FudgeCore.getMutatorOfArbitrary = getMutatorOfArbitrary;
    /**
     * Base class for all types being mutable using [[Mutator]]-objects, thus providing and using interfaces created at runtime.
     * Mutables provide a [[Mutator]] that is build by collecting all object-properties that are either of a primitive type or again Mutable.
     * Subclasses can either reduce the standard [[Mutator]] built by this base class by deleting properties or implement an individual getMutator-method.
     * The provided properties of the [[Mutator]] must match public properties or getters/setters of the object.
     * Otherwise, they will be ignored if not handled by an override of the mutate-method in the subclass and throw errors in an automatically generated user-interface for the object.
     */
    class Mutable extends FudgeCore.EventTargetƒ {
        /**
         * Retrieves the type of this mutable subclass as the name of the runtime class
         * @returns The type of the mutable
         */
        get type() {
            return this.constructor.name;
        }
        /**
         * Collect applicable attributes of the instance and copies of their values in a Mutator-object
         */
        getMutator() {
            let mutator = {};
            // collect primitive and mutable attributes
            for (let attribute in this) {
                let value = this[attribute];
                if (value instanceof Function)
                    continue;
                if (value instanceof Object && !(value instanceof Mutable))
                    continue;
                mutator[attribute] = this[attribute];
            }
            // mutator can be reduced but not extended!
            Object.preventExtensions(mutator);
            // delete unwanted attributes
            this.reduceMutator(mutator);
            // replace references to mutable objects with references to copies
            for (let attribute in mutator) {
                let value = mutator[attribute];
                if (value instanceof Mutable)
                    mutator[attribute] = value.getMutator();
            }
            return mutator;
        }
        /**
         * Collect the attributes of the instance and their values applicable for animation.
         * Basic functionality is identical to [[getMutator]], returned mutator should then be reduced by the subclassed instance
         */
        getMutatorForAnimation() {
            return this.getMutator();
        }
        /**
         * Collect the attributes of the instance and their values applicable for the user interface.
         * Basic functionality is identical to [[getMutator]], returned mutator should then be reduced by the subclassed instance
         */
        getMutatorForUserInterface() {
            return this.getMutator();
        }
        /**
         * Collect the attributes of the instance and their values applicable for indiviualization by the component.
         * Basic functionality is identical to [[getMutator]], returned mutator should then be reduced by the subclassed instance
         */
        // public getMutatorForComponent(): MutatorForComponent {
        //     return <MutatorForComponent>this.getMutator();
        // }
        /**
         * Returns an associative array with the same attributes as the given mutator, but with the corresponding types as string-values
         * Does not recurse into objects!
         * @param _mutator
         */
        getMutatorAttributeTypes(_mutator) {
            let types = {};
            for (let attribute in _mutator) {
                let type = null;
                let value = _mutator[attribute];
                if (_mutator[attribute] != undefined)
                    if (typeof (value) == "object")
                        type = this[attribute].constructor.name;
                    else
                        type = _mutator[attribute].constructor.name;
                types[attribute] = type;
            }
            return types;
        }
        /**
         * Updates the values of the given mutator according to the current state of the instance
         * @param _mutator
         */
        updateMutator(_mutator) {
            for (let attribute in _mutator) {
                let value = _mutator[attribute];
                if (value instanceof Mutable)
                    value = value.getMutator();
                else
                    _mutator[attribute] = this[attribute];
            }
        }
        /**
         * Updates the attribute values of the instance according to the state of the mutator. Must be protected...!
         * @param _mutator
         */
        mutate(_mutator) {
            // TODO: don't assign unknown properties
            for (let attribute in _mutator) {
                let value = _mutator[attribute];
                let mutant = this[attribute];
                if (mutant instanceof Mutable)
                    mutant.mutate(value);
                else
                    this[attribute] = value;
            }
            this.dispatchEvent(new Event("mutate" /* MUTATE */));
        }
    }
    FudgeCore.Mutable = Mutable;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Handles the external serialization and deserialization of [[Serializable]] objects. The internal process is handled by the objects themselves.
     * A [[Serialization]] object can be created from a [[Serializable]] object and a JSON-String may be created from that.
     * Vice versa, a JSON-String can be parsed to a [[Serialization]] which can be deserialized to a [[Serializable]] object.
     * ```plaintext
     *  [Serializable] → (serialize) → [Serialization] → (stringify)
     *                                                        ↓
     *                                                    [String]
     *                                                        ↓
     *  [Serializable] ← (deserialize) ← [Serialization] ← (parse)
     * ```
     * While the internal serialize/deserialize methods of the objects care of the selection of information needed to recreate the object and its structure,
     * the [[Serializer]] keeps track of the namespaces and classes in order to recreate [[Serializable]] objects. The general structure of a [[Serialization]] is as follows
     * ```plaintext
     * {
     *      namespaceName.className: {
     *          propertyName: propertyValue,
     *          ...,
     *          propertyNameOfReference: SerializationOfTheReferencedObject,
     *          ...,
     *          constructorNameOfSuperclass: SerializationOfSuperClass
     *      }
     * }
     * ```
     * Since the instance of the superclass is created automatically when an object is created,
     * the SerializationOfSuperClass omits the the namespaceName.className key and consists only of its value.
     * The constructorNameOfSuperclass is given instead as a property name in the serialization of the subclass.
     */
    class Serializer {
        /**
         * Registers a namespace to the [[Serializer]], to enable automatic instantiation of classes defined within
         * @param _namespace
         */
        static registerNamespace(_namespace) {
            for (let name in Serializer.namespaces)
                if (Serializer.namespaces[name] == _namespace)
                    return;
            let name = Serializer.findNamespaceIn(_namespace, window);
            if (!name)
                for (let parentName in Serializer.namespaces) {
                    name = Serializer.findNamespaceIn(_namespace, Serializer.namespaces[parentName]);
                    if (name) {
                        name = parentName + "." + name;
                        break;
                    }
                }
            if (!name)
                throw new Error("Namespace not found. Maybe parent namespace hasn't been registered before?");
            Serializer.namespaces[name] = _namespace;
        }
        /**
         * Returns a javascript object representing the serializable FUDGE-object given,
         * including attached components, children, superclass-objects all information needed for reconstruction
         * @param _object An object to serialize, implementing the [[Serializable]] interface
         */
        static serialize(_object) {
            let serialization = {};
            // TODO: save the namespace with the constructors name
            // serialization[_object.constructor.name] = _object.serialize();
            let path = this.getFullPath(_object);
            if (!path)
                throw new Error(`Namespace of serializable object of type ${_object.constructor.name} not found. Maybe the namespace hasn't been registered or the class not exported?`);
            serialization[path] = _object.serialize();
            return serialization;
            // return _object.serialize();
        }
        /**
         * Returns a FUDGE-object reconstructed from the information in the [[Serialization]] given,
         * including attached components, children, superclass-objects
         * @param _serialization
         */
        static deserialize(_serialization) {
            let reconstruct;
            try {
                // loop constructed solely to access type-property. Only one expected!
                for (let path in _serialization) {
                    // reconstruct = new (<General>Fudge)[typeName];
                    reconstruct = Serializer.reconstruct(path);
                    reconstruct.deserialize(_serialization[path]);
                    return reconstruct;
                }
            }
            catch (_error) {
                throw new Error("Deserialization failed: " + _error);
            }
            return null;
        }
        //TODO: implement prettifier to make JSON-Stringification of serializations more readable, e.g. placing x, y and z in one line
        static prettify(_json) { return _json; }
        /**
         * Returns a formatted, human readable JSON-String, representing the given [[Serializaion]] that may have been created by [[Serializer]].serialize
         * @param _serialization
         */
        static stringify(_serialization) {
            // adjustments to serialization can be made here before stringification, if desired
            let json = JSON.stringify(_serialization, null, 2);
            let pretty = Serializer.prettify(json);
            return pretty;
        }
        /**
         * Returns a [[Serialization]] created from the given JSON-String. Result may be passed to [[Serializer]].deserialize
         * @param _json
         */
        static parse(_json) {
            return JSON.parse(_json);
        }
        /**
         * Creates an object of the class defined with the full path including the namespaceName(s) and the className seperated by dots(.)
         * @param _path
         */
        static reconstruct(_path) {
            let typeName = _path.substr(_path.lastIndexOf(".") + 1);
            let namespace = Serializer.getNamespace(_path);
            if (!namespace)
                throw new Error(`Namespace of serializable object of type ${typeName} not found. Maybe the namespace hasn't been registered?`);
            let reconstruction = new namespace[typeName];
            return reconstruction;
        }
        /**
         * Returns the full path to the class of the object, if found in the registered namespaces
         * @param _object
         */
        static getFullPath(_object) {
            let typeName = _object.constructor.name;
            // Debug.log("Searching namespace of: " + typeName);
            for (let namespaceName in Serializer.namespaces) {
                let found = Serializer.namespaces[namespaceName][typeName];
                if (found && _object instanceof found)
                    return namespaceName + "." + typeName;
            }
            return null;
        }
        /**
         * Returns the namespace-object defined within the full path, if registered
         * @param _path
         */
        static getNamespace(_path) {
            let namespaceName = _path.substr(0, _path.lastIndexOf("."));
            return Serializer.namespaces[namespaceName];
        }
        /**
         * Finds the namespace-object in properties of the parent-object (e.g. window), if present
         * @param _namespace
         * @param _parent
         */
        static findNamespaceIn(_namespace, _parent) {
            for (let prop in _parent)
                if (_parent[prop] == _namespace)
                    return prop;
            return null;
        }
    }
    /** In order for the Serializer to create class instances, it needs access to the appropriate namespaces */
    Serializer.namespaces = { "ƒ": FudgeCore };
    FudgeCore.Serializer = Serializer;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class RenderInjector {
        static inject(_constructor, _injector) {
            let injection = Reflect.get(_injector, "inject" + _constructor.name);
            if (!injection) {
                console.error("No injection decorator defined for " + _constructor.name);
            }
            Object.defineProperty(_constructor.prototype, "useRenderData", {
                value: injection
            });
        }
    }
    FudgeCore.RenderInjector = RenderInjector;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class RenderInjectorCoat extends FudgeCore.RenderInjector {
        static decorate(_constructor) {
            FudgeCore.RenderInjector.inject(_constructor, RenderInjectorCoat);
        }
        static injectCoatColored(_renderShader) {
            let colorUniformLocation = _renderShader.uniforms["u_color"];
            let color = this.color.getArray();
            FudgeCore.RenderOperator.getRenderingContext().uniform4fv(colorUniformLocation, color);
        }
        static injectCoatTextured(_renderShader) {
            let crc3 = FudgeCore.RenderOperator.getRenderingContext();
            if (this.renderData) {
                // buffers exist
                crc3.activeTexture(WebGL2RenderingContext.TEXTURE0);
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, this.renderData["texture0"]);
                crc3.uniform1i(_renderShader.uniforms["u_texture"], 0);
                crc3.uniformMatrix3fv(_renderShader.uniforms["u_pivot"], false, this.pivot.get());
            }
            else {
                this.renderData = {};
                // TODO: check if all WebGL-Creations are asserted
                const texture = FudgeCore.RenderManager.assert(crc3.createTexture());
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, texture);
                try {
                    crc3.texImage2D(crc3.TEXTURE_2D, 0, crc3.RGBA, crc3.RGBA, crc3.UNSIGNED_BYTE, this.texture.image);
                    crc3.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.UNSIGNED_BYTE, this.texture.image);
                }
                catch (_error) {
                    FudgeCore.Debug.error(_error);
                }
                crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, WebGL2RenderingContext.NEAREST);
                crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.NEAREST);
                crc3.generateMipmap(crc3.TEXTURE_2D);
                this.renderData["texture0"] = texture;
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
                this.useRenderData(_renderShader);
            }
        }
        static injectCoatMatCap(_renderShader) {
            let crc3 = FudgeCore.RenderOperator.getRenderingContext();
            let colorUniformLocation = _renderShader.uniforms["u_tint_color"];
            let { r, g, b, a } = this.tintColor;
            let tintColorArray = new Float32Array([r, g, b, a]);
            crc3.uniform4fv(colorUniformLocation, tintColorArray);
            let floatUniformLocation = _renderShader.uniforms["u_flatmix"];
            let flatMix = this.flatMix;
            crc3.uniform1f(floatUniformLocation, flatMix);
            if (this.renderData) {
                // buffers exist
                crc3.activeTexture(WebGL2RenderingContext.TEXTURE0);
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, this.renderData["texture0"]);
                crc3.uniform1i(_renderShader.uniforms["u_texture"], 0);
            }
            else {
                this.renderData = {};
                // TODO: check if all WebGL-Creations are asserted
                const texture = FudgeCore.RenderManager.assert(crc3.createTexture());
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, texture);
                try {
                    crc3.texImage2D(crc3.TEXTURE_2D, 0, crc3.RGBA, crc3.RGBA, crc3.UNSIGNED_BYTE, this.texture.image);
                    crc3.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.UNSIGNED_BYTE, this.texture.image);
                }
                catch (_error) {
                    FudgeCore.Debug.error(_error);
                }
                crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, WebGL2RenderingContext.NEAREST);
                crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.NEAREST);
                crc3.generateMipmap(crc3.TEXTURE_2D);
                this.renderData["texture0"] = texture;
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
                this.useRenderData(_renderShader);
            }
        }
    }
    FudgeCore.RenderInjectorCoat = RenderInjectorCoat;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class RenderInjectorMesh {
        static decorate(_constructor) {
            Object.defineProperty(_constructor.prototype, "useRenderBuffers", {
                value: RenderInjectorMesh.useRenderBuffers
            });
            Object.defineProperty(_constructor.prototype, "createRenderBuffers", {
                value: RenderInjectorMesh.createRenderBuffers
            });
            Object.defineProperty(_constructor.prototype, "deleteRenderBuffers", {
                value: RenderInjectorMesh.deleteRenderBuffers
            });
        }
        static createRenderBuffers() {
            // console.log("createRenderBuffers", this);
            // return;
            let crc3 = FudgeCore.RenderOperator.getRenderingContext();
            let vertices = FudgeCore.RenderOperator.assert(crc3.createBuffer());
            crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, vertices);
            crc3.bufferData(WebGL2RenderingContext.ARRAY_BUFFER, this.vertices, WebGL2RenderingContext.STATIC_DRAW);
            let indices = FudgeCore.RenderOperator.assert(crc3.createBuffer());
            crc3.bindBuffer(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, indices);
            crc3.bufferData(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, this.indices, WebGL2RenderingContext.STATIC_DRAW);
            let textureUVs = crc3.createBuffer();
            crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, textureUVs);
            crc3.bufferData(WebGL2RenderingContext.ARRAY_BUFFER, this.textureUVs, WebGL2RenderingContext.STATIC_DRAW);
            let normalsFace = FudgeCore.RenderOperator.assert(crc3.createBuffer());
            crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, normalsFace);
            crc3.bufferData(WebGL2RenderingContext.ARRAY_BUFFER, this.normalsFace, WebGL2RenderingContext.STATIC_DRAW);
            let renderBuffers = {
                vertices: vertices,
                indices: indices,
                nIndices: this.getIndexCount(),
                textureUVs: textureUVs,
                normalsFace: normalsFace
            };
            this.renderBuffers = renderBuffers;
        }
        static useRenderBuffers(_renderShader, _world, _projection, _id) {
            // console.log("useRenderBuffers", this);
            // return;
            let crc3 = FudgeCore.RenderOperator.getRenderingContext();
            let aPosition = _renderShader.attributes["a_position"];
            crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.renderBuffers.vertices);
            crc3.enableVertexAttribArray(aPosition);
            FudgeCore.RenderOperator.setAttributeStructure(aPosition, FudgeCore.Mesh.getBufferSpecification());
            crc3.bindBuffer(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, this.renderBuffers.indices);
            let uProjection = _renderShader.uniforms["u_projection"];
            crc3.uniformMatrix4fv(uProjection, false, _projection.get());
            // feed in face normals if shader accepts u_world. 
            let uWorld = _renderShader.uniforms["u_world"];
            if (uWorld) {
                crc3.uniformMatrix4fv(uWorld, false, _world.get());
            }
            let aNormal = _renderShader.attributes["a_normal"];
            if (aNormal) {
                crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.renderBuffers.normalsFace);
                crc3.enableVertexAttribArray(aNormal);
                FudgeCore.RenderOperator.setAttributeStructure(aNormal, FudgeCore.Mesh.getBufferSpecification());
            }
            // feed in texture coordinates if shader accepts a_textureUVs
            let aTextureUVs = _renderShader.attributes["a_textureUVs"];
            if (aTextureUVs) {
                crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.renderBuffers.textureUVs);
                crc3.enableVertexAttribArray(aTextureUVs); // enable the buffer
                crc3.vertexAttribPointer(aTextureUVs, 2, WebGL2RenderingContext.FLOAT, false, 0, 0);
            }
            // feed in an id of the node if shader accepts u_id. Used for picking
            let uId = _renderShader.uniforms["u_id"];
            if (uId)
                FudgeCore.RenderOperator.getRenderingContext().uniform1i(uId, _id);
        }
        static deleteRenderBuffers(_renderBuffers) {
            // console.log("deleteRenderBuffers", this);
            // return;
            let crc3 = FudgeCore.RenderOperator.getRenderingContext();
            if (_renderBuffers) {
                crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, null);
                crc3.deleteBuffer(_renderBuffers.vertices);
                crc3.deleteBuffer(_renderBuffers.textureUVs);
                crc3.bindBuffer(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, null);
                crc3.deleteBuffer(_renderBuffers.indices);
            }
        }
    }
    FudgeCore.RenderInjectorMesh = RenderInjectorMesh;
})(FudgeCore || (FudgeCore = {}));
///<reference path="RenderInjector.ts"/>
///<reference path="RenderInjectorCoat.ts"/>
///<reference path="RenderInjectorMesh.ts"/>
var FudgeCore;
///<reference path="RenderInjector.ts"/>
///<reference path="RenderInjectorCoat.ts"/>
///<reference path="RenderInjectorMesh.ts"/>
(function (FudgeCore) {
    /**
     * Base class for RenderManager, handling the connection to the rendering system, in this case WebGL.
     * Methods and attributes of this class should not be called directly, only through [[RenderManager]]
     */
    class RenderOperator {
        /**
         * Wrapper function to utilize the bufferSpecification interface when passing data to the shader via a buffer.
         * @param _attributeLocation // The location of the attribute on the shader, to which they data will be passed.
         * @param _bufferSpecification // Interface passing datapullspecifications to the buffer.
         */
        static setAttributeStructure(_attributeLocation, _bufferSpecification) {
            RenderOperator.crc3.vertexAttribPointer(_attributeLocation, _bufferSpecification.size, _bufferSpecification.dataType, _bufferSpecification.normalize, _bufferSpecification.stride, _bufferSpecification.offset);
        }
        /**
        * Checks the first parameter and throws an exception with the WebGL-errorcode if the value is null
        * @param _value // value to check against null
        * @param _message // optional, additional message for the exception
        */
        static assert(_value, _message = "") {
            if (_value === null)
                throw new Error(`Assertion failed. ${_message}, WebGL-Error: ${RenderOperator.crc3 ? RenderOperator.crc3.getError() : ""}`);
            return _value;
        }
        /**
         * Initializes offscreen-canvas, renderingcontext and hardware viewport.
         */
        static initialize(_antialias = false, _alpha = true) {
            let contextAttributes = { alpha: _alpha, antialias: _antialias, premultipliedAlpha: false };
            let canvas = document.createElement("canvas");
            RenderOperator.crc3 = RenderOperator.assert(canvas.getContext("webgl2", contextAttributes), "WebGL-context couldn't be created");
            // Enable backface- and zBuffer-culling.
            RenderOperator.crc3.enable(WebGL2RenderingContext.CULL_FACE);
            RenderOperator.crc3.enable(WebGL2RenderingContext.DEPTH_TEST);
            RenderOperator.crc3.enable(WebGL2RenderingContext.BLEND);
            RenderOperator.crc3.blendEquation(WebGL2RenderingContext.FUNC_ADD);
            RenderOperator.crc3.blendFunc(WebGL2RenderingContext.DST_ALPHA, WebGL2RenderingContext.ONE_MINUS_DST_ALPHA);
            // RenderOperator.crc3.enable(WebGL2RenderingContext.);
            // RenderOperator.crc3.pixelStorei(WebGL2RenderingContext.UNPACK_FLIP_Y_WEBGL, true);
            RenderOperator.rectViewport = RenderOperator.getCanvasRect();
            RenderOperator.renderShaderRayCast = RenderOperator.createProgram(FudgeCore.ShaderRayCast);
        }
        /**
         * Return a reference to the offscreen-canvas
         */
        static getCanvas() {
            return RenderOperator.crc3.canvas; // TODO: enable OffscreenCanvas
        }
        /**
         * Return a reference to the rendering context
         */
        static getRenderingContext() {
            return RenderOperator.crc3;
        }
        /**
         * Return a rectangle describing the size of the offscreen-canvas. x,y are 0 at all times.
         */
        static getCanvasRect() {
            let canvas = RenderOperator.crc3.canvas;
            return FudgeCore.Rectangle.GET(0, 0, canvas.width, canvas.height);
        }
        /**
         * Set the size of the offscreen-canvas.
         */
        static setCanvasSize(_width, _height) {
            RenderOperator.crc3.canvas.width = _width;
            RenderOperator.crc3.canvas.height = _height;
        }
        /**
         * Set the area on the offscreen-canvas to render the camera image to.
         * @param _rect
         */
        static setViewportRectangle(_rect) {
            Object.assign(RenderOperator.rectViewport, _rect);
            RenderOperator.crc3.viewport(_rect.x, _rect.y, _rect.width, _rect.height);
        }
        /**
         * Retrieve the area on the offscreen-canvas the camera image gets rendered to.
         */
        static getViewportRectangle() {
            return RenderOperator.rectViewport;
        }
        /**
         * Convert light data to flat arrays
         * TODO: this method appears to be obsolete...?
         */
        static createRenderLights(_lights) {
            let renderLights = {};
            for (let entry of _lights) {
                // TODO: simplyfy, since direction is now handled by ComponentLight
                switch (entry[0]) {
                    case FudgeCore.LightAmbient:
                        let ambient = [];
                        for (let cmpLight of entry[1]) {
                            let c = cmpLight.light.color;
                            ambient.push(c.r, c.g, c.b, c.a);
                        }
                        renderLights["u_ambient"] = new Float32Array(ambient);
                        break;
                    case FudgeCore.LightDirectional:
                        let directional = [];
                        for (let cmpLight of entry[1]) {
                            let c = cmpLight.light.color;
                            // let d: Vector3 = (<LightDirectional>light.getLight()).direction;
                            directional.push(c.r, c.g, c.b, c.a, 0, 0, 1);
                        }
                        renderLights["u_directional"] = new Float32Array(directional);
                        break;
                    default:
                        FudgeCore.Debug.warn("Shaderstructure undefined for", entry[0]);
                }
            }
            return renderLights;
        }
        /**
         * Set light data in shaders
         */
        static setLightsInShader(_renderShader, _lights) {
            RenderOperator.useProgram(_renderShader);
            let uni = _renderShader.uniforms;
            let ambient = uni["u_ambient.color"];
            if (ambient) {
                let cmpLights = _lights.get(FudgeCore.LightAmbient);
                if (cmpLights) {
                    // TODO: add up ambient lights to a single color
                    let result = new FudgeCore.Color(0, 0, 0, 1);
                    for (let cmpLight of cmpLights)
                        result.add(cmpLight.light.color);
                    RenderOperator.crc3.uniform4fv(ambient, result.getArray());
                }
            }
            let nDirectional = uni["u_nLightsDirectional"];
            if (nDirectional) {
                let cmpLights = _lights.get(FudgeCore.LightDirectional);
                if (cmpLights) {
                    let n = cmpLights.length;
                    RenderOperator.crc3.uniform1ui(nDirectional, n);
                    for (let i = 0; i < n; i++) {
                        let cmpLight = cmpLights[i];
                        RenderOperator.crc3.uniform4fv(uni[`u_directional[${i}].color`], cmpLight.light.color.getArray());
                        let direction = FudgeCore.Vector3.Z();
                        direction.transform(cmpLight.pivot);
                        direction.transform(cmpLight.getContainer().mtxWorld);
                        RenderOperator.crc3.uniform3fv(uni[`u_directional[${i}].direction`], direction.get());
                    }
                }
            }
            // debugger;
        }
        /**
         * Draw a mesh buffer using the given infos and the complete projection matrix
         */
        static draw(_renderShader, _mesh, _coat, _world, _projection) {
            RenderOperator.useProgram(_renderShader);
            _mesh.useRenderBuffers(_renderShader, _world, _projection);
            _coat.useRenderData(_renderShader);
            RenderOperator.crc3.drawElements(WebGL2RenderingContext.TRIANGLES, _mesh.renderBuffers.nIndices, WebGL2RenderingContext.UNSIGNED_SHORT, 0);
        }
        // #region Shaderprogram 
        static createProgram(_shaderClass) {
            let crc3 = RenderOperator.crc3;
            let program = crc3.createProgram();
            let renderShader;
            try {
                crc3.attachShader(program, RenderOperator.assert(compileShader(_shaderClass.getVertexShaderSource(), WebGL2RenderingContext.VERTEX_SHADER)));
                crc3.attachShader(program, RenderOperator.assert(compileShader(_shaderClass.getFragmentShaderSource(), WebGL2RenderingContext.FRAGMENT_SHADER)));
                crc3.linkProgram(program);
                let error = RenderOperator.assert(crc3.getProgramInfoLog(program));
                if (error !== "") {
                    throw new Error("Error linking Shader: " + error);
                }
                renderShader = {
                    program: program,
                    attributes: detectAttributes(),
                    uniforms: detectUniforms()
                };
            }
            catch (_error) {
                FudgeCore.Debug.error(_error);
                debugger;
            }
            return renderShader;
            function compileShader(_shaderCode, _shaderType) {
                let webGLShader = crc3.createShader(_shaderType);
                crc3.shaderSource(webGLShader, _shaderCode);
                crc3.compileShader(webGLShader);
                let error = RenderOperator.assert(crc3.getShaderInfoLog(webGLShader));
                if (error !== "") {
                    throw new Error("Error compiling shader: " + error);
                }
                // Check for any compilation errors.
                if (!crc3.getShaderParameter(webGLShader, WebGL2RenderingContext.COMPILE_STATUS)) {
                    alert(crc3.getShaderInfoLog(webGLShader));
                    return null;
                }
                return webGLShader;
            }
            function detectAttributes() {
                let detectedAttributes = {};
                let attributeCount = crc3.getProgramParameter(program, WebGL2RenderingContext.ACTIVE_ATTRIBUTES);
                for (let i = 0; i < attributeCount; i++) {
                    let attributeInfo = RenderOperator.assert(crc3.getActiveAttrib(program, i));
                    if (!attributeInfo) {
                        break;
                    }
                    detectedAttributes[attributeInfo.name] = crc3.getAttribLocation(program, attributeInfo.name);
                }
                return detectedAttributes;
            }
            function detectUniforms() {
                let detectedUniforms = {};
                let uniformCount = crc3.getProgramParameter(program, WebGL2RenderingContext.ACTIVE_UNIFORMS);
                for (let i = 0; i < uniformCount; i++) {
                    let info = RenderOperator.assert(crc3.getActiveUniform(program, i));
                    if (!info) {
                        break;
                    }
                    detectedUniforms[info.name] = RenderOperator.assert(crc3.getUniformLocation(program, info.name));
                }
                return detectedUniforms;
            }
        }
        static useProgram(_shaderInfo) {
            RenderOperator.crc3.useProgram(_shaderInfo.program);
            RenderOperator.crc3.enableVertexAttribArray(_shaderInfo.attributes["a_position"]);
        }
        static deleteProgram(_program) {
            if (_program) {
                RenderOperator.crc3.deleteProgram(_program.program);
                delete _program.attributes;
                delete _program.uniforms;
            }
        }
        // #endregion
        // #region Meshbuffer
        static createBuffers(_mesh) {
            let vertices = RenderOperator.assert(RenderOperator.crc3.createBuffer());
            RenderOperator.crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, vertices);
            RenderOperator.crc3.bufferData(WebGL2RenderingContext.ARRAY_BUFFER, _mesh.vertices, WebGL2RenderingContext.STATIC_DRAW);
            let indices = RenderOperator.assert(RenderOperator.crc3.createBuffer());
            RenderOperator.crc3.bindBuffer(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, indices);
            RenderOperator.crc3.bufferData(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, _mesh.indices, WebGL2RenderingContext.STATIC_DRAW);
            let textureUVs = RenderOperator.crc3.createBuffer();
            RenderOperator.crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, textureUVs);
            RenderOperator.crc3.bufferData(WebGL2RenderingContext.ARRAY_BUFFER, _mesh.textureUVs, WebGL2RenderingContext.STATIC_DRAW);
            let normalsFace = RenderOperator.assert(RenderOperator.crc3.createBuffer());
            RenderOperator.crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, normalsFace);
            RenderOperator.crc3.bufferData(WebGL2RenderingContext.ARRAY_BUFFER, _mesh.normalsFace, WebGL2RenderingContext.STATIC_DRAW);
            let bufferInfo = {
                vertices: vertices,
                indices: indices,
                nIndices: _mesh.getIndexCount(),
                textureUVs: textureUVs,
                normalsFace: normalsFace
            };
            return bufferInfo;
        }
        static useBuffers(_renderBuffers) {
            // TODO: currently unused, done specifically in draw. Could be saved in VAO within RenderBuffers
            // RenderOperator.crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, _renderBuffers.vertices);
            // RenderOperator.crc3.bindBuffer(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, _renderBuffers.indices);
            // RenderOperator.crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, _renderBuffers.textureUVs);
        }
        static deleteBuffers(_renderBuffers) {
            if (_renderBuffers) {
                RenderOperator.crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, null);
                RenderOperator.crc3.deleteBuffer(_renderBuffers.vertices);
                RenderOperator.crc3.deleteBuffer(_renderBuffers.textureUVs);
                RenderOperator.crc3.bindBuffer(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, null);
                RenderOperator.crc3.deleteBuffer(_renderBuffers.indices);
            }
        }
        // #endregion
        // #region MaterialParameters
        static createParameter(_coat) {
            // let vao: WebGLVertexArrayObject = RenderOperator.assert<WebGLVertexArrayObject>(RenderOperator.crc3.createVertexArray());
            let coatInfo = {
                //vao: null,
                coat: _coat
            };
            return coatInfo;
        }
        static useParameter(_coatInfo) {
            // RenderOperator.crc3.bindVertexArray(_coatInfo.vao);
        }
        static deleteParameter(_coatInfo) {
            if (_coatInfo) {
                RenderOperator.crc3.bindVertexArray(null);
                // RenderOperator.crc3.deleteVertexArray(_coatInfo.vao);
            }
        }
    }
    FudgeCore.RenderOperator = RenderOperator;
})(FudgeCore || (FudgeCore = {}));
/// <reference path="Debug/DebugTarget.ts"/>
/// <reference path="Event/Event.ts"/>
/// <reference path="Transfer/Mutable.ts"/>  
/// <reference path="Transfer/Serializer.ts"/> 
/// <reference path="Render/RenderOperator.ts"/>
// / <reference path="../Transfer/Mutable.ts"/>
var FudgeCore;
// / <reference path="../Transfer/Mutable.ts"/>
(function (FudgeCore) {
    /**
     * Internally used to differentiate between the various generated structures and events.
     * @author Lukas Scheuerle, HFU, 2019
     */
    let ANIMATION_STRUCTURE_TYPE;
    (function (ANIMATION_STRUCTURE_TYPE) {
        /**Default: forward, continous */
        ANIMATION_STRUCTURE_TYPE[ANIMATION_STRUCTURE_TYPE["NORMAL"] = 0] = "NORMAL";
        /**backward, continous */
        ANIMATION_STRUCTURE_TYPE[ANIMATION_STRUCTURE_TYPE["REVERSE"] = 1] = "REVERSE";
        /**forward, rastered */
        ANIMATION_STRUCTURE_TYPE[ANIMATION_STRUCTURE_TYPE["RASTERED"] = 2] = "RASTERED";
        /**backward, rastered */
        ANIMATION_STRUCTURE_TYPE[ANIMATION_STRUCTURE_TYPE["RASTEREDREVERSE"] = 3] = "RASTEREDREVERSE";
    })(ANIMATION_STRUCTURE_TYPE || (ANIMATION_STRUCTURE_TYPE = {}));
    /**
     * Animation Class to hold all required Objects that are part of an Animation.
     * Also holds functions to play said Animation.
     * Can be added to a Node and played through [[ComponentAnimator]].
     * @author Lukas Scheuerle, HFU, 2019
     */
    class Animation extends FudgeCore.Mutable {
        constructor(_name, _animStructure = {}, _fps = 60) {
            super();
            this.totalTime = 0;
            this.labels = {};
            this.stepsPerSecond = 10;
            this.events = {};
            this.framesPerSecond = 60;
            // processed eventlist and animation strucutres for playback.
            this.eventsProcessed = new Map();
            this.animationStructuresProcessed = new Map();
            this.name = _name;
            this.animationStructure = _animStructure;
            this.animationStructuresProcessed.set(ANIMATION_STRUCTURE_TYPE.NORMAL, _animStructure);
            this.framesPerSecond = _fps;
            this.calculateTotalTime();
        }
        /**
         * Generates a new "Mutator" with the information to apply to the [[Node]] the [[ComponentAnimator]] is attached to with [[Node.applyAnimation()]].
         * @param _time The time at which the animation currently is at
         * @param _direction The direction in which the animation is supposed to be playing back. >0 == forward, 0 == stop, <0 == backwards
         * @param _playback The playbackmode the animation is supposed to be calculated with.
         * @returns a "Mutator" to apply.
         */
        getMutated(_time, _direction, _playback) {
            let m = {};
            if (_playback == FudgeCore.ANIMATION_PLAYBACK.TIMEBASED_CONTINOUS) {
                if (_direction >= 0) {
                    m = this.traverseStructureForMutator(this.getProcessedAnimationStructure(ANIMATION_STRUCTURE_TYPE.NORMAL), _time);
                }
                else {
                    m = this.traverseStructureForMutator(this.getProcessedAnimationStructure(ANIMATION_STRUCTURE_TYPE.REVERSE), _time);
                }
            }
            else {
                if (_direction >= 0) {
                    m = this.traverseStructureForMutator(this.getProcessedAnimationStructure(ANIMATION_STRUCTURE_TYPE.RASTERED), _time);
                }
                else {
                    m = this.traverseStructureForMutator(this.getProcessedAnimationStructure(ANIMATION_STRUCTURE_TYPE.RASTEREDREVERSE), _time);
                }
            }
            return m;
        }
        /**
         * Returns a list of the names of the events the [[ComponentAnimator]] needs to fire between _min and _max.
         * @param _min The minimum time (inclusive) to check between
         * @param _max The maximum time (exclusive) to check between
         * @param _playback The playback mode to check in. Has an effect on when the Events are fired.
         * @param _direction The direction the animation is supposed to run in. >0 == forward, 0 == stop, <0 == backwards
         * @returns a list of strings with the names of the custom events to fire.
         */
        getEventsToFire(_min, _max, _playback, _direction) {
            let eventList = [];
            let minSection = Math.floor(_min / this.totalTime);
            let maxSection = Math.floor(_max / this.totalTime);
            _min = _min % this.totalTime;
            _max = _max % this.totalTime;
            while (minSection <= maxSection) {
                let eventTriggers = this.getCorrectEventList(_direction, _playback);
                if (minSection == maxSection) {
                    eventList = eventList.concat(this.checkEventsBetween(eventTriggers, _min, _max));
                }
                else {
                    eventList = eventList.concat(this.checkEventsBetween(eventTriggers, _min, this.totalTime));
                    _min = 0;
                }
                minSection++;
            }
            return eventList;
        }
        /**
         * Adds an Event to the List of events.
         * @param _name The name of the event (needs to be unique per Animation).
         * @param _time The timestamp of the event (in milliseconds).
         */
        setEvent(_name, _time) {
            this.events[_name] = _time;
            this.eventsProcessed.clear();
        }
        /**
         * Removes the event with the given name from the list of events.
         * @param _name name of the event to remove.
         */
        removeEvent(_name) {
            delete this.events[_name];
            this.eventsProcessed.clear();
        }
        get getLabels() {
            //TODO: this actually needs testing
            let en = new Enumerator(this.labels);
            return en;
        }
        get fps() {
            return this.framesPerSecond;
        }
        set fps(_fps) {
            this.framesPerSecond = _fps;
            this.eventsProcessed.clear();
            this.animationStructuresProcessed.clear();
        }
        /**
         * (Re-)Calculate the total time of the Animation. Calculation-heavy, use only if actually needed.
         */
        calculateTotalTime() {
            this.totalTime = 0;
            this.traverseStructureForTime(this.animationStructure);
        }
        //#region transfer
        serialize() {
            let s = {
                idResource: this.idResource,
                name: this.name,
                labels: {},
                events: {},
                fps: this.framesPerSecond,
                sps: this.stepsPerSecond
            };
            for (let name in this.labels) {
                s.labels[name] = this.labels[name];
            }
            for (let name in this.events) {
                s.events[name] = this.events[name];
            }
            s.animationStructure = this.traverseStructureForSerialisation(this.animationStructure);
            return s;
        }
        deserialize(_serialization) {
            this.idResource = _serialization.idResource;
            this.name = _serialization.name;
            this.framesPerSecond = _serialization.fps;
            this.stepsPerSecond = _serialization.sps;
            this.labels = {};
            for (let name in _serialization.labels) {
                this.labels[name] = _serialization.labels[name];
            }
            this.events = {};
            for (let name in _serialization.events) {
                this.events[name] = _serialization.events[name];
            }
            this.eventsProcessed = new Map();
            this.animationStructure = this.traverseStructureForDeserialisation(_serialization.animationStructure);
            this.animationStructuresProcessed = new Map();
            this.calculateTotalTime();
            return this;
        }
        getMutator() {
            return this.serialize();
        }
        reduceMutator(_mutator) {
            delete _mutator.totalTime;
        }
        /**
         * Traverses an AnimationStructure and returns the Serialization of said Structure.
         * @param _structure The Animation Structure at the current level to transform into the Serialization.
         * @returns the filled Serialization.
         */
        traverseStructureForSerialisation(_structure) {
            let newSerialization = {};
            for (let n in _structure) {
                if (_structure[n] instanceof FudgeCore.AnimationSequence) {
                    newSerialization[n] = _structure[n].serialize();
                }
                else {
                    newSerialization[n] = this.traverseStructureForSerialisation(_structure[n]);
                }
            }
            return newSerialization;
        }
        /**
         * Traverses a Serialization to create a new AnimationStructure.
         * @param _serialization The serialization to transfer into an AnimationStructure
         * @returns the newly created AnimationStructure.
         */
        traverseStructureForDeserialisation(_serialization) {
            let newStructure = {};
            for (let n in _serialization) {
                if (_serialization[n].animationSequence) {
                    let animSeq = new FudgeCore.AnimationSequence();
                    newStructure[n] = animSeq.deserialize(_serialization[n]);
                }
                else {
                    newStructure[n] = this.traverseStructureForDeserialisation(_serialization[n]);
                }
            }
            return newStructure;
        }
        //#endregion
        /**
         * Finds the list of events to be used with these settings.
         * @param _direction The direction the animation is playing in.
         * @param _playback The playbackmode the animation is playing in.
         * @returns The correct AnimationEventTrigger Object to use
         */
        getCorrectEventList(_direction, _playback) {
            if (_playback != FudgeCore.ANIMATION_PLAYBACK.FRAMEBASED) {
                if (_direction >= 0) {
                    return this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.NORMAL);
                }
                else {
                    return this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.REVERSE);
                }
            }
            else {
                if (_direction >= 0) {
                    return this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.RASTERED);
                }
                else {
                    return this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.RASTEREDREVERSE);
                }
            }
        }
        /**
         * Traverses an AnimationStructure to turn it into the "Mutator" to return to the Component.
         * @param _structure The strcuture to traverse
         * @param _time the point in time to write the animation numbers into.
         * @returns The "Mutator" filled with the correct values at the given time.
         */
        traverseStructureForMutator(_structure, _time) {
            let newMutator = {};
            for (let n in _structure) {
                if (_structure[n] instanceof FudgeCore.AnimationSequence) {
                    newMutator[n] = _structure[n].evaluate(_time);
                }
                else {
                    newMutator[n] = this.traverseStructureForMutator(_structure[n], _time);
                }
            }
            return newMutator;
        }
        /**
         * Traverses the current AnimationStrcuture to find the totalTime of this animation.
         * @param _structure The structure to traverse
         */
        traverseStructureForTime(_structure) {
            for (let n in _structure) {
                if (_structure[n] instanceof FudgeCore.AnimationSequence) {
                    let sequence = _structure[n];
                    if (sequence.length > 0) {
                        let sequenceTime = sequence.getKey(sequence.length - 1).Time;
                        this.totalTime = sequenceTime > this.totalTime ? sequenceTime : this.totalTime;
                    }
                }
                else {
                    this.traverseStructureForTime(_structure[n]);
                }
            }
        }
        /**
         * Ensures the existance of the requested [[AnimationStrcuture]] and returns it.
         * @param _type the type of the structure to get
         * @returns the requested [[AnimationStructure]]
         */
        getProcessedAnimationStructure(_type) {
            if (!this.animationStructuresProcessed.has(_type)) {
                this.calculateTotalTime();
                let ae = {};
                switch (_type) {
                    case ANIMATION_STRUCTURE_TYPE.NORMAL:
                        ae = this.animationStructure;
                        break;
                    case ANIMATION_STRUCTURE_TYPE.REVERSE:
                        ae = this.traverseStructureForNewStructure(this.animationStructure, this.calculateReverseSequence.bind(this));
                        break;
                    case ANIMATION_STRUCTURE_TYPE.RASTERED:
                        ae = this.traverseStructureForNewStructure(this.animationStructure, this.calculateRasteredSequence.bind(this));
                        break;
                    case ANIMATION_STRUCTURE_TYPE.RASTEREDREVERSE:
                        ae = this.traverseStructureForNewStructure(this.getProcessedAnimationStructure(ANIMATION_STRUCTURE_TYPE.REVERSE), this.calculateRasteredSequence.bind(this));
                        break;
                    default:
                        return {};
                }
                this.animationStructuresProcessed.set(_type, ae);
            }
            return this.animationStructuresProcessed.get(_type);
        }
        /**
         * Ensures the existance of the requested [[AnimationEventTrigger]] and returns it.
         * @param _type The type of AnimationEventTrigger to get
         * @returns the requested [[AnimationEventTrigger]]
         */
        getProcessedEventTrigger(_type) {
            if (!this.eventsProcessed.has(_type)) {
                this.calculateTotalTime();
                let ev = {};
                switch (_type) {
                    case ANIMATION_STRUCTURE_TYPE.NORMAL:
                        ev = this.events;
                        break;
                    case ANIMATION_STRUCTURE_TYPE.REVERSE:
                        ev = this.calculateReverseEventTriggers(this.events);
                        break;
                    case ANIMATION_STRUCTURE_TYPE.RASTERED:
                        ev = this.calculateRasteredEventTriggers(this.events);
                        break;
                    case ANIMATION_STRUCTURE_TYPE.RASTEREDREVERSE:
                        ev = this.calculateRasteredEventTriggers(this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.REVERSE));
                        break;
                    default:
                        return {};
                }
                this.eventsProcessed.set(_type, ev);
            }
            return this.eventsProcessed.get(_type);
        }
        /**
         * Traverses an existing structure to apply a recalculation function to the AnimationStructure to store in a new Structure.
         * @param _oldStructure The old structure to traverse
         * @param _functionToUse The function to use to recalculated the structure.
         * @returns A new Animation Structure with the recalulated Animation Sequences.
         */
        traverseStructureForNewStructure(_oldStructure, _functionToUse) {
            let newStructure = {};
            for (let n in _oldStructure) {
                if (_oldStructure[n] instanceof FudgeCore.AnimationSequence) {
                    newStructure[n] = _functionToUse(_oldStructure[n]);
                }
                else {
                    newStructure[n] = this.traverseStructureForNewStructure(_oldStructure[n], _functionToUse);
                }
            }
            return newStructure;
        }
        /**
         * Creates a reversed Animation Sequence out of a given Sequence.
         * @param _sequence The sequence to calculate the new sequence out of
         * @returns The reversed Sequence
         */
        calculateReverseSequence(_sequence) {
            let seq = new FudgeCore.AnimationSequence();
            for (let i = 0; i < _sequence.length; i++) {
                let oldKey = _sequence.getKey(i);
                let key = new FudgeCore.AnimationKey(this.totalTime - oldKey.Time, oldKey.Value, oldKey.SlopeOut, oldKey.SlopeIn, oldKey.Constant);
                seq.addKey(key);
            }
            return seq;
        }
        /**
         * Creates a rastered [[AnimationSequence]] out of a given sequence.
         * @param _sequence The sequence to calculate the new sequence out of
         * @returns the rastered sequence.
         */
        calculateRasteredSequence(_sequence) {
            let seq = new FudgeCore.AnimationSequence();
            let frameTime = 1000 / this.framesPerSecond;
            for (let i = 0; i < this.totalTime; i += frameTime) {
                let key = new FudgeCore.AnimationKey(i, _sequence.evaluate(i), 0, 0, true);
                seq.addKey(key);
            }
            return seq;
        }
        /**
         * Creates a new reversed [[AnimationEventTrigger]] object based on the given one.
         * @param _events the event object to calculate the new one out of
         * @returns the reversed event object
         */
        calculateReverseEventTriggers(_events) {
            let ae = {};
            for (let name in _events) {
                ae[name] = this.totalTime - _events[name];
            }
            return ae;
        }
        /**
         * Creates a rastered [[AnimationEventTrigger]] object based on the given one.
         * @param _events the event object to calculate the new one out of
         * @returns the rastered event object
         */
        calculateRasteredEventTriggers(_events) {
            let ae = {};
            let frameTime = 1000 / this.framesPerSecond;
            for (let name in _events) {
                ae[name] = _events[name] - (_events[name] % frameTime);
            }
            return ae;
        }
        /**
         * Checks which events lay between two given times and returns the names of the ones that do.
         * @param _eventTriggers The event object to check the events inside of
         * @param _min the minimum of the range to check between (inclusive)
         * @param _max the maximum of the range to check between (exclusive)
         * @returns an array of the names of the events in the given range.
         */
        checkEventsBetween(_eventTriggers, _min, _max) {
            let eventsToTrigger = [];
            for (let name in _eventTriggers) {
                if (_min <= _eventTriggers[name] && _eventTriggers[name] < _max) {
                    eventsToTrigger.push(name);
                }
            }
            return eventsToTrigger;
        }
    }
    FudgeCore.Animation = Animation;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="../Transfer/Serializer.ts"/>
// / <reference path="../Transfer/Mutable.ts"/>
var FudgeCore;
// / <reference path="../Transfer/Serializer.ts"/>
// / <reference path="../Transfer/Mutable.ts"/>
(function (FudgeCore) {
    /**
     * Calculates the values between [[AnimationKey]]s.
     * Represented internally by a cubic function (`f(x) = ax³ + bx² + cx + d`).
     * Only needs to be recalculated when the keys change, so at runtime it should only be calculated once.
     * @author Lukas Scheuerle, HFU, 2019
     */
    class AnimationFunction {
        constructor(_keyIn, _keyOut = null) {
            this.a = 0;
            this.b = 0;
            this.c = 0;
            this.d = 0;
            this.keyIn = _keyIn;
            this.keyOut = _keyOut;
            this.calculate();
        }
        /**
         * Calculates the value of the function at the given time.
         * @param _time the point in time at which to evaluate the function in milliseconds. Will be corrected for offset internally.
         * @returns the value at the given time
         */
        evaluate(_time) {
            _time -= this.keyIn.Time;
            let time2 = _time * _time;
            let time3 = time2 * _time;
            return this.a * time3 + this.b * time2 + this.c * _time + this.d;
        }
        set setKeyIn(_keyIn) {
            this.keyIn = _keyIn;
            this.calculate();
        }
        set setKeyOut(_keyOut) {
            this.keyOut = _keyOut;
            this.calculate();
        }
        /**
         * (Re-)Calculates the parameters of the cubic function.
         * See https://math.stackexchange.com/questions/3173469/calculate-cubic-equation-from-two-points-and-two-slopes-variably
         * and https://jirkadelloro.github.io/FUDGE/Documentation/Logs/190410_Notizen_LS
         */
        calculate() {
            if (!this.keyIn) {
                this.d = this.c = this.b = this.a = 0;
                return;
            }
            if (!this.keyOut || this.keyIn.Constant) {
                this.d = this.keyIn.Value;
                this.c = this.b = this.a = 0;
                return;
            }
            let x1 = this.keyOut.Time - this.keyIn.Time;
            this.d = this.keyIn.Value;
            this.c = this.keyIn.SlopeOut;
            this.a = (-x1 * (this.keyIn.SlopeOut + this.keyOut.SlopeIn) - 2 * this.keyIn.Value + 2 * this.keyOut.Value) / -Math.pow(x1, 3);
            this.b = (this.keyOut.SlopeIn - this.keyIn.SlopeOut - 3 * this.a * Math.pow(x1, 2)) / (2 * x1);
        }
    }
    FudgeCore.AnimationFunction = AnimationFunction;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="../Transfer/Serializer.ts"/>
// / <reference path="../Transfer/Mutable.ts"/>
var FudgeCore;
// / <reference path="../Transfer/Serializer.ts"/>
// / <reference path="../Transfer/Mutable.ts"/>
(function (FudgeCore) {
    /**
     * Holds information about set points in time, their accompanying values as well as their slopes.
     * Also holds a reference to the [[AnimationFunction]]s that come in and out of the sides. The [[AnimationFunction]]s are handled by the [[AnimationSequence]]s.
     * Saved inside an [[AnimationSequence]].
     * @author Lukas Scheuerle, HFU, 2019
     */
    class AnimationKey extends FudgeCore.Mutable {
        constructor(_time = 0, _value = 0, _slopeIn = 0, _slopeOut = 0, _constant = false) {
            super();
            this.constant = false;
            this.slopeIn = 0;
            this.slopeOut = 0;
            this.time = _time;
            this.value = _value;
            this.slopeIn = _slopeIn;
            this.slopeOut = _slopeOut;
            this.constant = _constant;
            this.broken = this.slopeIn != -this.slopeOut;
            this.functionOut = new FudgeCore.AnimationFunction(this, null);
        }
        get Time() {
            return this.time;
        }
        set Time(_time) {
            this.time = _time;
            this.functionIn.calculate();
            this.functionOut.calculate();
        }
        get Value() {
            return this.value;
        }
        set Value(_value) {
            this.value = _value;
            this.functionIn.calculate();
            this.functionOut.calculate();
        }
        get Constant() {
            return this.constant;
        }
        set Constant(_constant) {
            this.constant = _constant;
            this.functionIn.calculate();
            this.functionOut.calculate();
        }
        get SlopeIn() {
            return this.slopeIn;
        }
        set SlopeIn(_slope) {
            this.slopeIn = _slope;
            this.functionIn.calculate();
        }
        get SlopeOut() {
            return this.slopeOut;
        }
        set SlopeOut(_slope) {
            this.slopeOut = _slope;
            this.functionOut.calculate();
        }
        /**
         * Static comparation function to use in an array sort function to sort the keys by their time.
         * @param _a the animation key to check
         * @param _b the animation key to check against
         * @returns >0 if a>b, 0 if a=b, <0 if a<b
         */
        static compare(_a, _b) {
            return _a.time - _b.time;
        }
        //#region transfer
        serialize() {
            let s = {};
            s.time = this.time;
            s.value = this.value;
            s.slopeIn = this.slopeIn;
            s.slopeOut = this.slopeOut;
            s.constant = this.constant;
            return s;
        }
        deserialize(_serialization) {
            this.time = _serialization.time;
            this.value = _serialization.value;
            this.slopeIn = _serialization.slopeIn;
            this.slopeOut = _serialization.slopeOut;
            this.constant = _serialization.constant;
            this.broken = this.slopeIn != -this.slopeOut;
            return this;
        }
        getMutator() {
            return this.serialize();
        }
        reduceMutator(_mutator) {
            //
        }
    }
    FudgeCore.AnimationKey = AnimationKey;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A sequence of [[AnimationKey]]s that is mapped to an attribute of a [[Node]] or its [[Component]]s inside the [[Animation]].
     * Provides functions to modify said keys
     * @author Lukas Scheuerle, HFU, 2019
     */
    class AnimationSequence extends FudgeCore.Mutable {
        constructor() {
            super(...arguments);
            this.keys = [];
        }
        /**
         * Evaluates the sequence at the given point in time.
         * @param _time the point in time at which to evaluate the sequence in milliseconds.
         * @returns the value of the sequence at the given time. 0 if there are no keys.
         */
        evaluate(_time) {
            if (this.keys.length == 0)
                return 0; //TODO: shouldn't return 0 but something indicating no change, like null. probably needs to be changed in Node as well to ignore non-numeric values in the applyAnimation function
            if (this.keys.length == 1 || this.keys[0].Time >= _time)
                return this.keys[0].Value;
            for (let i = 0; i < this.keys.length - 1; i++) {
                if (this.keys[i].Time <= _time && this.keys[i + 1].Time > _time) {
                    return this.keys[i].functionOut.evaluate(_time);
                }
            }
            return this.keys[this.keys.length - 1].Value;
        }
        /**
         * Adds a new key to the sequence.
         * @param _key the key to add
         */
        addKey(_key) {
            this.keys.push(_key);
            this.keys.sort(FudgeCore.AnimationKey.compare);
            this.regenerateFunctions();
        }
        /**
         * Removes a given key from the sequence.
         * @param _key the key to remove
         */
        removeKey(_key) {
            for (let i = 0; i < this.keys.length; i++) {
                if (this.keys[i] == _key) {
                    this.keys.splice(i, 1);
                    this.regenerateFunctions();
                    return;
                }
            }
        }
        /**
         * Removes the Animation Key at the given index from the keys.
         * @param _index the zero-based index at which to remove the key
         * @returns the removed AnimationKey if successful, null otherwise.
         */
        removeKeyAtIndex(_index) {
            if (_index < 0 || _index >= this.keys.length) {
                return null;
            }
            let ak = this.keys[_index];
            this.keys.splice(_index, 1);
            this.regenerateFunctions();
            return ak;
        }
        /**
         * Gets a key from the sequence at the desired index.
         * @param _index the zero-based index at which to get the key
         * @returns the AnimationKey at the index if it exists, null otherwise.
         */
        getKey(_index) {
            if (_index < 0 || _index >= this.keys.length)
                return null;
            return this.keys[_index];
        }
        get length() {
            return this.keys.length;
        }
        //#region transfer
        serialize() {
            let s = {
                keys: [],
                animationSequence: true
            };
            for (let i = 0; i < this.keys.length; i++) {
                s.keys[i] = this.keys[i].serialize();
            }
            return s;
        }
        deserialize(_serialization) {
            for (let i = 0; i < _serialization.keys.length; i++) {
                // this.keys.push(<AnimationKey>Serializer.deserialize(_serialization.keys[i]));
                let k = new FudgeCore.AnimationKey();
                k.deserialize(_serialization.keys[i]);
                this.keys[i] = k;
            }
            this.regenerateFunctions();
            return this;
        }
        reduceMutator(_mutator) {
            //
        }
        //#endregion
        /**
         * Utility function that (re-)generates all functions in the sequence.
         */
        regenerateFunctions() {
            for (let i = 0; i < this.keys.length; i++) {
                let f = new FudgeCore.AnimationFunction(this.keys[i]);
                this.keys[i].functionOut = f;
                if (i == this.keys.length - 1) {
                    //TODO: check if this is even useful. Maybe update the runcondition to length - 1 instead. Might be redundant if functionIn is removed, see TODO in AnimationKey.
                    f.setKeyOut = this.keys[0];
                    this.keys[0].functionIn = f;
                    break;
                }
                f.setKeyOut = this.keys[i + 1];
                this.keys[i + 1].functionIn = f;
            }
        }
    }
    FudgeCore.AnimationSequence = AnimationSequence;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Extension of AudioBuffer with a load method that creates a buffer in the [[AudioManager]].default to be used with [[ComponentAudio]]
     * @authors Thomas Dorner, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2020
     */
    class Audio extends AudioBuffer {
        /**
         * Asynchronously loads the audio (mp3) from the given url
         */
        static async load(_url) {
            const response = await window.fetch(_url);
            const arrayBuffer = await response.arrayBuffer();
            return (await FudgeCore.AudioManager.default.decodeAudioData(arrayBuffer));
        }
    }
    FudgeCore.Audio = Audio;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Extends the standard AudioContext for integration with [[Node]]-branches.
     * Creates a default object at startup to be addressed as AudioManager default.
     * Other objects of this class may be create for special purposes.
     */
    class AudioManager extends AudioContext {
        constructor(contextOptions) {
            super(contextOptions);
            this.branch = null;
            this.cmpListener = null;
            /**
             * Determines branch to listen to. Each [[ComponentAudio]] in the branch will connect to this contexts master gain, all others disconnect.
             */
            this.listenTo = (_branch) => {
                if (this.branch)
                    this.branch.broadcastEvent(new Event("childRemoveFromAudioBranch" /* CHILD_REMOVE */));
                if (!_branch)
                    return;
                this.branch = _branch;
                this.branch.broadcastEvent(new Event("childAppendToAudioBranch" /* CHILD_APPEND */));
            };
            /**
             * Retrieve the branch currently listening to
             */
            this.getBranchListeningTo = () => {
                return this.branch;
            };
            /**
             * Set the [[ComponentAudioListener]] that serves the spatial location and orientation for this contexts listener
             */
            this.listen = (_cmpListener) => {
                this.cmpListener = _cmpListener;
            };
            /**
             * Updates the spatial settings of the AudioNodes effected in the current branch
             */
            this.update = () => {
                this.branch.broadcastEvent(new Event("updateAudioBranch" /* UPDATE */));
                if (this.cmpListener)
                    this.cmpListener.update(this.listener);
            };
            this.gain = this.createGain();
            this.gain.connect(this.destination);
        }
        /**
         * Set the master volume
         */
        set volume(_value) {
            this.gain.gain.value = _value;
        }
        /**
         * Get the master volume
         */
        get volume() {
            return this.gain.gain.value;
        }
    }
    /** The default context that may be used throughout the project without the need to create others */
    AudioManager.default = new AudioManager({ latencyHint: "interactive", sampleRate: 44100 });
    FudgeCore.AudioManager = AudioManager;
})(FudgeCore || (FudgeCore = {}));
// namespace FudgeCore {
//     /**
//      * Enumerator for all possible Oscillator Types
//      */
//     type OSCILLATOR_TYPE = "sine" | "square" | "sawtooth" | "triangle" | "custom";
//     /**
//      * Interface to create Custom Oscillator Types.
//      * Start-/Endpoint of a custum curve e.g. sine curve.
//      * Both parameters need to be inbetween -1 and 1.
//      * @param startpoint startpoint of a curve 
//      * @param endpoint Endpoint of a curve 
//      */
//     interface OscillatorWave {
//         startpoint: number;
//         endpoint: number;
//     }
//     /**
//      * Add an [[AudioFilter]] to an [[Audio]]
//      * @authors Thomas Dorner, HFU, 2019
//      */
//     export class AudioOscillator {
//         public audioOscillator: OscillatorNode; 
//         private frequency: number;
//         private oscillatorType: OSCILLATOR_TYPE;
//         private oscillatorWave: PeriodicWave;
//         private localGain: GainNode;
//         private localGainValue: number;
//         constructor(_audioSettings: AudioSettings, _oscillatorType?: OSCILLATOR_TYPE) {
//             this.audioOscillator = _audioSettings.getAudioContext().createOscillator();
//             this.localGain = _audioSettings.getAudioContext().createGain();
//             this.oscillatorType = _oscillatorType;
//             if (this.oscillatorType != "custom") {
//                 this.audioOscillator.type = this.oscillatorType;
//             }
//             else {
//                 if (!this.oscillatorWave) {
//                     this.audioOscillator.setPeriodicWave(this.oscillatorWave);
//                 }
//                 else {
//                     console.log("Create a Custom Periodic Wave first to use Custom Type");
//                 }
//             }
//         }
//         public setOscillatorType(_oscillatorType: OSCILLATOR_TYPE): void {
//             if (this.oscillatorType != "custom") {
//                 this.audioOscillator.type = this.oscillatorType;
//             }
//             else {
//                 if (!this.oscillatorWave) {
//                     this.audioOscillator.setPeriodicWave(this.oscillatorWave);
//                 }
//             }
//         }
//         public getOscillatorType(): OSCILLATOR_TYPE {
//             return this.oscillatorType;
//         }
//         public createPeriodicWave(_audioSettings: AudioSettings, _real: OscillatorWave, _imag: OscillatorWave): void {
//             let waveReal: Float32Array = new Float32Array(2);
//             waveReal[0] = _real.startpoint;
//             waveReal[1] = _real.endpoint;
//             let waveImag: Float32Array = new Float32Array(2);
//             waveImag[0] = _imag.startpoint;
//             waveImag[1] = _imag.endpoint;
//             this.oscillatorWave = _audioSettings.getAudioContext().createPeriodicWave(waveReal, waveImag);
//         }
//         public setLocalGain(_localGain: GainNode): void {
//             this.localGain = _localGain;
//         }
//         public getLocalGain(): GainNode {
//             return this.localGain;
//         }
//         public setLocalGainValue(_localGainValue: number): void {
//             this.localGainValue = _localGainValue;
//             this.localGain.gain.value = this.localGainValue;
//         }
//         public getLocalGainValue(): number {
//             return this.localGainValue;
//         }
//         public setFrequency(_audioSettings: AudioSettings, _frequency: number): void {
//             this.frequency = _frequency;
//             this.audioOscillator.frequency.setValueAtTime(this.frequency, _audioSettings.getAudioContext().currentTime);
//         }
//         public getFrequency(): number {
//             return this.frequency;
//         }
//         public createSnare(_audioSettings: AudioSettings): void {
//             this.setOscillatorType("triangle");
//             this.setFrequency(_audioSettings, 100);
//             this.setLocalGainValue(0);
//             this.localGain.gain.setValueAtTime(0, _audioSettings.getAudioContext().currentTime);
//             this.localGain.gain.exponentialRampToValueAtTime(0.01, _audioSettings.getAudioContext().currentTime + .1);
//             this.audioOscillator.connect(this.localGain);
//         }
//     }
// }
var FudgeCore;
(function (FudgeCore) {
    /**
     * Holds data to feed into a [[Shader]] to describe the surface of [[Mesh]].
     * [[Material]]s reference [[Coat]] and [[Shader]].
     * The method useRenderData will be injected by [[RenderInjector]] at runtime, extending the functionality of this class to deal with the renderer.
     */
    class Coat extends FudgeCore.Mutable {
        constructor() {
            super(...arguments);
            this.name = "Coat";
            //#endregion
        }
        mutate(_mutator) {
            super.mutate(_mutator);
        }
        useRenderData(_renderShader) { }
        //#region Transfer
        serialize() {
            let serialization = this.getMutator();
            return serialization;
        }
        deserialize(_serialization) {
            this.mutate(_serialization);
            return this;
        }
        reduceMutator() { }
    }
    FudgeCore.Coat = Coat;
    /**
     * The simplest [[Coat]] providing just a color
     */
    let CoatColored = class CoatColored extends Coat {
        constructor(_color) {
            super();
            this.color = _color || new FudgeCore.Color(0.5, 0.5, 0.5, 1);
        }
    };
    CoatColored = __decorate([
        FudgeCore.RenderInjectorCoat.decorate
    ], CoatColored);
    FudgeCore.CoatColored = CoatColored;
    /**
     * A [[Coat]] to be used by the MatCap Shader providing a texture, a tint color (0.5 grey is neutral)
     * and a flatMix number for mixing between smooth and flat shading.
     */
    let CoatMatCap = class CoatMatCap extends Coat {
        constructor(_texture, _tintcolor, _flatmix) {
            super();
            this.texture = null;
            this.tintColor = new FudgeCore.Color(0.5, 0.5, 0.5, 1);
            this.flatMix = 0.5;
            this.texture = _texture || new FudgeCore.TextureImage();
            this.tintColor = _tintcolor || new FudgeCore.Color(0.5, 0.5, 0.5, 1);
            this.flatMix = _flatmix > 1.0 ? this.flatMix = 1.0 : this.flatMix = _flatmix || 0.5;
        }
    };
    CoatMatCap = __decorate([
        FudgeCore.RenderInjectorCoat.decorate
    ], CoatMatCap);
    FudgeCore.CoatMatCap = CoatMatCap;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A [[Coat]] providing a texture and additional data for texturing
     */
    let CoatTextured = class CoatTextured extends FudgeCore.Coat {
        constructor() {
            super(...arguments);
            this.texture = null;
            this.pivot = FudgeCore.Matrix3x3.IDENTITY();
            // public getMutatorForComponent(): MutatorForComponent {
            //   let mutatorPivot: MutatorForComponent = <MutatorForComponent><unknown>this.pivot.getMutator();
            //   return mutatorPivot;
            // }
            // public mutate(_mutator: MutatorForComponent): void {
            //   this.pivot.mutate(_mutator);
            // }
        }
    };
    CoatTextured = __decorate([
        FudgeCore.RenderInjectorCoat.decorate
    ], CoatTextured);
    FudgeCore.CoatTextured = CoatTextured;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="../Transfer/Serializer.ts"/>
// / <reference path="../Transfer/Mutable.ts"/>
var FudgeCore;
// / <reference path="../Transfer/Serializer.ts"/>
// / <reference path="../Transfer/Mutable.ts"/>
(function (FudgeCore) {
    /**
     * Superclass for all [[Component]]s that can be attached to [[Node]]s.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2020 | Jascha Karagöl, HFU, 2019
     */
    class Component extends FudgeCore.Mutable {
        constructor() {
            super(...arguments);
            this.singleton = true;
            this.container = null;
            this.active = true;
            //#endregion
        }
        static registerSubclass(_subclass) { return Component.subclasses.push(_subclass) - 1; }
        activate(_on) {
            this.active = _on;
            this.dispatchEvent(new Event(_on ? "componentActivate" /* COMPONENT_ACTIVATE */ : "componentDeactivate" /* COMPONENT_DEACTIVATE */));
        }
        get isActive() {
            return this.active;
        }
        /**
         * Is true, when only one instance of the component class can be attached to a node
         */
        get isSingleton() {
            return this.singleton;
        }
        /**
         * Retrieves the node, this component is currently attached to
         * @returns The container node or null, if the component is not attached to
         */
        getContainer() {
            return this.container;
        }
        /**
         * Tries to add the component to the given node, removing it from the previous container if applicable
         * @param _container The node to attach this component to
         */
        setContainer(_container) {
            if (this.container == _container)
                return;
            let previousContainer = this.container;
            try {
                if (previousContainer)
                    previousContainer.removeComponent(this);
                this.container = _container;
                if (this.container)
                    this.container.addComponent(this);
            }
            catch (_error) {
                this.container = previousContainer;
            }
        }
        //#region Transfer
        serialize() {
            let serialization = {
                active: this.active
            };
            return serialization;
        }
        deserialize(_serialization) {
            this.active = _serialization.active;
            return this;
        }
        reduceMutator(_mutator) {
            delete _mutator.singleton;
            delete _mutator.container;
        }
    }
    Component.subclasses = [];
    FudgeCore.Component = Component;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="../Time/Loop.ts"/>
// / <reference path="../Animation/Animation.ts"/>
var FudgeCore;
// / <reference path="../Time/Loop.ts"/>
// / <reference path="../Animation/Animation.ts"/>
(function (FudgeCore) {
    /**
     * Holds different playmodes the animation uses to play back its animation.
     * @author Lukas Scheuerle, HFU, 2019
     */
    let ANIMATION_PLAYMODE;
    (function (ANIMATION_PLAYMODE) {
        /**Plays animation in a loop: it restarts once it hit the end.*/
        ANIMATION_PLAYMODE[ANIMATION_PLAYMODE["LOOP"] = 0] = "LOOP";
        /**Plays animation once and stops at the last key/frame*/
        ANIMATION_PLAYMODE[ANIMATION_PLAYMODE["PLAYONCE"] = 1] = "PLAYONCE";
        /**Plays animation once and stops on the first key/frame */
        ANIMATION_PLAYMODE[ANIMATION_PLAYMODE["PLAYONCESTOPAFTER"] = 2] = "PLAYONCESTOPAFTER";
        /**Plays animation like LOOP, but backwards.*/
        ANIMATION_PLAYMODE[ANIMATION_PLAYMODE["REVERSELOOP"] = 3] = "REVERSELOOP";
        /**Causes the animation not to play at all. Useful for jumping to various positions in the animation without proceeding in the animation.*/
        ANIMATION_PLAYMODE[ANIMATION_PLAYMODE["STOP"] = 4] = "STOP";
        //TODO: add an INHERIT and a PINGPONG mode
    })(ANIMATION_PLAYMODE = FudgeCore.ANIMATION_PLAYMODE || (FudgeCore.ANIMATION_PLAYMODE = {}));
    let ANIMATION_PLAYBACK;
    (function (ANIMATION_PLAYBACK) {
        //TODO: add an in-depth description of what happens to the animation (and events) depending on the Playback. Use Graphs to explain.
        /**Calculates the state of the animation at the exact position of time. Ignores FPS value of animation.*/
        ANIMATION_PLAYBACK[ANIMATION_PLAYBACK["TIMEBASED_CONTINOUS"] = 0] = "TIMEBASED_CONTINOUS";
        /**Limits the calculation of the state of the animation to the FPS value of the animation. Skips frames if needed.*/
        ANIMATION_PLAYBACK[ANIMATION_PLAYBACK["TIMEBASED_RASTERED_TO_FPS"] = 1] = "TIMEBASED_RASTERED_TO_FPS";
        /**Uses the FPS value of the animation to advance once per frame, no matter the speed of the frames. Doesn't skip any frames.*/
        ANIMATION_PLAYBACK[ANIMATION_PLAYBACK["FRAMEBASED"] = 2] = "FRAMEBASED";
    })(ANIMATION_PLAYBACK = FudgeCore.ANIMATION_PLAYBACK || (FudgeCore.ANIMATION_PLAYBACK = {}));
    /**
     * Holds a reference to an [[Animation]] and controls it. Controls playback and playmode as well as speed.
     * @authors Lukas Scheuerle, HFU, 2019
     */
    class ComponentAnimator extends FudgeCore.Component {
        constructor(_animation = new FudgeCore.Animation(""), _playmode = ANIMATION_PLAYMODE.LOOP, _playback = ANIMATION_PLAYBACK.TIMEBASED_CONTINOUS) {
            super();
            this.speedScalesWithGlobalSpeed = true;
            this.speedScale = 1;
            this.lastTime = 0;
            this.animation = _animation;
            this.playmode = _playmode;
            this.playback = _playback;
            this.localTime = new FudgeCore.Time();
            //TODO: update animation total time when loading a different animation?
            this.animation.calculateTotalTime();
            FudgeCore.Loop.addEventListener("loopFrame" /* LOOP_FRAME */, this.updateAnimationLoop.bind(this));
            FudgeCore.Time.game.addEventListener("timeScaled" /* TIME_SCALED */, this.updateScale.bind(this));
        }
        set speed(_s) {
            this.speedScale = _s;
            this.updateScale();
        }
        /**
         * Jumps to a certain time in the animation to play from there.
         * @param _time The time to jump to
         */
        jumpTo(_time) {
            this.localTime.set(_time);
            this.lastTime = _time;
            _time = _time % this.animation.totalTime;
            let mutator = this.animation.getMutated(_time, this.calculateDirection(_time), this.playback);
            this.getContainer().applyAnimation(mutator);
        }
        /**
         * Returns the current time of the animation, modulated for animation length.
         */
        getCurrentTime() {
            return this.localTime.get() % this.animation.totalTime;
        }
        /**
         * Forces an update of the animation from outside. Used in the ViewAnimation. Shouldn't be used during the game.
         * @param _time the (unscaled) time to update the animation with.
         * @returns a Tupel containing the Mutator for Animation and the playmode corrected time.
         */
        updateAnimation(_time) {
            return this.updateAnimationLoop(null, _time);
        }
        //#region transfer
        serialize() {
            let s = super.serialize();
            s["animation"] = this.animation.serialize();
            s["playmode"] = this.playmode;
            s["playback"] = this.playback;
            s["speedScale"] = this.speedScale;
            s["speedScalesWithGlobalSpeed"] = this.speedScalesWithGlobalSpeed;
            s[super.constructor.name] = super.serialize();
            return s;
        }
        deserialize(_s) {
            this.animation = new FudgeCore.Animation("");
            this.animation.deserialize(_s.animation);
            this.playback = _s.playback;
            this.playmode = _s.playmode;
            this.speedScale = _s.speedScale;
            this.speedScalesWithGlobalSpeed = _s.speedScalesWithGlobalSpeed;
            super.deserialize(_s[super.constructor.name]);
            return this;
        }
        //#endregion
        //#region updateAnimation
        /**
         * Updates the Animation.
         * Gets called every time the Loop fires the LOOP_FRAME Event.
         * Uses the built-in time unless a different time is specified.
         * May also be called from updateAnimation().
         */
        updateAnimationLoop(_e, _time) {
            if (this.animation.totalTime == 0)
                return [null, 0];
            let time = _time || this.localTime.get();
            if (this.playback == ANIMATION_PLAYBACK.FRAMEBASED) {
                time = this.lastTime + (1000 / this.animation.fps);
            }
            let direction = this.calculateDirection(time);
            time = this.applyPlaymodes(time);
            this.executeEvents(this.animation.getEventsToFire(this.lastTime, time, this.playback, direction));
            if (this.lastTime != time) {
                this.lastTime = time;
                time = time % this.animation.totalTime;
                let mutator = this.animation.getMutated(time, direction, this.playback);
                if (this.getContainer()) {
                    this.getContainer().applyAnimation(mutator);
                }
                return [mutator, time];
            }
            return [null, time];
        }
        /**
         * Fires all custom events the Animation should have fired between the last frame and the current frame.
         * @param events a list of names of custom events to fire
         */
        executeEvents(events) {
            for (let i = 0; i < events.length; i++) {
                this.dispatchEvent(new Event(events[i]));
            }
        }
        /**
         * Calculates the actual time to use, using the current playmodes.
         * @param _time the time to apply the playmodes to
         * @returns the recalculated time
         */
        applyPlaymodes(_time) {
            switch (this.playmode) {
                case ANIMATION_PLAYMODE.STOP:
                    return this.localTime.getOffset();
                case ANIMATION_PLAYMODE.PLAYONCE:
                    if (_time >= this.animation.totalTime)
                        return this.animation.totalTime - 0.01; //TODO: this might cause some issues
                    else
                        return _time;
                case ANIMATION_PLAYMODE.PLAYONCESTOPAFTER:
                    if (_time >= this.animation.totalTime)
                        return this.animation.totalTime + 0.01; //TODO: this might cause some issues
                    else
                        return _time;
                default:
                    return _time;
            }
        }
        /**
         * Calculates and returns the direction the animation should currently be playing in.
         * @param _time the time at which to calculate the direction
         * @returns 1 if forward, 0 if stop, -1 if backwards
         */
        calculateDirection(_time) {
            switch (this.playmode) {
                case ANIMATION_PLAYMODE.STOP:
                    return 0;
                // case ANIMATION_PLAYMODE.PINGPONG:
                //   if (Math.floor(_time / this.animation.totalTime) % 2 == 0)
                //     return 1;
                //   else
                //     return -1;
                case ANIMATION_PLAYMODE.REVERSELOOP:
                    return -1;
                case ANIMATION_PLAYMODE.PLAYONCE:
                case ANIMATION_PLAYMODE.PLAYONCESTOPAFTER:
                    if (_time >= this.animation.totalTime) {
                        return 0;
                    }
                default:
                    return 1;
            }
        }
        /**
         * Updates the scale of the animation if the user changes it or if the global game timer changed its scale.
         */
        updateScale() {
            let newScale = this.speedScale;
            if (this.speedScalesWithGlobalSpeed)
                newScale *= FudgeCore.Time.game.getScale();
            this.localTime.setScale(newScale);
        }
    }
    ComponentAnimator.iSubclass = FudgeCore.Component.registerSubclass(ComponentAnimator);
    FudgeCore.ComponentAnimator = ComponentAnimator;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let AUDIO_PANNER;
    (function (AUDIO_PANNER) {
        AUDIO_PANNER["CONE_INNER_ANGLE"] = "coneInnerAngle";
        AUDIO_PANNER["CONE_OUTER_ANGLE"] = "coneOuterAngle";
        AUDIO_PANNER["CONE_OUTER_GAIN"] = "coneOuterGain";
        AUDIO_PANNER["DISTANCE_MODEL"] = "distanceModel";
        AUDIO_PANNER["MAX_DISTANCE"] = "maxDistance";
        AUDIO_PANNER["PANNING_MODEL"] = "panningModel";
        AUDIO_PANNER["REF_DISTANCE"] = "refDistance";
        AUDIO_PANNER["ROLLOFF_FACTOR"] = "rolloffFactor";
    })(AUDIO_PANNER = FudgeCore.AUDIO_PANNER || (FudgeCore.AUDIO_PANNER = {}));
    let AUDIO_NODE_TYPE;
    (function (AUDIO_NODE_TYPE) {
        AUDIO_NODE_TYPE[AUDIO_NODE_TYPE["SOURCE"] = 0] = "SOURCE";
        AUDIO_NODE_TYPE[AUDIO_NODE_TYPE["PANNER"] = 1] = "PANNER";
        AUDIO_NODE_TYPE[AUDIO_NODE_TYPE["GAIN"] = 2] = "GAIN";
    })(AUDIO_NODE_TYPE = FudgeCore.AUDIO_NODE_TYPE || (FudgeCore.AUDIO_NODE_TYPE = {}));
    /**
     * Builds a minimal audio graph (by default in [[AudioManager]].default) and synchronizes it with the containing [[Node]]
     * ```plaintext
     * ┌ AudioManager(.default) ────────────────────────┐
     * │ ┌ ComponentAudio ───────────────────┐          │
     * │ │    ┌──────┐   ┌──────┐   ┌──────┐ │ ┌──────┐ │
     * │ │    │source│ → │panner│ → │ gain │ → │ gain │ │
     * │ │    └──────┘   └──────┘   └──────┘ │ └──────┘ │
     * │ └───────────────────────────────────┘          │
     * └────────────────────────────────────────────────┘
     * ```
     * @authors Thomas Dorner, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ComponentAudio extends FudgeCore.Component {
        constructor(_audio = null, _loop = false, _start = false, _audioManager = FudgeCore.AudioManager.default) {
            super();
            /** places and directs the panner relative to the world transform of the [[Node]]  */
            this.pivot = FudgeCore.Matrix4x4.IDENTITY();
            this.singleton = false;
            this.playing = false;
            this.listened = false;
            /**
             * Automatically connects/disconnects AudioNodes when adding/removing this component to/from a node.
             * Therefore unused AudioNodes may be garbage collected when an unused component is collected
             */
            this.handleAttach = (_event) => {
                // Debug.log(_event);
                if (_event.type == "componentAdd" /* COMPONENT_ADD */) {
                    this.getContainer().addEventListener("childAppendToAudioBranch" /* CHILD_APPEND */, this.handleBranch, true);
                    this.getContainer().addEventListener("childRemoveFromAudioBranch" /* CHILD_REMOVE */, this.handleBranch, true);
                    this.getContainer().addEventListener("updateAudioBranch" /* UPDATE */, this.update, true);
                    this.listened = this.getContainer().isDescendantOf(FudgeCore.AudioManager.default.getBranchListeningTo());
                }
                else {
                    this.getContainer().removeEventListener("childAppendToAudioBranch" /* CHILD_APPEND */, this.handleBranch, true);
                    this.getContainer().removeEventListener("childRemoveFromAudioBranch" /* CHILD_REMOVE */, this.handleBranch, true);
                    this.getContainer().removeEventListener("updateAudioBranch" /* UPDATE */, this.update, true);
                    this.listened = false;
                }
                this.updateConnection();
            };
            /**
             * Automatically connects/disconnects AudioNodes when appending/removing the branch the component is in.
             */
            this.handleBranch = (_event) => {
                // Debug.log(_event);
                this.listened = (_event.type == "childAppendToAudioBranch" /* CHILD_APPEND */);
                this.updateConnection();
            };
            /**
             * Updates the panner node, its position and direction, using the worldmatrix of the container and the pivot of this component.
             */
            this.update = (_event) => {
                let mtxResult = this.pivot;
                if (this.getContainer())
                    mtxResult = FudgeCore.Matrix4x4.MULTIPLICATION(this.getContainer().mtxWorld, this.pivot);
                // Debug.log(mtxResult.toString());
                let position = mtxResult.translation;
                let forward = FudgeCore.Vector3.TRANSFORMATION(FudgeCore.Vector3.Z(1), mtxResult, false);
                this.panner.positionX.value = position.x;
                this.panner.positionY.value = position.y;
                this.panner.positionZ.value = position.z;
                this.panner.orientationX.value = forward.x;
                this.panner.orientationY.value = forward.y;
                this.panner.orientationZ.value = forward.z;
            };
            this.install(_audioManager);
            this.createSource(_audio, _loop);
            this.addEventListener("componentAdd" /* COMPONENT_ADD */, this.handleAttach);
            this.addEventListener("componentRemove" /* COMPONENT_REMOVE */, this.handleAttach);
            if (_start)
                this.play(_start);
        }
        set audio(_audio) {
            this.source.buffer = _audio;
        }
        get audio() {
            return this.source.buffer;
        }
        set volume(_value) {
            this.gain.gain.value = _value;
        }
        get volume() {
            return this.gain.gain.value;
        }
        /**
         * Set the property of the panner to the given value. Use to manipulate range and rolloff etc.
         */
        setPanner(_property, _value) {
            Object.assign(this.panner, { [_property]: _value });
        }
        // TODO: may be used for serialization of AudioNodes
        getMutatorOfNode(_type) {
            let node = this.getAudioNode(_type);
            let mutator = FudgeCore.getMutatorOfArbitrary(node);
            return mutator;
        }
        /**
         * Returns the specified AudioNode of the standard graph for further manipulation
         */
        getAudioNode(_type) {
            switch (_type) {
                case AUDIO_NODE_TYPE.SOURCE: return this.source;
                case AUDIO_NODE_TYPE.PANNER: return this.panner;
                case AUDIO_NODE_TYPE.GAIN: return this.gain;
            }
        }
        /**
         * Start or stop playing the audio
         */
        play(_on) {
            if (_on) {
                this.createSource(this.audio, this.source.loop);
                this.source.start(0, 0);
            }
            else
                this.source.stop();
            this.playing = _on;
        }
        get isPlaying() {
            return this.playing;
        }
        get isAttached() {
            return this.getContainer() != null;
        }
        get isListened() {
            return this.listened;
        }
        /**
         * Inserts AudioNodes between the panner and the local gain of this [[ComponentAudio]]
         * _input and _output may be the same AudioNode, if there is only one to insert,
         * or may have multiple AudioNode between them to create an effect-graph.\
         * Note that [[ComponentAudio]] does not keep track of inserted AudioNodes!
         * ```plaintext
         * ┌ AudioManager(.default) ──────────────────────────────────────────────────────┐
         * │ ┌ ComponentAudio ─────────────────────────────────────────────────┐          │
         * │ │    ┌──────┐   ┌──────┐   ┌──────┐          ┌───────┐   ┌──────┐ │ ┌──────┐ │
         * │ │    │source│ → │panner│ → │_input│ → ...  → │_output│ → │ gain │ → │ gain │ │
         * │ │    └──────┘   └──────┘   └──────┘          └───────┘   └──────┘ │ └──────┘ │
         * │ └─────────────────────────────────────────────────────────────────┘          │
         * └──────────────────────────────────────────────────────────────────────────────┘
         * ```
         */
        insertAudioNodes(_input, _output) {
            this.panner.disconnect(0);
            if (!_input && !_output) {
                this.panner.connect(this.gain);
                return;
            }
            this.panner.connect(_input);
            _output.connect(this.gain);
        }
        /**
         * Activate override. Connects or disconnects AudioNodes
         */
        activate(_on) {
            super.activate(_on);
            this.updateConnection();
        }
        /**
         * Connects this components gain-node to the gain node of the AudioManager this component runs on.
         * Only call this method if the component is not attached to a [[Node]] but needs to be heard.
         */
        connect(_on) {
            if (_on)
                this.gain.connect(this.audioManager.gain);
            else
                this.gain.disconnect(this.audioManager.gain);
        }
        install(_audioManager = FudgeCore.AudioManager.default) {
            let active = this.isActive;
            this.activate(false);
            this.audioManager = _audioManager;
            this.panner = _audioManager.createPanner();
            this.gain = _audioManager.createGain();
            this.panner.connect(this.gain);
            this.gain.connect(_audioManager.gain);
            this.activate(active);
        }
        createSource(_audio, _loop) {
            if (this.source) {
                this.source.disconnect();
                this.source.buffer = null;
            }
            this.source = this.audioManager.createBufferSource();
            this.source.connect(this.panner);
            if (_audio)
                this.audio = _audio;
            this.source.loop = _loop;
        }
        updateConnection() {
            try {
                this.connect(this.isActive && this.isAttached && this.listened);
            }
            catch (_error) {
                // nop
            }
        }
    }
    ComponentAudio.iSubclass = FudgeCore.Component.registerSubclass(ComponentAudio);
    FudgeCore.ComponentAudio = ComponentAudio;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Serves to set the spatial location and orientation of AudioListeners relative to the
     * world transform of the [[Node]] it is attached to.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ComponentAudioListener extends FudgeCore.Component {
        constructor() {
            super(...arguments);
            this.pivot = FudgeCore.Matrix4x4.IDENTITY();
        }
        /**
         * Updates the position and orientation of the given AudioListener
         */
        update(_listener) {
            let mtxResult = this.pivot;
            if (this.getContainer())
                mtxResult = FudgeCore.Matrix4x4.MULTIPLICATION(this.getContainer().mtxWorld, this.pivot);
            // Debug.log(mtxResult.toString());
            let position = mtxResult.translation;
            let forward = FudgeCore.Vector3.TRANSFORMATION(FudgeCore.Vector3.Z(1), mtxResult, false);
            let up = FudgeCore.Vector3.TRANSFORMATION(FudgeCore.Vector3.Y(), mtxResult, false);
            _listener.positionX.value = position.x;
            _listener.positionY.value = position.y;
            _listener.positionZ.value = position.z;
            _listener.forwardX.value = forward.x;
            _listener.forwardY.value = forward.y;
            _listener.forwardZ.value = forward.z;
            _listener.upX.value = up.x;
            _listener.upY.value = up.y;
            _listener.upZ.value = up.z;
            // Debug.log(mtxResult.translation.toString(), forward.toString(), up.toString());
        }
    }
    ComponentAudioListener.iSubclass = FudgeCore.Component.registerSubclass(ComponentAudioListener);
    FudgeCore.ComponentAudioListener = ComponentAudioListener;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="Component.ts"/>
var FudgeCore;
// / <reference path="Component.ts"/>
(function (FudgeCore) {
    let FIELD_OF_VIEW;
    (function (FIELD_OF_VIEW) {
        FIELD_OF_VIEW[FIELD_OF_VIEW["HORIZONTAL"] = 0] = "HORIZONTAL";
        FIELD_OF_VIEW[FIELD_OF_VIEW["VERTICAL"] = 1] = "VERTICAL";
        FIELD_OF_VIEW[FIELD_OF_VIEW["DIAGONAL"] = 2] = "DIAGONAL";
    })(FIELD_OF_VIEW = FudgeCore.FIELD_OF_VIEW || (FudgeCore.FIELD_OF_VIEW = {}));
    /**
     * Defines identifiers for the various projections a camera can provide.
     * TODO: change back to number enum if strings not needed
     */
    let PROJECTION;
    (function (PROJECTION) {
        PROJECTION["CENTRAL"] = "central";
        PROJECTION["ORTHOGRAPHIC"] = "orthographic";
        PROJECTION["DIMETRIC"] = "dimetric";
        PROJECTION["STEREO"] = "stereo";
    })(PROJECTION = FudgeCore.PROJECTION || (FudgeCore.PROJECTION = {}));
    /**
     * The camera component holds the projection-matrix and other data needed to render a scene from the perspective of the node it is attached to.
     * @authors Jascha Karagöl, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ComponentCamera extends FudgeCore.Component {
        constructor() {
            super(...arguments);
            this.pivot = FudgeCore.Matrix4x4.IDENTITY();
            this.backgroundColor = new FudgeCore.Color(0, 0, 0, 1); // The color of the background the camera will render.
            //private orthographic: boolean = false; // Determines whether the image will be rendered with perspective or orthographic projection.
            this.projection = PROJECTION.CENTRAL;
            this.transform = new FudgeCore.Matrix4x4; // The matrix to multiply each scene objects transformation by, to determine where it will be drawn.
            this.fieldOfView = 45; // The camera's sensorangle.
            this.aspectRatio = 1.0;
            this.direction = FIELD_OF_VIEW.DIAGONAL;
            this.backgroundEnabled = true; // Determines whether or not the background of this camera will be rendered.
            //#endregion
        }
        // TODO: examine, if background should be an attribute of Camera or Viewport
        getProjection() {
            return this.projection;
        }
        getBackgroundEnabled() {
            return this.backgroundEnabled;
        }
        getAspect() {
            return this.aspectRatio;
        }
        getFieldOfView() {
            return this.fieldOfView;
        }
        getDirection() {
            return this.direction;
        }
        /**
         * Returns the multiplikation of the worldtransformation of the camera container with the projection matrix
         * @returns the world-projection-matrix
         */
        get ViewProjectionMatrix() {
            //TODO: optimize, no need to recalculate if neither mtxWorld nor pivot have changed
            let mtxCamera = this.pivot;
            try {
                mtxCamera = FudgeCore.Matrix4x4.MULTIPLICATION(this.getContainer().mtxWorld, this.pivot);
            }
            catch (_error) {
                // no container node or no world transformation found -> continue with pivot only
            }
            let mtxWorldProjection = FudgeCore.Matrix4x4.INVERSION(mtxCamera);
            mtxWorldProjection = FudgeCore.Matrix4x4.MULTIPLICATION(this.transform, mtxWorldProjection);
            return mtxWorldProjection;
        }
        /**
         * Set the camera to perspective projection. The world origin is in the center of the canvaselement.
         * @param _aspect The aspect ratio between width and height of projectionspace.(Default = canvas.clientWidth / canvas.ClientHeight)
         * @param _fieldOfView The field of view in Degrees. (Default = 45)
         * @param _direction The plane on which the fieldOfView-Angle is given
         */
        projectCentral(_aspect = this.aspectRatio, _fieldOfView = this.fieldOfView, _direction = this.direction) {
            this.aspectRatio = _aspect;
            this.fieldOfView = _fieldOfView;
            this.direction = _direction;
            this.projection = PROJECTION.CENTRAL;
            this.transform = FudgeCore.Matrix4x4.PROJECTION_CENTRAL(_aspect, this.fieldOfView, 1, 2000, this.direction); // TODO: remove magic numbers
        }
        /**
         * Set the camera to orthographic projection. The origin is in the top left corner of the canvas.
         * @param _left The positionvalue of the projectionspace's left border. (Default = 0)
         * @param _right The positionvalue of the projectionspace's right border. (Default = canvas.clientWidth)
         * @param _bottom The positionvalue of the projectionspace's bottom border.(Default = canvas.clientHeight)
         * @param _top The positionvalue of the projectionspace's top border.(Default = 0)
         */
        projectOrthographic(_left = 0, _right = FudgeCore.RenderManager.getCanvas().clientWidth, _bottom = FudgeCore.RenderManager.getCanvas().clientHeight, _top = 0) {
            this.projection = PROJECTION.ORTHOGRAPHIC;
            this.transform = FudgeCore.Matrix4x4.PROJECTION_ORTHOGRAPHIC(_left, _right, _bottom, _top, 400, -400); // TODO: examine magic numbers!
        }
        /**
         * Return the calculated normed dimension of the projection surface, that is in the hypothetical distance of 1 to the camera
         */
        getProjectionRectangle() {
            let tanFov = Math.tan(Math.PI * this.fieldOfView / 360); // Half of the angle, to calculate dimension from the center -> right angle
            let tanHorizontal = 0;
            let tanVertical = 0;
            if (this.direction == FIELD_OF_VIEW.DIAGONAL) {
                let aspect = Math.sqrt(this.aspectRatio);
                tanHorizontal = tanFov * aspect;
                tanVertical = tanFov / aspect;
            }
            else if (this.direction == FIELD_OF_VIEW.VERTICAL) {
                tanVertical = tanFov;
                tanHorizontal = tanVertical * this.aspectRatio;
            }
            else { //FOV_DIRECTION.HORIZONTAL
                tanHorizontal = tanFov;
                tanVertical = tanHorizontal / this.aspectRatio;
            }
            return FudgeCore.Rectangle.GET(0, 0, tanHorizontal * 2, tanVertical * 2);
        }
        project(_pointInWorldSpace) {
            let result;
            result = FudgeCore.Vector3.TRANSFORMATION(_pointInWorldSpace, this.ViewProjectionMatrix);
            let m = this.ViewProjectionMatrix.get();
            let w = m[3] * _pointInWorldSpace.x + m[7] * _pointInWorldSpace.y + m[11] * _pointInWorldSpace.z + m[15];
            result.scale(1 / w);
            return result;
        }
        //#region Transfer
        serialize() {
            let serialization = {
                backgroundColor: this.backgroundColor,
                backgroundEnabled: this.backgroundEnabled,
                projection: this.projection,
                fieldOfView: this.fieldOfView,
                direction: this.direction,
                aspect: this.aspectRatio,
                pivot: this.pivot.serialize(),
                [super.constructor.name]: super.serialize()
            };
            return serialization;
        }
        deserialize(_serialization) {
            this.backgroundColor = _serialization.backgroundColor;
            this.backgroundEnabled = _serialization.backgroundEnabled;
            this.projection = _serialization.projection;
            this.fieldOfView = _serialization.fieldOfView;
            this.aspectRatio = _serialization.aspect;
            this.direction = _serialization.direction;
            this.pivot.deserialize(_serialization.pivot);
            super.deserialize(_serialization[super.constructor.name]);
            switch (this.projection) {
                case PROJECTION.ORTHOGRAPHIC:
                    this.projectOrthographic(); // TODO: serialize and deserialize parameters
                    break;
                case PROJECTION.CENTRAL:
                    this.projectCentral();
                    break;
            }
            return this;
        }
        getMutatorAttributeTypes(_mutator) {
            let types = super.getMutatorAttributeTypes(_mutator);
            if (types.direction)
                types.direction = FIELD_OF_VIEW;
            if (types.projection)
                types.projection = PROJECTION;
            return types;
        }
        mutate(_mutator) {
            super.mutate(_mutator);
            switch (this.projection) {
                case PROJECTION.CENTRAL:
                    this.projectCentral(this.aspectRatio, this.fieldOfView, this.direction);
                    break;
            }
        }
        reduceMutator(_mutator) {
            delete _mutator.transform;
            super.reduceMutator(_mutator);
        }
    }
    ComponentCamera.iSubclass = FudgeCore.Component.registerSubclass(ComponentCamera);
    FudgeCore.ComponentCamera = ComponentCamera;
})(FudgeCore || (FudgeCore = {}));
// /<reference path="../Light/Light.ts"/>
var FudgeCore;
// /<reference path="../Light/Light.ts"/>
(function (FudgeCore) {
    /**
     * Attaches a [[Light]] to the node
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    /**
     * Defines identifiers for the various types of light this component can provide.
     */
    // export enum LIGHT_TYPE {
    //     AMBIENT = "ambient",
    //     DIRECTIONAL = "directional",
    //     POINT = "point",
    //     SPOT = "spot"
    // }
    class ComponentLight extends FudgeCore.Component {
        constructor(_light = new FudgeCore.LightAmbient()) {
            super();
            // private static constructors: { [type: string]: General } = { [LIGHT_TYPE.AMBIENT]: LightAmbient, [LIGHT_TYPE.DIRECTIONAL]: LightDirectional, [LIGHT_TYPE.POINT]: LightPoint, [LIGHT_TYPE.SPOT]: LightSpot };
            this.pivot = FudgeCore.Matrix4x4.IDENTITY();
            this.light = null;
            this.singleton = false;
            this.light = _light;
        }
        setType(_class) {
            let mtrOld = {};
            if (this.light)
                mtrOld = this.light.getMutator();
            this.light = new _class();
            this.light.mutate(mtrOld);
        }
    }
    ComponentLight.iSubclass = FudgeCore.Component.registerSubclass(ComponentLight);
    FudgeCore.ComponentLight = ComponentLight;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Attaches a [[Material]] to the node
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ComponentMaterial extends FudgeCore.Component {
        // public mutatorCoat: MutatorForComponent;
        constructor(_material = null) {
            super();
            this.material = _material;
            // this.mutatorCoat = _material.getCoat().getMutatorForComponent();
        }
        //#region Transfer
        serialize() {
            let serialization;
            /* at this point of time, serialization as resource and as inline object is possible. TODO: check if inline becomes obsolete */
            let idMaterial = this.material.idResource;
            if (idMaterial)
                serialization = { idMaterial: idMaterial };
            else
                serialization = { material: FudgeCore.Serializer.serialize(this.material) };
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        deserialize(_serialization) {
            let material;
            if (_serialization.idMaterial)
                material = FudgeCore.ResourceManager.get(_serialization.idMaterial);
            else
                material = FudgeCore.Serializer.deserialize(_serialization.material);
            this.material = material;
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
    }
    ComponentMaterial.iSubclass = FudgeCore.Component.registerSubclass(ComponentMaterial);
    FudgeCore.ComponentMaterial = ComponentMaterial;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Attaches a [[Mesh]] to the node
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ComponentMesh extends FudgeCore.Component {
        constructor(_mesh = null) {
            super();
            this.pivot = FudgeCore.Matrix4x4.IDENTITY();
            this.mesh = null;
            this.mesh = _mesh;
        }
        //#region Transfer
        serialize() {
            let serialization;
            /* at this point of time, serialization as resource and as inline object is possible. TODO: check if inline becomes obsolete */
            let idMesh = this.mesh.idResource;
            if (idMesh)
                serialization = { idMesh: idMesh };
            else
                serialization = { mesh: FudgeCore.Serializer.serialize(this.mesh) };
            serialization.pivot = this.pivot.serialize();
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        deserialize(_serialization) {
            let mesh;
            if (_serialization.idMesh)
                mesh = FudgeCore.ResourceManager.get(_serialization.idMesh);
            else
                mesh = FudgeCore.Serializer.deserialize(_serialization.mesh);
            this.mesh = mesh;
            this.pivot.deserialize(_serialization.pivot);
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
    }
    ComponentMesh.iSubclass = FudgeCore.Component.registerSubclass(ComponentMesh);
    FudgeCore.ComponentMesh = ComponentMesh;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Base class for scripts the user writes
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ComponentScript extends FudgeCore.Component {
        constructor() {
            super();
            this.singleton = false;
        }
        serialize() {
            return this.getMutator();
        }
        deserialize(_serialization) {
            this.mutate(_serialization);
            return this;
        }
    }
    // registering this doesn't make sense, only its subclasses. Or this component must refer to scripts to be attached to this component
    // TODO: rethink & refactor
    ComponentScript.iSubclass = FudgeCore.Component.registerSubclass(ComponentScript);
    FudgeCore.ComponentScript = ComponentScript;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Attaches a transform-[[Matrix4x4]] to the node, moving, scaling and rotating it in space relative to its parent.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ComponentTransform extends FudgeCore.Component {
        constructor(_matrix = FudgeCore.Matrix4x4.IDENTITY()) {
            super();
            this.local = _matrix;
        }
        //#region Transfer
        serialize() {
            let serialization = {
                local: this.local.serialize(),
                [super.constructor.name]: super.serialize()
            };
            return serialization;
        }
        deserialize(_serialization) {
            super.deserialize(_serialization[super.constructor.name]);
            this.local.deserialize(_serialization.local);
            return this;
        }
        // public mutate(_mutator: Mutator): void {
        //     this.local.mutate(_mutator);
        // }
        // public getMutator(): Mutator { 
        //     return this.local.getMutator();
        // }
        // public getMutatorAttributeTypes(_mutator: Mutator): MutatorAttributeTypes {
        //     let types: MutatorAttributeTypes = this.local.getMutatorAttributeTypes(_mutator);
        //     return types;
        // }
        reduceMutator(_mutator) {
            delete _mutator.world;
            super.reduceMutator(_mutator);
        }
    }
    ComponentTransform.iSubclass = FudgeCore.Component.registerSubclass(ComponentTransform);
    FudgeCore.ComponentTransform = ComponentTransform;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class Axis extends EventTarget {
        constructor(_factor = 1, _type = 0 /* PROPORTIONAL */) {
            super();
            this.valueBase = 0;
            this.inputTarget = 0;
            this.valuePrevious = 0;
            this.inputPrevious = 0;
            this.timeInputDelay = 0;
            this.factor = 0;
            this.timeInputTargetSet = 0;
            this.time = FudgeCore.Time.game;
            this.factor = _factor;
            this.type = _type;
        }
        setTime(_time) {
            this.time = _time;
            this.getValue();
        }
        setInput(_target) {
            this.valueBase = this.getValue();
            this.inputPrevious = this.getInputDelayed();
            this.inputTarget = this.factor * _target;
            this.timeInputTargetSet = this.time.get();
            this.dispatchEvent(new Event("input" /* INPUT */));
        }
        setDelay(_time) {
            // TODO: check if this needs to be disallowed for type DIFFERENTIAL
            this.timeInputDelay = Math.max(0, _time);
        }
        setFactor(_factor) {
            this.factor = _factor;
        }
        getValue() {
            let value = 0;
            let input = this.getInputDelayed();
            switch (this.type) {
                case 1 /* INTEGRAL */:
                    let timeCurrent = this.time.get();
                    let timeElapsedSinceInput = timeCurrent - this.timeInputTargetSet;
                    value = this.valueBase;
                    if (this.timeInputDelay > 0) {
                        if (timeElapsedSinceInput < this.timeInputDelay) {
                            value += 0.5 * (this.inputPrevious + input) * timeElapsedSinceInput;
                            break;
                        }
                        else {
                            value += 0.5 * (this.inputPrevious + input) * this.timeInputDelay;
                            timeElapsedSinceInput -= this.timeInputDelay;
                        }
                    }
                    value += input * timeElapsedSinceInput;
                    // value += 0.5 * (this.inputPrevious - input) * this.timeInputDelay + input * timeElapsedSinceInput;
                    break;
                case 2 /* DIFFERENTIAL */:
                    value = this.valueBase + input;
                    this.inputTarget = 0;
                    this.valueBase = value;
                    break;
                case 0 /* PROPORTIONAL */:
                default:
                    value = input;
                    break;
            }
            return value;
        }
        getInputDelayed() {
            if (this.timeInputDelay > 0) {
                let timeElapsedSinceInput = this.time.get() - this.timeInputTargetSet;
                if (timeElapsedSinceInput < this.timeInputDelay)
                    return this.inputPrevious + (this.inputTarget - this.inputPrevious) * timeElapsedSinceInput / this.timeInputDelay;
            }
            return this.inputTarget;
        }
    }
    FudgeCore.Axis = Axis;
})(FudgeCore || (FudgeCore = {}));
// <reference path="DebugAlert.ts"/>
var FudgeCore;
// <reference path="DebugAlert.ts"/>
(function (FudgeCore) {
    /**
     * The filters corresponding to debug activities, more to come
     */
    let DEBUG_FILTER;
    (function (DEBUG_FILTER) {
        DEBUG_FILTER[DEBUG_FILTER["NONE"] = 0] = "NONE";
        DEBUG_FILTER[DEBUG_FILTER["INFO"] = 1] = "INFO";
        DEBUG_FILTER[DEBUG_FILTER["LOG"] = 2] = "LOG";
        DEBUG_FILTER[DEBUG_FILTER["WARN"] = 4] = "WARN";
        DEBUG_FILTER[DEBUG_FILTER["ERROR"] = 8] = "ERROR";
        DEBUG_FILTER[DEBUG_FILTER["FUDGE"] = 16] = "FUDGE";
        DEBUG_FILTER[DEBUG_FILTER["CLEAR"] = 256] = "CLEAR";
        DEBUG_FILTER[DEBUG_FILTER["GROUP"] = 257] = "GROUP";
        DEBUG_FILTER[DEBUG_FILTER["GROUPCOLLAPSED"] = 258] = "GROUPCOLLAPSED";
        DEBUG_FILTER[DEBUG_FILTER["GROUPEND"] = 260] = "GROUPEND";
        DEBUG_FILTER[DEBUG_FILTER["MESSAGES"] = 31] = "MESSAGES";
        DEBUG_FILTER[DEBUG_FILTER["FORMAT"] = 263] = "FORMAT";
        DEBUG_FILTER[DEBUG_FILTER["ALL"] = 287] = "ALL";
    })(DEBUG_FILTER = FudgeCore.DEBUG_FILTER || (FudgeCore.DEBUG_FILTER = {}));
    // Ⓘ Ⓛ Ⓦ Ⓔ ☠ ☢ ⚠ ✎ ✔ ✓ ❌ ⭍ ☈ 🛈 ▣ ◧ ♢ ♦ ⚂ ⛋ ❖ ⬓ ⬒ 🍩 🍫 🍬 🎲 ☕ 🧊
    FudgeCore.DEBUG_SYMBOL = {
        [DEBUG_FILTER.INFO]: "✓",
        [DEBUG_FILTER.LOG]: "✎",
        [DEBUG_FILTER.WARN]: "⚠",
        [DEBUG_FILTER.ERROR]: "❌",
        [DEBUG_FILTER.FUDGE]: "🎲"
    };
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
(function (FudgeCore) {
    /**
     * Routing to the standard-console
     */
    class DebugConsole extends FudgeCore.DebugTarget {
        /**
         * Displays critical information about failures, which is emphasized e.g. by color
         */
        static fudge(_message, ..._args) {
            console.debug("🎲", _message, ..._args);
            // let trace: string[] = new Error("Test").stack.split("\n");
            // console.log(trace[4]);
            // console.trace("Test");
        }
    }
    DebugConsole.delegates = {
        [FudgeCore.DEBUG_FILTER.INFO]: console.info,
        [FudgeCore.DEBUG_FILTER.LOG]: console.log,
        [FudgeCore.DEBUG_FILTER.WARN]: console.warn,
        [FudgeCore.DEBUG_FILTER.ERROR]: console.error,
        [FudgeCore.DEBUG_FILTER.FUDGE]: DebugConsole.fudge,
        [FudgeCore.DEBUG_FILTER.CLEAR]: console.clear,
        [FudgeCore.DEBUG_FILTER.GROUP]: console.group,
        [FudgeCore.DEBUG_FILTER.GROUPCOLLAPSED]: console.groupCollapsed,
        [FudgeCore.DEBUG_FILTER.GROUPEND]: console.groupEnd
    };
    FudgeCore.DebugConsole = DebugConsole;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
/// <reference path="DebugInterfaces.ts"/>
/// <reference path="DebugConsole.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
/// <reference path="DebugInterfaces.ts"/>
/// <reference path="DebugConsole.ts"/>
(function (FudgeCore) {
    /**
     * The Debug-Class offers functions known from the console-object and additions,
     * routing the information to various [[DebugTargets]] that can be easily defined by the developers and registerd by users
     * Override functions in subclasses of [[DebugTarget]] and register them as their delegates
     */
    class Debug {
        // TODO: create filter DEBUG_FILTER.FUDGE solely for messages from FUDGE
        /**
         * De- / Activate a filter for the given DebugTarget.
         */
        static setFilter(_target, _filter) {
            for (let filter in Debug.delegates)
                Debug.delegates[filter].delete(_target);
            for (let filter in FudgeCore.DEBUG_FILTER) {
                let parsed = parseInt(filter);
                if (isNaN(parsed))
                    break;
                if ([FudgeCore.DEBUG_FILTER.MESSAGES, FudgeCore.DEBUG_FILTER.FORMAT, FudgeCore.DEBUG_FILTER.ALL].indexOf(parsed) != -1)
                    // dont delegate combos... 
                    continue;
                if (_filter & parsed)
                    Debug.delegates[parsed].set(_target, _target.delegates[parsed]);
            }
        }
        /**
         * Info(...) displays additional information with low priority
         */
        static info(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.INFO, _message, _args);
        }
        /**
         * Displays information with medium priority
         */
        static log(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.LOG, _message, _args);
        }
        /**
         * Displays information about non-conformities in usage, which is emphasized e.g. by color
         */
        static warn(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.WARN, _message, _args);
        }
        /**
         * Displays critical information about failures, which is emphasized e.g. by color
         */
        static error(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.ERROR, _message, _args);
        }
        /**
         * Displays messages from FUDGE
         */
        static fudge(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.FUDGE, _message, _args);
        }
        /**
         * Clears the output and removes previous messages if possible
         */
        static clear() {
            Debug.delegate(FudgeCore.DEBUG_FILTER.CLEAR, null, null);
        }
        /**
         * Opens a new group for messages
         */
        static group(_name) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.GROUP, _name, null);
        }
        /**
         * Opens a new group for messages that is collapsed at first
         */
        static groupCollapsed(_name) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.GROUPCOLLAPSED, _name, null);
        }
        /**
         * Closes the youngest group
         */
        static groupEnd() {
            Debug.delegate(FudgeCore.DEBUG_FILTER.GROUPEND, null, null);
        }
        /**
         * Lookup all delegates registered to the filter and call them using the given arguments
         */
        static delegate(_filter, _message, _args) {
            let delegates = Debug.delegates[_filter];
            for (let delegate of delegates.values())
                if (delegate)
                    if (_args && _args.length > 0)
                        delegate(_message, ..._args);
                    else
                        delegate(_message);
        }
        /**
         * setup routing to standard console
         */
        static setupConsole() {
            let result = {};
            let filters = [
                FudgeCore.DEBUG_FILTER.INFO, FudgeCore.DEBUG_FILTER.LOG, FudgeCore.DEBUG_FILTER.WARN, FudgeCore.DEBUG_FILTER.ERROR, FudgeCore.DEBUG_FILTER.FUDGE,
                FudgeCore.DEBUG_FILTER.CLEAR, FudgeCore.DEBUG_FILTER.GROUP, FudgeCore.DEBUG_FILTER.GROUPCOLLAPSED, FudgeCore.DEBUG_FILTER.GROUPEND
            ];
            for (let filter of filters)
                result[filter] = new Map([[FudgeCore.DebugConsole, FudgeCore.DebugConsole.delegates[filter]]]);
            return result;
        }
    }
    /**
     * For each set filter, this associative array keeps references to the registered delegate functions of the chosen [[DebugTargets]]
     */
    Debug.delegates = Debug.setupConsole();
    FudgeCore.Debug = Debug;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
(function (FudgeCore) {
    /**
     * Routing to the alert box
     */
    class DebugAlert extends FudgeCore.DebugTarget {
        static createDelegate(_headline) {
            let delegate = function (_message, ..._args) {
                let args = _args.map(_arg => _arg.toString());
                let out = _headline + " " + FudgeCore.DebugTarget.mergeArguments(_message, args);
                alert(out);
            };
            return delegate;
        }
    }
    DebugAlert.delegates = {
        [FudgeCore.DEBUG_FILTER.INFO]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.INFO]),
        [FudgeCore.DEBUG_FILTER.LOG]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.LOG]),
        [FudgeCore.DEBUG_FILTER.WARN]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.WARN]),
        [FudgeCore.DEBUG_FILTER.ERROR]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.ERROR]),
        [FudgeCore.DEBUG_FILTER.FUDGE]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.FUDGE])
    };
    FudgeCore.DebugAlert = DebugAlert;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
(function (FudgeCore) {
    /**
     * Routing to a HTMLDialogElement
     */
    class DebugDialog extends FudgeCore.DebugTarget {
    }
    FudgeCore.DebugDialog = DebugDialog;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
(function (FudgeCore) {
    /**
     * Route to an HTMLTextArea, may be obsolete when using HTMLDialogElement
     */
    class DebugTextArea extends FudgeCore.DebugTarget {
        static clear() {
            DebugTextArea.textArea.textContent = "";
            DebugTextArea.groups = [];
        }
        static group(_name) {
            DebugTextArea.print("▼ " + _name);
            DebugTextArea.groups.push(_name);
        }
        static groupEnd() {
            DebugTextArea.groups.pop();
        }
        static createDelegate(_headline) {
            let delegate = function (_message, ..._args) {
                DebugTextArea.print(_headline + " " + FudgeCore.DebugTarget.mergeArguments(_message, _args));
            };
            return delegate;
        }
        static getIndentation(_level) {
            let result = "";
            for (let i = 0; i < _level; i++)
                result += "| ";
            return result;
        }
        static print(_text) {
            DebugTextArea.textArea.textContent += DebugTextArea.getIndentation(DebugTextArea.groups.length) + _text + "\n";
            if (DebugTextArea.autoScroll)
                DebugTextArea.textArea.scrollTop = DebugTextArea.textArea.scrollHeight;
        }
    }
    DebugTextArea.textArea = document.createElement("textarea");
    DebugTextArea.autoScroll = true;
    DebugTextArea.delegates = {
        [FudgeCore.DEBUG_FILTER.INFO]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.INFO]),
        [FudgeCore.DEBUG_FILTER.LOG]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.LOG]),
        [FudgeCore.DEBUG_FILTER.WARN]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.WARN]),
        [FudgeCore.DEBUG_FILTER.ERROR]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.ERROR]),
        [FudgeCore.DEBUG_FILTER.FUDGE]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.FUDGE]),
        [FudgeCore.DEBUG_FILTER.CLEAR]: DebugTextArea.clear,
        [FudgeCore.DEBUG_FILTER.GROUP]: DebugTextArea.group,
        [FudgeCore.DEBUG_FILTER.GROUPCOLLAPSED]: DebugTextArea.group,
        [FudgeCore.DEBUG_FILTER.GROUPEND]: DebugTextArea.groupEnd
    };
    DebugTextArea.groups = [];
    FudgeCore.DebugTextArea = DebugTextArea;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Defines a color as values in the range of 0 to 1 for the four channels red, green, blue and alpha (for opacity)
     */
    class Color extends FudgeCore.Mutable {
        constructor(_r = 1, _g = 1, _b = 1, _a = 1) {
            super();
            this.setNormRGBA(_r, _g, _b, _a);
        }
        static getHexFromCSSKeyword(_keyword) {
            Color.crc2.fillStyle = _keyword;
            return Color.crc2.fillStyle;
        }
        static CSS(_keyword, _alpha = 1) {
            let hex = Color.getHexFromCSSKeyword(_keyword);
            let color = new Color(parseInt(hex.substr(1, 2), 16) / 255, parseInt(hex.substr(3, 2), 16) / 255, parseInt(hex.substr(5, 2), 16) / 255, _alpha);
            return color;
        }
        static MULTIPLY(_color1, _color2) {
            return new Color(_color1.r * _color2.r, _color1.g * _color2.g, _color1.b * _color2.b, _color1.a * _color2.a);
        }
        setNormRGBA(_r, _g, _b, _a) {
            this.r = Math.min(1, Math.max(0, _r));
            this.g = Math.min(1, Math.max(0, _g));
            this.b = Math.min(1, Math.max(0, _b));
            this.a = Math.min(1, Math.max(0, _a));
        }
        setBytesRGBA(_r, _g, _b, _a) {
            this.setNormRGBA(_r / 255, _g / 255, _b / 255, _a / 255);
        }
        getArray() {
            return new Float32Array([this.r, this.g, this.b, this.a]);
        }
        setArrayNormRGBA(_color) {
            this.setNormRGBA(_color[0], _color[1], _color[2], _color[3]);
        }
        setArrayBytesRGBA(_color) {
            this.setBytesRGBA(_color[0], _color[1], _color[2], _color[3]);
        }
        getArrayBytesRGBA() {
            return new Uint8ClampedArray([this.r * 255, this.g * 255, this.b * 255, this.a * 255]);
        }
        add(_color) {
            this.r += _color.r;
            this.g += _color.g;
            this.b += _color.b;
            this.a += _color.a;
        }
        getCSS() {
            let bytes = this.getArrayBytesRGBA();
            return `RGBA(${bytes[0]}, ${bytes[1]}, ${bytes[2]}, ${bytes[3]})`;
        }
        reduceMutator(_mutator) { }
    }
    // crc2 only used for converting colors from strings predefined by CSS
    Color.crc2 = document.createElement("canvas").getContext("2d");
    FudgeCore.Color = Color;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Baseclass for materials. Combines a [[Shader]] with a compatible [[Coat]]
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Material extends FudgeCore.Mutable {
        constructor(_name, _shader, _coat) {
            super();
            this.idResource = undefined;
            this.name = _name;
            this.shaderType = _shader;
            if (_shader) {
                if (_coat)
                    this.setCoat(_coat);
                else
                    this.setCoat(this.createCoatMatchingShader());
            }
            FudgeCore.ResourceManager.register(this);
        }
        /**
         * Creates a new [[Coat]] instance that is valid for the [[Shader]] referenced by this material
         */
        createCoatMatchingShader() {
            let coat = new (this.shaderType.getCoat())();
            return coat;
        }
        /**
         * Makes this material reference the given [[Coat]] if it is compatible with the referenced [[Shader]]
         * @param _coat
         */
        setCoat(_coat) {
            if (_coat.constructor != this.shaderType.getCoat())
                throw (new Error("Shader and coat don't match"));
            this.coat = _coat;
        }
        /**
         * Returns the currently referenced [[Coat]] instance
         */
        getCoat() {
            return this.coat;
        }
        /**
         * Changes the materials reference to the given [[Shader]], creates and references a new [[Coat]] instance
         * and mutates the new coat to preserve matching properties.
         * @param _shaderType
         */
        setShader(_shaderType) {
            this.shaderType = _shaderType;
            let coat = this.createCoatMatchingShader();
            coat.mutate(this.coat.getMutator());
            this.setCoat(coat);
        }
        /**
         * Returns the [[Shader]] referenced by this material
         */
        getShader() {
            return this.shaderType;
        }
        //#region Transfer
        // TODO: this type of serialization was implemented for implicit Material create. Check if obsolete when only one material class exists and/or materials are stored separately
        serialize() {
            let serialization = {
                name: this.name,
                idResource: this.idResource,
                shader: this.shaderType.name,
                coat: FudgeCore.Serializer.serialize(this.coat)
            };
            return serialization;
        }
        deserialize(_serialization) {
            this.name = _serialization.name;
            this.idResource = _serialization.idResource;
            // TODO: provide for shaders in the users namespace. See Serializer fullpath etc.
            // tslint:disable-next-line: no-any
            this.shaderType = FudgeCore[_serialization.shader];
            let coat = FudgeCore.Serializer.deserialize(_serialization.coat);
            this.setCoat(coat);
            return this;
        }
        reduceMutator(_mutator) {
            //
        }
    }
    FudgeCore.Material = Material;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Keeps a depot of objects that have been marked for reuse, sorted by type.
     * Using [[Recycler]] reduces load on the carbage collector and thus supports smooth performance
     */
    class Recycler {
        /**
         * Returns an object of the requested type from the depot, or a new one, if the depot was empty
         * @param _T The class identifier of the desired object
         */
        static get(_T) {
            let key = _T.name;
            let instances = Recycler.depot[key];
            if (instances && instances.length > 0)
                return instances.pop();
            else
                return new _T();
        }
        /**
         * Stores the object in the depot for later recycling. Users are responsible for throwing in objects that are about to loose scope and are not referenced by any other
         * @param _instance
         */
        static store(_instance) {
            let key = _instance.constructor.name;
            //Debug.log(key);
            let instances = Recycler.depot[key] || [];
            instances.push(_instance);
            Recycler.depot[key] = instances;
            // Debug.log(`ObjectManager.depot[${key}]: ${ObjectManager.depot[key].length}`);
            //Debug.log(this.depot);
        }
        /**
         * Emptys the depot of a given type, leaving the objects for the garbage collector. May result in a short stall when many objects were in
         * @param _T
         */
        static dump(_T) {
            let key = _T.name;
            Recycler.depot[key] = [];
        }
        /**
         * Emptys all depots, leaving all objects to the garbage collector. May result in a short stall when many objects were in
         */
        static dumpAll() {
            Recycler.depot = {};
        }
    }
    Recycler.depot = {};
    FudgeCore.Recycler = Recycler;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Static class handling the resources used with the current FUDGE-instance.
     * Keeps a list of the resources and generates ids to retrieve them.
     * Resources are objects referenced multiple times but supposed to be stored only once
     */
    class ResourceManager {
        /**
         * Generates an id for the resources and registers it with the list of resources
         * @param _resource
         */
        static register(_resource) {
            if (!_resource.idResource)
                _resource.idResource = ResourceManager.generateId(_resource);
            ResourceManager.resources[_resource.idResource] = _resource;
        }
        /**
         * Generate a user readable and unique id using the type of the resource, the date and random numbers
         * @param _resource
         */
        static generateId(_resource) {
            // TODO: build id and integrate info from resource, not just date
            let idResource;
            do
                idResource = _resource.constructor.name + "|" + new Date().toISOString() + "|" + Math.random().toPrecision(5).substr(2, 5);
            while (ResourceManager.resources[idResource]);
            return idResource;
        }
        /**
         * Tests, if an object is a [[SerializableResource]]
         * @param _object The object to examine
         */
        static isResource(_object) {
            return (Reflect.has(_object, "idResource"));
        }
        /**
         * Retrieves the resource stored with the given id
         * @param _idResource
         */
        static get(_idResource) {
            let resource = ResourceManager.resources[_idResource];
            if (!resource) {
                let serialization = ResourceManager.serialization[_idResource];
                if (!serialization) {
                    FudgeCore.Debug.error("Resource not found", _idResource);
                    return null;
                }
                resource = ResourceManager.deserializeResource(serialization);
            }
            return resource;
        }
        /**
         * Creates and registers a resource from a [[Node]], copying the complete branch starting with it
         * @param _node A node to create the resource from
         * @param _replaceWithInstance if true (default), the node used as origin is replaced by a [[NodeResourceInstance]] of the [[NodeResource]] created
         */
        static registerNodeAsResource(_node, _replaceWithInstance = true) {
            let serialization = _node.serialize();
            let nodeResource = new FudgeCore.NodeResource("NodeResource");
            nodeResource.deserialize(serialization);
            ResourceManager.register(nodeResource);
            if (_replaceWithInstance && _node.getParent()) {
                let instance = new FudgeCore.NodeResourceInstance(nodeResource);
                _node.getParent().replaceChild(_node, instance);
            }
            return nodeResource;
        }
        /**
         * Serialize all resources
         */
        static serialize() {
            let serialization = {};
            for (let idResource in ResourceManager.resources) {
                let resource = ResourceManager.resources[idResource];
                if (idResource != resource.idResource)
                    FudgeCore.Debug.error("Resource-id mismatch", resource);
                serialization[idResource] = FudgeCore.Serializer.serialize(resource);
            }
            return serialization;
        }
        /**
         * Create resources from a serialization, deleting all resources previously registered
         * @param _serialization
         */
        static deserialize(_serialization) {
            ResourceManager.serialization = _serialization;
            ResourceManager.resources = {};
            for (let idResource in _serialization) {
                let serialization = _serialization[idResource];
                let resource = ResourceManager.deserializeResource(serialization);
                if (resource)
                    ResourceManager.resources[idResource] = resource;
            }
            return ResourceManager.resources;
        }
        static deserializeResource(_serialization) {
            return FudgeCore.Serializer.deserialize(_serialization);
        }
    }
    ResourceManager.resources = {};
    ResourceManager.serialization = null;
    FudgeCore.ResourceManager = ResourceManager;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="../Light/Light.ts"/>
// / <reference path="../Event/Event.ts"/>
// / <reference path="../Component/ComponentLight.ts"/>
// / <reference path="../Math/Rectangle.ts"/>
var FudgeCore;
// / <reference path="../Light/Light.ts"/>
// / <reference path="../Event/Event.ts"/>
// / <reference path="../Component/ComponentLight.ts"/>
// / <reference path="../Math/Rectangle.ts"/>
(function (FudgeCore) {
    /**
     * Controls the rendering of a branch of a scenetree, using the given [[ComponentCamera]],
     * and the propagation of the rendered image from the offscreen renderbuffer to the target canvas
     * through a series of [[Framing]] objects. The stages involved are in order of rendering
     * [[RenderManager]].viewport -> [[Viewport]].source -> [[Viewport]].destination -> DOM-Canvas -> Client(CSS)
     * @authors Jascha Karagöl, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Viewport extends FudgeCore.EventTargetƒ {
        constructor() {
            super(...arguments);
            this.name = "Viewport"; // The name to call this viewport by.
            this.camera = null; // The camera representing the view parameters to render the branch.
            // TODO: verify if client to canvas should be in Viewport or somewhere else (Window, Container?)
            // Multiple viewports using the same canvas shouldn't differ here...
            // different framing methods can be used, this is the default
            this.frameClientToCanvas = new FudgeCore.FramingScaled();
            this.frameCanvasToDestination = new FudgeCore.FramingComplex();
            this.frameDestinationToSource = new FudgeCore.FramingScaled();
            this.frameSourceToRender = new FudgeCore.FramingScaled();
            this.adjustingFrames = true;
            this.adjustingCamera = true;
            this.lights = null;
            this.branch = null; // The first node in the tree(branch) that will be rendered.
            this.crc2 = null;
            this.canvas = null;
            this.pickBuffers = [];
            /**
             * Handle drag-drop events and dispatch to viewport as FUDGE-Event
             */
            this.hndDragDropEvent = (_event) => {
                let _dragevent = _event;
                switch (_dragevent.type) {
                    case "dragover":
                    case "drop":
                        _dragevent.preventDefault();
                        _dragevent.dataTransfer.effectAllowed = "none";
                        break;
                    case "dragstart":
                        // just dummy data,  valid data should be set in handler registered by the user
                        _dragevent.dataTransfer.setData("text", "Hallo");
                        // TODO: check if there is a better solution to hide the ghost image of the draggable object
                        _dragevent.dataTransfer.setDragImage(new Image(), 0, 0);
                        break;
                }
                let event = new FudgeCore.EventDragDrop("ƒ" + _event.type, _dragevent);
                this.addCanvasPosition(event);
                this.dispatchEvent(event);
            };
            /**
             * Handle pointer events and dispatch to viewport as FUDGE-Event
             */
            this.hndPointerEvent = (_event) => {
                let event = new FudgeCore.EventPointer("ƒ" + _event.type, _event);
                this.addCanvasPosition(event);
                this.dispatchEvent(event);
            };
            /**
             * Handle keyboard events and dispatch to viewport as FUDGE-Event, if the viewport has the focus
             */
            this.hndKeyboardEvent = (_event) => {
                if (!this.hasFocus)
                    return;
                let event = new FudgeCore.EventKeyboard("ƒ" + _event.type, _event);
                this.dispatchEvent(event);
            };
            /**
             * Handle wheel event and dispatch to viewport as FUDGE-Event
             */
            this.hndWheelEvent = (_event) => {
                let event = new FudgeCore.EventWheel("ƒ" + _event.type, _event);
                this.dispatchEvent(event);
            };
        }
        /**
         * Connects the viewport to the given canvas to render the given branch to using the given camera-component, and names the viewport as given.
         * @param _name
         * @param _branch
         * @param _camera
         * @param _canvas
         */
        initialize(_name, _branch, _camera, _canvas) {
            this.name = _name;
            this.camera = _camera;
            this.canvas = _canvas;
            this.crc2 = _canvas.getContext("2d");
            this.rectSource = FudgeCore.RenderManager.getCanvasRect();
            this.rectDestination = this.getClientRectangle();
            this.setBranch(_branch);
        }
        /**
         * Retrieve the 2D-context attached to the destination canvas
         */
        getContext() {
            return this.crc2;
        }
        /**
         * Retrieve the size of the destination canvas as a rectangle, x and y are always 0
         */
        getCanvasRectangle() {
            return FudgeCore.Rectangle.GET(0, 0, this.canvas.width, this.canvas.height);
        }
        /**
         * Retrieve the client rectangle the canvas is displayed and fit in, x and y are always 0
         */
        getClientRectangle() {
            // FUDGE doesn't care about where the client rect is, only about the size matters.
            // return Rectangle.GET(this.canvas.offsetLeft, this.canvas.offsetTop, this.canvas.clientWidth, this.canvas.clientHeight);
            return FudgeCore.Rectangle.GET(0, 0, this.canvas.clientWidth, this.canvas.clientHeight);
        }
        /**
         * Set the branch to be drawn in the viewport.
         */
        setBranch(_branch) {
            if (this.branch) {
                this.branch.removeEventListener("componentAdd" /* COMPONENT_ADD */, this.hndComponentEvent);
                this.branch.removeEventListener("componentRemove" /* COMPONENT_REMOVE */, this.hndComponentEvent);
            }
            this.branch = _branch;
            if (this.branch) {
                this.collectLights();
                this.branch.addEventListener("componentAdd" /* COMPONENT_ADD */, this.hndComponentEvent);
                this.branch.addEventListener("componentRemove" /* COMPONENT_REMOVE */, this.hndComponentEvent);
            }
        }
        /**
         * Logs this viewports scenegraph to the console.
         */
        showSceneGraph() {
            // TODO: move to debug-class
            let output = "SceneGraph for this viewport:";
            output += "\n \n";
            output += this.branch.name;
            FudgeCore.Debug.log(output + "   => ROOTNODE" + this.createSceneGraph(this.branch));
        }
        // #region Drawing
        /**
         * Draw this viewport
         */
        draw() {
            FudgeCore.RenderManager.resetFrameBuffer();
            if (!this.camera.isActive)
                return;
            if (this.adjustingFrames)
                this.adjustFrames();
            if (this.adjustingCamera)
                this.adjustCamera();
            FudgeCore.RenderManager.clear(this.camera.backgroundColor);
            if (FudgeCore.RenderManager.addBranch(this.branch))
                // branch has not yet been processed fully by rendermanager -> update all registered nodes
                FudgeCore.RenderManager.update();
            FudgeCore.RenderManager.setLights(this.lights);
            FudgeCore.RenderManager.drawBranch(this.branch, this.camera);
            this.crc2.imageSmoothingEnabled = false;
            this.crc2.drawImage(FudgeCore.RenderManager.getCanvas(), this.rectSource.x, this.rectSource.y, this.rectSource.width, this.rectSource.height, this.rectDestination.x, this.rectDestination.y, this.rectDestination.width, this.rectDestination.height);
        }
        /**
        * Draw this viewport for RayCast
        */
        createPickBuffers() {
            if (this.adjustingFrames)
                this.adjustFrames();
            if (this.adjustingCamera)
                this.adjustCamera();
            if (FudgeCore.RenderManager.addBranch(this.branch))
                // branch has not yet been processed fully by rendermanager -> update all registered nodes
                FudgeCore.RenderManager.update();
            this.pickBuffers = FudgeCore.RenderManager.drawBranchForRayCast(this.branch, this.camera);
            FudgeCore.Debug.log(this.pickBuffers[0].frameBuffer);
        }
        pickNodeAt(_pos) {
            // this.createPickBuffers();
            let hits = FudgeCore.RenderManager.pickNodeAt(_pos, this.pickBuffers, this.rectSource);
            hits.sort((a, b) => (b.zBuffer > 0) ? (a.zBuffer > 0) ? a.zBuffer - b.zBuffer : 1 : -1);
            return hits;
        }
        /**
         * Adjust all frames involved in the rendering process from the display area in the client up to the renderer canvas
         */
        adjustFrames() {
            // get the rectangle of the canvas area as displayed (consider css)
            let rectClient = this.getClientRectangle();
            // adjust the canvas size according to the given framing applied to client
            let rectCanvas = this.frameClientToCanvas.getRect(rectClient);
            this.canvas.width = rectCanvas.width;
            this.canvas.height = rectCanvas.height;
            // adjust the destination area on the target-canvas to render to by applying the framing to canvas
            this.rectDestination = this.frameCanvasToDestination.getRect(rectCanvas);
            // adjust the area on the source-canvas to render from by applying the framing to destination area
            this.rectSource = this.frameDestinationToSource.getRect(this.rectDestination);
            // having an offset source does make sense only when multiple viewports display parts of the same rendering. For now: shift it to 0,0
            this.rectSource.x = this.rectSource.y = 0;
            // still, a partial image of the rendering may be retrieved by moving and resizing the render viewport
            let rectRender = this.frameSourceToRender.getRect(this.rectSource);
            FudgeCore.RenderManager.setViewportRectangle(rectRender);
            // no more transformation after this for now, offscreen canvas and render-viewport have the same size
            FudgeCore.RenderManager.setCanvasSize(rectRender.width, rectRender.height);
        }
        /**
         * Adjust the camera parameters to fit the rendering into the render vieport
         */
        adjustCamera() {
            let rect = FudgeCore.RenderManager.getViewportRectangle();
            this.camera.projectCentral(rect.width / rect.height, this.camera.getFieldOfView());
        }
        // #endregion
        //#region Points
        /**
         * Returns a point on the source-rectangle matching the given point on the client rectangle
         */
        pointClientToSource(_client) {
            let result = this.frameClientToCanvas.getPoint(_client, this.getClientRectangle());
            result = this.frameCanvasToDestination.getPoint(result, this.getCanvasRectangle());
            result = this.frameDestinationToSource.getPoint(result, this.rectSource);
            //TODO: when Source, Render and RenderViewport deviate, continue transformation 
            return result;
        }
        /**
         * Returns a point on the render-rectangle matching the given point on the source rectangle
         */
        pointSourceToRender(_source) {
            let projectionRectangle = this.camera.getProjectionRectangle();
            let point = this.frameSourceToRender.getPoint(_source, projectionRectangle);
            return point;
        }
        /**
         * Returns a point on the render-rectangle matching the given point on the client rectangle
         */
        pointClientToRender(_client) {
            let point = this.pointClientToSource(_client);
            point = this.pointSourceToRender(point);
            //TODO: when Render and RenderViewport deviate, continue transformation 
            return point;
        }
        /**
         * Returns a point in normed view-rectangle matching the given point on the client rectangle
         * The view-rectangle matches the client size in the hypothetical distance of 1 to the camera, its origin in the center and y-axis pointing up
         * TODO: examine, if this should be a camera-method. Current implementation is for central-projection
         */
        pointClientToProjection(_client) {
            let posRender = this.pointClientToRender(_client);
            let rectRender = this.frameSourceToRender.getRect(this.rectSource);
            let rectProjection = this.camera.getProjectionRectangle();
            let posProjection = new FudgeCore.Vector2(rectProjection.width * posRender.x / rectRender.width, rectProjection.height * posRender.y / rectRender.height);
            posProjection.subtract(new FudgeCore.Vector2(rectProjection.width / 2, rectProjection.height / 2));
            posProjection.y *= -1;
            return posProjection;
        }
        /**
         * Returns a point in the client rectangle matching the given point in normed clipspace rectangle,
         * which stretches from -1 to 1 in both dimensions, y pointing up
         */
        pointClipToClient(_normed) {
            // let rectClient: Rectangle = this.getClientRectangle();
            // let result: Vector2 = Vector2.ONE(0.5);
            // result.x *= (_normed.x + 1) * rectClient.width;
            // result.y *= (1 - _normed.y) * rectClient.height;
            // result.add(rectClient.position);
            //TODO: check if rectDestination can be safely (and more perfomant) be used instead getClientRectangle
            let pointClient = FudgeCore.RenderManager.rectClip.pointToRect(_normed, this.rectDestination);
            return pointClient;
        }
        /**
         * Returns a point in the client rectangle matching the given point in normed clipspace rectangle,
         * which stretches from -1 to 1 in both dimensions, y pointing up
         */
        pointClipToCanvas(_normed) {
            let pointCanvas = FudgeCore.RenderManager.rectClip.pointToRect(_normed, this.getCanvasRectangle());
            return pointCanvas;
        }
        pointClientToScreen(_client) {
            let screen = new FudgeCore.Vector2(this.canvas.offsetLeft + _client.x, this.canvas.offsetTop + _client.y);
            return screen;
        }
        //#endregion
        // #region Events (passing from canvas to viewport and from there into branch)
        /**
         * Returns true if this viewport currently has focus and thus receives keyboard events
         */
        get hasFocus() {
            return (Viewport.focus == this);
        }
        /**
         * Switch the viewports focus on or off. Only one viewport in one FUDGE instance can have the focus, thus receiving keyboard events.
         * So a viewport currently having the focus will lose it, when another one receives it. The viewports fire [[Event]]s accordingly.
         *
         * @param _on
         */
        setFocus(_on) {
            if (_on) {
                if (Viewport.focus == this)
                    return;
                if (Viewport.focus)
                    Viewport.focus.dispatchEvent(new Event("focusout" /* FOCUS_OUT */));
                Viewport.focus = this;
                this.dispatchEvent(new Event("focusin" /* FOCUS_IN */));
            }
            else {
                if (Viewport.focus != this)
                    return;
                this.dispatchEvent(new Event("focusout" /* FOCUS_OUT */));
                Viewport.focus = null;
            }
        }
        /**
         * De- / Activates the given pointer event to be propagated into the viewport as FUDGE-Event
         * @param _type
         * @param _on
         */
        activatePointerEvent(_type, _on) {
            this.activateEvent(this.canvas, _type, this.hndPointerEvent, _on);
        }
        /**
         * De- / Activates the given keyboard event to be propagated into the viewport as FUDGE-Event
         * @param _type
         * @param _on
         */
        activateKeyboardEvent(_type, _on) {
            this.activateEvent(this.canvas.ownerDocument, _type, this.hndKeyboardEvent, _on);
        }
        /**
         * De- / Activates the given drag-drop event to be propagated into the viewport as FUDGE-Event
         * @param _type
         * @param _on
         */
        activateDragDropEvent(_type, _on) {
            if (_type == "\u0192dragstart" /* START */)
                this.canvas.draggable = _on;
            this.activateEvent(this.canvas, _type, this.hndDragDropEvent, _on);
        }
        /**
         * De- / Activates the wheel event to be propagated into the viewport as FUDGE-Event
         * @param _type
         * @param _on
         */
        activateWheelEvent(_type, _on) {
            this.activateEvent(this.canvas, _type, this.hndWheelEvent, _on);
        }
        /**
         * Add position of the pointer mapped to canvas-coordinates as canvasX, canvasY to the event
         * @param event
         */
        addCanvasPosition(event) {
            event.canvasX = this.canvas.width * event.pointerX / event.clientRect.width;
            event.canvasY = this.canvas.height * event.pointerY / event.clientRect.height;
        }
        activateEvent(_target, _type, _handler, _on) {
            _type = _type.slice(1); // chip the ƒlorentin
            if (_on)
                _target.addEventListener(_type, _handler);
            else
                _target.removeEventListener(_type, _handler);
        }
        hndComponentEvent(_event) {
            FudgeCore.Debug.log(_event);
        }
        // #endregion
        /**
         * Collect all lights in the branch to pass to shaders
         */
        collectLights() {
            // TODO: make private
            this.lights = new Map();
            for (let node of this.branch.branch) {
                let cmpLights = node.getComponents(FudgeCore.ComponentLight);
                for (let cmpLight of cmpLights) {
                    let type = cmpLight.light.getType();
                    let lightsOfType = this.lights.get(type);
                    if (!lightsOfType) {
                        lightsOfType = [];
                        this.lights.set(type, lightsOfType);
                    }
                    lightsOfType.push(cmpLight);
                }
            }
        }
        /**
         * Creates an outputstring as visual representation of this viewports scenegraph. Called for the passed node and recursive for all its children.
         * @param _fudgeNode The node to create a scenegraphentry for.
         */
        createSceneGraph(_fudgeNode) {
            // TODO: move to debug-class
            let output = "";
            for (let name in _fudgeNode.getChildren()) {
                let child = _fudgeNode.getChildren()[name];
                output += "\n";
                let current = child;
                if (current.getParent() && current.getParent().getParent())
                    output += "|";
                while (current.getParent() && current.getParent().getParent()) {
                    output += "   ";
                    current = current.getParent();
                }
                output += "'--";
                output += child.name;
                output += this.createSceneGraph(child);
            }
            return output;
        }
    }
    FudgeCore.Viewport = Viewport;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class EventDragDrop extends DragEvent {
        constructor(type, _event) {
            super(type, _event);
            let target = _event.target;
            this.clientRect = target.getClientRects()[0];
            this.pointerX = _event.clientX - this.clientRect.left;
            this.pointerY = _event.clientY - this.clientRect.top;
        }
    }
    FudgeCore.EventDragDrop = EventDragDrop;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class EventKeyboard extends KeyboardEvent {
        constructor(type, _event) {
            super(type, _event);
        }
    }
    FudgeCore.EventKeyboard = EventKeyboard;
    /**
     * The codes sent from a standard english keyboard layout
     */
    let KEYBOARD_CODE;
    (function (KEYBOARD_CODE) {
        KEYBOARD_CODE["A"] = "KeyA";
        KEYBOARD_CODE["B"] = "KeyB";
        KEYBOARD_CODE["C"] = "KeyC";
        KEYBOARD_CODE["D"] = "KeyD";
        KEYBOARD_CODE["E"] = "KeyE";
        KEYBOARD_CODE["F"] = "KeyF";
        KEYBOARD_CODE["G"] = "KeyG";
        KEYBOARD_CODE["H"] = "KeyH";
        KEYBOARD_CODE["I"] = "KeyI";
        KEYBOARD_CODE["J"] = "KeyJ";
        KEYBOARD_CODE["K"] = "KeyK";
        KEYBOARD_CODE["L"] = "KeyL";
        KEYBOARD_CODE["M"] = "KeyM";
        KEYBOARD_CODE["N"] = "KeyN";
        KEYBOARD_CODE["O"] = "KeyO";
        KEYBOARD_CODE["P"] = "KeyP";
        KEYBOARD_CODE["Q"] = "KeyQ";
        KEYBOARD_CODE["R"] = "KeyR";
        KEYBOARD_CODE["S"] = "KeyS";
        KEYBOARD_CODE["T"] = "KeyT";
        KEYBOARD_CODE["U"] = "KeyU";
        KEYBOARD_CODE["V"] = "KeyV";
        KEYBOARD_CODE["W"] = "KeyW";
        KEYBOARD_CODE["X"] = "KeyX";
        KEYBOARD_CODE["Y"] = "KeyY";
        KEYBOARD_CODE["Z"] = "KeyZ";
        KEYBOARD_CODE["ESC"] = "Escape";
        KEYBOARD_CODE["ZERO"] = "Digit0";
        KEYBOARD_CODE["ONE"] = "Digit1";
        KEYBOARD_CODE["TWO"] = "Digit2";
        KEYBOARD_CODE["THREE"] = "Digit3";
        KEYBOARD_CODE["FOUR"] = "Digit4";
        KEYBOARD_CODE["FIVE"] = "Digit5";
        KEYBOARD_CODE["SIX"] = "Digit6";
        KEYBOARD_CODE["SEVEN"] = "Digit7";
        KEYBOARD_CODE["EIGHT"] = "Digit8";
        KEYBOARD_CODE["NINE"] = "Digit9";
        KEYBOARD_CODE["MINUS"] = "Minus";
        KEYBOARD_CODE["EQUAL"] = "Equal";
        KEYBOARD_CODE["BACKSPACE"] = "Backspace";
        KEYBOARD_CODE["TABULATOR"] = "Tab";
        KEYBOARD_CODE["BRACKET_LEFT"] = "BracketLeft";
        KEYBOARD_CODE["BRACKET_RIGHT"] = "BracketRight";
        KEYBOARD_CODE["ENTER"] = "Enter";
        KEYBOARD_CODE["CTRL_LEFT"] = "ControlLeft";
        KEYBOARD_CODE["SEMICOLON"] = "Semicolon";
        KEYBOARD_CODE["QUOTE"] = "Quote";
        KEYBOARD_CODE["BACK_QUOTE"] = "Backquote";
        KEYBOARD_CODE["SHIFT_LEFT"] = "ShiftLeft";
        KEYBOARD_CODE["BACKSLASH"] = "Backslash";
        KEYBOARD_CODE["COMMA"] = "Comma";
        KEYBOARD_CODE["PERIOD"] = "Period";
        KEYBOARD_CODE["SLASH"] = "Slash";
        KEYBOARD_CODE["SHIFT_RIGHT"] = "ShiftRight";
        KEYBOARD_CODE["NUMPAD_MULTIPLY"] = "NumpadMultiply";
        KEYBOARD_CODE["ALT_LEFT"] = "AltLeft";
        KEYBOARD_CODE["SPACE"] = "Space";
        KEYBOARD_CODE["CAPS_LOCK"] = "CapsLock";
        KEYBOARD_CODE["F1"] = "F1";
        KEYBOARD_CODE["F2"] = "F2";
        KEYBOARD_CODE["F3"] = "F3";
        KEYBOARD_CODE["F4"] = "F4";
        KEYBOARD_CODE["F5"] = "F5";
        KEYBOARD_CODE["F6"] = "F6";
        KEYBOARD_CODE["F7"] = "F7";
        KEYBOARD_CODE["F8"] = "F8";
        KEYBOARD_CODE["F9"] = "F9";
        KEYBOARD_CODE["F10"] = "F10";
        KEYBOARD_CODE["PAUSE"] = "Pause";
        KEYBOARD_CODE["SCROLL_LOCK"] = "ScrollLock";
        KEYBOARD_CODE["NUMPAD7"] = "Numpad7";
        KEYBOARD_CODE["NUMPAD8"] = "Numpad8";
        KEYBOARD_CODE["NUMPAD9"] = "Numpad9";
        KEYBOARD_CODE["NUMPAD_SUBTRACT"] = "NumpadSubtract";
        KEYBOARD_CODE["NUMPAD4"] = "Numpad4";
        KEYBOARD_CODE["NUMPAD5"] = "Numpad5";
        KEYBOARD_CODE["NUMPAD6"] = "Numpad6";
        KEYBOARD_CODE["NUMPAD_ADD"] = "NumpadAdd";
        KEYBOARD_CODE["NUMPAD1"] = "Numpad1";
        KEYBOARD_CODE["NUMPAD2"] = "Numpad2";
        KEYBOARD_CODE["NUMPAD3"] = "Numpad3";
        KEYBOARD_CODE["NUMPAD0"] = "Numpad0";
        KEYBOARD_CODE["NUMPAD_DECIMAL"] = "NumpadDecimal";
        KEYBOARD_CODE["PRINT_SCREEN"] = "PrintScreen";
        KEYBOARD_CODE["INTL_BACK_SLASH"] = "IntlBackSlash";
        KEYBOARD_CODE["F11"] = "F11";
        KEYBOARD_CODE["F12"] = "F12";
        KEYBOARD_CODE["NUMPAD_EQUAL"] = "NumpadEqual";
        KEYBOARD_CODE["F13"] = "F13";
        KEYBOARD_CODE["F14"] = "F14";
        KEYBOARD_CODE["F15"] = "F15";
        KEYBOARD_CODE["F16"] = "F16";
        KEYBOARD_CODE["F17"] = "F17";
        KEYBOARD_CODE["F18"] = "F18";
        KEYBOARD_CODE["F19"] = "F19";
        KEYBOARD_CODE["F20"] = "F20";
        KEYBOARD_CODE["F21"] = "F21";
        KEYBOARD_CODE["F22"] = "F22";
        KEYBOARD_CODE["F23"] = "F23";
        KEYBOARD_CODE["F24"] = "F24";
        KEYBOARD_CODE["KANA_MODE"] = "KanaMode";
        KEYBOARD_CODE["LANG2"] = "Lang2";
        KEYBOARD_CODE["LANG1"] = "Lang1";
        KEYBOARD_CODE["INTL_RO"] = "IntlRo";
        KEYBOARD_CODE["CONVERT"] = "Convert";
        KEYBOARD_CODE["NON_CONVERT"] = "NonConvert";
        KEYBOARD_CODE["INTL_YEN"] = "IntlYen";
        KEYBOARD_CODE["NUMPAD_COMMA"] = "NumpadComma";
        KEYBOARD_CODE["UNDO"] = "Undo";
        KEYBOARD_CODE["PASTE"] = "Paste";
        KEYBOARD_CODE["MEDIA_TRACK_PREVIOUS"] = "MediaTrackPrevious";
        KEYBOARD_CODE["CUT"] = "Cut";
        KEYBOARD_CODE["COPY"] = "Copy";
        KEYBOARD_CODE["MEDIA_TRACK_NEXT"] = "MediaTrackNext";
        KEYBOARD_CODE["NUMPAD_ENTER"] = "NumpadEnter";
        KEYBOARD_CODE["CTRL_RIGHT"] = "ControlRight";
        KEYBOARD_CODE["AUDIO_VOLUME_MUTE"] = "AudioVolumeMute";
        KEYBOARD_CODE["LAUNCH_APP2"] = "LaunchApp2";
        KEYBOARD_CODE["MEDIA_PLAY_PAUSE"] = "MediaPlayPause";
        KEYBOARD_CODE["MEDIA_STOP"] = "MediaStop";
        KEYBOARD_CODE["EJECT"] = "Eject";
        KEYBOARD_CODE["AUDIO_VOLUME_DOWN"] = "AudioVolumeDown";
        KEYBOARD_CODE["VOLUME_DOWN"] = "VolumeDown";
        KEYBOARD_CODE["AUDIO_VOLUME_UP"] = "AudioVolumeUp";
        KEYBOARD_CODE["VOLUME_UP"] = "VolumeUp";
        KEYBOARD_CODE["BROWSER_HOME"] = "BrowserHome";
        KEYBOARD_CODE["NUMPAD_DIVIDE"] = "NumpadDivide";
        KEYBOARD_CODE["ALT_RIGHT"] = "AltRight";
        KEYBOARD_CODE["HELP"] = "Help";
        KEYBOARD_CODE["NUM_LOCK"] = "NumLock";
        KEYBOARD_CODE["HOME"] = "Home";
        KEYBOARD_CODE["ARROW_UP"] = "ArrowUp";
        KEYBOARD_CODE["ARROW_RIGHT"] = "ArrowRight";
        KEYBOARD_CODE["ARROW_DOWN"] = "ArrowDown";
        KEYBOARD_CODE["ARROW_LEFT"] = "ArrowLeft";
        KEYBOARD_CODE["END"] = "End";
        KEYBOARD_CODE["PAGE_UP"] = "PageUp";
        KEYBOARD_CODE["PAGE_DOWN"] = "PageDown";
        KEYBOARD_CODE["INSERT"] = "Insert";
        KEYBOARD_CODE["DELETE"] = "Delete";
        KEYBOARD_CODE["META_LEFT"] = "Meta_Left";
        KEYBOARD_CODE["OS_LEFT"] = "OSLeft";
        KEYBOARD_CODE["META_RIGHT"] = "MetaRight";
        KEYBOARD_CODE["OS_RIGHT"] = "OSRight";
        KEYBOARD_CODE["CONTEXT_MENU"] = "ContextMenu";
        KEYBOARD_CODE["POWER"] = "Power";
        KEYBOARD_CODE["BROWSER_SEARCH"] = "BrowserSearch";
        KEYBOARD_CODE["BROWSER_FAVORITES"] = "BrowserFavorites";
        KEYBOARD_CODE["BROWSER_REFRESH"] = "BrowserRefresh";
        KEYBOARD_CODE["BROWSER_STOP"] = "BrowserStop";
        KEYBOARD_CODE["BROWSER_FORWARD"] = "BrowserForward";
        KEYBOARD_CODE["BROWSER_BACK"] = "BrowserBack";
        KEYBOARD_CODE["LAUNCH_APP1"] = "LaunchApp1";
        KEYBOARD_CODE["LAUNCH_MAIL"] = "LaunchMail";
        KEYBOARD_CODE["LAUNCH_MEDIA_PLAYER"] = "LaunchMediaPlayer";
        //mac brings this buttton
        KEYBOARD_CODE["FN"] = "Fn";
        //Linux brings these
        KEYBOARD_CODE["AGAIN"] = "Again";
        KEYBOARD_CODE["PROPS"] = "Props";
        KEYBOARD_CODE["SELECT"] = "Select";
        KEYBOARD_CODE["OPEN"] = "Open";
        KEYBOARD_CODE["FIND"] = "Find";
        KEYBOARD_CODE["WAKE_UP"] = "WakeUp";
        KEYBOARD_CODE["NUMPAD_PARENT_LEFT"] = "NumpadParentLeft";
        KEYBOARD_CODE["NUMPAD_PARENT_RIGHT"] = "NumpadParentRight";
        //android
        KEYBOARD_CODE["SLEEP"] = "Sleep";
    })(KEYBOARD_CODE = FudgeCore.KEYBOARD_CODE || (FudgeCore.KEYBOARD_CODE = {}));
    /*
    Firefox can't make use of those buttons and Combinations:
    SINGELE_BUTTONS:
     Druck,
    COMBINATIONS:
     Shift + F10, Shift + Numpad5,
     CTRL + q, CTRL + F4,
     ALT + F1, ALT + F2, ALT + F3, ALT + F7, ALT + F8, ALT + F10
    Opera won't do good with these Buttons and combinations:
    SINGLE_BUTTONS:
     Float32Array, F11, ALT,
    COMBINATIONS:
     CTRL + q, CTRL + t, CTRL + h, CTRL + g, CTRL + n, CTRL + f
     ALT + F1, ALT + F2, ALT + F4, ALT + F5, ALT + F6, ALT + F7, ALT + F8, ALT + F10
     */
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class EventPointer extends PointerEvent {
        constructor(type, _event) {
            super(type, _event);
            let target = _event.target;
            this.clientRect = target.getClientRects()[0];
            this.pointerX = _event.clientX - this.clientRect.left;
            this.pointerY = _event.clientY - this.clientRect.top;
        }
    }
    FudgeCore.EventPointer = EventPointer;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class EventTimer {
        constructor(_timer, ..._arguments) {
            this.type = "\u0192lapse" /* CALL */;
            this.firstCall = true;
            this.lastCall = false;
            this.target = _timer;
            this.arguments = _arguments;
            this.firstCall = true;
        }
    }
    FudgeCore.EventTimer = EventTimer;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class EventWheel extends WheelEvent {
        constructor(type, _event) {
            super(type, _event);
        }
    }
    FudgeCore.EventWheel = EventWheel;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Baseclass for different kinds of lights.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Light extends FudgeCore.Mutable {
        constructor(_color = new FudgeCore.Color(1, 1, 1, 1)) {
            super();
            this.color = _color;
        }
        getType() {
            return this.constructor;
        }
        reduceMutator() { }
    }
    FudgeCore.Light = Light;
    /**
     * Ambient light, coming from all directions, illuminating everything with its color independent of position and orientation (like a foggy day or in the shades)
     * ```plaintext
     * ~ ~ ~
     *  ~ ~ ~
     * ```
     */
    class LightAmbient extends Light {
        constructor(_color = new FudgeCore.Color(1, 1, 1, 1)) {
            super(_color);
        }
    }
    FudgeCore.LightAmbient = LightAmbient;
    /**
     * Directional light, illuminating everything from a specified direction with its color (like standing in bright sunlight)
     * ```plaintext
     * --->
     * --->
     * --->
     * ```
     */
    class LightDirectional extends Light {
        constructor(_color = new FudgeCore.Color(1, 1, 1, 1)) {
            super(_color);
        }
    }
    FudgeCore.LightDirectional = LightDirectional;
    /**
     * Omnidirectional light emitting from its position, illuminating objects depending on their position and distance with its color (like a colored light bulb)
     * ```plaintext
     *         .\|/.
     *        -- o --
     *         ´/|\`
     * ```
     */
    class LightPoint extends Light {
        constructor() {
            super(...arguments);
            this.range = 10;
        }
    }
    FudgeCore.LightPoint = LightPoint;
    /**
     * Spot light emitting within a specified angle from its position, illuminating objects depending on their position and distance with its color
     * ```plaintext
     *          o
     *         /|\
     *        / | \
     * ```
     */
    class LightSpot extends Light {
    }
    FudgeCore.LightSpot = LightSpot;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Framing describes how to map a rectangle into a given frame
     * and how points in the frame correspond to points in the resulting rectangle
     */
    class Framing extends FudgeCore.Mutable {
        reduceMutator(_mutator) { }
    }
    FudgeCore.Framing = Framing;
    /**
     * The resulting rectangle has a fixed width and height and display should scale to fit the frame
     * Points are scaled in the same ratio
     */
    class FramingFixed extends Framing {
        constructor(_width = 300, _height = 150) {
            super();
            this.width = 300;
            this.height = 150;
            this.setSize(_width, _height);
        }
        setSize(_width, _height) {
            this.width = _width;
            this.height = _height;
        }
        getPoint(_pointInFrame, _rectFrame) {
            let result = new FudgeCore.Vector2(this.width * (_pointInFrame.x - _rectFrame.x) / _rectFrame.width, this.height * (_pointInFrame.y - _rectFrame.y) / _rectFrame.height);
            return result;
        }
        getPointInverse(_point, _rect) {
            let result = new FudgeCore.Vector2(_point.x * _rect.width / this.width + _rect.x, _point.y * _rect.height / this.height + _rect.y);
            return result;
        }
        getRect(_rectFrame) {
            return FudgeCore.Rectangle.GET(0, 0, this.width, this.height);
        }
    }
    FudgeCore.FramingFixed = FramingFixed;
    /**
     * Width and height of the resulting rectangle are fractions of those of the frame, scaled by normed values normWidth and normHeight.
     * Display should scale to fit the frame and points are scaled in the same ratio
     */
    class FramingScaled extends Framing {
        constructor() {
            super(...arguments);
            this.normWidth = 1.0;
            this.normHeight = 1.0;
        }
        setScale(_normWidth, _normHeight) {
            this.normWidth = _normWidth;
            this.normHeight = _normHeight;
        }
        getPoint(_pointInFrame, _rectFrame) {
            let result = new FudgeCore.Vector2(this.normWidth * (_pointInFrame.x - _rectFrame.x), this.normHeight * (_pointInFrame.y - _rectFrame.y));
            return result;
        }
        getPointInverse(_point, _rect) {
            let result = new FudgeCore.Vector2(_point.x / this.normWidth + _rect.x, _point.y / this.normHeight + _rect.y);
            return result;
        }
        getRect(_rectFrame) {
            return FudgeCore.Rectangle.GET(0, 0, this.normWidth * _rectFrame.width, this.normHeight * _rectFrame.height);
        }
    }
    FudgeCore.FramingScaled = FramingScaled;
    /**
     * The resulting rectangle fits into a margin given as fractions of the size of the frame given by normAnchor
     * plus an absolute padding given by pixelBorder. Display should fit into this.
     */
    class FramingComplex extends Framing {
        constructor() {
            super(...arguments);
            this.margin = { left: 0, top: 0, right: 0, bottom: 0 };
            this.padding = { left: 0, top: 0, right: 0, bottom: 0 };
        }
        getPoint(_pointInFrame, _rectFrame) {
            let result = new FudgeCore.Vector2(_pointInFrame.x - this.padding.left - this.margin.left * _rectFrame.width, _pointInFrame.y - this.padding.top - this.margin.top * _rectFrame.height);
            return result;
        }
        getPointInverse(_point, _rect) {
            let result = new FudgeCore.Vector2(_point.x + this.padding.left + this.margin.left * _rect.width, _point.y + this.padding.top + this.margin.top * _rect.height);
            return result;
        }
        getRect(_rectFrame) {
            if (!_rectFrame)
                return null;
            let minX = _rectFrame.x + this.margin.left * _rectFrame.width + this.padding.left;
            let minY = _rectFrame.y + this.margin.top * _rectFrame.height + this.padding.top;
            let maxX = _rectFrame.x + (1 - this.margin.right) * _rectFrame.width - this.padding.right;
            let maxY = _rectFrame.y + (1 - this.margin.bottom) * _rectFrame.height - this.padding.bottom;
            return FudgeCore.Rectangle.GET(minX, minY, maxX - minX, maxY - minY);
        }
        getMutator() {
            return { margin: this.margin, padding: this.padding };
        }
    }
    FudgeCore.FramingComplex = FramingComplex;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Simple class for 3x3 matrix operations
     * @authors Jascha Karagöl, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2020
     */
    class Matrix3x3 extends FudgeCore.Mutable {
        constructor() {
            super();
            this.data = new Float32Array(3); // The data of the matrix.
            this.mutator = null; // prepared for optimization, keep mutator to reduce redundant calculation and for comparison. Set to null when data changes!
            this.data = new Float32Array([
                1, 0, 0,
                0, 1, 0,
                0, 0, 1
            ]);
            this.resetCache();
        }
        /**
         * - get: a copy of the calculated translation vector
         * - set: effect the matrix ignoring its rotation and scaling
         */
        get translation() {
            if (!this.vectors.translation)
                this.vectors.translation = new FudgeCore.Vector2(this.data[6], this.data[7]);
            return this.vectors.translation.copy;
        }
        set translation(_translation) {
            this.data.set(_translation.get(), 12);
            // no full cache reset required
            this.vectors.translation = _translation;
            this.mutator = null;
        }
        /**
         * - get: a copy of the calculated rotation vector
         * - set: effect the matrix
         */
        get rotation() {
            if (!this.vectors.rotation)
                this.vectors.rotation = this.getEulerAngles();
            return this.vectors.rotation;
        }
        set rotation(_rotation) {
            this.mutate({ "rotation": _rotation });
            this.resetCache();
        }
        /**
         * - get: a copy of the calculated scale vector
         * - set: effect the matrix
         */
        get scaling() {
            if (!this.vectors.scaling)
                this.vectors.scaling = new FudgeCore.Vector2(Math.hypot(this.data[0], this.data[1]), Math.hypot(this.data[3], this.data[4]));
            return this.vectors.scaling.copy;
        }
        set scaling(_scaling) {
            this.mutate({ "scaling": _scaling });
            this.resetCache();
        }
        //TODO: figure out what this is used for
        static PROJECTION(_width, _height) {
            let matrix = new Matrix3x3;
            matrix.data.set([
                2 / _width, 0, 0,
                0, -2 / _height, 0,
                -1, 1, 1
            ]);
            return matrix;
        }
        static IDENTITY() {
            const result = FudgeCore.Recycler.get(Matrix3x3);
            result.data.set([
                1, 0, 0,
                0, 1, 0,
                0, 0, 1
            ]);
            return result;
        }
        /**
         * Returns a matrix that translates coordinates along the x-, y- and z-axis according to the given vector.
         */
        static TRANSLATION(_translate) {
            const matrix = FudgeCore.Recycler.get(Matrix3x3);
            matrix.data.set([
                1, 0, 0,
                0, 1, 0,
                _translate.x, _translate.y, 1
            ]);
            return matrix;
        }
        /**
         * Returns a matrix that rotates coordinates on the z-axis when multiplied by.
         * @param _angleInDegrees The value of the rotation.
         */
        static ROTATION(_angleInDegrees) {
            // const matrix: Matrix3x3 = new Matrix3x3;
            const matrix = FudgeCore.Recycler.get(Matrix3x3);
            let angleInRadians = _angleInDegrees * Math.PI / 180;
            let sin = Math.sin(angleInRadians);
            let cos = Math.cos(angleInRadians);
            matrix.data.set([
                cos, sin, 0,
                -sin, cos, 0,
                0, 0, 1
            ]);
            return matrix;
        }
        /**
         * Returns a matrix that scales coordinates along the x-, y- and z-axis according to the given vector
         */
        static SCALING(_scalar) {
            // const matrix: Matrix3x3 = new Matrix3x3;
            const matrix = FudgeCore.Recycler.get(Matrix3x3);
            matrix.data.set([
                _scalar.x, 0, 0,
                0, _scalar.y, 0,
                0, 0, 1
            ]);
            return matrix;
        }
        //#endregion
        static MULTIPLICATION(_a, _b) {
            let a00 = _a.data[0 * 3 + 0];
            let a01 = _a.data[0 * 3 + 1];
            let a02 = _a.data[0 * 3 + 2];
            let a10 = _a.data[1 * 3 + 0];
            let a11 = _a.data[1 * 3 + 1];
            let a12 = _a.data[1 * 3 + 2];
            let a20 = _a.data[2 * 3 + 0];
            let a21 = _a.data[2 * 3 + 1];
            let a22 = _a.data[2 * 3 + 2];
            let b00 = _b.data[0 * 3 + 0];
            let b01 = _b.data[0 * 3 + 1];
            let b02 = _b.data[0 * 3 + 2];
            let b10 = _b.data[1 * 3 + 0];
            let b11 = _b.data[1 * 3 + 1];
            let b12 = _b.data[1 * 3 + 2];
            let b20 = _b.data[2 * 3 + 0];
            let b21 = _b.data[2 * 3 + 1];
            let b22 = _b.data[2 * 3 + 2];
            let matrix = new Matrix3x3;
            matrix.data.set([
                b00 * a00 + b01 * a10 + b02 * a20,
                b00 * a01 + b01 * a11 + b02 * a21,
                b00 * a02 + b01 * a12 + b02 * a22,
                b10 * a00 + b11 * a10 + b12 * a20,
                b10 * a01 + b11 * a11 + b12 * a21,
                b10 * a02 + b11 * a12 + b12 * a22,
                b20 * a00 + b21 * a10 + b22 * a20,
                b20 * a01 + b21 * a11 + b22 * a21,
                b20 * a02 + b21 * a12 + b22 * a22
            ]);
            return matrix;
        }
        //#region Translation
        /**
         * Add a translation by the given vector to this matrix
         */
        translate(_by) {
            const matrix = Matrix3x3.MULTIPLICATION(this, Matrix3x3.TRANSLATION(_by));
            // TODO: possible optimization, translation may alter mutator instead of deleting it.
            this.set(matrix);
            FudgeCore.Recycler.store(matrix);
        }
        /**
         * Add a translation along the x-Axis by the given amount to this matrix
         */
        translateX(_x) {
            this.data[6] += _x;
            this.mutator = null;
            this.vectors.translation = null;
        }
        /**
         * Add a translation along the y-Axis by the given amount to this matrix
         */
        translateY(_y) {
            this.data[7] += _y;
            this.mutator = null;
            this.vectors.translation = null;
        }
        //#endregion
        //#region Scaling
        /**
         * Add a scaling by the given vector to this matrix
         */
        scale(_by) {
            const matrix = Matrix3x3.MULTIPLICATION(this, Matrix3x3.SCALING(_by));
            this.set(matrix);
            FudgeCore.Recycler.store(matrix);
        }
        /**
         * Add a scaling along the x-Axis by the given amount to this matrix
         */
        scaleX(_by) {
            this.scale(new FudgeCore.Vector2(_by, 1));
        }
        /**
         * Add a scaling along the y-Axis by the given amount to this matrix
         */
        scaleY(_by) {
            this.scale(new FudgeCore.Vector2(1, _by));
        }
        //#endregion
        //#region Rotation
        /**
         * Adds a rotation around the z-Axis to this matrix
         */
        rotate(_angleInDegrees) {
            const matrix = Matrix3x3.MULTIPLICATION(this, Matrix3x3.ROTATION(_angleInDegrees));
            this.set(matrix);
            FudgeCore.Recycler.store(matrix);
        }
        //#endregion
        //#region Transformation
        /**
         * Multiply this matrix with the given matrix
         */
        multiply(_matrix) {
            this.set(Matrix3x3.MULTIPLICATION(this, _matrix));
            this.mutator = null;
        }
        //#endregion
        //#region Transfer
        /**
         * Calculates and returns the euler-angles representing the current rotation of this matrix
         */
        getEulerAngles() {
            let scaling = this.scaling;
            let s0 = this.data[0] / scaling.x;
            let s1 = this.data[1] / scaling.x;
            let s3 = this.data[3] / scaling.y;
            let s4 = this.data[4] / scaling.y;
            let xSkew = Math.atan2(-s3, s4);
            let ySkew = Math.atan2(s0, s1);
            let sy = Math.hypot(s0, s1); // probably 2. param should be this.data[4] / scaling.y
            let rotation;
            if (!(sy > 1e-6))
                rotation = ySkew;
            else
                rotation = xSkew;
            rotation *= 180 / Math.PI;
            return rotation;
        }
        /**
         * Sets the elements of this matrix to the values of the given matrix
         */
        set(_to) {
            // this.data = _to.get();
            this.data.set(_to.data);
            this.resetCache();
        }
        toString() {
            return `ƒ.Matrix3x3(translation: ${this.translation.toString()}, rotation: ${this.rotation.toString()}, scaling: ${this.scaling.toString()}`;
        }
        /**
         * Return the elements of this matrix as a Float32Array
         */
        get() {
            return new Float32Array(this.data);
        }
        serialize() {
            // TODO: save translation, rotation and scale as vectors for readability and manipulation
            let serialization = this.getMutator();
            return serialization;
        }
        deserialize(_serialization) {
            this.mutate(_serialization);
            return this;
        }
        getMutator() {
            if (this.mutator)
                return this.mutator;
            let mutator = {
                translation: this.translation.getMutator(),
                rotation: this.rotation,
                scaling: this.scaling.getMutator()
            };
            // cache mutator
            this.mutator = mutator;
            return mutator;
        }
        mutate(_mutator) {
            let oldTranslation = this.translation;
            let oldRotation = this.rotation;
            let oldScaling = this.scaling;
            let newTranslation = _mutator["translation"];
            let newRotation = _mutator["rotation"];
            let newScaling = _mutator["scaling"];
            let vectors = { translation: oldTranslation, rotation: oldRotation, scaling: oldScaling };
            if (newTranslation) {
                vectors.translation = new FudgeCore.Vector2(newTranslation.x != undefined ? newTranslation.x : oldTranslation.x, newTranslation.y != undefined ? newTranslation.y : oldTranslation.y);
            }
            vectors.rotation = (newRotation == undefined) ? oldRotation : newRotation;
            if (newScaling) {
                vectors.scaling = new FudgeCore.Vector2(newScaling.x != undefined ? newScaling.x : oldScaling.x, newScaling.y != undefined ? newScaling.y : oldScaling.y);
            }
            // TODO: possible performance optimization when only one or two components change, then use old matrix instead of IDENTITY and transform by differences/quotients
            let matrix = Matrix3x3.IDENTITY();
            if (vectors.translation)
                matrix.translate(vectors.translation);
            if (vectors.rotation) {
                matrix.rotate(vectors.rotation);
            }
            if (vectors.scaling)
                matrix.scale(vectors.scaling);
            this.set(matrix);
            this.vectors = vectors;
        }
        getMutatorAttributeTypes(_mutator) {
            let types = {};
            if (_mutator.translation)
                types.translation = "Vector2";
            if (_mutator.rotation)
                types.rotation = "number";
            if (_mutator.scaling)
                types.scaling = "Vector2";
            return types;
        }
        reduceMutator(_mutator) { }
        resetCache() {
            this.vectors = { translation: null, rotation: null, scaling: null };
            this.mutator = null;
        }
    }
    FudgeCore.Matrix3x3 = Matrix3x3;
    //#endregion
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Stores a 4x4 transformation matrix and provides operations for it.
     * ```plaintext
     * [ 0, 1, 2, 3 ] ← row vector x
     * [ 4, 5, 6, 7 ] ← row vector y
     * [ 8, 9,10,11 ] ← row vector z
     * [12,13,14,15 ] ← translation
     *            ↑  homogeneous column
     * ```
     * @authors Jascha Karagöl, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Matrix4x4 extends FudgeCore.Mutable {
        constructor() {
            super();
            this.data = new Float32Array(16); // The data of the matrix.
            this.mutator = null; // prepared for optimization, keep mutator to reduce redundant calculation and for comparison. Set to null when data changes!
            this.data.set([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]);
            this.resetCache();
        }
        /**
         * - get: a copy of the calculated translation vector
         * - set: effect the matrix ignoring its rotation and scaling
         */
        get translation() {
            if (!this.vectors.translation)
                this.vectors.translation = new FudgeCore.Vector3(this.data[12], this.data[13], this.data[14]);
            return this.vectors.translation.copy;
        }
        set translation(_translation) {
            this.data.set(_translation.get(), 12);
            // no full cache reset required
            this.vectors.translation = _translation.copy;
            this.mutator = null;
        }
        /**
         * - get: a copy of the calculated rotation vector
         * - set: effect the matrix
         */
        get rotation() {
            if (!this.vectors.rotation)
                this.vectors.rotation = this.getEulerAngles();
            return this.vectors.rotation.copy;
        }
        set rotation(_rotation) {
            this.mutate({ "rotation": _rotation });
            this.resetCache();
        }
        /**
         * - get: a copy of the calculated scale vector
         * - set: effect the matrix
         */
        get scaling() {
            if (!this.vectors.scaling)
                this.vectors.scaling = new FudgeCore.Vector3(Math.hypot(this.data[0], this.data[1], this.data[2]), Math.hypot(this.data[4], this.data[5], this.data[6]), Math.hypot(this.data[8], this.data[9], this.data[10]));
            return this.vectors.scaling.copy;
        }
        set scaling(_scaling) {
            this.mutate({ "scaling": _scaling });
            this.resetCache();
        }
        //#region STATICS
        /**
         * Retrieve a new identity matrix
         */
        static IDENTITY() {
            // const result: Matrix4x4 = new Matrix4x4();
            const result = FudgeCore.Recycler.get(Matrix4x4);
            result.data.set([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]);
            return result;
        }
        /**
         * Computes and returns the product of two passed matrices.
         * @param _a The matrix to multiply.
         * @param _b The matrix to multiply by.
         */
        static MULTIPLICATION(_a, _b) {
            let a = _a.data;
            let b = _b.data;
            // let matrix: Matrix4x4 = new Matrix4x4();
            const matrix = FudgeCore.Recycler.get(Matrix4x4);
            let a00 = a[0 * 4 + 0];
            let a01 = a[0 * 4 + 1];
            let a02 = a[0 * 4 + 2];
            let a03 = a[0 * 4 + 3];
            let a10 = a[1 * 4 + 0];
            let a11 = a[1 * 4 + 1];
            let a12 = a[1 * 4 + 2];
            let a13 = a[1 * 4 + 3];
            let a20 = a[2 * 4 + 0];
            let a21 = a[2 * 4 + 1];
            let a22 = a[2 * 4 + 2];
            let a23 = a[2 * 4 + 3];
            let a30 = a[3 * 4 + 0];
            let a31 = a[3 * 4 + 1];
            let a32 = a[3 * 4 + 2];
            let a33 = a[3 * 4 + 3];
            let b00 = b[0 * 4 + 0];
            let b01 = b[0 * 4 + 1];
            let b02 = b[0 * 4 + 2];
            let b03 = b[0 * 4 + 3];
            let b10 = b[1 * 4 + 0];
            let b11 = b[1 * 4 + 1];
            let b12 = b[1 * 4 + 2];
            let b13 = b[1 * 4 + 3];
            let b20 = b[2 * 4 + 0];
            let b21 = b[2 * 4 + 1];
            let b22 = b[2 * 4 + 2];
            let b23 = b[2 * 4 + 3];
            let b30 = b[3 * 4 + 0];
            let b31 = b[3 * 4 + 1];
            let b32 = b[3 * 4 + 2];
            let b33 = b[3 * 4 + 3];
            matrix.data.set([
                b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30,
                b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31,
                b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32,
                b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33,
                b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30,
                b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31,
                b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32,
                b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33,
                b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30,
                b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31,
                b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32,
                b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33,
                b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30,
                b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31,
                b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32,
                b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33
            ]);
            return matrix;
        }
        /**
         * Computes and returns the inverse of a passed matrix.
         * @param _matrix The matrix to compute the inverse of.
         */
        static INVERSION(_matrix) {
            let m = _matrix.data;
            let m00 = m[0 * 4 + 0];
            let m01 = m[0 * 4 + 1];
            let m02 = m[0 * 4 + 2];
            let m03 = m[0 * 4 + 3];
            let m10 = m[1 * 4 + 0];
            let m11 = m[1 * 4 + 1];
            let m12 = m[1 * 4 + 2];
            let m13 = m[1 * 4 + 3];
            let m20 = m[2 * 4 + 0];
            let m21 = m[2 * 4 + 1];
            let m22 = m[2 * 4 + 2];
            let m23 = m[2 * 4 + 3];
            let m30 = m[3 * 4 + 0];
            let m31 = m[3 * 4 + 1];
            let m32 = m[3 * 4 + 2];
            let m33 = m[3 * 4 + 3];
            let tmp0 = m22 * m33;
            let tmp1 = m32 * m23;
            let tmp2 = m12 * m33;
            let tmp3 = m32 * m13;
            let tmp4 = m12 * m23;
            let tmp5 = m22 * m13;
            let tmp6 = m02 * m33;
            let tmp7 = m32 * m03;
            let tmp8 = m02 * m23;
            let tmp9 = m22 * m03;
            let tmp10 = m02 * m13;
            let tmp11 = m12 * m03;
            let tmp12 = m20 * m31;
            let tmp13 = m30 * m21;
            let tmp14 = m10 * m31;
            let tmp15 = m30 * m11;
            let tmp16 = m10 * m21;
            let tmp17 = m20 * m11;
            let tmp18 = m00 * m31;
            let tmp19 = m30 * m01;
            let tmp20 = m00 * m21;
            let tmp21 = m20 * m01;
            let tmp22 = m00 * m11;
            let tmp23 = m10 * m01;
            let t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) -
                (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);
            let t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) -
                (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);
            let t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) -
                (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);
            let t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) -
                (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);
            let d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);
            // let matrix: Matrix4x4 = new Matrix4x4;
            const matrix = FudgeCore.Recycler.get(Matrix4x4);
            matrix.data.set([
                d * t0,
                d * t1,
                d * t2,
                d * t3,
                d * ((tmp1 * m10 + tmp2 * m20 + tmp5 * m30) - (tmp0 * m10 + tmp3 * m20 + tmp4 * m30)),
                d * ((tmp0 * m00 + tmp7 * m20 + tmp8 * m30) - (tmp1 * m00 + tmp6 * m20 + tmp9 * m30)),
                d * ((tmp3 * m00 + tmp6 * m10 + tmp11 * m30) - (tmp2 * m00 + tmp7 * m10 + tmp10 * m30)),
                d * ((tmp4 * m00 + tmp9 * m10 + tmp10 * m20) - (tmp5 * m00 + tmp8 * m10 + tmp11 * m20)),
                d * ((tmp12 * m13 + tmp15 * m23 + tmp16 * m33) - (tmp13 * m13 + tmp14 * m23 + tmp17 * m33)),
                d * ((tmp13 * m03 + tmp18 * m23 + tmp21 * m33) - (tmp12 * m03 + tmp19 * m23 + tmp20 * m33)),
                d * ((tmp14 * m03 + tmp19 * m13 + tmp22 * m33) - (tmp15 * m03 + tmp18 * m13 + tmp23 * m33)),
                d * ((tmp17 * m03 + tmp20 * m13 + tmp23 * m23) - (tmp16 * m03 + tmp21 * m13 + tmp22 * m23)),
                d * ((tmp14 * m22 + tmp17 * m32 + tmp13 * m12) - (tmp16 * m32 + tmp12 * m12 + tmp15 * m22)),
                d * ((tmp20 * m32 + tmp12 * m02 + tmp19 * m22) - (tmp18 * m22 + tmp21 * m32 + tmp13 * m02)),
                d * ((tmp18 * m12 + tmp23 * m32 + tmp15 * m02) - (tmp22 * m32 + tmp14 * m02 + tmp19 * m12)),
                d * ((tmp22 * m22 + tmp16 * m02 + tmp21 * m12) - (tmp20 * m12 + tmp23 * m22 + tmp17 * m02)) // [15]
            ]);
            return matrix;
        }
        /**
         * Computes and returns a rotationmatrix that aligns a transformations z-axis with the vector between it and its target.
         * @param _transformPosition The x,y and z-coordinates of the object to rotate.
         * @param _targetPosition The position to look at.
         */
        static LOOK_AT(_transformPosition, _targetPosition, _up = FudgeCore.Vector3.Y()) {
            // const matrix: Matrix4x4 = new Matrix4x4;
            const matrix = FudgeCore.Recycler.get(Matrix4x4);
            let zAxis = FudgeCore.Vector3.DIFFERENCE(_targetPosition, _transformPosition);
            zAxis.normalize();
            let xAxis = FudgeCore.Vector3.NORMALIZATION(FudgeCore.Vector3.CROSS(_up, zAxis));
            let yAxis = FudgeCore.Vector3.NORMALIZATION(FudgeCore.Vector3.CROSS(zAxis, xAxis));
            matrix.data.set([
                xAxis.x, xAxis.y, xAxis.z, 0,
                yAxis.x, yAxis.y, yAxis.z, 0,
                zAxis.x, zAxis.y, zAxis.z, 0,
                _transformPosition.x,
                _transformPosition.y,
                _transformPosition.z,
                1
            ]);
            return matrix;
        }
        /**
         * Returns a matrix that translates coordinates along the x-, y- and z-axis according to the given vector.
         */
        static TRANSLATION(_translate) {
            // let matrix: Matrix4x4 = new Matrix4x4;
            const matrix = FudgeCore.Recycler.get(Matrix4x4);
            matrix.data.set([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                _translate.x, _translate.y, _translate.z, 1
            ]);
            return matrix;
        }
        /**
         * Returns a matrix that rotates coordinates on the x-axis when multiplied by.
         * @param _angleInDegrees The value of the rotation.
         */
        static ROTATION_X(_angleInDegrees) {
            // const matrix: Matrix4x4 = new Matrix4x4;
            const matrix = FudgeCore.Recycler.get(Matrix4x4);
            let angleInRadians = _angleInDegrees * Math.PI / 180;
            let sin = Math.sin(angleInRadians);
            let cos = Math.cos(angleInRadians);
            matrix.data.set([
                1, 0, 0, 0,
                0, cos, sin, 0,
                0, -sin, cos, 0,
                0, 0, 0, 1
            ]);
            return matrix;
        }
        /**
         * Returns a matrix that rotates coordinates on the y-axis when multiplied by.
         * @param _angleInDegrees The value of the rotation.
         */
        static ROTATION_Y(_angleInDegrees) {
            // const matrix: Matrix4x4 = new Matrix4x4;
            let matrix = FudgeCore.Recycler.get(Matrix4x4);
            let angleInRadians = _angleInDegrees * Math.PI / 180;
            let sin = Math.sin(angleInRadians);
            let cos = Math.cos(angleInRadians);
            matrix.data.set([
                cos, 0, -sin, 0,
                0, 1, 0, 0,
                sin, 0, cos, 0,
                0, 0, 0, 1
            ]);
            return matrix;
        }
        /**
         * Returns a matrix that rotates coordinates on the z-axis when multiplied by.
         * @param _angleInDegrees The value of the rotation.
         */
        static ROTATION_Z(_angleInDegrees) {
            // const matrix: Matrix4x4 = new Matrix4x4;
            const matrix = FudgeCore.Recycler.get(Matrix4x4);
            let angleInRadians = _angleInDegrees * Math.PI / 180;
            let sin = Math.sin(angleInRadians);
            let cos = Math.cos(angleInRadians);
            matrix.data.set([
                cos, sin, 0, 0,
                -sin, cos, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]);
            return matrix;
        }
        /**
         * Returns a matrix that scales coordinates along the x-, y- and z-axis according to the given vector
         */
        static SCALING(_scalar) {
            // const matrix: Matrix4x4 = new Matrix4x4;
            const matrix = FudgeCore.Recycler.get(Matrix4x4);
            matrix.data.set([
                _scalar.x, 0, 0, 0,
                0, _scalar.y, 0, 0,
                0, 0, _scalar.z, 0,
                0, 0, 0, 1
            ]);
            return matrix;
        }
        //#endregion
        //#region PROJECTIONS
        /**
         * Computes and returns a matrix that applies perspective to an object, if its transform is multiplied by it.
         * @param _aspect The aspect ratio between width and height of projectionspace.(Default = canvas.clientWidth / canvas.ClientHeight)
         * @param _fieldOfViewInDegrees The field of view in Degrees. (Default = 45)
         * @param _near The near clipspace border on the z-axis.
         * @param _far The far clipspace border on the z-axis.
         * @param _direction The plane on which the fieldOfView-Angle is given
         */
        static PROJECTION_CENTRAL(_aspect, _fieldOfViewInDegrees, _near, _far, _direction) {
            //TODO: camera looks down negative z-direction, should be positive
            let fieldOfViewInRadians = _fieldOfViewInDegrees * Math.PI / 180;
            let f = Math.tan(0.5 * (Math.PI - fieldOfViewInRadians));
            let rangeInv = 1.0 / (_near - _far);
            // const matrix: Matrix4x4 = new Matrix4x4;
            const matrix = FudgeCore.Recycler.get(Matrix4x4);
            matrix.data.set([
                f, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (_near + _far) * rangeInv, -1,
                0, 0, _near * _far * rangeInv * 2, 0
            ]);
            if (_direction == FudgeCore.FIELD_OF_VIEW.DIAGONAL) {
                _aspect = Math.sqrt(_aspect);
                matrix.data[0] = f / _aspect;
                matrix.data[5] = f * _aspect;
            }
            else if (_direction == FudgeCore.FIELD_OF_VIEW.VERTICAL)
                matrix.data[0] = f / _aspect;
            else //FOV_DIRECTION.HORIZONTAL
                matrix.data[5] = f * _aspect;
            // HACK: matrix should look in positive z-direction, preferably the matrix should be calculated like that right away
            matrix.rotateY(180);
            return matrix;
        }
        /**
         * Computes and returns a matrix that applies orthographic projection to an object, if its transform is multiplied by it.
         * @param _left The positionvalue of the projectionspace's left border.
         * @param _right The positionvalue of the projectionspace's right border.
         * @param _bottom The positionvalue of the projectionspace's bottom border.
         * @param _top The positionvalue of the projectionspace's top border.
         * @param _near The positionvalue of the projectionspace's near border.
         * @param _far The positionvalue of the projectionspace's far border
         */
        static PROJECTION_ORTHOGRAPHIC(_left, _right, _bottom, _top, _near = -400, _far = 400) {
            // const matrix: Matrix4x4 = new Matrix4x4;
            const matrix = FudgeCore.Recycler.get(Matrix4x4);
            matrix.data.set([
                2 / (_right - _left), 0, 0, 0,
                0, 2 / (_top - _bottom), 0, 0,
                0, 0, 2 / (_near - _far), 0,
                (_left + _right) / (_left - _right),
                (_bottom + _top) / (_bottom - _top),
                (_near + _far) / (_near - _far),
                1
            ]);
            return matrix;
        }
        //#endregion
        //#region Rotation
        /**
         * Rotate this matrix by given vector in the order Z, Y, X. Right hand rotation is used, thumb points in axis direction, fingers curling indicate rotation
         * @param _by
         */
        rotate(_by, _fromLeft = false) {
            this.rotateZ(_by.z, _fromLeft);
            this.rotateY(_by.y, _fromLeft);
            this.rotateX(_by.x, _fromLeft);
        }
        /**
         * Adds a rotation around the x-Axis to this matrix
         */
        rotateX(_angleInDegrees, _fromLeft = false) {
            let rotation = Matrix4x4.ROTATION_X(_angleInDegrees);
            this.multiply(rotation, _fromLeft);
            FudgeCore.Recycler.store(rotation);
        }
        /**
         * Adds a rotation around the y-Axis to this matrix
         */
        rotateY(_angleInDegrees, _fromLeft = false) {
            let rotation = Matrix4x4.ROTATION_Y(_angleInDegrees);
            this.multiply(rotation, _fromLeft);
            FudgeCore.Recycler.store(rotation);
        }
        /**
         * Adds a rotation around the z-Axis to this matrix
         */
        rotateZ(_angleInDegrees, _fromLeft = false) {
            let rotation = Matrix4x4.ROTATION_Z(_angleInDegrees);
            this.multiply(rotation, _fromLeft);
            FudgeCore.Recycler.store(rotation);
        }
        /**
         * Adjusts the rotation of this matrix to face the given target and tilts it to accord with the given up vector
         */
        lookAt(_target, _up = FudgeCore.Vector3.Y()) {
            const matrix = Matrix4x4.LOOK_AT(this.translation, _target); // TODO: Handle rotation around z-axis
            this.set(matrix);
            FudgeCore.Recycler.store(matrix);
        }
        //#endregion
        //#region Translation
        /**
         * Add a translation by the given vector to this matrix
         */
        translate(_by) {
            const matrix = Matrix4x4.MULTIPLICATION(this, Matrix4x4.TRANSLATION(_by));
            // TODO: possible optimization, translation may alter mutator instead of deleting it.
            this.set(matrix);
            FudgeCore.Recycler.store(matrix);
        }
        /**
         * Add a translation along the x-Axis by the given amount to this matrix
         */
        translateX(_x) {
            this.data[12] += _x;
            this.mutator = null;
            this.vectors.translation = null;
        }
        /**
         * Add a translation along the y-Axis by the given amount to this matrix
         */
        translateY(_y) {
            this.data[13] += _y;
            this.mutator = null;
            this.vectors.translation = null;
        }
        /**
         * Add a translation along the y-Axis by the given amount to this matrix
         */
        translateZ(_z) {
            this.data[14] += _z;
            this.mutator = null;
            this.vectors.translation = null;
        }
        //#endregion
        //#region Scaling
        /**
         * Add a scaling by the given vector to this matrix
         */
        scale(_by) {
            const matrix = Matrix4x4.MULTIPLICATION(this, Matrix4x4.SCALING(_by));
            this.set(matrix);
            FudgeCore.Recycler.store(matrix);
        }
        /**
         * Add a scaling along the x-Axis by the given amount to this matrix
         */
        scaleX(_by) {
            this.scale(new FudgeCore.Vector3(_by, 1, 1));
        }
        /**
         * Add a scaling along the y-Axis by the given amount to this matrix
         */
        scaleY(_by) {
            this.scale(new FudgeCore.Vector3(1, _by, 1));
        }
        /**
         * Add a scaling along the z-Axis by the given amount to this matrix
         */
        scaleZ(_by) {
            this.scale(new FudgeCore.Vector3(1, 1, _by));
        }
        //#endregion
        //#region Transformation
        /**
         * Multiply this matrix with the given matrix
         */
        multiply(_matrix, _fromLeft = false) {
            const matrix = _fromLeft ? Matrix4x4.MULTIPLICATION(_matrix, this) : Matrix4x4.MULTIPLICATION(this, _matrix);
            this.set(matrix);
            FudgeCore.Recycler.store(matrix);
        }
        //#endregion
        //#region Transfer
        /**
         * Calculates and returns the euler-angles representing the current rotation of this matrix
         */
        getEulerAngles() {
            let scaling = this.scaling;
            let s0 = this.data[0] / scaling.x;
            let s1 = this.data[1] / scaling.x;
            let s2 = this.data[2] / scaling.x;
            let s6 = this.data[6] / scaling.y;
            let s10 = this.data[10] / scaling.z;
            let sy = Math.hypot(s0, s1); // probably 2. param should be this.data[4] / scaling.y
            let singular = sy < 1e-6; // If
            let x1, y1, z1;
            let x2, y2, z2;
            if (!singular) {
                x1 = Math.atan2(s6, s10);
                y1 = Math.atan2(-s2, sy);
                z1 = Math.atan2(s1, s0);
                x2 = Math.atan2(-s6, -s10);
                y2 = Math.atan2(-s2, -sy);
                z2 = Math.atan2(-s1, -s0);
                if (Math.abs(x2) + Math.abs(y2) + Math.abs(z2) < Math.abs(x1) + Math.abs(y1) + Math.abs(z1)) {
                    x1 = x2;
                    y1 = y2;
                    z1 = z2;
                }
            }
            else {
                x1 = Math.atan2(-this.data[9] / scaling.z, this.data[5] / scaling.y);
                y1 = Math.atan2(-this.data[2] / scaling.x, sy);
                z1 = 0;
            }
            let rotation = new FudgeCore.Vector3(x1, y1, z1);
            rotation.scale(180 / Math.PI);
            return rotation;
        }
        /**
         * Sets the elements of this matrix to the values of the given matrix
         */
        set(_to) {
            // this.data = _to.get();
            this.data.set(_to.data);
            this.resetCache();
        }
        toString() {
            return `ƒ.Matrix4x4(translation: ${this.translation.toString()}, rotation: ${this.rotation.toString()}, scaling: ${this.scaling.toString()}`;
        }
        /**
         * Return the elements of this matrix as a Float32Array
         */
        get() {
            return new Float32Array(this.data);
        }
        serialize() {
            // TODO: save translation, rotation and scale as vectors for readability and manipulation
            let serialization = this.getMutator();
            return serialization;
        }
        deserialize(_serialization) {
            this.mutate(_serialization);
            return this;
        }
        getMutator() {
            if (this.mutator)
                return this.mutator;
            let mutator = {
                translation: this.translation.getMutator(),
                rotation: this.rotation.getMutator(),
                scaling: this.scaling.getMutator()
            };
            // cache mutator
            this.mutator = mutator;
            return mutator;
        }
        mutate(_mutator) {
            let oldTranslation = this.translation;
            let oldRotation = this.rotation;
            let oldScaling = this.scaling;
            let newTranslation = _mutator["translation"];
            let newRotation = _mutator["rotation"];
            let newScaling = _mutator["scaling"];
            let vectors = { translation: oldTranslation, rotation: oldRotation, scaling: oldScaling };
            if (newTranslation) {
                vectors.translation = new FudgeCore.Vector3(newTranslation.x != undefined ? newTranslation.x : oldTranslation.x, newTranslation.y != undefined ? newTranslation.y : oldTranslation.y, newTranslation.z != undefined ? newTranslation.z : oldTranslation.z);
            }
            if (newRotation) {
                vectors.rotation = new FudgeCore.Vector3(newRotation.x != undefined ? newRotation.x : oldRotation.x, newRotation.y != undefined ? newRotation.y : oldRotation.y, newRotation.z != undefined ? newRotation.z : oldRotation.z);
            }
            if (newScaling) {
                vectors.scaling = new FudgeCore.Vector3(newScaling.x != undefined ? newScaling.x : oldScaling.x, newScaling.y != undefined ? newScaling.y : oldScaling.y, newScaling.z != undefined ? newScaling.z : oldScaling.z);
            }
            // TODO: possible performance optimization when only one or two components change, then use old matrix instead of IDENTITY and transform by differences/quotients
            let matrix = Matrix4x4.IDENTITY();
            if (vectors.translation)
                matrix.translate(vectors.translation);
            if (vectors.rotation) {
                matrix.rotateZ(vectors.rotation.z);
                matrix.rotateY(vectors.rotation.y);
                matrix.rotateX(vectors.rotation.x);
            }
            if (vectors.scaling)
                matrix.scale(vectors.scaling);
            this.set(matrix);
            this.vectors = vectors;
        }
        getMutatorAttributeTypes(_mutator) {
            let types = {};
            if (_mutator.translation)
                types.translation = "Vector3";
            if (_mutator.rotation)
                types.rotation = "Vector3";
            if (_mutator.scaling)
                types.scaling = "Vector3";
            return types;
        }
        reduceMutator(_mutator) { }
        resetCache() {
            this.vectors = { translation: null, rotation: null, scaling: null };
            this.mutator = null;
        }
    }
    FudgeCore.Matrix4x4 = Matrix4x4;
    //#endregion
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Class for creating random values, supporting Javascript's Math.random and a deterministig pseudo-random number generator (PRNG)
     * that can be fed with a seed and then returns a reproducable set of random numbers (if the precision of Javascript allows)
     *
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Random {
        /**
         * Create an instance of [[Random]]. If desired, creates a PRNG with it and feeds the given seed.
         * @param _ownGenerator
         * @param _seed
         */
        constructor(_ownGenerator = false, _seed = Math.random()) {
            this.generate = Math.random;
            if (_ownGenerator)
                this.generate = Random.createGenerator(_seed);
        }
        /**
         * Creates a dererminstic PRNG with the given seed
         */
        static createGenerator(_seed) {
            // TODO: replace with random number generator to generate predictable sequence
            return Math.random;
        }
        /**
         * Returns a normed random number, thus in the range of [0, 1[
         */
        getNorm() {
            return this.generate();
        }
        /**
         * Returns a random number in the range of given [_min, _max[
         */
        getRange(_min, _max) {
            return _min + this.generate() * (_max - _min);
        }
        /**
         * Returns a random integer number in the range of given floored [_min, _max[
         */
        getRangeFloored(_min, _max) {
            return Math.floor(this.getRange(_min, _max));
        }
        /**
         * Returns true or false randomly
         */
        getBoolean() {
            return this.generate() < 0.5;
        }
        /**
         * Returns -1 or 1 randomly
         */
        getSign() {
            return this.getBoolean() ? 1 : -1;
        }
        /**
         * Returns a randomly selected index into the given array
         */
        getIndex(_array) {
            if (_array.length > 0)
                return this.getRangeFloored(0, _array.length);
            return -1;
        }
        /**
         * Returns removes a randomly selected element from the given array and returns it
         */
        splice(_array) {
            return _array.splice(this.getIndex(_array), 1)[0];
        }
        /**
         * Returns a randomly selected key from the given Map-instance
         */
        getKey(_map) {
            let keys = Array.from(_map.keys());
            return keys[this.getIndex(keys)];
        }
        /**
         * Returns a randomly selected property name from the given object
         */
        getPropertyName(_object) {
            let keys = Object.getOwnPropertyNames(_object);
            return keys[this.getIndex(keys)];
        }
        /**
         * Returns a randomly selected symbol from the given object, if symbols are used as keys
         */
        getPropertySymbol(_object) {
            let keys = Object.getOwnPropertySymbols(_object);
            return keys[this.getIndex(keys)];
        }
    }
    Random.default = new Random();
    FudgeCore.Random = Random;
    /**
     * Standard [[Random]]-instance using Math.random().
     */
    FudgeCore.random = new Random();
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Defines the origin of a rectangle
     */
    let ORIGIN2D;
    (function (ORIGIN2D) {
        ORIGIN2D[ORIGIN2D["TOPLEFT"] = 0] = "TOPLEFT";
        ORIGIN2D[ORIGIN2D["TOPCENTER"] = 1] = "TOPCENTER";
        ORIGIN2D[ORIGIN2D["TOPRIGHT"] = 2] = "TOPRIGHT";
        ORIGIN2D[ORIGIN2D["CENTERLEFT"] = 16] = "CENTERLEFT";
        ORIGIN2D[ORIGIN2D["CENTER"] = 17] = "CENTER";
        ORIGIN2D[ORIGIN2D["CENTERRIGHT"] = 18] = "CENTERRIGHT";
        ORIGIN2D[ORIGIN2D["BOTTOMLEFT"] = 32] = "BOTTOMLEFT";
        ORIGIN2D[ORIGIN2D["BOTTOMCENTER"] = 33] = "BOTTOMCENTER";
        ORIGIN2D[ORIGIN2D["BOTTOMRIGHT"] = 34] = "BOTTOMRIGHT";
    })(ORIGIN2D = FudgeCore.ORIGIN2D || (FudgeCore.ORIGIN2D = {}));
    /**
     * Defines a rectangle with position and size and add comfortable methods to it
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Rectangle extends FudgeCore.Mutable {
        constructor(_x = 0, _y = 0, _width = 1, _height = 1, _origin = ORIGIN2D.TOPLEFT) {
            super();
            this.position = FudgeCore.Recycler.get(FudgeCore.Vector2);
            this.size = FudgeCore.Recycler.get(FudgeCore.Vector2);
            this.setPositionAndSize(_x, _y, _width, _height, _origin);
        }
        /**
         * Returns a new rectangle created with the given parameters
         */
        static GET(_x = 0, _y = 0, _width = 1, _height = 1, _origin = ORIGIN2D.TOPLEFT) {
            let rect = FudgeCore.Recycler.get(Rectangle);
            rect.setPositionAndSize(_x, _y, _width, _height);
            return rect;
        }
        /**
         * Sets the position and size of the rectangle according to the given parameters
         */
        setPositionAndSize(_x = 0, _y = 0, _width = 1, _height = 1, _origin = ORIGIN2D.TOPLEFT) {
            this.size.set(_width, _height);
            switch (_origin & 0x03) {
                case 0x00:
                    this.position.x = _x;
                    break;
                case 0x01:
                    this.position.x = _x - _width / 2;
                    break;
                case 0x02:
                    this.position.x = _x - _width;
                    break;
            }
            switch (_origin & 0x30) {
                case 0x00:
                    this.position.y = _y;
                    break;
                case 0x10:
                    this.position.y = _y - _height / 2;
                    break;
                case 0x20:
                    this.position.y = _y - _height;
                    break;
            }
        }
        pointToRect(_point, _target) {
            let result = _point.copy;
            result.subtract(this.position);
            result.x *= _target.width / this.width;
            result.y *= _target.height / this.height;
            result.add(_target.position);
            return result;
        }
        get x() {
            return this.position.x;
        }
        get y() {
            return this.position.y;
        }
        get width() {
            return this.size.x;
        }
        get height() {
            return this.size.y;
        }
        /**
         * Return the leftmost expansion, respecting also negative values of width
         */
        get left() {
            if (this.size.x > 0)
                return this.position.x;
            return (this.position.x + this.size.x);
        }
        /**
         * Return the topmost expansion, respecting also negative values of height
         */
        get top() {
            if (this.size.y > 0)
                return this.position.y;
            return (this.position.y + this.size.y);
        }
        /**
         * Return the rightmost expansion, respecting also negative values of width
         */
        get right() {
            if (this.size.x > 0)
                return (this.position.x + this.size.x);
            return this.position.x;
        }
        /**
         * Return the lowest expansion, respecting also negative values of height
         */
        get bottom() {
            if (this.size.y > 0)
                return (this.position.y + this.size.y);
            return this.position.y;
        }
        set x(_x) {
            this.position.x = _x;
        }
        set y(_y) {
            this.position.y = _y;
        }
        set width(_width) {
            this.position.x = _width;
        }
        set height(_height) {
            this.position.y = _height;
        }
        set left(_value) {
            this.size.x = this.right - _value;
            this.position.x = _value;
        }
        set top(_value) {
            this.size.y = this.bottom - _value;
            this.position.y = _value;
        }
        set right(_value) {
            this.size.x = this.position.x + _value;
        }
        set bottom(_value) {
            this.size.y = this.position.y + _value;
        }
        get copy() {
            return Rectangle.GET(this.x, this.y, this.width, this.height);
        }
        /**
         * Returns true if the given point is inside of this rectangle or on the border
         * @param _point
         */
        isInside(_point) {
            return (_point.x >= this.left && _point.x <= this.right && _point.y >= this.top && _point.y <= this.bottom);
        }
        collides(_rect) {
            if (this.left > _rect.right)
                return false;
            if (this.right < _rect.left)
                return false;
            if (this.top > _rect.bottom)
                return false;
            if (this.bottom < _rect.top)
                return false;
            return true;
        }
        toString() {
            let result = `ƒ.Rectangle(position:${this.position.toString()}, size:${this.size.toString()}`;
            result += `, left:${this.left.toPrecision(5)}, top:${this.top.toPrecision(5)}, right:${this.right.toPrecision(5)}, bottom:${this.bottom.toPrecision(5)}`;
            return result;
        }
        reduceMutator(_mutator) { }
    }
    FudgeCore.Rectangle = Rectangle;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Stores and manipulates a twodimensional vector comprised of the components x and y
     * ```plaintext
     *            +y
     *             |__ +x
     * ```
     * @authors Lukas Scheuerle, Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Vector2 extends FudgeCore.Mutable {
        constructor(_x = 0, _y = 0) {
            super();
            this.data = new Float32Array([_x, _y]);
        }
        get x() {
            return this.data[0];
        }
        get y() {
            return this.data[1];
        }
        set x(_x) {
            this.data[0] = _x;
        }
        set y(_y) {
            this.data[1] = _y;
        }
        /**
         * Returns the length of the vector
         */
        get magnitude() {
            return Math.hypot(...this.data);
        }
        /**
         * Returns the square of the magnitude of the vector without calculating a square root. Faster for simple proximity evaluation.
         */
        get magnitudeSquared() {
            return Vector2.DOT(this, this);
        }
        /**
         * A shorthand for writing `new Vector2(0, 0)`.
         * @returns A new vector with the values (0, 0)
         */
        static ZERO() {
            let vector = new Vector2();
            return vector;
        }
        /**
         * A shorthand for writing `new Vector2(_scale, _scale)`.
         * @param _scale the scale of the vector. Default: 1
         */
        static ONE(_scale = 1) {
            let vector = new Vector2(_scale, _scale);
            return vector;
        }
        /**
         * A shorthand for writing `new Vector2(0, y)`.
         * @param _scale The number to write in the y coordinate. Default: 1
         * @returns A new vector with the values (0, _scale)
         */
        static Y(_scale = 1) {
            let vector = new Vector2(0, _scale);
            return vector;
        }
        /**
         * A shorthand for writing `new Vector2(x, 0)`.
         * @param _scale The number to write in the x coordinate. Default: 1
         * @returns A new vector with the values (_scale, 0)
         */
        static X(_scale = 1) {
            let vector = new Vector2(_scale, 0);
            return vector;
        }
        static TRANSFORMATION(_vector, _matrix, _includeTranslation = true) {
            let result = new Vector2();
            let m = _matrix.get();
            let [x, y] = _vector.get();
            result.x = m[0] * x + m[3] * y;
            result.y = m[1] * x + m[4] * y;
            if (_includeTranslation) {
                result.add(_matrix.translation);
            }
            return result;
        }
        /**
         * Normalizes a given vector to the given length without editing the original vector.
         * @param _vector the vector to normalize
         * @param _length the length of the resulting vector. defaults to 1
         * @returns a new vector representing the normalised vector scaled by the given length
         */
        static NORMALIZATION(_vector, _length = 1) {
            let vector = Vector2.ZERO();
            try {
                let [x, y] = _vector.data;
                let factor = _length / Math.hypot(x, y);
                vector.data = new Float32Array([_vector.x * factor, _vector.y * factor]);
            }
            catch (_error) {
                FudgeCore.Debug.fudge(_error);
            }
            return vector;
        }
        /**
         * Scales a given vector by a given scale without changing the original vector
         * @param _vector The vector to scale.
         * @param _scale The scale to scale with.
         * @returns A new vector representing the scaled version of the given vector
         */
        static SCALE(_vector, _scale) {
            let vector = new Vector2(_vector.x * _scale, _vector.y * _scale);
            return vector;
        }
        /**
         * Sums up multiple vectors.
         * @param _vectors A series of vectors to sum up
         * @returns A new vector representing the sum of the given vectors
         */
        static SUM(..._vectors) {
            let result = new Vector2();
            for (let vector of _vectors)
                result.data = new Float32Array([result.x + vector.x, result.y + vector.y]);
            return result;
        }
        /**
         * Subtracts two vectors.
         * @param _a The vector to subtract from.
         * @param _b The vector to subtract.
         * @returns A new vector representing the difference of the given vectors
         */
        static DIFFERENCE(_a, _b) {
            let vector = new Vector2;
            vector.data = new Float32Array([_a.x - _b.x, _a.y - _b.y]);
            return vector;
        }
        /**
         * Computes the dotproduct of 2 vectors.
         * @param _a The vector to multiply.
         * @param _b The vector to multiply by.
         * @returns A new vector representing the dotproduct of the given vectors
         */
        static DOT(_a, _b) {
            let scalarProduct = _a.x * _b.x + _a.y * _b.y;
            return scalarProduct;
        }
        /**
         * Calculates the cross product of two Vectors. Due to them being only 2 Dimensional, the result is a single number,
         * which implicitly is on the Z axis. It is also the signed magnitude of the result.
         * @param _a Vector to compute the cross product on
         * @param _b Vector to compute the cross product with
         * @returns A number representing result of the cross product.
         */
        static CROSSPRODUCT(_a, _b) {
            let crossProduct = _a.x * _b.y - _a.y * _b.x;
            return crossProduct;
        }
        /**
         * Calculates the orthogonal vector to the given vector. Rotates counterclockwise by default.
         * ```plaintext
         * ↑ => ← => ↓ => → => ↑
         * ```
         * @param _vector Vector to get the orthogonal equivalent of
         * @param _clockwise Should the rotation be clockwise instead of the default counterclockwise? default: false
         * @returns A Vector that is orthogonal to and has the same magnitude as the given Vector.
         */
        static ORTHOGONAL(_vector, _clockwise = false) {
            if (_clockwise)
                return new Vector2(_vector.y, -_vector.x);
            else
                return new Vector2(-_vector.y, _vector.x);
        }
        /**
         * Returns true if the coordinates of this and the given vector are to be considered identical within the given tolerance
         * TODO: examine, if tolerance as criterium for the difference is appropriate with very large coordinate values or if _tolerance should be multiplied by coordinate value
         */
        equals(_compare, _tolerance = Number.EPSILON) {
            if (Math.abs(this.x - _compare.x) > _tolerance)
                return false;
            if (Math.abs(this.y - _compare.y) > _tolerance)
                return false;
            return true;
        }
        /**
         * Adds the given vector to the executing vector, changing the executor.
         * @param _addend The vector to add.
         */
        add(_addend) {
            this.data = new Vector2(_addend.x + this.x, _addend.y + this.y).data;
        }
        /**
         * Subtracts the given vector from the executing vector, changing the executor.
         * @param _subtrahend The vector to subtract.
         */
        subtract(_subtrahend) {
            this.data = new Vector2(this.x - _subtrahend.x, this.y - _subtrahend.y).data;
        }
        /**
         * Scales the Vector by the _scale.
         * @param _scale The scale to multiply the vector with.
         */
        scale(_scale) {
            this.data = new Vector2(_scale * this.x, _scale * this.y).data;
        }
        /**
         * Normalizes the vector.
         * @param _length A modificator to get a different length of normalized vector.
         */
        normalize(_length = 1) {
            this.data = Vector2.NORMALIZATION(this, _length).data;
        }
        /**
         * Sets the Vector to the given parameters. Ommitted parameters default to 0.
         * @param _x new x to set
         * @param _y new y to set
         */
        set(_x = 0, _y = 0) {
            this.data = new Float32Array([_x, _y]);
        }
        /**
         * @returns An array of the data of the vector
         */
        get() {
            return new Float32Array(this.data);
        }
        /**
         * @returns A deep copy of the vector.
         */
        get copy() {
            return new Vector2(this.x, this.y);
        }
        transform(_matrix, _includeTranslation = true) {
            this.data = Vector2.TRANSFORMATION(this, _matrix, _includeTranslation).data;
        }
        /**
         * Adds a z-component to the vector and returns a new Vector3
         */
        toVector3() {
            return new FudgeCore.Vector3(this.x, this.y, 0);
        }
        toString() {
            let result = `(${this.x.toPrecision(5)}, ${this.y.toPrecision(5)})`;
            return result;
        }
        getMutator() {
            let mutator = {
                x: this.data[0], y: this.data[1]
            };
            return mutator;
        }
        reduceMutator(_mutator) { }
    }
    FudgeCore.Vector2 = Vector2;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Stores and manipulates a threedimensional vector comprised of the components x, y and z
     * ```plaintext
     *            +y
     *             |__ +x
     *            /
     *          +z
     * ```
     * @authors Jascha Karagöl, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Vector3 extends FudgeCore.Mutable {
        constructor(_x = 0, _y = 0, _z = 0) {
            super();
            this.data = new Float32Array([_x, _y, _z]);
        }
        // TODO: implement equals-functions
        get x() {
            return this.data[0];
        }
        get y() {
            return this.data[1];
        }
        get z() {
            return this.data[2];
        }
        set x(_x) {
            this.data[0] = _x;
        }
        set y(_y) {
            this.data[1] = _y;
        }
        set z(_z) {
            this.data[2] = _z;
        }
        /**
         * Returns the length of the vector
         */
        get magnitude() {
            return Math.hypot(...this.data);
        }
        /**
         * Returns the square of the magnitude of the vector without calculating a square root. Faster for simple proximity evaluation.
         */
        get magnitudeSquared() {
            return Vector3.DOT(this, this);
        }
        /**
         * Creates and returns a vector with the given length pointing in x-direction
         */
        static X(_scale = 1) {
            const vector = new Vector3(_scale, 0, 0);
            return vector;
        }
        /**
         * Creates and returns a vector with the given length pointing in y-direction
         */
        static Y(_scale = 1) {
            const vector = new Vector3(0, _scale, 0);
            return vector;
        }
        /**
         * Creates and returns a vector with the given length pointing in z-direction
         */
        static Z(_scale = 1) {
            const vector = new Vector3(0, 0, _scale);
            return vector;
        }
        /**
         * Creates and returns a vector with the value 0 on each axis
         */
        static ZERO() {
            const vector = new Vector3(0, 0, 0);
            return vector;
        }
        /**
         * Creates and returns a vector of the given size on each of the three axis
         */
        static ONE(_scale = 1) {
            const vector = new Vector3(_scale, _scale, _scale);
            return vector;
        }
        /**
         * Creates and returns a vector through transformation of the given vector by the given matrix
         */
        static TRANSFORMATION(_vector, _matrix, _includeTranslation = true) {
            let result = new Vector3();
            let m = _matrix.get();
            let [x, y, z] = _vector.get();
            result.x = m[0] * x + m[4] * y + m[8] * z;
            result.y = m[1] * x + m[5] * y + m[9] * z;
            result.z = m[2] * x + m[6] * y + m[10] * z;
            if (_includeTranslation) {
                result.add(_matrix.translation);
            }
            return result;
        }
        /**
         * Creates and returns a vector which is a copy of the given vector scaled to the given length
         */
        static NORMALIZATION(_vector, _length = 1) {
            let vector = Vector3.ZERO();
            try {
                let factor = _length / _vector.magnitude;
                vector.data = new Float32Array([_vector.x * factor, _vector.y * factor, _vector.z * factor]);
            }
            catch (_error) {
                FudgeCore.Debug.warn(_error);
            }
            return vector;
        }
        /**
         * Sums up multiple vectors.
         * @param _vectors A series of vectors to sum up
         * @returns A new vector representing the sum of the given vectors
         */
        static SUM(..._vectors) {
            let result = new Vector3();
            for (let vector of _vectors)
                result.data = new Float32Array([result.x + vector.x, result.y + vector.y, result.z + vector.z]);
            return result;
        }
        /**
         * Subtracts two vectors.
         * @param _a The vector to subtract from.
         * @param _b The vector to subtract.
         * @returns A new vector representing the difference of the given vectors
         */
        static DIFFERENCE(_a, _b) {
            let vector = new Vector3;
            vector.data = new Float32Array([_a.x - _b.x, _a.y - _b.y, _a.z - _b.z]);
            return vector;
        }
        /**
         * Returns a new vector representing the given vector scaled by the given scaling factor
         */
        static SCALE(_vector, _scaling) {
            let scaled = new Vector3();
            scaled.data = new Float32Array([_vector.x * _scaling, _vector.y * _scaling, _vector.z * _scaling]);
            return scaled;
        }
        /**
         * Computes the crossproduct of 2 vectors.
         * @param _a The vector to multiply.
         * @param _b The vector to multiply by.
         * @returns A new vector representing the crossproduct of the given vectors
         */
        static CROSS(_a, _b) {
            let vector = new Vector3;
            vector.data = new Float32Array([
                _a.y * _b.z - _a.z * _b.y,
                _a.z * _b.x - _a.x * _b.z,
                _a.x * _b.y - _a.y * _b.x
            ]);
            return vector;
        }
        /**
         * Computes the dotproduct of 2 vectors.
         * @param _a The vector to multiply.
         * @param _b The vector to multiply by.
         * @returns A new vector representing the dotproduct of the given vectors
         */
        static DOT(_a, _b) {
            let scalarProduct = _a.x * _b.x + _a.y * _b.y + _a.z * _b.z;
            return scalarProduct;
        }
        /**
         * Calculates and returns the reflection of the incoming vector at the given normal vector. The length of normal should be 1.
         *     __________________
         *           /|\
         * incoming / | \ reflection
         *         /  |  \
         *          normal
         *
         */
        static REFLECTION(_incoming, _normal) {
            let dot = -Vector3.DOT(_incoming, _normal);
            let reflection = Vector3.SUM(_incoming, Vector3.SCALE(_normal, 2 * dot));
            return reflection;
        }
        /**
         * Returns true if the coordinates of this and the given vector are to be considered identical within the given tolerance
         * TODO: examine, if tolerance as criterium for the difference is appropriate with very large coordinate values or if _tolerance should be multiplied by coordinate value
         */
        equals(_compare, _tolerance = Number.EPSILON) {
            if (Math.abs(this.x - _compare.x) > _tolerance)
                return false;
            if (Math.abs(this.y - _compare.y) > _tolerance)
                return false;
            if (Math.abs(this.z - _compare.z) > _tolerance)
                return false;
            return true;
        }
        add(_addend) {
            this.data = new Vector3(_addend.x + this.x, _addend.y + this.y, _addend.z + this.z).data;
        }
        subtract(_subtrahend) {
            this.data = new Vector3(this.x - _subtrahend.x, this.y - _subtrahend.y, this.z - _subtrahend.z).data;
        }
        scale(_scale) {
            this.data = new Vector3(_scale * this.x, _scale * this.y, _scale * this.z).data;
        }
        normalize(_length = 1) {
            this.data = Vector3.NORMALIZATION(this, _length).data;
        }
        set(_x = 0, _y = 0, _z = 0) {
            this.data = new Float32Array([_x, _y, _z]);
        }
        get() {
            return new Float32Array(this.data);
        }
        get copy() {
            return new Vector3(this.x, this.y, this.z);
        }
        transform(_matrix, _includeTranslation = true) {
            this.data = Vector3.TRANSFORMATION(this, _matrix, _includeTranslation).data;
        }
        /**
         * Drops the z-component and returns a Vector2 consisting of the x- and y-components
         */
        toVector2() {
            return new FudgeCore.Vector2(this.x, this.y);
        }
        reflect(_normal) {
            const reflected = Vector3.REFLECTION(this, _normal);
            this.set(reflected.x, reflected.y, reflected.z);
            FudgeCore.Recycler.store(reflected);
        }
        toString() {
            let result = `(${this.x.toPrecision(5)}, ${this.y.toPrecision(5)}, ${this.z.toPrecision(5)})`;
            return result;
        }
        map(_function) {
            let copy = FudgeCore.Recycler.get(Vector3);
            copy.data = this.data.map(_function);
            return copy;
        }
        getMutator() {
            let mutator = {
                x: this.data[0], y: this.data[1], z: this.data[2]
            };
            return mutator;
        }
        reduceMutator(_mutator) { }
    }
    FudgeCore.Vector3 = Vector3;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    var Mesh_1;
    /**
     * Abstract base class for all meshes.
     * Meshes provide indexed vertices, the order of indices to create trigons and normals, and texture coordinates
     *
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    let Mesh = Mesh_1 = class Mesh {
        constructor() {
            this.idResource = undefined;
        }
        static getBufferSpecification() {
            return { size: 3, dataType: WebGL2RenderingContext.FLOAT, normalize: false, stride: 0, offset: 0 };
        }
        static registerSubclass(_subclass) { return Mesh_1.subclasses.push(_subclass) - 1; }
        useRenderBuffers(_renderShader, _world, _projection, _id) { }
        createRenderBuffers(_renderShader) { }
        deleteRenderBuffers(_renderShader) { }
        getVertexCount() {
            return this.vertices.length / Mesh_1.getBufferSpecification().size;
        }
        getIndexCount() {
            return this.indices.length;
        }
        // Serialize/Deserialize for all meshes that calculate without parameters
        serialize() {
            let serialization = {
                idResource: this.idResource
            }; // no data needed ...
            return serialization;
        }
        deserialize(_serialization) {
            this.create(); // TODO: must not be created, if an identical mesh already exists
            this.idResource = _serialization.idResource;
            return this;
        }
        calculateFaceNormals() {
            let normals = [];
            let vertices = [];
            for (let v = 0; v < this.vertices.length; v += 3)
                vertices.push(new FudgeCore.Vector3(this.vertices[v], this.vertices[v + 1], this.vertices[v + 2]));
            for (let i = 0; i < this.indices.length; i += 3) {
                let vertex = [this.indices[i], this.indices[i + 1], this.indices[i + 2]];
                let v0 = FudgeCore.Vector3.DIFFERENCE(vertices[vertex[0]], vertices[vertex[1]]);
                let v1 = FudgeCore.Vector3.DIFFERENCE(vertices[vertex[0]], vertices[vertex[2]]);
                let normal = FudgeCore.Vector3.NORMALIZATION(FudgeCore.Vector3.CROSS(v0, v1));
                let index = vertex[2] * 3;
                normals[index] = normal.x;
                normals[index + 1] = normal.y;
                normals[index + 2] = normal.z;
            }
            return new Float32Array(normals);
        }
    };
    Mesh.subclasses = [];
    Mesh = Mesh_1 = __decorate([
        FudgeCore.RenderInjectorMesh.decorate
    ], Mesh);
    FudgeCore.Mesh = Mesh;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a simple cube with edges of length 1, each face consisting of two trigons
     * ```plaintext
     *            4____7
     *           0/__3/|
     *            ||5_||6
     *           1|/_2|/
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class MeshCube extends FudgeCore.Mesh {
        constructor() {
            super();
            this.create();
        }
        create() {
            this.vertices = this.createVertices();
            this.indices = this.createIndices();
            this.textureUVs = this.createTextureUVs();
            this.normalsFace = this.createFaceNormals();
        }
        createVertices() {
            let vertices = new Float32Array([
                // First wrap
                // front
                /*0*/ -1, 1, 1, /*1*/ -1, -1, 1, /*2*/ 1, -1, 1, /*3*/ 1, 1, 1,
                // back
                /*4*/ -1, 1, -1, /* 5*/ -1, -1, -1, /* 6*/ 1, -1, -1, /* 7*/ 1, 1, -1,
                // Second wrap
                // front
                /*0*/ -1, 1, 1, /*1*/ -1, -1, 1, /*2*/ 1, -1, 1, /*3*/ 1, 1, 1,
                // back
                /*4*/ -1, 1, -1, /* 5*/ -1, -1, -1, /* 6*/ 1, -1, -1, /* 7*/ 1, 1, -1
            ]);
            // scale down to a length of 1 for all edges
            vertices = vertices.map(_value => _value / 2);
            return vertices;
        }
        createIndices() {
            let indices = new Uint16Array([
                // First wrap
                // front
                1, 2, 0, 2, 3, 0,
                // right
                2, 6, 3, 6, 7, 3,
                // back
                6, 5, 7, 5, 4, 7,
                // Second wrap
                // left
                5 + 8, 1 + 8, 4 + 8, 1 + 8, 0 + 8, 4 + 8,
                // top
                4 + 8, 0 + 8, 3 + 8, 7 + 8, 4 + 8, 3 + 8,
                // bottom
                5 + 8, 6 + 8, 1 + 8, 6 + 8, 2 + 8, 1 + 8
                /*,
                // left
                4, 5, 1, 4, 1, 0,
                // top
                4, 0, 3, 4, 3, 7,
                // bottom
                1, 5, 6, 1, 6, 2
                */
            ]);
            return indices;
        }
        createTextureUVs() {
            let textureUVs = new Float32Array([
                // First wrap
                // front
                /*0*/ 0, 0, /*1*/ 0, 1, /*2*/ 1, 1, /*3*/ 1, 0,
                // back
                /*4*/ 3, 0, /*5*/ 3, 1, /*6*/ 2, 1, /*7*/ 2, 0,
                // Second wrap
                // front
                /*0*/ 1, 0, /*1*/ 1, 1, /*2*/ 1, 2, /*3*/ 1, -1,
                // back
                /*4*/ 0, 0, /*5*/ 0, 1, /*6*/ 0, 2, /*7*/ 0, -1
            ]);
            return textureUVs;
        }
        createFaceNormals() {
            let normals = new Float32Array([
                // for each triangle, the last vertex of the three defining refers to the normalvector when using flat shading
                // First wrap
                // front
                /*0*/ 0, 0, 1, /*1*/ 0, 0, 0, /*2*/ 0, 0, 0, /*3*/ 1, 0, 0,
                // back
                /*4*/ 0, 0, 0, /*5*/ 0, 0, 0, /*6*/ 0, 0, 0, /*7*/ 0, 0, -1,
                // Second wrap
                // front
                /*0*/ 0, 0, 0, /*1*/ 0, -1, 0, /*2*/ 0, 0, 0, /*3*/ 0, 1, 0,
                // back
                /*4*/ -1, 0, 0, /*5*/ 0, 0, 0, /*6*/ 0, 0, 0, /*7*/ 0, 0, 0
            ]);
            //normals = this.createVertices();
            return normals;
        }
    }
    MeshCube.iSubclass = FudgeCore.Mesh.registerSubclass(MeshCube);
    FudgeCore.MeshCube = MeshCube;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generates a planar Grid and applies a Heightmap-Function to it.
     * @authors Jirka Dell'Oro-Friedl, Simon Storl-Schulke, HFU, 2020
     */
    class MeshHeightMap extends FudgeCore.Mesh {
        constructor(_resolutionX = 16, _resolutionZ = 16, _heightMapFunction) {
            super();
            this.resolutionX = _resolutionX;
            this.resolutionZ = _resolutionZ;
            if (_resolutionZ || _resolutionX <= 0) {
                FudgeCore.Debug.warn("HeightMap Mesh cannot have resolution values < 1. ");
                this.resolutionX = Math.max(1, this.resolutionX);
                this.resolutionZ = Math.max(1, this.resolutionZ);
            }
            if (_heightMapFunction)
                this.heightMapFunction = _heightMapFunction;
            else
                this.heightMapFunction = function (_x, _y) { return 0; };
            this.create();
        }
        create() {
            this.vertices = this.createVertices();
            this.indices = this.createIndices();
            this.textureUVs = this.createTextureUVs();
            this.normalsFace = this.createFaceNormals();
        }
        createVertices() {
            let vertices = new Float32Array((this.resolutionX + 1) * (this.resolutionZ + 1) * 3);
            //Iterate over each cell to generate grid of vertices
            for (let i = 0, z = 0; z <= this.resolutionZ; z++) {
                for (let x = 0; x <= this.resolutionX; x++) {
                    // X
                    vertices[i] = x / this.resolutionX - 0.5;
                    // Apply heightmap to y coordinate
                    vertices[i + 1] = this.heightMapFunction(x / this.resolutionX, z / this.resolutionZ);
                    // Z
                    vertices[i + 2] = z / this.resolutionZ - 0.5;
                    i += 3;
                }
            }
            return vertices;
        }
        createIndices() {
            let vert = 0;
            let tris = 0;
            let indices = new Uint16Array(this.resolutionX * this.resolutionZ * 6);
            for (let z = 0; z < this.resolutionZ; z++) {
                for (let x = 0; x < this.resolutionX; x++) {
                    // First triangle of each grid-cell
                    indices[tris + 0] = vert + 0;
                    indices[tris + 1] = vert + this.resolutionX + 1;
                    indices[tris + 2] = vert + 1;
                    // Second triangle of each grid-cell
                    indices[tris + 3] = vert + 1;
                    indices[tris + 4] = vert + this.resolutionX + 1;
                    indices[tris + 5] = vert + this.resolutionX + 2;
                    vert++;
                    tris += 6;
                }
                vert++;
            }
            return indices;
        }
        createTextureUVs() {
            let textureUVs = new Float32Array(this.indices.length * 2);
            for (let i = 0, z = 0; z <= this.resolutionZ; z++) {
                for (let x = 0; x <= this.resolutionX; x++) {
                    textureUVs[i] = x / this.resolutionX;
                    textureUVs[i + 1] = z / this.resolutionZ;
                    i += 2;
                }
            }
            return textureUVs;
        }
        createFaceNormals() {
            return this.calculateFaceNormals();
        }
    }
    MeshHeightMap.iSubclass = FudgeCore.Mesh.registerSubclass(MeshHeightMap);
    FudgeCore.MeshHeightMap = MeshHeightMap;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a simple pyramid with edges at the base of length 1 and a height of 1. The sides consisting of one, the base of two trigons
     * ```plaintext
     *               4
     *              /\`.
     *            3/__\_\ 2
     *           0/____\/1
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class MeshPyramid extends FudgeCore.Mesh {
        constructor() {
            super();
            this.create();
        }
        create() {
            this.vertices = this.createVertices();
            this.indices = this.createIndices();
            this.textureUVs = this.createTextureUVs();
            this.normalsFace = this.createFaceNormals();
        }
        createVertices() {
            let vertices = new Float32Array([
                // floor
                /*0*/ -1, 0, 1, /*1*/ 1, 0, 1, /*2*/ 1, 0, -1, /*3*/ -1, 0, -1,
                // tip
                /*4*/ 0, 2, 0,
                // floor again for texturing and normals
                /*5*/ -1, 0, 1, /*6*/ 1, 0, 1, /*7*/ 1, 0, -1, /*8*/ -1, 0, -1
            ]);
            // scale down to a length of 1 for bottom edges and height
            vertices = vertices.map(_value => _value / 2);
            return vertices;
        }
        createIndices() {
            let indices = new Uint16Array([
                // front
                4, 0, 1,
                // right
                4, 1, 2,
                // back
                4, 2, 3,
                // left
                4, 3, 0,
                // bottom
                5 + 0, 5 + 2, 5 + 1, 5 + 0, 5 + 3, 5 + 2
            ]);
            return indices;
        }
        createTextureUVs() {
            let textureUVs = new Float32Array([
                // front
                /*0*/ 0, 1, /*1*/ 0.5, 1, /*2*/ 1, 1, /*3*/ 0.5, 1,
                // back
                /*4*/ 0.5, 0,
                /*5*/ 0, 0, /*6*/ 1, 0, /*7*/ 1, 1, /*8*/ 0, 1
            ]);
            return textureUVs;
        }
        createFaceNormals() {
            return new Float32Array(this.calculateFaceNormals());
        }
    }
    MeshPyramid.iSubclass = FudgeCore.Mesh.registerSubclass(MeshPyramid);
    FudgeCore.MeshPyramid = MeshPyramid;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a simple quad with edges of length 1, the face consisting of two trigons
     * ```plaintext
     *        0 __ 3
     *         |__|
     *        1    2
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class MeshQuad extends FudgeCore.Mesh {
        constructor() {
            super();
            this.create();
        }
        create() {
            this.vertices = this.createVertices();
            this.indices = this.createIndices();
            this.textureUVs = this.createTextureUVs();
            this.normalsFace = this.createFaceNormals();
        }
        createVertices() {
            let vertices = new Float32Array([
                /*0*/ -1, 1, 0, /*1*/ -1, -1, 0, /*2*/ 1, -1, 0, /*3*/ 1, 1, 0
            ]);
            vertices = vertices.map(_value => _value / 2);
            return vertices;
        }
        createIndices() {
            let indices = new Uint16Array([
                1, 2, 0, 2, 3, 0
            ]);
            return indices;
        }
        createTextureUVs() {
            let textureUVs = new Float32Array([
                // front
                /*0*/ 0, 0, /*1*/ 0, 1, /*2*/ 1, 1, /*3*/ 1, 0
            ]);
            return textureUVs;
        }
        createFaceNormals() {
            return new Float32Array([
                /*0*/ 0, 0, 1, /*1*/ 0, 0, 0, /*2*/ 0, 0, 0, /*3*/ 0, 0, 0
            ]);
        }
    }
    MeshQuad.iSubclass = FudgeCore.Mesh.registerSubclass(MeshQuad);
    FudgeCore.MeshQuad = MeshQuad;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a UV Sphere with a given number of sectors and stacks (clamped at 128*128)
     * Implementation based on http://www.songho.ca/opengl/gl_sphere.html
     * @authors Simon Storl-Schulke, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2020
     */
    class MeshSphere extends FudgeCore.Mesh {
        // Dirty Workaround to have access to the normals from createVertices()
        // private normals: Array<number> = [];
        // private textureUVs: Array<number> = [];
        // public textureUVs: Float32Array;
        constructor(_sectors = 12, _stacks = 8) {
            super();
            //Clamp resolution to prevent performance issues
            this.sectors = Math.min(_sectors, 128);
            this.stacks = Math.min(_stacks, 128);
            if (_sectors < 3 || _stacks < 2) {
                FudgeCore.Debug.warn("UV Sphere must have at least 3 sectors and 2 stacks to form a 3-dimensional shape.");
                this.sectors = Math.max(3, _sectors);
                this.stacks = Math.max(2, _stacks);
            }
            this.create();
        }
        create() {
            let vertices = [];
            let normals = [];
            let textureUVs = [];
            let x;
            let z;
            let xz;
            let y;
            let sectorStep = 2 * Math.PI / this.sectors;
            let stackStep = Math.PI / this.stacks;
            let stackAngle;
            let sectorAngle;
            /* add (sectorCount+1) vertices per stack.
            the first and last vertices have same position and normal,
            but different tex coords */
            for (let i = 0; i <= this.stacks; ++i) {
                stackAngle = Math.PI / 2 - i * stackStep;
                xz = Math.cos(stackAngle);
                y = Math.sin(stackAngle);
                // add (sectorCount+1) vertices per stack
                // the first and last vertices have same position and normal, but different tex coords
                for (let j = 0; j <= this.sectors; ++j) {
                    sectorAngle = j * sectorStep;
                    //vertex position
                    x = xz * Math.cos(sectorAngle);
                    z = xz * Math.sin(sectorAngle);
                    vertices.push(x, y, z);
                    //normals
                    normals.push(x, y, z);
                    //UV Coords
                    textureUVs.push(j / this.sectors * -1);
                    textureUVs.push(i / this.stacks);
                }
            }
            // scale down
            vertices = vertices.map(_value => _value / 2);
            this.textureUVs = new Float32Array(textureUVs);
            this.normals = new Float32Array(normals);
            this.vertices = new Float32Array(vertices);
            this.normalsFace = this.createFaceNormals();
            this.indices = this.createIndices();
        }
        createIndices() {
            let inds = [];
            let k1;
            let k2;
            for (let i = 0; i < this.stacks; ++i) {
                k1 = i * (this.sectors + 1); // beginning of current stack
                k2 = k1 + this.sectors + 1; // beginning of next stack
                for (let j = 0; j < this.sectors; ++j, ++k1, ++k2) {
                    // 2 triangles per sector excluding first and last stacks
                    // k1 => k2 => k1+1
                    if (i != 0) {
                        inds.push(k1);
                        inds.push(k1 + 1);
                        inds.push(k2);
                    }
                    if (i != (this.stacks - 1)) {
                        inds.push(k1 + 1);
                        inds.push(k2 + 1);
                        inds.push(k2);
                    }
                }
            }
            let indices = new Uint16Array(inds);
            return indices;
        }
        createVertices() {
            return this.vertices;
        }
        createTextureUVs() {
            return this.textureUVs;
        }
        //TODO: we also need REAL face normals
        createFaceNormals() {
            return this.normals;
        }
    }
    MeshSphere.iSubclass = FudgeCore.Mesh.registerSubclass(MeshSphere);
    FudgeCore.MeshSphere = MeshSphere;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate two quads placed back to back, the one facing in negative Z-direction is textured reversed
     * ```plaintext
     *        0 __ 3
     *         |__|
     *        1    2
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2020
     */
    class MeshSprite extends FudgeCore.Mesh {
        constructor() {
            super();
            this.create();
        }
        create() {
            this.vertices = this.createVertices();
            this.indices = this.createIndices();
            this.textureUVs = this.createTextureUVs();
            this.normalsFace = this.createFaceNormals();
        }
        createVertices() {
            let vertices = new Float32Array([
                /*0*/ -1, 1, 0, /*1*/ -1, -1, 0, /*2*/ 1, -1, 0, /*3*/ 1, 1, 0
            ]);
            vertices = vertices.map(_value => _value / 2);
            return vertices;
        }
        createIndices() {
            let indices = new Uint16Array([
                1, 2, 0, 2, 3, 0,
                0, 3, 1, 3, 2, 1 //back
            ]);
            return indices;
        }
        createTextureUVs() {
            let textureUVs = new Float32Array([
                // front
                /*0*/ 0, 0, /*1*/ 0, 1, /*2*/ 1, 1, /*3*/ 1, 0
            ]);
            return textureUVs;
        }
        createFaceNormals() {
            return new Float32Array([
                /*0: normal of front face*/
                0, 0, 1,
                /*1: normal of back face*/
                0, 0, -1,
                /*2*/
                0, 0, 0,
                /*3*/
                0, 0, 0
            ]);
        }
    }
    MeshSprite.iSubclass = FudgeCore.Mesh.registerSubclass(MeshSprite);
    FudgeCore.MeshSprite = MeshSprite;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Represents a node in the scenetree.
     * @authors Jascha Karagöl, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Node extends FudgeCore.EventTargetƒ {
        /**
         * Creates a new node with a name and initializes all attributes
         * @param _name The name by which the node can be called.
         */
        constructor(_name) {
            super();
            this.mtxWorld = FudgeCore.Matrix4x4.IDENTITY();
            this.timestampUpdate = 0;
            this.parent = null; // The parent of this node.
            this.children = []; // array of child nodes appended to this node.
            this.components = {};
            // private tags: string[] = []; // Names of tags that are attached to this node. (TODO: As of yet no functionality)
            // private layers: string[] = []; // Names of the layers this node is on. (TODO: As of yet no functionality)
            this.listeners = {};
            this.captures = {};
            this.active = true;
            /**
             * Simply calls [[addChild]]. This reference is here solely because appendChild is the equivalent method in DOM.
             * See and preferably use [[addChild]]
             */
            // tslint:disable-next-line: member-ordering
            this.appendChild = this.addChild;
            this.name = _name;
        }
        activate(_on) {
            this.active = _on;
            this.dispatchEvent(new Event(_on ? "componentActivate" /* COMPONENT_ACTIVATE */ : "componentDeactivate" /* COMPONENT_DEACTIVATE */));
        }
        get isActive() {
            return this.active;
        }
        /**
         * Returns a reference to this nodes parent node
         */
        getParent() {
            return this.parent;
        }
        /**
         * Traces back the ancestors of this node and returns the first
         */
        getAncestor() {
            let ancestor = this;
            while (ancestor.getParent())
                ancestor = ancestor.getParent();
            return ancestor;
        }
        /**
         * Shortcut to retrieve this nodes [[ComponentTransform]]
         */
        get cmpTransform() {
            return this.getComponents(FudgeCore.ComponentTransform)[0];
        }
        /**
         * Shortcut to retrieve the local [[Matrix4x4]] attached to this nodes [[ComponentTransform]]
         * Returns null if no [[ComponentTransform]] is attached
         */
        // TODO: rejected for now, since there is some computational overhead, so node.mtxLocal should not be used carelessly
        // public get mtxLocal(): Matrix4x4 {
        //     let cmpTransform: ComponentTransform = this.cmpTransform;
        //     if (cmpTransform)
        //         return cmpTransform.local;
        //     else
        //         return null;
        // }
        // #region Scenetree
        /**
         * Returns a clone of the list of children
         */
        getChildren() {
            return this.children.slice(0);
        }
        /**
         * Returns an array of references to childnodes with the supplied name.
         * @param _name The name of the nodes to be found.
         * @return An array with references to nodes
         */
        getChildrenByName(_name) {
            let found = [];
            found = this.children.filter((_node) => _node.name == _name);
            return found;
        }
        /**
         * Adds the given reference to a node to the list of children, if not already in
         * @param _node The node to be added as a child
         * @throws Error when trying to add an ancestor of this
         */
        addChild(_node) {
            if (this.children.includes(_node))
                // _node is already a child of this
                return;
            let inAudioBranch = false;
            let branchListened = FudgeCore.AudioManager.default.getBranchListeningTo();
            let ancestor = this;
            while (ancestor) {
                ancestor.timestampUpdate = 0;
                inAudioBranch = inAudioBranch || (ancestor == branchListened);
                if (ancestor == _node)
                    throw (new Error("Cyclic reference prohibited in node hierarchy, ancestors must not be added as children"));
                else
                    ancestor = ancestor.parent;
            }
            let previousParent = _node.parent;
            if (previousParent)
                previousParent.removeChild(_node);
            this.children.push(_node);
            _node.parent = this;
            _node.dispatchEvent(new Event("childAppend" /* CHILD_APPEND */, { bubbles: true }));
            if (inAudioBranch)
                _node.broadcastEvent(new Event("childAppendToAudioBranch" /* CHILD_APPEND */));
        }
        /**
         * Removes the reference to the give node from the list of children
         * @param _node The node to be removed.
         */
        removeChild(_node) {
            let found = this.findChild(_node);
            if (found < 0)
                return;
            _node.dispatchEvent(new Event("childRemove" /* CHILD_REMOVE */, { bubbles: true }));
            if (this.isDescendantOf(FudgeCore.AudioManager.default.getBranchListeningTo()))
                _node.broadcastEvent(new Event("childRemoveFromAudioBranch" /* CHILD_REMOVE */));
            this.children.splice(found, 1);
            _node.parent = null;
        }
        /**
         * Returns the position of the node in the list of children or -1 if not found
         * @param _node The node to be found.
         */
        findChild(_node) {
            return this.children.indexOf(_node);
        }
        /**
         * Replaces a child node with another, preserving the position in the list of children
         * @param _replace The node to be replaced
         * @param _with The node to replace with
         */
        replaceChild(_replace, _with) {
            let found = this.findChild(_replace);
            if (found < 0)
                return false;
            let previousParent = _with.getParent();
            if (previousParent)
                previousParent.removeChild(_with);
            _replace.parent = null;
            this.children[found] = _with;
            _with.parent = this;
            _with.dispatchEvent(new Event("childAppend" /* CHILD_APPEND */, { bubbles: true }));
            if (this.isDescendantOf(FudgeCore.AudioManager.default.getBranchListeningTo()))
                _with.broadcastEvent(new Event("childAppendToAudioBranch" /* CHILD_APPEND */));
            return true;
        }
        /**
         * Generator yielding the node and all successors in the branch below for iteration
         */
        get branch() {
            return this.getBranchGenerator();
        }
        isUpdated(_timestampUpdate) {
            return (this.timestampUpdate == _timestampUpdate);
        }
        isDescendantOf(_ancestor) {
            let node = this;
            while (node && node != _ancestor)
                node = node.parent;
            return (node != null);
        }
        /**
         * Applies a Mutator from [[Animation]] to all its components and transfers it to its children.
         * @param _mutator The mutator generated from an [[Animation]]
         */
        applyAnimation(_mutator) {
            if (_mutator.components) {
                for (let componentName in _mutator.components) {
                    if (this.components[componentName]) {
                        let mutatorOfComponent = _mutator.components;
                        for (let i in mutatorOfComponent[componentName]) {
                            if (this.components[componentName][+i]) {
                                let componentToMutate = this.components[componentName][+i];
                                let mutatorArray = mutatorOfComponent[componentName];
                                let mutatorWithComponentName = mutatorArray[+i];
                                for (let cname in mutatorWithComponentName) { // trick used to get the only entry in the list
                                    let mutatorToGive = mutatorWithComponentName[cname];
                                    componentToMutate.mutate(mutatorToGive);
                                }
                            }
                        }
                    }
                }
            }
            if (_mutator.children) {
                for (let i = 0; i < _mutator.children.length; i++) {
                    let name = _mutator.children[i]["ƒ.Node"].name;
                    let childNodes = this.getChildrenByName(name);
                    for (let childNode of childNodes) {
                        childNode.applyAnimation(_mutator.children[i]["ƒ.Node"]);
                    }
                }
            }
        }
        // #endregion
        // #region Components
        /**
         * Returns a list of all components attached to this node, independent of type.
         */
        getAllComponents() {
            let all = [];
            for (let type in this.components) {
                all = all.concat(this.components[type]);
            }
            return all;
        }
        /**
         * Returns a clone of the list of components of the given class attached to this node.
         * @param _class The class of the components to be found.
         */
        getComponents(_class) {
            return (this.components[_class.name] || []).slice(0);
        }
        /**
         * Returns the first compontent found of the given class attached this node or null, if list is empty or doesn't exist
         * @param _class The class of the components to be found.
         */
        getComponent(_class) {
            let list = this.components[_class.name];
            if (list)
                return list[0];
            return null;
        }
        /**
         * Adds the supplied component into the nodes component map.
         * @param _component The component to be pushed into the array.
         */
        addComponent(_component) {
            if (_component.getContainer() == this)
                return;
            if (this.components[_component.type] === undefined)
                this.components[_component.type] = [_component];
            else if (_component.isSingleton)
                throw new Error("Component is marked singleton and can't be attached, no more than one allowed");
            else
                this.components[_component.type].push(_component);
            _component.setContainer(this);
            _component.dispatchEvent(new Event("componentAdd" /* COMPONENT_ADD */));
        }
        /**
         * Removes the given component from the node, if it was attached, and sets its parent to null.
         * @param _component The component to be removed
         * @throws Exception when component is not found
         */
        removeComponent(_component) {
            try {
                let componentsOfType = this.components[_component.type];
                let foundAt = componentsOfType.indexOf(_component);
                if (foundAt < 0)
                    return;
                _component.dispatchEvent(new Event("componentRemove" /* COMPONENT_REMOVE */));
                componentsOfType.splice(foundAt, 1);
                _component.setContainer(null);
            }
            catch (_error) {
                throw new Error(`Unable to remove component '${_component}'in node named '${this.name}'`);
            }
        }
        // #endregion
        // #region Serialization
        serialize() {
            let serialization = {
                name: this.name
            };
            let components = {};
            for (let type in this.components) {
                components[type] = [];
                for (let component of this.components[type]) {
                    // components[type].push(component.serialize());
                    components[type].push(FudgeCore.Serializer.serialize(component));
                }
            }
            serialization["components"] = components;
            let children = [];
            for (let child of this.children) {
                children.push(FudgeCore.Serializer.serialize(child));
            }
            serialization["children"] = children;
            this.dispatchEvent(new Event("nodeSerialized" /* NODE_SERIALIZED */));
            return serialization;
        }
        deserialize(_serialization) {
            this.name = _serialization.name;
            // this.parent = is set when the nodes are added
            // deserialize components first so scripts can react to children being appended
            for (let type in _serialization.components) {
                for (let serializedComponent of _serialization.components[type]) {
                    let deserializedComponent = FudgeCore.Serializer.deserialize(serializedComponent);
                    this.addComponent(deserializedComponent);
                }
            }
            for (let serializedChild of _serialization.children) {
                let deserializedChild = FudgeCore.Serializer.deserialize(serializedChild);
                this.appendChild(deserializedChild);
            }
            this.dispatchEvent(new Event("nodeDeserialized" /* NODE_DESERIALIZED */));
            return this;
        }
        // #endregion
        // #region Events
        /**
         * Adds an event listener to the node. The given handler will be called when a matching event is passed to the node.
         * Deviating from the standard EventTarget, here the _handler must be a function and _capture is the only option.
         * @param _type The type of the event, should be an enumerated value of NODE_EVENT, can be any string
         * @param _handler The function to call when the event reaches this node
         * @param _capture When true, the listener listens in the capture phase, when the event travels deeper into the hierarchy of nodes.
         */
        addEventListener(_type, _handler, _capture = false) {
            let listListeners = _capture ? this.captures : this.listeners;
            if (!listListeners[_type])
                listListeners[_type] = [];
            listListeners[_type].push(_handler);
        }
        /**
         * Removes an event listener from the node. The signatur must match the one used with addEventListener
         * @param _type The type of the event, should be an enumerated value of NODE_EVENT, can be any string
         * @param _handler The function to call when the event reaches this node
         * @param _capture When true, the listener listens in the capture phase, when the event travels deeper into the hierarchy of nodes.
         */
        removeEventListener(_type, _handler, _capture = false) {
            let listenersForType = _capture ? this.captures[_type] : this.listeners[_type];
            if (listenersForType)
                for (let i = listenersForType.length - 1; i >= 0; i--)
                    if (listenersForType[i] == _handler)
                        listenersForType.splice(i, 1);
        }
        /**
         * Dispatches a synthetic event to target. This implementation always returns true (standard: return true only if either event's cancelable attribute value is false or its preventDefault() method was not invoked)
         * The event travels into the hierarchy to this node dispatching the event, invoking matching handlers of the nodes ancestors listening to the capture phase,
         * than the matching handler of the target node in the target phase, and back out of the hierarchy in the bubbling phase, invoking appropriate handlers of the anvestors
         * @param _event The event to dispatch
         */
        dispatchEvent(_event) {
            let ancestors = [];
            let upcoming = this;
            // overwrite event target
            Object.defineProperty(_event, "target", { writable: true, value: this });
            // TODO: consider using Reflect instead of Object throughout. See also Render and Mutable...
            while (upcoming.parent)
                ancestors.push(upcoming = upcoming.parent);
            // capture phase
            Object.defineProperty(_event, "eventPhase", { writable: true, value: Event.CAPTURING_PHASE });
            for (let i = ancestors.length - 1; i >= 0; i--) {
                let ancestor = ancestors[i];
                Object.defineProperty(_event, "currentTarget", { writable: true, value: ancestor });
                let captures = ancestor.captures[_event.type] || [];
                for (let handler of captures)
                    handler(_event);
            }
            if (!_event.bubbles)
                return true;
            // target phase
            Object.defineProperty(_event, "eventPhase", { writable: true, value: Event.AT_TARGET });
            Object.defineProperty(_event, "currentTarget", { writable: true, value: this });
            let listeners = this.listeners[_event.type] || [];
            for (let handler of listeners)
                handler(_event);
            // bubble phase
            Object.defineProperty(_event, "eventPhase", { writable: true, value: Event.BUBBLING_PHASE });
            for (let i = 0; i < ancestors.length; i++) {
                let ancestor = ancestors[i];
                Object.defineProperty(_event, "currentTarget", { writable: true, value: ancestor });
                let listeners = ancestor.listeners[_event.type] || [];
                for (let handler of listeners)
                    handler(_event);
            }
            return true; //TODO: return a meaningful value, see documentation of dispatch event
        }
        /**
         * Broadcasts a synthetic event to this node and from there to all nodes deeper in the hierarchy,
         * invoking matching handlers of the nodes listening to the capture phase. Watch performance when there are many nodes involved
         * @param _event The event to broadcast
         */
        broadcastEvent(_event) {
            // overwrite event target and phase
            Object.defineProperty(_event, "eventPhase", { writable: true, value: Event.CAPTURING_PHASE });
            Object.defineProperty(_event, "target", { writable: true, value: this });
            this.broadcastEventRecursive(_event);
        }
        broadcastEventRecursive(_event) {
            // capture phase only
            Object.defineProperty(_event, "currentTarget", { writable: true, value: this });
            let captures = this.captures[_event.type] || [];
            for (let handler of captures)
                handler(_event);
            // appears to be slower, astonishingly...
            // captures.forEach(function (handler: Function): void {
            //     handler(_event);
            // });
            // same for children
            for (let child of this.children) {
                child.broadcastEventRecursive(_event);
            }
        }
        // #endregion
        *getBranchGenerator() {
            yield this;
            for (let child of this.children)
                yield* child.branch;
        }
    }
    FudgeCore.Node = Node;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A node managed by [[ResourceManager]] that functions as a template for [[NodeResourceInstance]]s
     */
    class NodeResource extends FudgeCore.Node {
        constructor() {
            super(...arguments);
            this.idResource = undefined;
        }
    }
    FudgeCore.NodeResource = NodeResource;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * An instance of a [[NodeResource]].
     * This node keeps a reference to its resource an can thus optimize serialization
     */
    class NodeResourceInstance extends FudgeCore.Node {
        constructor(_nodeResource) {
            super("NodeResourceInstance");
            /** id of the resource that instance was created from */
            // TODO: examine, if this should be a direct reference to the NodeResource, instead of the id
            this.idSource = undefined;
            if (_nodeResource)
                this.set(_nodeResource);
        }
        /**
         * Recreate this node from the [[NodeResource]] referenced
         */
        reset() {
            let resource = FudgeCore.ResourceManager.get(this.idSource);
            this.set(resource);
        }
        //TODO: optimize using the referenced NodeResource, serialize/deserialize only the differences
        serialize() {
            let serialization = super.serialize();
            serialization.idSource = this.idSource;
            return serialization;
        }
        deserialize(_serialization) {
            super.deserialize(_serialization);
            this.idSource = _serialization.idSource;
            return this;
        }
        /**
         * Set this node to be a recreation of the [[NodeResource]] given
         * @param _nodeResource
         */
        set(_nodeResource) {
            // TODO: examine, if the serialization should be stored in the NodeResource for optimization
            let serialization = FudgeCore.Serializer.serialize(_nodeResource);
            //Serializer.deserialize(serialization);
            for (let path in serialization) {
                this.deserialize(serialization[path]);
                break;
            }
            this.idSource = _nodeResource.idResource;
            this.dispatchEvent(new Event("nodeResourceInstantiated" /* NODERESOURCE_INSTANTIATED */));
        }
    }
    FudgeCore.NodeResourceInstance = NodeResourceInstance;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class Ray {
        constructor(_direction = FudgeCore.Vector3.Z(-1), _origin = FudgeCore.Vector3.ZERO(), _length = 1) {
            this.origin = _origin;
            this.direction = _direction;
            this.length = _length;
        }
    }
    FudgeCore.Ray = Ray;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class RayHit {
        constructor(_node = null, _face = 0, _zBuffer = 0) {
            this.node = _node;
            this.face = _face;
            this.zBuffer = _zBuffer;
        }
    }
    FudgeCore.RayHit = RayHit;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="RenderOperator.ts"/>
var FudgeCore;
// / <reference path="RenderOperator.ts"/>
(function (FudgeCore) {
    /**
     * This class manages the references to render data used by nodes.
     * Multiple nodes may refer to the same data via their references to shader, coat and mesh
     */
    class Reference {
        constructor(_reference) {
            this.count = 0;
            this.reference = _reference;
        }
        getReference() {
            return this.reference;
        }
        increaseCounter() {
            this.count++;
            return this.count;
        }
        decreaseCounter() {
            if (this.count == 0)
                throw (new Error("Negative reference counter"));
            this.count--;
            return this.count;
        }
    }
    /**
     * Manages the handling of the ressources that are going to be rendered by [[RenderOperator]].
     * Stores the references to the shader, the coat and the mesh used for each node registered.
     * With these references, the already buffered data is retrieved when rendering.
     */
    class RenderManager extends FudgeCore.RenderOperator {
        // #region Adding
        /**
         * Register the node for rendering. Create a reference for it and increase the matching render-data references or create them first if necessary
         * @param _node
         */
        static addNode(_node) {
            if (RenderManager.nodes.get(_node))
                return;
            let cmpMaterial = _node.getComponent(FudgeCore.ComponentMaterial);
            if (!cmpMaterial)
                return;
            let shader = cmpMaterial.material.getShader();
            RenderManager.createReference(RenderManager.renderShaders, shader, RenderManager.createProgram);
            // let coat: Coat = cmpMaterial.material.getCoat();
            // RenderManager.createReference<Coat, RenderCoat>(RenderManager.renderCoats, coat, RenderManager.createParameter);
            let mesh = _node.getComponent(FudgeCore.ComponentMesh).mesh;
            RenderManager.createReference(RenderManager.renderBuffers, mesh, RenderManager.createBuffers);
            mesh.createRenderBuffers(null);
            // TODO: buffers for shaders, coats and meshes must be referenced by the nodes components/referenced instances directly!
            let nodeReferences = { shader: shader, /*coat: coat,*/ mesh: mesh }; //, doneTransformToWorld: false };
            RenderManager.nodes.set(_node, nodeReferences);
        }
        /**
         * Register the node and its valid successors in the branch for rendering using [[addNode]]
         * @param _node
         * @returns false, if the given node has a current timestamp thus having being processed during latest RenderManager.update and no addition is needed
         */
        static addBranch(_node) {
            // TODO: rethink optimization!!
            // if (_node.isUpdated(RenderManager.timestampUpdate))
            //     return false;
            for (let node of _node.branch)
                try {
                    // may fail when some components are missing. TODO: cleanup
                    RenderManager.addNode(node);
                }
                catch (_error) {
                    FudgeCore.Debug.log(_error);
                }
            return true;
        }
        // #endregion
        // #region Removing
        /**
         * Unregister the node so that it won't be rendered any more. Decrease the render-data references and delete the node reference.
         * @param _node
         */
        static removeNode(_node) {
            let nodeReferences = RenderManager.nodes.get(_node);
            if (!nodeReferences)
                return;
            RenderManager.removeReference(RenderManager.renderShaders, nodeReferences.shader, RenderManager.deleteProgram);
            // RenderManager.removeReference<Coat, RenderCoat>(RenderManager.renderCoats, nodeReferences.coat, RenderManager.deleteParameter);
            RenderManager.removeReference(RenderManager.renderBuffers, nodeReferences.mesh, RenderManager.deleteBuffers);
            RenderManager.nodes.delete(_node);
            nodeReferences.mesh.deleteRenderBuffers(null);
        }
        /**
         * Unregister the node and its valid successors in the branch to free renderer resources. Uses [[removeNode]]
         * @param _node
         */
        static removeBranch(_node) {
            for (let node of _node.branch)
                RenderManager.removeNode(node);
        }
        // #endregion
        // #region Updating
        /**
         * Reflect changes in the node concerning shader, coat and mesh, manage the render-data references accordingly and update the node references
         * @param _node
         */
        static updateNode(_node) {
            let nodeReferences = RenderManager.nodes.get(_node);
            if (!nodeReferences)
                return;
            let cmpMaterial = _node.getComponent(FudgeCore.ComponentMaterial);
            let shader = cmpMaterial.material.getShader();
            if (shader !== nodeReferences.shader) {
                RenderManager.removeReference(RenderManager.renderShaders, nodeReferences.shader, RenderManager.deleteProgram);
                RenderManager.createReference(RenderManager.renderShaders, shader, RenderManager.createProgram);
                nodeReferences.shader = shader;
            }
            // let coat: Coat = cmpMaterial.material.getCoat();
            // if (coat !== nodeReferences.coat) {
            //   RenderManager.removeReference<Coat, RenderCoat>(RenderManager.renderCoats, nodeReferences.coat, RenderManager.deleteParameter);
            //   RenderManager.createReference<Coat, RenderCoat>(RenderManager.renderCoats, coat, RenderManager.createParameter);
            //   nodeReferences.coat = coat;
            // }
            let mesh = (_node.getComponent(FudgeCore.ComponentMesh)).mesh;
            if (mesh !== nodeReferences.mesh) {
                RenderManager.removeReference(RenderManager.renderBuffers, nodeReferences.mesh, RenderManager.deleteBuffers);
                RenderManager.createReference(RenderManager.renderBuffers, mesh, RenderManager.createBuffers);
                nodeReferences.mesh = mesh;
            }
        }
        /**
         * Update the node and its valid successors in the branch using [[updateNode]]
         * @param _node
         */
        static updateBranch(_node) {
            for (let node of _node.branch)
                RenderManager.updateNode(node);
        }
        // #endregion
        // #region Lights
        /**
         * Viewports collect the lights relevant to the branch to render and calls setLights to pass the collection.
         * RenderManager passes it on to all shaders used that can process light
         * @param _lights
         */
        static setLights(_lights) {
            // let renderLights: RenderLights = RenderManager.createRenderLights(_lights);
            for (let entry of RenderManager.renderShaders) {
                let renderShader = entry[1].getReference();
                RenderManager.setLightsInShader(renderShader, _lights);
            }
            // debugger;
        }
        // #endregion
        // #region Rendering
        /**
         * Update all render data. After RenderManager, multiple viewports can render their associated data without updating the same data multiple times
         */
        static update() {
            RenderManager.timestampUpdate = performance.now();
            RenderManager.recalculateAllNodeTransforms();
        }
        /**
         * Clear the offscreen renderbuffer with the given [[Color]]
         * @param _color
         */
        static clear(_color = null) {
            RenderManager.crc3.clearColor(_color.r, _color.g, _color.b, _color.a);
            RenderManager.crc3.clear(WebGL2RenderingContext.COLOR_BUFFER_BIT | WebGL2RenderingContext.DEPTH_BUFFER_BIT);
        }
        /**
         * Reset the offscreen framebuffer to the original RenderingContext
         */
        static resetFrameBuffer(_color = null) {
            RenderManager.crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, null);
        }
        /**
         * Draws the branch starting with the given [[Node]] using the camera given [[ComponentCamera]].
         * @param _node
         * @param _cmpCamera
         */
        static drawBranch(_node, _cmpCamera, _drawNode = RenderManager.drawNode) {
            if (!_node.isActive)
                return;
            if (_drawNode == RenderManager.drawNode)
                RenderManager.resetFrameBuffer();
            let finalTransform;
            let cmpMesh = _node.getComponent(FudgeCore.ComponentMesh);
            if (cmpMesh)
                finalTransform = FudgeCore.Matrix4x4.MULTIPLICATION(_node.mtxWorld, cmpMesh.pivot);
            else
                finalTransform = _node.mtxWorld; // caution, RenderManager is a reference...
            // multiply camera matrix
            let projection = FudgeCore.Matrix4x4.MULTIPLICATION(_cmpCamera.ViewProjectionMatrix, finalTransform);
            _drawNode(_node, finalTransform, projection);
            for (let name in _node.getChildren()) {
                let childNode = _node.getChildren()[name];
                RenderManager.drawBranch(childNode, _cmpCamera, _drawNode); //, world);
            }
            FudgeCore.Recycler.store(projection);
            if (finalTransform != _node.mtxWorld)
                FudgeCore.Recycler.store(finalTransform);
        }
        //#region RayCast & Picking
        /**
         * Draws the branch for RayCasting starting with the given [[Node]] using the camera given [[ComponentCamera]].
         * @param _node
         * @param _cmpCamera
         */
        static drawBranchForRayCast(_node, _cmpCamera) {
            RenderManager.pickBuffers = [];
            if (!RenderManager.renderShaders.get(FudgeCore.ShaderRayCast))
                RenderManager.createReference(RenderManager.renderShaders, FudgeCore.ShaderRayCast, RenderManager.createProgram);
            //TODO: examine, why switching blendFunction is necessary 
            FudgeCore.RenderOperator.crc3.blendFunc(1, 0);
            RenderManager.drawBranch(_node, _cmpCamera, RenderManager.drawNodeForRayCast);
            FudgeCore.RenderOperator.crc3.blendFunc(WebGL2RenderingContext.DST_ALPHA, WebGL2RenderingContext.ONE_MINUS_DST_ALPHA);
            RenderManager.resetFrameBuffer();
            return RenderManager.pickBuffers;
        }
        static pickNodeAt(_pos, _pickBuffers, _rect) {
            let hits = [];
            for (let pickBuffer of _pickBuffers) {
                RenderManager.crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, pickBuffer.frameBuffer);
                // TODO: instead of reading all data and afterwards pick the pixel, read only the pixel!
                let data = new Uint8Array(_rect.width * _rect.height * 4);
                RenderManager.crc3.readPixels(0, 0, _rect.width, _rect.height, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.UNSIGNED_BYTE, data);
                let pixel = _pos.x + _rect.width * _pos.y;
                // let zBuffer: number = data[4 * pixel + 1] + data[4 * pixel + 2] / 256;
                let zBuffer = data[4 * pixel + 0];
                let hit = new FudgeCore.RayHit(pickBuffer.node, 0, zBuffer);
                hits.push(hit);
            }
            return hits;
        }
        static drawNode(_node, _finalTransform, _projection) {
            let references = RenderManager.nodes.get(_node);
            if (!references)
                return;
            let coat = _node.getComponent(FudgeCore.ComponentMaterial).material.getCoat();
            let shaderInfo = RenderManager.renderShaders.get(references.shader).getReference();
            RenderManager.draw(shaderInfo, references.mesh, coat, _finalTransform, _projection);
            // RenderManager.draw(shaderInfo, bufferInfo, coatInfo, _finalTransform, _projection);
        }
        static drawNodeForRayCast(_node, _finalTransform, _projection) {
            // TODO: look into SSBOs!
            let target = RenderManager.getRayCastTexture();
            const framebuffer = RenderManager.crc3.createFramebuffer();
            // render to our targetTexture by binding the framebuffer
            RenderManager.crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, framebuffer);
            // attach the texture as the first color attachment
            const attachmentPoint = WebGL2RenderingContext.COLOR_ATTACHMENT0;
            RenderManager.crc3.framebufferTexture2D(WebGL2RenderingContext.FRAMEBUFFER, attachmentPoint, WebGL2RenderingContext.TEXTURE_2D, target, 0);
            let references = RenderManager.nodes.get(_node);
            if (!references)
                return; // TODO: deal with partial references
            let pickBuffer = { node: _node, texture: target, frameBuffer: framebuffer };
            RenderManager.pickBuffers.push(pickBuffer);
            let renderShader = FudgeCore.RenderOperator.renderShaderRayCast;
            FudgeCore.RenderOperator.useProgram(renderShader);
            references.mesh.useRenderBuffers(renderShader, _finalTransform, _projection, RenderManager.pickBuffers.length);
            FudgeCore.RenderOperator.crc3.drawElements(WebGL2RenderingContext.TRIANGLES, references.mesh.renderBuffers.nIndices, WebGL2RenderingContext.UNSIGNED_SHORT, 0);
            // make texture available to onscreen-display
        }
        static getRayCastTexture() {
            // create to render to
            const targetTextureWidth = RenderManager.getViewportRectangle().width;
            const targetTextureHeight = RenderManager.getViewportRectangle().height;
            const targetTexture = RenderManager.crc3.createTexture();
            RenderManager.crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, targetTexture);
            {
                const internalFormat = WebGL2RenderingContext.RGBA8;
                const format = WebGL2RenderingContext.RGBA;
                const type = WebGL2RenderingContext.UNSIGNED_BYTE;
                RenderManager.crc3.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, internalFormat, targetTextureWidth, targetTextureHeight, 0, format, type, null);
                // set the filtering so we don't need mips
                RenderManager.crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.LINEAR);
                RenderManager.crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_S, WebGL2RenderingContext.CLAMP_TO_EDGE);
                RenderManager.crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_T, WebGL2RenderingContext.CLAMP_TO_EDGE);
            }
            return targetTexture;
        }
        //#endregion
        //#region Transformation of branch
        /**
         * Recalculate the world matrix of all registered nodes respecting their hierarchical relation.
         */
        static recalculateAllNodeTransforms() {
            // inner function to be called in a for each node at the bottom of RenderManager function
            // function markNodeToBeTransformed(_nodeReferences: NodeReferences, _node: Node, _map: MapNodeToNodeReferences): void {
            //     _nodeReferences.doneTransformToWorld = false;
            // }
            // inner function to be called in a for each node at the bottom of RenderManager function
            let recalculateBranchContainingNode = (_nodeReferences, _node, _map) => {
                // find uppermost ancestor not recalculated yet
                let ancestor = _node;
                let parent;
                while (true) {
                    parent = ancestor.getParent();
                    if (!parent)
                        break;
                    if (_node.isUpdated(RenderManager.timestampUpdate))
                        break;
                    ancestor = parent;
                }
                // TODO: check if nodes without meshes must be registered
                // use the ancestors parent world matrix to start with, or identity if no parent exists or it's missing a ComponenTransform
                let matrix = FudgeCore.Matrix4x4.IDENTITY();
                if (parent)
                    matrix = parent.mtxWorld;
                // start recursive recalculation of the whole branch starting from the ancestor found
                RenderManager.recalculateTransformsOfNodeAndChildren(ancestor, matrix);
            };
            // call the functions above for each registered node
            // RenderManager.nodes.forEach(markNodeToBeTransformed);
            RenderManager.nodes.forEach(recalculateBranchContainingNode);
        }
        /**
         * Recursive method receiving a childnode and its parents updated world transform.
         * If the childnode owns a ComponentTransform, its worldmatrix is recalculated and passed on to its children, otherwise its parents matrix
         * @param _node
         * @param _world
         */
        static recalculateTransformsOfNodeAndChildren(_node, _world) {
            let world = _world;
            let cmpTransform = _node.cmpTransform;
            if (cmpTransform)
                world = FudgeCore.Matrix4x4.MULTIPLICATION(_world, cmpTransform.local);
            _node.mtxWorld = world;
            _node.timestampUpdate = RenderManager.timestampUpdate;
            for (let child of _node.getChildren()) {
                RenderManager.recalculateTransformsOfNodeAndChildren(child, world);
            }
        }
        // #endregion
        // #region Manage references to render data
        /**
         * Removes a reference to a program, parameter or buffer by decreasing its reference counter and deleting it, if the counter reaches 0
         * @param _in
         * @param _key
         * @param _deletor
         */
        static removeReference(_in, _key, _deletor) {
            let reference;
            reference = _in.get(_key);
            if (reference.decreaseCounter() == 0) {
                // The following deletions may be an optimization, not necessary to start with and maybe counterproductive.
                // If data should be used later again, it must then be reconstructed...
                _deletor(reference.getReference());
                _in.delete(_key);
            }
        }
        /**
         * Increases the counter of the reference to a program, parameter or buffer. Creates the reference, if it's not existent.
         * @param _in
         * @param _key
         * @param _creator
         */
        static createReference(_in, _key, _creator) {
            let reference;
            reference = _in.get(_key);
            if (reference)
                reference.increaseCounter();
            else {
                let content = _creator(_key);
                reference = new Reference(content);
                reference.increaseCounter();
                _in.set(_key, reference);
            }
        }
    }
    RenderManager.rectClip = new FudgeCore.Rectangle(-1, 1, 2, -2);
    /** Stores references to the compiled shader programs and makes them available via the references to shaders */
    RenderManager.renderShaders = new Map();
    /** Stores references to the vertex array objects and makes them available via the references to coats */
    // private static renderCoats: Map<Coat, Reference<RenderCoat>> = new Map();
    /** Stores references to the vertex buffers and makes them available via the references to meshes */
    RenderManager.renderBuffers = new Map();
    RenderManager.nodes = new Map();
    FudgeCore.RenderManager = RenderManager;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="../Coat/Coat.ts"/>
var FudgeCore;
// / <reference path="../Coat/Coat.ts"/>
(function (FudgeCore) {
    /**
     * Static superclass for the representation of WebGl shaderprograms.
     * @authors Jascha Karagöl, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    // TODO: define attribute/uniforms as layout and use those consistently in shaders
    class Shader {
        /** The type of coat that can be used with this shader to create a material */
        static getCoat() { return null; }
        static getVertexShaderSource() { return null; }
        static getFragmentShaderSource() { return null; }
        static registerSubclass(_subclass) { return Shader.subclasses.push(_subclass) - 1; }
    }
    Shader.subclasses = [];
    FudgeCore.Shader = Shader;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Single color shading
     * @authors Jascha Karagöl, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ShaderFlat extends FudgeCore.Shader {
        static getCoat() {
            return FudgeCore.CoatColored;
        }
        static getVertexShaderSource() {
            return `#version 300 es

                    struct LightAmbient {
                        vec4 color;
                    };
                    struct LightDirectional {
                        vec4 color;
                        vec3 direction;
                    };

                    const uint MAX_LIGHTS_DIRECTIONAL = 10u;

                    in vec3 a_position;
                    in vec3 a_normal;
                    uniform mat4 u_world;
                    uniform mat4 u_projection;

                    uniform LightAmbient u_ambient;
                    uniform uint u_nLightsDirectional;
                    uniform LightDirectional u_directional[MAX_LIGHTS_DIRECTIONAL];
                    flat out vec4 v_color;
                    
                    void main() {   
                        gl_Position = u_projection * vec4(a_position, 1.0);
                        vec3 normal = normalize(mat3(u_world) * a_normal);

                        v_color = u_ambient.color;
                        for (uint i = 0u; i < u_nLightsDirectional; i++) {
                            float illumination = -dot(normal, u_directional[i].direction);
                            if (illumination > 0.0f)
                                v_color += illumination * u_directional[i].color; // vec4(1,1,1,1); // 
                        }
                        v_color.a = 1.0;
                    }`;
        }
        static getFragmentShaderSource() {
            return `#version 300 es
                    precision mediump float;

                    uniform vec4 u_color;
                    flat in vec4 v_color;
                    out vec4 frag;
                    
                    void main() {
                        frag = u_color * v_color;
                    }`;
        }
    }
    ShaderFlat.iSubclass = FudgeCore.Shader.registerSubclass(ShaderFlat);
    FudgeCore.ShaderFlat = ShaderFlat;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Matcap (Material Capture) shading. The texture provided by the coat is used as a matcap material.
     * Implementation based on https://www.clicktorelease.com/blog/creating-spherical-environment-mapping-shader/
     * @authors Simon Storl-Schulke, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ShaderMatCap extends FudgeCore.Shader {
        static getCoat() {
            return FudgeCore.CoatMatCap;
        }
        static getVertexShaderSource() {
            return `#version 300 es

                    in vec3 a_position;
                    in vec3 a_normal;
                    uniform mat4 u_projection;

                    out vec2 tex_coords_smooth;
                    flat out vec2 tex_coords_flat;

                    void main() {
                        mat4 normalMatrix = transpose(inverse(u_projection));
                        vec4 p = vec4(a_position, 1.0);
                        vec4 normal4 = vec4(a_normal, 1.0);
                        vec3 e = normalize( vec3( u_projection * p ) );
                        vec3 n = normalize( vec3(normalMatrix * normal4) );

                        vec3 r = reflect( e, n );
                        float m = 2. * sqrt(
                            pow( r.x, 2. ) +
                            pow( r.y, 2. ) +
                            pow( r.z + 1., 2. )
                        );

                        tex_coords_smooth = r.xy / m + .5;
                        tex_coords_flat = r.xy / m + .5;

                        gl_Position = u_projection * vec4(a_position, 1.0);
                    }`;
        }
        static getFragmentShaderSource() {
            return `#version 300 es
                    precision mediump float;
                    
                    uniform vec4 u_tint_color;
                    uniform float u_flatmix;
                    uniform sampler2D u_texture;
                    
                    in vec2 tex_coords_smooth;
                    flat in vec2 tex_coords_flat;

                    out vec4 frag;

                    void main() {
                        vec2 tc = mix(tex_coords_smooth, tex_coords_flat, u_flatmix);
                        frag = u_tint_color * texture(u_texture, tc) * 2.0;
                    }`;
        }
    }
    ShaderMatCap.iSubclass = FudgeCore.Shader.registerSubclass(ShaderMatCap);
    FudgeCore.ShaderMatCap = ShaderMatCap;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Renders for Raycasting
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ShaderRayCast extends FudgeCore.Shader {
        static getVertexShaderSource() {
            return `#version 300 es

                    in vec3 a_position;
                    uniform mat4 u_projection;
                    
                    void main() {   
                        gl_Position = u_projection * vec4(a_position, 1.0);
                    }`;
        }
        static getFragmentShaderSource() {
            return `#version 300 es
                    precision mediump float;
                    precision highp int;
                    
                    uniform int u_id;
                    out vec4 frag;
                    
                    void main() {
                       float id = float(u_id)/ 256.0;
                       float upperbyte = trunc(gl_FragCoord.z * 256.0) / 256.0;
                       float lowerbyte = fract(gl_FragCoord.z * 256.0);
                       frag = vec4(gl_FragCoord.z, upperbyte, lowerbyte, 1.0);
                    }`;
        }
    }
    FudgeCore.ShaderRayCast = ShaderRayCast;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Textured shading
     * @authors Jascha Karagöl, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ShaderTexture extends FudgeCore.Shader {
        static getCoat() {
            return FudgeCore.CoatTextured;
        }
        static getVertexShaderSource() {
            return `#version 300 es

                in vec3 a_position;
                in vec2 a_textureUVs;
                uniform mat4 u_projection;
                uniform vec4 u_color;
                uniform mat3 u_pivot;
                out vec2 v_textureUVs;

                void main() {  
                    gl_Position = u_projection * vec4(a_position, 1.0);
                    // v_textureUVs = a_textureUVs;
                    v_textureUVs = vec2(u_pivot * vec3(a_textureUVs, 1.0)).xy;
                }`;
        }
        static getFragmentShaderSource() {
            return `#version 300 es
                precision mediump float;
                
                in vec2 v_textureUVs;
                uniform sampler2D u_texture;
                out vec4 frag;
                
                void main() {
                    frag = texture(u_texture, v_textureUVs);
                    if (frag.a < 0.01)
                      discard;
            }`;
        }
    }
    ShaderTexture.iSubclass = FudgeCore.Shader.registerSubclass(ShaderTexture);
    FudgeCore.ShaderTexture = ShaderTexture;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Single color shading
     * @authors Jascha Karagöl, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ShaderUniColor extends FudgeCore.Shader {
        static getCoat() {
            return FudgeCore.CoatColored;
        }
        static getVertexShaderSource() {
            return `#version 300 es

                    in vec3 a_position;
                    uniform mat4 u_projection;
                    
                    void main() {   
                        gl_Position = u_projection * vec4(a_position, 1.0);
                    }`;
        }
        static getFragmentShaderSource() {
            return `#version 300 es
                    precision mediump float;
                    
                    uniform vec4 u_color;
                    out vec4 frag;
                    
                    void main() {
                       frag = u_color;
                    }`;
        }
    }
    ShaderUniColor.iSubclass = FudgeCore.Shader.registerSubclass(ShaderUniColor);
    FudgeCore.ShaderUniColor = ShaderUniColor;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Baseclass for different kinds of textures.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Texture extends FudgeCore.Mutable {
        reduceMutator() { }
    }
    FudgeCore.Texture = Texture;
    /**
     * Texture created from an existing image
     */
    class TextureImage extends Texture {
        constructor() {
            super(...arguments);
            this.image = null;
        }
    }
    FudgeCore.TextureImage = TextureImage;
    /**
     * Texture created from a canvas
     */
    class TextureCanvas extends Texture {
    }
    FudgeCore.TextureCanvas = TextureCanvas;
    /**
     * Texture created from a FUDGE-Sketch
     */
    class TextureSketch extends TextureCanvas {
    }
    FudgeCore.TextureSketch = TextureSketch;
    /**
     * Texture created from an HTML-page
     */
    class TextureHTML extends TextureCanvas {
    }
    FudgeCore.TextureHTML = TextureHTML;
})(FudgeCore || (FudgeCore = {}));
// /<reference path="../Event/Event.ts"/>
// /<reference path="../Time/Time.ts"/>
var FudgeCore;
// /<reference path="../Event/Event.ts"/>
// /<reference path="../Time/Time.ts"/>
(function (FudgeCore) {
    /**
     * Determines the mode a loop runs in
     */
    let LOOP_MODE;
    (function (LOOP_MODE) {
        /** Loop cycles controlled by window.requestAnimationFrame */
        LOOP_MODE["FRAME_REQUEST"] = "frameRequest";
        /** Loop cycles with the given framerate in [[Time]].game */
        LOOP_MODE["TIME_GAME"] = "timeGame";
        /** Loop cycles with the given framerate in realtime, independent of [[Time]].game */
        LOOP_MODE["TIME_REAL"] = "timeReal";
    })(LOOP_MODE = FudgeCore.LOOP_MODE || (FudgeCore.LOOP_MODE = {}));
    /**
     * Core loop of a Fudge application. Initializes automatically and must be started explicitly.
     * It then fires [[EVENT]].LOOP\_FRAME to all added listeners at each frame
     *
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Loop extends FudgeCore.EventTargetStatic {
        /**
         * Starts the loop with the given mode and fps
         * @param _mode
         * @param _fps Is only applicable in TIME-modes
         * @param _syncWithAnimationFrame Experimental and only applicable in TIME-modes. Should defer the loop-cycle until the next possible animation frame.
         */
        static start(_mode = LOOP_MODE.FRAME_REQUEST, _fps = 60, _syncWithAnimationFrame = false) {
            Loop.stop();
            Loop.timeStartGame = FudgeCore.Time.game.get();
            Loop.timeStartReal = performance.now();
            Loop.timeLastFrameGame = Loop.timeStartGame;
            Loop.timeLastFrameReal = Loop.timeStartReal;
            Loop.fpsDesired = (_mode == LOOP_MODE.FRAME_REQUEST) ? 60 : _fps;
            Loop.framesToAverage = Loop.fpsDesired;
            Loop.timeLastFrameGameAvg = Loop.timeLastFrameRealAvg = 1000 / Loop.fpsDesired;
            Loop.mode = _mode;
            Loop.syncWithAnimationFrame = _syncWithAnimationFrame;
            let log = `Loop starting in mode ${Loop.mode}`;
            if (Loop.mode != LOOP_MODE.FRAME_REQUEST)
                log += ` with attempted ${_fps} fps`;
            FudgeCore.Debug.log(log);
            switch (_mode) {
                case LOOP_MODE.FRAME_REQUEST:
                    Loop.loopFrame();
                    break;
                case LOOP_MODE.TIME_REAL:
                    Loop.idIntervall = window.setInterval(Loop.loopTime, 1000 / Loop.fpsDesired);
                    Loop.loopTime();
                    break;
                case LOOP_MODE.TIME_GAME:
                    Loop.idIntervall = FudgeCore.Time.game.setTimer(1000 / Loop.fpsDesired, 0, Loop.loopTime);
                    Loop.loopTime();
                    break;
                default:
                    break;
            }
            Loop.running = true;
        }
        /**
         * Stops the loop
         */
        static stop() {
            if (!Loop.running)
                return;
            switch (Loop.mode) {
                case LOOP_MODE.FRAME_REQUEST:
                    window.cancelAnimationFrame(Loop.idRequest);
                    break;
                case LOOP_MODE.TIME_REAL:
                    window.clearInterval(Loop.idIntervall);
                    window.cancelAnimationFrame(Loop.idRequest);
                    break;
                case LOOP_MODE.TIME_GAME:
                    FudgeCore.Time.game.deleteTimer(Loop.idIntervall);
                    window.cancelAnimationFrame(Loop.idRequest);
                    break;
                default:
                    break;
            }
            Loop.running = false;
            FudgeCore.Debug.log("Loop stopped!");
        }
        static getFpsGameAverage() {
            return 1000 / Loop.timeLastFrameGameAvg;
        }
        static getFpsRealAverage() {
            return 1000 / Loop.timeLastFrameRealAvg;
        }
        static loop() {
            let time;
            time = performance.now();
            Loop.timeFrameReal = time - Loop.timeLastFrameReal;
            Loop.timeLastFrameReal = time;
            time = FudgeCore.Time.game.get();
            Loop.timeFrameGame = time - Loop.timeLastFrameGame;
            Loop.timeLastFrameGame = time;
            Loop.timeLastFrameGameAvg = ((Loop.framesToAverage - 1) * Loop.timeLastFrameGameAvg + Loop.timeFrameGame) / Loop.framesToAverage;
            Loop.timeLastFrameRealAvg = ((Loop.framesToAverage - 1) * Loop.timeLastFrameRealAvg + Loop.timeFrameReal) / Loop.framesToAverage;
            let event = new Event("loopFrame" /* LOOP_FRAME */);
            Loop.targetStatic.dispatchEvent(event);
        }
        static loopFrame() {
            Loop.loop();
            Loop.idRequest = window.requestAnimationFrame(Loop.loopFrame);
        }
        static loopTime() {
            if (Loop.syncWithAnimationFrame)
                Loop.idRequest = window.requestAnimationFrame(Loop.loop);
            else
                Loop.loop();
        }
    }
    /** The gametime the loop was started, overwritten at each start */
    Loop.timeStartGame = 0;
    /** The realtime the loop was started, overwritten at each start */
    Loop.timeStartReal = 0;
    /** The gametime elapsed since the last loop cycle */
    Loop.timeFrameGame = 0;
    /** The realtime elapsed since the last loop cycle */
    Loop.timeFrameReal = 0;
    Loop.timeLastFrameGame = 0;
    Loop.timeLastFrameReal = 0;
    Loop.timeLastFrameGameAvg = 0;
    Loop.timeLastFrameRealAvg = 0;
    Loop.running = false;
    Loop.mode = LOOP_MODE.FRAME_REQUEST;
    Loop.idIntervall = 0;
    Loop.idRequest = 0;
    Loop.fpsDesired = 30;
    Loop.framesToAverage = 30;
    Loop.syncWithAnimationFrame = false;
    FudgeCore.Loop = Loop;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Instances of this class generate a timestamp that correlates with the time elapsed since the start of the program but allows for resetting and scaling.
     * Supports [[Timer]]s similar to window.setInterval but with respect to the scaled time.
     * All time values are given in milliseconds
     *
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Time extends FudgeCore.EventTargetƒ {
        constructor() {
            super();
            this.timers = {};
            this.idTimerNext = 0;
            this.start = performance.now();
            this.scale = 1.0;
            this.offset = 0.0;
            this.lastCallToElapsed = 0.0;
        }
        /**
         * Returns the game-time-object which starts automatically and serves as base for various internal operations.
         */
        // public static get game(): Time {
        //   return Time.gameTime;
        // }
        static getUnits(_milliseconds) {
            let units = {};
            units.asSeconds = _milliseconds / 1000;
            units.asMinutes = units.asSeconds / 60;
            units.asHours = units.asMinutes / 60;
            units.hours = Math.floor(units.asHours);
            units.minutes = Math.floor(units.asMinutes) % 60;
            units.seconds = Math.floor(units.asSeconds) % 60;
            units.fraction = _milliseconds % 1000;
            units.thousands = _milliseconds % 10;
            units.hundreds = _milliseconds % 100 - units.thousands;
            units.tenths = units.fraction - units.hundreds - units.thousands;
            return units;
        }
        //#region Get/Set time and scaling
        /**
         * Retrieves the current scaled timestamp of this instance in milliseconds
         */
        get() {
            return this.offset + this.scale * (performance.now() - this.start);
        }
        /**
         * Returns the remaining time to the given point of time
         */
        getRemainder(_to) {
            return _to - this.get();
        }
        /**
         * (Re-) Sets the timestamp of this instance
         * @param _time The timestamp to represent the current time (default 0.0)
         */
        set(_time = 0) {
            this.offset = _time;
            this.start = performance.now();
            this.getElapsedSincePreviousCall();
        }
        /**
         * Sets the scaling of this time, allowing for slowmotion (<1) or fastforward (>1)
         * @param _scale The desired scaling (default 1.0)
         */
        setScale(_scale = 1.0) {
            this.set(this.get());
            this.scale = _scale;
            //TODO: catch scale=0
            this.rescaleAllTimers();
            this.getElapsedSincePreviousCall();
            this.dispatchEvent(new Event("timeScaled" /* TIME_SCALED */));
        }
        /**
         * Retrieves the current scaling of this time
         */
        getScale() {
            return this.scale;
        }
        /**
         * Retrieves the offset of this time
         */
        getOffset() {
            return this.offset;
        }
        /**
         * Retrieves the scaled time in milliseconds passed since the last call to this method
         * Automatically reset at every call to set(...) and setScale(...)
         */
        getElapsedSincePreviousCall() {
            let current = this.get();
            let elapsed = current - this.lastCallToElapsed;
            this.lastCallToElapsed = current;
            return elapsed;
        }
        //#endregion
        //#region Timers
        /**
         * Returns a Promise<void> to be resolved after the time given. To be used with async/await
         */
        delay(_lapse) {
            return new Promise(_resolve => this.setTimer(_lapse, 1, () => _resolve()));
        }
        // TODO: examine if web-workers would enhance performance here!
        /**
         * Stops and deletes all [[Timer]]s attached. Should be called before this Time-object leaves scope
         */
        clearAllTimers() {
            for (let id in this.timers) {
                this.deleteTimer(Number(id));
            }
        }
        /**
         * Deletes [[Timer]] found using the internal id of the connected interval-object
         * @param _id
         */
        deleteTimerByItsInternalId(_id) {
            for (let id in this.timers) {
                let timer = this.timers[id];
                if (timer.id == _id) {
                    timer.clear();
                    delete this.timers[id];
                }
            }
        }
        /**
         * Installs a timer at this time object
         * @param _lapse The object-time to elapse between the calls to _callback
         * @param _count The number of calls desired, 0 = Infinite
         * @param _handler The function to call each the given lapse has elapsed
         * @param _arguments Additional parameters to pass to callback function
         */
        setTimer(_lapse, _count, _handler, ..._arguments) {
            let timer = new FudgeCore.Timer(this, _lapse, _count, _handler, _arguments);
            this.timers[++this.idTimerNext] = timer;
            return this.idTimerNext;
        }
        /**
         * Deletes the timer with the id given by this time object
         */
        deleteTimer(_id) {
            this.timers[_id].clear();
            delete this.timers[_id];
        }
        /**
         * Returns a copy of the list of timers currently installed on this time object
         */
        getTimers() {
            let result = {};
            return Object.assign(result, this.timers);
        }
        /**
         * Returns true if there are [[Timers]] installed to this
         */
        hasTimers() {
            return (Object.keys(this.timers).length > 0);
        }
        /**
         * Recreates [[Timer]]s when scaling changes
         */
        rescaleAllTimers() {
            for (let id in this.timers) {
                let timer = this.timers[id];
                timer.clear();
                if (!this.scale)
                    // Time has stopped, no need to replace cleared timers
                    continue;
                this.timers[id] = timer.installCopy();
            }
        }
    }
    /** Standard game time starting automatically with the application */
    Time.game = new Time();
    FudgeCore.Time = Time;
    //#endregion
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A [[Timer]]-instance internally uses window.setInterval to call a given handler with a given frequency a given number of times,
     * passing an [[TimerEventƒ]]-instance with additional information and given arguments.
     * The frequency scales with the [[Time]]-instance the [[Timer]]-instance is attached to.
     *
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Timer {
        /**
         * Creates a [[Timer]] instance.
         * @param _time The [[Time]] instance, the timer attaches to
         * @param _elapse The time in milliseconds to elapse, to the next call of _handler, measured in _time
         * @param _count The desired number of calls to _handler, Timer deinstalls automatically after last call. Passing 0 invokes infinite calls
         * @param _handler The [[TimerHandler]] instance to call
         * @param _arguments Additional arguments to pass to _handler
         */
        constructor(_time, _elapse, _count, _handler, ..._arguments) {
            this.time = _time;
            this.elapse = _elapse;
            this.event = new FudgeCore.EventTimer(this, _arguments);
            this.handler = _handler;
            this.count = _count;
            let scale = Math.abs(_time.getScale());
            if (!scale) {
                // Time is stopped, timer won't be active
                this.active = false;
                return;
            }
            this.timeoutReal = this.elapse / scale;
            let callback = () => {
                this.event.lastCall = (this.count == 1);
                _handler(this.event);
                this.event.firstCall = false;
                if (this.count > 0)
                    if (--this.count == 0)
                        _time.deleteTimerByItsInternalId(this.idWindow);
            };
            this.idWindow = window.setInterval(callback, this.timeoutReal, _arguments);
            this.active = true;
        }
        /**
         * Returns the window-id of the timer, which was returned by setInterval
         */
        get id() {
            return this.idWindow;
        }
        /**
         * Returns the time-intervall for calls to the handler
         */
        get lapse() {
            return this.elapse;
        }
        /**
         * Attaches a copy of this at its current state to the same [[Time]]-instance. Used internally when rescaling [[Time]]
         */
        installCopy() {
            return new Timer(this.time, this.elapse, this.count, this.handler, this.event.arguments);
        }
        /**
         * Clears the timer, removing it from the interval-timers handled by window
         */
        clear() {
            // if (this.type == TIMER_TYPE.TIMEOUT) {
            //     if (this.active)
            //         // save remaining time to timeout as new timeout for restart
            //         this.timeout = this.timeout * (1 - (performance.now() - this.startTimeReal) / this.timeoutReal);
            //     window.clearTimeout(this.id);
            // }
            // else
            // TODO: reusing timer starts interval anew. Should be remaining interval as timeout, then starting interval anew 
            window.clearInterval(this.idWindow);
            this.active = false;
        }
    }
    FudgeCore.Timer = Timer;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Handles file transfer from a Fudge-Browserapp to the local filesystem without a local server.
     * Saves to the download-path given by the browser, loads from the player's choice.
     */
    class FileIoBrowserLocal extends FudgeCore.EventTargetStatic {
        // TODO: refactor to async function to be handled using promise, instead of using event target
        static load() {
            FileIoBrowserLocal.selector = document.createElement("input");
            FileIoBrowserLocal.selector.type = "file";
            FileIoBrowserLocal.selector.multiple = true;
            FileIoBrowserLocal.selector.hidden = true;
            FileIoBrowserLocal.selector.addEventListener("change", FileIoBrowserLocal.handleFileSelect);
            document.body.appendChild(FileIoBrowserLocal.selector);
            FileIoBrowserLocal.selector.click();
        }
        // TODO: refactor to async function to be handled using promise, instead of using event target
        static save(_toSave) {
            for (let filename in _toSave) {
                let content = _toSave[filename];
                let blob = new Blob([content], { type: "text/plain" });
                let url = window.URL.createObjectURL(blob);
                //*/ using anchor element for download
                let downloader;
                downloader = document.createElement("a");
                downloader.setAttribute("href", url);
                downloader.setAttribute("download", filename);
                document.body.appendChild(downloader);
                downloader.click();
                document.body.removeChild(downloader);
                window.URL.revokeObjectURL(url);
            }
            let event = new CustomEvent("fileSaved" /* FILE_SAVED */, { detail: { mapFilenameToContent: _toSave } });
            FileIoBrowserLocal.targetStatic.dispatchEvent(event);
        }
        static async handleFileSelect(_event) {
            FudgeCore.Debug.fudge("-------------------------------- handleFileSelect");
            document.body.removeChild(FileIoBrowserLocal.selector);
            let fileList = _event.target.files;
            FudgeCore.Debug.fudge(fileList, fileList.length);
            if (fileList.length == 0)
                return;
            let loaded = {};
            await FileIoBrowserLocal.loadFiles(fileList, loaded);
            let event = new CustomEvent("fileLoaded" /* FILE_LOADED */, { detail: { mapFilenameToContent: loaded } });
            FileIoBrowserLocal.targetStatic.dispatchEvent(event);
        }
        static async loadFiles(_fileList, _loaded) {
            for (let file of _fileList) {
                const content = await new Response(file).text();
                _loaded[file.name] = content;
            }
        }
    }
    FudgeCore.FileIoBrowserLocal = FileIoBrowserLocal;
})(FudgeCore || (FudgeCore = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRnVkZ2VDb3JlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vU291cmNlL0RlYnVnL0RlYnVnVGFyZ2V0LnRzIiwiLi4vU291cmNlL0V2ZW50L0V2ZW50LnRzIiwiLi4vU291cmNlL1RyYW5zZmVyL011dGFibGUudHMiLCIuLi9Tb3VyY2UvVHJhbnNmZXIvU2VyaWFsaXplci50cyIsIi4uL1NvdXJjZS9SZW5kZXIvUmVuZGVySW5qZWN0b3IudHMiLCIuLi9Tb3VyY2UvUmVuZGVyL1JlbmRlckluamVjdG9yQ29hdC50cyIsIi4uL1NvdXJjZS9SZW5kZXIvUmVuZGVySW5qZWN0b3JNZXNoLnRzIiwiLi4vU291cmNlL1JlbmRlci9SZW5kZXJPcGVyYXRvci50cyIsIi4uL1NvdXJjZS9SZWZlcmVuY2VzLnRzIiwiLi4vU291cmNlL0FuaW1hdGlvbi9BbmltYXRpb24udHMiLCIuLi9Tb3VyY2UvQW5pbWF0aW9uL0FuaW1hdGlvbkZ1bmN0aW9uLnRzIiwiLi4vU291cmNlL0FuaW1hdGlvbi9BbmltYXRpb25LZXkudHMiLCIuLi9Tb3VyY2UvQW5pbWF0aW9uL0FuaW1hdGlvblNlcXVlbmNlLnRzIiwiLi4vU291cmNlL0F1ZGlvL0F1ZGlvLnRzIiwiLi4vU291cmNlL0F1ZGlvL0F1ZGlvTWFuYWdlci50cyIsIi4uL1NvdXJjZS9BdWRpby9BdWRpb09zY2lsbGF0b3IudHMiLCIuLi9Tb3VyY2UvQ29hdC9Db2F0LnRzIiwiLi4vU291cmNlL0NvYXQvQ29hdFRleHR1cmVkLnRzIiwiLi4vU291cmNlL0NvbXBvbmVudC9Db21wb25lbnQudHMiLCIuLi9Tb3VyY2UvQ29tcG9uZW50L0NvbXBvbmVudEFuaW1hdG9yLnRzIiwiLi4vU291cmNlL0NvbXBvbmVudC9Db21wb25lbnRBdWRpby50cyIsIi4uL1NvdXJjZS9Db21wb25lbnQvQ29tcG9uZW50QXVkaW9MaXN0ZW5lci50cyIsIi4uL1NvdXJjZS9Db21wb25lbnQvQ29tcG9uZW50Q2FtZXJhLnRzIiwiLi4vU291cmNlL0NvbXBvbmVudC9Db21wb25lbnRMaWdodC50cyIsIi4uL1NvdXJjZS9Db21wb25lbnQvQ29tcG9uZW50TWF0ZXJpYWwudHMiLCIuLi9Tb3VyY2UvQ29tcG9uZW50L0NvbXBvbmVudE1lc2gudHMiLCIuLi9Tb3VyY2UvQ29tcG9uZW50L0NvbXBvbmVudFNjcmlwdC50cyIsIi4uL1NvdXJjZS9Db21wb25lbnQvQ29tcG9uZW50VHJhbnNmb3JtLnRzIiwiLi4vU291cmNlL0NvbnRyb2wvQXhpcy50cyIsIi4uL1NvdXJjZS9EZWJ1Zy9EZWJ1Z0ludGVyZmFjZXMudHMiLCIuLi9Tb3VyY2UvRGVidWcvRGVidWdDb25zb2xlLnRzIiwiLi4vU291cmNlL0RlYnVnL0RlYnVnLnRzIiwiLi4vU291cmNlL0RlYnVnL0RlYnVnQWxlcnQudHMiLCIuLi9Tb3VyY2UvRGVidWcvRGVidWdEaWFsb2cudHMiLCIuLi9Tb3VyY2UvRGVidWcvRGVidWdUZXh0QXJlYS50cyIsIi4uL1NvdXJjZS9FbmdpbmUvQ29sb3IudHMiLCIuLi9Tb3VyY2UvRW5naW5lL01hdGVyaWFsLnRzIiwiLi4vU291cmNlL0VuZ2luZS9SZWN5Y2xlci50cyIsIi4uL1NvdXJjZS9FbmdpbmUvUmVzb3VyY2VNYW5hZ2VyLnRzIiwiLi4vU291cmNlL0VuZ2luZS9WaWV3cG9ydC50cyIsIi4uL1NvdXJjZS9FdmVudC9FdmVudEF1ZGlvLnRzIiwiLi4vU291cmNlL0V2ZW50L0V2ZW50RHJhZ0Ryb3AudHMiLCIuLi9Tb3VyY2UvRXZlbnQvRXZlbnRLZXlib2FyZC50cyIsIi4uL1NvdXJjZS9FdmVudC9FdmVudFBvaW50ZXIudHMiLCIuLi9Tb3VyY2UvRXZlbnQvRXZlbnRUaW1lci50cyIsIi4uL1NvdXJjZS9FdmVudC9FdmVudFdoZWVsLnRzIiwiLi4vU291cmNlL0xpZ2h0L0xpZ2h0LnRzIiwiLi4vU291cmNlL01hdGgvRnJhbWluZy50cyIsIi4uL1NvdXJjZS9NYXRoL01hdHJpeDN4My50cyIsIi4uL1NvdXJjZS9NYXRoL01hdHJpeDR4NC50cyIsIi4uL1NvdXJjZS9NYXRoL1JhbmRvbS50cyIsIi4uL1NvdXJjZS9NYXRoL1JlY3RhbmdsZS50cyIsIi4uL1NvdXJjZS9NYXRoL1ZlY3RvcjIudHMiLCIuLi9Tb3VyY2UvTWF0aC9WZWN0b3IzLnRzIiwiLi4vU291cmNlL01lc2gvTWVzaC50cyIsIi4uL1NvdXJjZS9NZXNoL01lc2hDdWJlLnRzIiwiLi4vU291cmNlL01lc2gvTWVzaEhlaWdodE1hcC50cyIsIi4uL1NvdXJjZS9NZXNoL01lc2hPcGVyYXRpb25zLnRzIiwiLi4vU291cmNlL01lc2gvTWVzaFB5cmFtaWQudHMiLCIuLi9Tb3VyY2UvTWVzaC9NZXNoUXVhZC50cyIsIi4uL1NvdXJjZS9NZXNoL01lc2hTcGhlcmUudHMiLCIuLi9Tb3VyY2UvTWVzaC9NZXNoU3ByaXRlLnRzIiwiLi4vU291cmNlL05vZGUvTm9kZS50cyIsIi4uL1NvdXJjZS9Ob2RlL05vZGVSZXNvdXJjZS50cyIsIi4uL1NvdXJjZS9Ob2RlL05vZGVSZXNvdXJjZUluc3RhbmNlLnRzIiwiLi4vU291cmNlL1JheS9SYXkudHMiLCIuLi9Tb3VyY2UvUmF5L1JheUhpdC50cyIsIi4uL1NvdXJjZS9SZW5kZXIvUmVuZGVyTWFuYWdlci50cyIsIi4uL1NvdXJjZS9TaGFkZXIvU2hhZGVyLnRzIiwiLi4vU291cmNlL1NoYWRlci9TaGFkZXJGbGF0LnRzIiwiLi4vU291cmNlL1NoYWRlci9TaGFkZXJNYXRDYXAudHMiLCIuLi9Tb3VyY2UvU2hhZGVyL1NoYWRlclJheUNhc3QudHMiLCIuLi9Tb3VyY2UvU2hhZGVyL1NoYWRlclRleHR1cmUudHMiLCIuLi9Tb3VyY2UvU2hhZGVyL1NoYWRlclVuaUNvbG9yLnRzIiwiLi4vU291cmNlL1RleHR1cmUvVGV4dHVyZS50cyIsIi4uL1NvdXJjZS9UaW1lL0xvb3AudHMiLCIuLi9Tb3VyY2UvVGltZS9UaW1lLnRzIiwiLi4vU291cmNlL1RpbWUvVGltZXIudHMiLCIuLi9Tb3VyY2UvVHJhbnNmZXIvRmlsZUlvQnJvd3NlckxvY2FsLnRzIl0s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QUMsQ0FBQyxDQUFDO1lBQ3JDLElBQUksR0FBRyxHQUFXLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUNyQyxJQUFJLEdBQUcsR0FBVyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDckMsSUFBSSxHQUFHLEdBQVcsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQ3JDLElBQUksR0FBRyxHQUFXLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUNyQyxJQUFJLEdBQUcsR0FBVyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDckMsSUFBSSxHQUFHLEdBQVcsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQ3JDLElBQUksR0FBRyxHQUFXLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUNyQyxJQUFJLEdBQUcsR0FBVyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDckMsSUFBSSxNQUFNLEdBQWMsSUFBSSxTQUFTLENBQUM7WUFDdEMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUM7Z0JBQ2QsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2dCQUNqQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7Z0JBQ2pDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztnQkFDakMsR0FBRyxHQUFHLEdBQUcs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LENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUNiO2dCQUNFLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2dCQUM3QyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztnQkFDN0MsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7Z0JBQzdDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2dCQUM3QyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztnQkFDN0MsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7Z0JBQzdDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2dCQUM3QyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztnQkFDN0MsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7Z0JBQzdDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2dCQUM3QyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztnQkFDN0MsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7Z0JBQzdDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2dCQUM3QyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztnQkFDN0MsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7Z0JBQzdDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2FBQzlDLENBQUMsQ0FBQztZQUNMLE9BQU8sTUFBTSxDQUFDO1FBQ2hCLENBQUM7UUFFRDs7O1dBR0c7UUFDSSxNQUFNLENBQUMsU0FBUyxDQUFDLE9BQWtCO1lBQ3hDLElBQUksQ0FBQyxHQUFpQixPQUFPLENBQUMsSUFBSSxDQUFDO1lBQ25DLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksSUFBSSxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDN0IsSUFBSSxJQUFJLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM3QixJQUFJLElBQUksR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzdCLElBQUksSUFBSSxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDN0IsSUFBSSxJQUFJLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM3QixJQUFJLElBQUksR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzdCLElBQUksSUFBSSxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDN0IsSUFBSSxJQUFJLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM3QixJQUFJLElBQUksR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzdCLElBQUksSUFBSSxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDN0IsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzlCLElBQUksS0FBSyxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDOUIsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzlCLElBQUksS0FBSyxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDOUIsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzlCLElBQUksS0FBSyxHQUFXLEdBQUcsR0FBRyxHQUFH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S0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUN2RixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUMzRixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUMzRixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUMzRixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUMzRixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUMzRixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUMzRixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUMzRixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUUsT0FBTzthQUNyRyxDQUFDLENBQUM7WUFDSCxPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO1FBRUQ7Ozs7V0FJRztRQUNJLE1BQU0sQ0FBQyxPQUFPLENBQUMsa0JBQTJCLEVBQUUsZUFBd0IsRUFBRSxNQUFlLFVBQUEsT0FBTyxDQUFDLENBQUMsRUFBRTtZQUNyRywyQ0FBMkM7WUFDM0MsTUFBTSxNQUFNLEdBQWMsVUFBQSxRQUFRLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQ2xELElBQUksS0FBSyxHQUFZLFVBQUEsT0FBTyxDQUFDLFVBQVUsQ0FBQyxlQUFlLEVBQUUsa0JBQWtCLENBQUMsQ0FBQztZQUM3RSxLQUFLLENBQUMsU0FBUyxFQUFFLENBQUM7WUFDbEIsSUFBSSxLQUFLLEdBQVksVUFBQSxPQUFPLENBQUMsYUFBYSxDQUFDLFVBQUEsT0FBTyxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQztZQUN0RSxJQUFJLEtBQUssR0FBWSxVQUFBLE9BQU8sQ0FBQyxhQUFhLENBQUMsVUFBQSxPQUFPLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQ3hFLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUNiO2dCQUNFLEtBQUssQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUM7Z0JBQzVCLEtBQUssQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUM7Z0JBQzVCLEtBQUssQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUM7Z0JBQzVCLGtCQUFrQixDQUFDLENBQUM7Z0JBQ3BCLGtCQUFrQixDQUFDLENBQUM7Z0JBQ3BCLGtCQUFrQixDQUFDLENBQUM7Z0JBQ3BCLENBQUM7YUFDRixDQUFDLENBQUM7WUFDTCxPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO1FBRUQ7O1dBRUc7UUFDSSxNQUFNLENBQUMsV0FBVyxDQUFDLFVBQW1CO1lBQzNDLHlDQUF5QztZQUN6QyxNQUFNLE1BQU0sR0FBYyxVQUFBLFFBQVEsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDbEQsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUM7Z0JBQ2QsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztnQkFDVixDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO2dCQUNWLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7Z0JBQ1YsVUFBVSxDQUFDLENBQUMsRUFBRSxVQUFVLENBQUMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxDQUFDLEVBQUUsQ0FBQzthQUM1QyxDQUFDLENBQUM7WUFDSCxPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO1FBRUQ7OztXQUdHO1FBQ0ksTUFBTSxDQUFDLFVBQVUsQ0FBQyxlQUF1QjtZQUM5QywyQ0FBMkM7WUFDM0MsTUFBTSxNQUFNLEdBQWMsVUFBQSxRQUFRLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQ2xELElBQUksY0FBYyxHQUFXLGVBQWUsR0FBRyxJQUFJLENBQUMsRUFBRSxHQUFHLEdBQUcsQ0FBQztZQUM3RCxJQUFJLEdBQUcsR0FBVyxJQUFJLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxDQUFDO1lBQzNDLElBQUksR0FBRyxHQUFXLElBQUksQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDLENBQUM7WUFDM0MsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUM7Z0JBQ2QsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztnQkFDVixDQUFDLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDO2dCQUNkLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQztnQkFDZixDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO2FBQ1gsQ0FBQyxDQUFDO1lBQ0gsT0FBTyxNQUFNLENBQUM7UUFDaEIsQ0FBQztRQUVEOzs7V0FHRztRQUNJLE1BQU0sQ0FBQyxVQUFVLENBQUMsZUFBdUI7WUFDOUMsMkNBQTJDO1lBQzNDLElBQUksTUFBTSxHQUFjLFVBQUEsUUFBUSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUNoRCxJQUFJLGNBQWMsR0FBVyxlQUFlLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxHQUFHLENBQUM7WUFDN0QsSUFBSSxHQUFHLEdBQVcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUMsQ0FBQztZQUMzQyxJQUFJLEdBQUcsR0FBVyxJQUFJLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxDQUFDO1lBQzNDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDO2dCQUNkLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQkFDZixDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO2dCQUNWLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUM7Z0JBQ2QsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQzthQUNYLENBQUMsQ0FBQztZQUNILE9BQU8sTUFBTSxDQUFDO1FBQ2hCLENBQUM7UUFFRDs7O1dBR0c7UUFDSSxNQUFNLENBQUMsVUFBVSxDQUFDLGVBQXVCO1lBQzlDLDJDQUEyQztZQUMzQyxNQUFNLE1BQU0sR0FBYyxVQUFBLFFBQVEsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDbEQsSUFBSSxjQUFjLEdBQVcsZUFBZSxHQUFHLElBQUksQ0FBQyxFQUFFLEdBQUcsR0FBRyxDQUFDO1lBQzdELElBQUksR0FBRyxHQUFXLElBQUksQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDLENBQUM7WUFDM0MsSUFBSSxHQUFHLEdBQVcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUMsQ0FBQztZQUMzQyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQztnQkFDZCxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDO2dCQUNkLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQztnQkFDZixDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO2dCQUNWLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7YUFDWCxDQUFDLENBQUM7WUFDSCxPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO1FBRUQ7O1dBRUc7UUFDSSxNQUFNLENBQUMsT0FBTyxDQUFDLE9BQWdCO1lBQ3BDLDJDQUEyQztZQUMzQyxNQUFNLE1BQU0sR0FBYyxVQUFBLFFBQVEsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDbEQsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUM7Z0JBQ2QsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7Z0JBQ2xCLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO2dCQUNsQixDQUFDLEVBQUUsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQztnQkFDbEIsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQzthQUNYLENBQUMsQ0FBQztZQUNILE9BQU8sTUFBTSxDQUFDO1FBQ2hCLENBQUM7UUFDRCxZQUFZO1FBRVoscUJBQXFCO1FBQ3JCOzs7Ozs7O1dBT0c7UUFDSSxNQUFNLENBQUMsa0JBQWtCLENBQUMsT0FBZSxFQUFFLHFCQUE2QixFQUFFLEtBQWEsRUFBRSxJQUFZLEVBQUUsVUFBeUI7WUFDckksa0VBQWtFO1lBQ2xFLElBQUksb0JBQW9CLEdBQVcscUJBQXFCLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxHQUFHLENBQUM7WUFDekUsSUFBSSxDQUFDLEdBQVcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHLG9CQUFvQixDQUFDLENBQUMsQ0FBQztZQUNqRSxJQUFJLFFBQVEsR0FBVyxHQUFHLEdBQUcsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLENBQUM7WUFDNUMsMkNBQTJDO1lBQzNDLE1BQU0sTUFBTSxHQUFjLFVBQUEsUUFBUSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUNsRCxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQztnQkFDZCxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO2dCQUNWLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7Z0JBQ1YsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxRQUFRLEVBQUUsQ0FBQyxDQUFDO2dCQUNuQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEtBQUssR0FBRyxJQUFJLEdBQUcsUUFBUSxHQUFHLENBQUMsRUFBRSxDQUFDO2FBQ3JDLENBQUMsQ0FBQztZQUVILElBQUksVUFBVSxJQUFJLFVBQUEsYUFBYSxDQUFDLFFBQVEsRUFBRTtnQkFDeEMsT0FBTyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBQzdCLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLE9BQU8sQ0FBQztnQkFDN0IsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsT0FBTyxDQUFDO2FBQzlCO2lCQUNJLElBQUksVUFBVSxJQUFJLFVBQUEsYUFBYSxDQUFDLFFBQVE7Z0JBQzNDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLE9BQU8sQ0FBQztpQkFDMUIsMEJBQTBCO2dCQUM3QixNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxPQUFPLENBQUM7WUFFL0Isb0hBQW9IO1lBQ3BILE1BQU0sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7WUFFcEIsT0FBTyxNQUFNLENBQUM7UUFDaEIsQ0FBQztRQUVEOzs7Ozs7OztXQVFHO1FBQ0ksTUFBTSxDQUFDLHVCQUF1QixDQUFDLEtBQWEsRUFBRSxNQUFjLEVBQUUsT0FBZSxFQUFFLElBQVksRUFBRSxRQUFnQixDQUFDLEdBQUcsRUFBRSxPQUFlLEdBQUc7WUFDMUksMkNBQTJDO1lBQzNDLE1BQU0sTUFBTSxHQUFjLFVBQUEsUUFBUSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUNsRCxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQztnQkFDZCxDQUFDLEdBQUcsQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO2dCQUM3QixDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO2dCQUM3QixDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDO2dCQUMzQixDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUM7Z0JBQ25DLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztnQkFDbkMsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO2dCQUMvQixDQUFDO2FBQ0YsQ0FBQyxDQUFDO1lBQ0gsT0FBTyxNQUFNLENBQUM7UUFDaEIsQ0FBQztRQUNELFlBQVk7UUFFWixrQkFBa0I7UUFDbEI7OztXQUdHO1FBQ0ksTUFBTSxDQUFDLEdBQVksRUFBRSxZQUFxQixLQUFLO1lBQ3BELElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQztZQUMvQixJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUM7WUFDL0IsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDO1FBQ2pDLENBQUM7UUFFRDs7V0FFRztRQUNJLE9BQU8sQ0FBQyxlQUF1QixFQUFFLFlBQXFCLEtBQUs7WUFDaEUsSUFBSSxRQUFRLEdBQWMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxlQUFlLENBQUMsQ0FBQztZQUNoRSxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsRUFBRSxTQUFTLENBQUMsQ0FBQztZQUNuQyxVQUFBLFFBQVEsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDM0IsQ0FBQztRQUVEOztXQUVHO1FBQ0ksT0FBTyxDQUFDLGVBQXVCLEVBQUUsWUFBcUIsS0FBSztZQUNoRSxJQUFJLFFBQVEsR0FBYyxTQUFTLENBQUMsVUFBVSxDQUFDLGVBQWUsQ0FBQyxDQUFDO1lBQ2hFLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1lBQ25DLFVBQUEsUUFBUSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUMzQixDQUFDO1FBRUQ7O1dBRUc7UUFDSSxPQUFPLENBQUMsZUFBdUIsRUFBRSxZQUFxQixLQUFLO1lBQ2hFLElBQUksUUFBUSxHQUFjLFNBQVMsQ0FBQyxVQUFVLENBQUMsZUFBZSxDQUFDLENBQUM7WUFDaEUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLEVBQUUsU0FBUyxDQUFDLENBQUM7WUFDbkMsVUFBQSxRQUFRLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQzNCLENBQUM7UUFFRDs7V0FFRztRQUNJLE1BQU0sQ0FBQyxPQUFnQixFQUFFLE1BQWUsVUFBQSxPQUFPLENBQUMsQ0FBQyxFQUFFO1lBQ3hELE1BQU0sTUFBTSxHQUFjLFNBQVMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLHNDQUFzQztZQUM5RyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ2pCLFVBQUEsUUFBUSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUN6QixDQUFDO1FBQ0QsWUFBWTtRQUVaLHFCQUFxQjtRQUNyQjs7V0FFRztRQUNJLFNBQVMsQ0FBQyxHQUFZO1lBQzNCLE1BQU0sTUFBTSxHQUFjLFNBQVMsQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUNyRixxRkFBcUY7WUFDckYsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUNqQixVQUFBLFFBQVEsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDekIsQ0FBQztRQUVEOztXQUVHO1FBQ0ksVUFBVSxDQUFDLEVBQVU7WUFDMUIsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDcEIsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7WUFDcEIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDO1FBQ2xDLENBQUM7UUFDRDs7V0FFRztRQUNJLFVBQVUsQ0FBQyxFQUFVO1lBQzFCLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksRUFBRSxDQUFDO1lBQ3BCLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO1lBQ3BCLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQztRQUNsQyxDQUFDO1FBQ0Q7O1dBRUc7UUFDSSxVQUFVLENBQUMsRUFBVTtZQUMxQixJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUNwQixJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztZQUNwQixJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUM7UUFDbEMsQ0FBQztRQUNELFlBQVk7UUFFWixpQkFBaUI7UUFDakI7O1dBRUc7UUFDSSxLQUFLLENBQUMsR0FBWTtZQUN2QixNQUFNLE1BQU0sR0FBYyxTQUFTLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDakYsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUNqQixVQUFBLFFBQVEsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDekIsQ0FBQztRQUNEOztXQUVHO1FBQ0ksTUFBTSxDQUFDLEdBQVc7WUFDdkIsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLFVBQUEsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNyQyxDQUFDO1FBQ0Q7O1dBRUc7UUFDSSxNQUFNLENBQUMsR0FBVztZQUN2QixJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksVUFBQSxPQUFPLENBQUMsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3JDLENBQUM7UUFDRDs7V0FFRztRQUNJLE1BQU0sQ0FBQyxHQUFXO1lBQ3ZCLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxVQUFBLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDckMsQ0FBQztRQUNELFlBQVk7UUFFWix3QkFBd0I7UUFDeEI7O1dBRUc7UUFDSSxRQUFRLENBQUMsT0FBa0IsRUFBRSxZQUFxQixLQUFLO1lBQzVELE1BQU0sTUFBTSxHQUFjLFNBQVMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLGNBQWMsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBQ3hILElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDakIsVUFBQSxRQUFRLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3pCLENBQUM7UUFDRCxZQUFZO1FBRVosa0JBQWtCO1FBQ2xCOztXQUVHO1FBQ0ksY0FBYztZQUNuQixJQUFJLE9BQU8sR0FBWSxJQUFJLENBQUMsT0FBTyxDQUFDO1lBRXBDLElBQUksRUFBRSxHQUFXLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQztZQUMxQyxJQUFJLEVBQUUsR0FBVyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUM7WUFDMUMsSUFBSSxFQUFFLEdBQVcsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDO1lBQzFDLElBQUksRUFBRSxHQUFXLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQztZQUMxQyxJQUFJLEdBQUcsR0FBVyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUM7WUFFNUMsSUFBSSxFQUFFLEdBQVcsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyx1REFBdUQ7WUFFNUYsSUFBSSxRQUFRLEdBQVksRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFDLEtBQUs7WUFFeEMsSUFBSSxFQUFVLEVBQUUsRUFBVSxFQUFFLEVBQVUsQ0FBQztZQUN2QyxJQUFJLEVBQVUsRUFBRSxFQUFVLEVBQUUsRUFBVSxDQUFDO1lBRXZDLElBQUksQ0FBQyxRQUFRLEVBQUU7Z0JBQ2IsRUFBRSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLEdBQUcsQ0FBQyxDQUFDO2dCQUN6QixFQUFFLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztnQkFDekIsRUFBRSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO2dCQUV4QixFQUFFLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUMzQixFQUFFLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO2dCQUMxQixFQUFFLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO2dCQUUxQixJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFO29CQUMzRixFQUFFLEdBQUcsRUFBRSxDQUFDO29CQUNSLEVBQUUsR0FBRyxFQUFFLENBQUM7b0JBQ1IsRUFBRSxHQUFHLEVBQUUsQ0FBQztpQkFDVDthQUNGO2lCQUNJO2dCQUNILEVBQUUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNyRSxFQUFFLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztnQkFDL0MsRUFBRSxHQUFHLENBQUMsQ0FBQzthQUNSO1lBRUQsSUFBSSxRQUFRLEdBQVksSUFBSSxVQUFBLE9BQU8sQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQ2hELFFBQVEsQ0FBQyxLQUFLLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUU5QixPQUFPLFFBQVEsQ0FBQztRQUNsQixDQUFDO1FBRUQ7O1dBRUc7UUFDSSxHQUFHLENBQUMsR0FBYztZQUN2Qix5QkFBeUI7WUFDekIsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ3hCLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUNwQixDQUFDO1FBRU0sUUFBUTtZQUNiLE9BQU8sNEJBQTRCLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxFQUFFLGVBQWUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLEVBQUUsY0FBYyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUM7UUFDL0ksQ0FBQztRQUVEOztXQUVHO1FBQ0ksR0FBRztZQUNSLE9BQU8sSUFBSSxZQUFZLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3JDLENBQUM7UUFFTSxTQUFTO1lBQ2QseUZBQXlGO1lBQ3pGLElBQUksYUFBYSxHQUFrQixJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7WUFDckQsT0FBTyxhQUFhLENBQUM7UUFDdkIsQ0FBQztRQUNNLFdBQVcsQ0FBQyxjQUE2QjtZQUM5QyxJQUFJLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1lBQzVCLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVNLFVBQVU7WUFDZixJQUFJLElBQUksQ0FBQyxPQUFPO2dCQUNkLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQztZQUV0QixJQUFJLE9BQU8sR0FBWTtnQkFDckIsV0FBVyxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsVUFBVSxFQUFFO2dCQUMxQyxRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLEVBQUU7Z0JBQ3BDLE9BQU8sRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsRUFBRTthQUNuQyxDQUFDO1lBRUYsZ0JBQWdCO1lBQ2hCLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO1lBQ3ZCLE9BQU8sT0FBTyxDQUFDO1FBQ2pCLENBQUM7UUFFTSxNQUFNLENBQUMsUUFBaUI7WUFDN0IsSUFBSSxjQUFjLEdBQVksSUFBSSxDQUFDLFdBQVcsQ0FBQztZQUMvQyxJQUFJLFdBQVcsR0FBWSxJQUFJLENBQUMsUUFBUSxDQUFDO1lBQ3pDLElBQUksVUFBVSxHQUFZLElBQUksQ0FBQyxPQUFPLENBQUM7WUFDdkMsSUFBSSxjQUFjLEdBQXFCLFFBQVEsQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUMvRCxJQUFJLFdBQVcsR0FBcUIsUUFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQ3pELElBQUksVUFBVSxHQUFxQixRQUFRLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDdkQsSUFBSSxPQUFPLEdBQXlCLEVBQUUsV0FBVyxFQUFFLGNBQWMsRUFBRSxRQUFRLEVBQUUsV0FBVyxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsQ0FBQztZQUNoSCxJQUFJLGNBQWMsRUFBRTtnQkFDbEIsT0FBTyxDQUFDLFdBQVcsR0FBRyxJQUFJLFVBQUEsT0FBTyxDQUMvQixjQUFjLENBQUMsQ0FBQyxJQUFJLFNBQVMsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLENBQUMsRUFDbkUsY0FBYyxDQUFDLENBQUMsSUFBSSxTQUFTLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxDQUFDLEVBQ25FLGNBQWMsQ0FBQyxDQUFDLElBQUksU0FBUyxDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUNwRSxDQUFDO2FBQ0g7WUFDRCxJQUFJLFdBQVcsRUFBRTtnQkFDZixPQUFPLENBQUMsUUFBUSxHQUFHLElBQUksVUFBQSxPQUFPLENBQzVCLFdBQVcsQ0FBQyxDQUFDLElBQUksU0FBUyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxFQUMxRCxXQUFXLENBQUMsQ0FBQyxJQUFJLFNBQVMsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsRUFDMUQsV0FBVyxDQUFDLENBQUMsSUFBSSxTQUFTLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQzNELENBQUM7YUFDSDtZQUNELElBQUksVUFBVSxFQUFFO2dCQUNkLE9BQU8sQ0FBQyxPQUFPLEdBQUcsSUFBSSxVQUFBLE9BQU8sQ0FDM0IsVUFBVSxDQUFDLENBQUMsSUFBSSxTQUFTLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLEVBQ3ZELFVBQVUsQ0FBQyxDQUFDLElBQUksU0FBUyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxFQUN2RCxVQUFVLENBQUMsQ0FBQyxJQUFJLFNBQVMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FDeEQsQ0FBQzthQUNIO1lBRUQsaUtBQWlLO1lBQ2pLLElBQUksTUFBTSxHQUFjLFNBQVMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUM3QyxJQUFJLE9BQU8sQ0FBQyxXQUFXO2dCQUNyQixNQUFNLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUN4QyxJQUFJLE9BQU8sQ0FBQyxRQUFRLEVBQUU7Z0JBQ3BCLE1BQU0sQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDbkMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNuQyxNQUFNLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDcEM7WUFDRCxJQUFJLE9BQU8sQ0FBQyxPQUFPO2dCQUNqQixNQUFNLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUNoQyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBRWpCLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO1FBQ3pCLENBQUM7UUFFTSx3QkFBd0IsQ0FBQyxRQUFpQjtZQUMvQyxJQUFJLEtBQUssR0FBMEIsRUFBRSxDQUFDO1lBQ3RDLElBQUksUUFBUSxDQUFDLFdBQVc7Z0JBQUUsS0FBSyxDQUFDLFdBQVcsR0FBRyxTQUFTLENBQUM7WUFDeEQsSUFBSSxRQUFRLENBQUMsUUFBUTtnQkFBRSxLQUFLLENBQUMsUUFBUSxHQUFHLFNBQVMsQ0FBQztZQUNsRCxJQUFJLFFBQVEsQ0FBQyxPQUFPO2dCQUFFLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxDQUFDO1lBQ2hELE9BQU8sS0FBSyxDQUFDO1FBQ2YsQ0FBQztRQUNTLGFBQWEsQ0FBQyxRQUFpQixJQUFnQixDQUFDO1FBRWxELFVBQVU7WUFDaEIsSUFBSSxDQUFDLE9BQU8sR0FBRyxFQUFFLFdBQVcsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUM7WUFDcEUsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7UUFDdEIsQ0FBQztLQUNGO0lBdnFCWSxtQkFBUyxZQXVxQnJCLENBQUE7SUFDRCxZQUFZO0FBQ2QsQ0FBQyxFQWhzQlMsU0FBUyxLQUFULFNBQVMsUUFnc0JsQjtBQ2hzQkQsSUFBVSxTQUFTLENBNkdsQjtBQTdHRCxXQUFVLFNBQVM7SUFDakI7Ozs7O09BS0c7SUFDSCxNQUFhLE1BQU07UUFJakI7Ozs7V0FJRztRQUNILFlBQVksZ0JBQXlCLEtBQUssRUFBRSxRQUFnQixJQUFJLENBQUMsTUFBTSxFQUFFO1lBUGpFLGFBQVEsR0FBYSxJQUFJLENBQUMsTUFBTSxDQUFDO1lBUXZDLElBQUksYUFBYTtnQkFDZixJQUFJLENBQUMsUUFBUSxHQUFHLE1BQU0sQ0FBQyxlQUFlLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDbEQsQ0FBQztRQUVEOztXQUVHO1FBQ0ksTUFBTSxDQUFDLGVBQWUsQ0FBQyxLQUFhO1lBQ3pDLDhFQUE4RTtZQUM5RSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUM7UUFDckIsQ0FBQztRQUVEOztXQUVHO1FBQ0ksT0FBTztZQUNaLE9BQU8sSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ3pCLENBQUM7UUFFRDs7V0FFRztRQUNJLFFBQVEsQ0FBQyxJQUFZLEVBQUUsSUFBWTtZQUN4QyxPQUFPLElBQUksR0FBRyxJQUFJLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLENBQUM7UUFDaEQsQ0FBQztRQUVEOztXQUVHO1FBQ0ksZUFBZSxDQUFDLElBQVksRUFBRSxJQUFZO1lBQy9DLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQy9DLENBQUM7UUFFRDs7V0FFRztRQUNJLFVBQVU7WUFDZixPQUFPLElBQUksQ0FBQyxRQUFRLEVBQUUsR0FBRyxHQUFHLENBQUM7UUFDL0IsQ0FBQztRQUVEOztXQUVHO1FBQ0ksT0FBTztZQUNaLE9BQU8sSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3BDLENBQUM7UUFFRDs7V0FFRztRQUNJLFFBQVEsQ0FBSSxNQUFnQjtZQUNqQyxJQUFJLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQztnQkFDbkIsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDaEQsT0FBTyxDQUFDLENBQUMsQ0FBQztRQUNaLENBQUM7UUFFRDs7V0FFRztRQUNJLE1BQU0sQ0FBSSxNQUFnQjtZQUMvQixPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNwRCxDQUFDO1FBRUQ7O1dBRUc7UUFDSSxNQUFNLENBQU8sSUFBZTtZQUNqQyxJQUFJLElBQUksR0FBWSxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO1lBQzVDLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUNuQyxDQUFDO1FBRUQ7O1dBRUc7UUFDSSxlQUFlLENBQUMsT0FBZTtZQUNwQyxJQUFJLElBQUksR0FBYSxNQUFNLENBQUMsbUJBQW1CLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDekQsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ25DLENBQUM7UUFFRDs7V0FFRztRQUNJLGlCQUFpQixDQUFDLE9BQWU7WUFDdEMsSUFBSSxJQUFJLEdBQWEsTUFBTSxDQUFDLHFCQUFxQixDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQzNELE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUNuQyxDQUFDOztJQTlGYSxjQUFPLEdBQVcsSUFBSSxNQUFNLEVBQUUsQ0FBQztJQURsQyxnQkFBTSxTQWdHbEIsQ0FBQTtJQUVEOztPQUVHO0lBQ1UsZ0JBQU0sR0FBVyxJQUFJLE1BQU0sRUFBRSxDQUFDO0FBQzdDLENBQUMsRUE3R1MsU0FBUyxLQUFULFNBQVMsUUE2R2xCO0FDN0dELElBQVUsU0FBUyxDQXFLbEI7QUFyS0QsV0FBVSxTQUFTO0lBQ2pCOztPQUVHO0lBQ0gsSUFBWSxRQVVYO0lBVkQsV0FBWSxRQUFRO1FBQ2xCLDZDQUFjLENBQUE7UUFDZCxpREFBZ0IsQ0FBQTtRQUNoQiwrQ0FBZSxDQUFBO1FBQ2Ysb0RBQWlCLENBQUE7UUFDakIsNENBQWEsQ0FBQTtRQUNiLHNEQUFrQixDQUFBO1FBQ2xCLG9EQUFpQixDQUFBO1FBQ2pCLHdEQUFtQixDQUFBO1FBQ25CLHNEQUFrQixDQUFBO0lBQ3BCLENBQUMsRUFWVyxRQUFRLEdBQVIsa0JBQVEsS0FBUixrQkFBUSxRQVVuQjtJQUVEOzs7T0FHRztJQUNILE1BQWEsU0FBVSxTQUFRLFVBQUEsT0FBTztRQUlwQyxZQUFZLEtBQWEsQ0FBQyxFQUFFLEtBQWEsQ0FBQyxFQUFFLFNBQWlCLENBQUMsRUFBRSxVQUFrQixDQUFDLEVBQUUsVUFBb0IsUUFBUSxDQUFDLE9BQU87WUFDdkgsS0FBSyxFQUFFLENBQUM7WUFKSCxhQUFRLEdBQVksVUFBQSxRQUFRLENBQUMsR0FBRyxDQUFDLFVBQUEsT0FBTyxDQUFDLENBQUM7WUFDMUMsU0FBSSxHQUFZLFVBQUEsUUFBUSxDQUFDLEdBQUcsQ0FBQyxVQUFBLE9BQU8sQ0FBQyxDQUFDO1lBSTNDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDNUQsQ0FBQztRQUVEOztXQUVHO1FBQ0ksTUFBTSxDQUFDLEdBQUcsQ0FBQyxLQUFhLENBQUMsRUFBRSxLQUFhLENBQUMsRUFBRSxTQUFpQixDQUFDLEVBQUUsVUFBa0IsQ0FBQyxFQUFFLFVBQW9CLFFBQVEsQ0FBQyxPQUFPO1lBQzdILElBQUksSUFBSSxHQUFjLFVBQUEsUUFBUSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUM5QyxJQUFJLENBQUMsa0JBQWtCLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsT0FBTyxDQUFDLENBQUM7WUFDakQsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO1FBRUQ7O1dBRUc7UUFDSSxrQkFBa0IsQ0FBQyxLQUFhLENBQUMsRUFBRSxLQUFhLENBQUMsRUFBRSxTQUFpQixDQUFDLEVBQUUsVUFBa0IsQ0FBQyxFQUFFLFVBQW9CLFFBQVEsQ0FBQyxPQUFPO1lBQ3JJLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQztZQUMvQixRQUFRLE9BQU8sR0FBRyxJQUFJLEVBQUU7Z0JBQ3RCLEtBQUssSUFBSTtvQkFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7b0JBQUMsTUFBTTtnQkFDdkMsS0FBSyxJQUFJO29CQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxNQUFNLEdBQUcsQ0FBQyxDQUFDO29CQUFDLE1BQU07Z0JBQ3BELEtBQUssSUFBSTtvQkFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsTUFBTSxDQUFDO29CQUFDLE1BQU07YUFDakQ7WUFDRCxRQUFRLE9BQU8sR0FBRyxJQUFJLEVBQUU7Z0JBQ3RCLEtBQUssSUFBSTtvQkFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7b0JBQUMsTUFBTTtnQkFDdkMsS0FBSyxJQUFJO29CQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxPQUFPLEdBQUcsQ0FBQyxDQUFDO29CQUFDLE1BQU07Z0JBQ3JELEtBQUssSUFBSTtvQkFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsT0FBTyxDQUFDO29CQUFDLE1BQU07YUFDbEQ7UUFDSCxDQUFDO1FBRU0sV0FBVyxDQUFDLE1BQWUsRUFBRSxPQUFrQjtZQUNwRCxJQUFJLE1BQU0sR0FBWSxNQUFNLENBQUMsSUFBSSxDQUFDO1lBQ2xDLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQy9CLE1BQU0sQ0FBQyxDQUFDLElBQUksT0FBTyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO1lBQ3ZDLE1BQU0sQ0FBQyxDQUFDLElBQUksT0FBTyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO1lBQ3pDLE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQzdCLE9BQU8sTUFBTSxDQUFDO1FBQ2hCLENBQUM7UUFFRCxJQUFJLENBQUM7WUFDSCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1FBQ3pCLENBQUM7UUFDRCxJQUFJLENBQUM7WUFDSCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1FBQ3pCLENBQUM7UUFDRCxJQUFJLEtBQUs7WUFDUCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ3JCLENBQUM7UUFDRCxJQUFJLE1BQU07WUFDUixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ3JCLENBQUM7UUFFRDs7V0FFRztRQUNILElBQUksSUFBSTtZQUNOLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQztnQkFDakIsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUN6QixPQUFPLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN6QyxDQUFDO1FBQ0Q7O1dBRUc7UUFDSCxJQUFJLEdBQUc7WUFDTCxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUM7Z0JBQ2pCLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7WUFDekIsT0FBTyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDekMsQ0FBQztRQUNEOztXQUVHO1FBQ0gsSUFBSSxLQUFLO1lBQ1AsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDO2dCQUNqQixPQUFPLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN6QyxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1FBQ3pCLENBQUM7UUFDRDs7V0FFRztRQUNILElBQUksTUFBTTtZQUNSLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQztnQkFDakIsT0FBTyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDekMsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztRQUN6QixDQUFDO1FBRUQsSUFBSSxDQUFDLENBQUMsRUFBVTtZQUNkLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUN2QixDQUFDO1FBQ0QsSUFBSSxDQUFDLENBQUMsRUFBVTtZQUNkLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUN2QixDQUFDO1FBQ0QsSUFBSSxLQUFLLENBQUMsTUFBYztZQUN0QixJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUM7UUFDM0IsQ0FBQztRQUNELElBQUksTUFBTSxDQUFDLE9BQWU7WUFDeEIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDO1FBQzVCLENBQUM7UUFDRCxJQUFJLElBQUksQ0FBQyxNQUFjO1lBQ3JCLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDO1lBQ2xDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQztRQUMzQixDQUFDO1FBQ0QsSUFBSSxHQUFHLENBQUMsTUFBYztZQUNwQixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztZQUNuQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUM7UUFDM0IsQ0FBQztRQUNELElBQUksS0FBSyxDQUFDLE1BQWM7WUFDdEIsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDO1FBQ3pDLENBQUM7UUFDRCxJQUFJLE1BQU0sQ0FBQyxNQUFjO1lBQ3ZCLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQztRQUN6QyxDQUFDO1FBRUQsSUFBVyxJQUFJO1lBQ2IsT0FBTyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUNoRSxDQUFDO1FBRUQ7OztXQUdHO1FBQ0ksUUFBUSxDQUFDLE1BQWU7WUFDN0IsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksSUFBSSxNQUFNLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxLQUFLLElBQUksTUFBTSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsR0FBRyxJQUFJLE1BQU0sQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQzlHLENBQUM7UUFFTSxRQUFRLENBQUMsS0FBZ0I7WUFDOUIsSUFBSSxJQUFJLENBQUMsSUFBSSxHQUFHLEtBQUssQ0FBQyxLQUFLO2dCQUFFLE9BQU8sS0FBSyxDQUFDO1lBQzFDLElBQUksSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsSUFBSTtnQkFBRSxPQUFPLEtBQUssQ0FBQztZQUMxQyxJQUFJLElBQUksQ0FBQyxHQUFHLEdBQUcsS0FBSyxDQUFDLE1BQU07Z0JBQUUsT0FBTyxLQUFLLENBQUM7WUFDMUMsSUFBSSxJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQyxHQUFHO2dCQUFFLE9BQU8sS0FBSyxDQUFDO1lBQzFDLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVNLFFBQVE7WUFDYixJQUFJLE1BQU0sR0FBVyx3QkFBd0IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLEVBQUUsVUFBVSxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUM7WUFDdEcsTUFBTSxJQUFJLFVBQVUsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLFNBQVMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLFdBQVcsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLFlBQVksSUFBSSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztZQUN6SixPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO1FBRVMsYUFBYSxDQUFDLFFBQWlCLElBQWUsQ0FBQztLQUMxRDtJQWhKWSxtQkFBUyxZQWdKckIsQ0FBQTtBQUNILENBQUMsRUFyS1MsU0FBUyxLQUFULFNBQVMsUUFxS2xCO0FDcktELElBQVUsU0FBUyxDQW9SbEI7QUFwUkQsV0FBVSxTQUFTO0lBQ2pCOzs7Ozs7O09BT0c7SUFDSCxNQUFhLE9BQVEsU0FBUSxVQUFBLE9BQU87UUFHbEMsWUFBbUIsS0FBYSxDQUFDLEVBQUUsS0FBYSxDQUFDO1lBQy9DLEtBQUssRUFBRSxDQUFDO1lBQ1IsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLFlBQVksQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3pDLENBQUM7UUFFRCxJQUFJLENBQUM7WUFDSCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdEIsQ0FBQztRQUNELElBQUksQ0FBQztZQUNILE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN0QixDQUFDO1FBRUQsSUFBSSxDQUFDLENBQUMsRUFBVTtZQUNkLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQ3BCLENBQUM7UUFDRCxJQUFJLENBQUMsQ0FBQyxFQUFVO1lBQ2QsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDcEIsQ0FBQztRQUVEOztXQUVHO1FBQ0gsSUFBSSxTQUFTO1lBQ1gsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2xDLENBQUM7UUFFRDs7V0FFRztRQUNILElBQUksZ0JBQWdCO1lBQ2xCLE9BQU8sT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDakMsQ0FBQztRQUVEOzs7V0FHRztRQUNJLE1BQU0sQ0FBQyxJQUFJO1lBQ2hCLElBQUksTUFBTSxHQUFZLElBQUksT0FBTyxFQUFFLENBQUM7WUFDcEMsT0FBTyxNQUFNLENBQUM7UUFDaEIsQ0FBQztRQUVEOzs7V0FHRztRQUNJLE1BQU0sQ0FBQyxHQUFHLENBQUMsU0FBaUIsQ0FBQztZQUNsQyxJQUFJLE1BQU0sR0FBWSxJQUFJLE9BQU8sQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7WUFDbEQsT0FBTyxNQUFNLENBQUM7UUFDaEIsQ0FBQztRQUVEOzs7O1dBSUc7UUFDSSxNQUFNLENBQUMsQ0FBQyxDQUFDLFNBQWlCLENBQUM7WUFDaEMsSUFBSSxNQUFNLEdBQVksSUFBSSxPQUFPLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1lBQzdDLE9BQU8sTUFBTSxDQUFDO1FBQ2hCLENBQUM7UUFFRDs7OztXQUlHO1FBQ0ksTUFBTSxDQUFDLENBQUMsQ0FBQyxTQUFpQixDQUFDO1lBQ2hDLElBQUksTUFBTSxHQUFZLElBQUksT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQztZQUM3QyxPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO1FBRU0sTUFBTSxDQUFDLGNBQWMsQ0FBQyxPQUFnQixFQUFFLE9BQWtCLEVBQUUsc0JBQStCLElBQUk7WUFDcEcsSUFBSSxNQUFNLEdBQVksSUFBSSxPQUFPLEVBQUUsQ0FBQztZQUNwQyxJQUFJLENBQUMsR0FBaUIsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQ3BDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQzNCLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQy9CLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBRS9CLElBQUksbUJBQW1CLEVBQUU7Z0JBQ3ZCLE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDO2FBQ2pDO1lBRUQsT0FBTyxNQUFNLENBQUM7UUFDaEIsQ0FBQztRQUVEOzs7OztXQUtHO1FBQ0ksTUFBTSxDQUFDLGFBQWEsQ0FBQyxPQUFnQixFQUFFLFVBQWtCLENBQUM7WUFDL0QsSUFBSSxNQUFNLEdBQVksT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDO1lBQ3JDLElBQUk7Z0JBQ0YsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDO2dCQUMxQixJQUFJLE1BQU0sR0FBVyxPQUFPLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7Z0JBQ2hELE1BQU0sQ0FBQyxJQUFJLEdBQUcsSUFBSSxZQUFZLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUM7YUFDMUU7WUFBQyxPQUFPLE1BQU0sRUFBRTtnQkFDZixVQUFBLEtBQUssQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7YUFDckI7WUFDRCxPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO1FBRUQ7Ozs7O1dBS0c7UUFDSSxNQUFNLENBQUMsS0FBSyxDQUFDLE9BQWdCLEVBQUUsTUFBYztZQUNsRCxJQUFJLE1BQU0sR0FBWSxJQUFJLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDO1lBQzFFLE9BQU8sTUFBTSxDQUFDO1FBQ2hCLENBQUM7UUFFRDs7OztXQUlHO1FBQ0ksTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLFFBQW1CO1lBQ3RDLElBQUksTUFBTSxHQUFZLElBQUksT0FBTyxFQUFFLENBQUM7WUFDcEMsS0FBSyxJQUFJLE1BQU0sSUFBSSxRQUFRO2dCQUN6QixNQUFNLENBQUMsSUFBSSxHQUFHLElBQUksWUFBWSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDN0UsT0FBTyxNQUFNLENBQUM7UUFDaEIsQ0FBQztRQUVEOzs7OztXQUtHO1FBQ0ksTUFBTSxDQUFDLFVBQVUsQ0FBQyxFQUFXLEVBQUUsRUFBVztZQUMvQyxJQUFJLE1BQU0sR0FBWSxJQUFJLE9BQU8sQ0FBQztZQUNsQyxNQUFNLENBQUMsSUFBSSxHQUFHLElBQUksWUFBWSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDM0QsT0FBTyxNQUFNLENBQUM7UUFDaEIsQ0FBQztRQUVEOzs7OztXQUtHO1FBQ0ksTUFBTSxDQUFDLEdBQUcsQ0FBQyxFQUFXLEVBQUUsRUFBVztZQUN4QyxJQUFJLGFBQWEsR0FBVyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQ3RELE9BQU8sYUFBYSxDQUFDO1FBQ3ZCLENBQUM7UUFFRDs7Ozs7O1dBTUc7UUFDSSxNQUFNLENBQUMsWUFBWSxDQUFDLEVBQVcsRUFBRSxFQUFXO1lBQ2pELElBQUksWUFBWSxHQUFXLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDckQsT0FBTyxZQUFZLENBQUM7UUFDdEIsQ0FBQztRQUVEOzs7Ozs7OztXQVFHO1FBQ0ksTUFBTSxDQUFDLFVBQVUsQ0FBQyxPQUFnQixFQUFFLGFBQXNCLEtBQUs7WUFDcEUsSUFBSSxVQUFVO2dCQUFFLE9BQU8sSUFBSSxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQzs7Z0JBQ3JELE9BQU8sSUFBSSxPQUFPLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNqRCxDQUFDO1FBRUQ7OztXQUdHO1FBQ0ksTUFBTSxDQUFDLFFBQWlCLEVBQUUsYUFBcUIsTUFBTSxDQUFDLE9BQU87WUFDbEUsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLFVBQVU7Z0JBQUUsT0FBTyxLQUFLLENBQUM7WUFDN0QsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLFVBQVU7Z0JBQUUsT0FBTyxLQUFLLENBQUM7WUFDN0QsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO1FBRUQ7OztXQUdHO1FBQ0ksR0FBRyxDQUFDLE9BQWdCO1lBQ3pCLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztRQUN2RSxDQUFDO1FBRUQ7OztXQUdHO1FBQ0ksUUFBUSxDQUFDLFdBQW9CO1lBQ2xDLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxXQUFXLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztRQUMvRSxDQUFDO1FBRUQ7OztXQUdHO1FBQ0ksS0FBSyxDQUFDLE1BQWM7WUFDekIsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLE9BQU8sQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLENBQUMsRUFBRSxNQUFNLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztRQUNqRSxDQUFDO1FBRUQ7OztXQUdHO1FBQ0ksU0FBUyxDQUFDLFVBQWtCLENBQUM7WUFDbEMsSUFBSSxDQUFDLElBQUksR0FBRyxPQUFPLENBQUMsYUFBYSxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUM7UUFDeEQsQ0FBQztRQUVEOzs7O1dBSUc7UUFDSSxHQUFHLENBQUMsS0FBYSxDQUFDLEVBQUUsS0FBYSxDQUFDO1lBQ3ZDLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxZQUFZLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUN6QyxDQUFDO1FBRUQ7O1dBRUc7UUFDSSxHQUFHO1lBQ1IsT0FBTyxJQUFJLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDckMsQ0FBQztRQUVEOztXQUVHO1FBQ0gsSUFBVyxJQUFJO1lBQ2IsT0FBTyxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNyQyxDQUFDO1FBRU0sU0FBUyxDQUFDLE9BQWtCLEVBQUUsc0JBQStCLElBQUk7WUFDdEUsSUFBSSxDQUFDLElBQUksR0FBRyxPQUFPLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsbUJBQW1CLENBQUMsQ0FBQyxJQUFJLENBQUM7UUFDOUUsQ0FBQztRQUVEOztXQUVHO1FBQ0ksU0FBUztZQUNkLE9BQU8sSUFBSSxVQUFBLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDeEMsQ0FBQztRQUVNLFFBQVE7WUFDYixJQUFJLE1BQU0sR0FBVyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUM7WUFDNUUsT0FBTyxNQUFNLENBQUM7UUFDaEIsQ0FBQztRQUVNLFVBQVU7WUFDZixJQUFJLE9BQU8sR0FBWTtnQkFDckIsQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO2FBQ2pDLENBQUM7WUFDRixPQUFPLE9BQU8sQ0FBQztRQUNqQixDQUFDO1FBQ1MsYUFBYSxDQUFDLFFBQWlCLElBQWdCLENBQUM7S0FDM0Q7SUExUVksaUJBQU8sVUEwUW5CLENBQUE7QUFDSCxDQUFDLEVBcFJTLFNBQVMsS0FBVCxTQUFTLFFBb1JsQjtBQ3BSRCxJQUFVLFNBQVMsQ0E2UWxCO0FBN1FELFdBQVUsU0FBUztJQUNqQjs7Ozs7Ozs7O09BU0c7SUFDSCxNQUFhLE9BQVEsU0FBUSxVQUFBLE9BQU87UUFHbEMsWUFBbUIsS0FBYSxDQUFDLEVBQUUsS0FBYSxDQUFDLEVBQUUsS0FBYSxDQUFDO1lBQy9ELEtBQUssRUFBRSxDQUFDO1lBQ1IsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLFlBQVksQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUM3QyxDQUFDO1FBRUQsbUNBQW1DO1FBQ25DLElBQUksQ0FBQztZQUNILE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN0QixDQUFDO1FBQ0QsSUFBSSxDQUFDO1lBQ0gsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3RCLENBQUM7UUFDRCxJQUFJLENBQUM7WUFDSCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdEIsQ0FBQztRQUVELElBQUksQ0FBQyxDQUFDLEVBQVU7WUFDZCxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNwQixDQUFDO1FBQ0QsSUFBSSxDQUFDLENBQUMsRUFBVTtZQUNkLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQ3BCLENBQUM7UUFDRCxJQUFJLENBQUMsQ0FBQyxFQUFVO1lBQ2QsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDcEIsQ0FBQztRQUVEOztXQUVHO1FBQ0gsSUFBSSxTQUFTO1lBQ1gsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2xDLENBQUM7UUFFRDs7V0FFRztRQUNILElBQUksZ0JBQWdCO1lBQ2xCLE9BQU8sT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDakMsQ0FBQztRQUVEOztXQUVHO1FBQ0ksTUFBTSxDQUFDLENBQUMsQ0FBQyxTQUFpQixDQUFDO1lBQ2hDLE1BQU0sTUFBTSxHQUFZLElBQUksT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDbEQsT0FBTyxNQUFNLENBQUM7UUFDaEIsQ0FBQztRQUVEOztXQUVHO1FBQ0ksTUFBTSxDQUFDLENBQUMsQ0FBQyxTQUFpQixDQUFDO1lBQ2hDLE1BQU0sTUFBTSxHQUFZLElBQUksT0FBTyxDQUFDLENBQUMsRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDbEQsT0FBTyxNQUFNLENBQUM7UUFDaEIsQ0FBQztRQUVEOztXQUVHO1FBQ0ksTUFBTSxDQUFDLENBQUMsQ0FBQyxTQUFpQixDQUFDO1lBQ2hDLE1BQU0sTUFBTSxHQUFZLElBQUksT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7WUFDbEQsT0FBTyxNQUFNLENBQUM7UUFDaEIsQ0FBQztRQUVEOztXQUVHO1FBQ0ksTUFBTSxDQUFDLElBQUk7WUFDaEIsTUFBTSxNQUFNLEdBQVksSUFBSSxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUM3QyxPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO1FBRUQ7O1dBRUc7UUFDSSxNQUFNLENBQUMsR0FBRyxDQUFDLFNBQWlCLENBQUM7WUFDbEMsTUFBTSxNQUFNLEdBQVksSUFBSSxPQUFPLENBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQztZQUM1RCxPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO1FBRUQ7O1dBRUc7UUFDSSxNQUFNLENBQUMsY0FBYyxDQUFDLE9BQWdCLEVBQUUsT0FBa0IsRUFBRSxzQkFBK0IsSUFBSTtZQUNwRyxJQUFJLE1BQU0sR0FBWSxJQUFJLE9BQU8sRUFBRSxDQUFDO1lBQ3BDLElBQUksQ0FBQyxHQUFpQixPQUFPLENBQUMsR0FBRyxFQUFFLENBQUM7WUFDcEMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQzlCLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDMUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUMxQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBRTNDLElBQUksbUJBQW1CLEVBQUU7Z0JBQ3ZCLE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDO2FBQ2pDO1lBRUQsT0FBTyxNQUFNLENBQUM7UUFDaEIsQ0FBQztRQUVEOztXQUVHO1FBQ0ksTUFBTSxDQUFDLGFBQWEsQ0FBQyxPQUFnQixFQUFFLFVBQWtCLENBQUM7WUFDL0QsSUFBSSxNQUFNLEdBQVksT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDO1lBQ3JDLElBQUk7Z0JBQ0YsSUFBSSxNQUFNLEdBQVcsT0FBTyxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUM7Z0JBQ2pELE1BQU0sQ0FBQyxJQUFJLEdBQUcsSUFBSSxZQUFZLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQyxHQUFHLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUM7YUFDOUY7WUFBQyxPQUFPLE1BQU0sRUFBRTtnQkFDZixVQUFBLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7YUFDcEI7WUFDRCxPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO1FBRUQ7Ozs7V0FJRztRQUNJLE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxRQUFtQjtZQUN0QyxJQUFJLE1BQU0sR0FBWSxJQUFJLE9BQU8sRUFBRSxDQUFDO1lBQ3BDLEtBQUssSUFBSSxNQUFNLElBQUksUUFBUTtnQkFDekIsTUFBTSxDQUFDLElBQUksR0FBRyxJQUFJLFlBQVksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNsRyxPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO1FBQ0Q7Ozs7O1dBS0c7UUFDSSxNQUFNLENBQUMsVUFBVSxDQUFDLEVBQVcsRUFBRSxFQUFXO1lBQy9DLElBQUksTUFBTSxHQUFZLElBQUksT0FBTyxDQUFDO1lBQ2xDLE1BQU0sQ0FBQyxJQUFJLEdBQUcsSUFBSSxZQUFZLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDeEUsT0FBTyxNQUFNLENBQUM7UUFDaEIsQ0FBQztRQUNEOztXQUVHO1FBQ0ksTUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFnQixFQUFFLFFBQWdCO1lBQ3BELElBQUksTUFBTSxHQUFZLElBQUksT0FBTyxFQUFFLENBQUM7WUFDcEMsTUFBTSxDQUFDLElBQUksR0FBRyxJQUFJLFlBQVksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDLEdBQUcsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNuRyxPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO1FBQ0Q7Ozs7O1dBS0c7UUFDSSxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQVcsRUFBRSxFQUFXO1lBQzFDLElBQUksTUFBTSxHQUFZLElBQUksT0FBTyxDQUFDO1lBQ2xDLE1BQU0sQ0FBQyxJQUFJLEdBQUcsSUFBSSxZQUFZLENBQUM7Z0JBQzdCLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO2dCQUN6QixFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztnQkFDekIsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7YUFBQyxDQUFDLENBQUM7WUFDOUIsT0FBTyxNQUFNLENBQUM7UUFDaEIsQ0FBQztRQUNEOzs7OztXQUtHO1FBQ0ksTUFBTSxDQUFDLEdBQUcsQ0FBQyxFQUFXLEVBQUUsRUFBVztZQUN4QyxJQUFJLGFBQWEsR0FBVyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUNwRSxPQUFPLGFBQWEsQ0FBQztRQUN2QixDQUFDO1FBRUQ7Ozs7Ozs7O1dBUUc7UUFDSSxNQUFNLENBQUMsVUFBVSxDQUFDLFNBQWtCLEVBQUUsT0FBZ0I7WUFDM0QsSUFBSSxHQUFHLEdBQVcsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQztZQUNuRCxJQUFJLFVBQVUsR0FBWSxPQUFPLENBQUMsR0FBRyxDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUNsRixPQUFPLFVBQVUsQ0FBQztRQUNwQixDQUFDO1FBRUQ7OztXQUdHO1FBQ0ksTUFBTSxDQUFDLFFBQWlCLEVBQUUsYUFBcUIsTUFBTSxDQUFDLE9BQU87WUFDbEUsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLFVBQVU7Z0JBQUUsT0FBTyxLQUFLLENBQUM7WUFDN0QsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLFVBQVU7Z0JBQUUsT0FBTyxLQUFLLENBQUM7WUFDN0QsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLFVBQVU7Z0JBQUUsT0FBTyxLQUFLLENBQUM7WUFDN0QsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO1FBRU0sR0FBRyxDQUFDLE9BQWdCO1lBQ3pCLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7UUFDM0YsQ0FBQztRQUNNLFFBQVEsQ0FBQyxXQUFvQjtZQUNsQyxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsV0FBVyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO1FBQ3ZHLENBQUM7UUFDTSxLQUFLLENBQUMsTUFBYztZQUN6QixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksT0FBTyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsQ0FBQyxFQUFFLE1BQU0sR0FBRyxJQUFJLENBQUMsQ0FBQyxFQUFFLE1BQU0sR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO1FBQ2xGLENBQUM7UUFFTSxTQUFTLENBQUMsVUFBa0IsQ0FBQztZQUNsQyxJQUFJLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQyxhQUFhLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQztRQUN4RCxDQUFDO1FBRU0sR0FBRyxDQUFDLEtBQWEsQ0FBQyxFQUFFLEtBQWEsQ0FBQyxFQUFFLEtBQWEsQ0FBQztZQUN2RCxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksWUFBWSxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQzdDLENBQUM7UUFFTSxHQUFHO1lBQ1IsT0FBTyxJQUFJLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDckMsQ0FBQztRQUVELElBQVcsSUFBSTtZQUNiLE9BQU8sSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM3QyxDQUFDO1FBRU0sU0FBUyxDQUFDLE9BQWtCLEVBQUUsc0JBQStCLElBQUk7WUFDdEUsSUFBSSxDQUFDLElBQUksR0FBRyxPQUFPLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsbUJBQW1CLENBQUMsQ0FBQyxJQUFJLENBQUM7UUFDOUUsQ0FBQztRQUVEOztXQUVHO1FBQ0ksU0FBUztZQUNkLE9BQU8sSUFBSSxVQUFBLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNyQyxDQUFDO1FBRU0sT0FBTyxDQUFDLE9BQWdCO1lBQzdCLE1BQU0sU0FBUyxHQUFZLE9BQU8sQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBQzdELElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNoRCxVQUFBLFFBQVEsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDNUIsQ0FBQztRQUVNLFFBQVE7WUFDYixJQUFJLE1BQU0sR0FBVyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUM7WUFDdEcsT0FBTyxNQUFNLENBQUM7UUFDaEIsQ0FBQztRQUVNLEdBQUcsQ0FBQyxTQUF3RTtZQUNqRixJQUFJLElBQUksR0FBWSxVQUFBLFFBQVEsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDMUMsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUNyQyxPQUFPLElBQUksQ0FBQztRQUNkLENBQUM7UUFFTSxVQUFVO1lBQ2YsSUFBSSxPQUFPLEdBQVk7Z0JBQ3JCLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQzthQUNsRCxDQUFDO1lBQ0YsT0FBTyxPQUFPLENBQUM7UUFDakIsQ0FBQztRQUNTLGFBQWEsQ0FBQyxRQUFpQixJQUFnQixDQUFDO0tBQzNEO0lBalFZLGlCQUFPLFVBaVFuQixDQUFBO0FBQ0gsQ0FBQyxFQTdRUyxTQUFTLEtBQVQsU0FBUyxRQTZRbEI7QUM3UUQsSUFBVSxTQUFTLENBaUZsQjtBQWpGRCxXQUFVLFNBQVM7O0lBQ2pCOzs7OztPQUtHO0lBRUgsSUFBc0IsSUFBSSxZQUExQixNQUFzQixJQUFJO1FBQTFCO1lBU1MsZUFBVSxHQUFXLFNBQVMsQ0FBQztRQStEMUMsQ0FBQztRQTNEVSxNQUFNLENBQUMsc0JBQXNCO1lBQ2xDLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQyxFQUFFLFFBQVEsRUFBRSxzQkFBc0IsQ0FBQyxLQUFLLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsQ0FBQyxFQUFFLE1BQU0sRUFBRSxDQUFDLEVBQUUsQ0FBQztRQUNyRyxDQUFDO1FBRVMsTUFBTSxDQUFDLGdCQUFnQixDQUFDLFNBQXNCLElBQVksT0FBTyxNQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRTFHLGdCQUFnQixDQUFDLGFBQTJCLEVBQUUsTUFBaUIsRUFBRSxXQUFzQixFQUFFLEdBQVksSUFBeUMsQ0FBQztRQUMvSSxtQkFBbUIsQ0FBQyxhQUEyQixJQUF5QyxDQUFDO1FBQ3pGLG1CQUFtQixDQUFDLGFBQTJCLElBQXlDLENBQUM7UUFHekYsY0FBYztZQUNyQixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxHQUFHLE1BQUksQ0FBQyxzQkFBc0IsRUFBRSxDQUFDLElBQUksQ0FBQztRQUNuRSxDQUFDO1FBQ1EsYUFBYTtZQUNwQixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDO1FBQzdCLENBQUM7UUFHQyx5RUFBeUU7UUFDbEUsU0FBUztZQUNoQixJQUFJLGFBQWEsR0FBa0I7Z0JBQ2pDLFVBQVUsRUFBRSxJQUFJLENBQUMsVUFBVTthQUM1QixDQUFDLENBQUMscUJBQXFCO1lBQ3hCLE9BQU8sYUFBYSxDQUFDO1FBQ3ZCLENBQUM7UUFDUSxXQUFXLENBQUMsY0FBNkI7WUFDaEQsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsaUVBQWlFO1lBQ2hGLElBQUksQ0FBQyxVQUFVLEdBQUcsY0FBYyxDQUFDLFVBQVUsQ0FBQztZQUM1QyxPQUFPLElBQUksQ0FBQztRQUNkLENBQUM7UUFJVyxvQkFBb0I7WUFDOUIsSUFBSSxPQUFPLEdBQWEsRUFBRSxDQUFDO1lBQzNCLElBQUksUUFBUSxHQUFjLEVBQUUsQ0FBQztZQUU3QixLQUFLLElBQUksQ0FBQyxHQUFXLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxJQUFJLENBQUM7Z0JBQ3RELFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxVQUFBLE9BQU8sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUUzRixLQUFLLElBQUksQ0FBQyxHQUFXLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFDdkQsSUFBSSxNQUFNLEdBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBRW5GLElBQUksRUFBRSxHQUFZLFVBQUEsT0FBTyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQy9FLElBQUksRUFBRSxHQUFZLFVBQUEsT0FBTyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQy9FLElBQUksTUFBTSxHQUFZLFVBQUEsT0FBTyxDQUFDLGFBQWEsQ0FBQyxVQUFBLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7Z0JBQ25FLElBQUksS0FBSyxHQUFXLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQ2xDLE9BQU8sQ0FBQyxLQUFLLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDO2dCQUMxQixPQUFPLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUM7Z0JBQzlCLE9BQU8sQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQzthQUMvQjtZQUNELE9BQU8sSUFBSSxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDbkMsQ0FBQztLQU1GLENBQUE7SUF2RTBCLGVBQVUsR0FBa0IsRUFBRSxDQUFDO0lBRGxDLElBQUk7UUFEekIsVUFBQSxrQkFBa0IsQ0FBQyxRQUFRO09BQ04sSUFBSSxDQXdFM0I7SUF4RXVCLGNBQUksT0F3RTNCLENBQUE7QUFDRCxDQUFDLEVBakZTLFNBQVMsS0FBVCxTQUFTLFFBaUZsQjtBQ2pGRCxJQUFVLFNBQVMsQ0FrSGxCO0FBbEhELFdBQVUsU0FBUztJQUNqQjs7Ozs7Ozs7O09BU0c7SUFDSCxNQUFhLFFBQVMsU0FBUSxVQUFBLElBQUk7UUFHaEM7WUFDRSxLQUFLLEVBQUUsQ0FBQztZQUNSLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUNoQixDQUFDO1FBRU0sTUFBTTtZQUNYLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO1lBQ3RDLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1lBQ3BDLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7WUFDMUMsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUM5QyxDQUFDO1FBRVMsY0FBYztZQUN0QixJQUFJLFFBQVEsR0FBaUIsSUFBSSxZQUFZLENBQUM7Z0JBQ3BDLGFBQWE7Z0JBQ2IsUUFBUTtnQkFDUixLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7Z0JBQy9ELE9BQU87Z0JBQ1AsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUcsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7Z0JBQ3RFLGNBQWM7Z0JBQ2QsUUFBUTtnQkFDUixLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7Z0JBQy9ELE9BQU87Z0JBQ1AsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUcsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7YUFDL0UsQ0FBQyxDQUFDO1lBRUgsNENBQTRDO1lBQzVDLFFBQVEsR0FBRyxRQUFRLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBRTlDLE9BQU8sUUFBUSxDQUFDO1FBQ2xCLENBQUM7UUFFUyxhQUFhO1lBQ3JCLElBQUksT0FBTyxHQUFnQixJQUFJLFdBQVcsQ0FBQztnQkFDekMsYUFBYTtnQkFDYixRQUFRO2dCQUNSLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztnQkFDaEIsUUFBUTtnQkFDUixDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7Z0JBQ2hCLE9BQU87Z0JBQ1AsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO2dCQUVoQixjQUFjO2dCQUNkLE9BQU87Z0JBQ1AsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDO2dCQUN4QyxNQUFNO2dCQUNOLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQztnQkFDeEMsU0FBUztnQkFDVCxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUM7Z0JBRXhDOzs7Ozs7O2tCQU9FO2FBQ0gsQ0FBQyxDQUFDO1lBQ0gsT0FBTyxPQUFPLENBQUM7UUFDakIsQ0FBQztRQUVTLGdCQUFnQjtZQUN4QixJQUFJLFVBQVUsR0FBaUIsSUFBSSxZQUFZLENBQUM7Z0JBQ3RDLGFBQWE7Z0JBQ2IsUUFBUTtnQkFDUixLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUM7Z0JBQy9DLE9BQU87Z0JBQ1AsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDO2dCQUUvQyxjQUFjO2dCQUNkLFFBQVE7Z0JBQ1IsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7Z0JBQ2hELE9BQU87Z0JBQ1AsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7YUFDekQsQ0FBQyxDQUFDO1lBQ0gsT0FBTyxVQUFVLENBQUM7UUFDcEIsQ0FBQztRQUVTLGlCQUFpQjtZQUN6QixJQUFJLE9BQU8sR0FBaUIsSUFBSSxZQUFZLENBQUM7Z0JBQ25DLDhHQUE4RztnQkFDOUcsYUFBYTtnQkFDYixRQUFRO2dCQUNSLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7Z0JBQzFELE9BQU87Z0JBQ1AsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO2dCQUUzRCxjQUFjO2dCQUNkLFFBQVE7Z0JBQ1IsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO2dCQUMzRCxPQUFPO2dCQUNQLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQzthQUNwRSxDQUFDLENBQUM7WUFFSCxrQ0FBa0M7WUFFbEMsT0FBTyxPQUFPLENBQUM7UUFDakIsQ0FBQzs7SUFwR3NCLGtCQUFTLEdBQVcsVUFBQSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLENBQUM7SUFEaEUsa0JBQVEsV0FzR3BCLENBQUE7QUFDSCxDQUFDLEVBbEhTLFNBQVMsS0FBVCxTQUFTLFFBa0hsQjtBQ2xIRCxJQUFVLFNBQVMsQ0FzR2xCO0FBdEdELFdBQVUsU0FBUztJQU9qQjs7O09BR0c7SUFDSCxNQUFhLGFBQWMsU0FBUSxVQUFBLElBQUk7UUFPckMsWUFBbUIsZUFBdUIsRUFBRSxFQUFFLGVBQXVCLEVBQUUsRUFBRSxrQkFBc0M7WUFDN0csS0FBSyxFQUFFLENBQUM7WUFDUixJQUFJLENBQUMsV0FBVyxHQUFHLFlBQVksQ0FBQztZQUNoQyxJQUFJLENBQUMsV0FBVyxHQUFHLFlBQVksQ0FBQztZQUVoQyxJQUFJLFlBQVksSUFBSSxZQUFZLElBQUksQ0FBQyxFQUFFO2dCQUNyQyxVQUFBLEtBQUssQ0FBQyxJQUFJLENBQUMsb0RBQW9ELENBQUMsQ0FBQztnQkFDakUsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7Z0JBQ2pELElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO2FBQ2xEO1lBRUQsSUFBSSxrQkFBa0I7Z0JBQUUsSUFBSSxDQUFDLGlCQUFpQixHQUFHLGtCQUFrQixDQUFDOztnQkFDL0QsSUFBSSxDQUFDLGlCQUFpQixHQUFHLFVBQVUsRUFBVSxFQUFFLEVBQVUsSUFBWSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUV0RixJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDaEIsQ0FBQztRQUVNLE1BQU07WUFDWCxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztZQUN0QyxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztZQUNwQyxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1lBQzFDLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFDOUMsQ0FBQztRQUVTLGNBQWM7WUFDdEIsSUFBSSxRQUFRLEdBQWlCLElBQUksWUFBWSxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxXQUFXLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFFbkcscURBQXFEO1lBQ3JELEtBQUssSUFBSSxDQUFDLEdBQVcsQ0FBQyxFQUFFLENBQUMsR0FBVyxDQUFDLEVBQUUsQ0FBQyxJQUFJLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ2pFLEtBQUssSUFBSSxDQUFDLEdBQVcsQ0FBQyxFQUFFLENBQUMsSUFBSSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUMsRUFBRSxFQUFFO29CQUNsRCxJQUFJO29CQUNKLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLFdBQVcsR0FBRyxHQUFHLENBQUM7b0JBQ3pDLGtDQUFrQztvQkFDbEMsUUFBUSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztvQkFDckYsSUFBSTtvQkFDSixRQUFRLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsV0FBVyxHQUFHLEdBQUcsQ0FBQztvQkFDN0MsQ0FBQyxJQUFJLENBQUMsQ0FBQztpQkFDUjthQUNGO1lBQ0QsT0FBTyxRQUFRLENBQUM7UUFDbEIsQ0FBQztRQUVTLGFBQWE7WUFDckIsSUFBSSxJQUFJLEdBQVcsQ0FBQyxDQUFDO1lBQ3JCLElBQUksSUFBSSxHQUFXLENBQUMsQ0FBQztZQUVyQixJQUFJLE9BQU8sR0FBZ0IsSUFBSSxXQUFXLENBQUMsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsV0FBVyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQ3BGLEtBQUssSUFBSSxDQUFDLEdBQVcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUMsRUFBRSxFQUFFO2dCQUNqRCxLQUFLLElBQUksQ0FBQyxHQUFXLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDLEVBQUUsRUFBRTtvQkFFakQsbUNBQW1DO29CQUNuQyxPQUFPLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksR0FBRyxDQUFDLENBQUM7b0JBQzdCLE9BQU8sQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxHQUFHLElBQUksQ0FBQyxXQUFXLEdBQUcsQ0FBQyxDQUFDO29CQUNoRCxPQUFPLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksR0FBRyxDQUFDLENBQUM7b0JBRTdCLG9DQUFvQztvQkFDcEMsT0FBTyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxDQUFDO29CQUM3QixPQUFPLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksR0FBRyxJQUFJLENBQUMsV0FBVyxHQUFHLENBQUMsQ0FBQztvQkFDaEQsT0FBTyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLEdBQUcsSUFBSSxDQUFDLFdBQVcsR0FBRyxDQUFDLENBQUM7b0JBQ2hELElBQUksRUFBRSxDQUFDO29CQUNQLElBQUksSUFBSSxDQUFDLENBQUM7aUJBQ1g7Z0JBQ0QsSUFBSSxFQUFFLENBQUM7YUFDUjtZQUNELE9BQU8sT0FBTyxDQUFDO1FBQ2pCLENBQUM7UUFFUyxnQkFBZ0I7WUFDeEIsSUFBSSxVQUFVLEdBQWlCLElBQUksWUFBWSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBRXpFLEtBQUssSUFBSSxDQUFDLEdBQVcsQ0FBQyxFQUFFLENBQUMsR0FBVyxDQUFDLEVBQUUsQ0FBQyxJQUFJLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ2pFLEtBQUssSUFBSSxDQUFDLEdBQVcsQ0FBQyxFQUFFLENBQUMsSUFBSSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUMsRUFBRSxFQUFFO29CQUNsRCxVQUFVLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUM7b0JBQ3JDLFVBQVUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUM7b0JBQ3pDLENBQUMsSUFBSSxDQUFDLENBQUM7aUJBQ1I7YUFDRjtZQUNELE9BQU8sVUFBVSxDQUFDO1FBQ3BCLENBQUM7UUFFUyxpQkFBaUI7WUFDekIsT0FBTyxJQUFJLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztRQUNyQyxDQUFDOztJQXhGc0IsdUJBQVMsR0FBVyxVQUFBLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxhQUFhLENBQUMsQ0FBQztJQURyRSx1QkFBYSxnQkEwRnpCLENBQUE7QUFDSCxDQUFDLEVBdEdTLFNBQVMsS0FBVCxTQUFTLFFBc0dsQjtBRXRHRCxJQUFVLFNBQVMsQ0F3RWxCO0FBeEVELFdBQVUsU0FBUztJQUNqQjs7Ozs7Ozs7O09BU0c7SUFDSCxNQUFhLFdBQVksU0FBUSxVQUFBLElBQUk7UUFHbkM7WUFDRSxLQUFLLEVBQUUsQ0FBQztZQUNSLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUNoQixDQUFDO1FBRU0sTUFBTTtZQUNYLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO1lBQ3RDLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1lBQ3BDLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7WUFDMUMsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUM5QyxDQUFDO1FBRVMsY0FBYztZQUN0QixJQUFJLFFBQVEsR0FBaUIsSUFBSSxZQUFZLENBQUM7Z0JBQ3BDLFFBQVE7Z0JBQ1IsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO2dCQUMvRCxNQUFNO2dCQUNOLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7Z0JBQ2Isd0NBQXdDO2dCQUN4QyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7YUFDeEUsQ0FBQyxDQUFDO1lBRUgsMERBQTBEO1lBQzFELFFBQVEsR0FBRyxRQUFRLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQzlDLE9BQU8sUUFBUSxDQUFDO1FBQ2xCLENBQUM7UUFFUyxhQUFhO1lBQ3JCLElBQUksT0FBTyxHQUFnQixJQUFJLFdBQVcsQ0FBQztnQkFDekMsUUFBUTtnQkFDUixDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7Z0JBQ1AsUUFBUTtnQkFDUixDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7Z0JBQ1AsT0FBTztnQkFDUCxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7Z0JBQ1AsT0FBTztnQkFDUCxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7Z0JBQ1AsU0FBUztnQkFDVCxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUM7YUFDekMsQ0FBQyxDQUFDO1lBQ0gsT0FBTyxPQUFPLENBQUM7UUFDakIsQ0FBQztRQUVTLGdCQUFnQjtZQUN4QixJQUFJLFVBQVUsR0FBaUIsSUFBSSxZQUFZLENBQUM7Z0JBQ3RDLFFBQVE7Z0JBQ1IsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDO2dCQUNuRCxPQUFPO2dCQUNQLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQkFDWixLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUM7YUFDeEQsQ0FBQyxDQUFDO1lBQ0gsT0FBTyxVQUFVLENBQUM7UUFDcEIsQ0FBQztRQUVTLGlCQUFpQjtZQUN6QixPQUFPLElBQUksWUFBWSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDLENBQUM7UUFDdkQsQ0FBQzs7SUExRHNCLHFCQUFTLEdBQVcsVUFBQSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsV0FBVyxDQUFDLENBQUM7SUFEbkUscUJBQVcsY0E0RHZCLENBQUE7QUFDSCxDQUFDLEVBeEVTLFNBQVMsS0FBVCxTQUFTLFFBd0VsQjtBQ3hFRCxJQUFVLFNBQVMsQ0F1RGxCO0FBdkRELFdBQVUsU0FBUztJQUNqQjs7Ozs7Ozs7T0FRRztJQUNILE1BQWEsUUFBUyxTQUFRLFVBQUEsSUFBSTtRQUdoQztZQUNFLEtBQUssRUFBRSxDQUFDO1lBQ1IsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQ2hCLENBQUM7UUFFTSxNQUFNO1lBQ1gsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7WUFDdEMsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7WUFDcEMsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztZQUMxQyxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQzlDLENBQUM7UUFFUyxjQUFjO1lBQ3RCLElBQUksUUFBUSxHQUFpQixJQUFJLFlBQVksQ0FBQztnQkFDcEMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO2FBQ3hFLENBQUMsQ0FBQztZQUVILFFBQVEsR0FBRyxRQUFRLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBRTlDLE9BQU8sUUFBUSxDQUFDO1FBQ2xCLENBQUM7UUFDUyxhQUFhO1lBQ3JCLElBQUksT0FBTyxHQUFnQixJQUFJLFdBQVcsQ0FBQztnQkFDekMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO2FBQ2pCLENBQUMsQ0FBQztZQUNILE9BQU8sT0FBTyxDQUFDO1FBQ2pCLENBQUM7UUFFUyxnQkFBZ0I7WUFDeEIsSUFBSSxVQUFVLEdBQWlCLElBQUksWUFBWSxDQUFDO2dCQUN0QyxRQUFRO2dCQUNSLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQzthQUN4RCxDQUFDLENBQUM7WUFDSCxPQUFPLFVBQVUsQ0FBQztRQUNwQixDQUFDO1FBRVMsaUJBQWlCO1lBQ3pCLE9BQU8sSUFBSSxZQUFZLENBQUM7Z0JBQ2QsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQzthQUNuRSxDQUFDLENBQUM7UUFDTCxDQUFDOztJQTFDc0Isa0JBQVMsR0FBVyxVQUFBLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQURoRSxrQkFBUSxXQTRDcEIsQ0FBQTtBQUNILENBQUMsRUF2RFMsU0FBUyxLQUFULFNBQVMsUUF1RGxCO0FDdkRELElBQVUsU0FBUyxDQW9JbEI7QUFwSUQsV0FBVSxTQUFTO0lBQ2pCOzs7O09BSUc7SUFDSCxNQUFhLFVBQVcsU0FBUSxVQUFBLElBQUk7UUFRbEMsdUVBQXVFO1FBQ3ZFLHVDQUF1QztRQUN2QywwQ0FBMEM7UUFDMUMsbUNBQW1DO1FBRW5DLFlBQW1CLFdBQW1CLEVBQUUsRUFBRSxVQUFrQixDQUFDO1lBQzNELEtBQUssRUFBRSxDQUFDO1lBRVIsZ0RBQWdEO1lBQ2hELElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUUsR0FBRyxDQUFDLENBQUM7WUFDdkMsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxHQUFHLENBQUMsQ0FBQztZQUVyQyxJQUFJLFFBQVEsR0FBRyxDQUFDLElBQUksT0FBTyxHQUFHLENBQUMsRUFBRTtnQkFDL0IsVUFBQSxLQUFLLENBQUMsSUFBSSxDQUFDLG9GQUFvRixDQUFDLENBQUM7Z0JBQ2pHLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUM7Z0JBQ3JDLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUM7YUFDcEM7WUFFRCxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDaEIsQ0FBQztRQUVNLE1BQU07WUFDWCxJQUFJLFFBQVEsR0FBa0IsRUFBRSxDQUFDO1lBQ2pDLElBQUksT0FBTyxHQUFhLEVBQUUsQ0FBQztZQUMzQixJQUFJLFVBQVUsR0FBYSxFQUFFLENBQUM7WUFFOUIsSUFBSSxDQUFTLENBQUM7WUFDZCxJQUFJLENBQVMsQ0FBQztZQUNkLElBQUksRUFBVSxDQUFDO1lBQ2YsSUFBSSxDQUFTLENBQUM7WUFHZCxJQUFJLFVBQVUsR0FBVyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDO1lBQ3BELElBQUksU0FBUyxHQUFXLElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztZQUM5QyxJQUFJLFVBQWtCLENBQUM7WUFDdkIsSUFBSSxXQUFtQixDQUFDO1lBRXhCOzt1Q0FFMkI7WUFDM0IsS0FBSyxJQUFJLENBQUMsR0FBVyxDQUFDLEVBQUUsQ0FBQyxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLEVBQUU7Z0JBQzdDLFVBQVUsR0FBRyxJQUFJLENBQUMsRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsU0FBUyxDQUFDO2dCQUN6QyxFQUFFLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQztnQkFDMUIsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7Z0JBRXpCLHlDQUF5QztnQkFDekMsc0ZBQXNGO2dCQUN0RixLQUFLLElBQUksQ0FBQyxHQUFXLENBQUMsRUFBRSxDQUFDLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsRUFBRTtvQkFDOUMsV0FBVyxHQUFHLENBQUMsR0FBRyxVQUFVLENBQUM7b0JBRTdCLGlCQUFpQjtvQkFDakIsQ0FBQyxHQUFHLEVBQUUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDO29CQUMvQixDQUFDLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUM7b0JBQy9CLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztvQkFFdkIsU0FBUztvQkFDVCxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7b0JBRXRCLFdBQVc7b0JBQ1gsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUN2QyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7aUJBQ2xDO2FBQ0Y7WUFFRCxhQUFhO1lBQ2IsUUFBUSxHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFFOUMsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLFlBQVksQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUMvQyxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ3pDLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDM0MsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztZQUM1QyxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUN0QyxDQUFDO1FBRVMsYUFBYTtZQUNyQixJQUFJLElBQUksR0FBa0IsRUFBRSxDQUFDO1lBRTdCLElBQUksRUFBVSxDQUFDO1lBQ2YsSUFBSSxFQUFVLENBQUM7WUFFZixLQUFLLElBQUksQ0FBQyxHQUFXLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsRUFBRTtnQkFDNUMsRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBRyw2QkFBNkI7Z0JBQzVELEVBQUUsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUMsQ0FBSSwwQkFBMEI7Z0JBRXpELEtBQUssSUFBSSxDQUFDLEdBQVcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFO29CQUV6RCx5REFBeUQ7b0JBQ3pELG1CQUFtQjtvQkFDbkIsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFO3dCQUNWLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7d0JBQ2QsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7d0JBQ2xCLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7cUJBQ2Y7b0JBRUQsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxFQUFFO3dCQUMxQixJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQzt3QkFDbEIsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7d0JBQ2xCLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7cUJBQ2Y7aUJBQ0Y7YUFDRjtZQUNELElBQUksT0FBTyxHQUFnQixJQUFJLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNqRCxPQUFPLE9BQU8sQ0FBQztRQUNqQixDQUFDO1FBRVMsY0FBYztZQUN0QixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUM7UUFDdkIsQ0FBQztRQUVTLGdCQUFnQjtZQUN4QixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUM7UUFDekIsQ0FBQztRQUVELHNDQUFzQztRQUM1QixpQkFBaUI7WUFDekIsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDO1FBQ3RCLENBQUM7O0lBM0hzQixvQkFBUyxHQUFXLFVBQUEsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBRGxFLG9CQUFVLGFBNkh0QixDQUFBO0FBQ0gsQ0FBQyxFQXBJUyxTQUFTLEtBQVQsU0FBUyxRQW9JbEI7QUNwSUQsSUFBVSxTQUFTLENBK0RsQjtBQS9ERCxXQUFVLFNBQVM7SUFDakI7Ozs7Ozs7O09BUUc7SUFDSCxNQUFhLFVBQVcsU0FBUSxVQUFBLElBQUk7UUFHbEM7WUFDRSxLQUFLLEVBQUUsQ0FBQztZQUNSLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUNoQixDQUFDO1FBRU0sTUFBTTtZQUNYLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO1lBQ3RDLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1lBQ3BDLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7WUFDMUMsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUM5QyxDQUFDO1FBRVMsY0FBYztZQUN0QixJQUFJLFFBQVEsR0FBaUIsSUFBSSxZQUFZLENBQUM7Z0JBQzVDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQzthQUNoRSxDQUFDLENBQUM7WUFFSCxRQUFRLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztZQUU5QyxPQUFPLFFBQVEsQ0FBQztRQUNsQixDQUFDO1FBQ1MsYUFBYTtZQUNyQixJQUFJLE9BQU8sR0FBZ0IsSUFBSSxXQUFXLENBQUM7Z0JBQ3pDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztnQkFDaEIsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUUsTUFBTTthQUN6QixDQUFDLENBQUM7WUFDSCxPQUFPLE9BQU8sQ0FBQztRQUNqQixDQUFDO1FBRVMsZ0JBQWdCO1lBQ3hCLElBQUksVUFBVSxHQUFpQixJQUFJLFlBQVksQ0FBQztnQkFDOUMsUUFBUTtnQkFDUixLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUM7YUFDaEQsQ0FBQyxDQUFDO1lBQ0gsT0FBTyxVQUFVLENBQUM7UUFDcEIsQ0FBQztRQUVTLGlCQUFpQjtZQUN6QixPQUFPLElBQUksWUFBWSxDQUFDO2dCQUN0QiwyQkFBMkI7Z0JBQzNCLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztnQkFDUCwwQkFBMEI7Z0JBQzFCLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO2dCQUNSLEtBQUs7Z0JBQ0wsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO2dCQUNQLEtBQUs7Z0JBQ0wsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO2FBQ1IsQ0FBQyxDQUFDO1FBQ0wsQ0FBQzs7SUFsRHNCLG9CQUFTLEdBQVcsVUFBQSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsVUFBVSxDQUFDLENBQUM7SUFEbEUsb0JBQVUsYUFvRHRCLENBQUE7QUFDSCxDQUFDLEVBL0RTLFNBQVMsS0FBVCxTQUFTLFFBK0RsQjtBQy9ERCxJQUFVLFNBQVMsQ0E0Y2xCO0FBNWNELFdBQVUsU0FBUztJQUtqQjs7O09BR0c7SUFDSCxNQUFhLElBQUssU0FBUSxVQUFBLFlBQVk7UUFjcEM7OztXQUdHO1FBQ0gsWUFBbUIsS0FBYTtZQUM5QixLQUFLLEVBQUUsQ0FBQztZQWpCSCxhQUFRLEdBQWMsVUFBQSxTQUFTLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDM0Msb0JBQWUsR0FBVyxDQUFDLENBQUM7WUFFM0IsV0FBTSxHQUFnQixJQUFJLENBQUMsQ0FBQywyQkFBMkI7WUFDdkQsYUFBUSxHQUFXLEVBQUUsQ0FBQyxDQUFDLDhDQUE4QztZQUNyRSxlQUFVLEdBQXlCLEVBQUUsQ0FBQztZQUM5QyxtSEFBbUg7WUFDbkgsNEdBQTRHO1lBQ3BHLGNBQVMsR0FBMkIsRUFBRSxDQUFDO1lBQ3ZDLGFBQVEsR0FBMkIsRUFBRSxDQUFDO1lBQ3RDLFdBQU0sR0FBWSxJQUFJLENBQUM7WUF5RS9COzs7ZUFHRztZQUNILDRDQUE0QztZQUM1QixnQkFBVyxHQUEwQixJQUFJLENBQUMsUUFBUSxDQUFDO1lBdEVqRSxJQUFJLENBQUMsSUFBSSxHQUFHLEtBQUssQ0FBQztRQUNwQixDQUFDO1FBRU0sUUFBUSxDQUFDLEdBQVk7WUFDMUIsSUFBSSxDQUFDLE1BQU0sR0FBRyxHQUFHLENBQUM7WUFDbEIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyw4Q0FBMEIsQ0FBQyxpREFBMkIsQ0FBQyxDQUFDLENBQUM7UUFDN0YsQ0FBQztRQUNELElBQVcsUUFBUTtZQUNqQixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUM7UUFDckIsQ0FBQztRQUVEOztXQUVHO1FBQ0ksU0FBUztZQUNkLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUNyQixDQUFDO1FBRUQ7O1dBRUc7UUFDSSxXQUFXO1lBQ2hCLElBQUksUUFBUSxHQUFTLElBQUksQ0FBQztZQUMxQixPQUFPLFFBQVEsQ0FBQyxTQUFTLEVBQUU7Z0JBQ3pCLFFBQVEsR0FBRyxRQUFRLENBQUMsU0FBUyxFQUFFLENBQUM7WUFDbEMsT0FBTyxRQUFRLENBQUM7UUFDbEIsQ0FBQztRQUVEOztXQUVHO1FBQ0gsSUFBVyxZQUFZO1lBQ3JCLE9BQTJCLElBQUksQ0FBQyxhQUFhLENBQUMsVUFBQSxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3ZFLENBQUM7UUFDRDs7O1dBR0c7UUFDSCxxSEFBcUg7UUFDckgscUNBQXFDO1FBQ3JDLGdFQUFnRTtRQUNoRSx3QkFBd0I7UUFDeEIscUNBQXFDO1FBQ3JDLFdBQVc7UUFDWCx1QkFBdUI7UUFDdkIsSUFBSTtRQUVKLG9CQUFvQjtRQUNwQjs7V0FFRztRQUNJLFdBQVc7WUFDaEIsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNoQyxDQUFDO1FBQ0Q7Ozs7V0FJRztRQUNJLGlCQUFpQixDQUFDLEtBQWE7WUFDcEMsSUFBSSxLQUFLLEdBQVcsRUFBRSxDQUFDO1lBQ3ZCLEtBQUssR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEtBQVcsRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksSUFBSSxLQUFLLENBQUMsQ0FBQztZQUNuRSxPQUFPLEtBQUssQ0FBQztRQUNmLENBQUM7UUFTRDs7OztXQUlHO1FBQ0ksUUFBUSxDQUFDLEtBQVc7WUFDekIsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUM7Z0JBQy9CLG1DQUFtQztnQkFDbkMsT0FBTztZQUVULElBQUksYUFBYSxHQUFZLEtBQUssQ0FBQztZQUNuQyxJQUFJLGNBQWMsR0FBUyxVQUFBLFlBQVksQ0FBQyxPQUFPLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztZQUN2RSxJQUFJLFFBQVEsR0FBUyxJQUFJLENBQUM7WUFDMUIsT0FBTyxRQUFRLEVBQUU7Z0JBQ2YsUUFBUSxDQUFDLGVBQWUsR0FBRyxDQUFDLENBQUM7Z0JBQzdCLGFBQWEsR0FBRyxhQUFhLElBQUksQ0FBQyxRQUFRLElBQUksY0FBYyxDQUFDLENBQUM7Z0JBQzlELElBQUksUUFBUSxJQUFJLEtBQUs7b0JBQ25CLE1BQU0sQ0FBQyxJQUFJLEtBQUssQ0FBQyx3RkFBd0YsQ0FBQyxDQUFDLENBQUM7O29CQUU1RyxRQUFRLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQzthQUM5QjtZQUVELElBQUksY0FBYyxHQUFTLEtBQUssQ0FBQyxNQUFNLENBQUM7WUFDeEMsSUFBSSxjQUFjO2dCQUNoQixjQUFjLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3BDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzFCLEtBQUssQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDO1lBQ3BCLEtBQUssQ0FBQyxhQUFhLENBQUMsSUFBSSxLQUFLLG1DQUFxQixFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDdEUsSUFBSSxhQUFhO2dCQUNmLEtBQUssQ0FBQyxjQUFjLENBQUMsSUFBSSxLQUFLLCtDQUEwQixDQUFDLENBQUM7UUFDOUQsQ0FBQztRQUVEOzs7V0FHRztRQUNJLFdBQVcsQ0FBQyxLQUFXO1lBQzVCLElBQUksS0FBSyxHQUFXLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDMUMsSUFBSSxLQUFLLEdBQUcsQ0FBQztnQkFDWCxPQUFPO1lBRVQsS0FBSyxDQUFDLGFBQWEsQ0FBQyxJQUFJLEtBQUssbUNBQXFCLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQztZQUN0RSxJQUFJLElBQUksQ0FBQyxjQUFjLENBQUMsVUFBQSxZQUFZLENBQUMsT0FBTyxDQUFDLG9CQUFvQixFQUFFLENBQUM7Z0JBQ2xFLEtBQUssQ0FBQyxjQUFjLENBQUMsSUFBSSxLQUFLLGlEQUEwQixDQUFDLENBQUM7WUFDNUQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQy9CLEtBQUssQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDO1FBQ3RCLENBQUM7UUFFRDs7O1dBR0c7UUFDSSxTQUFTLENBQUMsS0FBVztZQUMxQixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3RDLENBQUM7UUFFRDs7OztXQUlHO1FBQ0ksWUFBWSxDQUFDLFFBQWMsRUFBRSxLQUFXO1lBQzdDLElBQUksS0FBSyxHQUFXLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDN0MsSUFBSSxLQUFLLEdBQUcsQ0FBQztnQkFDWCxPQUFPLEtBQUssQ0FBQztZQUVmLElBQUksY0FBYyxHQUFTLEtBQUssQ0FBQyxTQUFTLEVBQUUsQ0FBQztZQUM3QyxJQUFJLGNBQWM7Z0JBQ2hCLGNBQWMsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUM7WUFFcEMsUUFBUSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUM7WUFDdkIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsR0FBRyxLQUFLLENBQUM7WUFDN0IsS0FBSyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUM7WUFFcEIsS0FBSyxDQUFDLGFBQWEsQ0FBQyxJQUFJLEtBQUssbUNBQXFCLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQztZQUN0RSxJQUFJLElBQUksQ0FBQyxjQUFjLENBQUMsVUFBQSxZQUFZLENBQUMsT0FBTyxDQUFDLG9CQUFvQixFQUFFLENBQUM7Z0JBQ2xFLEtBQUssQ0FBQyxjQUFjLENBQUMsSUFBSSxLQUFLLCtDQUEwQixDQUFDLENBQUM7WUFFNUQsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO1FBRUQ7O1dBRUc7UUFDSCxJQUFXLE1BQU07WUFDZixPQUFPLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1FBQ25DLENBQUM7UUFFTSxTQUFTLENBQUMsZ0JBQXdCO1lBQ3ZDLE9BQU8sQ0FBQyxJQUFJLENBQUMsZUFBZSxJQUFJLGdCQUFnQixDQUFDLENBQUM7UUFDcEQsQ0FBQztRQUVNLGNBQWMsQ0FBQyxTQUFlO1lBQ25DLElBQUksSUFBSSxHQUFTLElBQUksQ0FBQztZQUN0QixPQUFPLElBQUksSUFBSSxJQUFJLElBQUksU0FBUztnQkFDOUIsSUFBSSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7WUFDckIsT0FBTyxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsQ0FBQztRQUN4QixDQUFDO1FBRUQ7OztXQUdHO1FBQ0ksY0FBYyxDQUFDLFFBQWlCO1lBQ3JDLElBQUksUUFBUSxDQUFDLFVBQVUsRUFBRTtnQkFDdkIsS0FBSyxJQUFJLGFBQWEsSUFBSSxRQUFRLENBQUMsVUFBVSxFQUFFO29CQUM3QyxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLEVBQUU7d0JBQ2xDLElBQUksa0JBQWtCLEdBQXFCLFFBQVEsQ0FBQyxVQUFVLENBQUM7d0JBQy9ELEtBQUssSUFBSSxDQUFDLElBQUksa0JBQWtCLENBQUMsYUFBYSxDQUFDLEVBQUU7NEJBQy9DLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO2dDQUN0QyxJQUFJLGlCQUFpQixHQUFjLElBQUksQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQ0FDdEUsSUFBSSxZQUFZLEdBQStCLGtCQUFrQixDQUFDLGFBQWEsQ0FBRSxDQUFDO2dDQUNsRixJQUFJLHdCQUF3QixHQUFxQixZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQ0FDbEUsS0FBSyxJQUFJLEtBQUssSUFBSSx3QkFBd0IsRUFBRSxFQUFJLCtDQUErQztvQ0FDN0YsSUFBSSxhQUFhLEdBQXFCLHdCQUF3QixDQUFDLEtBQUssQ0FBQyxDQUFDO29DQUN0RSxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUM7aUNBQ3pDOzZCQUNGO3lCQUNGO3FCQUNGO2lCQUNGO2FBQ0Y7WUFDRCxJQUFJLFFBQVEsQ0FBQyxRQUFRLEVBQUU7Z0JBQ3JCLEtBQUssSUFBSSxDQUFDLEdBQVcsQ0FBQyxFQUFFLENBQUMsR0FBbUIsUUFBUSxDQUFDLFFBQVMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7b0JBQzFFLElBQUksSUFBSSxHQUFtQyxRQUFRLENBQUMsUUFBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBRSxDQUFDLElBQUksQ0FBQztvQkFDakYsSUFBSSxVQUFVLEdBQVcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxDQUFDO29CQUN0RCxLQUFLLElBQUksU0FBUyxJQUFJLFVBQVUsRUFBRTt3QkFDaEMsU0FBUyxDQUFDLGNBQWMsQ0FBMkIsUUFBUSxDQUFDLFFBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO3FCQUNyRjtpQkFDRjthQUNGO1FBQ0gsQ0FBQztRQUNELGFBQWE7UUFFYixxQkFBcUI7UUFDckI7O1dBRUc7UUFDSSxnQkFBZ0I7WUFDckIsSUFBSSxHQUFHLEdBQWdCLEVBQUUsQ0FBQztZQUMxQixLQUFLLElBQUksSUFBSSxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUU7Z0JBQ2hDLEdBQUcsR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQzthQUN6QztZQUNELE9BQU8sR0FBRyxDQUFDO1FBQ2IsQ0FBQztRQUVEOzs7V0FHRztRQUNJLGFBQWEsQ0FBc0IsTUFBbUI7WUFDM0QsT0FBWSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM1RCxDQUFDO1FBQ0Q7OztXQUdHO1FBQ0ksWUFBWSxDQUFzQixNQUFtQjtZQUMxRCxJQUFJLElBQUksR0FBYSxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNsRCxJQUFJLElBQUk7Z0JBQ04sT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDakIsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO1FBRUQ7OztXQUdHO1FBQ0ksWUFBWSxDQUFDLFVBQXFCO1lBQ3ZDLElBQUksVUFBVSxDQUFDLFlBQVksRUFBRSxJQUFJLElBQUk7Z0JBQ25DLE9BQU87WUFDVCxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxLQUFLLFNBQVM7Z0JBQ2hELElBQUksQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7aUJBRWhELElBQUksVUFBVSxDQUFDLFdBQVc7Z0JBQ3hCLE1BQU0sSUFBSSxLQUFLLENBQUMsK0VBQStFLENBQUMsQ0FBQzs7Z0JBRWpHLElBQUksQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUV0RCxVQUFVLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQzlCLFVBQVUsQ0FBQyxhQUFhLENBQUMsSUFBSSxLQUFLLG9DQUFxQixDQUFDLENBQUM7UUFDM0QsQ0FBQztRQUNEOzs7O1dBSUc7UUFDSSxlQUFlLENBQUMsVUFBcUI7WUFDMUMsSUFBSTtnQkFDRixJQUFJLGdCQUFnQixHQUFnQixJQUFJLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDckUsSUFBSSxPQUFPLEdBQVcsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDO2dCQUMzRCxJQUFJLE9BQU8sR0FBRyxDQUFDO29CQUNiLE9BQU87Z0JBQ1QsVUFBVSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEtBQUssMENBQXdCLENBQUMsQ0FBQztnQkFDNUQsZ0JBQWdCLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDcEMsVUFBVSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUMvQjtZQUFDLE9BQU8sTUFBTSxFQUFFO2dCQUNmLE1BQU0sSUFBSSxLQUFLLENBQUMsK0JBQStCLFVBQVUsbUJBQW1CLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO2FBQzNGO1FBQ0gsQ0FBQztRQUNELGFBQWE7UUFFYix3QkFBd0I7UUFDakIsU0FBUztZQUNkLElBQUksYUFBYSxHQUFrQjtnQkFDakMsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJO2FBQ2hCLENBQUM7WUFFRixJQUFJLFVBQVUsR0FBa0IsRUFBRSxDQUFDO1lBQ25DLEtBQUssSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRTtnQkFDaEMsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQkFDdEIsS0FBSyxJQUFJLFNBQVMsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxFQUFFO29CQUMzQyxnREFBZ0Q7b0JBQ2hELFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBQSxVQUFVLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7aUJBQ3hEO2FBQ0Y7WUFDRCxhQUFhLENBQUMsWUFBWSxDQUFDLEdBQUcsVUFBVSxDQUFDO1lBRXpDLElBQUksUUFBUSxHQUFvQixFQUFFLENBQUM7WUFDbkMsS0FBSyxJQUFJLEtBQUssSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO2dCQUMvQixRQUFRLENBQUMsSUFBSSxDQUFDLFVBQUEsVUFBVSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO2FBQzVDO1lBQ0QsYUFBYSxDQUFDLFVBQVUsQ0FBQyxHQUFHLFFBQVEsQ0FBQztZQUVyQyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksS0FBSyx3Q0FBdUIsQ0FBQyxDQUFDO1lBQ3JELE9BQU8sYUFBYSxDQUFDO1FBQ3ZCLENBQUM7UUFFTSxXQUFXLENBQUMsY0FBNkI7WUFDOUMsSUFBSSxDQUFDLElBQUksR0FBRyxjQUFjLENBQUMsSUFBSSxDQUFDO1lBQ2hDLGdEQUFnRDtZQUVoRCwrRUFBK0U7WUFDL0UsS0FBSyxJQUFJLElBQUksSUFBSSxjQUFjLENBQUMsVUFBVSxFQUFFO2dCQUMxQyxLQUFLLElBQUksbUJBQW1CLElBQUksY0FBYyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsRUFBRTtvQkFDL0QsSUFBSSxxQkFBcUIsR0FBeUIsVUFBQSxVQUFVLENBQUMsV0FBVyxDQUFDLG1CQUFtQixDQUFDLENBQUM7b0JBQzlGLElBQUksQ0FBQyxZQUFZLENBQUMscUJBQXFCLENBQUMsQ0FBQztpQkFDMUM7YUFDRjtZQUVELEtBQUssSUFBSSxlQUFlLElBQUksY0FBYyxDQUFDLFFBQVEsRUFBRTtnQkFDbkQsSUFBSSxpQkFBaUIsR0FBZSxVQUFBLFVBQVUsQ0FBQyxXQUFXLENBQUMsZUFBZSxDQUFDLENBQUM7Z0JBQzVFLElBQUksQ0FBQyxXQUFXLENBQUMsaUJBQWlCLENBQUMsQ0FBQzthQUNyQztZQUVELElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxLQUFLLDRDQUF5QixDQUFDLENBQUM7WUFDdkQsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO1FBQ0QsYUFBYTtRQUViLGlCQUFpQjtRQUNqQjs7Ozs7O1dBTUc7UUFDSSxnQkFBZ0IsQ0FBQyxLQUFxQixFQUFFLFFBQXVCLEVBQUUsV0FBa0QsS0FBSztZQUM3SCxJQUFJLGFBQWEsR0FBMkIsUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDO1lBQ3RGLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDO2dCQUN2QixhQUFhLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQzVCLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDdEMsQ0FBQztRQUNEOzs7OztXQUtHO1FBQ0ksbUJBQW1CLENBQUMsS0FBcUIsRUFBRSxRQUF1QixFQUFFLFdBQWtELEtBQUs7WUFDaEksSUFBSSxnQkFBZ0IsR0FBb0IsUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ2hHLElBQUksZ0JBQWdCO2dCQUNsQixLQUFLLElBQUksQ0FBQyxHQUFXLGdCQUFnQixDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUU7b0JBQzNELElBQUksZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLElBQUksUUFBUTt3QkFDakMsZ0JBQWdCLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUN0QyxDQUFDO1FBQ0Q7Ozs7O1dBS0c7UUFDSSxhQUFhLENBQUMsTUFBYTtZQUNoQyxJQUFJLFNBQVMsR0FBVyxFQUFFLENBQUM7WUFDM0IsSUFBSSxRQUFRLEdBQVMsSUFBSSxDQUFDO1lBQzFCLHlCQUF5QjtZQUN6QixNQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxRQUFRLEVBQUUsRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO1lBQ3pFLDRGQUE0RjtZQUM1RixPQUFPLFFBQVEsQ0FBQyxNQUFNO2dCQUNwQixTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUM7WUFFN0MsZ0JBQWdCO1lBQ2hCLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLFlBQVksRUFBRSxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLEtBQUssQ0FBQyxlQUFlLEVBQUUsQ0FBQyxDQUFDO1lBQzlGLEtBQUssSUFBSSxDQUFDLEdBQVcsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDdEQsSUFBSSxRQUFRLEdBQVMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNsQyxNQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxlQUFlLEVBQUUsRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsQ0FBQyxDQUFDO2dCQUNwRixJQUFJLFFBQVEsR0FBb0IsUUFBUSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO2dCQUNyRSxLQUFLLElBQUksT0FBTyxJQUFJLFFBQVE7b0JBQzFCLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQzthQUNuQjtZQUVELElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTztnQkFDakIsT0FBTyxJQUFJLENBQUM7WUFFZCxlQUFlO1lBQ2YsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsWUFBWSxFQUFFLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUM7WUFDeEYsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsZUFBZSxFQUFFLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztZQUNoRixJQUFJLFNBQVMsR0FBb0IsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1lBQ25FLEtBQUssSUFBSSxPQUFPLElBQUksU0FBUztnQkFDM0IsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBRWxCLGVBQWU7WUFDZixNQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxZQUFZLEVBQUUsRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUMsY0FBYyxFQUFFLENBQUMsQ0FBQztZQUM3RixLQUFLLElBQUksQ0FBQyxHQUFXLENBQUMsRUFBRSxDQUFDLEdBQUcsU0FBUyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDakQsSUFBSSxRQUFRLEdBQVMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNsQyxNQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxlQUFlLEVBQUUsRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsQ0FBQyxDQUFDO2dCQUNwRixJQUFJLFNBQVMsR0FBZSxRQUFRLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7Z0JBQ2xFLEtBQUssSUFBSSxPQUFPLElBQUksU0FBUztvQkFDM0IsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO2FBQ25CO1lBQ0QsT0FBTyxJQUFJLENBQUMsQ0FBQyxzRUFBc0U7UUFDckYsQ0FBQztRQUNEOzs7O1dBSUc7UUFDSSxjQUFjLENBQUMsTUFBYTtZQUNqQyxtQ0FBbUM7WUFDbkMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsWUFBWSxFQUFFLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLGVBQWUsRUFBRSxDQUFDLENBQUM7WUFDOUYsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsUUFBUSxFQUFFLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztZQUN6RSxJQUFJLENBQUMsdUJBQXVCLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDdkMsQ0FBQztRQUVPLHVCQUF1QixDQUFDLE1BQWE7WUFDM0MscUJBQXFCO1lBQ3JCLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLGVBQWUsRUFBRSxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7WUFDaEYsSUFBSSxRQUFRLEdBQWUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1lBQzVELEtBQUssSUFBSSxPQUFPLElBQUksUUFBUTtnQkFDMUIsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ2xCLHlDQUF5QztZQUN6Qyx3REFBd0Q7WUFDeEQsdUJBQXVCO1lBQ3ZCLE1BQU07WUFFTixvQkFBb0I7WUFDcEIsS0FBSyxJQUFJLEtBQUssSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO2dCQUMvQixLQUFLLENBQUMsdUJBQXVCLENBQUMsTUFBTSxDQUFDLENBQUM7YUFDdkM7UUFDSCxDQUFDO1FBQ0QsYUFBYTtRQUVMLENBQUUsa0JBQWtCO1lBQzFCLE1BQU0sSUFBSSxDQUFDO1lBQ1gsS0FBSyxJQUFJLEtBQUssSUFBSSxJQUFJLENBQUMsUUFBUTtnQkFDN0IsS0FBSyxDQUFDLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQztRQUN4QixDQUFDO0tBQ0Y7SUFsY1ksY0FBSSxPQWtjaEIsQ0FBQTtBQUNILENBQUMsRUE1Y1MsU0FBUyxLQUFULFNBQVMsUUE0Y2xCO0FDNWNELElBQVUsU0FBUyxDQU9sQjtBQVBELFdBQVUsU0FBUztJQUNmOztPQUVHO0lBQ0gsTUFBYSxZQUFhLFNBQVEsVUFBQSxJQUFJO1FBQXRDOztZQUNXLGVBQVUsR0FBVyxTQUFTLENBQUM7UUFDMUMsQ0FBQztLQUFBO0lBRlksc0JBQVksZUFFeEIsQ0FBQTtBQUNMLENBQUMsRUFQUyxTQUFTLEtBQVQsU0FBUyxRQU9sQjtBQ1BELElBQVUsU0FBUyxDQXVEbEI7QUF2REQsV0FBVSxTQUFTO0lBQ2Y7OztPQUdHO0lBQ0gsTUFBYSxvQkFBcUIsU0FBUSxVQUFBLElBQUk7UUFLMUMsWUFBWSxhQUEyQjtZQUNuQyxLQUFLLENBQUMsc0JBQXNCLENBQUMsQ0FBQztZQUxsQyx3REFBd0Q7WUFDeEQsNkZBQTZGO1lBQ3JGLGFBQVEsR0FBVyxTQUFTLENBQUM7WUFJakMsSUFBSSxhQUFhO2dCQUNiLElBQUksQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDaEMsQ0FBQztRQUVEOztXQUVHO1FBQ0ksS0FBSztZQUNSLElBQUksUUFBUSxHQUErQixVQUFBLGVBQWUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQzlFLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDdkIsQ0FBQztRQUVELDhGQUE4RjtRQUN2RixTQUFTO1lBQ1osSUFBSSxhQUFhLEdBQWtCLEtBQUssQ0FBQyxTQUFTLEVBQUUsQ0FBQztZQUNyRCxhQUFhLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7WUFDdkMsT0FBTyxhQUFhLENBQUM7UUFDekIsQ0FBQztRQUVNLFdBQVcsQ0FBQyxjQUE2QjtZQUM1QyxLQUFLLENBQUMsV0FBVyxDQUFDLGNBQWMsQ0FBQyxDQUFDO1lBQ2xDLElBQUksQ0FBQyxRQUFRLEdBQUcsY0FBYyxDQUFDLFFBQVEsQ0FBQztZQUN4QyxPQUFPLElBQUksQ0FBQztRQUNoQixDQUFDO1FBRUQ7OztXQUdHO1FBQ0ssR0FBRyxDQUFDLGFBQTJCO1lBQ25DLDRGQUE0RjtZQUM1RixJQUFJLGFBQWEsR0FBa0IsVUFBQSxVQUFVLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQ3ZFLHdDQUF3QztZQUN4QyxLQUFLLElBQUksSUFBSSxJQUFJLGFBQWEsRUFBRTtnQkFDNUIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztnQkFDdEMsTUFBTTthQUNUO1lBQ0QsSUFBSSxDQUFDLFFBQVEsR0FBRyxhQUFhLENBQUMsVUFBVSxDQUFDO1lBQ3pDLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxLQUFLLDREQUFpQyxDQUFDLENBQUM7UUFDbkUsQ0FBQztLQUdKO0lBakRZLDhCQUFvQix1QkFpRGhDLENBQUE7QUFDTCxDQUFDLEVBdkRTLFNBQVMsS0FBVCxTQUFTLFFBdURsQjtBQ3ZERCxJQUFVLFNBQVMsQ0FZbEI7QUFaRCxXQUFVLFNBQVM7SUFDZixNQUFhLEdBQUc7UUFLWixZQUFZLGFBQXNCLFVBQUEsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLFVBQW1CLFVBQUEsT0FBTyxDQUFDLElBQUksRUFBRSxFQUFFLFVBQWtCLENBQUM7WUFDbkcsSUFBSSxDQUFDLE1BQU0sR0FBRyxPQUFPLENBQUM7WUFDdEIsSUFBSSxDQUFDLFNBQVMsR0FBRyxVQUFVLENBQUM7WUFDNUIsSUFBSSxDQUFDLE1BQU0sR0FBRyxPQUFPLENBQUM7UUFDMUIsQ0FBQztLQUNKO0lBVlksYUFBRyxNQVVmLENBQUE7QUFDTCxDQUFDLEVBWlMsU0FBUyxLQUFULFNBQVMsUUFZbEI7QUNaRCxJQUFVLFNBQVMsQ0FZbEI7QUFaRCxXQUFVLFNBQVM7SUFDZixNQUFhLE1BQU07UUFLZixZQUFZLFFBQWMsSUFBSSxFQUFFLFFBQWdCLENBQUMsRUFBRSxXQUFtQixDQUFDO1lBQ25FLElBQUksQ0FBQyxJQUFJLEdBQUcsS0FBSyxDQUFDO1lBQ2xCLElBQUksQ0FBQyxJQUFJLEdBQUcsS0FBSyxDQUFDO1lBQ2xCLElBQUksQ0FBQyxPQUFPLEdBQUcsUUFBUSxDQUFDO1FBQzVCLENBQUM7S0FDSjtJQVZZLGdCQUFNLFNBVWxCLENBQUE7QUFDTCxDQUFDLEVBWlMsU0FBUyxLQUFULFNBQVMsUUFZbEI7QUNaRCwwQ0FBMEM7QUFDMUMsSUFBVSxTQUFTLENBMGNsQjtBQTNjRCwwQ0FBMEM7QUFDMUMsV0FBVSxTQUFTO0lBZWpCOzs7T0FHRztJQUNILE1BQU0sU0FBUztRQUliLFlBQVksVUFBYTtZQUZqQixVQUFLLEdBQVcsQ0FBQyxDQUFDO1lBR3hCLElBQUksQ0FBQyxTQUFTLEdBQUcsVUFBVSxDQUFDO1FBQzlCLENBQUM7UUFFTSxZQUFZO1lBQ2pCLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQztRQUN4QixDQUFDO1FBRU0sZUFBZTtZQUNwQixJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7WUFDYixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUM7UUFDcEIsQ0FBQztRQUNNLGVBQWU7WUFDcEIsSUFBSSxJQUFJLENBQUMsS0FBSyxJQUFJLENBQUM7Z0JBQUUsTUFBTSxDQUFDLElBQUksS0FBSyxDQUFDLDRCQUE0QixDQUFDLENBQUMsQ0FBQztZQUNyRSxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7WUFDYixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUM7UUFDcEIsQ0FBQztLQUNGO0lBRUQ7Ozs7T0FJRztJQUNILE1BQXNCLGFBQWMsU0FBUSxVQUFBLGNBQWM7UUFZeEQsaUJBQWlCO1FBQ2pCOzs7V0FHRztRQUNJLE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBVztZQUMvQixJQUFJLGFBQWEsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQztnQkFDaEMsT0FBTztZQUVULElBQUksV0FBVyxHQUFzQixLQUFLLENBQUMsWUFBWSxDQUFDLFVBQUEsaUJBQWlCLENBQUMsQ0FBQztZQUMzRSxJQUFJLENBQUMsV0FBVztnQkFDZCxPQUFPO1lBRVQsSUFBSSxNQUFNLEdBQWtCLFdBQVcsQ0FBQyxRQUFRLENBQUMsU0FBUyxFQUFFLENBQUM7WUFDN0QsYUFBYSxDQUFDLGVBQWUsQ0FBOEIsYUFBYSxDQUFDLGFBQWEsRUFBRSxNQUFNLEVBQUUsYUFBYSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBRTdILG1EQUFtRDtZQUNuRCxtSEFBbUg7WUFFbkgsSUFBSSxJQUFJLEdBQXlCLEtBQUssQ0FBQyxZQUFZLENBQUMsVUFBQSxhQUFhLENBQUUsQ0FBQyxJQUFJLENBQUM7WUFDekUsYUFBYSxDQUFDLGVBQWUsQ0FBc0IsYUFBYSxDQUFDLGFBQWEsRUFBRSxJQUFJLEVBQUUsYUFBYSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQ25ILElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUUvQix3SEFBd0g7WUFDeEgsSUFBSSxjQUFjLEdBQW1CLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxlQUFlLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsa0NBQWtDO1lBQ3ZILGFBQWEsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxjQUFjLENBQUMsQ0FBQztRQUNqRCxDQUFDO1FBRUQ7Ozs7V0FJRztRQUNJLE1BQU0sQ0FBQyxTQUFTLENBQUMsS0FBVztZQUNqQywrQkFBK0I7WUFDL0Isc0RBQXNEO1lBQ3RELG9CQUFvQjtZQUNwQixLQUFLLElBQUksSUFBSSxJQUFJLEtBQUssQ0FBQyxNQUFNO2dCQUMzQixJQUFJO29CQUNGLDJEQUEyRDtvQkFDM0QsYUFBYSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztpQkFDN0I7Z0JBQUMsT0FBTyxNQUFNLEVBQUU7b0JBQ2YsVUFBQSxLQUFLLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDO2lCQUNuQjtZQUNILE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUNELGFBQWE7UUFFYixtQkFBbUI7UUFDbkI7OztXQUdHO1FBQ0ksTUFBTSxDQUFDLFVBQVUsQ0FBQyxLQUFXO1lBQ2xDLElBQUksY0FBYyxHQUFtQixhQUFhLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNwRSxJQUFJLENBQUMsY0FBYztnQkFDakIsT0FBTztZQUVULGFBQWEsQ0FBQyxlQUFlLENBQThCLGFBQWEsQ0FBQyxhQUFhLEVBQUUsY0FBYyxDQUFDLE1BQU0sRUFBRSxhQUFhLENBQUMsYUFBYSxDQUFDLENBQUM7WUFDNUksa0lBQWtJO1lBQ2xJLGFBQWEsQ0FBQyxlQUFlLENBQXNCLGFBQWEsQ0FBQyxhQUFhLEVBQUUsY0FBYyxDQUFDLElBQUksRUFBRSxhQUFhLENBQUMsYUFBYSxDQUFDLENBQUM7WUFFbEksYUFBYSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7WUFFbEMsY0FBYyxDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNoRCxDQUFDO1FBRUQ7OztXQUdHO1FBQ0ksTUFBTSxDQUFDLFlBQVksQ0FBQyxLQUFXO1lBQ3BDLEtBQUssSUFBSSxJQUFJLElBQUksS0FBSyxDQUFDLE1BQU07Z0JBQzNCLGFBQWEsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDbkMsQ0FBQztRQUNELGFBQWE7UUFFYixtQkFBbUI7UUFDbkI7OztXQUdHO1FBQ0ksTUFBTSxDQUFDLFVBQVUsQ0FBQyxLQUFXO1lBQ2xDLElBQUksY0FBYyxHQUFtQixhQUFhLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNwRSxJQUFJLENBQUMsY0FBYztnQkFDakIsT0FBTztZQUVULElBQUksV0FBVyxHQUFzQixLQUFLLENBQUMsWUFBWSxDQUFDLFVBQUEsaUJBQWlCLENBQUMsQ0FBQztZQUUzRSxJQUFJLE1BQU0sR0FBa0IsV0FBVyxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUUsQ0FBQztZQUM3RCxJQUFJLE1BQU0sS0FBSyxjQUFjLENBQUMsTUFBTSxFQUFFO2dCQUNwQyxhQUFhLENBQUMsZUFBZSxDQUE4QixhQUFhLENBQUMsYUFBYSxFQUFFLGNBQWMsQ0FBQyxNQUFNLEVBQUUsYUFBYSxDQUFDLGFBQWEsQ0FBQyxDQUFDO2dCQUM1SSxhQUFhLENBQUMsZUFBZSxDQUE4QixhQUFhLENBQUMsYUFBYSxFQUFFLE1BQU0sRUFBRSxhQUFhLENBQUMsYUFBYSxDQUFDLENBQUM7Z0JBQzdILGNBQWMsQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO2FBQ2hDO1lBRUQsbURBQW1EO1lBQ25ELHNDQUFzQztZQUN0QyxvSUFBb0k7WUFDcEkscUhBQXFIO1lBQ3JILGdDQUFnQztZQUNoQyxJQUFJO1lBRUosSUFBSSxJQUFJLEdBQXlCLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxVQUFBLGFBQWEsQ0FBQyxDQUFFLENBQUMsSUFBSSxDQUFDO1lBQzNFLElBQUksSUFBSSxLQUFLLGNBQWMsQ0FBQyxJQUFJLEVBQUU7Z0JBQ2hDLGFBQWEsQ0FBQyxlQUFlLENBQXNCLGFBQWEsQ0FBQyxhQUFhLEVBQUUsY0FBYyxDQUFDLElBQUksRUFBRSxhQUFhLENBQUMsYUFBYSxDQUFDLENBQUM7Z0JBQ2xJLGFBQWEsQ0FBQyxlQUFlLENBQXNCLGFBQWEsQ0FBQyxhQUFhLEVBQUUsSUFBSSxFQUFFLGFBQWEsQ0FBQyxhQUFhLENBQUMsQ0FBQztnQkFDbkgsY0FBYyxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7YUFDNUI7UUFDSCxDQUFDO1FBRUQ7OztXQUdHO1FBQ0ksTUFBTSxDQUFDLFlBQVksQ0FBQyxLQUFXO1lBQ3BDLEtBQUssSUFBSSxJQUFJLElBQUksS0FBSyxDQUFDLE1BQU07Z0JBQzNCLGFBQWEsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDbkMsQ0FBQztRQUNELGFBQWE7UUFFYixpQkFBaUI7UUFDakI7Ozs7V0FJRztRQUNJLE1BQU0sQ0FBQyxTQUFTLENBQUMsT0FBZ0M7WUFDdEQsOEVBQThFO1lBQzlFLEtBQUssSUFBSSxLQUFLLElBQUksYUFBYSxDQUFDLGFBQWEsRUFBRTtnQkFDN0MsSUFBSSxZQUFZLEdBQWlCLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLEVBQUUsQ0FBQztnQkFDekQsYUFBYSxDQUFDLGlCQUFpQixDQUFDLFlBQVksRUFBRSxPQUFPLENBQUMsQ0FBQzthQUN4RDtZQUNELFlBQVk7UUFDZCxDQUFDO1FBQ0QsYUFBYTtRQUViLG9CQUFvQjtRQUNwQjs7V0FFRztRQUNJLE1BQU0sQ0FBQyxNQUFNO1lBQ2xCLGFBQWEsQ0FBQyxlQUFlLEdBQUcsV0FBVyxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQ2xELGFBQWEsQ0FBQyw0QkFBNEIsRUFBRSxDQUFDO1FBQy9DLENBQUM7UUFFRDs7O1dBR0c7UUFDSSxNQUFNLENBQUMsS0FBSyxDQUFDLFNBQWdCLElBQUk7WUFDdEMsYUFBYSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3RFLGFBQWEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLHNCQUFzQixDQUFDLGdCQUFnQixHQUFHLHNCQUFzQixDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFDOUcsQ0FBQztRQUVEOztXQUVHO1FBQ0ksTUFBTSxDQUFDLGdCQUFnQixDQUFDLFNBQWdCLElBQUk7WUFDakQsYUFBYSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsc0JBQXNCLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQy9FLENBQUM7UUFFRDs7OztXQUlHO1FBQ0ksTUFBTSxDQUFDLFVBQVUsQ0FBQyxLQUFXLEVBQUUsVUFBMkIsRUFBRSxZQUFzQixhQUFhLENBQUMsUUFBUTtZQUM3RyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVE7Z0JBQ2pCLE9BQU87WUFDVCxJQUFJLFNBQVMsSUFBSSxhQUFhLENBQUMsUUFBUTtnQkFDckMsYUFBYSxDQUFDLGdCQUFnQixFQUFFLENBQUM7WUFFbkMsSUFBSSxjQUF5QixDQUFDO1lBRTlCLElBQUksT0FBTyxHQUFrQixLQUFLLENBQUMsWUFBWSxDQUFDLFVBQUEsYUFBYSxDQUFDLENBQUM7WUFDL0QsSUFBSSxPQUFPO2dCQUNULGNBQWMsR0FBRyxVQUFBLFNBQVMsQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7O2dCQUV6RSxjQUFjLEdBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLDJDQUEyQztZQUU5RSx5QkFBeUI7WUFDekIsSUFBSSxVQUFVLEdBQWMsVUFBQSxTQUFTLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxvQkFBb0IsRUFBRSxjQUFjLENBQUMsQ0FBQztZQUV0RyxTQUFTLENBQUMsS0FBSyxFQUFFLGNBQWMsRUFBRSxVQUFVLENBQUMsQ0FBQztZQUU3QyxLQUFLLElBQUksSUFBSSxJQUFJLEtBQUssQ0FBQyxXQUFXLEVBQUUsRUFBRTtnQkFDcEMsSUFBSSxTQUFTLEdBQVMsS0FBSyxDQUFDLFdBQVcsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUNoRCxhQUFhLENBQUMsVUFBVSxDQUFDLFNBQVMsRUFBRSxVQUFVLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQyxXQUFXO2FBQ3hFO1lBRUQsVUFBQSxRQUFRLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQzNCLElBQUksY0FBYyxJQUFJLEtBQUssQ0FBQyxRQUFRO2dCQUNsQyxVQUFBLFFBQVEsQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDbkMsQ0FBQztRQUVELDJCQUEyQjtRQUUzQjs7OztXQUlHO1FBQ0ksTUFBTSxDQUFDLG9CQUFvQixDQUFDLEtBQVcsRUFBRSxVQUEyQjtZQUN6RSxhQUFhLENBQUMsV0FBVyxHQUFHLEVBQUUsQ0FBQztZQUMvQixJQUFJLENBQUMsYUFBYSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsVUFBQSxhQUFhLENBQUM7Z0JBQ2pELGFBQWEsQ0FBQyxlQUFlLENBQThCLGFBQWEsQ0FBQyxhQUFhLEVBQUUsVUFBQSxhQUFhLEVBQUUsYUFBYSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBRXRJLDBEQUEwRDtZQUMxRCxVQUFBLGNBQWMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUNwQyxhQUFhLENBQUMsVUFBVSxDQUFDLEtBQUssRUFBRSxVQUFVLEVBQUUsYUFBYSxDQUFDLGtCQUFrQixDQUFDLENBQUM7WUFDOUUsVUFBQSxjQUFjLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxzQkFBc0IsQ0FBQyxTQUFTLEVBQUUsc0JBQXNCLENBQUMsbUJBQW1CLENBQUMsQ0FBQztZQUU1RyxhQUFhLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztZQUNqQyxPQUFPLGFBQWEsQ0FBQyxXQUFXLENBQUM7UUFDbkMsQ0FBQztRQUVNLE1BQU0sQ0FBQyxVQUFVLENBQUMsSUFBYSxFQUFFLFlBQTBCLEVBQUUsS0FBZ0I7WUFDbEYsSUFBSSxJQUFJLEdBQWEsRUFBRSxDQUFDO1lBRXhCLEtBQUssSUFBSSxVQUFVLElBQUksWUFBWSxFQUFFO2dCQUNuQyxhQUFhLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxzQkFBc0IsQ0FBQyxXQUFXLEVBQUUsVUFBVSxDQUFDLFdBQVcsQ0FBQyxDQUFDO2dCQUMvRix3RkFBd0Y7Z0JBQ3hGLElBQUksSUFBSSxHQUFlLElBQUksVUFBVSxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztnQkFDdEUsYUFBYSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxLQUFLLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxNQUFNLEVBQUUsc0JBQXNCLENBQUMsSUFBSSxFQUFFLHNCQUFzQixDQUFDLGFBQWEsRUFBRSxJQUFJLENBQUMsQ0FBQztnQkFDeEksSUFBSSxLQUFLLEdBQVcsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7Z0JBRWxELHlFQUF5RTtnQkFDekUsSUFBSSxPQUFPLEdBQVcsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUM7Z0JBQzFDLElBQUksR0FBRyxHQUFXLElBQUksVUFBQSxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUM7Z0JBRTFELElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7YUFDaEI7WUFFRCxPQUFPLElBQUksQ0FBQztRQUNkLENBQUM7UUFHTyxNQUFNLENBQUMsUUFBUSxDQUFDLEtBQVcsRUFBRSxlQUEwQixFQUFFLFdBQXNCO1lBQ3JGLElBQUksVUFBVSxHQUFtQixhQUFhLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNoRSxJQUFJLENBQUMsVUFBVTtnQkFDYixPQUFPO1lBRVQsSUFBSSxJQUFJLEdBQVMsS0FBSyxDQUFDLFlBQVksQ0FBQyxVQUFBLGlCQUFpQixDQUFDLENBQUMsUUFBUSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQzFFLElBQUksVUFBVSxHQUFpQixhQUFhLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsWUFBWSxFQUFFLENBQUM7WUFDakcsYUFBYSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsVUFBVSxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsZUFBZSxFQUFFLFdBQVcsQ0FBQyxDQUFDO1lBQ3BGLHNGQUFzRjtRQUN4RixDQUFDO1FBRU8sTUFBTSxDQUFDLGtCQUFrQixDQUFDLEtBQVcsRUFBRSxlQUEwQixFQUFFLFdBQXNCO1lBQy9GLHlCQUF5QjtZQUN6QixJQUFJLE1BQU0sR0FBaUIsYUFBYSxDQUFDLGlCQUFpQixFQUFFLENBQUM7WUFFN0QsTUFBTSxXQUFXLEdBQXFCLGFBQWEsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztZQUM3RSx5REFBeUQ7WUFDekQsYUFBYSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsc0JBQXNCLENBQUMsV0FBVyxFQUFFLFdBQVcsQ0FBQyxDQUFDO1lBQ3BGLG1EQUFtRDtZQUNuRCxNQUFNLGVBQWUsR0FBVyxzQkFBc0IsQ0FBQyxpQkFBaUIsQ0FBQztZQUN6RSxhQUFhLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLHNCQUFzQixDQUFDLFdBQVcsRUFBRSxlQUFlLEVBQUUsc0JBQXNCLENBQUMsVUFBVSxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQztZQUUzSSxJQUFJLFVBQVUsR0FBbUIsYUFBYSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDaEUsSUFBSSxDQUFDLFVBQVU7Z0JBQ2IsT0FBTyxDQUFDLHFDQUFxQztZQUUvQyxJQUFJLFVBQVUsR0FBZSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxXQUFXLEVBQUUsV0FBVyxFQUFFLENBQUM7WUFDeEYsYUFBYSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7WUFFM0MsSUFBSSxZQUFZLEdBQWlCLFVBQUEsY0FBYyxDQUFDLG1CQUFtQixDQUFDO1lBQ3BFLFVBQUEsY0FBYyxDQUFDLFVBQVUsQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUN4QyxVQUFVLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFlBQVksRUFBRSxlQUFlLEVBQUUsV0FBVyxFQUFFLGFBQWEsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7WUFFL0csVUFBQSxjQUFjLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxzQkFBc0IsQ0FBQyxTQUFTLEVBQUUsVUFBVSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsUUFBUSxFQUFFLHNCQUFzQixDQUFDLGNBQWMsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUVySiw2Q0FBNkM7UUFDL0MsQ0FBQztRQUVPLE1BQU0sQ0FBQyxpQkFBaUI7WUFDOUIsc0JBQXNCO1lBQ3RCLE1BQU0sa0JBQWtCLEdBQVcsYUFBYSxDQUFDLG9CQUFvQixFQUFFLENBQUMsS0FBSyxDQUFDO1lBQzlFLE1BQU0sbUJBQW1CLEdBQVcsYUFBYSxDQUFDLG9CQUFvQixFQUFFLENBQUMsTUFBTSxDQUFDO1lBQ2hGLE1BQU0sYUFBYSxHQUFpQixhQUFhLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1lBQ3ZFLGFBQWEsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLHNCQUFzQixDQUFDLFVBQVUsRUFBRSxhQUFhLENBQUMsQ0FBQztZQUVqRjtnQkFDRSxNQUFNLGNBQWMsR0FBVyxzQkFBc0IsQ0FBQyxLQUFLLENBQUM7Z0JBQzVELE1BQU0sTUFBTSxHQUFXLHNCQUFzQixDQUFDLElBQUksQ0FBQztnQkFDbkQsTUFBTSxJQUFJLEdBQVcsc0JBQXNCLENBQUMsYUFBYSxDQUFDO2dCQUMxRCxhQUFhLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FDM0Isc0JBQXNCLENBQUMsVUFBVSxFQUFFLENBQUMsRUFBRSxjQUFjLEVBQUUsa0JBQWtCLEVBQUUsbUJBQW1CLEVBQUUsQ0FBQyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUNySCxDQUFDO2dCQUVGLDBDQUEwQztnQkFDMUMsYUFBYSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsc0JBQXNCLENBQUMsVUFBVSxFQUFFLHNCQUFzQixDQUFDLGtCQUFrQixFQUFFLHNCQUFzQixDQUFDLE1BQU0sQ0FBQyxDQUFDO2dCQUM5SSxhQUFhLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxzQkFBc0IsQ0FBQyxVQUFVLEVBQUUsc0JBQXNCLENBQUMsY0FBYyxFQUFFLHNCQUFzQixDQUFDLGFBQWEsQ0FBQyxDQUFDO2dCQUNqSixhQUFhLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxzQkFBc0IsQ0FBQyxVQUFVLEVBQUUsc0JBQXNCLENBQUMsY0FBYyxFQUFFLHNCQUFzQixDQUFDLGFBQWEsQ0FBQyxDQUFDO2FBQ2xKO1lBRUQsT0FBTyxhQUFhLENBQUM7UUFDdkIsQ0FBQztRQUNELFlBQVk7UUFFWixrQ0FBa0M7UUFDbEM7O1dBRUc7UUFDSyxNQUFNLENBQUMsNEJBQTRCO1lBQ3pDLHlGQUF5RjtZQUN6Rix3SEFBd0g7WUFDeEgsb0RBQW9EO1lBQ3BELElBQUk7WUFFSix5RkFBeUY7WUFDekYsSUFBSSwrQkFBK0IsR0FBd0UsQ0FBQyxlQUErQixFQUFFLEtBQVcsRUFBRSxJQUE2QixFQUFFLEVBQUU7Z0JBQ3pMLCtDQUErQztnQkFDL0MsSUFBSSxRQUFRLEdBQVMsS0FBSyxDQUFDO2dCQUMzQixJQUFJLE1BQVksQ0FBQztnQkFDakIsT0FBTyxJQUFJLEVBQUU7b0JBQ1gsTUFBTSxHQUFHLFFBQVEsQ0FBQyxTQUFTLEVBQUUsQ0FBQztvQkFDOUIsSUFBSSxDQUFDLE1BQU07d0JBQ1QsTUFBTTtvQkFDUixJQUFJLEtBQUssQ0FBQyxTQUFTLENBQUMsYUFBYSxDQUFDLGVBQWUsQ0FBQzt3QkFDaEQsTUFBTTtvQkFDUixRQUFRLEdBQUcsTUFBTSxDQUFDO2lCQUNuQjtnQkFDRCx5REFBeUQ7Z0JBRXpELDJIQUEySDtnQkFDM0gsSUFBSSxNQUFNLEdBQWMsVUFBQSxTQUFTLENBQUMsUUFBUSxFQUFFLENBQUM7Z0JBQzdDLElBQUksTUFBTTtvQkFDUixNQUFNLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQztnQkFFM0IscUZBQXFGO2dCQUNyRixhQUFhLENBQUMsc0NBQXNDLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1lBQ3pFLENBQUMsQ0FBQztZQUVGLG9EQUFvRDtZQUNwRCx3REFBd0Q7WUFDeEQsYUFBYSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsK0JBQStCLENBQUMsQ0FBQztRQUMvRCxDQUFDO1FBRUQ7Ozs7O1dBS0c7UUFDSyxNQUFNLENBQUMsc0NBQXNDLENBQUMsS0FBVyxFQUFFLE1BQWlCO1lBQ2xGLElBQUksS0FBSyxHQUFjLE1BQU0sQ0FBQztZQUM5QixJQUFJLFlBQVksR0FBdUIsS0FBSyxDQUFDLFlBQVksQ0FBQztZQUMxRCxJQUFJLFlBQVk7Z0JBQ2QsS0FBSyxHQUFHLFVBQUEsU0FBUyxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBRS9ELEtBQUssQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDO1lBQ3ZCLEtBQUssQ0FBQyxlQUFlLEdBQUcsYUFBYSxDQUFDLGVBQWUsQ0FBQztZQUV0RCxLQUFLLElBQUksS0FBSyxJQUFJLEtBQUssQ0FBQyxXQUFXLEVBQUUsRUFBRTtnQkFDckMsYUFBYSxDQUFDLHNDQUFzQyxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQzthQUNwRTtRQUNILENBQUM7UUFDRCxhQUFhO1FBRWIsMkNBQTJDO1FBQzNDOzs7OztXQUtHO1FBQ0ssTUFBTSxDQUFDLGVBQWUsQ0FBeUIsR0FBMkMsRUFBRSxJQUFhLEVBQUUsUUFBa0I7WUFDbkksSUFBSSxTQUFtQyxDQUFDO1lBQ3hDLFNBQVMsR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQzFCLElBQUksU0FBUyxDQUFDLGVBQWUsRUFBRSxJQUFJLENBQUMsRUFBRTtnQkFDcEMsMkdBQTJHO2dCQUMzRyx1RUFBdUU7Z0JBQ3ZFLFFBQVEsQ0FBQyxTQUFTLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQztnQkFDbkMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUNsQjtRQUNILENBQUM7UUFFRDs7Ozs7V0FLRztRQUNLLE1BQU0sQ0FBQyxlQUFlLENBQXlCLEdBQTJDLEVBQUUsSUFBYSxFQUFFLFFBQWtCO1lBQ25JLElBQUksU0FBbUMsQ0FBQztZQUN4QyxTQUFTLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUMxQixJQUFJLFNBQVM7Z0JBQ1gsU0FBUyxDQUFDLGVBQWUsRUFBRSxDQUFDO2lCQUN6QjtnQkFDSCxJQUFJLE9BQU8sR0FBa0IsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUM1QyxTQUFTLEdBQUcsSUFBSSxTQUFTLENBQWdCLE9BQU8sQ0FBQyxDQUFDO2dCQUNsRCxTQUFTLENBQUMsZUFBZSxFQUFFLENBQUM7Z0JBQzVCLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO2FBQzFCO1FBQ0gsQ0FBQzs7SUF2WmEsc0JBQVEsR0FBYyxJQUFJLFVBQUEsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNoRSwrR0FBK0c7SUFDaEcsMkJBQWEsR0FBZ0QsSUFBSSxHQUFHLEVBQUUsQ0FBQztJQUN0Rix5R0FBeUc7SUFDekcsNEVBQTRFO0lBQzVFLG9HQUFvRztJQUNyRiwyQkFBYSxHQUF3QyxJQUFJLEdBQUcsRUFBRSxDQUFDO0lBQy9ELG1CQUFLLEdBQTRCLElBQUksR0FBRyxFQUFFLENBQUM7SUFSdEMsdUJBQWEsZ0JBMFpsQyxDQUFBO0FBQ0gsQ0FBQyxFQTFjUyxTQUFTLEtBQVQsU0FBUyxRQTBjbEI7QUMzY0Qsd0NBQXdDO0FBQ3hDLElBQVUsU0FBUyxDQWlCbEI7QUFsQkQsd0NBQXdDO0FBQ3hDLFdBQVUsU0FBUztJQUNqQjs7O09BR0c7SUFFSCxrRkFBa0Y7SUFFbEYsTUFBYSxNQUFNO1FBRWpCLDhFQUE4RTtRQUN2RSxNQUFNLENBQUMsT0FBTyxLQUFrQixPQUFPLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDOUMsTUFBTSxDQUFDLHFCQUFxQixLQUFhLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQztRQUN2RCxNQUFNLENBQUMsdUJBQXVCLEtBQWEsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBRXRELE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxTQUF3QixJQUFZLE9BQU8sTUFBTSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7SUFOOUYsaUJBQVUsR0FBb0IsRUFBRSxDQUFDO0lBRDdDLGdCQUFNLFNBUWxCLENBQUE7QUFDSCxDQUFDLEVBakJTLFNBQVMsS0FBVCxTQUFTLFFBaUJsQjtBQ2xCRCxJQUFVLFNBQVMsQ0E2RGxCO0FBN0RELFdBQVUsU0FBUztJQUNqQjs7O09BR0c7SUFDSCxNQUFhLFVBQVcsU0FBUSxVQUFBLE1BQU07UUFHN0IsTUFBTSxDQUFDLE9BQU87WUFDbkIsT0FBTyxVQUFBLFdBQVcsQ0FBQztRQUNyQixDQUFDO1FBRU0sTUFBTSxDQUFDLHFCQUFxQjtZQUNqQyxPQUFPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7c0JBaUNTLENBQUM7UUFDbkIsQ0FBQztRQUNNLE1BQU0sQ0FBQyx1QkFBdUI7WUFDbkMsT0FBTzs7Ozs7Ozs7O3NCQVNTLENBQUM7UUFDbkIsQ0FBQzs7SUFyRHNCLG9CQUFTLEdBQVcsVUFBQSxNQUFNLENBQUMsZ0JBQWdCLENBQUMsVUFBVSxDQUFDLENBQUM7SUFEcEUsb0JBQVUsYUF1RHRCLENBQUE7QUFDSCxDQUFDLEVBN0RTLFNBQVMsS0FBVCxTQUFTLFFBNkRsQjtBQzVERCxJQUFVLFNBQVMsQ0E4RGxCO0FBOURELFdBQVUsU0FBUztJQUNqQjs7OztPQUlHO0lBQ0gsTUFBYSxZQUFhLFNBQVEsVUFBQSxNQUFNO1FBRy9CLE1BQU0sQ0FBQyxPQUFPO1lBQ25CLE9BQU8sVUFBQSxVQUFVLENBQUM7UUFDcEIsQ0FBQztRQUVNLE1BQU0sQ0FBQyxxQkFBcUI7WUFDakMsT0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3NCQTJCUyxDQUFDO1FBQ25CLENBQUM7UUFDTSxNQUFNLENBQUMsdUJBQXVCO1lBQ25DLE9BQU87Ozs7Ozs7Ozs7Ozs7OztzQkFlUyxDQUFDO1FBQ25CLENBQUM7O0lBckRzQixzQkFBUyxHQUFXLFVBQUEsTUFBTSxDQUFDLGdCQUFnQixDQUFDLFlBQVksQ0FBQyxDQUFDO0lBRHRFLHNCQUFZLGVBdUR4QixDQUFBO0FBQ0gsQ0FBQyxFQTlEUyxTQUFTLEtBQVQsU0FBUyxRQThEbEI7QUMvREQsSUFBVSxTQUFTLENBZ0NsQjtBQWhDRCxXQUFVLFNBQVM7SUFDakI7OztPQUdHO0lBQ0gsTUFBYSxhQUFjLFNBQVEsVUFBQSxNQUFNO1FBQ2hDLE1BQU0sQ0FBQyxxQkFBcUI7WUFDakMsT0FBTzs7Ozs7OztzQkFPUyxDQUFDO1FBQ25CLENBQUM7UUFDTSxNQUFNLENBQUMsdUJBQXVCO1lBQ25DLE9BQU87Ozs7Ozs7Ozs7OztzQkFZUyxDQUFDO1FBQ25CLENBQUM7S0FDRjtJQTFCWSx1QkFBYSxnQkEwQnpCLENBQUE7QUFDSCxDQUFDLEVBaENTLFNBQVMsS0FBVCxTQUFTLFFBZ0NsQjtBQ2hDRCxJQUFVLFNBQVMsQ0EyQ2xCO0FBM0NELFdBQVUsU0FBUztJQUNqQjs7O09BR0c7SUFDSCxNQUFhLGFBQWMsU0FBUSxVQUFBLE1BQU07UUFHaEMsTUFBTSxDQUFDLE9BQU87WUFDbkIsT0FBTyxVQUFBLFlBQVksQ0FBQztRQUN0QixDQUFDO1FBRU0sTUFBTSxDQUFDLHFCQUFxQjtZQUNqQyxPQUFPOzs7Ozs7Ozs7Ozs7O2tCQWFLLENBQUM7UUFDZixDQUFDO1FBQ00sTUFBTSxDQUFDLHVCQUF1QjtZQUNuQyxPQUFPOzs7Ozs7Ozs7OztjQVdDLENBQUM7UUFDWCxDQUFDOztJQW5Dc0IsdUJBQVMsR0FBVyxVQUFBLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUR2RSx1QkFBYSxnQkFxQ3pCLENBQUE7QUFDSCxDQUFDLEVBM0NTLFNBQVMsS0FBVCxTQUFTLFFBMkNsQjtBQzNDRCxJQUFVLFNBQVMsQ0FrQ2xCO0FBbENELFdBQVUsU0FBUztJQUNqQjs7O09BR0c7SUFDSCxNQUFhLGNBQWUsU0FBUSxVQUFBLE1BQU07UUFHakMsTUFBTSxDQUFDLE9BQU87WUFDbkIsT0FBTyxVQUFBLFdBQVcsQ0FBQztRQUNyQixDQUFDO1FBRU0sTUFBTSxDQUFDLHFCQUFxQjtZQUNqQyxPQUFPOzs7Ozs7O3NCQU9TLENBQUM7UUFDbkIsQ0FBQztRQUNNLE1BQU0sQ0FBQyx1QkFBdUI7WUFDbkMsT0FBTzs7Ozs7Ozs7c0JBUVMsQ0FBQztRQUNuQixDQUFDOztJQTFCc0Isd0JBQVMsR0FBVyxVQUFBLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxjQUFjLENBQUMsQ0FBQztJQUR4RSx3QkFBYyxpQkE0QjFCLENBQUE7QUFDSCxDQUFDLEVBbENTLFNBQVMsS0FBVCxTQUFTLFFBa0NsQjtBQ2xDRCxJQUFVLFNBQVMsQ0E4QmxCO0FBOUJELFdBQVUsU0FBUztJQUNmOzs7T0FHRztJQUNILE1BQXNCLE9BQVEsU0FBUSxVQUFBLE9BQU87UUFDL0IsYUFBYSxLQUFlLENBQUM7S0FDMUM7SUFGcUIsaUJBQU8sVUFFNUIsQ0FBQTtJQUVEOztPQUVHO0lBQ0gsTUFBYSxZQUFhLFNBQVEsT0FBTztRQUF6Qzs7WUFDVyxVQUFLLEdBQXFCLElBQUksQ0FBQztRQUMxQyxDQUFDO0tBQUE7SUFGWSxzQkFBWSxlQUV4QixDQUFBO0lBQ0Q7O09BRUc7SUFDSCxNQUFhLGFBQWMsU0FBUSxPQUFPO0tBQ3pDO0lBRFksdUJBQWEsZ0JBQ3pCLENBQUE7SUFDRDs7T0FFRztJQUNILE1BQWEsYUFBYyxTQUFRLGFBQWE7S0FDL0M7SUFEWSx1QkFBYSxnQkFDekIsQ0FBQTtJQUNEOztPQUVHO0lBQ0gsTUFBYSxXQUFZLFNBQVEsYUFBYTtLQUM3QztJQURZLHFCQUFXLGNBQ3ZCLENBQUE7QUFDTCxDQUFDLEVBOUJTLFNBQVMsS0FBVCxTQUFTLFFBOEJsQjtBQzlCRCx5Q0FBeUM7QUFDekMsdUNBQXVDO0FBQ3ZDLElBQVUsU0FBUyxDQW9KbEI7QUF0SkQseUNBQXlDO0FBQ3pDLHVDQUF1QztBQUN2QyxXQUFVLFNBQVM7SUFDakI7O09BRUc7SUFDSCxJQUFZLFNBT1g7SUFQRCxXQUFZLFNBQVM7UUFDbkIsNkRBQTZEO1FBQzdELDJDQUE4QixDQUFBO1FBQzlCLDREQUE0RDtRQUM1RCxtQ0FBc0IsQ0FBQTtRQUN0QixxRkFBcUY7UUFDckYsbUNBQXNCLENBQUE7SUFDeEIsQ0FBQyxFQVBXLFNBQVMsR0FBVCxtQkFBUyxLQUFULG1CQUFTLFFBT3BCO0lBRUQ7Ozs7O09BS0c7SUFDSCxNQUFhLElBQUssU0FBUSxVQUFBLGlCQUFpQjtRQXNCekM7Ozs7O1dBS0c7UUFDSSxNQUFNLENBQUMsS0FBSyxDQUFDLFFBQW1CLFNBQVMsQ0FBQyxhQUFhLEVBQUUsT0FBZSxFQUFFLEVBQUUsMEJBQW1DLEtBQUs7WUFDekgsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1lBRVosSUFBSSxDQUFDLGFBQWEsR0FBRyxVQUFBLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7WUFDckMsSUFBSSxDQUFDLGFBQWEsR0FBRyxXQUFXLENBQUMsR0FBRyxFQUFFLENBQUM7WUFDdkMsSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksQ0FBQyxhQUFhLENBQUM7WUFDNUMsSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksQ0FBQyxhQUFhLENBQUM7WUFDNUMsSUFBSSxDQUFDLFVBQVUsR0FBRyxDQUFDLEtBQUssSUFBSSxTQUFTLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO1lBQ2pFLElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQztZQUN2QyxJQUFJLENBQUMsb0JBQW9CLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixHQUFHLElBQUksR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDO1lBQy9FLElBQUksQ0FBQyxJQUFJLEdBQUcsS0FBSyxDQUFDO1lBQ2xCLElBQUksQ0FBQyxzQkFBc0IsR0FBRyx1QkFBdUIsQ0FBQztZQUV0RCxJQUFJLEdBQUcsR0FBVyx5QkFBeUIsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1lBQ3ZELElBQUksSUFBSSxDQUFDLElBQUksSUFBSSxTQUFTLENBQUMsYUFBYTtnQkFDdEMsR0FBRyxJQUFJLG1CQUFtQixJQUFJLE1BQU0sQ0FBQztZQUN2QyxVQUFBLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7WUFFZixRQUFRLEtBQUssRUFBRTtnQkFDYixLQUFLLFNBQVMsQ0FBQyxhQUFhO29CQUMxQixJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7b0JBQ2pCLE1BQU07Z0JBQ1IsS0FBSyxTQUFTLENBQUMsU0FBUztvQkFDdEIsSUFBSSxDQUFDLFdBQVcsR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztvQkFDN0UsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO29CQUNoQixNQUFNO2dCQUNSLEtBQUssU0FBUyxDQUFDLFNBQVM7b0JBQ3RCLElBQUksQ0FBQyxXQUFXLEdBQUcsVUFBQSxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO29CQUNoRixJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7b0JBQ2hCLE1BQU07Z0JBQ1I7b0JBQ0UsTUFBTTthQUNUO1lBRUQsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7UUFDdEIsQ0FBQztRQUVEOztXQUVHO1FBQ0ksTUFBTSxDQUFDLElBQUk7WUFDaEIsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPO2dCQUNmLE9BQU87WUFFVCxRQUFRLElBQUksQ0FBQyxJQUFJLEVBQUU7Z0JBQ2pCLEtBQUssU0FBUyxDQUFDLGFBQWE7b0JBQzFCLE1BQU0sQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7b0JBQzVDLE1BQU07Z0JBQ1IsS0FBSyxTQUFTLENBQUMsU0FBUztvQkFDdEIsTUFBTSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7b0JBQ3ZDLE1BQU0sQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7b0JBQzVDLE1BQU07Z0JBQ1IsS0FBSyxTQUFTLENBQUMsU0FBUztvQkFDdEIsVUFBQSxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7b0JBQ3hDLE1BQU0sQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7b0JBQzVDLE1BQU07Z0JBQ1I7b0JBQ0UsTUFBTTthQUNUO1lBRUQsSUFBSSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7WUFDckIsVUFBQSxLQUFLLENBQUMsR0FBRyxDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBQzdCLENBQUM7UUFFTSxNQUFNLENBQUMsaUJBQWlCO1lBQzdCLE9BQU8sSUFBSSxHQUFHLElBQUksQ0FBQyxvQkFBb0IsQ0FBQztRQUMxQyxDQUFDO1FBQ00sTUFBTSxDQUFDLGlCQUFpQjtZQUM3QixPQUFPLElBQUksR0FBRyxJQUFJLENBQUMsb0JBQW9CLENBQUM7UUFDMUMsQ0FBQztRQUVPLE1BQU0sQ0FBQyxJQUFJO1lBQ2pCLElBQUksSUFBWSxDQUFDO1lBQ2pCLElBQUksR0FBRyxXQUFXLENBQUMsR0FBRyxFQUFFLENBQUM7WUFDekIsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDO1lBQ25ELElBQUksQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLENBQUM7WUFFOUIsSUFBSSxHQUFHLFVBQUEsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztZQUN2QixJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUM7WUFDbkQsSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksQ0FBQztZQUU5QixJQUFJLENBQUMsb0JBQW9CLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxlQUFlLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDO1lBQ2pJLElBQUksQ0FBQyxvQkFBb0IsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLGVBQWUsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsb0JBQW9CLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUM7WUFFakksSUFBSSxLQUFLLEdBQVUsSUFBSSxLQUFLLDhCQUFrQixDQUFDO1lBQy9DLElBQUksQ0FBQyxZQUFZLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3pDLENBQUM7UUFFTyxNQUFNLENBQUMsU0FBUztZQUN0QixJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDWixJQUFJLENBQUMsU0FBUyxHQUFHLE1BQU0sQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDaEUsQ0FBQztRQUVPLE1BQU0sQ0FBQyxRQUFRO1lBQ3JCLElBQUksSUFBSSxDQUFDLHNCQUFzQjtnQkFDN0IsSUFBSSxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDOztnQkFFekQsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ2hCLENBQUM7O0lBN0hELG1FQUFtRTtJQUNyRCxrQkFBYSxHQUFXLENBQUMsQ0FBQztJQUN4QyxtRUFBbUU7SUFDckQsa0JBQWEsR0FBVyxDQUFDLENBQUM7SUFDeEMscURBQXFEO0lBQ3ZDLGtCQUFhLEdBQVcsQ0FBQyxDQUFDO0lBQ3hDLHFEQUFxRDtJQUN2QyxrQkFBYSxHQUFXLENBQUMsQ0FBQztJQUV6QixzQkFBaUIsR0FBVyxDQUFDLENBQUM7SUFDOUIsc0JBQWlCLEdBQVcsQ0FBQyxDQUFDO0lBQzlCLHlCQUFvQixHQUFXLENBQUMsQ0FBQztJQUNqQyx5QkFBb0IsR0FBVyxDQUFDLENBQUM7SUFDakMsWUFBTyxHQUFZLEtBQUssQ0FBQztJQUN6QixTQUFJLEdBQWMsU0FBUyxDQUFDLGFBQWEsQ0FBQztJQUMxQyxnQkFBVyxHQUFXLENBQUMsQ0FBQztJQUN4QixjQUFTLEdBQVcsQ0FBQyxDQUFDO0lBQ3RCLGVBQVUsR0FBVyxFQUFFLENBQUM7SUFDeEIsb0JBQWUsR0FBVyxFQUFFLENBQUM7SUFDN0IsMkJBQXNCLEdBQVksS0FBSyxDQUFDO0lBcEI1QyxjQUFJLE9BK0hoQixDQUFBO0FBRUgsQ0FBQyxFQXBKUyxTQUFTLEtBQVQsU0FBUyxRQW9KbEI7QUN0SkQsSUFBVSxTQUFTLENBME5sQjtBQTFORCxXQUFVLFNBQVM7SUFrQmpCOzs7Ozs7T0FNRztJQUNILE1BQWEsSUFBSyxTQUFRLFVBQUEsWUFBWTtRQVVwQztZQUNFLEtBQUssRUFBRSxDQUFDO1lBSkYsV0FBTSxHQUFXLEVBQUUsQ0FBQztZQUNwQixnQkFBVyxHQUFXLENBQUMsQ0FBQztZQUk5QixJQUFJLENBQUMsS0FBSyxHQUFHLFdBQVcsQ0FBQyxHQUFHLEVBQUUsQ0FBQztZQUMvQixJQUFJLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBQztZQUNqQixJQUFJLENBQUMsTUFBTSxHQUFHLEdBQUcsQ0FBQztZQUNsQixJQUFJLENBQUMsaUJBQWlCLEdBQUcsR0FBRyxDQUFDO1FBQy9CLENBQUM7UUFFRDs7V0FFRztRQUNILG1DQUFtQztRQUNuQywwQkFBMEI7UUFDMUIsSUFBSTtRQUVHLE1BQU0sQ0FBQyxRQUFRLENBQUMsYUFBcUI7WUFDMUMsSUFBSSxLQUFLLEdBQWMsRUFBRSxDQUFDO1lBRTFCLEtBQUssQ0FBQyxTQUFTLEdBQUcsYUFBYSxHQUFHLElBQUksQ0FBQztZQUN2QyxLQUFLLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQyxTQUFTLEdBQUcsRUFBRSxDQUFDO1lBQ3ZDLEtBQUssQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUM7WUFFckMsS0FBSyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUN4QyxLQUFLLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztZQUNqRCxLQUFLLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztZQUVqRCxLQUFLLENBQUMsUUFBUSxHQUFHLGFBQWEsR0FBRyxJQUFJLENBQUM7WUFDdEMsS0FBSyxDQUFDLFNBQVMsR0FBRyxhQUFhLEdBQUcsRUFBRSxDQUFDO1lBQ3JDLEtBQUssQ0FBQyxRQUFRLEdBQUcsYUFBYSxHQUFHLEdBQUcsR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDO1lBQ3ZELEtBQUssQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQyxTQUFTLENBQUM7WUFFakUsT0FBTyxLQUFLLENBQUM7UUFDZixDQUFDO1FBRUQsa0NBQWtDO1FBQ2xDOztXQUVHO1FBQ0ksR0FBRztZQUNSLE9BQU8sSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsV0FBVyxDQUFDLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNyRSxDQUFDO1FBRUQ7O1dBRUc7UUFDSSxZQUFZLENBQUMsR0FBVztZQUM3QixPQUFPLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDMUIsQ0FBQztRQUVEOzs7V0FHRztRQUNJLEdBQUcsQ0FBQyxRQUFnQixDQUFDO1lBQzFCLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO1lBQ3BCLElBQUksQ0FBQyxLQUFLLEdBQUcsV0FBVyxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQy9CLElBQUksQ0FBQywyQkFBMkIsRUFBRSxDQUFDO1FBQ3JDLENBQUM7UUFFRDs7O1dBR0c7UUFDSSxRQUFRLENBQUMsU0FBaUIsR0FBRztZQUNsQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO1lBQ3JCLElBQUksQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDO1lBQ3BCLHFCQUFxQjtZQUNyQixJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztZQUN4QixJQUFJLENBQUMsMkJBQTJCLEVBQUUsQ0FBQztZQUNuQyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksS0FBSyxnQ0FBbUIsQ0FBQyxDQUFDO1FBQ25ELENBQUM7UUFFRDs7V0FFRztRQUNJLFFBQVE7WUFDYixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUM7UUFDcEIsQ0FBQztRQUVEOztXQUVHO1FBQ0ksU0FBUztZQUNkLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUNyQixDQUFDO1FBRUQ7OztXQUdHO1FBQ0ksMkJBQTJCO1lBQ2hDLElBQUksT0FBTyxHQUFXLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztZQUNqQyxJQUFJLE9BQU8sR0FBVyxPQUFPLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDO1lBQ3ZELElBQUksQ0FBQyxpQkFBaUIsR0FBRyxPQUFPLENBQUM7WUFDakMsT0FBTyxPQUFPLENBQUM7UUFDakIsQ0FBQztRQUNELFlBQVk7UUFHWixnQkFBZ0I7UUFDaEI7O1dBRUc7UUFDSSxLQUFLLENBQUMsTUFBYztZQUN6QixPQUFPLElBQUksT0FBTyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUM3RSxDQUFDO1FBRUQsK0RBQStEO1FBQy9EOztXQUVHO1FBQ0ksY0FBYztZQUNuQixLQUFLLElBQUksRUFBRSxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7Z0JBQzFCLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7YUFDOUI7UUFDSCxDQUFDO1FBRUQ7OztXQUdHO1FBQ0ksMEJBQTBCLENBQUMsR0FBVztZQUMzQyxLQUFLLElBQUksRUFBRSxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7Z0JBQzFCLElBQUksS0FBSyxHQUFVLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUM7Z0JBQ25DLElBQUksS0FBSyxDQUFDLEVBQUUsSUFBSSxHQUFHLEVBQUU7b0JBQ25CLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQztvQkFDZCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUM7aUJBQ3hCO2FBQ0Y7UUFDSCxDQUFDO1FBRUQ7Ozs7OztXQU1HO1FBQ0ksUUFBUSxDQUFDLE1BQWMsRUFBRSxNQUFjLEVBQUUsUUFBc0IsRUFBRSxHQUFHLFVBQW9CO1lBQzdGLElBQUksS0FBSyxHQUFVLElBQUksVUFBQSxLQUFLLENBQUMsSUFBSSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLFVBQVUsQ0FBQyxDQUFDO1lBQ3pFLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsS0FBSyxDQUFDO1lBQ3hDLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQztRQUMxQixDQUFDO1FBRUQ7O1dBRUc7UUFDSSxXQUFXLENBQUMsR0FBVztZQUM1QixJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDO1lBQ3pCLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUMxQixDQUFDO1FBRUQ7O1dBRUc7UUFDSSxTQUFTO1lBQ2QsSUFBSSxNQUFNLEdBQVcsRUFBRSxDQUFDO1lBQ3hCLE9BQU8sTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQzVDLENBQUM7UUFFRDs7V0FFRztRQUNJLFNBQVM7WUFDZCxPQUFPLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQy9DLENBQUM7UUFFRDs7V0FFRztRQUNLLGdCQUFnQjtZQUN0QixLQUFLLElBQUksRUFBRSxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7Z0JBQzFCLElBQUksS0FBSyxHQUFVLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUM7Z0JBQ25DLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQztnQkFDZCxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUs7b0JBQ2Isc0RBQXNEO29CQUN0RCxTQUFTO2dCQUVYLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLFdBQVcsRUFBRSxDQUFDO2FBQ3ZDO1FBQ0gsQ0FBQzs7SUE3TEQscUVBQXFFO0lBQzlDLFNBQUksR0FBUyxJQUFJLElBQUksRUFBRSxDQUFDO0lBRnBDLGNBQUksT0ErTGhCLENBQUE7SUFDRCxZQUFZO0FBQ2QsQ0FBQyxFQTFOUyxTQUFTLEtBQVQsU0FBUyxRQTBObEI7QUMxTkQsSUFBVSxTQUFTLENBb0dsQjtBQXBHRCxXQUFVLFNBQVM7SUFNakI7Ozs7OztPQU1HO0lBQ0gsTUFBYSxLQUFLO1FBVWhCOzs7Ozs7O1dBT0c7UUFDSCxZQUFZLEtBQVcsRUFBRSxPQUFlLEVBQUUsTUFBYyxFQUFFLFFBQXNCLEVBQUUsR0FBRyxVQUFvQjtZQUN2RyxJQUFJLENBQUMsSUFBSSxHQUFHLEtBQUssQ0FBQztZQUNsQixJQUFJLENBQUMsTUFBTSxHQUFHLE9BQU8sQ0FBQztZQUN0QixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksVUFBQSxVQUFVLENBQUMsSUFBSSxFQUFFLFVBQVUsQ0FBQyxDQUFDO1lBQzlDLElBQUksQ0FBQyxPQUFPLEdBQUcsUUFBUSxDQUFDO1lBQ3hCLElBQUksQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDO1lBRXBCLElBQUksS0FBSyxHQUFXLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7WUFFL0MsSUFBSSxDQUFDLEtBQUssRUFBRTtnQkFDVix5Q0FBeUM7Z0JBQ3pDLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO2dCQUNwQixPQUFPO2FBQ1I7WUFFRCxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO1lBRXZDLElBQUksUUFBUSxHQUFhLEdBQVMsRUFBRTtnQkFDbEMsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDO2dCQUN4QyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUNyQixJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7Z0JBRTdCLElBQUksSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDO29CQUNoQixJQUFJLEVBQUUsSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFDO3dCQUNuQixLQUFLLENBQUMsMEJBQTBCLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBRXRELENBQUMsQ0FBQztZQUVGLElBQUksQ0FBQyxRQUFRLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLFdBQVcsRUFBRSxVQUFVLENBQUMsQ0FBQztZQUMzRSxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQztRQUNyQixDQUFDO1FBRUQ7O1dBRUc7UUFDSCxJQUFXLEVBQUU7WUFDWCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUM7UUFDdkIsQ0FBQztRQUVEOztXQUVHO1FBQ0gsSUFBVyxLQUFLO1lBQ2QsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDO1FBQ3JCLENBQUM7UUFFRDs7V0FFRztRQUNJLFdBQVc7WUFDaEIsT0FBTyxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDM0YsQ0FBQztRQUVEOztXQUVHO1FBQ0ksS0FBSztZQUNWLHlDQUF5QztZQUN6Qyx1QkFBdUI7WUFDdkIsdUVBQXVFO1lBQ3ZFLDJHQUEyRztZQUMzRyxvQ0FBb0M7WUFDcEMsSUFBSTtZQUNKLE9BQU87WUFDUCxrSEFBa0g7WUFDbEgsTUFBTSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDcEMsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7UUFDdEIsQ0FBQztLQUNGO0lBdEZZLGVBQUssUUFzRmpCLENBQUE7QUFDSCxDQUFDLEVBcEdTLFNBQVMsS0FBVCxTQUFTLFFBb0dsQjtBQ3BHRCxJQUFVLFNBQVMsQ0FnRWxCO0FBaEVELFdBQVUsU0FBUztJQUlmOzs7T0FHRztJQUNILE1BQWEsa0JBQW1CLFNBQVEsVUFBQSxpQkFBaUI7UUFFckQsOEZBQThGO1FBQ3ZGLE1BQU0sQ0FBQyxJQUFJO1lBQ2Qsa0JBQWtCLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDOUQsa0JBQWtCLENBQUMsUUFBUSxDQUFDLElBQUksR0FBRyxNQUFNLENBQUM7WUFDMUMsa0JBQWtCLENBQUMsUUFBUSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7WUFDNUMsa0JBQWtCLENBQUMsUUFBUSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUM7WUFDMUMsa0JBQWtCLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxrQkFBa0IsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1lBQzVGLFFBQVEsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ3ZELGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUN4QyxDQUFDO1FBRUQsOEZBQThGO1FBQ3ZGLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBNkI7WUFDNUMsS0FBSyxJQUFJLFFBQVEsSUFBSSxPQUFPLEVBQUU7Z0JBQzFCLElBQUksT0FBTyxHQUFXLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztnQkFDeEMsSUFBSSxJQUFJLEdBQVMsSUFBSSxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsRUFBRSxFQUFFLElBQUksRUFBRSxZQUFZLEVBQUUsQ0FBQyxDQUFDO2dCQUM3RCxJQUFJLEdBQUcsR0FBVyxNQUFNLENBQUMsR0FBRyxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDbkQsc0NBQXNDO2dCQUN0QyxJQUFJLFVBQTZCLENBQUM7Z0JBQ2xDLFVBQVUsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUN6QyxVQUFVLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQztnQkFDckMsVUFBVSxDQUFDLFlBQVksQ0FBQyxVQUFVLEVBQUUsUUFBUSxDQUFDLENBQUM7Z0JBQzlDLFFBQVEsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxDQUFDO2dCQUN0QyxVQUFVLENBQUMsS0FBSyxFQUFFLENBQUM7Z0JBQ25CLFFBQVEsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxDQUFDO2dCQUN0QyxNQUFNLENBQUMsR0FBRyxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUNuQztZQUVELElBQUksS0FBSyxHQUFnQixJQUFJLFdBQVcsK0JBQW1CLEVBQUUsTUFBTSxFQUFFLEVBQUUsb0JBQW9CLEVBQUUsT0FBTyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQzFHLGtCQUFrQixDQUFDLFlBQVksQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDekQsQ0FBQztRQUVNLE1BQU0sQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsTUFBYTtZQUM5QyxVQUFBLEtBQUssQ0FBQyxLQUFLLENBQUMsbURBQW1ELENBQUMsQ0FBQztZQUNqRSxRQUFRLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUN2RCxJQUFJLFFBQVEsR0FBZ0MsTUFBTSxDQUFDLE1BQU8sQ0FBQyxLQUFLLENBQUM7WUFDakUsVUFBQSxLQUFLLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDdkMsSUFBSSxRQUFRLENBQUMsTUFBTSxJQUFJLENBQUM7Z0JBQ3BCLE9BQU87WUFFWCxJQUFJLE1BQU0sR0FBeUIsRUFBRSxDQUFDO1lBQ3RDLE1BQU0sa0JBQWtCLENBQUMsU0FBUyxDQUFDLFFBQVEsRUFBRSxNQUFNLENBQUMsQ0FBQztZQUVyRCxJQUFJLEtBQUssR0FBZ0IsSUFBSSxXQUFXLGlDQUFvQixFQUFFLE1BQU0sRUFBRSxFQUFFLG9CQUFvQixFQUFFLE1BQU0sRUFBRSxFQUFFLENBQUMsQ0FBQztZQUMxRyxrQkFBa0IsQ0FBQyxZQUFZLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3pELENBQUM7UUFFTSxNQUFNLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxTQUFtQixFQUFFLE9BQTZCO1lBQzVFLEtBQUssSUFBSSxJQUFJLElBQUksU0FBUyxFQUFFO2dCQUN4QixNQUFNLE9BQU8sR0FBVyxNQUFNLElBQUksUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO2dCQUN4RCxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLE9BQU8sQ0FBQzthQUNoQztRQUNMLENBQUM7S0FDSjtJQXZEWSw0QkFBa0IscUJBdUQ5QixDQUFBO0FBQ0wsQ0FBQyxFQWhFUyxTQUFTLEtBQVQsU0FBUyxRQWdFbEIiLCJzb3VyY2VzQ29udGVudCI6WyJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBCYXNlIGNsYXNzIGZvciB0aGUgZGlmZmVyZW50IERlYnVnVGFyZ2V0cywgbWFpbmx5IGZvciB0ZWNobmljYWwgcHVycG9zZSBvZiBpbmhlcml0YW5jZVxyXG4gICAqL1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBEZWJ1Z1RhcmdldCB7XHJcbiAgICBwdWJsaWMgZGVsZWdhdGVzOiBNYXBEZWJ1Z0ZpbHRlclRvRGVsZWdhdGU7XHJcbiAgICBwdWJsaWMgc3RhdGljIG1lcmdlQXJndW1lbnRzKF9tZXNzYWdlOiBPYmplY3QsIC4uLl9hcmdzOiBPYmplY3RbXSk6IHN0cmluZyB7XHJcbiAgICAgIGxldCBvdXQ6IHN0cmluZyA9IF9tZXNzYWdlLnRvU3RyaW5nKCk7IC8vSlNPTi5zdHJpbmdpZnkoX21lc3NhZ2UpO1xyXG4gICAgICBmb3IgKGxldCBhcmcgb2YgX2FyZ3MpXHJcbiAgICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIE51bWJlcilcclxuICAgICAgICAgIG91dCArPSBcIiwgXCIgKyBhcmcudG9QcmVjaXNpb24oMikudG9TdHJpbmcoKTsgLy9KU09OLnN0cmluZ2lmeShhcmcsIG51bGwsIDIpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIG91dCArPSBcIiwgXCIgKyBhcmcudG9TdHJpbmcoKTsgLy9KU09OLnN0cmluZ2lmeShhcmcsIG51bGwsIDIpO1xyXG4gICAgICByZXR1cm4gb3V0O1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gICAgZXhwb3J0IGludGVyZmFjZSBNYXBFdmVudFR5cGVUb0xpc3RlbmVyIHtcclxuICAgICAgICBbZXZlbnRUeXBlOiBzdHJpbmddOiBFdmVudExpc3RlbmVyW107XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUeXBlcyBvZiBldmVudHMgc3BlY2lmaWMgdG8gRnVkZ2UsIGluIGFkZGl0aW9uIHRvIHRoZSBzdGFuZGFyZCBET00vQnJvd3Nlci1UeXBlcyBhbmQgY3VzdG9tIHN0cmluZ3NcclxuICAgICAqL1xyXG4gICAgZXhwb3J0IGNvbnN0IGVudW0gRVZFTlQge1xyXG4gICAgICAgIC8qKiBkaXNwYXRjaGVkIHRvIHRhcmdldHMgcmVnaXN0ZXJlZCBhdCBbW0xvb3BdXSwgd2hlbiByZXF1ZXN0ZWQgYW5pbWF0aW9uIGZyYW1lIHN0YXJ0cyAqL1xyXG4gICAgICAgIExPT1BfRlJBTUUgPSBcImxvb3BGcmFtZVwiLFxyXG4gICAgICAgIC8qKiBkaXNwYXRjaGVkIHRvIGEgW1tDb21wb25lbnRdXSB3aGVuIGl0cyBiZWluZyBhZGRlZCB0byBhIFtbTm9kZV1dICovXHJcbiAgICAgICAgQ09NUE9ORU5UX0FERCA9IFwiY29tcG9uZW50QWRkXCIsXHJcbiAgICAgICAgLyoqIGRpc3BhdGNoZWQgdG8gYSBbW0NvbXBvbmVudF1dIHdoZW4gaXRzIGJlaW5nIHJlbW92ZWQgZnJvbSBhIFtbTm9kZV1dICovXHJcbiAgICAgICAgQ09NUE9ORU5UX1JFTU9WRSA9IFwiY29tcG9uZW50UmVtb3ZlXCIsXHJcbiAgICAgICAgLyoqIGRpc3BhdGNoZWQgdG8gYSBbW0NvbXBvbmVudF1dIHdoZW4gaXRzIGJlaW5nIGFjdGl2YXRlZCAqL1xyXG4gICAgICAgIENPTVBPTkVOVF9BQ1RJVkFURSA9IFwiY29tcG9uZW50QWN0aXZhdGVcIixcclxuICAgICAgICAvKiogZGlzcGF0Y2hlZCB0byBhIFtbQ29tcG9uZW50XV0gd2hlbiBpdHMgYmVpbmcgZGVhY3RpdmF0ZWQgKi9cclxuICAgICAgICBDT01QT05FTlRfREVBQ1RJVkFURSA9IFwiY29tcG9uZW50RGVhY3RpdmF0ZVwiLFxyXG4gICAgICAgIC8qKiBkaXNwYXRjaGVkIHRvIGEgY2hpbGQgW1tOb2RlXV0gYW5kIGl0cyBhbmNlc3RvcnMgYWZ0ZXIgaXQgd2FzIGFwcGVuZGVkIHRvIGEgcGFyZW50ICovXHJcbiAgICAgICAgQ0hJTERfQVBQRU5EID0gXCJjaGlsZEFwcGVuZFwiLFxyXG4gICAgICAgIC8qKiBkaXNwYXRjaGVkIHRvIGEgY2hpbGQgW1tOb2RlXV0gYW5kIGl0cyBhbmNlc3RvcnMganVzdCBiZWZvcmUgaXRzIGJlaW5nIHJlbW92ZWQgZnJvbSBpdHMgcGFyZW50ICovXHJcbiAgICAgICAgQ0hJTERfUkVNT1ZFID0gXCJjaGlsZFJlbW92ZVwiLFxyXG4gICAgICAgIC8qKiBkaXNwYXRjaGVkIHRvIGEgW1tNdXRhYmxlXV0gd2hlbiBpdHMgYmVpbmcgbXV0YXRlZCAqL1xyXG4gICAgICAgIE1VVEFURSA9IFwibXV0YXRlXCIsXHJcbiAgICAgICAgLyoqIGRpc3BhdGNoZWQgdG8gW1tWaWV3cG9ydF1dIHdoZW4gaXQgZ2V0cyB0aGUgZm9jdXMgdG8gcmVjZWl2ZSBrZXlib2FyZCBpbnB1dCAqL1xyXG4gICAgICAgIEZPQ1VTX0lOID0gXCJmb2N1c2luXCIsXHJcbiAgICAgICAgLyoqIGRpc3BhdGNoZWQgdG8gW1tWaWV3cG9ydF1dIHdoZW4gaXQgbG9zZXMgdGhlIGZvY3VzIHRvIHJlY2VpdmUga2V5Ym9hcmQgaW5wdXQgKi9cclxuICAgICAgICBGT0NVU19PVVQgPSBcImZvY3Vzb3V0XCIsXHJcbiAgICAgICAgLyoqIGRpc3BhdGNoZWQgdG8gW1tOb2RlXV0gd2hlbiBpdCdzIGRvbmUgc2VyaWFsaXppbmcgKi9cclxuICAgICAgICBOT0RFX1NFUklBTElaRUQgPSBcIm5vZGVTZXJpYWxpemVkXCIsXHJcbiAgICAgICAgLyoqIGRpc3BhdGNoZWQgdG8gW1tOb2RlXV0gd2hlbiBpdCdzIGRvbmUgZGVzZXJpYWxpemluZywgc28gYWxsIGNvbXBvbmVudHMsIGNoaWxkcmVuIGFuZCBhdHRyaWJ1dGVzIGFyZSBhdmFpbGFibGUgKi9cclxuICAgICAgICBOT0RFX0RFU0VSSUFMSVpFRCA9IFwibm9kZURlc2VyaWFsaXplZFwiLFxyXG4gICAgICAgIC8qKiBkaXNwYXRjaGVkIHRvIFtbTm9kZVJlc291cmNlSW5zdGFuY2VdXSB3aGVuIGl0J3MgY29udGVudCBpcyBzZXQgYWNjb3JkaW5nIHRvIGEgc2VyaWFsaXphdGlvbiBvZiBhIFtbTm9kZVJlc291cmNlXV0gICovXHJcbiAgICAgICAgTk9ERVJFU09VUkNFX0lOU1RBTlRJQVRFRCA9IFwibm9kZVJlc291cmNlSW5zdGFudGlhdGVkXCIsXHJcbiAgICAgICAgLyoqIGRpc3BhdGNoZWQgdG8gW1tUaW1lXV0gd2hlbiBpdCdzIHNjYWxpbmcgY2hhbmdlZCAgKi9cclxuICAgICAgICBUSU1FX1NDQUxFRCA9IFwidGltZVNjYWxlZFwiLFxyXG4gICAgICAgIC8qKiBkaXNwYXRjaGVkIHRvIFtbRmlsZUlvXV0gd2hlbiBhIGxpc3Qgb2YgZmlsZXMgaGFzIGJlZW4gbG9hZGVkICAqL1xyXG4gICAgICAgIEZJTEVfTE9BREVEID0gXCJmaWxlTG9hZGVkXCIsXHJcbiAgICAgICAgLyoqIGRpc3BhdGNoZWQgdG8gW1tGaWxlSW9dXSB3aGVuIGEgbGlzdCBvZiBmaWxlcyBoYXMgYmVlbiBzYXZlZCAqL1xyXG4gICAgICAgIEZJTEVfU0FWRUQgPSBcImZpbGVTYXZlZFwiXHJcbiAgICB9XHJcblxyXG5cclxuICAgIGV4cG9ydCB0eXBlIEV2ZW50xpIgPSBFdmVudFBvaW50ZXIgfCBFdmVudERyYWdEcm9wIHwgRXZlbnRXaGVlbCB8IEV2ZW50S2V5Ym9hcmQgfCBFdmVudDtcclxuXHJcbiAgICBleHBvcnQgdHlwZSBFdmVudExpc3RlbmVyxpIgPVxyXG4gICAgICAgICgoX2V2ZW50OiBFdmVudFBvaW50ZXIpID0+IHZvaWQpIHxcclxuICAgICAgICAoKF9ldmVudDogRXZlbnREcmFnRHJvcCkgPT4gdm9pZCkgfFxyXG4gICAgICAgICgoX2V2ZW50OiBFdmVudFdoZWVsKSA9PiB2b2lkKSB8XHJcbiAgICAgICAgKChfZXZlbnQ6IEV2ZW50S2V5Ym9hcmQpID0+IHZvaWQpIHxcclxuICAgICAgICAoKF9ldmVudDogRXZlbnTGkikgPT4gdm9pZCkgfFxyXG4gICAgICAgIEV2ZW50TGlzdGVuZXJPYmplY3Q7XHJcblxyXG4gICAgZXhwb3J0IGNsYXNzIEV2ZW50VGFyZ2V0xpIgZXh0ZW5kcyBFdmVudFRhcmdldCB7XHJcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihfdHlwZTogc3RyaW5nLCBfaGFuZGxlcjogRXZlbnRMaXN0ZW5lcsaSLCBfb3B0aW9ucz86IGJvb2xlYW4gfCBBZGRFdmVudExpc3RlbmVyT3B0aW9ucyk6IHZvaWQge1xyXG4gICAgICAgICAgICBzdXBlci5hZGRFdmVudExpc3RlbmVyKF90eXBlLCA8RXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdD5faGFuZGxlciwgX29wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKF90eXBlOiBzdHJpbmcsIF9oYW5kbGVyOiBFdmVudExpc3RlbmVyxpIsIF9vcHRpb25zPzogYm9vbGVhbiB8IEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zKTogdm9pZCB7XHJcbiAgICAgICAgICAgIHN1cGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoX3R5cGUsIDxFdmVudExpc3RlbmVyT3JFdmVudExpc3RlbmVyT2JqZWN0Pl9oYW5kbGVyLCBfb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkaXNwYXRjaEV2ZW50KF9ldmVudDogRXZlbnTGkik6IGJvb2xlYW4ge1xyXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuZGlzcGF0Y2hFdmVudChfZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJhc2UgY2xhc3MgZm9yIEV2ZW50VGFyZ2V0IHNpbmdsZXRvbnMsIHdoaWNoIGFyZSBmaXhlZCBlbnRpdGllcyBpbiB0aGUgc3RydWN0dXJlIG9mIEZ1ZGdlLCBzdWNoIGFzIHRoZSBjb3JlIGxvb3AgXHJcbiAgICAgKi9cclxuICAgIGV4cG9ydCBjbGFzcyBFdmVudFRhcmdldFN0YXRpYyBleHRlbmRzIEV2ZW50VGFyZ2V0xpIge1xyXG4gICAgICAgIHByb3RlY3RlZCBzdGF0aWMgdGFyZ2V0U3RhdGljOiBFdmVudFRhcmdldFN0YXRpYyA9IG5ldyBFdmVudFRhcmdldFN0YXRpYygpO1xyXG5cclxuICAgICAgICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGFkZEV2ZW50TGlzdGVuZXIoX3R5cGU6IHN0cmluZywgX2hhbmRsZXI6IEV2ZW50TGlzdGVuZXIpOiB2b2lkIHtcclxuICAgICAgICAgICAgRXZlbnRUYXJnZXRTdGF0aWMudGFyZ2V0U3RhdGljLmFkZEV2ZW50TGlzdGVuZXIoX3R5cGUsIF9oYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyByZW1vdmVFdmVudExpc3RlbmVyKF90eXBlOiBzdHJpbmcsIF9oYW5kbGVyOiBFdmVudExpc3RlbmVyKTogdm9pZCB7XHJcbiAgICAgICAgICAgIEV2ZW50VGFyZ2V0U3RhdGljLnRhcmdldFN0YXRpYy5yZW1vdmVFdmVudExpc3RlbmVyKF90eXBlLCBfaGFuZGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgZGlzcGF0Y2hFdmVudChfZXZlbnQ6IEV2ZW50KTogYm9vbGVhbiB7XHJcbiAgICAgICAgICAgIEV2ZW50VGFyZ2V0U3RhdGljLnRhcmdldFN0YXRpYy5kaXNwYXRjaEV2ZW50KF9ldmVudCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vRXZlbnQvRXZlbnQudHNcIi8+XHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEludGVyZmFjZSBkZXNjcmliaW5nIHRoZSBkYXRhdHlwZXMgb2YgdGhlIGF0dHJpYnV0ZXMgYSBtdXRhdG9yIGFzIHN0cmluZ3MgXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBNdXRhdG9yQXR0cmlidXRlVHlwZXMge1xyXG4gICAgW2F0dHJpYnV0ZTogc3RyaW5nXTogc3RyaW5nIHwgT2JqZWN0O1xyXG4gIH1cclxuICAvKipcclxuICAgKiBJbnRlcmZhY2UgZGVzY3JpYmluZyBhIG11dGF0b3IsIHdoaWNoIGlzIGFuIGFzc29jaWF0aXZlIGFycmF5IHdpdGggbmFtZXMgb2YgYXR0cmlidXRlcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyB2YWx1ZXNcclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIE11dGF0b3Ige1xyXG4gICAgW2F0dHJpYnV0ZTogc3RyaW5nXTogT2JqZWN0O1xyXG4gIH1cclxuXHJcbiAgLypcclxuICAgKiBJbnRlcmZhY2VzIGRlZGljYXRlZCBmb3IgZWFjaCBwdXJwb3NlLiBFeHRyYSBhdHRyaWJ1dGUgbmVjZXNzYXJ5IGZvciBjb21waWxldGltZSB0eXBlIGNoZWNraW5nLCBub3QgZXhpc3RlbnQgYXQgcnVudGltZVxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgTXV0YXRvckZvckFuaW1hdGlvbiBleHRlbmRzIE11dGF0b3IgeyByZWFkb25seSBmb3JBbmltYXRpb246IG51bGw7IH1cclxuICBleHBvcnQgaW50ZXJmYWNlIE11dGF0b3JGb3JVc2VySW50ZXJmYWNlIGV4dGVuZHMgTXV0YXRvciB7IHJlYWRvbmx5IGZvclVzZXJJbnRlcmZhY2U6IG51bGw7IH1cclxuICAvLyBleHBvcnQgaW50ZXJmYWNlIE11dGF0b3JGb3JDb21wb25lbnQgZXh0ZW5kcyBNdXRhdG9yIHsgcmVhZG9ubHkgZm9yVXNlckNvbXBvbmVudDogbnVsbDsgfVxyXG5cclxuICAvKipcclxuICAgKiBDb2xsZWN0IGFwcGxpY2FibGUgYXR0cmlidXRlcyBvZiB0aGUgaW5zdGFuY2UgYW5kIGNvcGllcyBvZiB0aGVpciB2YWx1ZXMgaW4gYSBNdXRhdG9yLW9iamVjdFxyXG4gICAqL1xyXG4gIGV4cG9ydCBmdW5jdGlvbiBnZXRNdXRhdG9yT2ZBcmJpdHJhcnkoX29iamVjdDogT2JqZWN0KTogTXV0YXRvciB7XHJcbiAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHt9O1xyXG4gICAgbGV0IGF0dHJpYnV0ZXM6IChzdHJpbmcgfCBudW1iZXIgfCBzeW1ib2wpW10gPSBSZWZsZWN0Lm93bktleXMoUmVmbGVjdC5nZXRQcm90b3R5cGVPZihfb2JqZWN0KSk7XHJcbiAgICBmb3IgKGxldCBhdHRyaWJ1dGUgb2YgYXR0cmlidXRlcykge1xyXG4gICAgICBsZXQgdmFsdWU6IE9iamVjdCA9IFJlZmxlY3QuZ2V0KF9vYmplY3QsIGF0dHJpYnV0ZSk7XHJcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKVxyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAvLyBpZiAodmFsdWUgaW5zdGFuY2VvZiBPYmplY3QgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIE11dGFibGUpKVxyXG4gICAgICAvLyAgIGNvbnRpbnVlO1xyXG4gICAgICBtdXRhdG9yW2F0dHJpYnV0ZS50b1N0cmluZygpXSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEJhc2UgY2xhc3MgZm9yIGFsbCB0eXBlcyBiZWluZyBtdXRhYmxlIHVzaW5nIFtbTXV0YXRvcl1dLW9iamVjdHMsIHRodXMgcHJvdmlkaW5nIGFuZCB1c2luZyBpbnRlcmZhY2VzIGNyZWF0ZWQgYXQgcnVudGltZS4gIFxyXG4gICAqIE11dGFibGVzIHByb3ZpZGUgYSBbW011dGF0b3JdXSB0aGF0IGlzIGJ1aWxkIGJ5IGNvbGxlY3RpbmcgYWxsIG9iamVjdC1wcm9wZXJ0aWVzIHRoYXQgYXJlIGVpdGhlciBvZiBhIHByaW1pdGl2ZSB0eXBlIG9yIGFnYWluIE11dGFibGUuXHJcbiAgICogU3ViY2xhc3NlcyBjYW4gZWl0aGVyIHJlZHVjZSB0aGUgc3RhbmRhcmQgW1tNdXRhdG9yXV0gYnVpbHQgYnkgdGhpcyBiYXNlIGNsYXNzIGJ5IGRlbGV0aW5nIHByb3BlcnRpZXMgb3IgaW1wbGVtZW50IGFuIGluZGl2aWR1YWwgZ2V0TXV0YXRvci1tZXRob2QuXHJcbiAgICogVGhlIHByb3ZpZGVkIHByb3BlcnRpZXMgb2YgdGhlIFtbTXV0YXRvcl1dIG11c3QgbWF0Y2ggcHVibGljIHByb3BlcnRpZXMgb3IgZ2V0dGVycy9zZXR0ZXJzIG9mIHRoZSBvYmplY3QuXHJcbiAgICogT3RoZXJ3aXNlLCB0aGV5IHdpbGwgYmUgaWdub3JlZCBpZiBub3QgaGFuZGxlZCBieSBhbiBvdmVycmlkZSBvZiB0aGUgbXV0YXRlLW1ldGhvZCBpbiB0aGUgc3ViY2xhc3MgYW5kIHRocm93IGVycm9ycyBpbiBhbiBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCB1c2VyLWludGVyZmFjZSBmb3IgdGhlIG9iamVjdC5cclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgTXV0YWJsZSBleHRlbmRzIEV2ZW50VGFyZ2V0xpIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHR5cGUgb2YgdGhpcyBtdXRhYmxlIHN1YmNsYXNzIGFzIHRoZSBuYW1lIG9mIHRoZSBydW50aW1lIGNsYXNzXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdHlwZSBvZiB0aGUgbXV0YWJsZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHR5cGUoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29sbGVjdCBhcHBsaWNhYmxlIGF0dHJpYnV0ZXMgb2YgdGhlIGluc3RhbmNlIGFuZCBjb3BpZXMgb2YgdGhlaXIgdmFsdWVzIGluIGEgTXV0YXRvci1vYmplY3RcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0ge307XHJcblxyXG4gICAgICAvLyBjb2xsZWN0IHByaW1pdGl2ZSBhbmQgbXV0YWJsZSBhdHRyaWJ1dGVzXHJcbiAgICAgIGZvciAobGV0IGF0dHJpYnV0ZSBpbiB0aGlzKSB7XHJcbiAgICAgICAgbGV0IHZhbHVlOiBPYmplY3QgPSB0aGlzW2F0dHJpYnV0ZV07XHJcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pXHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBPYmplY3QgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIE11dGFibGUpKVxyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgbXV0YXRvclthdHRyaWJ1dGVdID0gdGhpc1thdHRyaWJ1dGVdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBtdXRhdG9yIGNhbiBiZSByZWR1Y2VkIGJ1dCBub3QgZXh0ZW5kZWQhXHJcbiAgICAgIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyhtdXRhdG9yKTtcclxuICAgICAgLy8gZGVsZXRlIHVud2FudGVkIGF0dHJpYnV0ZXNcclxuICAgICAgdGhpcy5yZWR1Y2VNdXRhdG9yKG11dGF0b3IpO1xyXG5cclxuICAgICAgLy8gcmVwbGFjZSByZWZlcmVuY2VzIHRvIG11dGFibGUgb2JqZWN0cyB3aXRoIHJlZmVyZW5jZXMgdG8gY29waWVzXHJcbiAgICAgIGZvciAobGV0IGF0dHJpYnV0ZSBpbiBtdXRhdG9yKSB7XHJcbiAgICAgICAgbGV0IHZhbHVlOiBPYmplY3QgPSBtdXRhdG9yW2F0dHJpYnV0ZV07XHJcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTXV0YWJsZSlcclxuICAgICAgICAgIG11dGF0b3JbYXR0cmlidXRlXSA9IHZhbHVlLmdldE11dGF0b3IoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb2xsZWN0IHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBpbnN0YW5jZSBhbmQgdGhlaXIgdmFsdWVzIGFwcGxpY2FibGUgZm9yIGFuaW1hdGlvbi5cclxuICAgICAqIEJhc2ljIGZ1bmN0aW9uYWxpdHkgaXMgaWRlbnRpY2FsIHRvIFtbZ2V0TXV0YXRvcl1dLCByZXR1cm5lZCBtdXRhdG9yIHNob3VsZCB0aGVuIGJlIHJlZHVjZWQgYnkgdGhlIHN1YmNsYXNzZWQgaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldE11dGF0b3JGb3JBbmltYXRpb24oKTogTXV0YXRvckZvckFuaW1hdGlvbiB7XHJcbiAgICAgIHJldHVybiA8TXV0YXRvckZvckFuaW1hdGlvbj50aGlzLmdldE11dGF0b3IoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29sbGVjdCB0aGUgYXR0cmlidXRlcyBvZiB0aGUgaW5zdGFuY2UgYW5kIHRoZWlyIHZhbHVlcyBhcHBsaWNhYmxlIGZvciB0aGUgdXNlciBpbnRlcmZhY2UuXHJcbiAgICAgKiBCYXNpYyBmdW5jdGlvbmFsaXR5IGlzIGlkZW50aWNhbCB0byBbW2dldE11dGF0b3JdXSwgcmV0dXJuZWQgbXV0YXRvciBzaG91bGQgdGhlbiBiZSByZWR1Y2VkIGJ5IHRoZSBzdWJjbGFzc2VkIGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yRm9yVXNlckludGVyZmFjZSgpOiBNdXRhdG9yRm9yVXNlckludGVyZmFjZSB7XHJcbiAgICAgIHJldHVybiA8TXV0YXRvckZvclVzZXJJbnRlcmZhY2U+dGhpcy5nZXRNdXRhdG9yKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbGxlY3QgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIGluc3RhbmNlIGFuZCB0aGVpciB2YWx1ZXMgYXBwbGljYWJsZSBmb3IgaW5kaXZpdWFsaXphdGlvbiBieSB0aGUgY29tcG9uZW50LlxyXG4gICAgICogQmFzaWMgZnVuY3Rpb25hbGl0eSBpcyBpZGVudGljYWwgdG8gW1tnZXRNdXRhdG9yXV0sIHJldHVybmVkIG11dGF0b3Igc2hvdWxkIHRoZW4gYmUgcmVkdWNlZCBieSB0aGUgc3ViY2xhc3NlZCBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICAvLyBwdWJsaWMgZ2V0TXV0YXRvckZvckNvbXBvbmVudCgpOiBNdXRhdG9yRm9yQ29tcG9uZW50IHtcclxuICAgIC8vICAgICByZXR1cm4gPE11dGF0b3JGb3JDb21wb25lbnQ+dGhpcy5nZXRNdXRhdG9yKCk7XHJcbiAgICAvLyB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgd2l0aCB0aGUgc2FtZSBhdHRyaWJ1dGVzIGFzIHRoZSBnaXZlbiBtdXRhdG9yLCBidXQgd2l0aCB0aGUgY29ycmVzcG9uZGluZyB0eXBlcyBhcyBzdHJpbmctdmFsdWVzXHJcbiAgICAgKiBEb2VzIG5vdCByZWN1cnNlIGludG8gb2JqZWN0cyFcclxuICAgICAqIEBwYXJhbSBfbXV0YXRvciBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldE11dGF0b3JBdHRyaWJ1dGVUeXBlcyhfbXV0YXRvcjogTXV0YXRvcik6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyB7XHJcbiAgICAgIGxldCB0eXBlczogTXV0YXRvckF0dHJpYnV0ZVR5cGVzID0ge307XHJcbiAgICAgIGZvciAobGV0IGF0dHJpYnV0ZSBpbiBfbXV0YXRvcikge1xyXG4gICAgICAgIGxldCB0eXBlOiBzdHJpbmcgPSBudWxsO1xyXG4gICAgICAgIGxldCB2YWx1ZTogbnVtYmVyIHwgYm9vbGVhbiB8IHN0cmluZyB8IG9iamVjdCA9IF9tdXRhdG9yW2F0dHJpYnV0ZV07XHJcbiAgICAgICAgaWYgKF9tdXRhdG9yW2F0dHJpYnV0ZV0gIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09IFwib2JqZWN0XCIpXHJcbiAgICAgICAgICAgIHR5cGUgPSAoPEdlbmVyYWw+dGhpcylbYXR0cmlidXRlXS5jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB0eXBlID0gX211dGF0b3JbYXR0cmlidXRlXS5jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gICAgICAgIHR5cGVzW2F0dHJpYnV0ZV0gPSB0eXBlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0eXBlcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgdmFsdWVzIG9mIHRoZSBnaXZlbiBtdXRhdG9yIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSBfbXV0YXRvciBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHVwZGF0ZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgZm9yIChsZXQgYXR0cmlidXRlIGluIF9tdXRhdG9yKSB7XHJcbiAgICAgICAgbGV0IHZhbHVlOiBPYmplY3QgPSBfbXV0YXRvclthdHRyaWJ1dGVdO1xyXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE11dGFibGUpXHJcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmdldE11dGF0b3IoKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICBfbXV0YXRvclthdHRyaWJ1dGVdID0gKDxHZW5lcmFsPnRoaXMpW2F0dHJpYnV0ZV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgYXR0cmlidXRlIHZhbHVlcyBvZiB0aGUgaW5zdGFuY2UgYWNjb3JkaW5nIHRvIHRoZSBzdGF0ZSBvZiB0aGUgbXV0YXRvci4gTXVzdCBiZSBwcm90ZWN0ZWQuLi4hXHJcbiAgICAgKiBAcGFyYW0gX211dGF0b3JcclxuICAgICAqL1xyXG4gICAgcHVibGljIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICAvLyBUT0RPOiBkb24ndCBhc3NpZ24gdW5rbm93biBwcm9wZXJ0aWVzXHJcbiAgICAgIGZvciAobGV0IGF0dHJpYnV0ZSBpbiBfbXV0YXRvcikge1xyXG4gICAgICAgIGxldCB2YWx1ZTogTXV0YXRvciA9IDxNdXRhdG9yPl9tdXRhdG9yW2F0dHJpYnV0ZV07XHJcbiAgICAgICAgbGV0IG11dGFudDogT2JqZWN0ID0gKDxHZW5lcmFsPnRoaXMpW2F0dHJpYnV0ZV07XHJcbiAgICAgICAgaWYgKG11dGFudCBpbnN0YW5jZW9mIE11dGFibGUpXHJcbiAgICAgICAgICBtdXRhbnQubXV0YXRlKHZhbHVlKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAoPEdlbmVyYWw+dGhpcylbYXR0cmlidXRlXSA9IHZhbHVlO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuTVVUQVRFKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlZHVjZXMgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIGdlbmVyYWwgbXV0YXRvciBhY2NvcmRpbmcgdG8gZGVzaXJlZCBvcHRpb25zIGZvciBtdXRhdGlvbi4gVG8gYmUgaW1wbGVtZW50ZWQgaW4gc3ViY2xhc3Nlc1xyXG4gICAgICogQHBhcmFtIF9tdXRhdG9yIFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQ7XHJcbiAgfVxyXG59XHJcbiIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBuby1hbnlcclxuICAgIGV4cG9ydCB0eXBlIEdlbmVyYWwgPSBhbnk7XHJcblxyXG4gICAgZXhwb3J0IGludGVyZmFjZSBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgICBbdHlwZTogc3RyaW5nXTogR2VuZXJhbDtcclxuICAgIH1cclxuICAgIGV4cG9ydCBpbnRlcmZhY2UgU2VyaWFsaXphYmxlIHtcclxuICAgICAgICBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbjtcclxuICAgICAgICBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFNlcmlhbGl6YWJsZTtcclxuICAgIH1cclxuXHJcbiAgICBpbnRlcmZhY2UgTmFtZXNwYWNlUmVnaXN0ZXIge1xyXG4gICAgICAgIFtuYW1lOiBzdHJpbmddOiBPYmplY3Q7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVzIHRoZSBleHRlcm5hbCBzZXJpYWxpemF0aW9uIGFuZCBkZXNlcmlhbGl6YXRpb24gb2YgW1tTZXJpYWxpemFibGVdXSBvYmplY3RzLiBUaGUgaW50ZXJuYWwgcHJvY2VzcyBpcyBoYW5kbGVkIGJ5IHRoZSBvYmplY3RzIHRoZW1zZWx2ZXMuICBcclxuICAgICAqIEEgW1tTZXJpYWxpemF0aW9uXV0gb2JqZWN0IGNhbiBiZSBjcmVhdGVkIGZyb20gYSBbW1NlcmlhbGl6YWJsZV1dIG9iamVjdCBhbmQgYSBKU09OLVN0cmluZyBtYXkgYmUgY3JlYXRlZCBmcm9tIHRoYXQuICBcclxuICAgICAqIFZpY2UgdmVyc2EsIGEgSlNPTi1TdHJpbmcgY2FuIGJlIHBhcnNlZCB0byBhIFtbU2VyaWFsaXphdGlvbl1dIHdoaWNoIGNhbiBiZSBkZXNlcmlhbGl6ZWQgdG8gYSBbW1NlcmlhbGl6YWJsZV1dIG9iamVjdC5cclxuICAgICAqIGBgYHBsYWludGV4dFxyXG4gICAgICogIFtTZXJpYWxpemFibGVdIOKGkiAoc2VyaWFsaXplKSDihpIgW1NlcmlhbGl6YXRpb25dIOKGkiAoc3RyaW5naWZ5KSAgXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4oaTXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbU3RyaW5nXVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKGk1xyXG4gICAgICogIFtTZXJpYWxpemFibGVdIOKGkCAoZGVzZXJpYWxpemUpIOKGkCBbU2VyaWFsaXphdGlvbl0g4oaQIChwYXJzZSlcclxuICAgICAqIGBgYCAgICAgIFxyXG4gICAgICogV2hpbGUgdGhlIGludGVybmFsIHNlcmlhbGl6ZS9kZXNlcmlhbGl6ZSBtZXRob2RzIG9mIHRoZSBvYmplY3RzIGNhcmUgb2YgdGhlIHNlbGVjdGlvbiBvZiBpbmZvcm1hdGlvbiBuZWVkZWQgdG8gcmVjcmVhdGUgdGhlIG9iamVjdCBhbmQgaXRzIHN0cnVjdHVyZSwgIFxyXG4gICAgICogdGhlIFtbU2VyaWFsaXplcl1dIGtlZXBzIHRyYWNrIG9mIHRoZSBuYW1lc3BhY2VzIGFuZCBjbGFzc2VzIGluIG9yZGVyIHRvIHJlY3JlYXRlIFtbU2VyaWFsaXphYmxlXV0gb2JqZWN0cy4gVGhlIGdlbmVyYWwgc3RydWN0dXJlIG9mIGEgW1tTZXJpYWxpemF0aW9uXV0gaXMgYXMgZm9sbG93cyAgXHJcbiAgICAgKiBgYGBwbGFpbnRleHRcclxuICAgICAqIHtcclxuICAgICAqICAgICAgbmFtZXNwYWNlTmFtZS5jbGFzc05hbWU6IHtcclxuICAgICAqICAgICAgICAgIHByb3BlcnR5TmFtZTogcHJvcGVydHlWYWx1ZSxcclxuICAgICAqICAgICAgICAgIC4uLixcclxuICAgICAqICAgICAgICAgIHByb3BlcnR5TmFtZU9mUmVmZXJlbmNlOiBTZXJpYWxpemF0aW9uT2ZUaGVSZWZlcmVuY2VkT2JqZWN0LFxyXG4gICAgICogICAgICAgICAgLi4uLFxyXG4gICAgICogICAgICAgICAgY29uc3RydWN0b3JOYW1lT2ZTdXBlcmNsYXNzOiBTZXJpYWxpemF0aW9uT2ZTdXBlckNsYXNzXHJcbiAgICAgKiAgICAgIH1cclxuICAgICAqIH1cclxuICAgICAqIGBgYFxyXG4gICAgICogU2luY2UgdGhlIGluc3RhbmNlIG9mIHRoZSBzdXBlcmNsYXNzIGlzIGNyZWF0ZWQgYXV0b21hdGljYWxseSB3aGVuIGFuIG9iamVjdCBpcyBjcmVhdGVkLCBcclxuICAgICAqIHRoZSBTZXJpYWxpemF0aW9uT2ZTdXBlckNsYXNzIG9taXRzIHRoZSB0aGUgbmFtZXNwYWNlTmFtZS5jbGFzc05hbWUga2V5IGFuZCBjb25zaXN0cyBvbmx5IG9mIGl0cyB2YWx1ZS4gXHJcbiAgICAgKiBUaGUgY29uc3RydWN0b3JOYW1lT2ZTdXBlcmNsYXNzIGlzIGdpdmVuIGluc3RlYWQgYXMgYSBwcm9wZXJ0eSBuYW1lIGluIHRoZSBzZXJpYWxpemF0aW9uIG9mIHRoZSBzdWJjbGFzcy5cclxuICAgICAqL1xyXG4gICAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNlcmlhbGl6ZXIge1xyXG4gICAgICAgIC8qKiBJbiBvcmRlciBmb3IgdGhlIFNlcmlhbGl6ZXIgdG8gY3JlYXRlIGNsYXNzIGluc3RhbmNlcywgaXQgbmVlZHMgYWNjZXNzIHRvIHRoZSBhcHByb3ByaWF0ZSBuYW1lc3BhY2VzICovXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgbmFtZXNwYWNlczogTmFtZXNwYWNlUmVnaXN0ZXIgPSB7IFwixpJcIjogRnVkZ2VDb3JlIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlZ2lzdGVycyBhIG5hbWVzcGFjZSB0byB0aGUgW1tTZXJpYWxpemVyXV0sIHRvIGVuYWJsZSBhdXRvbWF0aWMgaW5zdGFudGlhdGlvbiBvZiBjbGFzc2VzIGRlZmluZWQgd2l0aGluXHJcbiAgICAgICAgICogQHBhcmFtIF9uYW1lc3BhY2UgXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyByZWdpc3Rlck5hbWVzcGFjZShfbmFtZXNwYWNlOiBPYmplY3QpOiB2b2lkIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBTZXJpYWxpemVyLm5hbWVzcGFjZXMpXHJcbiAgICAgICAgICAgICAgICBpZiAoU2VyaWFsaXplci5uYW1lc3BhY2VzW25hbWVdID09IF9uYW1lc3BhY2UpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgbGV0IG5hbWU6IHN0cmluZyA9IFNlcmlhbGl6ZXIuZmluZE5hbWVzcGFjZUluKF9uYW1lc3BhY2UsIHdpbmRvdyk7XHJcbiAgICAgICAgICAgIGlmICghbmFtZSlcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHBhcmVudE5hbWUgaW4gU2VyaWFsaXplci5uYW1lc3BhY2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IFNlcmlhbGl6ZXIuZmluZE5hbWVzcGFjZUluKF9uYW1lc3BhY2UsIFNlcmlhbGl6ZXIubmFtZXNwYWNlc1twYXJlbnROYW1lXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHBhcmVudE5hbWUgKyBcIi5cIiArIG5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghbmFtZSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5hbWVzcGFjZSBub3QgZm91bmQuIE1heWJlIHBhcmVudCBuYW1lc3BhY2UgaGFzbid0IGJlZW4gcmVnaXN0ZXJlZCBiZWZvcmU/XCIpO1xyXG5cclxuICAgICAgICAgICAgU2VyaWFsaXplci5uYW1lc3BhY2VzW25hbWVdID0gX25hbWVzcGFjZTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgamF2YXNjcmlwdCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzZXJpYWxpemFibGUgRlVER0Utb2JqZWN0IGdpdmVuLFxyXG4gICAgICAgICAqIGluY2x1ZGluZyBhdHRhY2hlZCBjb21wb25lbnRzLCBjaGlsZHJlbiwgc3VwZXJjbGFzcy1vYmplY3RzIGFsbCBpbmZvcm1hdGlvbiBuZWVkZWQgZm9yIHJlY29uc3RydWN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIF9vYmplY3QgQW4gb2JqZWN0IHRvIHNlcmlhbGl6ZSwgaW1wbGVtZW50aW5nIHRoZSBbW1NlcmlhbGl6YWJsZV1dIGludGVyZmFjZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgc2VyaWFsaXplKF9vYmplY3Q6IFNlcmlhbGl6YWJsZSk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICAgICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHt9O1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBzYXZlIHRoZSBuYW1lc3BhY2Ugd2l0aCB0aGUgY29uc3RydWN0b3JzIG5hbWVcclxuICAgICAgICAgICAgLy8gc2VyaWFsaXphdGlvbltfb2JqZWN0LmNvbnN0cnVjdG9yLm5hbWVdID0gX29iamVjdC5zZXJpYWxpemUoKTtcclxuICAgICAgICAgICAgbGV0IHBhdGg6IHN0cmluZyA9IHRoaXMuZ2V0RnVsbFBhdGgoX29iamVjdCk7XHJcbiAgICAgICAgICAgIGlmICghcGF0aClcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTmFtZXNwYWNlIG9mIHNlcmlhbGl6YWJsZSBvYmplY3Qgb2YgdHlwZSAke19vYmplY3QuY29uc3RydWN0b3IubmFtZX0gbm90IGZvdW5kLiBNYXliZSB0aGUgbmFtZXNwYWNlIGhhc24ndCBiZWVuIHJlZ2lzdGVyZWQgb3IgdGhlIGNsYXNzIG5vdCBleHBvcnRlZD9gKTtcclxuICAgICAgICAgICAgc2VyaWFsaXphdGlvbltwYXRoXSA9IF9vYmplY3Quc2VyaWFsaXplKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgICAgICAgICAvLyByZXR1cm4gX29iamVjdC5zZXJpYWxpemUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBGVURHRS1vYmplY3QgcmVjb25zdHJ1Y3RlZCBmcm9tIHRoZSBpbmZvcm1hdGlvbiBpbiB0aGUgW1tTZXJpYWxpemF0aW9uXV0gZ2l2ZW4sXHJcbiAgICAgICAgICogaW5jbHVkaW5nIGF0dGFjaGVkIGNvbXBvbmVudHMsIGNoaWxkcmVuLCBzdXBlcmNsYXNzLW9iamVjdHNcclxuICAgICAgICAgKiBAcGFyYW0gX3NlcmlhbGl6YXRpb24gXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFNlcmlhbGl6YWJsZSB7XHJcbiAgICAgICAgICAgIGxldCByZWNvbnN0cnVjdDogU2VyaWFsaXphYmxlO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgLy8gbG9vcCBjb25zdHJ1Y3RlZCBzb2xlbHkgdG8gYWNjZXNzIHR5cGUtcHJvcGVydHkuIE9ubHkgb25lIGV4cGVjdGVkIVxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcGF0aCBpbiBfc2VyaWFsaXphdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlY29uc3RydWN0ID0gbmV3ICg8R2VuZXJhbD5GdWRnZSlbdHlwZU5hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlY29uc3RydWN0ID0gU2VyaWFsaXplci5yZWNvbnN0cnVjdChwYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICByZWNvbnN0cnVjdC5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltwYXRoXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlY29uc3RydWN0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRlc2VyaWFsaXphdGlvbiBmYWlsZWQ6IFwiICsgX2Vycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vVE9ETzogaW1wbGVtZW50IHByZXR0aWZpZXIgdG8gbWFrZSBKU09OLVN0cmluZ2lmaWNhdGlvbiBvZiBzZXJpYWxpemF0aW9ucyBtb3JlIHJlYWRhYmxlLCBlLmcuIHBsYWNpbmcgeCwgeSBhbmQgeiBpbiBvbmUgbGluZVxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgcHJldHRpZnkoX2pzb246IHN0cmluZyk6IHN0cmluZyB7IHJldHVybiBfanNvbjsgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgZm9ybWF0dGVkLCBodW1hbiByZWFkYWJsZSBKU09OLVN0cmluZywgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBbW1NlcmlhbGl6YWlvbl1dIHRoYXQgbWF5IGhhdmUgYmVlbiBjcmVhdGVkIGJ5IFtbU2VyaWFsaXplcl1dLnNlcmlhbGl6ZVxyXG4gICAgICAgICAqIEBwYXJhbSBfc2VyaWFsaXphdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgc3RyaW5naWZ5KF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogc3RyaW5nIHtcclxuICAgICAgICAgICAgLy8gYWRqdXN0bWVudHMgdG8gc2VyaWFsaXphdGlvbiBjYW4gYmUgbWFkZSBoZXJlIGJlZm9yZSBzdHJpbmdpZmljYXRpb24sIGlmIGRlc2lyZWRcclxuICAgICAgICAgICAgbGV0IGpzb246IHN0cmluZyA9IEpTT04uc3RyaW5naWZ5KF9zZXJpYWxpemF0aW9uLCBudWxsLCAyKTtcclxuICAgICAgICAgICAgbGV0IHByZXR0eTogc3RyaW5nID0gU2VyaWFsaXplci5wcmV0dGlmeShqc29uKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByZXR0eTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBbW1NlcmlhbGl6YXRpb25dXSBjcmVhdGVkIGZyb20gdGhlIGdpdmVuIEpTT04tU3RyaW5nLiBSZXN1bHQgbWF5IGJlIHBhc3NlZCB0byBbW1NlcmlhbGl6ZXJdXS5kZXNlcmlhbGl6ZVxyXG4gICAgICAgICAqIEBwYXJhbSBfanNvbiBcclxuICAgICAgICAgKi9cclxuICAgICAgICBwdWJsaWMgc3RhdGljIHBhcnNlKF9qc29uOiBzdHJpbmcpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoX2pzb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBvZiB0aGUgY2xhc3MgZGVmaW5lZCB3aXRoIHRoZSBmdWxsIHBhdGggaW5jbHVkaW5nIHRoZSBuYW1lc3BhY2VOYW1lKHMpIGFuZCB0aGUgY2xhc3NOYW1lIHNlcGVyYXRlZCBieSBkb3RzKC4pIFxyXG4gICAgICAgICAqIEBwYXJhbSBfcGF0aCBcclxuICAgICAgICAgKi9cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyByZWNvbnN0cnVjdChfcGF0aDogc3RyaW5nKTogU2VyaWFsaXphYmxlIHtcclxuICAgICAgICAgICAgbGV0IHR5cGVOYW1lOiBzdHJpbmcgPSBfcGF0aC5zdWJzdHIoX3BhdGgubGFzdEluZGV4T2YoXCIuXCIpICsgMSk7XHJcbiAgICAgICAgICAgIGxldCBuYW1lc3BhY2U6IE9iamVjdCA9IFNlcmlhbGl6ZXIuZ2V0TmFtZXNwYWNlKF9wYXRoKTtcclxuICAgICAgICAgICAgaWYgKCFuYW1lc3BhY2UpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5hbWVzcGFjZSBvZiBzZXJpYWxpemFibGUgb2JqZWN0IG9mIHR5cGUgJHt0eXBlTmFtZX0gbm90IGZvdW5kLiBNYXliZSB0aGUgbmFtZXNwYWNlIGhhc24ndCBiZWVuIHJlZ2lzdGVyZWQ/YCk7XHJcbiAgICAgICAgICAgIGxldCByZWNvbnN0cnVjdGlvbjogU2VyaWFsaXphYmxlID0gbmV3ICg8R2VuZXJhbD5uYW1lc3BhY2UpW3R5cGVOYW1lXTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlY29uc3RydWN0aW9uO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgZnVsbCBwYXRoIHRvIHRoZSBjbGFzcyBvZiB0aGUgb2JqZWN0LCBpZiBmb3VuZCBpbiB0aGUgcmVnaXN0ZXJlZCBuYW1lc3BhY2VzXHJcbiAgICAgICAgICogQHBhcmFtIF9vYmplY3QgXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgZ2V0RnVsbFBhdGgoX29iamVjdDogU2VyaWFsaXphYmxlKTogc3RyaW5nIHtcclxuICAgICAgICAgICAgbGV0IHR5cGVOYW1lOiBzdHJpbmcgPSBfb2JqZWN0LmNvbnN0cnVjdG9yLm5hbWU7XHJcbiAgICAgICAgICAgIC8vIERlYnVnLmxvZyhcIlNlYXJjaGluZyBuYW1lc3BhY2Ugb2Y6IFwiICsgdHlwZU5hbWUpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lc3BhY2VOYW1lIGluIFNlcmlhbGl6ZXIubmFtZXNwYWNlcykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kOiBHZW5lcmFsID0gKDxHZW5lcmFsPlNlcmlhbGl6ZXIubmFtZXNwYWNlcylbbmFtZXNwYWNlTmFtZV1bdHlwZU5hbWVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kICYmIF9vYmplY3QgaW5zdGFuY2VvZiBmb3VuZClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZXNwYWNlTmFtZSArIFwiLlwiICsgdHlwZU5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBuYW1lc3BhY2Utb2JqZWN0IGRlZmluZWQgd2l0aGluIHRoZSBmdWxsIHBhdGgsIGlmIHJlZ2lzdGVyZWRcclxuICAgICAgICAgKiBAcGFyYW0gX3BhdGhcclxuICAgICAgICAgKi9cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBnZXROYW1lc3BhY2UoX3BhdGg6IHN0cmluZyk6IE9iamVjdCB7XHJcbiAgICAgICAgICAgIGxldCBuYW1lc3BhY2VOYW1lOiBzdHJpbmcgPSBfcGF0aC5zdWJzdHIoMCwgX3BhdGgubGFzdEluZGV4T2YoXCIuXCIpKTtcclxuICAgICAgICAgICAgcmV0dXJuIFNlcmlhbGl6ZXIubmFtZXNwYWNlc1tuYW1lc3BhY2VOYW1lXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZpbmRzIHRoZSBuYW1lc3BhY2Utb2JqZWN0IGluIHByb3BlcnRpZXMgb2YgdGhlIHBhcmVudC1vYmplY3QgKGUuZy4gd2luZG93KSwgaWYgcHJlc2VudFxyXG4gICAgICAgICAqIEBwYXJhbSBfbmFtZXNwYWNlIFxyXG4gICAgICAgICAqIEBwYXJhbSBfcGFyZW50IFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIGZpbmROYW1lc3BhY2VJbihfbmFtZXNwYWNlOiBPYmplY3QsIF9wYXJlbnQ6IE9iamVjdCk6IHN0cmluZyB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHByb3AgaW4gX3BhcmVudClcclxuICAgICAgICAgICAgICAgIGlmICgoPEdlbmVyYWw+X3BhcmVudClbcHJvcF0gPT0gX25hbWVzcGFjZSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcDtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGNsYXNzIFJlbmRlckluamVjdG9yIHtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGluamVjdChfY29uc3RydWN0b3I6IEZ1bmN0aW9uLCBfaW5qZWN0b3I6IHR5cGVvZiBSZW5kZXJJbmplY3Rvcik6IHZvaWQge1xyXG4gICAgICBsZXQgaW5qZWN0aW9uOiBGdW5jdGlvbiA9IFJlZmxlY3QuZ2V0KF9pbmplY3RvciwgXCJpbmplY3RcIiArIF9jb25zdHJ1Y3Rvci5uYW1lKTtcclxuICAgICAgaWYgKCFpbmplY3Rpb24pIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiTm8gaW5qZWN0aW9uIGRlY29yYXRvciBkZWZpbmVkIGZvciBcIiArIF9jb25zdHJ1Y3Rvci5uYW1lKTtcclxuICAgICAgfVxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2NvbnN0cnVjdG9yLnByb3RvdHlwZSwgXCJ1c2VSZW5kZXJEYXRhXCIsIHtcclxuICAgICAgICB2YWx1ZTogaW5qZWN0aW9uXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHByaXZhdGUgc3RhdGljIGluamVjdFJlbmRlckRhdGFGb3JDb2F0Q29sb3JlZCh0aGlzOiBDb2F0LCBfcmVuZGVyU2hhZGVyOiBSZW5kZXJTaGFkZXIpOiB2b2lkIHtcclxuICAgIC8vICAgbGV0IGNvbG9yVW5pZm9ybUxvY2F0aW9uOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiA9IF9yZW5kZXJTaGFkZXIudW5pZm9ybXNbXCJ1X2NvbG9yXCJdO1xyXG4gICAgLy8gICAvLyBsZXQgeyByLCBnLCBiLCBhIH0gPSAoPENvYXRDb2xvcmVkPnRoaXMpLmNvbG9yO1xyXG4gICAgLy8gICAvLyBsZXQgY29sb3I6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoW3IsIGcsIGIsIGFdKTtcclxuICAgIC8vICAgbGV0IGNvbG9yOiBGbG9hdDMyQXJyYXkgPSAoPENvYXRDb2xvcmVkPnRoaXMpLmNvbG9yLmdldEFycmF5KCk7XHJcbiAgICAvLyAgIFJlbmRlck9wZXJhdG9yLmdldFJlbmRlcmluZ0NvbnRleHQoKS51bmlmb3JtNGZ2KGNvbG9yVW5pZm9ybUxvY2F0aW9uLCBjb2xvcik7XHJcbiAgICAvLyB9XHJcblxyXG4gICAgLy8gcHJpdmF0ZSBzdGF0aWMgaW5qZWN0VGV4dHVyZWQodGhpczogQ29hdCwgX3JlbmRlclNoYWRlcjogUmVuZGVyU2hhZGVyKTogdm9pZCB7XHJcbiAgICAvLyAgIGxldCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyT3BlcmF0b3IuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG4gICAgLy8gICBpZiAodGhpcy5yZW5kZXJEYXRhKSB7XHJcbiAgICAvLyAgICAgLy8gYnVmZmVycyBleGlzdFxyXG4gICAgLy8gICAgIGNyYzMuYWN0aXZlVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkUwKTtcclxuICAgIC8vICAgICBjcmMzLmJpbmRUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgdGhpcy5yZW5kZXJEYXRhW1widGV4dHVyZTBcIl0pO1xyXG4gICAgLy8gICAgIGNyYzMudW5pZm9ybTFpKF9yZW5kZXJTaGFkZXIudW5pZm9ybXNbXCJ1X3RleHR1cmVcIl0sIDApO1xyXG4gICAgLy8gICAgIGNyYzMudW5pZm9ybU1hdHJpeDNmdihfcmVuZGVyU2hhZGVyLnVuaWZvcm1zW1widV9waXZvdFwiXSwgZmFsc2UsICg8Q29hdFRleHR1cmVkPnRoaXMpLnBpdm90LmdldCgpKTtcclxuICAgIC8vICAgfVxyXG4gICAgLy8gICBlbHNlIHtcclxuICAgIC8vICAgICB0aGlzLnJlbmRlckRhdGEgPSB7fTtcclxuICAgIC8vICAgICAvLyBUT0RPOiBjaGVjayBpZiBhbGwgV2ViR0wtQ3JlYXRpb25zIGFyZSBhc3NlcnRlZFxyXG4gICAgLy8gICAgIGNvbnN0IHRleHR1cmU6IFdlYkdMVGV4dHVyZSA9IFJlbmRlck1hbmFnZXIuYXNzZXJ0PFdlYkdMVGV4dHVyZT4oY3JjMy5jcmVhdGVUZXh0dXJlKCkpO1xyXG4gICAgLy8gICAgIGNyYzMuYmluZFRleHR1cmUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcclxuXHJcbiAgICAvLyAgICAgdHJ5IHtcclxuICAgIC8vICAgICAgIGNyYzMudGV4SW1hZ2UyRChjcmMzLlRFWFRVUkVfMkQsIDAsIGNyYzMuUkdCQSwgY3JjMy5SR0JBLCBjcmMzLlVOU0lHTkVEX0JZVEUsICg8Q29hdFRleHR1cmVkPnRoaXMpLnRleHR1cmUuaW1hZ2UpO1xyXG4gICAgLy8gICAgICAgY3JjMy50ZXhJbWFnZTJEKFxyXG4gICAgLy8gICAgICAgICBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIDAsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuUkdCQSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5SR0JBLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOU0lHTkVEX0JZVEUsXHJcbiAgICAvLyAgICAgICAgICg8Q29hdFRleHR1cmVkPnRoaXMpLnRleHR1cmUuaW1hZ2VcclxuICAgIC8vICAgICAgICk7XHJcbiAgICAvLyAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XHJcbiAgICAvLyAgICAgICBEZWJ1Zy5lcnJvcihfZXJyb3IpO1xyXG4gICAgLy8gICAgIH1cclxuICAgIC8vICAgICBjcmMzLnRleFBhcmFtZXRlcmkoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfTUFHX0ZJTFRFUiwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ORUFSRVNUKTtcclxuICAgIC8vICAgICBjcmMzLnRleFBhcmFtZXRlcmkoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfTUlOX0ZJTFRFUiwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ORUFSRVNUKTtcclxuICAgIC8vICAgICBjcmMzLmdlbmVyYXRlTWlwbWFwKGNyYzMuVEVYVFVSRV8yRCk7XHJcbiAgICAvLyAgICAgdGhpcy5yZW5kZXJEYXRhW1widGV4dHVyZTBcIl0gPSB0ZXh0dXJlO1xyXG5cclxuICAgIC8vICAgICBjcmMzLmJpbmRUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgbnVsbCk7XHJcblxyXG4gICAgLy8gICAgIHRoaXMudXNlUmVuZGVyRGF0YShfcmVuZGVyU2hhZGVyKTtcclxuICAgIC8vICAgfVxyXG4gICAgLy8gfVxyXG5cclxuICAgIC8vIHByaXZhdGUgc3RhdGljIGluamVjdFJlbmRlckRhdGFGb3JDb2F0TWF0Q2FwKHRoaXM6IENvYXQsIF9yZW5kZXJTaGFkZXI6IFJlbmRlclNoYWRlcik6IHZvaWQge1xyXG4gICAgLy8gICBsZXQgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlck9wZXJhdG9yLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcclxuXHJcbiAgICAvLyAgIGxldCBjb2xvclVuaWZvcm1Mb2NhdGlvbjogV2ViR0xVbmlmb3JtTG9jYXRpb24gPSBfcmVuZGVyU2hhZGVyLnVuaWZvcm1zW1widV90aW50X2NvbG9yXCJdO1xyXG4gICAgLy8gICBsZXQgeyByLCBnLCBiLCBhIH0gPSAoPENvYXRNYXRDYXA+dGhpcykudGludENvbG9yO1xyXG4gICAgLy8gICBsZXQgdGludENvbG9yQXJyYXk6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoW3IsIGcsIGIsIGFdKTtcclxuICAgIC8vICAgY3JjMy51bmlmb3JtNGZ2KGNvbG9yVW5pZm9ybUxvY2F0aW9uLCB0aW50Q29sb3JBcnJheSk7XHJcblxyXG4gICAgLy8gICBsZXQgZmxvYXRVbmlmb3JtTG9jYXRpb246IFdlYkdMVW5pZm9ybUxvY2F0aW9uID0gX3JlbmRlclNoYWRlci51bmlmb3Jtc1tcInVfZmxhdG1peFwiXTtcclxuICAgIC8vICAgbGV0IGZsYXRNaXg6IG51bWJlciA9ICg8Q29hdE1hdENhcD50aGlzKS5mbGF0TWl4O1xyXG4gICAgLy8gICBjcmMzLnVuaWZvcm0xZihmbG9hdFVuaWZvcm1Mb2NhdGlvbiwgZmxhdE1peCk7XHJcblxyXG4gICAgLy8gICBpZiAodGhpcy5yZW5kZXJEYXRhKSB7XHJcbiAgICAvLyAgICAgLy8gYnVmZmVycyBleGlzdFxyXG4gICAgLy8gICAgIGNyYzMuYWN0aXZlVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkUwKTtcclxuICAgIC8vICAgICBjcmMzLmJpbmRUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgdGhpcy5yZW5kZXJEYXRhW1widGV4dHVyZTBcIl0pO1xyXG4gICAgLy8gICAgIGNyYzMudW5pZm9ybTFpKF9yZW5kZXJTaGFkZXIudW5pZm9ybXNbXCJ1X3RleHR1cmVcIl0sIDApO1xyXG4gICAgLy8gICB9XHJcbiAgICAvLyAgIGVsc2Uge1xyXG4gICAgLy8gICAgIHRoaXMucmVuZGVyRGF0YSA9IHt9O1xyXG4gICAgLy8gICAgIC8vIFRPRE86IGNoZWNrIGlmIGFsbCBXZWJHTC1DcmVhdGlvbnMgYXJlIGFzc2VydGVkXHJcbiAgICAvLyAgICAgY29uc3QgdGV4dHVyZTogV2ViR0xUZXh0dXJlID0gUmVuZGVyTWFuYWdlci5hc3NlcnQ8V2ViR0xUZXh0dXJlPihjcmMzLmNyZWF0ZVRleHR1cmUoKSk7XHJcbiAgICAvLyAgICAgY3JjMy5iaW5kVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIHRleHR1cmUpO1xyXG5cclxuICAgIC8vICAgICB0cnkge1xyXG4gICAgLy8gICAgICAgY3JjMy50ZXhJbWFnZTJEKGNyYzMuVEVYVFVSRV8yRCwgMCwgY3JjMy5SR0JBLCBjcmMzLlJHQkEsIGNyYzMuVU5TSUdORURfQllURSwgKDxDb2F0TWF0Q2FwPnRoaXMpLnRleHR1cmUuaW1hZ2UpO1xyXG4gICAgLy8gICAgICAgY3JjMy50ZXhJbWFnZTJEKFxyXG4gICAgLy8gICAgICAgICBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIDAsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuUkdCQSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5SR0JBLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOU0lHTkVEX0JZVEUsXHJcbiAgICAvLyAgICAgICAgICg8Q29hdE1hdENhcD50aGlzKS50ZXh0dXJlLmltYWdlXHJcbiAgICAvLyAgICAgICApO1xyXG4gICAgLy8gICAgIH0gY2F0Y2ggKF9lcnJvcikge1xyXG4gICAgLy8gICAgICAgRGVidWcuZXJyb3IoX2Vycm9yKTtcclxuICAgIC8vICAgICB9XHJcbiAgICAvLyAgICAgY3JjMy50ZXhQYXJhbWV0ZXJpKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFX01BR19GSUxURVIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTkVBUkVTVCk7XHJcbiAgICAvLyAgICAgY3JjMy50ZXhQYXJhbWV0ZXJpKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFX01JTl9GSUxURVIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTkVBUkVTVCk7XHJcbiAgICAvLyAgICAgY3JjMy5nZW5lcmF0ZU1pcG1hcChjcmMzLlRFWFRVUkVfMkQpO1xyXG4gICAgLy8gICAgIHRoaXMucmVuZGVyRGF0YVtcInRleHR1cmUwXCJdID0gdGV4dHVyZTtcclxuXHJcbiAgICAvLyAgICAgY3JjMy5iaW5kVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIG51bGwpO1xyXG4gICAgLy8gICAgIHRoaXMudXNlUmVuZGVyRGF0YShfcmVuZGVyU2hhZGVyKTtcclxuICAgIC8vICAgfVxyXG4gICAgLy8gfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBjbGFzcyBSZW5kZXJJbmplY3RvckNvYXQgZXh0ZW5kcyBSZW5kZXJJbmplY3RvciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIGRlY29yYXRlKF9jb25zdHJ1Y3RvcjogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgUmVuZGVySW5qZWN0b3IuaW5qZWN0KF9jb25zdHJ1Y3RvciwgUmVuZGVySW5qZWN0b3JDb2F0KTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGluamVjdENvYXRDb2xvcmVkKHRoaXM6IENvYXQsIF9yZW5kZXJTaGFkZXI6IFJlbmRlclNoYWRlcik6IHZvaWQge1xyXG4gICAgICBsZXQgY29sb3JVbmlmb3JtTG9jYXRpb246IFdlYkdMVW5pZm9ybUxvY2F0aW9uID0gX3JlbmRlclNoYWRlci51bmlmb3Jtc1tcInVfY29sb3JcIl07XHJcbiAgICAgIGxldCBjb2xvcjogRmxvYXQzMkFycmF5ID0gKDxDb2F0Q29sb3JlZD50aGlzKS5jb2xvci5nZXRBcnJheSgpO1xyXG4gICAgICBSZW5kZXJPcGVyYXRvci5nZXRSZW5kZXJpbmdDb250ZXh0KCkudW5pZm9ybTRmdihjb2xvclVuaWZvcm1Mb2NhdGlvbiwgY29sb3IpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgaW5qZWN0Q29hdFRleHR1cmVkKHRoaXM6IENvYXQsIF9yZW5kZXJTaGFkZXI6IFJlbmRlclNoYWRlcik6IHZvaWQge1xyXG4gICAgICBsZXQgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlck9wZXJhdG9yLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcclxuICAgICAgaWYgKHRoaXMucmVuZGVyRGF0YSkge1xyXG4gICAgICAgIC8vIGJ1ZmZlcnMgZXhpc3RcclxuICAgICAgICBjcmMzLmFjdGl2ZVRleHR1cmUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFMCk7XHJcbiAgICAgICAgY3JjMy5iaW5kVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIHRoaXMucmVuZGVyRGF0YVtcInRleHR1cmUwXCJdKTtcclxuICAgICAgICBjcmMzLnVuaWZvcm0xaShfcmVuZGVyU2hhZGVyLnVuaWZvcm1zW1widV90ZXh0dXJlXCJdLCAwKTtcclxuICAgICAgICBjcmMzLnVuaWZvcm1NYXRyaXgzZnYoX3JlbmRlclNoYWRlci51bmlmb3Jtc1tcInVfcGl2b3RcIl0sIGZhbHNlLCAoPENvYXRUZXh0dXJlZD50aGlzKS5waXZvdC5nZXQoKSk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJEYXRhID0ge307XHJcbiAgICAgICAgLy8gVE9ETzogY2hlY2sgaWYgYWxsIFdlYkdMLUNyZWF0aW9ucyBhcmUgYXNzZXJ0ZWRcclxuICAgICAgICBjb25zdCB0ZXh0dXJlOiBXZWJHTFRleHR1cmUgPSBSZW5kZXJNYW5hZ2VyLmFzc2VydDxXZWJHTFRleHR1cmU+KGNyYzMuY3JlYXRlVGV4dHVyZSgpKTtcclxuICAgICAgICBjcmMzLmJpbmRUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjcmMzLnRleEltYWdlMkQoY3JjMy5URVhUVVJFXzJELCAwLCBjcmMzLlJHQkEsIGNyYzMuUkdCQSwgY3JjMy5VTlNJR05FRF9CWVRFLCAoPENvYXRUZXh0dXJlZD50aGlzKS50ZXh0dXJlLmltYWdlKTtcclxuICAgICAgICAgIGNyYzMudGV4SW1hZ2UyRChcclxuICAgICAgICAgICAgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCAwLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlJHQkEsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuUkdCQSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTlNJR05FRF9CWVRFLFxyXG4gICAgICAgICAgICAoPENvYXRUZXh0dXJlZD50aGlzKS50ZXh0dXJlLmltYWdlXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xyXG4gICAgICAgICAgRGVidWcuZXJyb3IoX2Vycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3JjMy50ZXhQYXJhbWV0ZXJpKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFX01BR19GSUxURVIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTkVBUkVTVCk7XHJcbiAgICAgICAgY3JjMy50ZXhQYXJhbWV0ZXJpKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFX01JTl9GSUxURVIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTkVBUkVTVCk7XHJcbiAgICAgICAgY3JjMy5nZW5lcmF0ZU1pcG1hcChjcmMzLlRFWFRVUkVfMkQpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyRGF0YVtcInRleHR1cmUwXCJdID0gdGV4dHVyZTtcclxuXHJcbiAgICAgICAgY3JjMy5iaW5kVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIG51bGwpO1xyXG5cclxuICAgICAgICB0aGlzLnVzZVJlbmRlckRhdGEoX3JlbmRlclNoYWRlcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGluamVjdENvYXRNYXRDYXAodGhpczogQ29hdCwgX3JlbmRlclNoYWRlcjogUmVuZGVyU2hhZGVyKTogdm9pZCB7XHJcbiAgICAgIGxldCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyT3BlcmF0b3IuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG5cclxuICAgICAgbGV0IGNvbG9yVW5pZm9ybUxvY2F0aW9uOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiA9IF9yZW5kZXJTaGFkZXIudW5pZm9ybXNbXCJ1X3RpbnRfY29sb3JcIl07XHJcbiAgICAgIGxldCB7IHIsIGcsIGIsIGEgfSA9ICg8Q29hdE1hdENhcD50aGlzKS50aW50Q29sb3I7XHJcbiAgICAgIGxldCB0aW50Q29sb3JBcnJheTogRmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShbciwgZywgYiwgYV0pO1xyXG4gICAgICBjcmMzLnVuaWZvcm00ZnYoY29sb3JVbmlmb3JtTG9jYXRpb24sIHRpbnRDb2xvckFycmF5KTtcclxuXHJcbiAgICAgIGxldCBmbG9hdFVuaWZvcm1Mb2NhdGlvbjogV2ViR0xVbmlmb3JtTG9jYXRpb24gPSBfcmVuZGVyU2hhZGVyLnVuaWZvcm1zW1widV9mbGF0bWl4XCJdO1xyXG4gICAgICBsZXQgZmxhdE1peDogbnVtYmVyID0gKDxDb2F0TWF0Q2FwPnRoaXMpLmZsYXRNaXg7XHJcbiAgICAgIGNyYzMudW5pZm9ybTFmKGZsb2F0VW5pZm9ybUxvY2F0aW9uLCBmbGF0TWl4KTtcclxuXHJcbiAgICAgIGlmICh0aGlzLnJlbmRlckRhdGEpIHtcclxuICAgICAgICAvLyBidWZmZXJzIGV4aXN0XHJcbiAgICAgICAgY3JjMy5hY3RpdmVUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRTApO1xyXG4gICAgICAgIGNyYzMuYmluZFRleHR1cmUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCB0aGlzLnJlbmRlckRhdGFbXCJ0ZXh0dXJlMFwiXSk7XHJcbiAgICAgICAgY3JjMy51bmlmb3JtMWkoX3JlbmRlclNoYWRlci51bmlmb3Jtc1tcInVfdGV4dHVyZVwiXSwgMCk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJEYXRhID0ge307XHJcbiAgICAgICAgLy8gVE9ETzogY2hlY2sgaWYgYWxsIFdlYkdMLUNyZWF0aW9ucyBhcmUgYXNzZXJ0ZWRcclxuICAgICAgICBjb25zdCB0ZXh0dXJlOiBXZWJHTFRleHR1cmUgPSBSZW5kZXJNYW5hZ2VyLmFzc2VydDxXZWJHTFRleHR1cmU+KGNyYzMuY3JlYXRlVGV4dHVyZSgpKTtcclxuICAgICAgICBjcmMzLmJpbmRUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjcmMzLnRleEltYWdlMkQoY3JjMy5URVhUVVJFXzJELCAwLCBjcmMzLlJHQkEsIGNyYzMuUkdCQSwgY3JjMy5VTlNJR05FRF9CWVRFLCAoPENvYXRNYXRDYXA+dGhpcykudGV4dHVyZS5pbWFnZSk7XHJcbiAgICAgICAgICBjcmMzLnRleEltYWdlMkQoXHJcbiAgICAgICAgICAgIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgMCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5SR0JBLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlJHQkEsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5TSUdORURfQllURSxcclxuICAgICAgICAgICAgKDxDb2F0TWF0Q2FwPnRoaXMpLnRleHR1cmUuaW1hZ2VcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XHJcbiAgICAgICAgICBEZWJ1Zy5lcnJvcihfZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjcmMzLnRleFBhcmFtZXRlcmkoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfTUFHX0ZJTFRFUiwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ORUFSRVNUKTtcclxuICAgICAgICBjcmMzLnRleFBhcmFtZXRlcmkoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfTUlOX0ZJTFRFUiwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ORUFSRVNUKTtcclxuICAgICAgICBjcmMzLmdlbmVyYXRlTWlwbWFwKGNyYzMuVEVYVFVSRV8yRCk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJEYXRhW1widGV4dHVyZTBcIl0gPSB0ZXh0dXJlO1xyXG5cclxuICAgICAgICBjcmMzLmJpbmRUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgbnVsbCk7XHJcbiAgICAgICAgdGhpcy51c2VSZW5kZXJEYXRhKF9yZW5kZXJTaGFkZXIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGNsYXNzIFJlbmRlckluamVjdG9yTWVzaCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIGRlY29yYXRlKF9jb25zdHJ1Y3RvcjogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIFwidXNlUmVuZGVyQnVmZmVyc1wiLCB7XHJcbiAgICAgICAgdmFsdWU6IFJlbmRlckluamVjdG9yTWVzaC51c2VSZW5kZXJCdWZmZXJzXHJcbiAgICAgIH0pO1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2NvbnN0cnVjdG9yLnByb3RvdHlwZSwgXCJjcmVhdGVSZW5kZXJCdWZmZXJzXCIsIHtcclxuICAgICAgICB2YWx1ZTogUmVuZGVySW5qZWN0b3JNZXNoLmNyZWF0ZVJlbmRlckJ1ZmZlcnNcclxuICAgICAgfSk7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfY29uc3RydWN0b3IucHJvdG90eXBlLCBcImRlbGV0ZVJlbmRlckJ1ZmZlcnNcIiwge1xyXG4gICAgICAgIHZhbHVlOiBSZW5kZXJJbmplY3Rvck1lc2guZGVsZXRlUmVuZGVyQnVmZmVyc1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGNyZWF0ZVJlbmRlckJ1ZmZlcnModGhpczogTWVzaCk6IHZvaWQge1xyXG4gICAgICAvLyBjb25zb2xlLmxvZyhcImNyZWF0ZVJlbmRlckJ1ZmZlcnNcIiwgdGhpcyk7XHJcbiAgICAgIC8vIHJldHVybjtcclxuXHJcbiAgICAgIGxldCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyT3BlcmF0b3IuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG4gICAgICBsZXQgdmVydGljZXM6IFdlYkdMQnVmZmVyID0gUmVuZGVyT3BlcmF0b3IuYXNzZXJ0PFdlYkdMQnVmZmVyPihjcmMzLmNyZWF0ZUJ1ZmZlcigpKTtcclxuICAgICAgY3JjMy5iaW5kQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQVJSQVlfQlVGRkVSLCB2ZXJ0aWNlcyk7XHJcbiAgICAgIGNyYzMuYnVmZmVyRGF0YShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgdGhpcy52ZXJ0aWNlcywgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5TVEFUSUNfRFJBVyk7XHJcblxyXG4gICAgICBsZXQgaW5kaWNlczogV2ViR0xCdWZmZXIgPSBSZW5kZXJPcGVyYXRvci5hc3NlcnQ8V2ViR0xCdWZmZXI+KGNyYzMuY3JlYXRlQnVmZmVyKCkpO1xyXG4gICAgICBjcmMzLmJpbmRCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgaW5kaWNlcyk7XHJcbiAgICAgIGNyYzMuYnVmZmVyRGF0YShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmluZGljZXMsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuU1RBVElDX0RSQVcpO1xyXG5cclxuICAgICAgbGV0IHRleHR1cmVVVnM6IFdlYkdMQnVmZmVyID0gY3JjMy5jcmVhdGVCdWZmZXIoKTtcclxuICAgICAgY3JjMy5iaW5kQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQVJSQVlfQlVGRkVSLCB0ZXh0dXJlVVZzKTtcclxuICAgICAgY3JjMy5idWZmZXJEYXRhKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQVJSQVlfQlVGRkVSLCB0aGlzLnRleHR1cmVVVnMsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuU1RBVElDX0RSQVcpO1xyXG5cclxuICAgICAgbGV0IG5vcm1hbHNGYWNlOiBXZWJHTEJ1ZmZlciA9IFJlbmRlck9wZXJhdG9yLmFzc2VydDxXZWJHTEJ1ZmZlcj4oY3JjMy5jcmVhdGVCdWZmZXIoKSk7XHJcbiAgICAgIGNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgbm9ybWFsc0ZhY2UpO1xyXG4gICAgICBjcmMzLmJ1ZmZlckRhdGEoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BUlJBWV9CVUZGRVIsIHRoaXMubm9ybWFsc0ZhY2UsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuU1RBVElDX0RSQVcpO1xyXG5cclxuICAgICAgbGV0IHJlbmRlckJ1ZmZlcnM6IFJlbmRlckJ1ZmZlcnMgPSB7XHJcbiAgICAgICAgdmVydGljZXM6IHZlcnRpY2VzLFxyXG4gICAgICAgIGluZGljZXM6IGluZGljZXMsXHJcbiAgICAgICAgbkluZGljZXM6IHRoaXMuZ2V0SW5kZXhDb3VudCgpLFxyXG4gICAgICAgIHRleHR1cmVVVnM6IHRleHR1cmVVVnMsXHJcbiAgICAgICAgbm9ybWFsc0ZhY2U6IG5vcm1hbHNGYWNlXHJcbiAgICAgIH07XHJcblxyXG4gICAgICB0aGlzLnJlbmRlckJ1ZmZlcnMgPSByZW5kZXJCdWZmZXJzO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgdXNlUmVuZGVyQnVmZmVycyh0aGlzOiBNZXNoLCBfcmVuZGVyU2hhZGVyOiBSZW5kZXJTaGFkZXIsIF93b3JsZDogTWF0cml4NHg0LCBfcHJvamVjdGlvbjogTWF0cml4NHg0LCBfaWQ/OiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgLy8gY29uc29sZS5sb2coXCJ1c2VSZW5kZXJCdWZmZXJzXCIsIHRoaXMpO1xyXG4gICAgICAvLyByZXR1cm47XHJcbiAgICAgIGxldCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyT3BlcmF0b3IuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG5cclxuICAgICAgbGV0IGFQb3NpdGlvbjogbnVtYmVyID0gX3JlbmRlclNoYWRlci5hdHRyaWJ1dGVzW1wiYV9wb3NpdGlvblwiXTtcclxuICAgICAgY3JjMy5iaW5kQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQVJSQVlfQlVGRkVSLCB0aGlzLnJlbmRlckJ1ZmZlcnMudmVydGljZXMpO1xyXG4gICAgICBjcmMzLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGFQb3NpdGlvbik7XHJcbiAgICAgIFJlbmRlck9wZXJhdG9yLnNldEF0dHJpYnV0ZVN0cnVjdHVyZShhUG9zaXRpb24sIE1lc2guZ2V0QnVmZmVyU3BlY2lmaWNhdGlvbigpKTtcclxuXHJcbiAgICAgIGNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLnJlbmRlckJ1ZmZlcnMuaW5kaWNlcyk7XHJcblxyXG4gICAgICBsZXQgdVByb2plY3Rpb246IFdlYkdMVW5pZm9ybUxvY2F0aW9uID0gX3JlbmRlclNoYWRlci51bmlmb3Jtc1tcInVfcHJvamVjdGlvblwiXTtcclxuICAgICAgY3JjMy51bmlmb3JtTWF0cml4NGZ2KHVQcm9qZWN0aW9uLCBmYWxzZSwgX3Byb2plY3Rpb24uZ2V0KCkpO1xyXG5cclxuICAgICAgLy8gZmVlZCBpbiBmYWNlIG5vcm1hbHMgaWYgc2hhZGVyIGFjY2VwdHMgdV93b3JsZC4gXHJcbiAgICAgIGxldCB1V29ybGQ6IFdlYkdMVW5pZm9ybUxvY2F0aW9uID0gX3JlbmRlclNoYWRlci51bmlmb3Jtc1tcInVfd29ybGRcIl1cclxuICAgICAgaWYgKHVXb3JsZCkge1xyXG4gICAgICAgIGNyYzMudW5pZm9ybU1hdHJpeDRmdih1V29ybGQsIGZhbHNlLCBfd29ybGQuZ2V0KCkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgYU5vcm1hbDogbnVtYmVyID0gX3JlbmRlclNoYWRlci5hdHRyaWJ1dGVzW1wiYV9ub3JtYWxcIl07XHJcbiAgICAgIGlmIChhTm9ybWFsKSB7XHJcbiAgICAgICAgY3JjMy5iaW5kQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQVJSQVlfQlVGRkVSLCB0aGlzLnJlbmRlckJ1ZmZlcnMubm9ybWFsc0ZhY2UpO1xyXG4gICAgICAgIGNyYzMuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYU5vcm1hbCk7XHJcbiAgICAgICAgUmVuZGVyT3BlcmF0b3Iuc2V0QXR0cmlidXRlU3RydWN0dXJlKGFOb3JtYWwsIE1lc2guZ2V0QnVmZmVyU3BlY2lmaWNhdGlvbigpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gZmVlZCBpbiB0ZXh0dXJlIGNvb3JkaW5hdGVzIGlmIHNoYWRlciBhY2NlcHRzIGFfdGV4dHVyZVVWc1xyXG4gICAgICBsZXQgYVRleHR1cmVVVnM6IG51bWJlciA9IF9yZW5kZXJTaGFkZXIuYXR0cmlidXRlc1tcImFfdGV4dHVyZVVWc1wiXTtcclxuICAgICAgaWYgKGFUZXh0dXJlVVZzKSB7XHJcbiAgICAgICAgY3JjMy5iaW5kQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQVJSQVlfQlVGRkVSLCB0aGlzLnJlbmRlckJ1ZmZlcnMudGV4dHVyZVVWcyk7XHJcbiAgICAgICAgY3JjMy5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhVGV4dHVyZVVWcyk7IC8vIGVuYWJsZSB0aGUgYnVmZmVyXHJcbiAgICAgICAgY3JjMy52ZXJ0ZXhBdHRyaWJQb2ludGVyKGFUZXh0dXJlVVZzLCAyLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZMT0FULCBmYWxzZSwgMCwgMCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGZlZWQgaW4gYW4gaWQgb2YgdGhlIG5vZGUgaWYgc2hhZGVyIGFjY2VwdHMgdV9pZC4gVXNlZCBmb3IgcGlja2luZ1xyXG4gICAgICBsZXQgdUlkOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiA9IF9yZW5kZXJTaGFkZXIudW5pZm9ybXNbXCJ1X2lkXCJdO1xyXG4gICAgICBpZiAodUlkKVxyXG4gICAgICAgIFJlbmRlck9wZXJhdG9yLmdldFJlbmRlcmluZ0NvbnRleHQoKS51bmlmb3JtMWkodUlkLCBfaWQpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgZGVsZXRlUmVuZGVyQnVmZmVycyhfcmVuZGVyQnVmZmVyczogUmVuZGVyQnVmZmVycyk6IHZvaWQge1xyXG4gICAgICAvLyBjb25zb2xlLmxvZyhcImRlbGV0ZVJlbmRlckJ1ZmZlcnNcIiwgdGhpcyk7XHJcbiAgICAgIC8vIHJldHVybjtcclxuICAgICAgbGV0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJPcGVyYXRvci5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcbiAgICAgIGlmIChfcmVuZGVyQnVmZmVycykge1xyXG4gICAgICAgIGNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgbnVsbCk7XHJcbiAgICAgICAgY3JjMy5kZWxldGVCdWZmZXIoX3JlbmRlckJ1ZmZlcnMudmVydGljZXMpO1xyXG4gICAgICAgIGNyYzMuZGVsZXRlQnVmZmVyKF9yZW5kZXJCdWZmZXJzLnRleHR1cmVVVnMpO1xyXG4gICAgICAgIGNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBudWxsKTtcclxuICAgICAgICBjcmMzLmRlbGV0ZUJ1ZmZlcihfcmVuZGVyQnVmZmVycy5pbmRpY2VzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufSIsIi8vLzxyZWZlcmVuY2UgcGF0aD1cIlJlbmRlckluamVjdG9yLnRzXCIvPlxyXG4vLy88cmVmZXJlbmNlIHBhdGg9XCJSZW5kZXJJbmplY3RvckNvYXQudHNcIi8+XHJcbi8vLzxyZWZlcmVuY2UgcGF0aD1cIlJlbmRlckluamVjdG9yTWVzaC50c1wiLz5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGludGVyZmFjZSBCdWZmZXJTcGVjaWZpY2F0aW9uIHtcclxuICAgIHNpemU6IG51bWJlcjsgICAvLyBUaGUgc2l6ZSBvZiB0aGUgZGF0YXNhbXBsZS5cclxuICAgIGRhdGFUeXBlOiBudW1iZXI7IC8vIFRoZSBkYXRhdHlwZSBvZiB0aGUgc2FtcGxlIChlLmcuIGdsLkZMT0FULCBnbC5CWVRFLCBldGMuKVxyXG4gICAgbm9ybWFsaXplOiBib29sZWFuOyAvLyBGbGFnIHRvIG5vcm1hbGl6ZSB0aGUgZGF0YS5cclxuICAgIHN0cmlkZTogbnVtYmVyOyAvLyBOdW1iZXIgb2YgaW5kaWNlcyB0aGF0IHdpbGwgYmUgc2tpcHBlZCBlYWNoIGl0ZXJhdGlvbi5cclxuICAgIG9mZnNldDogbnVtYmVyOyAvLyBJbmRleCBvZiB0aGUgZWxlbWVudCB0byBiZWdpbiB3aXRoLlxyXG4gIH1cclxuICBleHBvcnQgaW50ZXJmYWNlIFJlbmRlclNoYWRlciB7XHJcbiAgICAvLyBUT0RPOiBleGFtaW5lLCBpZiB0aGlzIHNob3VsZCBiZSBpbmplY3RlZCBpbiBzaGFkZXIgY2xhc3MgdmlhIFJlbmRlckluamVjdG9yLCBhcyBkb25lIHdpdGggQ29hdFxyXG4gICAgcHJvZ3JhbTogV2ViR0xQcm9ncmFtO1xyXG4gICAgYXR0cmlidXRlczogeyBbbmFtZTogc3RyaW5nXTogbnVtYmVyIH07XHJcbiAgICB1bmlmb3JtczogeyBbbmFtZTogc3RyaW5nXTogV2ViR0xVbmlmb3JtTG9jYXRpb24gfTtcclxuICB9XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgUmVuZGVyQnVmZmVycyB7XHJcbiAgICAvLyBUT0RPOiBleGFtaW5lLCBpZiB0aGlzIHNob3VsZCBiZSBpbmplY3RlZCBpbiBtZXNoIGNsYXNzIHZpYSBSZW5kZXJJbmplY3RvciwgYXMgZG9uZSB3aXRoIENvYXRcclxuICAgIHZlcnRpY2VzOiBXZWJHTEJ1ZmZlcjtcclxuICAgIGluZGljZXM6IFdlYkdMQnVmZmVyO1xyXG4gICAgbkluZGljZXM6IG51bWJlcjtcclxuICAgIHRleHR1cmVVVnM6IFdlYkdMQnVmZmVyO1xyXG4gICAgbm9ybWFsc0ZhY2U6IFdlYkdMQnVmZmVyO1xyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGludGVyZmFjZSBSZW5kZXJDb2F0IHtcclxuICAgIC8vVE9ETzogZXhhbWluZSwgaWYgaXQgbWFrZXMgc2Vuc2UgdG8gc3RvcmUgYSB2YW8gZm9yIGVhY2ggQ29hdCwgZXZlbiB0aG91Z2ggZS5nLiBjb2xvciB3b24ndCBiZSBzdG9yZWQgYW55d2F5Li4uXHJcbiAgICAvL3ZhbzogV2ViR0xWZXJ0ZXhBcnJheU9iamVjdDtcclxuICAgIGNvYXQ6IENvYXQ7XHJcbiAgfVxyXG5cclxuICBleHBvcnQgaW50ZXJmYWNlIFJlbmRlckxpZ2h0cyB7XHJcbiAgICBbdHlwZTogc3RyaW5nXTogRmxvYXQzMkFycmF5O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQmFzZSBjbGFzcyBmb3IgUmVuZGVyTWFuYWdlciwgaGFuZGxpbmcgdGhlIGNvbm5lY3Rpb24gdG8gdGhlIHJlbmRlcmluZyBzeXN0ZW0sIGluIHRoaXMgY2FzZSBXZWJHTC5cclxuICAgKiBNZXRob2RzIGFuZCBhdHRyaWJ1dGVzIG9mIHRoaXMgY2xhc3Mgc2hvdWxkIG5vdCBiZSBjYWxsZWQgZGlyZWN0bHksIG9ubHkgdGhyb3VnaCBbW1JlbmRlck1hbmFnZXJdXVxyXG4gICAqL1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBSZW5kZXJPcGVyYXRvciB7XHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ7XHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHJlbmRlclNoYWRlclJheUNhc3Q6IFJlbmRlclNoYWRlcjtcclxuICAgIHByaXZhdGUgc3RhdGljIHJlY3RWaWV3cG9ydDogUmVjdGFuZ2xlO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIFdyYXBwZXIgZnVuY3Rpb24gdG8gdXRpbGl6ZSB0aGUgYnVmZmVyU3BlY2lmaWNhdGlvbiBpbnRlcmZhY2Ugd2hlbiBwYXNzaW5nIGRhdGEgdG8gdGhlIHNoYWRlciB2aWEgYSBidWZmZXIuXHJcbiAgICAgKiBAcGFyYW0gX2F0dHJpYnV0ZUxvY2F0aW9uIC8vIFRoZSBsb2NhdGlvbiBvZiB0aGUgYXR0cmlidXRlIG9uIHRoZSBzaGFkZXIsIHRvIHdoaWNoIHRoZXkgZGF0YSB3aWxsIGJlIHBhc3NlZC5cclxuICAgICAqIEBwYXJhbSBfYnVmZmVyU3BlY2lmaWNhdGlvbiAvLyBJbnRlcmZhY2UgcGFzc2luZyBkYXRhcHVsbHNwZWNpZmljYXRpb25zIHRvIHRoZSBidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc2V0QXR0cmlidXRlU3RydWN0dXJlKF9hdHRyaWJ1dGVMb2NhdGlvbjogbnVtYmVyLCBfYnVmZmVyU3BlY2lmaWNhdGlvbjogQnVmZmVyU3BlY2lmaWNhdGlvbik6IHZvaWQge1xyXG4gICAgICBSZW5kZXJPcGVyYXRvci5jcmMzLnZlcnRleEF0dHJpYlBvaW50ZXIoX2F0dHJpYnV0ZUxvY2F0aW9uLCBfYnVmZmVyU3BlY2lmaWNhdGlvbi5zaXplLCBfYnVmZmVyU3BlY2lmaWNhdGlvbi5kYXRhVHlwZSwgX2J1ZmZlclNwZWNpZmljYXRpb24ubm9ybWFsaXplLCBfYnVmZmVyU3BlY2lmaWNhdGlvbi5zdHJpZGUsIF9idWZmZXJTcGVjaWZpY2F0aW9uLm9mZnNldCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIENoZWNrcyB0aGUgZmlyc3QgcGFyYW1ldGVyIGFuZCB0aHJvd3MgYW4gZXhjZXB0aW9uIHdpdGggdGhlIFdlYkdMLWVycm9yY29kZSBpZiB0aGUgdmFsdWUgaXMgbnVsbFxyXG4gICAgKiBAcGFyYW0gX3ZhbHVlIC8vIHZhbHVlIHRvIGNoZWNrIGFnYWluc3QgbnVsbFxyXG4gICAgKiBAcGFyYW0gX21lc3NhZ2UgLy8gb3B0aW9uYWwsIGFkZGl0aW9uYWwgbWVzc2FnZSBmb3IgdGhlIGV4Y2VwdGlvblxyXG4gICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgYXNzZXJ0PFQ+KF92YWx1ZTogVCB8IG51bGwsIF9tZXNzYWdlOiBzdHJpbmcgPSBcIlwiKTogVCB7XHJcbiAgICAgIGlmIChfdmFsdWUgPT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBc3NlcnRpb24gZmFpbGVkLiAke19tZXNzYWdlfSwgV2ViR0wtRXJyb3I6ICR7UmVuZGVyT3BlcmF0b3IuY3JjMyA/IFJlbmRlck9wZXJhdG9yLmNyYzMuZ2V0RXJyb3IoKSA6IFwiXCJ9YCk7XHJcbiAgICAgIHJldHVybiBfdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemVzIG9mZnNjcmVlbi1jYW52YXMsIHJlbmRlcmluZ2NvbnRleHQgYW5kIGhhcmR3YXJlIHZpZXdwb3J0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGluaXRpYWxpemUoX2FudGlhbGlhczogYm9vbGVhbiA9IGZhbHNlLCBfYWxwaGE6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XHJcbiAgICAgIGxldCBjb250ZXh0QXR0cmlidXRlczogV2ViR0xDb250ZXh0QXR0cmlidXRlcyA9IHsgYWxwaGE6IF9hbHBoYSwgYW50aWFsaWFzOiBfYW50aWFsaWFzLCBwcmVtdWx0aXBsaWVkQWxwaGE6IGZhbHNlIH07XHJcbiAgICAgIGxldCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcclxuICAgICAgUmVuZGVyT3BlcmF0b3IuY3JjMyA9IFJlbmRlck9wZXJhdG9yLmFzc2VydDxXZWJHTDJSZW5kZXJpbmdDb250ZXh0PihcclxuICAgICAgICBjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsMlwiLCBjb250ZXh0QXR0cmlidXRlcyksXHJcbiAgICAgICAgXCJXZWJHTC1jb250ZXh0IGNvdWxkbid0IGJlIGNyZWF0ZWRcIlxyXG4gICAgICApO1xyXG4gICAgICAvLyBFbmFibGUgYmFja2ZhY2UtIGFuZCB6QnVmZmVyLWN1bGxpbmcuXHJcbiAgICAgIFJlbmRlck9wZXJhdG9yLmNyYzMuZW5hYmxlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ1VMTF9GQUNFKTtcclxuICAgICAgUmVuZGVyT3BlcmF0b3IuY3JjMy5lbmFibGUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ERVBUSF9URVNUKTtcclxuICAgICAgUmVuZGVyT3BlcmF0b3IuY3JjMy5lbmFibGUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5CTEVORCk7XHJcbiAgICAgIFJlbmRlck9wZXJhdG9yLmNyYzMuYmxlbmRFcXVhdGlvbihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZVTkNfQUREKTtcclxuICAgICAgUmVuZGVyT3BlcmF0b3IuY3JjMy5ibGVuZEZ1bmMoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5EU1RfQUxQSEEsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuT05FX01JTlVTX0RTVF9BTFBIQSk7XHJcbiAgICAgIC8vIFJlbmRlck9wZXJhdG9yLmNyYzMuZW5hYmxlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuKTtcclxuICAgICAgLy8gUmVuZGVyT3BlcmF0b3IuY3JjMy5waXhlbFN0b3JlaShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOUEFDS19GTElQX1lfV0VCR0wsIHRydWUpO1xyXG4gICAgICBSZW5kZXJPcGVyYXRvci5yZWN0Vmlld3BvcnQgPSBSZW5kZXJPcGVyYXRvci5nZXRDYW52YXNSZWN0KCk7XHJcblxyXG4gICAgICBSZW5kZXJPcGVyYXRvci5yZW5kZXJTaGFkZXJSYXlDYXN0ID0gUmVuZGVyT3BlcmF0b3IuY3JlYXRlUHJvZ3JhbShTaGFkZXJSYXlDYXN0KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhIHJlZmVyZW5jZSB0byB0aGUgb2Zmc2NyZWVuLWNhbnZhc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENhbnZhcygpOiBIVE1MQ2FudmFzRWxlbWVudCB7XHJcbiAgICAgIHJldHVybiA8SFRNTENhbnZhc0VsZW1lbnQ+UmVuZGVyT3BlcmF0b3IuY3JjMy5jYW52YXM7IC8vIFRPRE86IGVuYWJsZSBPZmZzY3JlZW5DYW52YXNcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGEgcmVmZXJlbmNlIHRvIHRoZSByZW5kZXJpbmcgY29udGV4dFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldFJlbmRlcmluZ0NvbnRleHQoKTogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCB7XHJcbiAgICAgIHJldHVybiBSZW5kZXJPcGVyYXRvci5jcmMzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYSByZWN0YW5nbGUgZGVzY3JpYmluZyB0aGUgc2l6ZSBvZiB0aGUgb2Zmc2NyZWVuLWNhbnZhcy4geCx5IGFyZSAwIGF0IGFsbCB0aW1lcy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXRDYW52YXNSZWN0KCk6IFJlY3RhbmdsZSB7XHJcbiAgICAgIGxldCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50ID0gPEhUTUxDYW52YXNFbGVtZW50PlJlbmRlck9wZXJhdG9yLmNyYzMuY2FudmFzO1xyXG4gICAgICByZXR1cm4gUmVjdGFuZ2xlLkdFVCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHNpemUgb2YgdGhlIG9mZnNjcmVlbi1jYW52YXMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc2V0Q2FudmFzU2l6ZShfd2lkdGg6IG51bWJlciwgX2hlaWdodDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIFJlbmRlck9wZXJhdG9yLmNyYzMuY2FudmFzLndpZHRoID0gX3dpZHRoO1xyXG4gICAgICBSZW5kZXJPcGVyYXRvci5jcmMzLmNhbnZhcy5oZWlnaHQgPSBfaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGFyZWEgb24gdGhlIG9mZnNjcmVlbi1jYW52YXMgdG8gcmVuZGVyIHRoZSBjYW1lcmEgaW1hZ2UgdG8uXHJcbiAgICAgKiBAcGFyYW0gX3JlY3RcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzZXRWaWV3cG9ydFJlY3RhbmdsZShfcmVjdDogUmVjdGFuZ2xlKTogdm9pZCB7XHJcbiAgICAgIE9iamVjdC5hc3NpZ24oUmVuZGVyT3BlcmF0b3IucmVjdFZpZXdwb3J0LCBfcmVjdCk7XHJcbiAgICAgIFJlbmRlck9wZXJhdG9yLmNyYzMudmlld3BvcnQoX3JlY3QueCwgX3JlY3QueSwgX3JlY3Qud2lkdGgsIF9yZWN0LmhlaWdodCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlIHRoZSBhcmVhIG9uIHRoZSBvZmZzY3JlZW4tY2FudmFzIHRoZSBjYW1lcmEgaW1hZ2UgZ2V0cyByZW5kZXJlZCB0by5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXRWaWV3cG9ydFJlY3RhbmdsZSgpOiBSZWN0YW5nbGUge1xyXG4gICAgICByZXR1cm4gUmVuZGVyT3BlcmF0b3IucmVjdFZpZXdwb3J0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydCBsaWdodCBkYXRhIHRvIGZsYXQgYXJyYXlzXHJcbiAgICAgKiBUT0RPOiB0aGlzIG1ldGhvZCBhcHBlYXJzIHRvIGJlIG9ic29sZXRlLi4uP1xyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGNyZWF0ZVJlbmRlckxpZ2h0cyhfbGlnaHRzOiBNYXBMaWdodFR5cGVUb0xpZ2h0TGlzdCk6IFJlbmRlckxpZ2h0cyB7XHJcbiAgICAgIGxldCByZW5kZXJMaWdodHM6IFJlbmRlckxpZ2h0cyA9IHt9O1xyXG4gICAgICBmb3IgKGxldCBlbnRyeSBvZiBfbGlnaHRzKSB7XHJcbiAgICAgICAgLy8gVE9ETzogc2ltcGx5ZnksIHNpbmNlIGRpcmVjdGlvbiBpcyBub3cgaGFuZGxlZCBieSBDb21wb25lbnRMaWdodFxyXG4gICAgICAgIHN3aXRjaCAoZW50cnlbMF0pIHtcclxuICAgICAgICAgIGNhc2UgTGlnaHRBbWJpZW50OlxyXG4gICAgICAgICAgICBsZXQgYW1iaWVudDogbnVtYmVyW10gPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgY21wTGlnaHQgb2YgZW50cnlbMV0pIHtcclxuICAgICAgICAgICAgICBsZXQgYzogQ29sb3IgPSBjbXBMaWdodC5saWdodC5jb2xvcjtcclxuICAgICAgICAgICAgICBhbWJpZW50LnB1c2goYy5yLCBjLmcsIGMuYiwgYy5hKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZW5kZXJMaWdodHNbXCJ1X2FtYmllbnRcIl0gPSBuZXcgRmxvYXQzMkFycmF5KGFtYmllbnQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgTGlnaHREaXJlY3Rpb25hbDpcclxuICAgICAgICAgICAgbGV0IGRpcmVjdGlvbmFsOiBudW1iZXJbXSA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBjbXBMaWdodCBvZiBlbnRyeVsxXSkge1xyXG4gICAgICAgICAgICAgIGxldCBjOiBDb2xvciA9IGNtcExpZ2h0LmxpZ2h0LmNvbG9yO1xyXG4gICAgICAgICAgICAgIC8vIGxldCBkOiBWZWN0b3IzID0gKDxMaWdodERpcmVjdGlvbmFsPmxpZ2h0LmdldExpZ2h0KCkpLmRpcmVjdGlvbjtcclxuICAgICAgICAgICAgICBkaXJlY3Rpb25hbC5wdXNoKGMuciwgYy5nLCBjLmIsIGMuYSwgMCwgMCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVuZGVyTGlnaHRzW1widV9kaXJlY3Rpb25hbFwiXSA9IG5ldyBGbG9hdDMyQXJyYXkoZGlyZWN0aW9uYWwpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIERlYnVnLndhcm4oXCJTaGFkZXJzdHJ1Y3R1cmUgdW5kZWZpbmVkIGZvclwiLCBlbnRyeVswXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZW5kZXJMaWdodHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgbGlnaHQgZGF0YSBpbiBzaGFkZXJzXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgc2V0TGlnaHRzSW5TaGFkZXIoX3JlbmRlclNoYWRlcjogUmVuZGVyU2hhZGVyLCBfbGlnaHRzOiBNYXBMaWdodFR5cGVUb0xpZ2h0TGlzdCk6IHZvaWQge1xyXG4gICAgICBSZW5kZXJPcGVyYXRvci51c2VQcm9ncmFtKF9yZW5kZXJTaGFkZXIpO1xyXG4gICAgICBsZXQgdW5pOiB7IFtuYW1lOiBzdHJpbmddOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiB9ID0gX3JlbmRlclNoYWRlci51bmlmb3JtcztcclxuXHJcbiAgICAgIGxldCBhbWJpZW50OiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiA9IHVuaVtcInVfYW1iaWVudC5jb2xvclwiXTtcclxuICAgICAgaWYgKGFtYmllbnQpIHtcclxuICAgICAgICBsZXQgY21wTGlnaHRzOiBDb21wb25lbnRMaWdodFtdID0gX2xpZ2h0cy5nZXQoTGlnaHRBbWJpZW50KTtcclxuICAgICAgICBpZiAoY21wTGlnaHRzKSB7XHJcbiAgICAgICAgICAvLyBUT0RPOiBhZGQgdXAgYW1iaWVudCBsaWdodHMgdG8gYSBzaW5nbGUgY29sb3JcclxuICAgICAgICAgIGxldCByZXN1bHQ6IENvbG9yID0gbmV3IENvbG9yKDAsIDAsIDAsIDEpO1xyXG4gICAgICAgICAgZm9yIChsZXQgY21wTGlnaHQgb2YgY21wTGlnaHRzKVxyXG4gICAgICAgICAgICByZXN1bHQuYWRkKGNtcExpZ2h0LmxpZ2h0LmNvbG9yKTtcclxuICAgICAgICAgIFJlbmRlck9wZXJhdG9yLmNyYzMudW5pZm9ybTRmdihhbWJpZW50LCByZXN1bHQuZ2V0QXJyYXkoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgbkRpcmVjdGlvbmFsOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiA9IHVuaVtcInVfbkxpZ2h0c0RpcmVjdGlvbmFsXCJdO1xyXG4gICAgICBpZiAobkRpcmVjdGlvbmFsKSB7XHJcbiAgICAgICAgbGV0IGNtcExpZ2h0czogQ29tcG9uZW50TGlnaHRbXSA9IF9saWdodHMuZ2V0KExpZ2h0RGlyZWN0aW9uYWwpO1xyXG4gICAgICAgIGlmIChjbXBMaWdodHMpIHtcclxuICAgICAgICAgIGxldCBuOiBudW1iZXIgPSBjbXBMaWdodHMubGVuZ3RoO1xyXG4gICAgICAgICAgUmVuZGVyT3BlcmF0b3IuY3JjMy51bmlmb3JtMXVpKG5EaXJlY3Rpb25hbCwgbik7XHJcbiAgICAgICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBjbXBMaWdodDogQ29tcG9uZW50TGlnaHQgPSBjbXBMaWdodHNbaV07XHJcbiAgICAgICAgICAgIFJlbmRlck9wZXJhdG9yLmNyYzMudW5pZm9ybTRmdih1bmlbYHVfZGlyZWN0aW9uYWxbJHtpfV0uY29sb3JgXSwgY21wTGlnaHQubGlnaHQuY29sb3IuZ2V0QXJyYXkoKSk7XHJcbiAgICAgICAgICAgIGxldCBkaXJlY3Rpb246IFZlY3RvcjMgPSBWZWN0b3IzLlooKTtcclxuICAgICAgICAgICAgZGlyZWN0aW9uLnRyYW5zZm9ybShjbXBMaWdodC5waXZvdCk7XHJcbiAgICAgICAgICAgIGRpcmVjdGlvbi50cmFuc2Zvcm0oY21wTGlnaHQuZ2V0Q29udGFpbmVyKCkubXR4V29ybGQpO1xyXG4gICAgICAgICAgICBSZW5kZXJPcGVyYXRvci5jcmMzLnVuaWZvcm0zZnYodW5pW2B1X2RpcmVjdGlvbmFsWyR7aX1dLmRpcmVjdGlvbmBdLCBkaXJlY3Rpb24uZ2V0KCkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAvLyBkZWJ1Z2dlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXcgYSBtZXNoIGJ1ZmZlciB1c2luZyB0aGUgZ2l2ZW4gaW5mb3MgYW5kIHRoZSBjb21wbGV0ZSBwcm9qZWN0aW9uIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGRyYXcoX3JlbmRlclNoYWRlcjogUmVuZGVyU2hhZGVyLCBfbWVzaDogTWVzaCwgX2NvYXQ6IENvYXQsIF93b3JsZDogTWF0cml4NHg0LCBfcHJvamVjdGlvbjogTWF0cml4NHg0KTogdm9pZCB7XHJcbiAgICAgIFJlbmRlck9wZXJhdG9yLnVzZVByb2dyYW0oX3JlbmRlclNoYWRlcik7XHJcbiAgICAgIF9tZXNoLnVzZVJlbmRlckJ1ZmZlcnMoX3JlbmRlclNoYWRlciwgX3dvcmxkLCBfcHJvamVjdGlvbik7XHJcbiAgICAgIF9jb2F0LnVzZVJlbmRlckRhdGEoX3JlbmRlclNoYWRlcik7XHJcbiAgICAgIFJlbmRlck9wZXJhdG9yLmNyYzMuZHJhd0VsZW1lbnRzKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVFJJQU5HTEVTLCBfbWVzaC5yZW5kZXJCdWZmZXJzLm5JbmRpY2VzLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOU0lHTkVEX1NIT1JULCAwKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAjcmVnaW9uIFNoYWRlcnByb2dyYW0gXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGNyZWF0ZVByb2dyYW0oX3NoYWRlckNsYXNzOiB0eXBlb2YgU2hhZGVyKTogUmVuZGVyU2hhZGVyIHtcclxuICAgICAgbGV0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJPcGVyYXRvci5jcmMzO1xyXG4gICAgICBsZXQgcHJvZ3JhbTogV2ViR0xQcm9ncmFtID0gY3JjMy5jcmVhdGVQcm9ncmFtKCk7XHJcbiAgICAgIGxldCByZW5kZXJTaGFkZXI6IFJlbmRlclNoYWRlcjtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjcmMzLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBSZW5kZXJPcGVyYXRvci5hc3NlcnQ8V2ViR0xTaGFkZXI+KGNvbXBpbGVTaGFkZXIoX3NoYWRlckNsYXNzLmdldFZlcnRleFNoYWRlclNvdXJjZSgpLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlZFUlRFWF9TSEFERVIpKSk7XHJcbiAgICAgICAgY3JjMy5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgUmVuZGVyT3BlcmF0b3IuYXNzZXJ0PFdlYkdMU2hhZGVyPihjb21waWxlU2hhZGVyKF9zaGFkZXJDbGFzcy5nZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZSQUdNRU5UX1NIQURFUikpKTtcclxuICAgICAgICBjcmMzLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xyXG4gICAgICAgIGxldCBlcnJvcjogc3RyaW5nID0gUmVuZGVyT3BlcmF0b3IuYXNzZXJ0PHN0cmluZz4oY3JjMy5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSk7XHJcbiAgICAgICAgaWYgKGVycm9yICE9PSBcIlwiKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBsaW5raW5nIFNoYWRlcjogXCIgKyBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbmRlclNoYWRlciA9IHtcclxuICAgICAgICAgIHByb2dyYW06IHByb2dyYW0sXHJcbiAgICAgICAgICBhdHRyaWJ1dGVzOiBkZXRlY3RBdHRyaWJ1dGVzKCksXHJcbiAgICAgICAgICB1bmlmb3JtczogZGV0ZWN0VW5pZm9ybXMoKVxyXG4gICAgICAgIH07XHJcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xyXG4gICAgICAgIERlYnVnLmVycm9yKF9lcnJvcik7XHJcbiAgICAgICAgZGVidWdnZXI7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlbmRlclNoYWRlcjtcclxuXHJcblxyXG4gICAgICBmdW5jdGlvbiBjb21waWxlU2hhZGVyKF9zaGFkZXJDb2RlOiBzdHJpbmcsIF9zaGFkZXJUeXBlOiBHTGVudW0pOiBXZWJHTFNoYWRlciB8IG51bGwge1xyXG4gICAgICAgIGxldCB3ZWJHTFNoYWRlcjogV2ViR0xTaGFkZXIgPSBjcmMzLmNyZWF0ZVNoYWRlcihfc2hhZGVyVHlwZSk7XHJcbiAgICAgICAgY3JjMy5zaGFkZXJTb3VyY2Uod2ViR0xTaGFkZXIsIF9zaGFkZXJDb2RlKTtcclxuICAgICAgICBjcmMzLmNvbXBpbGVTaGFkZXIod2ViR0xTaGFkZXIpO1xyXG4gICAgICAgIGxldCBlcnJvcjogc3RyaW5nID0gUmVuZGVyT3BlcmF0b3IuYXNzZXJ0PHN0cmluZz4oY3JjMy5nZXRTaGFkZXJJbmZvTG9nKHdlYkdMU2hhZGVyKSk7XHJcbiAgICAgICAgaWYgKGVycm9yICE9PSBcIlwiKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBjb21waWxpbmcgc2hhZGVyOiBcIiArIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGFueSBjb21waWxhdGlvbiBlcnJvcnMuXHJcbiAgICAgICAgaWYgKCFjcmMzLmdldFNoYWRlclBhcmFtZXRlcih3ZWJHTFNoYWRlciwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5DT01QSUxFX1NUQVRVUykpIHtcclxuICAgICAgICAgIGFsZXJ0KGNyYzMuZ2V0U2hhZGVySW5mb0xvZyh3ZWJHTFNoYWRlcikpO1xyXG4gICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB3ZWJHTFNoYWRlcjtcclxuICAgICAgfVxyXG4gICAgICBmdW5jdGlvbiBkZXRlY3RBdHRyaWJ1dGVzKCk6IHsgW25hbWU6IHN0cmluZ106IG51bWJlciB9IHtcclxuICAgICAgICBsZXQgZGV0ZWN0ZWRBdHRyaWJ1dGVzOiB7IFtuYW1lOiBzdHJpbmddOiBudW1iZXIgfSA9IHt9O1xyXG4gICAgICAgIGxldCBhdHRyaWJ1dGVDb3VudDogbnVtYmVyID0gY3JjMy5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQUNUSVZFX0FUVFJJQlVURVMpO1xyXG4gICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBhdHRyaWJ1dGVDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICBsZXQgYXR0cmlidXRlSW5mbzogV2ViR0xBY3RpdmVJbmZvID0gUmVuZGVyT3BlcmF0b3IuYXNzZXJ0PFdlYkdMQWN0aXZlSW5mbz4oY3JjMy5nZXRBY3RpdmVBdHRyaWIocHJvZ3JhbSwgaSkpO1xyXG4gICAgICAgICAgaWYgKCFhdHRyaWJ1dGVJbmZvKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZGV0ZWN0ZWRBdHRyaWJ1dGVzW2F0dHJpYnV0ZUluZm8ubmFtZV0gPSBjcmMzLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIGF0dHJpYnV0ZUluZm8ubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZXRlY3RlZEF0dHJpYnV0ZXM7XHJcbiAgICAgIH1cclxuICAgICAgZnVuY3Rpb24gZGV0ZWN0VW5pZm9ybXMoKTogeyBbbmFtZTogc3RyaW5nXTogV2ViR0xVbmlmb3JtTG9jYXRpb24gfSB7XHJcbiAgICAgICAgbGV0IGRldGVjdGVkVW5pZm9ybXM6IHsgW25hbWU6IHN0cmluZ106IFdlYkdMVW5pZm9ybUxvY2F0aW9uIH0gPSB7fTtcclxuICAgICAgICBsZXQgdW5pZm9ybUNvdW50OiBudW1iZXIgPSBjcmMzLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BQ1RJVkVfVU5JRk9STVMpO1xyXG4gICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB1bmlmb3JtQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgbGV0IGluZm86IFdlYkdMQWN0aXZlSW5mbyA9IFJlbmRlck9wZXJhdG9yLmFzc2VydDxXZWJHTEFjdGl2ZUluZm8+KGNyYzMuZ2V0QWN0aXZlVW5pZm9ybShwcm9ncmFtLCBpKSk7XHJcbiAgICAgICAgICBpZiAoIWluZm8pIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBkZXRlY3RlZFVuaWZvcm1zW2luZm8ubmFtZV0gPSBSZW5kZXJPcGVyYXRvci5hc3NlcnQ8V2ViR0xVbmlmb3JtTG9jYXRpb24+KGNyYzMuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIGluZm8ubmFtZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGV0ZWN0ZWRVbmlmb3JtcztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyB1c2VQcm9ncmFtKF9zaGFkZXJJbmZvOiBSZW5kZXJTaGFkZXIpOiB2b2lkIHtcclxuICAgICAgUmVuZGVyT3BlcmF0b3IuY3JjMy51c2VQcm9ncmFtKF9zaGFkZXJJbmZvLnByb2dyYW0pO1xyXG4gICAgICBSZW5kZXJPcGVyYXRvci5jcmMzLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KF9zaGFkZXJJbmZvLmF0dHJpYnV0ZXNbXCJhX3Bvc2l0aW9uXCJdKTtcclxuICAgIH1cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgZGVsZXRlUHJvZ3JhbShfcHJvZ3JhbTogUmVuZGVyU2hhZGVyKTogdm9pZCB7XHJcbiAgICAgIGlmIChfcHJvZ3JhbSkge1xyXG4gICAgICAgIFJlbmRlck9wZXJhdG9yLmNyYzMuZGVsZXRlUHJvZ3JhbShfcHJvZ3JhbS5wcm9ncmFtKTtcclxuICAgICAgICBkZWxldGUgX3Byb2dyYW0uYXR0cmlidXRlcztcclxuICAgICAgICBkZWxldGUgX3Byb2dyYW0udW5pZm9ybXM7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vICNlbmRyZWdpb25cclxuXHJcbiAgICAvLyAjcmVnaW9uIE1lc2hidWZmZXJcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgY3JlYXRlQnVmZmVycyhfbWVzaDogTWVzaCk6IFJlbmRlckJ1ZmZlcnMge1xyXG4gICAgICBsZXQgdmVydGljZXM6IFdlYkdMQnVmZmVyID0gUmVuZGVyT3BlcmF0b3IuYXNzZXJ0PFdlYkdMQnVmZmVyPihSZW5kZXJPcGVyYXRvci5jcmMzLmNyZWF0ZUJ1ZmZlcigpKTtcclxuICAgICAgUmVuZGVyT3BlcmF0b3IuY3JjMy5iaW5kQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQVJSQVlfQlVGRkVSLCB2ZXJ0aWNlcyk7XHJcbiAgICAgIFJlbmRlck9wZXJhdG9yLmNyYzMuYnVmZmVyRGF0YShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgX21lc2gudmVydGljZXMsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuU1RBVElDX0RSQVcpO1xyXG5cclxuICAgICAgbGV0IGluZGljZXM6IFdlYkdMQnVmZmVyID0gUmVuZGVyT3BlcmF0b3IuYXNzZXJ0PFdlYkdMQnVmZmVyPihSZW5kZXJPcGVyYXRvci5jcmMzLmNyZWF0ZUJ1ZmZlcigpKTtcclxuICAgICAgUmVuZGVyT3BlcmF0b3IuY3JjMy5iaW5kQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGluZGljZXMpO1xyXG4gICAgICBSZW5kZXJPcGVyYXRvci5jcmMzLmJ1ZmZlckRhdGEoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgX21lc2guaW5kaWNlcywgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5TVEFUSUNfRFJBVyk7XHJcblxyXG4gICAgICBsZXQgdGV4dHVyZVVWczogV2ViR0xCdWZmZXIgPSBSZW5kZXJPcGVyYXRvci5jcmMzLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAgICBSZW5kZXJPcGVyYXRvci5jcmMzLmJpbmRCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BUlJBWV9CVUZGRVIsIHRleHR1cmVVVnMpO1xyXG4gICAgICBSZW5kZXJPcGVyYXRvci5jcmMzLmJ1ZmZlckRhdGEoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BUlJBWV9CVUZGRVIsIF9tZXNoLnRleHR1cmVVVnMsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuU1RBVElDX0RSQVcpO1xyXG5cclxuICAgICAgbGV0IG5vcm1hbHNGYWNlOiBXZWJHTEJ1ZmZlciA9IFJlbmRlck9wZXJhdG9yLmFzc2VydDxXZWJHTEJ1ZmZlcj4oUmVuZGVyT3BlcmF0b3IuY3JjMy5jcmVhdGVCdWZmZXIoKSk7XHJcbiAgICAgIFJlbmRlck9wZXJhdG9yLmNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgbm9ybWFsc0ZhY2UpO1xyXG4gICAgICBSZW5kZXJPcGVyYXRvci5jcmMzLmJ1ZmZlckRhdGEoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BUlJBWV9CVUZGRVIsIF9tZXNoLm5vcm1hbHNGYWNlLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlNUQVRJQ19EUkFXKTtcclxuXHJcbiAgICAgIGxldCBidWZmZXJJbmZvOiBSZW5kZXJCdWZmZXJzID0ge1xyXG4gICAgICAgIHZlcnRpY2VzOiB2ZXJ0aWNlcyxcclxuICAgICAgICBpbmRpY2VzOiBpbmRpY2VzLFxyXG4gICAgICAgIG5JbmRpY2VzOiBfbWVzaC5nZXRJbmRleENvdW50KCksXHJcbiAgICAgICAgdGV4dHVyZVVWczogdGV4dHVyZVVWcyxcclxuICAgICAgICBub3JtYWxzRmFjZTogbm9ybWFsc0ZhY2VcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIGJ1ZmZlckluZm87XHJcbiAgICB9XHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHVzZUJ1ZmZlcnMoX3JlbmRlckJ1ZmZlcnM6IFJlbmRlckJ1ZmZlcnMpOiB2b2lkIHtcclxuICAgICAgLy8gVE9ETzogY3VycmVudGx5IHVudXNlZCwgZG9uZSBzcGVjaWZpY2FsbHkgaW4gZHJhdy4gQ291bGQgYmUgc2F2ZWQgaW4gVkFPIHdpdGhpbiBSZW5kZXJCdWZmZXJzXHJcbiAgICAgIC8vIFJlbmRlck9wZXJhdG9yLmNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgX3JlbmRlckJ1ZmZlcnMudmVydGljZXMpO1xyXG4gICAgICAvLyBSZW5kZXJPcGVyYXRvci5jcmMzLmJpbmRCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgX3JlbmRlckJ1ZmZlcnMuaW5kaWNlcyk7XHJcbiAgICAgIC8vIFJlbmRlck9wZXJhdG9yLmNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgX3JlbmRlckJ1ZmZlcnMudGV4dHVyZVVWcyk7XHJcblxyXG4gICAgfVxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBkZWxldGVCdWZmZXJzKF9yZW5kZXJCdWZmZXJzOiBSZW5kZXJCdWZmZXJzKTogdm9pZCB7XHJcbiAgICAgIGlmIChfcmVuZGVyQnVmZmVycykge1xyXG4gICAgICAgIFJlbmRlck9wZXJhdG9yLmNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgbnVsbCk7XHJcbiAgICAgICAgUmVuZGVyT3BlcmF0b3IuY3JjMy5kZWxldGVCdWZmZXIoX3JlbmRlckJ1ZmZlcnMudmVydGljZXMpO1xyXG4gICAgICAgIFJlbmRlck9wZXJhdG9yLmNyYzMuZGVsZXRlQnVmZmVyKF9yZW5kZXJCdWZmZXJzLnRleHR1cmVVVnMpO1xyXG4gICAgICAgIFJlbmRlck9wZXJhdG9yLmNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBudWxsKTtcclxuICAgICAgICBSZW5kZXJPcGVyYXRvci5jcmMzLmRlbGV0ZUJ1ZmZlcihfcmVuZGVyQnVmZmVycy5pbmRpY2VzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vICNyZWdpb24gTWF0ZXJpYWxQYXJhbWV0ZXJzXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGNyZWF0ZVBhcmFtZXRlcihfY29hdDogQ29hdCk6IFJlbmRlckNvYXQge1xyXG4gICAgICAvLyBsZXQgdmFvOiBXZWJHTFZlcnRleEFycmF5T2JqZWN0ID0gUmVuZGVyT3BlcmF0b3IuYXNzZXJ0PFdlYkdMVmVydGV4QXJyYXlPYmplY3Q+KFJlbmRlck9wZXJhdG9yLmNyYzMuY3JlYXRlVmVydGV4QXJyYXkoKSk7XHJcbiAgICAgIGxldCBjb2F0SW5mbzogUmVuZGVyQ29hdCA9IHtcclxuICAgICAgICAvL3ZhbzogbnVsbCxcclxuICAgICAgICBjb2F0OiBfY29hdFxyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gY29hdEluZm87XHJcbiAgICB9XHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHVzZVBhcmFtZXRlcihfY29hdEluZm86IFJlbmRlckNvYXQpOiB2b2lkIHtcclxuICAgICAgLy8gUmVuZGVyT3BlcmF0b3IuY3JjMy5iaW5kVmVydGV4QXJyYXkoX2NvYXRJbmZvLnZhbyk7XHJcbiAgICB9XHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGRlbGV0ZVBhcmFtZXRlcihfY29hdEluZm86IFJlbmRlckNvYXQpOiB2b2lkIHtcclxuICAgICAgaWYgKF9jb2F0SW5mbykge1xyXG4gICAgICAgIFJlbmRlck9wZXJhdG9yLmNyYzMuYmluZFZlcnRleEFycmF5KG51bGwpO1xyXG4gICAgICAgIC8vIFJlbmRlck9wZXJhdG9yLmNyYzMuZGVsZXRlVmVydGV4QXJyYXkoX2NvYXRJbmZvLnZhbyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vICNlbmRyZWdpb25cclxuICB9XHJcbn0iLCIvLy8gPHJlZmVyZW5jZSBwYXRoPVwiRGVidWcvRGVidWdUYXJnZXQudHNcIi8+XHJcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJFdmVudC9FdmVudC50c1wiLz5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlRyYW5zZmVyL011dGFibGUudHNcIi8+ICBcclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlRyYW5zZmVyL1NlcmlhbGl6ZXIudHNcIi8+IFxyXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiUmVuZGVyL1JlbmRlck9wZXJhdG9yLnRzXCIvPlxyXG4iLCIvLyAvIDxyZWZlcmVuY2UgcGF0aD1cIi4uL1RyYW5zZmVyL011dGFibGUudHNcIi8+XHJcblxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBIb2xkcyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgQW5pbWF0aW9uU3RydWN0dXJlIHRoYXQgdGhlIEFuaW1hdGlvbiB1c2VzIHRvIG1hcCB0aGUgU2VxdWVuY2VzIHRvIHRoZSBBdHRyaWJ1dGVzLlxyXG4gICAqIEJ1aWx0IG91dCBvZiBhIFtbTm9kZV1dJ3Mgc2VyaWFsc2F0aW9uLCBpdCBzd2FwcyB0aGUgdmFsdWVzIHdpdGggW1tBbmltYXRpb25TZXF1ZW5jZV1dcy5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIEFuaW1hdGlvblN0cnVjdHVyZSB7XHJcbiAgICBbYXR0cmlidXRlOiBzdHJpbmddOiBTZXJpYWxpemF0aW9uIHwgQW5pbWF0aW9uU2VxdWVuY2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAqIEFuIGFzc29jaWF0aXZlIGFycmF5IG1hcHBpbmcgbmFtZXMgb2YgbGFibGVzIHRvIHRpbWVzdGFtcHMuXHJcbiAgKiBMYWJlbHMgbmVlZCB0byBiZSB1bmlxdWUgcGVyIEFuaW1hdGlvbi5cclxuICAqIEBhdXRob3IgTHVrYXMgU2NoZXVlcmxlLCBIRlUsIDIwMTlcclxuICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgQW5pbWF0aW9uTGFiZWwge1xyXG4gICAgW25hbWU6IHN0cmluZ106IG51bWJlcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICogSG9sZHMgaW5mb3JtYXRpb24gYWJvdXQgQW5pbWF0aW9uIEV2ZW50IFRyaWdnZXJzXHJcbiAgKiBAYXV0aG9yIEx1a2FzIFNjaGV1ZXJsZSwgSEZVLCAyMDE5XHJcbiAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIEFuaW1hdGlvbkV2ZW50VHJpZ2dlciB7XHJcbiAgICBbbmFtZTogc3RyaW5nXTogbnVtYmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW50ZXJuYWxseSB1c2VkIHRvIGRpZmZlcmVudGlhdGUgYmV0d2VlbiB0aGUgdmFyaW91cyBnZW5lcmF0ZWQgc3RydWN0dXJlcyBhbmQgZXZlbnRzLlxyXG4gICAqIEBhdXRob3IgTHVrYXMgU2NoZXVlcmxlLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBlbnVtIEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRSB7XHJcbiAgICAvKipEZWZhdWx0OiBmb3J3YXJkLCBjb250aW5vdXMgKi9cclxuICAgIE5PUk1BTCxcclxuICAgIC8qKmJhY2t3YXJkLCBjb250aW5vdXMgKi9cclxuICAgIFJFVkVSU0UsXHJcbiAgICAvKipmb3J3YXJkLCByYXN0ZXJlZCAqL1xyXG4gICAgUkFTVEVSRUQsXHJcbiAgICAvKipiYWNrd2FyZCwgcmFzdGVyZWQgKi9cclxuICAgIFJBU1RFUkVEUkVWRVJTRVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQW5pbWF0aW9uIENsYXNzIHRvIGhvbGQgYWxsIHJlcXVpcmVkIE9iamVjdHMgdGhhdCBhcmUgcGFydCBvZiBhbiBBbmltYXRpb24uXHJcbiAgICogQWxzbyBob2xkcyBmdW5jdGlvbnMgdG8gcGxheSBzYWlkIEFuaW1hdGlvbi5cclxuICAgKiBDYW4gYmUgYWRkZWQgdG8gYSBOb2RlIGFuZCBwbGF5ZWQgdGhyb3VnaCBbW0NvbXBvbmVudEFuaW1hdG9yXV0uXHJcbiAgICogQGF1dGhvciBMdWthcyBTY2hldWVybGUsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBBbmltYXRpb24gZXh0ZW5kcyBNdXRhYmxlIGltcGxlbWVudHMgU2VyaWFsaXphYmxlUmVzb3VyY2Uge1xyXG4gICAgaWRSZXNvdXJjZTogc3RyaW5nO1xyXG4gICAgbmFtZTogc3RyaW5nO1xyXG4gICAgdG90YWxUaW1lOiBudW1iZXIgPSAwO1xyXG4gICAgbGFiZWxzOiBBbmltYXRpb25MYWJlbCA9IHt9O1xyXG4gICAgc3RlcHNQZXJTZWNvbmQ6IG51bWJlciA9IDEwO1xyXG4gICAgYW5pbWF0aW9uU3RydWN0dXJlOiBBbmltYXRpb25TdHJ1Y3R1cmU7XHJcbiAgICBldmVudHM6IEFuaW1hdGlvbkV2ZW50VHJpZ2dlciA9IHt9O1xyXG4gICAgcHJpdmF0ZSBmcmFtZXNQZXJTZWNvbmQ6IG51bWJlciA9IDYwO1xyXG5cclxuICAgIC8vIHByb2Nlc3NlZCBldmVudGxpc3QgYW5kIGFuaW1hdGlvbiBzdHJ1Y3V0cmVzIGZvciBwbGF5YmFjay5cclxuICAgIHByaXZhdGUgZXZlbnRzUHJvY2Vzc2VkOiBNYXA8QU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLCBBbmltYXRpb25FdmVudFRyaWdnZXI+ID0gbmV3IE1hcDxBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUsIEFuaW1hdGlvbkV2ZW50VHJpZ2dlcj4oKTtcclxuICAgIHByaXZhdGUgYW5pbWF0aW9uU3RydWN0dXJlc1Byb2Nlc3NlZDogTWFwPEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRSwgQW5pbWF0aW9uU3RydWN0dXJlPiA9IG5ldyBNYXA8QU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLCBBbmltYXRpb25TdHJ1Y3R1cmU+KCk7XHJcblxyXG4gICAgY29uc3RydWN0b3IoX25hbWU6IHN0cmluZywgX2FuaW1TdHJ1Y3R1cmU6IEFuaW1hdGlvblN0cnVjdHVyZSA9IHt9LCBfZnBzOiBudW1iZXIgPSA2MCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLm5hbWUgPSBfbmFtZTtcclxuICAgICAgdGhpcy5hbmltYXRpb25TdHJ1Y3R1cmUgPSBfYW5pbVN0cnVjdHVyZTtcclxuICAgICAgdGhpcy5hbmltYXRpb25TdHJ1Y3R1cmVzUHJvY2Vzc2VkLnNldChBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuTk9STUFMLCBfYW5pbVN0cnVjdHVyZSk7XHJcbiAgICAgIHRoaXMuZnJhbWVzUGVyU2Vjb25kID0gX2ZwcztcclxuICAgICAgdGhpcy5jYWxjdWxhdGVUb3RhbFRpbWUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBhIG5ldyBcIk11dGF0b3JcIiB3aXRoIHRoZSBpbmZvcm1hdGlvbiB0byBhcHBseSB0byB0aGUgW1tOb2RlXV0gdGhlIFtbQ29tcG9uZW50QW5pbWF0b3JdXSBpcyBhdHRhY2hlZCB0byB3aXRoIFtbTm9kZS5hcHBseUFuaW1hdGlvbigpXV0uXHJcbiAgICAgKiBAcGFyYW0gX3RpbWUgVGhlIHRpbWUgYXQgd2hpY2ggdGhlIGFuaW1hdGlvbiBjdXJyZW50bHkgaXMgYXRcclxuICAgICAqIEBwYXJhbSBfZGlyZWN0aW9uIFRoZSBkaXJlY3Rpb24gaW4gd2hpY2ggdGhlIGFuaW1hdGlvbiBpcyBzdXBwb3NlZCB0byBiZSBwbGF5aW5nIGJhY2suID4wID09IGZvcndhcmQsIDAgPT0gc3RvcCwgPDAgPT0gYmFja3dhcmRzXHJcbiAgICAgKiBAcGFyYW0gX3BsYXliYWNrIFRoZSBwbGF5YmFja21vZGUgdGhlIGFuaW1hdGlvbiBpcyBzdXBwb3NlZCB0byBiZSBjYWxjdWxhdGVkIHdpdGguXHJcbiAgICAgKiBAcmV0dXJucyBhIFwiTXV0YXRvclwiIHRvIGFwcGx5LlxyXG4gICAgICovXHJcbiAgICBnZXRNdXRhdGVkKF90aW1lOiBudW1iZXIsIF9kaXJlY3Rpb246IG51bWJlciwgX3BsYXliYWNrOiBBTklNQVRJT05fUExBWUJBQ0spOiBNdXRhdG9yIHsgICAgIC8vVE9ETzogZmluZCBhIGJldHRlciBuYW1lIGZvciB0aGlzXHJcbiAgICAgIGxldCBtOiBNdXRhdG9yID0ge307XHJcbiAgICAgIGlmIChfcGxheWJhY2sgPT0gQU5JTUFUSU9OX1BMQVlCQUNLLlRJTUVCQVNFRF9DT05USU5PVVMpIHtcclxuICAgICAgICBpZiAoX2RpcmVjdGlvbiA+PSAwKSB7XHJcbiAgICAgICAgICBtID0gdGhpcy50cmF2ZXJzZVN0cnVjdHVyZUZvck11dGF0b3IodGhpcy5nZXRQcm9jZXNzZWRBbmltYXRpb25TdHJ1Y3R1cmUoQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLk5PUk1BTCksIF90aW1lKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbSA9IHRoaXMudHJhdmVyc2VTdHJ1Y3R1cmVGb3JNdXRhdG9yKHRoaXMuZ2V0UHJvY2Vzc2VkQW5pbWF0aW9uU3RydWN0dXJlKEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5SRVZFUlNFKSwgX3RpbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoX2RpcmVjdGlvbiA+PSAwKSB7XHJcbiAgICAgICAgICBtID0gdGhpcy50cmF2ZXJzZVN0cnVjdHVyZUZvck11dGF0b3IodGhpcy5nZXRQcm9jZXNzZWRBbmltYXRpb25TdHJ1Y3R1cmUoQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlJBU1RFUkVEKSwgX3RpbWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBtID0gdGhpcy50cmF2ZXJzZVN0cnVjdHVyZUZvck11dGF0b3IodGhpcy5nZXRQcm9jZXNzZWRBbmltYXRpb25TdHJ1Y3R1cmUoQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlJBU1RFUkVEUkVWRVJTRSksIF90aW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBtO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgdGhlIG5hbWVzIG9mIHRoZSBldmVudHMgdGhlIFtbQ29tcG9uZW50QW5pbWF0b3JdXSBuZWVkcyB0byBmaXJlIGJldHdlZW4gX21pbiBhbmQgX21heC4gXHJcbiAgICAgKiBAcGFyYW0gX21pbiBUaGUgbWluaW11bSB0aW1lIChpbmNsdXNpdmUpIHRvIGNoZWNrIGJldHdlZW5cclxuICAgICAqIEBwYXJhbSBfbWF4IFRoZSBtYXhpbXVtIHRpbWUgKGV4Y2x1c2l2ZSkgdG8gY2hlY2sgYmV0d2VlblxyXG4gICAgICogQHBhcmFtIF9wbGF5YmFjayBUaGUgcGxheWJhY2sgbW9kZSB0byBjaGVjayBpbi4gSGFzIGFuIGVmZmVjdCBvbiB3aGVuIHRoZSBFdmVudHMgYXJlIGZpcmVkLiBcclxuICAgICAqIEBwYXJhbSBfZGlyZWN0aW9uIFRoZSBkaXJlY3Rpb24gdGhlIGFuaW1hdGlvbiBpcyBzdXBwb3NlZCB0byBydW4gaW4uID4wID09IGZvcndhcmQsIDAgPT0gc3RvcCwgPDAgPT0gYmFja3dhcmRzXHJcbiAgICAgKiBAcmV0dXJucyBhIGxpc3Qgb2Ygc3RyaW5ncyB3aXRoIHRoZSBuYW1lcyBvZiB0aGUgY3VzdG9tIGV2ZW50cyB0byBmaXJlLlxyXG4gICAgICovXHJcbiAgICBnZXRFdmVudHNUb0ZpcmUoX21pbjogbnVtYmVyLCBfbWF4OiBudW1iZXIsIF9wbGF5YmFjazogQU5JTUFUSU9OX1BMQVlCQUNLLCBfZGlyZWN0aW9uOiBudW1iZXIpOiBzdHJpbmdbXSB7XHJcbiAgICAgIGxldCBldmVudExpc3Q6IHN0cmluZ1tdID0gW107XHJcbiAgICAgIGxldCBtaW5TZWN0aW9uOiBudW1iZXIgPSBNYXRoLmZsb29yKF9taW4gLyB0aGlzLnRvdGFsVGltZSk7XHJcbiAgICAgIGxldCBtYXhTZWN0aW9uOiBudW1iZXIgPSBNYXRoLmZsb29yKF9tYXggLyB0aGlzLnRvdGFsVGltZSk7XHJcbiAgICAgIF9taW4gPSBfbWluICUgdGhpcy50b3RhbFRpbWU7XHJcbiAgICAgIF9tYXggPSBfbWF4ICUgdGhpcy50b3RhbFRpbWU7XHJcblxyXG4gICAgICB3aGlsZSAobWluU2VjdGlvbiA8PSBtYXhTZWN0aW9uKSB7XHJcbiAgICAgICAgbGV0IGV2ZW50VHJpZ2dlcnM6IEFuaW1hdGlvbkV2ZW50VHJpZ2dlciA9IHRoaXMuZ2V0Q29ycmVjdEV2ZW50TGlzdChfZGlyZWN0aW9uLCBfcGxheWJhY2spO1xyXG4gICAgICAgIGlmIChtaW5TZWN0aW9uID09IG1heFNlY3Rpb24pIHtcclxuICAgICAgICAgIGV2ZW50TGlzdCA9IGV2ZW50TGlzdC5jb25jYXQodGhpcy5jaGVja0V2ZW50c0JldHdlZW4oZXZlbnRUcmlnZ2VycywgX21pbiwgX21heCkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBldmVudExpc3QgPSBldmVudExpc3QuY29uY2F0KHRoaXMuY2hlY2tFdmVudHNCZXR3ZWVuKGV2ZW50VHJpZ2dlcnMsIF9taW4sIHRoaXMudG90YWxUaW1lKSk7XHJcbiAgICAgICAgICBfbWluID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWluU2VjdGlvbisrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gZXZlbnRMaXN0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhbiBFdmVudCB0byB0aGUgTGlzdCBvZiBldmVudHMuXHJcbiAgICAgKiBAcGFyYW0gX25hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IChuZWVkcyB0byBiZSB1bmlxdWUgcGVyIEFuaW1hdGlvbikuXHJcbiAgICAgKiBAcGFyYW0gX3RpbWUgVGhlIHRpbWVzdGFtcCBvZiB0aGUgZXZlbnQgKGluIG1pbGxpc2Vjb25kcykuXHJcbiAgICAgKi9cclxuICAgIHNldEV2ZW50KF9uYW1lOiBzdHJpbmcsIF90aW1lOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy5ldmVudHNbX25hbWVdID0gX3RpbWU7XHJcbiAgICAgIHRoaXMuZXZlbnRzUHJvY2Vzc2VkLmNsZWFyKCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgZXZlbnQgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBmcm9tIHRoZSBsaXN0IG9mIGV2ZW50cy5cclxuICAgICAqIEBwYXJhbSBfbmFtZSBuYW1lIG9mIHRoZSBldmVudCB0byByZW1vdmUuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZUV2ZW50KF9uYW1lOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgZGVsZXRlIHRoaXMuZXZlbnRzW19uYW1lXTtcclxuICAgICAgdGhpcy5ldmVudHNQcm9jZXNzZWQuY2xlYXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgZ2V0TGFiZWxzKCk6IEVudW1lcmF0b3Ige1xyXG4gICAgICAvL1RPRE86IHRoaXMgYWN0dWFsbHkgbmVlZHMgdGVzdGluZ1xyXG4gICAgICBsZXQgZW46IEVudW1lcmF0b3IgPSBuZXcgRW51bWVyYXRvcih0aGlzLmxhYmVscyk7XHJcbiAgICAgIHJldHVybiBlbjtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgZnBzKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmZyYW1lc1BlclNlY29uZDtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgZnBzKF9mcHM6IG51bWJlcikge1xyXG4gICAgICB0aGlzLmZyYW1lc1BlclNlY29uZCA9IF9mcHM7XHJcbiAgICAgIHRoaXMuZXZlbnRzUHJvY2Vzc2VkLmNsZWFyKCk7XHJcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RydWN0dXJlc1Byb2Nlc3NlZC5jbGVhcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogKFJlLSlDYWxjdWxhdGUgdGhlIHRvdGFsIHRpbWUgb2YgdGhlIEFuaW1hdGlvbi4gQ2FsY3VsYXRpb24taGVhdnksIHVzZSBvbmx5IGlmIGFjdHVhbGx5IG5lZWRlZC5cclxuICAgICAqL1xyXG4gICAgY2FsY3VsYXRlVG90YWxUaW1lKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLnRvdGFsVGltZSA9IDA7XHJcbiAgICAgIHRoaXMudHJhdmVyc2VTdHJ1Y3R1cmVGb3JUaW1lKHRoaXMuYW5pbWF0aW9uU3RydWN0dXJlKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gdHJhbnNmZXJcclxuICAgIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHM6IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgaWRSZXNvdXJjZTogdGhpcy5pZFJlc291cmNlLFxyXG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICBsYWJlbHM6IHt9LFxyXG4gICAgICAgIGV2ZW50czoge30sXHJcbiAgICAgICAgZnBzOiB0aGlzLmZyYW1lc1BlclNlY29uZCxcclxuICAgICAgICBzcHM6IHRoaXMuc3RlcHNQZXJTZWNvbmRcclxuICAgICAgfTtcclxuICAgICAgZm9yIChsZXQgbmFtZSBpbiB0aGlzLmxhYmVscykge1xyXG4gICAgICAgIHMubGFiZWxzW25hbWVdID0gdGhpcy5sYWJlbHNbbmFtZV07XHJcbiAgICAgIH1cclxuICAgICAgZm9yIChsZXQgbmFtZSBpbiB0aGlzLmV2ZW50cykge1xyXG4gICAgICAgIHMuZXZlbnRzW25hbWVdID0gdGhpcy5ldmVudHNbbmFtZV07XHJcbiAgICAgIH1cclxuICAgICAgcy5hbmltYXRpb25TdHJ1Y3R1cmUgPSB0aGlzLnRyYXZlcnNlU3RydWN0dXJlRm9yU2VyaWFsaXNhdGlvbih0aGlzLmFuaW1hdGlvblN0cnVjdHVyZSk7XHJcbiAgICAgIHJldHVybiBzO1xyXG4gICAgfVxyXG4gICAgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBTZXJpYWxpemFibGUge1xyXG4gICAgICB0aGlzLmlkUmVzb3VyY2UgPSBfc2VyaWFsaXphdGlvbi5pZFJlc291cmNlO1xyXG4gICAgICB0aGlzLm5hbWUgPSBfc2VyaWFsaXphdGlvbi5uYW1lO1xyXG4gICAgICB0aGlzLmZyYW1lc1BlclNlY29uZCA9IF9zZXJpYWxpemF0aW9uLmZwcztcclxuICAgICAgdGhpcy5zdGVwc1BlclNlY29uZCA9IF9zZXJpYWxpemF0aW9uLnNwcztcclxuICAgICAgdGhpcy5sYWJlbHMgPSB7fTtcclxuICAgICAgZm9yIChsZXQgbmFtZSBpbiBfc2VyaWFsaXphdGlvbi5sYWJlbHMpIHtcclxuICAgICAgICB0aGlzLmxhYmVsc1tuYW1lXSA9IF9zZXJpYWxpemF0aW9uLmxhYmVsc1tuYW1lXTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmV2ZW50cyA9IHt9O1xyXG4gICAgICBmb3IgKGxldCBuYW1lIGluIF9zZXJpYWxpemF0aW9uLmV2ZW50cykge1xyXG4gICAgICAgIHRoaXMuZXZlbnRzW25hbWVdID0gX3NlcmlhbGl6YXRpb24uZXZlbnRzW25hbWVdO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuZXZlbnRzUHJvY2Vzc2VkID0gbmV3IE1hcDxBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUsIEFuaW1hdGlvbkV2ZW50VHJpZ2dlcj4oKTtcclxuXHJcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RydWN0dXJlID0gdGhpcy50cmF2ZXJzZVN0cnVjdHVyZUZvckRlc2VyaWFsaXNhdGlvbihfc2VyaWFsaXphdGlvbi5hbmltYXRpb25TdHJ1Y3R1cmUpO1xyXG5cclxuICAgICAgdGhpcy5hbmltYXRpb25TdHJ1Y3R1cmVzUHJvY2Vzc2VkID0gbmV3IE1hcDxBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUsIEFuaW1hdGlvblN0cnVjdHVyZT4oKTtcclxuXHJcbiAgICAgIHRoaXMuY2FsY3VsYXRlVG90YWxUaW1lKCk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZSgpO1xyXG4gICAgfVxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLnRvdGFsVGltZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJhdmVyc2VzIGFuIEFuaW1hdGlvblN0cnVjdHVyZSBhbmQgcmV0dXJucyB0aGUgU2VyaWFsaXphdGlvbiBvZiBzYWlkIFN0cnVjdHVyZS5cclxuICAgICAqIEBwYXJhbSBfc3RydWN0dXJlIFRoZSBBbmltYXRpb24gU3RydWN0dXJlIGF0IHRoZSBjdXJyZW50IGxldmVsIHRvIHRyYW5zZm9ybSBpbnRvIHRoZSBTZXJpYWxpemF0aW9uLlxyXG4gICAgICogQHJldHVybnMgdGhlIGZpbGxlZCBTZXJpYWxpemF0aW9uLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHRyYXZlcnNlU3RydWN0dXJlRm9yU2VyaWFsaXNhdGlvbihfc3RydWN0dXJlOiBBbmltYXRpb25TdHJ1Y3R1cmUpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IG5ld1NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7fTtcclxuICAgICAgZm9yIChsZXQgbiBpbiBfc3RydWN0dXJlKSB7XHJcbiAgICAgICAgaWYgKF9zdHJ1Y3R1cmVbbl0gaW5zdGFuY2VvZiBBbmltYXRpb25TZXF1ZW5jZSkge1xyXG4gICAgICAgICAgbmV3U2VyaWFsaXphdGlvbltuXSA9IF9zdHJ1Y3R1cmVbbl0uc2VyaWFsaXplKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG5ld1NlcmlhbGl6YXRpb25bbl0gPSB0aGlzLnRyYXZlcnNlU3RydWN0dXJlRm9yU2VyaWFsaXNhdGlvbig8QW5pbWF0aW9uU3RydWN0dXJlPl9zdHJ1Y3R1cmVbbl0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbmV3U2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJhdmVyc2VzIGEgU2VyaWFsaXphdGlvbiB0byBjcmVhdGUgYSBuZXcgQW5pbWF0aW9uU3RydWN0dXJlLlxyXG4gICAgICogQHBhcmFtIF9zZXJpYWxpemF0aW9uIFRoZSBzZXJpYWxpemF0aW9uIHRvIHRyYW5zZmVyIGludG8gYW4gQW5pbWF0aW9uU3RydWN0dXJlXHJcbiAgICAgKiBAcmV0dXJucyB0aGUgbmV3bHkgY3JlYXRlZCBBbmltYXRpb25TdHJ1Y3R1cmUuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdHJhdmVyc2VTdHJ1Y3R1cmVGb3JEZXNlcmlhbGlzYXRpb24oX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBBbmltYXRpb25TdHJ1Y3R1cmUge1xyXG4gICAgICBsZXQgbmV3U3RydWN0dXJlOiBBbmltYXRpb25TdHJ1Y3R1cmUgPSB7fTtcclxuICAgICAgZm9yIChsZXQgbiBpbiBfc2VyaWFsaXphdGlvbikge1xyXG4gICAgICAgIGlmIChfc2VyaWFsaXphdGlvbltuXS5hbmltYXRpb25TZXF1ZW5jZSkge1xyXG4gICAgICAgICAgbGV0IGFuaW1TZXE6IEFuaW1hdGlvblNlcXVlbmNlID0gbmV3IEFuaW1hdGlvblNlcXVlbmNlKCk7XHJcbiAgICAgICAgICBuZXdTdHJ1Y3R1cmVbbl0gPSBhbmltU2VxLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uW25dKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbmV3U3RydWN0dXJlW25dID0gdGhpcy50cmF2ZXJzZVN0cnVjdHVyZUZvckRlc2VyaWFsaXNhdGlvbihfc2VyaWFsaXphdGlvbltuXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBuZXdTdHJ1Y3R1cmU7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbmRzIHRoZSBsaXN0IG9mIGV2ZW50cyB0byBiZSB1c2VkIHdpdGggdGhlc2Ugc2V0dGluZ3MuXHJcbiAgICAgKiBAcGFyYW0gX2RpcmVjdGlvbiBUaGUgZGlyZWN0aW9uIHRoZSBhbmltYXRpb24gaXMgcGxheWluZyBpbi5cclxuICAgICAqIEBwYXJhbSBfcGxheWJhY2sgVGhlIHBsYXliYWNrbW9kZSB0aGUgYW5pbWF0aW9uIGlzIHBsYXlpbmcgaW4uXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY29ycmVjdCBBbmltYXRpb25FdmVudFRyaWdnZXIgT2JqZWN0IHRvIHVzZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGdldENvcnJlY3RFdmVudExpc3QoX2RpcmVjdGlvbjogbnVtYmVyLCBfcGxheWJhY2s6IEFOSU1BVElPTl9QTEFZQkFDSyk6IEFuaW1hdGlvbkV2ZW50VHJpZ2dlciB7XHJcbiAgICAgIGlmIChfcGxheWJhY2sgIT0gQU5JTUFUSU9OX1BMQVlCQUNLLkZSQU1FQkFTRUQpIHtcclxuICAgICAgICBpZiAoX2RpcmVjdGlvbiA+PSAwKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRQcm9jZXNzZWRFdmVudFRyaWdnZXIoQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLk5PUk1BTCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLmdldFByb2Nlc3NlZEV2ZW50VHJpZ2dlcihBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuUkVWRVJTRSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChfZGlyZWN0aW9uID49IDApIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLmdldFByb2Nlc3NlZEV2ZW50VHJpZ2dlcihBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuUkFTVEVSRUQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRQcm9jZXNzZWRFdmVudFRyaWdnZXIoQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlJBU1RFUkVEUkVWRVJTRSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmF2ZXJzZXMgYW4gQW5pbWF0aW9uU3RydWN0dXJlIHRvIHR1cm4gaXQgaW50byB0aGUgXCJNdXRhdG9yXCIgdG8gcmV0dXJuIHRvIHRoZSBDb21wb25lbnQuXHJcbiAgICAgKiBAcGFyYW0gX3N0cnVjdHVyZSBUaGUgc3RyY3V0dXJlIHRvIHRyYXZlcnNlXHJcbiAgICAgKiBAcGFyYW0gX3RpbWUgdGhlIHBvaW50IGluIHRpbWUgdG8gd3JpdGUgdGhlIGFuaW1hdGlvbiBudW1iZXJzIGludG8uXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgXCJNdXRhdG9yXCIgZmlsbGVkIHdpdGggdGhlIGNvcnJlY3QgdmFsdWVzIGF0IHRoZSBnaXZlbiB0aW1lLiBcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSB0cmF2ZXJzZVN0cnVjdHVyZUZvck11dGF0b3IoX3N0cnVjdHVyZTogQW5pbWF0aW9uU3RydWN0dXJlLCBfdGltZTogbnVtYmVyKTogTXV0YXRvciB7XHJcbiAgICAgIGxldCBuZXdNdXRhdG9yOiBNdXRhdG9yID0ge307XHJcbiAgICAgIGZvciAobGV0IG4gaW4gX3N0cnVjdHVyZSkge1xyXG4gICAgICAgIGlmIChfc3RydWN0dXJlW25dIGluc3RhbmNlb2YgQW5pbWF0aW9uU2VxdWVuY2UpIHtcclxuICAgICAgICAgIG5ld011dGF0b3Jbbl0gPSAoPEFuaW1hdGlvblNlcXVlbmNlPl9zdHJ1Y3R1cmVbbl0pLmV2YWx1YXRlKF90aW1lKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbmV3TXV0YXRvcltuXSA9IHRoaXMudHJhdmVyc2VTdHJ1Y3R1cmVGb3JNdXRhdG9yKDxBbmltYXRpb25TdHJ1Y3R1cmU+X3N0cnVjdHVyZVtuXSwgX3RpbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbmV3TXV0YXRvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYXZlcnNlcyB0aGUgY3VycmVudCBBbmltYXRpb25TdHJjdXR1cmUgdG8gZmluZCB0aGUgdG90YWxUaW1lIG9mIHRoaXMgYW5pbWF0aW9uLlxyXG4gICAgICogQHBhcmFtIF9zdHJ1Y3R1cmUgVGhlIHN0cnVjdHVyZSB0byB0cmF2ZXJzZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHRyYXZlcnNlU3RydWN0dXJlRm9yVGltZShfc3RydWN0dXJlOiBBbmltYXRpb25TdHJ1Y3R1cmUpOiB2b2lkIHtcclxuICAgICAgZm9yIChsZXQgbiBpbiBfc3RydWN0dXJlKSB7XHJcbiAgICAgICAgaWYgKF9zdHJ1Y3R1cmVbbl0gaW5zdGFuY2VvZiBBbmltYXRpb25TZXF1ZW5jZSkge1xyXG4gICAgICAgICAgbGV0IHNlcXVlbmNlOiBBbmltYXRpb25TZXF1ZW5jZSA9IDxBbmltYXRpb25TZXF1ZW5jZT5fc3RydWN0dXJlW25dO1xyXG4gICAgICAgICAgaWYgKHNlcXVlbmNlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgbGV0IHNlcXVlbmNlVGltZTogbnVtYmVyID0gc2VxdWVuY2UuZ2V0S2V5KHNlcXVlbmNlLmxlbmd0aCAtIDEpLlRpbWU7XHJcbiAgICAgICAgICAgIHRoaXMudG90YWxUaW1lID0gc2VxdWVuY2VUaW1lID4gdGhpcy50b3RhbFRpbWUgPyBzZXF1ZW5jZVRpbWUgOiB0aGlzLnRvdGFsVGltZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy50cmF2ZXJzZVN0cnVjdHVyZUZvclRpbWUoPEFuaW1hdGlvblN0cnVjdHVyZT5fc3RydWN0dXJlW25dKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEVuc3VyZXMgdGhlIGV4aXN0YW5jZSBvZiB0aGUgcmVxdWVzdGVkIFtbQW5pbWF0aW9uU3RyY3V0dXJlXV0gYW5kIHJldHVybnMgaXQuXHJcbiAgICAgKiBAcGFyYW0gX3R5cGUgdGhlIHR5cGUgb2YgdGhlIHN0cnVjdHVyZSB0byBnZXRcclxuICAgICAqIEByZXR1cm5zIHRoZSByZXF1ZXN0ZWQgW1tBbmltYXRpb25TdHJ1Y3R1cmVdXVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGdldFByb2Nlc3NlZEFuaW1hdGlvblN0cnVjdHVyZShfdHlwZTogQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFKTogQW5pbWF0aW9uU3RydWN0dXJlIHtcclxuICAgICAgaWYgKCF0aGlzLmFuaW1hdGlvblN0cnVjdHVyZXNQcm9jZXNzZWQuaGFzKF90eXBlKSkge1xyXG4gICAgICAgIHRoaXMuY2FsY3VsYXRlVG90YWxUaW1lKCk7XHJcbiAgICAgICAgbGV0IGFlOiBBbmltYXRpb25TdHJ1Y3R1cmUgPSB7fTtcclxuICAgICAgICBzd2l0Y2ggKF90eXBlKSB7XHJcbiAgICAgICAgICBjYXNlIEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5OT1JNQUw6XHJcbiAgICAgICAgICAgIGFlID0gdGhpcy5hbmltYXRpb25TdHJ1Y3R1cmU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSBBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuUkVWRVJTRTpcclxuICAgICAgICAgICAgYWUgPSB0aGlzLnRyYXZlcnNlU3RydWN0dXJlRm9yTmV3U3RydWN0dXJlKHRoaXMuYW5pbWF0aW9uU3RydWN0dXJlLCB0aGlzLmNhbGN1bGF0ZVJldmVyc2VTZXF1ZW5jZS5iaW5kKHRoaXMpKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5SQVNURVJFRDpcclxuICAgICAgICAgICAgYWUgPSB0aGlzLnRyYXZlcnNlU3RydWN0dXJlRm9yTmV3U3RydWN0dXJlKHRoaXMuYW5pbWF0aW9uU3RydWN0dXJlLCB0aGlzLmNhbGN1bGF0ZVJhc3RlcmVkU2VxdWVuY2UuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSBBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuUkFTVEVSRURSRVZFUlNFOlxyXG4gICAgICAgICAgICBhZSA9IHRoaXMudHJhdmVyc2VTdHJ1Y3R1cmVGb3JOZXdTdHJ1Y3R1cmUodGhpcy5nZXRQcm9jZXNzZWRBbmltYXRpb25TdHJ1Y3R1cmUoQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlJFVkVSU0UpLCB0aGlzLmNhbGN1bGF0ZVJhc3RlcmVkU2VxdWVuY2UuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFuaW1hdGlvblN0cnVjdHVyZXNQcm9jZXNzZWQuc2V0KF90eXBlLCBhZSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0aW9uU3RydWN0dXJlc1Byb2Nlc3NlZC5nZXQoX3R5cGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRW5zdXJlcyB0aGUgZXhpc3RhbmNlIG9mIHRoZSByZXF1ZXN0ZWQgW1tBbmltYXRpb25FdmVudFRyaWdnZXJdXSBhbmQgcmV0dXJucyBpdC5cclxuICAgICAqIEBwYXJhbSBfdHlwZSBUaGUgdHlwZSBvZiBBbmltYXRpb25FdmVudFRyaWdnZXIgdG8gZ2V0XHJcbiAgICAgKiBAcmV0dXJucyB0aGUgcmVxdWVzdGVkIFtbQW5pbWF0aW9uRXZlbnRUcmlnZ2VyXV1cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBnZXRQcm9jZXNzZWRFdmVudFRyaWdnZXIoX3R5cGU6IEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRSk6IEFuaW1hdGlvbkV2ZW50VHJpZ2dlciB7XHJcbiAgICAgIGlmICghdGhpcy5ldmVudHNQcm9jZXNzZWQuaGFzKF90eXBlKSkge1xyXG4gICAgICAgIHRoaXMuY2FsY3VsYXRlVG90YWxUaW1lKCk7XHJcbiAgICAgICAgbGV0IGV2OiBBbmltYXRpb25FdmVudFRyaWdnZXIgPSB7fTtcclxuICAgICAgICBzd2l0Y2ggKF90eXBlKSB7XHJcbiAgICAgICAgICBjYXNlIEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5OT1JNQUw6XHJcbiAgICAgICAgICAgIGV2ID0gdGhpcy5ldmVudHM7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSBBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuUkVWRVJTRTpcclxuICAgICAgICAgICAgZXYgPSB0aGlzLmNhbGN1bGF0ZVJldmVyc2VFdmVudFRyaWdnZXJzKHRoaXMuZXZlbnRzKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5SQVNURVJFRDpcclxuICAgICAgICAgICAgZXYgPSB0aGlzLmNhbGN1bGF0ZVJhc3RlcmVkRXZlbnRUcmlnZ2Vycyh0aGlzLmV2ZW50cyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSBBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuUkFTVEVSRURSRVZFUlNFOlxyXG4gICAgICAgICAgICBldiA9IHRoaXMuY2FsY3VsYXRlUmFzdGVyZWRFdmVudFRyaWdnZXJzKHRoaXMuZ2V0UHJvY2Vzc2VkRXZlbnRUcmlnZ2VyKEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5SRVZFUlNFKSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmV2ZW50c1Byb2Nlc3NlZC5zZXQoX3R5cGUsIGV2KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy5ldmVudHNQcm9jZXNzZWQuZ2V0KF90eXBlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYXZlcnNlcyBhbiBleGlzdGluZyBzdHJ1Y3R1cmUgdG8gYXBwbHkgYSByZWNhbGN1bGF0aW9uIGZ1bmN0aW9uIHRvIHRoZSBBbmltYXRpb25TdHJ1Y3R1cmUgdG8gc3RvcmUgaW4gYSBuZXcgU3RydWN0dXJlLlxyXG4gICAgICogQHBhcmFtIF9vbGRTdHJ1Y3R1cmUgVGhlIG9sZCBzdHJ1Y3R1cmUgdG8gdHJhdmVyc2VcclxuICAgICAqIEBwYXJhbSBfZnVuY3Rpb25Ub1VzZSBUaGUgZnVuY3Rpb24gdG8gdXNlIHRvIHJlY2FsY3VsYXRlZCB0aGUgc3RydWN0dXJlLlxyXG4gICAgICogQHJldHVybnMgQSBuZXcgQW5pbWF0aW9uIFN0cnVjdHVyZSB3aXRoIHRoZSByZWNhbHVsYXRlZCBBbmltYXRpb24gU2VxdWVuY2VzLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHRyYXZlcnNlU3RydWN0dXJlRm9yTmV3U3RydWN0dXJlKF9vbGRTdHJ1Y3R1cmU6IEFuaW1hdGlvblN0cnVjdHVyZSwgX2Z1bmN0aW9uVG9Vc2U6IEZ1bmN0aW9uKTogQW5pbWF0aW9uU3RydWN0dXJlIHtcclxuICAgICAgbGV0IG5ld1N0cnVjdHVyZTogQW5pbWF0aW9uU3RydWN0dXJlID0ge307XHJcbiAgICAgIGZvciAobGV0IG4gaW4gX29sZFN0cnVjdHVyZSkge1xyXG4gICAgICAgIGlmIChfb2xkU3RydWN0dXJlW25dIGluc3RhbmNlb2YgQW5pbWF0aW9uU2VxdWVuY2UpIHtcclxuICAgICAgICAgIG5ld1N0cnVjdHVyZVtuXSA9IF9mdW5jdGlvblRvVXNlKF9vbGRTdHJ1Y3R1cmVbbl0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuZXdTdHJ1Y3R1cmVbbl0gPSB0aGlzLnRyYXZlcnNlU3RydWN0dXJlRm9yTmV3U3RydWN0dXJlKDxBbmltYXRpb25TdHJ1Y3R1cmU+X29sZFN0cnVjdHVyZVtuXSwgX2Z1bmN0aW9uVG9Vc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbmV3U3RydWN0dXJlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHJldmVyc2VkIEFuaW1hdGlvbiBTZXF1ZW5jZSBvdXQgb2YgYSBnaXZlbiBTZXF1ZW5jZS5cclxuICAgICAqIEBwYXJhbSBfc2VxdWVuY2UgVGhlIHNlcXVlbmNlIHRvIGNhbGN1bGF0ZSB0aGUgbmV3IHNlcXVlbmNlIG91dCBvZlxyXG4gICAgICogQHJldHVybnMgVGhlIHJldmVyc2VkIFNlcXVlbmNlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY2FsY3VsYXRlUmV2ZXJzZVNlcXVlbmNlKF9zZXF1ZW5jZTogQW5pbWF0aW9uU2VxdWVuY2UpOiBBbmltYXRpb25TZXF1ZW5jZSB7XHJcbiAgICAgIGxldCBzZXE6IEFuaW1hdGlvblNlcXVlbmNlID0gbmV3IEFuaW1hdGlvblNlcXVlbmNlKCk7XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBfc2VxdWVuY2UubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgb2xkS2V5OiBBbmltYXRpb25LZXkgPSBfc2VxdWVuY2UuZ2V0S2V5KGkpO1xyXG4gICAgICAgIGxldCBrZXk6IEFuaW1hdGlvbktleSA9IG5ldyBBbmltYXRpb25LZXkodGhpcy50b3RhbFRpbWUgLSBvbGRLZXkuVGltZSwgb2xkS2V5LlZhbHVlLCBvbGRLZXkuU2xvcGVPdXQsIG9sZEtleS5TbG9wZUluLCBvbGRLZXkuQ29uc3RhbnQpO1xyXG4gICAgICAgIHNlcS5hZGRLZXkoa2V5KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gc2VxO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHJhc3RlcmVkIFtbQW5pbWF0aW9uU2VxdWVuY2VdXSBvdXQgb2YgYSBnaXZlbiBzZXF1ZW5jZS5cclxuICAgICAqIEBwYXJhbSBfc2VxdWVuY2UgVGhlIHNlcXVlbmNlIHRvIGNhbGN1bGF0ZSB0aGUgbmV3IHNlcXVlbmNlIG91dCBvZlxyXG4gICAgICogQHJldHVybnMgdGhlIHJhc3RlcmVkIHNlcXVlbmNlLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNhbGN1bGF0ZVJhc3RlcmVkU2VxdWVuY2UoX3NlcXVlbmNlOiBBbmltYXRpb25TZXF1ZW5jZSk6IEFuaW1hdGlvblNlcXVlbmNlIHtcclxuICAgICAgbGV0IHNlcTogQW5pbWF0aW9uU2VxdWVuY2UgPSBuZXcgQW5pbWF0aW9uU2VxdWVuY2UoKTtcclxuICAgICAgbGV0IGZyYW1lVGltZTogbnVtYmVyID0gMTAwMCAvIHRoaXMuZnJhbWVzUGVyU2Vjb25kO1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy50b3RhbFRpbWU7IGkgKz0gZnJhbWVUaW1lKSB7XHJcbiAgICAgICAgbGV0IGtleTogQW5pbWF0aW9uS2V5ID0gbmV3IEFuaW1hdGlvbktleShpLCBfc2VxdWVuY2UuZXZhbHVhdGUoaSksIDAsIDAsIHRydWUpO1xyXG4gICAgICAgIHNlcS5hZGRLZXkoa2V5KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gc2VxO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyByZXZlcnNlZCBbW0FuaW1hdGlvbkV2ZW50VHJpZ2dlcl1dIG9iamVjdCBiYXNlZCBvbiB0aGUgZ2l2ZW4gb25lLiAgXHJcbiAgICAgKiBAcGFyYW0gX2V2ZW50cyB0aGUgZXZlbnQgb2JqZWN0IHRvIGNhbGN1bGF0ZSB0aGUgbmV3IG9uZSBvdXQgb2ZcclxuICAgICAqIEByZXR1cm5zIHRoZSByZXZlcnNlZCBldmVudCBvYmplY3RcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjYWxjdWxhdGVSZXZlcnNlRXZlbnRUcmlnZ2VycyhfZXZlbnRzOiBBbmltYXRpb25FdmVudFRyaWdnZXIpOiBBbmltYXRpb25FdmVudFRyaWdnZXIge1xyXG4gICAgICBsZXQgYWU6IEFuaW1hdGlvbkV2ZW50VHJpZ2dlciA9IHt9O1xyXG4gICAgICBmb3IgKGxldCBuYW1lIGluIF9ldmVudHMpIHtcclxuICAgICAgICBhZVtuYW1lXSA9IHRoaXMudG90YWxUaW1lIC0gX2V2ZW50c1tuYW1lXTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYWU7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHJhc3RlcmVkIFtbQW5pbWF0aW9uRXZlbnRUcmlnZ2VyXV0gb2JqZWN0IGJhc2VkIG9uIHRoZSBnaXZlbiBvbmUuICBcclxuICAgICAqIEBwYXJhbSBfZXZlbnRzIHRoZSBldmVudCBvYmplY3QgdG8gY2FsY3VsYXRlIHRoZSBuZXcgb25lIG91dCBvZlxyXG4gICAgICogQHJldHVybnMgdGhlIHJhc3RlcmVkIGV2ZW50IG9iamVjdFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNhbGN1bGF0ZVJhc3RlcmVkRXZlbnRUcmlnZ2VycyhfZXZlbnRzOiBBbmltYXRpb25FdmVudFRyaWdnZXIpOiBBbmltYXRpb25FdmVudFRyaWdnZXIge1xyXG4gICAgICBsZXQgYWU6IEFuaW1hdGlvbkV2ZW50VHJpZ2dlciA9IHt9O1xyXG4gICAgICBsZXQgZnJhbWVUaW1lOiBudW1iZXIgPSAxMDAwIC8gdGhpcy5mcmFtZXNQZXJTZWNvbmQ7XHJcbiAgICAgIGZvciAobGV0IG5hbWUgaW4gX2V2ZW50cykge1xyXG4gICAgICAgIGFlW25hbWVdID0gX2V2ZW50c1tuYW1lXSAtIChfZXZlbnRzW25hbWVdICUgZnJhbWVUaW1lKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYWU7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHdoaWNoIGV2ZW50cyBsYXkgYmV0d2VlbiB0d28gZ2l2ZW4gdGltZXMgYW5kIHJldHVybnMgdGhlIG5hbWVzIG9mIHRoZSBvbmVzIHRoYXQgZG8uXHJcbiAgICAgKiBAcGFyYW0gX2V2ZW50VHJpZ2dlcnMgVGhlIGV2ZW50IG9iamVjdCB0byBjaGVjayB0aGUgZXZlbnRzIGluc2lkZSBvZlxyXG4gICAgICogQHBhcmFtIF9taW4gdGhlIG1pbmltdW0gb2YgdGhlIHJhbmdlIHRvIGNoZWNrIGJldHdlZW4gKGluY2x1c2l2ZSlcclxuICAgICAqIEBwYXJhbSBfbWF4IHRoZSBtYXhpbXVtIG9mIHRoZSByYW5nZSB0byBjaGVjayBiZXR3ZWVuIChleGNsdXNpdmUpXHJcbiAgICAgKiBAcmV0dXJucyBhbiBhcnJheSBvZiB0aGUgbmFtZXMgb2YgdGhlIGV2ZW50cyBpbiB0aGUgZ2l2ZW4gcmFuZ2UuIFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNoZWNrRXZlbnRzQmV0d2VlbihfZXZlbnRUcmlnZ2VyczogQW5pbWF0aW9uRXZlbnRUcmlnZ2VyLCBfbWluOiBudW1iZXIsIF9tYXg6IG51bWJlcik6IHN0cmluZ1tdIHtcclxuICAgICAgbGV0IGV2ZW50c1RvVHJpZ2dlcjogc3RyaW5nW10gPSBbXTtcclxuICAgICAgZm9yIChsZXQgbmFtZSBpbiBfZXZlbnRUcmlnZ2Vycykge1xyXG4gICAgICAgIGlmIChfbWluIDw9IF9ldmVudFRyaWdnZXJzW25hbWVdICYmIF9ldmVudFRyaWdnZXJzW25hbWVdIDwgX21heCkge1xyXG4gICAgICAgICAgZXZlbnRzVG9UcmlnZ2VyLnB1c2gobmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBldmVudHNUb1RyaWdnZXI7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwiLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9UcmFuc2Zlci9TZXJpYWxpemVyLnRzXCIvPlxyXG4vLyAvIDxyZWZlcmVuY2UgcGF0aD1cIi4uL1RyYW5zZmVyL011dGFibGUudHNcIi8+XHJcblxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBDYWxjdWxhdGVzIHRoZSB2YWx1ZXMgYmV0d2VlbiBbW0FuaW1hdGlvbktleV1dcy5cclxuICAgKiBSZXByZXNlbnRlZCBpbnRlcm5hbGx5IGJ5IGEgY3ViaWMgZnVuY3Rpb24gKGBmKHgpID0gYXjCsyArIGJ4wrIgKyBjeCArIGRgKS4gXHJcbiAgICogT25seSBuZWVkcyB0byBiZSByZWNhbGN1bGF0ZWQgd2hlbiB0aGUga2V5cyBjaGFuZ2UsIHNvIGF0IHJ1bnRpbWUgaXQgc2hvdWxkIG9ubHkgYmUgY2FsY3VsYXRlZCBvbmNlLlxyXG4gICAqIEBhdXRob3IgTHVrYXMgU2NoZXVlcmxlLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQW5pbWF0aW9uRnVuY3Rpb24ge1xyXG4gICAgcHJpdmF0ZSBhOiBudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSBiOiBudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSBjOiBudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSBkOiBudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSBrZXlJbjogQW5pbWF0aW9uS2V5O1xyXG4gICAgcHJpdmF0ZSBrZXlPdXQ6IEFuaW1hdGlvbktleTtcclxuXHJcblxyXG4gICAgY29uc3RydWN0b3IoX2tleUluOiBBbmltYXRpb25LZXksIF9rZXlPdXQ6IEFuaW1hdGlvbktleSA9IG51bGwpIHtcclxuICAgICAgdGhpcy5rZXlJbiA9IF9rZXlJbjtcclxuICAgICAgdGhpcy5rZXlPdXQgPSBfa2V5T3V0O1xyXG4gICAgICB0aGlzLmNhbGN1bGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIGF0IHRoZSBnaXZlbiB0aW1lLlxyXG4gICAgICogQHBhcmFtIF90aW1lIHRoZSBwb2ludCBpbiB0aW1lIGF0IHdoaWNoIHRvIGV2YWx1YXRlIHRoZSBmdW5jdGlvbiBpbiBtaWxsaXNlY29uZHMuIFdpbGwgYmUgY29ycmVjdGVkIGZvciBvZmZzZXQgaW50ZXJuYWxseS5cclxuICAgICAqIEByZXR1cm5zIHRoZSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gdGltZVxyXG4gICAgICovXHJcbiAgICBldmFsdWF0ZShfdGltZTogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgICAgX3RpbWUgLT0gdGhpcy5rZXlJbi5UaW1lO1xyXG4gICAgICBsZXQgdGltZTI6IG51bWJlciA9IF90aW1lICogX3RpbWU7XHJcbiAgICAgIGxldCB0aW1lMzogbnVtYmVyID0gdGltZTIgKiBfdGltZTtcclxuICAgICAgcmV0dXJuIHRoaXMuYSAqIHRpbWUzICsgdGhpcy5iICogdGltZTIgKyB0aGlzLmMgKiBfdGltZSArIHRoaXMuZDtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgc2V0S2V5SW4oX2tleUluOiBBbmltYXRpb25LZXkpIHtcclxuICAgICAgdGhpcy5rZXlJbiA9IF9rZXlJbjtcclxuICAgICAgdGhpcy5jYWxjdWxhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgc2V0S2V5T3V0KF9rZXlPdXQ6IEFuaW1hdGlvbktleSkge1xyXG4gICAgICB0aGlzLmtleU91dCA9IF9rZXlPdXQ7XHJcbiAgICAgIHRoaXMuY2FsY3VsYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAoUmUtKUNhbGN1bGF0ZXMgdGhlIHBhcmFtZXRlcnMgb2YgdGhlIGN1YmljIGZ1bmN0aW9uLlxyXG4gICAgICogU2VlIGh0dHBzOi8vbWF0aC5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMzE3MzQ2OS9jYWxjdWxhdGUtY3ViaWMtZXF1YXRpb24tZnJvbS10d28tcG9pbnRzLWFuZC10d28tc2xvcGVzLXZhcmlhYmx5XHJcbiAgICAgKiBhbmQgaHR0cHM6Ly9qaXJrYWRlbGxvcm8uZ2l0aHViLmlvL0ZVREdFL0RvY3VtZW50YXRpb24vTG9ncy8xOTA0MTBfTm90aXplbl9MU1xyXG4gICAgICovXHJcbiAgICBjYWxjdWxhdGUoKTogdm9pZCB7XHJcbiAgICAgIGlmICghdGhpcy5rZXlJbikge1xyXG4gICAgICAgIHRoaXMuZCA9IHRoaXMuYyA9IHRoaXMuYiA9IHRoaXMuYSA9IDA7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghdGhpcy5rZXlPdXQgfHwgdGhpcy5rZXlJbi5Db25zdGFudCkge1xyXG4gICAgICAgIHRoaXMuZCA9IHRoaXMua2V5SW4uVmFsdWU7XHJcbiAgICAgICAgdGhpcy5jID0gdGhpcy5iID0gdGhpcy5hID0gMDtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCB4MTogbnVtYmVyID0gdGhpcy5rZXlPdXQuVGltZSAtIHRoaXMua2V5SW4uVGltZTtcclxuXHJcbiAgICAgIHRoaXMuZCA9IHRoaXMua2V5SW4uVmFsdWU7XHJcbiAgICAgIHRoaXMuYyA9IHRoaXMua2V5SW4uU2xvcGVPdXQ7XHJcblxyXG4gICAgICB0aGlzLmEgPSAoLXgxICogKHRoaXMua2V5SW4uU2xvcGVPdXQgKyB0aGlzLmtleU91dC5TbG9wZUluKSAtIDIgKiB0aGlzLmtleUluLlZhbHVlICsgMiAqIHRoaXMua2V5T3V0LlZhbHVlKSAvIC1NYXRoLnBvdyh4MSwgMyk7XHJcbiAgICAgIHRoaXMuYiA9ICh0aGlzLmtleU91dC5TbG9wZUluIC0gdGhpcy5rZXlJbi5TbG9wZU91dCAtIDMgKiB0aGlzLmEgKiBNYXRoLnBvdyh4MSwgMikpIC8gKDIgKiB4MSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxufSIsIi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vVHJhbnNmZXIvU2VyaWFsaXplci50c1wiLz5cclxuLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9UcmFuc2Zlci9NdXRhYmxlLnRzXCIvPlxyXG5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogSG9sZHMgaW5mb3JtYXRpb24gYWJvdXQgc2V0IHBvaW50cyBpbiB0aW1lLCB0aGVpciBhY2NvbXBhbnlpbmcgdmFsdWVzIGFzIHdlbGwgYXMgdGhlaXIgc2xvcGVzLiBcclxuICAgKiBBbHNvIGhvbGRzIGEgcmVmZXJlbmNlIHRvIHRoZSBbW0FuaW1hdGlvbkZ1bmN0aW9uXV1zIHRoYXQgY29tZSBpbiBhbmQgb3V0IG9mIHRoZSBzaWRlcy4gVGhlIFtbQW5pbWF0aW9uRnVuY3Rpb25dXXMgYXJlIGhhbmRsZWQgYnkgdGhlIFtbQW5pbWF0aW9uU2VxdWVuY2VdXXMuXHJcbiAgICogU2F2ZWQgaW5zaWRlIGFuIFtbQW5pbWF0aW9uU2VxdWVuY2VdXS5cclxuICAgKiBAYXV0aG9yIEx1a2FzIFNjaGV1ZXJsZSwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEFuaW1hdGlvbktleSBleHRlbmRzIE11dGFibGUgaW1wbGVtZW50cyBTZXJpYWxpemFibGUge1xyXG4gICAgLy8gVE9ETzogY2hlY2sgaWYgZnVuY3Rpb25JbiBjYW4gYmUgcmVtb3ZlZFxyXG4gICAgLyoqRG9uJ3QgbW9kaWZ5IHRoaXMgdW5sZXNzIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nLiovXHJcbiAgICBmdW5jdGlvbkluOiBBbmltYXRpb25GdW5jdGlvbjtcclxuICAgIC8qKkRvbid0IG1vZGlmeSB0aGlzIHVubGVzcyB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZy4qL1xyXG4gICAgZnVuY3Rpb25PdXQ6IEFuaW1hdGlvbkZ1bmN0aW9uO1xyXG4gICAgXHJcbiAgICBicm9rZW46IGJvb2xlYW47XHJcblxyXG4gICAgcHJpdmF0ZSB0aW1lOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIHZhbHVlOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIGNvbnN0YW50OiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgcHJpdmF0ZSBzbG9wZUluOiBudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSBzbG9wZU91dDogbnVtYmVyID0gMDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihfdGltZTogbnVtYmVyID0gMCwgX3ZhbHVlOiBudW1iZXIgPSAwLCBfc2xvcGVJbjogbnVtYmVyID0gMCwgX3Nsb3BlT3V0OiBudW1iZXIgPSAwLCBfY29uc3RhbnQ6IGJvb2xlYW4gPSBmYWxzZSkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLnRpbWUgPSBfdGltZTtcclxuICAgICAgdGhpcy52YWx1ZSA9IF92YWx1ZTtcclxuICAgICAgdGhpcy5zbG9wZUluID0gX3Nsb3BlSW47XHJcbiAgICAgIHRoaXMuc2xvcGVPdXQgPSBfc2xvcGVPdXQ7XHJcbiAgICAgIHRoaXMuY29uc3RhbnQgPSBfY29uc3RhbnQ7XHJcblxyXG4gICAgICB0aGlzLmJyb2tlbiA9IHRoaXMuc2xvcGVJbiAhPSAtdGhpcy5zbG9wZU91dDtcclxuICAgICAgdGhpcy5mdW5jdGlvbk91dCA9IG5ldyBBbmltYXRpb25GdW5jdGlvbih0aGlzLCBudWxsKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgVGltZSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy50aW1lO1xyXG4gICAgfVxyXG5cclxuICAgIHNldCBUaW1lKF90aW1lOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy50aW1lID0gX3RpbWU7XHJcbiAgICAgIHRoaXMuZnVuY3Rpb25Jbi5jYWxjdWxhdGUoKTtcclxuICAgICAgdGhpcy5mdW5jdGlvbk91dC5jYWxjdWxhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgVmFsdWUoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IFZhbHVlKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMudmFsdWUgPSBfdmFsdWU7XHJcbiAgICAgIHRoaXMuZnVuY3Rpb25Jbi5jYWxjdWxhdGUoKTtcclxuICAgICAgdGhpcy5mdW5jdGlvbk91dC5jYWxjdWxhdGUoKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZ2V0IENvbnN0YW50KCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy5jb25zdGFudDtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgQ29uc3RhbnQoX2NvbnN0YW50OiBib29sZWFuKSB7XHJcbiAgICAgIHRoaXMuY29uc3RhbnQgPSBfY29uc3RhbnQ7XHJcbiAgICAgIHRoaXMuZnVuY3Rpb25Jbi5jYWxjdWxhdGUoKTtcclxuICAgICAgdGhpcy5mdW5jdGlvbk91dC5jYWxjdWxhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgU2xvcGVJbigpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5zbG9wZUluO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBzZXQgU2xvcGVJbihfc2xvcGU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLnNsb3BlSW4gPSBfc2xvcGU7XHJcbiAgICAgIHRoaXMuZnVuY3Rpb25Jbi5jYWxjdWxhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgU2xvcGVPdXQoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc2xvcGVPdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IFNsb3BlT3V0KF9zbG9wZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuc2xvcGVPdXQgPSBfc2xvcGU7XHJcbiAgICAgIHRoaXMuZnVuY3Rpb25PdXQuY2FsY3VsYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGF0aWMgY29tcGFyYXRpb24gZnVuY3Rpb24gdG8gdXNlIGluIGFuIGFycmF5IHNvcnQgZnVuY3Rpb24gdG8gc29ydCB0aGUga2V5cyBieSB0aGVpciB0aW1lLlxyXG4gICAgICogQHBhcmFtIF9hIHRoZSBhbmltYXRpb24ga2V5IHRvIGNoZWNrXHJcbiAgICAgKiBAcGFyYW0gX2IgdGhlIGFuaW1hdGlvbiBrZXkgdG8gY2hlY2sgYWdhaW5zdFxyXG4gICAgICogQHJldHVybnMgPjAgaWYgYT5iLCAwIGlmIGE9YiwgPDAgaWYgYTxiXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjb21wYXJlKF9hOiBBbmltYXRpb25LZXksIF9iOiBBbmltYXRpb25LZXkpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gX2EudGltZSAtIF9iLnRpbWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIHRyYW5zZmVyXHJcbiAgICBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzOiBTZXJpYWxpemF0aW9uID0ge307XHJcbiAgICAgIHMudGltZSA9IHRoaXMudGltZTtcclxuICAgICAgcy52YWx1ZSA9IHRoaXMudmFsdWU7XHJcbiAgICAgIHMuc2xvcGVJbiA9IHRoaXMuc2xvcGVJbjtcclxuICAgICAgcy5zbG9wZU91dCA9IHRoaXMuc2xvcGVPdXQ7XHJcbiAgICAgIHMuY29uc3RhbnQgPSB0aGlzLmNvbnN0YW50O1xyXG4gICAgICByZXR1cm4gcztcclxuICAgIH1cclxuXHJcbiAgICBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFNlcmlhbGl6YWJsZSB7XHJcbiAgICAgIHRoaXMudGltZSA9IF9zZXJpYWxpemF0aW9uLnRpbWU7XHJcbiAgICAgIHRoaXMudmFsdWUgPSBfc2VyaWFsaXphdGlvbi52YWx1ZTtcclxuICAgICAgdGhpcy5zbG9wZUluID0gX3NlcmlhbGl6YXRpb24uc2xvcGVJbjtcclxuICAgICAgdGhpcy5zbG9wZU91dCA9IF9zZXJpYWxpemF0aW9uLnNsb3BlT3V0O1xyXG4gICAgICB0aGlzLmNvbnN0YW50ID0gX3NlcmlhbGl6YXRpb24uY29uc3RhbnQ7XHJcblxyXG4gICAgICB0aGlzLmJyb2tlbiA9IHRoaXMuc2xvcGVJbiAhPSAtdGhpcy5zbG9wZU91dDtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIGdldE11dGF0b3IoKTogTXV0YXRvciB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIC8vXHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgfVxyXG5cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEEgc2VxdWVuY2Ugb2YgW1tBbmltYXRpb25LZXldXXMgdGhhdCBpcyBtYXBwZWQgdG8gYW4gYXR0cmlidXRlIG9mIGEgW1tOb2RlXV0gb3IgaXRzIFtbQ29tcG9uZW50XV1zIGluc2lkZSB0aGUgW1tBbmltYXRpb25dXS5cclxuICAgKiBQcm92aWRlcyBmdW5jdGlvbnMgdG8gbW9kaWZ5IHNhaWQga2V5c1xyXG4gICAqIEBhdXRob3IgTHVrYXMgU2NoZXVlcmxlLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQW5pbWF0aW9uU2VxdWVuY2UgZXh0ZW5kcyBNdXRhYmxlIGltcGxlbWVudHMgU2VyaWFsaXphYmxlIHtcclxuICAgIHByaXZhdGUga2V5czogQW5pbWF0aW9uS2V5W10gPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEV2YWx1YXRlcyB0aGUgc2VxdWVuY2UgYXQgdGhlIGdpdmVuIHBvaW50IGluIHRpbWUuXHJcbiAgICAgKiBAcGFyYW0gX3RpbWUgdGhlIHBvaW50IGluIHRpbWUgYXQgd2hpY2ggdG8gZXZhbHVhdGUgdGhlIHNlcXVlbmNlIGluIG1pbGxpc2Vjb25kcy5cclxuICAgICAqIEByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgc2VxdWVuY2UgYXQgdGhlIGdpdmVuIHRpbWUuIDAgaWYgdGhlcmUgYXJlIG5vIGtleXMuXHJcbiAgICAgKi9cclxuICAgIGV2YWx1YXRlKF90aW1lOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICBpZiAodGhpcy5rZXlzLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgIHJldHVybiAwOyAvL1RPRE86IHNob3VsZG4ndCByZXR1cm4gMCBidXQgc29tZXRoaW5nIGluZGljYXRpbmcgbm8gY2hhbmdlLCBsaWtlIG51bGwuIHByb2JhYmx5IG5lZWRzIHRvIGJlIGNoYW5nZWQgaW4gTm9kZSBhcyB3ZWxsIHRvIGlnbm9yZSBub24tbnVtZXJpYyB2YWx1ZXMgaW4gdGhlIGFwcGx5QW5pbWF0aW9uIGZ1bmN0aW9uXHJcbiAgICAgIGlmICh0aGlzLmtleXMubGVuZ3RoID09IDEgfHwgdGhpcy5rZXlzWzBdLlRpbWUgPj0gX3RpbWUpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5c1swXS5WYWx1ZTtcclxuXHJcblxyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5rZXlzLmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgIGlmICh0aGlzLmtleXNbaV0uVGltZSA8PSBfdGltZSAmJiB0aGlzLmtleXNbaSArIDFdLlRpbWUgPiBfdGltZSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMua2V5c1tpXS5mdW5jdGlvbk91dC5ldmFsdWF0ZShfdGltZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLmtleXNbdGhpcy5rZXlzLmxlbmd0aCAtIDFdLlZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIG5ldyBrZXkgdG8gdGhlIHNlcXVlbmNlLlxyXG4gICAgICogQHBhcmFtIF9rZXkgdGhlIGtleSB0byBhZGRcclxuICAgICAqL1xyXG4gICAgYWRkS2V5KF9rZXk6IEFuaW1hdGlvbktleSk6IHZvaWQge1xyXG4gICAgICB0aGlzLmtleXMucHVzaChfa2V5KTtcclxuICAgICAgdGhpcy5rZXlzLnNvcnQoQW5pbWF0aW9uS2V5LmNvbXBhcmUpO1xyXG4gICAgICB0aGlzLnJlZ2VuZXJhdGVGdW5jdGlvbnMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYSBnaXZlbiBrZXkgZnJvbSB0aGUgc2VxdWVuY2UuXHJcbiAgICAgKiBAcGFyYW0gX2tleSB0aGUga2V5IHRvIHJlbW92ZVxyXG4gICAgICovXHJcbiAgICByZW1vdmVLZXkoX2tleTogQW5pbWF0aW9uS2V5KTogdm9pZCB7XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLmtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAodGhpcy5rZXlzW2ldID09IF9rZXkpIHtcclxuICAgICAgICAgIHRoaXMua2V5cy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICB0aGlzLnJlZ2VuZXJhdGVGdW5jdGlvbnMoKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhlIEFuaW1hdGlvbiBLZXkgYXQgdGhlIGdpdmVuIGluZGV4IGZyb20gdGhlIGtleXMuXHJcbiAgICAgKiBAcGFyYW0gX2luZGV4IHRoZSB6ZXJvLWJhc2VkIGluZGV4IGF0IHdoaWNoIHRvIHJlbW92ZSB0aGUga2V5XHJcbiAgICAgKiBAcmV0dXJucyB0aGUgcmVtb3ZlZCBBbmltYXRpb25LZXkgaWYgc3VjY2Vzc2Z1bCwgbnVsbCBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZUtleUF0SW5kZXgoX2luZGV4OiBudW1iZXIpOiBBbmltYXRpb25LZXkge1xyXG4gICAgICBpZiAoX2luZGV4IDwgMCB8fCBfaW5kZXggPj0gdGhpcy5rZXlzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCBhazogQW5pbWF0aW9uS2V5ID0gdGhpcy5rZXlzW19pbmRleF07XHJcbiAgICAgIHRoaXMua2V5cy5zcGxpY2UoX2luZGV4LCAxKTtcclxuICAgICAgdGhpcy5yZWdlbmVyYXRlRnVuY3Rpb25zKCk7XHJcbiAgICAgIHJldHVybiBhaztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSBrZXkgZnJvbSB0aGUgc2VxdWVuY2UgYXQgdGhlIGRlc2lyZWQgaW5kZXguXHJcbiAgICAgKiBAcGFyYW0gX2luZGV4IHRoZSB6ZXJvLWJhc2VkIGluZGV4IGF0IHdoaWNoIHRvIGdldCB0aGUga2V5XHJcbiAgICAgKiBAcmV0dXJucyB0aGUgQW5pbWF0aW9uS2V5IGF0IHRoZSBpbmRleCBpZiBpdCBleGlzdHMsIG51bGwgb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBnZXRLZXkoX2luZGV4OiBudW1iZXIpOiBBbmltYXRpb25LZXkge1xyXG4gICAgICBpZiAoX2luZGV4IDwgMCB8fCBfaW5kZXggPj0gdGhpcy5rZXlzLmxlbmd0aClcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgcmV0dXJuIHRoaXMua2V5c1tfaW5kZXhdO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBsZW5ndGgoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMua2V5cy5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIHRyYW5zZmVyXHJcbiAgICBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzOiBTZXJpYWxpemF0aW9uID0ge1xyXG4gICAgICAgIGtleXM6IFtdLFxyXG4gICAgICAgIGFuaW1hdGlvblNlcXVlbmNlOiB0cnVlXHJcbiAgICAgIH07XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLmtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBzLmtleXNbaV0gPSB0aGlzLmtleXNbaV0uc2VyaWFsaXplKCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHM7XHJcbiAgICB9XHJcbiAgICBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFNlcmlhbGl6YWJsZSB7XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBfc2VyaWFsaXphdGlvbi5rZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgLy8gdGhpcy5rZXlzLnB1c2goPEFuaW1hdGlvbktleT5TZXJpYWxpemVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLmtleXNbaV0pKTtcclxuICAgICAgICBsZXQgazogQW5pbWF0aW9uS2V5ID0gbmV3IEFuaW1hdGlvbktleSgpO1xyXG4gICAgICAgIGsuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24ua2V5c1tpXSk7XHJcbiAgICAgICAgdGhpcy5rZXlzW2ldID0gaztcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5yZWdlbmVyYXRlRnVuY3Rpb25zKCk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgLy9cclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXRpbGl0eSBmdW5jdGlvbiB0aGF0IChyZS0pZ2VuZXJhdGVzIGFsbCBmdW5jdGlvbnMgaW4gdGhlIHNlcXVlbmNlLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHJlZ2VuZXJhdGVGdW5jdGlvbnMoKTogdm9pZCB7XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLmtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgZjogQW5pbWF0aW9uRnVuY3Rpb24gPSBuZXcgQW5pbWF0aW9uRnVuY3Rpb24odGhpcy5rZXlzW2ldKTtcclxuICAgICAgICB0aGlzLmtleXNbaV0uZnVuY3Rpb25PdXQgPSBmO1xyXG4gICAgICAgIGlmIChpID09IHRoaXMua2V5cy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAvL1RPRE86IGNoZWNrIGlmIHRoaXMgaXMgZXZlbiB1c2VmdWwuIE1heWJlIHVwZGF0ZSB0aGUgcnVuY29uZGl0aW9uIHRvIGxlbmd0aCAtIDEgaW5zdGVhZC4gTWlnaHQgYmUgcmVkdW5kYW50IGlmIGZ1bmN0aW9uSW4gaXMgcmVtb3ZlZCwgc2VlIFRPRE8gaW4gQW5pbWF0aW9uS2V5LlxyXG4gICAgICAgICAgZi5zZXRLZXlPdXQgPSB0aGlzLmtleXNbMF07XHJcbiAgICAgICAgICB0aGlzLmtleXNbMF0uZnVuY3Rpb25JbiA9IGY7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgZi5zZXRLZXlPdXQgPSB0aGlzLmtleXNbaSArIDFdO1xyXG4gICAgICAgIHRoaXMua2V5c1tpICsgMV0uZnVuY3Rpb25JbiA9IGY7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBFeHRlbnNpb24gb2YgQXVkaW9CdWZmZXIgd2l0aCBhIGxvYWQgbWV0aG9kIHRoYXQgY3JlYXRlcyBhIGJ1ZmZlciBpbiB0aGUgW1tBdWRpb01hbmFnZXJdXS5kZWZhdWx0IHRvIGJlIHVzZWQgd2l0aCBbW0NvbXBvbmVudEF1ZGlvXV1cclxuICAgKiBAYXV0aG9ycyBUaG9tYXMgRG9ybmVyLCBIRlUsIDIwMTkgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBBdWRpbyBleHRlbmRzIEF1ZGlvQnVmZmVyIHtcclxuICAgIC8qKlxyXG4gICAgICogQXN5bmNocm9ub3VzbHkgbG9hZHMgdGhlIGF1ZGlvIChtcDMpIGZyb20gdGhlIGdpdmVuIHVybFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIGxvYWQoX3VybDogc3RyaW5nKTogUHJvbWlzZTxBdWRpbz4ge1xyXG4gICAgICBjb25zdCByZXNwb25zZTogUmVzcG9uc2UgPSBhd2FpdCB3aW5kb3cuZmV0Y2goX3VybCk7XHJcbiAgICAgIGNvbnN0IGFycmF5QnVmZmVyOiBBcnJheUJ1ZmZlciA9IGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XHJcbiAgICAgIHJldHVybiA8QXVkaW8+KGF3YWl0IEF1ZGlvTWFuYWdlci5kZWZhdWx0LmRlY29kZUF1ZGlvRGF0YShhcnJheUJ1ZmZlcikpO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEV4dGVuZHMgdGhlIHN0YW5kYXJkIEF1ZGlvQ29udGV4dCBmb3IgaW50ZWdyYXRpb24gd2l0aCBbW05vZGVdXS1icmFuY2hlcy5cclxuICAgKiBDcmVhdGVzIGEgZGVmYXVsdCBvYmplY3QgYXQgc3RhcnR1cCB0byBiZSBhZGRyZXNzZWQgYXMgQXVkaW9NYW5hZ2VyIGRlZmF1bHQuXHJcbiAgICogT3RoZXIgb2JqZWN0cyBvZiB0aGlzIGNsYXNzIG1heSBiZSBjcmVhdGUgZm9yIHNwZWNpYWwgcHVycG9zZXMuXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEF1ZGlvTWFuYWdlciBleHRlbmRzIEF1ZGlvQ29udGV4dCB7XHJcbiAgICAvKiogVGhlIGRlZmF1bHQgY29udGV4dCB0aGF0IG1heSBiZSB1c2VkIHRocm91Z2hvdXQgdGhlIHByb2plY3Qgd2l0aG91dCB0aGUgbmVlZCB0byBjcmVhdGUgb3RoZXJzICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGRlZmF1bHQ6IEF1ZGlvTWFuYWdlciA9IG5ldyBBdWRpb01hbmFnZXIoeyBsYXRlbmN5SGludDogXCJpbnRlcmFjdGl2ZVwiLCBzYW1wbGVSYXRlOiA0NDEwMCB9KTtcclxuICAgIC8qKiBUaGUgbWFzdGVyIHZvbHVtZSBhbGwgQXVkaW9Ob2RlcyBpbiB0aGUgY29udGV4dCBzaG91bGQgYXR0YWNoIHRvICovXHJcbiAgICBwdWJsaWMgcmVhZG9ubHkgZ2FpbjogR2Fpbk5vZGU7XHJcbiAgICBwcml2YXRlIGJyYW5jaDogTm9kZSA9IG51bGw7XHJcbiAgICBwcml2YXRlIGNtcExpc3RlbmVyOiBDb21wb25lbnRBdWRpb0xpc3RlbmVyID0gbnVsbDtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0T3B0aW9ucz86IEF1ZGlvQ29udGV4dE9wdGlvbnMpIHtcclxuICAgICAgc3VwZXIoY29udGV4dE9wdGlvbnMpO1xyXG4gICAgICB0aGlzLmdhaW4gPSB0aGlzLmNyZWF0ZUdhaW4oKTtcclxuICAgICAgdGhpcy5nYWluLmNvbm5lY3QodGhpcy5kZXN0aW5hdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIG1hc3RlciB2b2x1bWVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldCB2b2x1bWUoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5nYWluLmdhaW4udmFsdWUgPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIG1hc3RlciB2b2x1bWVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCB2b2x1bWUoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2Fpbi5nYWluLnZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lcyBicmFuY2ggdG8gbGlzdGVuIHRvLiBFYWNoIFtbQ29tcG9uZW50QXVkaW9dXSBpbiB0aGUgYnJhbmNoIHdpbGwgY29ubmVjdCB0byB0aGlzIGNvbnRleHRzIG1hc3RlciBnYWluLCBhbGwgb3RoZXJzIGRpc2Nvbm5lY3QuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBsaXN0ZW5UbyA9IChfYnJhbmNoOiBOb2RlIHwgbnVsbCk6IHZvaWQgPT4ge1xyXG4gICAgICBpZiAodGhpcy5icmFuY2gpXHJcbiAgICAgICAgdGhpcy5icmFuY2guYnJvYWRjYXN0RXZlbnQobmV3IEV2ZW50KEVWRU5UX0FVRElPLkNISUxEX1JFTU9WRSkpO1xyXG4gICAgICBpZiAoIV9icmFuY2gpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB0aGlzLmJyYW5jaCA9IF9icmFuY2g7XHJcbiAgICAgIHRoaXMuYnJhbmNoLmJyb2FkY2FzdEV2ZW50KG5ldyBFdmVudChFVkVOVF9BVURJTy5DSElMRF9BUFBFTkQpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlIHRoZSBicmFuY2ggY3VycmVudGx5IGxpc3RlbmluZyB0b1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0QnJhbmNoTGlzdGVuaW5nVG8gPSAoKTogTm9kZSA9PiB7XHJcbiAgICAgIHJldHVybiB0aGlzLmJyYW5jaDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgW1tDb21wb25lbnRBdWRpb0xpc3RlbmVyXV0gdGhhdCBzZXJ2ZXMgdGhlIHNwYXRpYWwgbG9jYXRpb24gYW5kIG9yaWVudGF0aW9uIGZvciB0aGlzIGNvbnRleHRzIGxpc3RlbmVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBsaXN0ZW4gPSAoX2NtcExpc3RlbmVyOiBDb21wb25lbnRBdWRpb0xpc3RlbmVyIHwgbnVsbCk6IHZvaWQgPT4ge1xyXG4gICAgICB0aGlzLmNtcExpc3RlbmVyID0gX2NtcExpc3RlbmVyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgc3BhdGlhbCBzZXR0aW5ncyBvZiB0aGUgQXVkaW9Ob2RlcyBlZmZlY3RlZCBpbiB0aGUgY3VycmVudCBicmFuY2hcclxuICAgICAqL1xyXG4gICAgcHVibGljIHVwZGF0ZSA9ICgpOiB2b2lkID0+IHtcclxuICAgICAgdGhpcy5icmFuY2guYnJvYWRjYXN0RXZlbnQobmV3IEV2ZW50KEVWRU5UX0FVRElPLlVQREFURSkpO1xyXG4gICAgICBpZiAodGhpcy5jbXBMaXN0ZW5lcilcclxuICAgICAgICB0aGlzLmNtcExpc3RlbmVyLnVwZGF0ZSh0aGlzLmxpc3RlbmVyKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCIvLyBuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAgIFxyXG4vLyAgICAgLyoqXHJcbi8vICAgICAgKiBFbnVtZXJhdG9yIGZvciBhbGwgcG9zc2libGUgT3NjaWxsYXRvciBUeXBlc1xyXG4vLyAgICAgICovXHJcbi8vICAgICB0eXBlIE9TQ0lMTEFUT1JfVFlQRSA9IFwic2luZVwiIHwgXCJzcXVhcmVcIiB8IFwic2F3dG9vdGhcIiB8IFwidHJpYW5nbGVcIiB8IFwiY3VzdG9tXCI7XHJcblxyXG4vLyAgICAgLyoqXHJcbi8vICAgICAgKiBJbnRlcmZhY2UgdG8gY3JlYXRlIEN1c3RvbSBPc2NpbGxhdG9yIFR5cGVzLlxyXG4vLyAgICAgICogU3RhcnQtL0VuZHBvaW50IG9mIGEgY3VzdHVtIGN1cnZlIGUuZy4gc2luZSBjdXJ2ZS5cclxuLy8gICAgICAqIEJvdGggcGFyYW1ldGVycyBuZWVkIHRvIGJlIGluYmV0d2VlbiAtMSBhbmQgMS5cclxuLy8gICAgICAqIEBwYXJhbSBzdGFydHBvaW50IHN0YXJ0cG9pbnQgb2YgYSBjdXJ2ZSBcclxuLy8gICAgICAqIEBwYXJhbSBlbmRwb2ludCBFbmRwb2ludCBvZiBhIGN1cnZlIFxyXG4vLyAgICAgICovXHJcbi8vICAgICBpbnRlcmZhY2UgT3NjaWxsYXRvcldhdmUge1xyXG4vLyAgICAgICAgIHN0YXJ0cG9pbnQ6IG51bWJlcjtcclxuLy8gICAgICAgICBlbmRwb2ludDogbnVtYmVyO1xyXG4vLyAgICAgfVxyXG4vLyAgICAgLyoqXHJcbi8vICAgICAgKiBBZGQgYW4gW1tBdWRpb0ZpbHRlcl1dIHRvIGFuIFtbQXVkaW9dXVxyXG4vLyAgICAgICogQGF1dGhvcnMgVGhvbWFzIERvcm5lciwgSEZVLCAyMDE5XHJcbi8vICAgICAgKi9cclxuLy8gICAgIGV4cG9ydCBjbGFzcyBBdWRpb09zY2lsbGF0b3Ige1xyXG5cclxuLy8gICAgICAgICBwdWJsaWMgYXVkaW9Pc2NpbGxhdG9yOiBPc2NpbGxhdG9yTm9kZTsgXHJcblxyXG4vLyAgICAgICAgIHByaXZhdGUgZnJlcXVlbmN5OiBudW1iZXI7XHJcbi8vICAgICAgICAgcHJpdmF0ZSBvc2NpbGxhdG9yVHlwZTogT1NDSUxMQVRPUl9UWVBFO1xyXG4vLyAgICAgICAgIHByaXZhdGUgb3NjaWxsYXRvcldhdmU6IFBlcmlvZGljV2F2ZTtcclxuXHJcbi8vICAgICAgICAgcHJpdmF0ZSBsb2NhbEdhaW46IEdhaW5Ob2RlO1xyXG4vLyAgICAgICAgIHByaXZhdGUgbG9jYWxHYWluVmFsdWU6IG51bWJlcjtcclxuXHJcbi8vICAgICAgICAgY29uc3RydWN0b3IoX2F1ZGlvU2V0dGluZ3M6IEF1ZGlvU2V0dGluZ3MsIF9vc2NpbGxhdG9yVHlwZT86IE9TQ0lMTEFUT1JfVFlQRSkge1xyXG4vLyAgICAgICAgICAgICB0aGlzLmF1ZGlvT3NjaWxsYXRvciA9IF9hdWRpb1NldHRpbmdzLmdldEF1ZGlvQ29udGV4dCgpLmNyZWF0ZU9zY2lsbGF0b3IoKTtcclxuLy8gICAgICAgICAgICAgdGhpcy5sb2NhbEdhaW4gPSBfYXVkaW9TZXR0aW5ncy5nZXRBdWRpb0NvbnRleHQoKS5jcmVhdGVHYWluKCk7XHJcbi8vICAgICAgICAgICAgIHRoaXMub3NjaWxsYXRvclR5cGUgPSBfb3NjaWxsYXRvclR5cGU7XHJcbi8vICAgICAgICAgICAgIGlmICh0aGlzLm9zY2lsbGF0b3JUeXBlICE9IFwiY3VzdG9tXCIpIHtcclxuLy8gICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9Pc2NpbGxhdG9yLnR5cGUgPSB0aGlzLm9zY2lsbGF0b3JUeXBlO1xyXG4vLyAgICAgICAgICAgICB9XHJcbi8vICAgICAgICAgICAgIGVsc2Uge1xyXG4vLyAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9zY2lsbGF0b3JXYXZlKSB7XHJcbi8vICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdWRpb09zY2lsbGF0b3Iuc2V0UGVyaW9kaWNXYXZlKHRoaXMub3NjaWxsYXRvcldhdmUpO1xyXG4vLyAgICAgICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbi8vICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJDcmVhdGUgYSBDdXN0b20gUGVyaW9kaWMgV2F2ZSBmaXJzdCB0byB1c2UgQ3VzdG9tIFR5cGVcIik7XHJcbi8vICAgICAgICAgICAgICAgICB9XHJcbi8vICAgICAgICAgICAgIH1cclxuLy8gICAgICAgICB9XHJcblxyXG4vLyAgICAgICAgIHB1YmxpYyBzZXRPc2NpbGxhdG9yVHlwZShfb3NjaWxsYXRvclR5cGU6IE9TQ0lMTEFUT1JfVFlQRSk6IHZvaWQge1xyXG4vLyAgICAgICAgICAgICBpZiAodGhpcy5vc2NpbGxhdG9yVHlwZSAhPSBcImN1c3RvbVwiKSB7XHJcbi8vICAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvT3NjaWxsYXRvci50eXBlID0gdGhpcy5vc2NpbGxhdG9yVHlwZTtcclxuLy8gICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgICAgICBlbHNlIHtcclxuLy8gICAgICAgICAgICAgICAgIGlmICghdGhpcy5vc2NpbGxhdG9yV2F2ZSkge1xyXG4vLyAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9Pc2NpbGxhdG9yLnNldFBlcmlvZGljV2F2ZSh0aGlzLm9zY2lsbGF0b3JXYXZlKTtcclxuLy8gICAgICAgICAgICAgICAgIH1cclxuLy8gICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgIH1cclxuXHJcbi8vICAgICAgICAgcHVibGljIGdldE9zY2lsbGF0b3JUeXBlKCk6IE9TQ0lMTEFUT1JfVFlQRSB7XHJcbi8vICAgICAgICAgICAgIHJldHVybiB0aGlzLm9zY2lsbGF0b3JUeXBlO1xyXG4vLyAgICAgICAgIH1cclxuXHJcbi8vICAgICAgICAgcHVibGljIGNyZWF0ZVBlcmlvZGljV2F2ZShfYXVkaW9TZXR0aW5nczogQXVkaW9TZXR0aW5ncywgX3JlYWw6IE9zY2lsbGF0b3JXYXZlLCBfaW1hZzogT3NjaWxsYXRvcldhdmUpOiB2b2lkIHtcclxuLy8gICAgICAgICAgICAgbGV0IHdhdmVSZWFsOiBGbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xyXG4vLyAgICAgICAgICAgICB3YXZlUmVhbFswXSA9IF9yZWFsLnN0YXJ0cG9pbnQ7XHJcbi8vICAgICAgICAgICAgIHdhdmVSZWFsWzFdID0gX3JlYWwuZW5kcG9pbnQ7XHJcblxyXG4vLyAgICAgICAgICAgICBsZXQgd2F2ZUltYWc6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XHJcbi8vICAgICAgICAgICAgIHdhdmVJbWFnWzBdID0gX2ltYWcuc3RhcnRwb2ludDtcclxuLy8gICAgICAgICAgICAgd2F2ZUltYWdbMV0gPSBfaW1hZy5lbmRwb2ludDtcclxuXHJcbi8vICAgICAgICAgICAgIHRoaXMub3NjaWxsYXRvcldhdmUgPSBfYXVkaW9TZXR0aW5ncy5nZXRBdWRpb0NvbnRleHQoKS5jcmVhdGVQZXJpb2RpY1dhdmUod2F2ZVJlYWwsIHdhdmVJbWFnKTtcclxuLy8gICAgICAgICB9XHJcblxyXG4vLyAgICAgICAgIHB1YmxpYyBzZXRMb2NhbEdhaW4oX2xvY2FsR2FpbjogR2Fpbk5vZGUpOiB2b2lkIHtcclxuLy8gICAgICAgICAgICAgdGhpcy5sb2NhbEdhaW4gPSBfbG9jYWxHYWluO1xyXG4vLyAgICAgICAgIH1cclxuXHJcbi8vICAgICAgICAgcHVibGljIGdldExvY2FsR2FpbigpOiBHYWluTm9kZSB7XHJcbi8vICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsR2FpbjtcclxuLy8gICAgICAgICB9XHJcblxyXG4vLyAgICAgICAgIHB1YmxpYyBzZXRMb2NhbEdhaW5WYWx1ZShfbG9jYWxHYWluVmFsdWU6IG51bWJlcik6IHZvaWQge1xyXG4vLyAgICAgICAgICAgICB0aGlzLmxvY2FsR2FpblZhbHVlID0gX2xvY2FsR2FpblZhbHVlO1xyXG4vLyAgICAgICAgICAgICB0aGlzLmxvY2FsR2Fpbi5nYWluLnZhbHVlID0gdGhpcy5sb2NhbEdhaW5WYWx1ZTtcclxuLy8gICAgICAgICB9XHJcblxyXG4vLyAgICAgICAgIHB1YmxpYyBnZXRMb2NhbEdhaW5WYWx1ZSgpOiBudW1iZXIge1xyXG4vLyAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbEdhaW5WYWx1ZTtcclxuLy8gICAgICAgICB9XHJcblxyXG4vLyAgICAgICAgIHB1YmxpYyBzZXRGcmVxdWVuY3koX2F1ZGlvU2V0dGluZ3M6IEF1ZGlvU2V0dGluZ3MsIF9mcmVxdWVuY3k6IG51bWJlcik6IHZvaWQge1xyXG4vLyAgICAgICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IF9mcmVxdWVuY3k7XHJcbi8vICAgICAgICAgICAgIHRoaXMuYXVkaW9Pc2NpbGxhdG9yLmZyZXF1ZW5jeS5zZXRWYWx1ZUF0VGltZSh0aGlzLmZyZXF1ZW5jeSwgX2F1ZGlvU2V0dGluZ3MuZ2V0QXVkaW9Db250ZXh0KCkuY3VycmVudFRpbWUpO1xyXG4vLyAgICAgICAgIH1cclxuXHJcbi8vICAgICAgICAgcHVibGljIGdldEZyZXF1ZW5jeSgpOiBudW1iZXIge1xyXG4vLyAgICAgICAgICAgICByZXR1cm4gdGhpcy5mcmVxdWVuY3k7XHJcbi8vICAgICAgICAgfVxyXG5cclxuLy8gICAgICAgICBwdWJsaWMgY3JlYXRlU25hcmUoX2F1ZGlvU2V0dGluZ3M6IEF1ZGlvU2V0dGluZ3MpOiB2b2lkIHtcclxuLy8gICAgICAgICAgICAgdGhpcy5zZXRPc2NpbGxhdG9yVHlwZShcInRyaWFuZ2xlXCIpO1xyXG4vLyAgICAgICAgICAgICB0aGlzLnNldEZyZXF1ZW5jeShfYXVkaW9TZXR0aW5ncywgMTAwKTtcclxuLy8gICAgICAgICAgICAgdGhpcy5zZXRMb2NhbEdhaW5WYWx1ZSgwKTtcclxuLy8gICAgICAgICAgICAgdGhpcy5sb2NhbEdhaW4uZ2Fpbi5zZXRWYWx1ZUF0VGltZSgwLCBfYXVkaW9TZXR0aW5ncy5nZXRBdWRpb0NvbnRleHQoKS5jdXJyZW50VGltZSk7XHJcbi8vICAgICAgICAgICAgIHRoaXMubG9jYWxHYWluLmdhaW4uZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZSgwLjAxLCBfYXVkaW9TZXR0aW5ncy5nZXRBdWRpb0NvbnRleHQoKS5jdXJyZW50VGltZSArIC4xKTtcclxuXHJcbi8vICAgICAgICAgICAgIHRoaXMuYXVkaW9Pc2NpbGxhdG9yLmNvbm5lY3QodGhpcy5sb2NhbEdhaW4pO1xyXG4vLyAgICAgICAgIH1cclxuLy8gICAgIH1cclxuLy8gfSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBIb2xkcyBkYXRhIHRvIGZlZWQgaW50byBhIFtbU2hhZGVyXV0gdG8gZGVzY3JpYmUgdGhlIHN1cmZhY2Ugb2YgW1tNZXNoXV0uICBcclxuICAgICAqIFtbTWF0ZXJpYWxdXXMgcmVmZXJlbmNlIFtbQ29hdF1dIGFuZCBbW1NoYWRlcl1dLiAgIFxyXG4gICAgICogVGhlIG1ldGhvZCB1c2VSZW5kZXJEYXRhIHdpbGwgYmUgaW5qZWN0ZWQgYnkgW1tSZW5kZXJJbmplY3Rvcl1dIGF0IHJ1bnRpbWUsIGV4dGVuZGluZyB0aGUgZnVuY3Rpb25hbGl0eSBvZiB0aGlzIGNsYXNzIHRvIGRlYWwgd2l0aCB0aGUgcmVuZGVyZXIuXHJcbiAgICAgKi9cclxuICAgIGV4cG9ydCBjbGFzcyBDb2F0IGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZSB7XHJcbiAgICAgICAgcHVibGljIG5hbWU6IHN0cmluZyA9IFwiQ29hdFwiO1xyXG4gICAgICAgIHByb3RlY3RlZCByZW5kZXJEYXRhOiB7W2tleTogc3RyaW5nXTogdW5rbm93bn07XHJcblxyXG4gICAgICAgIHB1YmxpYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgICAgICAgc3VwZXIubXV0YXRlKF9tdXRhdG9yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB1c2VSZW5kZXJEYXRhKF9yZW5kZXJTaGFkZXI6IFJlbmRlclNoYWRlcik6IHZvaWQgey8qIGluamVjdGVkIGJ5IFJlbmRlckluamVjdG9yKi8gfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgICAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gdGhpcy5nZXRNdXRhdG9yKCk7IFxyXG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVibGljIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogU2VyaWFsaXphYmxlIHtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKCk6IHZvaWQgeyAvKiovIH1cclxuICAgICAgICAvLyNlbmRyZWdpb25cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzaW1wbGVzdCBbW0NvYXRdXSBwcm92aWRpbmcganVzdCBhIGNvbG9yXHJcbiAgICAgKi9cclxuICAgIEBSZW5kZXJJbmplY3RvckNvYXQuZGVjb3JhdGVcclxuICAgIGV4cG9ydCBjbGFzcyBDb2F0Q29sb3JlZCBleHRlbmRzIENvYXQge1xyXG4gICAgICAgIHB1YmxpYyBjb2xvcjogQ29sb3I7XHJcblxyXG4gICAgICAgIGNvbnN0cnVjdG9yKF9jb2xvcj86IENvbG9yKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29sb3IgPSBfY29sb3IgfHwgbmV3IENvbG9yKDAuNSwgMC41LCAwLjUsIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgW1tDb2F0XV0gdG8gYmUgdXNlZCBieSB0aGUgTWF0Q2FwIFNoYWRlciBwcm92aWRpbmcgYSB0ZXh0dXJlLCBhIHRpbnQgY29sb3IgKDAuNSBncmV5IGlzIG5ldXRyYWwpXHJcbiAgICAgKiBhbmQgYSBmbGF0TWl4IG51bWJlciBmb3IgbWl4aW5nIGJldHdlZW4gc21vb3RoIGFuZCBmbGF0IHNoYWRpbmcuXHJcbiAgICAgKi9cclxuICAgIEBSZW5kZXJJbmplY3RvckNvYXQuZGVjb3JhdGVcclxuICAgIGV4cG9ydCBjbGFzcyBDb2F0TWF0Q2FwIGV4dGVuZHMgQ29hdCB7XHJcbiAgICAgICAgcHVibGljIHRleHR1cmU6IFRleHR1cmVJbWFnZSA9IG51bGw7XHJcbiAgICAgICAgcHVibGljIHRpbnRDb2xvcjogQ29sb3IgPSBuZXcgQ29sb3IoMC41LCAwLjUsIDAuNSwgMSk7XHJcbiAgICAgICAgcHVibGljIGZsYXRNaXg6IG51bWJlciA9IDAuNTtcclxuXHJcbiAgICAgICAgY29uc3RydWN0b3IoX3RleHR1cmU/OiBUZXh0dXJlSW1hZ2UsIF90aW50Y29sb3I/OiBDb2xvciwgX2ZsYXRtaXg/OiBudW1iZXIpIHtcclxuICAgICAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICAgICAgdGhpcy50ZXh0dXJlID0gX3RleHR1cmUgfHwgbmV3IFRleHR1cmVJbWFnZSgpO1xyXG4gICAgICAgICAgICB0aGlzLnRpbnRDb2xvciA9IF90aW50Y29sb3IgfHwgbmV3IENvbG9yKDAuNSwgMC41LCAwLjUsIDEpO1xyXG4gICAgICAgICAgICB0aGlzLmZsYXRNaXggPSBfZmxhdG1peCA+IDEuMCA/IHRoaXMuZmxhdE1peCA9IDEuMCA6IHRoaXMuZmxhdE1peCA9IF9mbGF0bWl4IHx8IDAuNTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBBIFtbQ29hdF1dIHByb3ZpZGluZyBhIHRleHR1cmUgYW5kIGFkZGl0aW9uYWwgZGF0YSBmb3IgdGV4dHVyaW5nXHJcbiAgICovXHJcbiAgQFJlbmRlckluamVjdG9yQ29hdC5kZWNvcmF0ZVxyXG4gIGV4cG9ydCBjbGFzcyBDb2F0VGV4dHVyZWQgZXh0ZW5kcyBDb2F0IHtcclxuICAgIHB1YmxpYyB0ZXh0dXJlOiBUZXh0dXJlSW1hZ2UgPSBudWxsO1xyXG4gICAgcHVibGljIHBpdm90OiBNYXRyaXgzeDMgPSBNYXRyaXgzeDMuSURFTlRJVFkoKTtcclxuICAgIC8vIGp1c3QgaWRlYXMgc28gZmFyXHJcbiAgICBwdWJsaWMgdGlsaW5nWDogbnVtYmVyO1xyXG4gICAgcHVibGljIHRpbGluZ1k6IG51bWJlcjtcclxuICAgIHB1YmxpYyByZXBldGl0aW9uOiBib29sZWFuO1xyXG5cclxuICAgIC8vIHB1YmxpYyBnZXRNdXRhdG9yRm9yQ29tcG9uZW50KCk6IE11dGF0b3JGb3JDb21wb25lbnQge1xyXG4gICAgLy8gICBsZXQgbXV0YXRvclBpdm90OiBNdXRhdG9yRm9yQ29tcG9uZW50ID0gPE11dGF0b3JGb3JDb21wb25lbnQ+PHVua25vd24+dGhpcy5waXZvdC5nZXRNdXRhdG9yKCk7XHJcbiAgICAvLyAgIHJldHVybiBtdXRhdG9yUGl2b3Q7XHJcbiAgICAvLyB9XHJcblxyXG4gICAgLy8gcHVibGljIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvckZvckNvbXBvbmVudCk6IHZvaWQge1xyXG4gICAgLy8gICB0aGlzLnBpdm90Lm11dGF0ZShfbXV0YXRvcik7XHJcbiAgICAvLyB9XHJcbiAgfVxyXG59IiwiLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9UcmFuc2Zlci9TZXJpYWxpemVyLnRzXCIvPlxyXG4vLyAvIDxyZWZlcmVuY2UgcGF0aD1cIi4uL1RyYW5zZmVyL011dGFibGUudHNcIi8+XHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKiBcclxuICAgKiBTdXBlcmNsYXNzIGZvciBhbGwgW1tDb21wb25lbnRdXXMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gW1tOb2RlXV1zLlxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIwIHwgSmFzY2hhIEthcmFnw7ZsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgQ29tcG9uZW50IGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZSB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IHN1YmNsYXNzZXM6IHR5cGVvZiBDb21wb25lbnRbXSA9IFtdO1xyXG5cclxuICAgIHByb3RlY3RlZCBzaW5nbGV0b246IGJvb2xlYW4gPSB0cnVlO1xyXG4gICAgcHJpdmF0ZSBjb250YWluZXI6IE5vZGUgfCBudWxsID0gbnVsbDtcclxuICAgIHByaXZhdGUgYWN0aXZlOiBib29sZWFuID0gdHJ1ZTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHJlZ2lzdGVyU3ViY2xhc3MoX3N1YmNsYXNzOiB0eXBlb2YgQ29tcG9uZW50KTogbnVtYmVyIHsgcmV0dXJuIENvbXBvbmVudC5zdWJjbGFzc2VzLnB1c2goX3N1YmNsYXNzKSAtIDE7IH1cclxuXHJcbiAgICBwdWJsaWMgYWN0aXZhdGUoX29uOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuYWN0aXZlID0gX29uO1xyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KF9vbiA/IEVWRU5ULkNPTVBPTkVOVF9BQ1RJVkFURSA6IEVWRU5ULkNPTVBPTkVOVF9ERUFDVElWQVRFKSk7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgZ2V0IGlzQWN0aXZlKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy5hY3RpdmU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJcyB0cnVlLCB3aGVuIG9ubHkgb25lIGluc3RhbmNlIG9mIHRoZSBjb21wb25lbnQgY2xhc3MgY2FuIGJlIGF0dGFjaGVkIHRvIGEgbm9kZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGlzU2luZ2xldG9uKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy5zaW5nbGV0b247XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyB0aGUgbm9kZSwgdGhpcyBjb21wb25lbnQgaXMgY3VycmVudGx5IGF0dGFjaGVkIHRvXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY29udGFpbmVyIG5vZGUgb3IgbnVsbCwgaWYgdGhlIGNvbXBvbmVudCBpcyBub3QgYXR0YWNoZWQgdG9cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldENvbnRhaW5lcigpOiBOb2RlIHwgbnVsbCB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJpZXMgdG8gYWRkIHRoZSBjb21wb25lbnQgdG8gdGhlIGdpdmVuIG5vZGUsIHJlbW92aW5nIGl0IGZyb20gdGhlIHByZXZpb3VzIGNvbnRhaW5lciBpZiBhcHBsaWNhYmxlXHJcbiAgICAgKiBAcGFyYW0gX2NvbnRhaW5lciBUaGUgbm9kZSB0byBhdHRhY2ggdGhpcyBjb21wb25lbnQgdG9cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldENvbnRhaW5lcihfY29udGFpbmVyOiBOb2RlIHwgbnVsbCk6IHZvaWQge1xyXG4gICAgICBpZiAodGhpcy5jb250YWluZXIgPT0gX2NvbnRhaW5lcilcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIGxldCBwcmV2aW91c0NvbnRhaW5lcjogTm9kZSA9IHRoaXMuY29udGFpbmVyO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGlmIChwcmV2aW91c0NvbnRhaW5lcilcclxuICAgICAgICAgIHByZXZpb3VzQ29udGFpbmVyLnJlbW92ZUNvbXBvbmVudCh0aGlzKTtcclxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IF9jb250YWluZXI7XHJcbiAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyKVxyXG4gICAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ29tcG9uZW50KHRoaXMpO1xyXG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcclxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IHByZXZpb3VzQ29udGFpbmVyO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge1xyXG4gICAgICAgIGFjdGl2ZTogdGhpcy5hY3RpdmVcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBTZXJpYWxpemFibGUge1xyXG4gICAgICB0aGlzLmFjdGl2ZSA9IF9zZXJpYWxpemF0aW9uLmFjdGl2ZTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLnNpbmdsZXRvbjtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLmNvbnRhaW5lcjtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gIH1cclxufSIsIi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vVGltZS9Mb29wLnRzXCIvPlxyXG4vLyAvIDxyZWZlcmVuY2UgcGF0aD1cIi4uL0FuaW1hdGlvbi9BbmltYXRpb24udHNcIi8+XHJcblxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBIb2xkcyBkaWZmZXJlbnQgcGxheW1vZGVzIHRoZSBhbmltYXRpb24gdXNlcyB0byBwbGF5IGJhY2sgaXRzIGFuaW1hdGlvbi5cclxuICAgKiBAYXV0aG9yIEx1a2FzIFNjaGV1ZXJsZSwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGVudW0gQU5JTUFUSU9OX1BMQVlNT0RFIHtcclxuICAgIC8qKlBsYXlzIGFuaW1hdGlvbiBpbiBhIGxvb3A6IGl0IHJlc3RhcnRzIG9uY2UgaXQgaGl0IHRoZSBlbmQuKi9cclxuICAgIExPT1AsXHJcbiAgICAvKipQbGF5cyBhbmltYXRpb24gb25jZSBhbmQgc3RvcHMgYXQgdGhlIGxhc3Qga2V5L2ZyYW1lKi9cclxuICAgIFBMQVlPTkNFLFxyXG4gICAgLyoqUGxheXMgYW5pbWF0aW9uIG9uY2UgYW5kIHN0b3BzIG9uIHRoZSBmaXJzdCBrZXkvZnJhbWUgKi9cclxuICAgIFBMQVlPTkNFU1RPUEFGVEVSLFxyXG4gICAgLyoqUGxheXMgYW5pbWF0aW9uIGxpa2UgTE9PUCwgYnV0IGJhY2t3YXJkcy4qL1xyXG4gICAgUkVWRVJTRUxPT1AsXHJcbiAgICAvKipDYXVzZXMgdGhlIGFuaW1hdGlvbiBub3QgdG8gcGxheSBhdCBhbGwuIFVzZWZ1bCBmb3IganVtcGluZyB0byB2YXJpb3VzIHBvc2l0aW9ucyBpbiB0aGUgYW5pbWF0aW9uIHdpdGhvdXQgcHJvY2VlZGluZyBpbiB0aGUgYW5pbWF0aW9uLiovXHJcbiAgICBTVE9QXHJcbiAgICAvL1RPRE86IGFkZCBhbiBJTkhFUklUIGFuZCBhIFBJTkdQT05HIG1vZGVcclxuICB9XHJcblxyXG4gIGV4cG9ydCBlbnVtIEFOSU1BVElPTl9QTEFZQkFDSyB7XHJcbiAgICAvL1RPRE86IGFkZCBhbiBpbi1kZXB0aCBkZXNjcmlwdGlvbiBvZiB3aGF0IGhhcHBlbnMgdG8gdGhlIGFuaW1hdGlvbiAoYW5kIGV2ZW50cykgZGVwZW5kaW5nIG9uIHRoZSBQbGF5YmFjay4gVXNlIEdyYXBocyB0byBleHBsYWluLlxyXG4gICAgLyoqQ2FsY3VsYXRlcyB0aGUgc3RhdGUgb2YgdGhlIGFuaW1hdGlvbiBhdCB0aGUgZXhhY3QgcG9zaXRpb24gb2YgdGltZS4gSWdub3JlcyBGUFMgdmFsdWUgb2YgYW5pbWF0aW9uLiovXHJcbiAgICBUSU1FQkFTRURfQ09OVElOT1VTLFxyXG4gICAgLyoqTGltaXRzIHRoZSBjYWxjdWxhdGlvbiBvZiB0aGUgc3RhdGUgb2YgdGhlIGFuaW1hdGlvbiB0byB0aGUgRlBTIHZhbHVlIG9mIHRoZSBhbmltYXRpb24uIFNraXBzIGZyYW1lcyBpZiBuZWVkZWQuKi9cclxuICAgIFRJTUVCQVNFRF9SQVNURVJFRF9UT19GUFMsXHJcbiAgICAvKipVc2VzIHRoZSBGUFMgdmFsdWUgb2YgdGhlIGFuaW1hdGlvbiB0byBhZHZhbmNlIG9uY2UgcGVyIGZyYW1lLCBubyBtYXR0ZXIgdGhlIHNwZWVkIG9mIHRoZSBmcmFtZXMuIERvZXNuJ3Qgc2tpcCBhbnkgZnJhbWVzLiovXHJcbiAgICBGUkFNRUJBU0VEXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBIb2xkcyBhIHJlZmVyZW5jZSB0byBhbiBbW0FuaW1hdGlvbl1dIGFuZCBjb250cm9scyBpdC4gQ29udHJvbHMgcGxheWJhY2sgYW5kIHBsYXltb2RlIGFzIHdlbGwgYXMgc3BlZWQuXHJcbiAgICogQGF1dGhvcnMgTHVrYXMgU2NoZXVlcmxlLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29tcG9uZW50QW5pbWF0b3IgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IENvbXBvbmVudC5yZWdpc3RlclN1YmNsYXNzKENvbXBvbmVudEFuaW1hdG9yKTtcclxuICAgIC8vVE9ETzogYWRkIGZ1bmN0aW9uYWxpdHkgdG8gYmxlbmQgZnJvbSBvbmUgYW5pbWF0aW9uIHRvIGFub3RoZXIuXHJcbiAgICBhbmltYXRpb246IEFuaW1hdGlvbjtcclxuICAgIHBsYXltb2RlOiBBTklNQVRJT05fUExBWU1PREU7XHJcbiAgICBwbGF5YmFjazogQU5JTUFUSU9OX1BMQVlCQUNLO1xyXG4gICAgc3BlZWRTY2FsZXNXaXRoR2xvYmFsU3BlZWQ6IGJvb2xlYW4gPSB0cnVlO1xyXG5cclxuICAgIHByaXZhdGUgbG9jYWxUaW1lOiBUaW1lO1xyXG4gICAgcHJpdmF0ZSBzcGVlZFNjYWxlOiBudW1iZXIgPSAxO1xyXG4gICAgcHJpdmF0ZSBsYXN0VGltZTogbnVtYmVyID0gMDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihfYW5pbWF0aW9uOiBBbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKFwiXCIpLCBfcGxheW1vZGU6IEFOSU1BVElPTl9QTEFZTU9ERSA9IEFOSU1BVElPTl9QTEFZTU9ERS5MT09QLCBfcGxheWJhY2s6IEFOSU1BVElPTl9QTEFZQkFDSyA9IEFOSU1BVElPTl9QTEFZQkFDSy5USU1FQkFTRURfQ09OVElOT1VTKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuYW5pbWF0aW9uID0gX2FuaW1hdGlvbjtcclxuICAgICAgdGhpcy5wbGF5bW9kZSA9IF9wbGF5bW9kZTtcclxuICAgICAgdGhpcy5wbGF5YmFjayA9IF9wbGF5YmFjaztcclxuXHJcbiAgICAgIHRoaXMubG9jYWxUaW1lID0gbmV3IFRpbWUoKTtcclxuXHJcbiAgICAgIC8vVE9ETzogdXBkYXRlIGFuaW1hdGlvbiB0b3RhbCB0aW1lIHdoZW4gbG9hZGluZyBhIGRpZmZlcmVudCBhbmltYXRpb24/XHJcbiAgICAgIHRoaXMuYW5pbWF0aW9uLmNhbGN1bGF0ZVRvdGFsVGltZSgpO1xyXG5cclxuICAgICAgTG9vcC5hZGRFdmVudExpc3RlbmVyKEVWRU5ULkxPT1BfRlJBTUUsIHRoaXMudXBkYXRlQW5pbWF0aW9uTG9vcC5iaW5kKHRoaXMpKTtcclxuICAgICAgVGltZS5nYW1lLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuVElNRV9TQ0FMRUQsIHRoaXMudXBkYXRlU2NhbGUuYmluZCh0aGlzKSk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IHNwZWVkKF9zOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5zcGVlZFNjYWxlID0gX3M7XHJcbiAgICAgIHRoaXMudXBkYXRlU2NhbGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEp1bXBzIHRvIGEgY2VydGFpbiB0aW1lIGluIHRoZSBhbmltYXRpb24gdG8gcGxheSBmcm9tIHRoZXJlLlxyXG4gICAgICogQHBhcmFtIF90aW1lIFRoZSB0aW1lIHRvIGp1bXAgdG9cclxuICAgICAqL1xyXG4gICAganVtcFRvKF90aW1lOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy5sb2NhbFRpbWUuc2V0KF90aW1lKTtcclxuICAgICAgdGhpcy5sYXN0VGltZSA9IF90aW1lO1xyXG4gICAgICBfdGltZSA9IF90aW1lICUgdGhpcy5hbmltYXRpb24udG90YWxUaW1lO1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHRoaXMuYW5pbWF0aW9uLmdldE11dGF0ZWQoX3RpbWUsIHRoaXMuY2FsY3VsYXRlRGlyZWN0aW9uKF90aW1lKSwgdGhpcy5wbGF5YmFjayk7XHJcbiAgICAgIHRoaXMuZ2V0Q29udGFpbmVyKCkuYXBwbHlBbmltYXRpb24obXV0YXRvcik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHRpbWUgb2YgdGhlIGFuaW1hdGlvbiwgbW9kdWxhdGVkIGZvciBhbmltYXRpb24gbGVuZ3RoLlxyXG4gICAgICovXHJcbiAgICBnZXRDdXJyZW50VGltZSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5sb2NhbFRpbWUuZ2V0KCkgJSB0aGlzLmFuaW1hdGlvbi50b3RhbFRpbWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3JjZXMgYW4gdXBkYXRlIG9mIHRoZSBhbmltYXRpb24gZnJvbSBvdXRzaWRlLiBVc2VkIGluIHRoZSBWaWV3QW5pbWF0aW9uLiBTaG91bGRuJ3QgYmUgdXNlZCBkdXJpbmcgdGhlIGdhbWUuXHJcbiAgICAgKiBAcGFyYW0gX3RpbWUgdGhlICh1bnNjYWxlZCkgdGltZSB0byB1cGRhdGUgdGhlIGFuaW1hdGlvbiB3aXRoLlxyXG4gICAgICogQHJldHVybnMgYSBUdXBlbCBjb250YWluaW5nIHRoZSBNdXRhdG9yIGZvciBBbmltYXRpb24gYW5kIHRoZSBwbGF5bW9kZSBjb3JyZWN0ZWQgdGltZS4gXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZUFuaW1hdGlvbihfdGltZTogbnVtYmVyKTogW011dGF0b3IsIG51bWJlcl0ge1xyXG4gICAgICByZXR1cm4gdGhpcy51cGRhdGVBbmltYXRpb25Mb29wKG51bGwsIF90aW1lKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gdHJhbnNmZXJcclxuICAgIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHM6IFNlcmlhbGl6YXRpb24gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgc1tcImFuaW1hdGlvblwiXSA9IHRoaXMuYW5pbWF0aW9uLnNlcmlhbGl6ZSgpO1xyXG4gICAgICBzW1wicGxheW1vZGVcIl0gPSB0aGlzLnBsYXltb2RlO1xyXG4gICAgICBzW1wicGxheWJhY2tcIl0gPSB0aGlzLnBsYXliYWNrO1xyXG4gICAgICBzW1wic3BlZWRTY2FsZVwiXSA9IHRoaXMuc3BlZWRTY2FsZTtcclxuICAgICAgc1tcInNwZWVkU2NhbGVzV2l0aEdsb2JhbFNwZWVkXCJdID0gdGhpcy5zcGVlZFNjYWxlc1dpdGhHbG9iYWxTcGVlZDtcclxuXHJcbiAgICAgIHNbc3VwZXIuY29uc3RydWN0b3IubmFtZV0gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuXHJcbiAgICAgIHJldHVybiBzO1xyXG4gICAgfVxyXG5cclxuICAgIGRlc2VyaWFsaXplKF9zOiBTZXJpYWxpemF0aW9uKTogU2VyaWFsaXphYmxlIHtcclxuICAgICAgdGhpcy5hbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKFwiXCIpO1xyXG4gICAgICB0aGlzLmFuaW1hdGlvbi5kZXNlcmlhbGl6ZShfcy5hbmltYXRpb24pO1xyXG4gICAgICB0aGlzLnBsYXliYWNrID0gX3MucGxheWJhY2s7XHJcbiAgICAgIHRoaXMucGxheW1vZGUgPSBfcy5wbGF5bW9kZTtcclxuICAgICAgdGhpcy5zcGVlZFNjYWxlID0gX3Muc3BlZWRTY2FsZTtcclxuICAgICAgdGhpcy5zcGVlZFNjYWxlc1dpdGhHbG9iYWxTcGVlZCA9IF9zLnNwZWVkU2NhbGVzV2l0aEdsb2JhbFNwZWVkO1xyXG5cclxuICAgICAgc3VwZXIuZGVzZXJpYWxpemUoX3Nbc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiB1cGRhdGVBbmltYXRpb25cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgQW5pbWF0aW9uLlxyXG4gICAgICogR2V0cyBjYWxsZWQgZXZlcnkgdGltZSB0aGUgTG9vcCBmaXJlcyB0aGUgTE9PUF9GUkFNRSBFdmVudC5cclxuICAgICAqIFVzZXMgdGhlIGJ1aWx0LWluIHRpbWUgdW5sZXNzIGEgZGlmZmVyZW50IHRpbWUgaXMgc3BlY2lmaWVkLlxyXG4gICAgICogTWF5IGFsc28gYmUgY2FsbGVkIGZyb20gdXBkYXRlQW5pbWF0aW9uKCkuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdXBkYXRlQW5pbWF0aW9uTG9vcChfZTogRXZlbnQsIF90aW1lOiBudW1iZXIpOiBbTXV0YXRvciwgbnVtYmVyXSB7XHJcbiAgICAgIGlmICh0aGlzLmFuaW1hdGlvbi50b3RhbFRpbWUgPT0gMClcclxuICAgICAgICByZXR1cm4gW251bGwsIDBdO1xyXG4gICAgICBsZXQgdGltZTogbnVtYmVyID0gX3RpbWUgfHwgdGhpcy5sb2NhbFRpbWUuZ2V0KCk7XHJcbiAgICAgIGlmICh0aGlzLnBsYXliYWNrID09IEFOSU1BVElPTl9QTEFZQkFDSy5GUkFNRUJBU0VEKSB7XHJcbiAgICAgICAgdGltZSA9IHRoaXMubGFzdFRpbWUgKyAoMTAwMCAvIHRoaXMuYW5pbWF0aW9uLmZwcyk7XHJcbiAgICAgIH1cclxuICAgICAgbGV0IGRpcmVjdGlvbjogbnVtYmVyID0gdGhpcy5jYWxjdWxhdGVEaXJlY3Rpb24odGltZSk7XHJcbiAgICAgIHRpbWUgPSB0aGlzLmFwcGx5UGxheW1vZGVzKHRpbWUpO1xyXG4gICAgICB0aGlzLmV4ZWN1dGVFdmVudHModGhpcy5hbmltYXRpb24uZ2V0RXZlbnRzVG9GaXJlKHRoaXMubGFzdFRpbWUsIHRpbWUsIHRoaXMucGxheWJhY2ssIGRpcmVjdGlvbikpO1xyXG5cclxuICAgICAgaWYgKHRoaXMubGFzdFRpbWUgIT0gdGltZSkge1xyXG4gICAgICAgIHRoaXMubGFzdFRpbWUgPSB0aW1lO1xyXG4gICAgICAgIHRpbWUgPSB0aW1lICUgdGhpcy5hbmltYXRpb24udG90YWxUaW1lO1xyXG4gICAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0gdGhpcy5hbmltYXRpb24uZ2V0TXV0YXRlZCh0aW1lLCBkaXJlY3Rpb24sIHRoaXMucGxheWJhY2spO1xyXG4gICAgICAgIGlmICh0aGlzLmdldENvbnRhaW5lcigpKSB7XHJcbiAgICAgICAgICB0aGlzLmdldENvbnRhaW5lcigpLmFwcGx5QW5pbWF0aW9uKG11dGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW211dGF0b3IsIHRpbWVdO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBbbnVsbCwgdGltZV07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlcyBhbGwgY3VzdG9tIGV2ZW50cyB0aGUgQW5pbWF0aW9uIHNob3VsZCBoYXZlIGZpcmVkIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IGZyYW1lLlxyXG4gICAgICogQHBhcmFtIGV2ZW50cyBhIGxpc3Qgb2YgbmFtZXMgb2YgY3VzdG9tIGV2ZW50cyB0byBmaXJlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZXhlY3V0ZUV2ZW50cyhldmVudHM6IHN0cmluZ1tdKTogdm9pZCB7XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KGV2ZW50c1tpXSkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBhY3R1YWwgdGltZSB0byB1c2UsIHVzaW5nIHRoZSBjdXJyZW50IHBsYXltb2Rlcy5cclxuICAgICAqIEBwYXJhbSBfdGltZSB0aGUgdGltZSB0byBhcHBseSB0aGUgcGxheW1vZGVzIHRvXHJcbiAgICAgKiBAcmV0dXJucyB0aGUgcmVjYWxjdWxhdGVkIHRpbWVcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBhcHBseVBsYXltb2RlcyhfdGltZTogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgICAgc3dpdGNoICh0aGlzLnBsYXltb2RlKSB7XHJcbiAgICAgICAgY2FzZSBBTklNQVRJT05fUExBWU1PREUuU1RPUDpcclxuICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsVGltZS5nZXRPZmZzZXQoKTtcclxuICAgICAgICBjYXNlIEFOSU1BVElPTl9QTEFZTU9ERS5QTEFZT05DRTpcclxuICAgICAgICAgIGlmIChfdGltZSA+PSB0aGlzLmFuaW1hdGlvbi50b3RhbFRpbWUpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGlvbi50b3RhbFRpbWUgLSAwLjAxOyAgICAgLy9UT0RPOiB0aGlzIG1pZ2h0IGNhdXNlIHNvbWUgaXNzdWVzXHJcbiAgICAgICAgICBlbHNlIHJldHVybiBfdGltZTtcclxuICAgICAgICBjYXNlIEFOSU1BVElPTl9QTEFZTU9ERS5QTEFZT05DRVNUT1BBRlRFUjpcclxuICAgICAgICAgIGlmIChfdGltZSA+PSB0aGlzLmFuaW1hdGlvbi50b3RhbFRpbWUpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGlvbi50b3RhbFRpbWUgKyAwLjAxOyAgICAgLy9UT0RPOiB0aGlzIG1pZ2h0IGNhdXNlIHNvbWUgaXNzdWVzXHJcbiAgICAgICAgICBlbHNlIHJldHVybiBfdGltZTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgcmV0dXJuIF90aW1lO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIGFuZCByZXR1cm5zIHRoZSBkaXJlY3Rpb24gdGhlIGFuaW1hdGlvbiBzaG91bGQgY3VycmVudGx5IGJlIHBsYXlpbmcgaW4uXHJcbiAgICAgKiBAcGFyYW0gX3RpbWUgdGhlIHRpbWUgYXQgd2hpY2ggdG8gY2FsY3VsYXRlIHRoZSBkaXJlY3Rpb25cclxuICAgICAqIEByZXR1cm5zIDEgaWYgZm9yd2FyZCwgMCBpZiBzdG9wLCAtMSBpZiBiYWNrd2FyZHNcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjYWxjdWxhdGVEaXJlY3Rpb24oX3RpbWU6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgIHN3aXRjaCAodGhpcy5wbGF5bW9kZSkge1xyXG4gICAgICAgIGNhc2UgQU5JTUFUSU9OX1BMQVlNT0RFLlNUT1A6XHJcbiAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAvLyBjYXNlIEFOSU1BVElPTl9QTEFZTU9ERS5QSU5HUE9ORzpcclxuICAgICAgICAvLyAgIGlmIChNYXRoLmZsb29yKF90aW1lIC8gdGhpcy5hbmltYXRpb24udG90YWxUaW1lKSAlIDIgPT0gMClcclxuICAgICAgICAvLyAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgLy8gICBlbHNlXHJcbiAgICAgICAgLy8gICAgIHJldHVybiAtMTtcclxuICAgICAgICBjYXNlIEFOSU1BVElPTl9QTEFZTU9ERS5SRVZFUlNFTE9PUDpcclxuICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICBjYXNlIEFOSU1BVElPTl9QTEFZTU9ERS5QTEFZT05DRTpcclxuICAgICAgICBjYXNlIEFOSU1BVElPTl9QTEFZTU9ERS5QTEFZT05DRVNUT1BBRlRFUjpcclxuICAgICAgICAgIGlmIChfdGltZSA+PSB0aGlzLmFuaW1hdGlvbi50b3RhbFRpbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBzY2FsZSBvZiB0aGUgYW5pbWF0aW9uIGlmIHRoZSB1c2VyIGNoYW5nZXMgaXQgb3IgaWYgdGhlIGdsb2JhbCBnYW1lIHRpbWVyIGNoYW5nZWQgaXRzIHNjYWxlLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHVwZGF0ZVNjYWxlKCk6IHZvaWQge1xyXG4gICAgICBsZXQgbmV3U2NhbGU6IG51bWJlciA9IHRoaXMuc3BlZWRTY2FsZTtcclxuICAgICAgaWYgKHRoaXMuc3BlZWRTY2FsZXNXaXRoR2xvYmFsU3BlZWQpXHJcbiAgICAgICAgbmV3U2NhbGUgKj0gVGltZS5nYW1lLmdldFNjYWxlKCk7XHJcbiAgICAgIHRoaXMubG9jYWxUaW1lLnNldFNjYWxlKG5ld1NjYWxlKTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBlbnVtIEFVRElPX1BBTk5FUiB7XHJcbiAgICBDT05FX0lOTkVSX0FOR0xFID0gXCJjb25lSW5uZXJBbmdsZVwiLFxyXG4gICAgQ09ORV9PVVRFUl9BTkdMRSA9IFwiY29uZU91dGVyQW5nbGVcIixcclxuICAgIENPTkVfT1VURVJfR0FJTiA9IFwiY29uZU91dGVyR2FpblwiLFxyXG4gICAgRElTVEFOQ0VfTU9ERUwgPSBcImRpc3RhbmNlTW9kZWxcIixcclxuICAgIE1BWF9ESVNUQU5DRSA9IFwibWF4RGlzdGFuY2VcIixcclxuICAgIFBBTk5JTkdfTU9ERUwgPSBcInBhbm5pbmdNb2RlbFwiLFxyXG4gICAgUkVGX0RJU1RBTkNFID0gXCJyZWZEaXN0YW5jZVwiLFxyXG4gICAgUk9MTE9GRl9GQUNUT1IgPSBcInJvbGxvZmZGYWN0b3JcIlxyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGVudW0gQVVESU9fTk9ERV9UWVBFIHtcclxuICAgIFNPVVJDRSwgUEFOTkVSLCBHQUlOXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBCdWlsZHMgYSBtaW5pbWFsIGF1ZGlvIGdyYXBoIChieSBkZWZhdWx0IGluIFtbQXVkaW9NYW5hZ2VyXV0uZGVmYXVsdCkgYW5kIHN5bmNocm9uaXplcyBpdCB3aXRoIHRoZSBjb250YWluaW5nIFtbTm9kZV1dXHJcbiAgICogYGBgcGxhaW50ZXh0XHJcbiAgICog4pSMIEF1ZGlvTWFuYWdlciguZGVmYXVsdCkg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXHJcbiAgICog4pSCIOKUjCBDb21wb25lbnRBdWRpbyDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJAgICAgICAgICAg4pSCXHJcbiAgICog4pSCIOKUgiAgICDilIzilIDilIDilIDilIDilIDilIDilJAgICDilIzilIDilIDilIDilIDilIDilIDilJAgICDilIzilIDilIDilIDilIDilIDilIDilJAg4pSCIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUkCDilIIgIFxyXG4gICAqIOKUgiDilIIgICAg4pSCc291cmNl4pSCIOKGkiDilIJwYW5uZXLilIIg4oaSIOKUgiBnYWluIOKUgiDihpIg4pSCIGdhaW4g4pSCIOKUglxyXG4gICAqIOKUgiDilIIgICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSYICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSYICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSYIOKUgiDilJTilIDilIDilIDilIDilIDilIDilJgg4pSCICBcclxuICAgKiDilIIg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYICAgICAgICAgIOKUglxyXG4gICAqIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxyXG4gICAqIGBgYFxyXG4gICAqIEBhdXRob3JzIFRob21hcyBEb3JuZXIsIEhGVSwgMjAxOSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIENvbXBvbmVudEF1ZGlvIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRBdWRpbyk7XHJcbiAgICAvKiogcGxhY2VzIGFuZCBkaXJlY3RzIHRoZSBwYW5uZXIgcmVsYXRpdmUgdG8gdGhlIHdvcmxkIHRyYW5zZm9ybSBvZiB0aGUgW1tOb2RlXV0gICovXHJcbiAgICBwdWJsaWMgcGl2b3Q6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpO1xyXG4gICAgXHJcbiAgICBwcm90ZWN0ZWQgc2luZ2xldG9uOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBcclxuICAgIHByaXZhdGUgZ2FpbjogR2Fpbk5vZGU7XHJcbiAgICBwcml2YXRlIHBhbm5lcjogUGFubmVyTm9kZTtcclxuICAgIHByaXZhdGUgc291cmNlOiBBdWRpb0J1ZmZlclNvdXJjZU5vZGU7XHJcbiAgICBwcml2YXRlIGF1ZGlvTWFuYWdlcjogQXVkaW9NYW5hZ2VyO1xyXG4gICAgcHJpdmF0ZSBwbGF5aW5nOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBwcml2YXRlIGxpc3RlbmVkOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgY29uc3RydWN0b3IoX2F1ZGlvOiBBdWRpbyA9IG51bGwsIF9sb29wOiBib29sZWFuID0gZmFsc2UsIF9zdGFydDogYm9vbGVhbiA9IGZhbHNlLCBfYXVkaW9NYW5hZ2VyOiBBdWRpb01hbmFnZXIgPSBBdWRpb01hbmFnZXIuZGVmYXVsdCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLmluc3RhbGwoX2F1ZGlvTWFuYWdlcik7XHJcbiAgICAgIHRoaXMuY3JlYXRlU291cmNlKF9hdWRpbywgX2xvb3ApO1xyXG5cclxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULkNPTVBPTkVOVF9BREQsIHRoaXMuaGFuZGxlQXR0YWNoKTtcclxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULkNPTVBPTkVOVF9SRU1PVkUsIHRoaXMuaGFuZGxlQXR0YWNoKTtcclxuXHJcbiAgICAgIGlmIChfc3RhcnQpXHJcbiAgICAgICAgdGhpcy5wbGF5KF9zdGFydCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldCBhdWRpbyhfYXVkaW86IEF1ZGlvKSB7XHJcbiAgICAgIHRoaXMuc291cmNlLmJ1ZmZlciA9IF9hdWRpbztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGF1ZGlvKCk6IEF1ZGlvIHtcclxuICAgICAgcmV0dXJuIDxBdWRpbz50aGlzLnNvdXJjZS5idWZmZXI7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldCB2b2x1bWUoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5nYWluLmdhaW4udmFsdWUgPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCB2b2x1bWUoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2Fpbi5nYWluLnZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBwcm9wZXJ0eSBvZiB0aGUgcGFubmVyIHRvIHRoZSBnaXZlbiB2YWx1ZS4gVXNlIHRvIG1hbmlwdWxhdGUgcmFuZ2UgYW5kIHJvbGxvZmYgZXRjLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0UGFubmVyKF9wcm9wZXJ0eTogQVVESU9fUEFOTkVSLCBfdmFsdWU6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMucGFubmVyLCB7IFtfcHJvcGVydHldOiBfdmFsdWUgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETzogbWF5IGJlIHVzZWQgZm9yIHNlcmlhbGl6YXRpb24gb2YgQXVkaW9Ob2Rlc1xyXG4gICAgcHVibGljIGdldE11dGF0b3JPZk5vZGUoX3R5cGU6IEFVRElPX05PREVfVFlQRSk6IE11dGF0b3Ige1xyXG4gICAgICBsZXQgbm9kZTogQXVkaW9Ob2RlID0gdGhpcy5nZXRBdWRpb05vZGUoX3R5cGUpO1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IGdldE11dGF0b3JPZkFyYml0cmFyeShub2RlKTtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzcGVjaWZpZWQgQXVkaW9Ob2RlIG9mIHRoZSBzdGFuZGFyZCBncmFwaCBmb3IgZnVydGhlciBtYW5pcHVsYXRpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEF1ZGlvTm9kZShfdHlwZTogQVVESU9fTk9ERV9UWVBFKTogQXVkaW9Ob2RlIHtcclxuICAgICAgc3dpdGNoIChfdHlwZSkge1xyXG4gICAgICAgIGNhc2UgQVVESU9fTk9ERV9UWVBFLlNPVVJDRTogcmV0dXJuIHRoaXMuc291cmNlO1xyXG4gICAgICAgIGNhc2UgQVVESU9fTk9ERV9UWVBFLlBBTk5FUjogcmV0dXJuIHRoaXMucGFubmVyO1xyXG4gICAgICAgIGNhc2UgQVVESU9fTk9ERV9UWVBFLkdBSU46IHJldHVybiB0aGlzLmdhaW47XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0IG9yIHN0b3AgcGxheWluZyB0aGUgYXVkaW9cclxuICAgICAqL1xyXG4gICAgcHVibGljIHBsYXkoX29uOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgIGlmIChfb24pIHtcclxuICAgICAgICB0aGlzLmNyZWF0ZVNvdXJjZSh0aGlzLmF1ZGlvLCB0aGlzLnNvdXJjZS5sb29wKTtcclxuICAgICAgICB0aGlzLnNvdXJjZS5zdGFydCgwLCAwKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlXHJcbiAgICAgICAgdGhpcy5zb3VyY2Uuc3RvcCgpO1xyXG4gICAgICB0aGlzLnBsYXlpbmcgPSBfb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBpc1BsYXlpbmcoKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLnBsYXlpbmc7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgZ2V0IGlzQXR0YWNoZWQoKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldENvbnRhaW5lcigpICE9IG51bGw7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgZ2V0IGlzTGlzdGVuZWQoKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnNlcnRzIEF1ZGlvTm9kZXMgYmV0d2VlbiB0aGUgcGFubmVyIGFuZCB0aGUgbG9jYWwgZ2FpbiBvZiB0aGlzIFtbQ29tcG9uZW50QXVkaW9dXVxyXG4gICAgICogX2lucHV0IGFuZCBfb3V0cHV0IG1heSBiZSB0aGUgc2FtZSBBdWRpb05vZGUsIGlmIHRoZXJlIGlzIG9ubHkgb25lIHRvIGluc2VydCxcclxuICAgICAqIG9yIG1heSBoYXZlIG11bHRpcGxlIEF1ZGlvTm9kZSBiZXR3ZWVuIHRoZW0gdG8gY3JlYXRlIGFuIGVmZmVjdC1ncmFwaC5cXFxyXG4gICAgICogTm90ZSB0aGF0IFtbQ29tcG9uZW50QXVkaW9dXSBkb2VzIG5vdCBrZWVwIHRyYWNrIG9mIGluc2VydGVkIEF1ZGlvTm9kZXMhXHJcbiAgICAgKiBgYGBwbGFpbnRleHRcclxuICAgICAqIOKUjCBBdWRpb01hbmFnZXIoLmRlZmF1bHQpIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxyXG4gICAgICog4pSCIOKUjCBDb21wb25lbnRBdWRpbyDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJAgICAgICAgICAg4pSCXHJcbiAgICAgKiDilIIg4pSCICAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgICAgICAgICDilIzilIDilIDilIDilIDilIDilIDilIDilJAgICDilIzilIDilIDilIDilIDilIDilIDilJAg4pSCIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUkCDilIIgIFxyXG4gICAgICog4pSCIOKUgiAgICDilIJzb3VyY2XilIIg4oaSIOKUgnBhbm5lcuKUgiDihpIg4pSCX2lucHV04pSCIOKGkiAuLi4gIOKGkiDilIJfb3V0cHV04pSCIOKGkiDilIIgZ2FpbiDilIIg4oaSIOKUgiBnYWluIOKUgiDilIJcclxuICAgICAqIOKUgiDilIIgICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSYICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSYICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSYICAgICAgICAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUmCDilIIg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSYIOKUgiAgXHJcbiAgICAgKiDilIIg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYICAgICAgICAgIOKUglxyXG4gICAgICog4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGluc2VydEF1ZGlvTm9kZXMoX2lucHV0OiBBdWRpb05vZGUsIF9vdXRwdXQ6IEF1ZGlvTm9kZSk6IHZvaWQge1xyXG4gICAgICB0aGlzLnBhbm5lci5kaXNjb25uZWN0KDApO1xyXG4gICAgICBpZiAoIV9pbnB1dCAmJiAhX291dHB1dCkge1xyXG4gICAgICAgIHRoaXMucGFubmVyLmNvbm5lY3QodGhpcy5nYWluKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5wYW5uZXIuY29ubmVjdChfaW5wdXQpO1xyXG4gICAgICBfb3V0cHV0LmNvbm5lY3QodGhpcy5nYWluKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFjdGl2YXRlIG92ZXJyaWRlLiBDb25uZWN0cyBvciBkaXNjb25uZWN0cyBBdWRpb05vZGVzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhY3RpdmF0ZShfb246IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgc3VwZXIuYWN0aXZhdGUoX29uKTtcclxuICAgICAgdGhpcy51cGRhdGVDb25uZWN0aW9uKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25uZWN0cyB0aGlzIGNvbXBvbmVudHMgZ2Fpbi1ub2RlIHRvIHRoZSBnYWluIG5vZGUgb2YgdGhlIEF1ZGlvTWFuYWdlciB0aGlzIGNvbXBvbmVudCBydW5zIG9uLlxyXG4gICAgICogT25seSBjYWxsIHRoaXMgbWV0aG9kIGlmIHRoZSBjb21wb25lbnQgaXMgbm90IGF0dGFjaGVkIHRvIGEgW1tOb2RlXV0gYnV0IG5lZWRzIHRvIGJlIGhlYXJkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29ubmVjdChfb246IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgaWYgKF9vbilcclxuICAgICAgICB0aGlzLmdhaW4uY29ubmVjdCh0aGlzLmF1ZGlvTWFuYWdlci5nYWluKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHRoaXMuZ2Fpbi5kaXNjb25uZWN0KHRoaXMuYXVkaW9NYW5hZ2VyLmdhaW4pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaW5zdGFsbChfYXVkaW9NYW5hZ2VyOiBBdWRpb01hbmFnZXIgPSBBdWRpb01hbmFnZXIuZGVmYXVsdCk6IHZvaWQge1xyXG4gICAgICBsZXQgYWN0aXZlOiBib29sZWFuID0gdGhpcy5pc0FjdGl2ZTtcclxuICAgICAgdGhpcy5hY3RpdmF0ZShmYWxzZSk7XHJcbiAgICAgIHRoaXMuYXVkaW9NYW5hZ2VyID0gX2F1ZGlvTWFuYWdlcjtcclxuICAgICAgdGhpcy5wYW5uZXIgPSBfYXVkaW9NYW5hZ2VyLmNyZWF0ZVBhbm5lcigpO1xyXG4gICAgICB0aGlzLmdhaW4gPSBfYXVkaW9NYW5hZ2VyLmNyZWF0ZUdhaW4oKTtcclxuICAgICAgdGhpcy5wYW5uZXIuY29ubmVjdCh0aGlzLmdhaW4pO1xyXG4gICAgICB0aGlzLmdhaW4uY29ubmVjdChfYXVkaW9NYW5hZ2VyLmdhaW4pO1xyXG4gICAgICB0aGlzLmFjdGl2YXRlKGFjdGl2ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBjcmVhdGVTb3VyY2UoX2F1ZGlvOiBBdWRpbywgX2xvb3A6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgaWYgKHRoaXMuc291cmNlKSB7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgIHRoaXMuc291cmNlLmJ1ZmZlciA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5zb3VyY2UgPSB0aGlzLmF1ZGlvTWFuYWdlci5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcclxuICAgICAgdGhpcy5zb3VyY2UuY29ubmVjdCh0aGlzLnBhbm5lcik7XHJcblxyXG4gICAgICBpZiAoX2F1ZGlvKVxyXG4gICAgICAgIHRoaXMuYXVkaW8gPSBfYXVkaW87XHJcbiAgICAgIHRoaXMuc291cmNlLmxvb3AgPSBfbG9vcDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHVwZGF0ZUNvbm5lY3Rpb24oKTogdm9pZCB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0KHRoaXMuaXNBY3RpdmUgJiYgdGhpcy5pc0F0dGFjaGVkICYmIHRoaXMubGlzdGVuZWQpO1xyXG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcclxuICAgICAgICAvLyBub3BcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEF1dG9tYXRpY2FsbHkgY29ubmVjdHMvZGlzY29ubmVjdHMgQXVkaW9Ob2RlcyB3aGVuIGFkZGluZy9yZW1vdmluZyB0aGlzIGNvbXBvbmVudCB0by9mcm9tIGEgbm9kZS4gXHJcbiAgICAgKiBUaGVyZWZvcmUgdW51c2VkIEF1ZGlvTm9kZXMgbWF5IGJlIGdhcmJhZ2UgY29sbGVjdGVkIHdoZW4gYW4gdW51c2VkIGNvbXBvbmVudCBpcyBjb2xsZWN0ZWRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBoYW5kbGVBdHRhY2ggPSAoX2V2ZW50OiBFdmVudCk6IHZvaWQgPT4ge1xyXG4gICAgICAvLyBEZWJ1Zy5sb2coX2V2ZW50KTtcclxuICAgICAgaWYgKF9ldmVudC50eXBlID09IEVWRU5ULkNPTVBPTkVOVF9BREQpIHtcclxuICAgICAgICB0aGlzLmdldENvbnRhaW5lcigpLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRfQVVESU8uQ0hJTERfQVBQRU5ELCB0aGlzLmhhbmRsZUJyYW5jaCwgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5nZXRDb250YWluZXIoKS5hZGRFdmVudExpc3RlbmVyKEVWRU5UX0FVRElPLkNISUxEX1JFTU9WRSwgdGhpcy5oYW5kbGVCcmFuY2gsIHRydWUpO1xyXG4gICAgICAgIHRoaXMuZ2V0Q29udGFpbmVyKCkuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVF9BVURJTy5VUERBVEUsIHRoaXMudXBkYXRlLCB0cnVlKTtcclxuICAgICAgICB0aGlzLmxpc3RlbmVkID0gdGhpcy5nZXRDb250YWluZXIoKS5pc0Rlc2NlbmRhbnRPZihBdWRpb01hbmFnZXIuZGVmYXVsdC5nZXRCcmFuY2hMaXN0ZW5pbmdUbygpKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICB0aGlzLmdldENvbnRhaW5lcigpLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlRfQVVESU8uQ0hJTERfQVBQRU5ELCB0aGlzLmhhbmRsZUJyYW5jaCwgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5nZXRDb250YWluZXIoKS5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5UX0FVRElPLkNISUxEX1JFTU9WRSwgdGhpcy5oYW5kbGVCcmFuY2gsIHRydWUpO1xyXG4gICAgICAgIHRoaXMuZ2V0Q29udGFpbmVyKCkucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVF9BVURJTy5VUERBVEUsIHRoaXMudXBkYXRlLCB0cnVlKTtcclxuICAgICAgICB0aGlzLmxpc3RlbmVkID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy51cGRhdGVDb25uZWN0aW9uKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQXV0b21hdGljYWxseSBjb25uZWN0cy9kaXNjb25uZWN0cyBBdWRpb05vZGVzIHdoZW4gYXBwZW5kaW5nL3JlbW92aW5nIHRoZSBicmFuY2ggdGhlIGNvbXBvbmVudCBpcyBpbi4gXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgaGFuZGxlQnJhbmNoID0gKF9ldmVudDogRXZlbnQpOiB2b2lkID0+IHtcclxuICAgICAgLy8gRGVidWcubG9nKF9ldmVudCk7XHJcbiAgICAgIHRoaXMubGlzdGVuZWQgPSAoX2V2ZW50LnR5cGUgPT0gRVZFTlRfQVVESU8uQ0hJTERfQVBQRU5EKTtcclxuICAgICAgdGhpcy51cGRhdGVDb25uZWN0aW9uKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogVXBkYXRlcyB0aGUgcGFubmVyIG5vZGUsIGl0cyBwb3NpdGlvbiBhbmQgZGlyZWN0aW9uLCB1c2luZyB0aGUgd29ybGRtYXRyaXggb2YgdGhlIGNvbnRhaW5lciBhbmQgdGhlIHBpdm90IG9mIHRoaXMgY29tcG9uZW50LiBcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSB1cGRhdGUgPSAoX2V2ZW50OiBFdmVudCk6IHZvaWQgPT4ge1xyXG4gICAgICBsZXQgbXR4UmVzdWx0OiBNYXRyaXg0eDQgPSB0aGlzLnBpdm90O1xyXG4gICAgICBpZiAodGhpcy5nZXRDb250YWluZXIoKSlcclxuICAgICAgICBtdHhSZXN1bHQgPSBNYXRyaXg0eDQuTVVMVElQTElDQVRJT04odGhpcy5nZXRDb250YWluZXIoKS5tdHhXb3JsZCwgdGhpcy5waXZvdCk7XHJcblxyXG4gICAgICAvLyBEZWJ1Zy5sb2cobXR4UmVzdWx0LnRvU3RyaW5nKCkpO1xyXG4gICAgICBsZXQgcG9zaXRpb246IFZlY3RvcjMgPSBtdHhSZXN1bHQudHJhbnNsYXRpb247XHJcbiAgICAgIGxldCBmb3J3YXJkOiBWZWN0b3IzID0gVmVjdG9yMy5UUkFOU0ZPUk1BVElPTihWZWN0b3IzLlooMSksIG10eFJlc3VsdCwgZmFsc2UpO1xyXG5cclxuICAgICAgdGhpcy5wYW5uZXIucG9zaXRpb25YLnZhbHVlID0gcG9zaXRpb24ueDtcclxuICAgICAgdGhpcy5wYW5uZXIucG9zaXRpb25ZLnZhbHVlID0gcG9zaXRpb24ueTtcclxuICAgICAgdGhpcy5wYW5uZXIucG9zaXRpb25aLnZhbHVlID0gcG9zaXRpb24uejtcclxuXHJcbiAgICAgIHRoaXMucGFubmVyLm9yaWVudGF0aW9uWC52YWx1ZSA9IGZvcndhcmQueDtcclxuICAgICAgdGhpcy5wYW5uZXIub3JpZW50YXRpb25ZLnZhbHVlID0gZm9yd2FyZC55O1xyXG4gICAgICB0aGlzLnBhbm5lci5vcmllbnRhdGlvbloudmFsdWUgPSBmb3J3YXJkLno7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogU2VydmVzIHRvIHNldCB0aGUgc3BhdGlhbCBsb2NhdGlvbiBhbmQgb3JpZW50YXRpb24gb2YgQXVkaW9MaXN0ZW5lcnMgcmVsYXRpdmUgdG8gdGhlXHJcbiAgICogd29ybGQgdHJhbnNmb3JtIG9mIHRoZSBbW05vZGVdXSBpdCBpcyBhdHRhY2hlZCB0by5cclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb21wb25lbnRBdWRpb0xpc3RlbmVyIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRBdWRpb0xpc3RlbmVyKTtcclxuICAgIHB1YmxpYyBwaXZvdDogTWF0cml4NHg0ID0gTWF0cml4NHg0LklERU5USVRZKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBwb3NpdGlvbiBhbmQgb3JpZW50YXRpb24gb2YgdGhlIGdpdmVuIEF1ZGlvTGlzdGVuZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIHVwZGF0ZShfbGlzdGVuZXI6IEF1ZGlvTGlzdGVuZXIpOiB2b2lkIHtcclxuICAgICAgbGV0IG10eFJlc3VsdDogTWF0cml4NHg0ID0gdGhpcy5waXZvdDtcclxuICAgICAgaWYgKHRoaXMuZ2V0Q29udGFpbmVyKCkpXHJcbiAgICAgICAgbXR4UmVzdWx0ID0gTWF0cml4NHg0Lk1VTFRJUExJQ0FUSU9OKHRoaXMuZ2V0Q29udGFpbmVyKCkubXR4V29ybGQsIHRoaXMucGl2b3QpO1xyXG5cclxuICAgICAgLy8gRGVidWcubG9nKG10eFJlc3VsdC50b1N0cmluZygpKTtcclxuICAgICAgbGV0IHBvc2l0aW9uOiBWZWN0b3IzID0gbXR4UmVzdWx0LnRyYW5zbGF0aW9uO1xyXG4gICAgICBsZXQgZm9yd2FyZDogVmVjdG9yMyA9IFZlY3RvcjMuVFJBTlNGT1JNQVRJT04oVmVjdG9yMy5aKDEpLCBtdHhSZXN1bHQsIGZhbHNlKTtcclxuICAgICAgbGV0IHVwOiBWZWN0b3IzID0gVmVjdG9yMy5UUkFOU0ZPUk1BVElPTihWZWN0b3IzLlkoKSwgbXR4UmVzdWx0LCBmYWxzZSk7XHJcblxyXG4gICAgICBfbGlzdGVuZXIucG9zaXRpb25YLnZhbHVlID0gcG9zaXRpb24ueDtcclxuICAgICAgX2xpc3RlbmVyLnBvc2l0aW9uWS52YWx1ZSA9IHBvc2l0aW9uLnk7XHJcbiAgICAgIF9saXN0ZW5lci5wb3NpdGlvbloudmFsdWUgPSBwb3NpdGlvbi56O1xyXG5cclxuICAgICAgX2xpc3RlbmVyLmZvcndhcmRYLnZhbHVlID0gZm9yd2FyZC54O1xyXG4gICAgICBfbGlzdGVuZXIuZm9yd2FyZFkudmFsdWUgPSBmb3J3YXJkLnk7XHJcbiAgICAgIF9saXN0ZW5lci5mb3J3YXJkWi52YWx1ZSA9IGZvcndhcmQuejtcclxuXHJcbiAgICAgIF9saXN0ZW5lci51cFgudmFsdWUgPSB1cC54O1xyXG4gICAgICBfbGlzdGVuZXIudXBZLnZhbHVlID0gdXAueTtcclxuICAgICAgX2xpc3RlbmVyLnVwWi52YWx1ZSA9IHVwLno7XHJcblxyXG4gICAgICAvLyBEZWJ1Zy5sb2cobXR4UmVzdWx0LnRyYW5zbGF0aW9uLnRvU3RyaW5nKCksIGZvcndhcmQudG9TdHJpbmcoKSwgdXAudG9TdHJpbmcoKSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsIi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiQ29tcG9uZW50LnRzXCIvPlxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgZW51bSBGSUVMRF9PRl9WSUVXIHtcclxuICAgIEhPUklaT05UQUwsIFZFUlRJQ0FMLCBESUFHT05BTFxyXG4gIH1cclxuICAvKipcclxuICAgKiBEZWZpbmVzIGlkZW50aWZpZXJzIGZvciB0aGUgdmFyaW91cyBwcm9qZWN0aW9ucyBhIGNhbWVyYSBjYW4gcHJvdmlkZS4gIFxyXG4gICAqIFRPRE86IGNoYW5nZSBiYWNrIHRvIG51bWJlciBlbnVtIGlmIHN0cmluZ3Mgbm90IG5lZWRlZFxyXG4gICAqL1xyXG4gIGV4cG9ydCBlbnVtIFBST0pFQ1RJT04ge1xyXG4gICAgQ0VOVFJBTCA9IFwiY2VudHJhbFwiLFxyXG4gICAgT1JUSE9HUkFQSElDID0gXCJvcnRob2dyYXBoaWNcIixcclxuICAgIERJTUVUUklDID0gXCJkaW1ldHJpY1wiLFxyXG4gICAgU1RFUkVPID0gXCJzdGVyZW9cIlxyXG4gIH1cclxuICAvKipcclxuICAgKiBUaGUgY2FtZXJhIGNvbXBvbmVudCBob2xkcyB0aGUgcHJvamVjdGlvbi1tYXRyaXggYW5kIG90aGVyIGRhdGEgbmVlZGVkIHRvIHJlbmRlciBhIHNjZW5lIGZyb20gdGhlIHBlcnNwZWN0aXZlIG9mIHRoZSBub2RlIGl0IGlzIGF0dGFjaGVkIHRvLlxyXG4gICAqIEBhdXRob3JzIEphc2NoYSBLYXJhZ8O2bCwgSEZVLCAyMDE5IHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29tcG9uZW50Q2FtZXJhIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRDYW1lcmEpO1xyXG4gICAgcHVibGljIHBpdm90OiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKTtcclxuICAgIHB1YmxpYyBiYWNrZ3JvdW5kQ29sb3I6IENvbG9yID0gbmV3IENvbG9yKDAsIDAsIDAsIDEpOyAvLyBUaGUgY29sb3Igb2YgdGhlIGJhY2tncm91bmQgdGhlIGNhbWVyYSB3aWxsIHJlbmRlci5cclxuICAgIC8vcHJpdmF0ZSBvcnRob2dyYXBoaWM6IGJvb2xlYW4gPSBmYWxzZTsgLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBpbWFnZSB3aWxsIGJlIHJlbmRlcmVkIHdpdGggcGVyc3BlY3RpdmUgb3Igb3J0aG9ncmFwaGljIHByb2plY3Rpb24uXHJcbiAgICBwcml2YXRlIHByb2plY3Rpb246IFBST0pFQ1RJT04gPSBQUk9KRUNUSU9OLkNFTlRSQUw7XHJcbiAgICBwcml2YXRlIHRyYW5zZm9ybTogTWF0cml4NHg0ID0gbmV3IE1hdHJpeDR4NDsgLy8gVGhlIG1hdHJpeCB0byBtdWx0aXBseSBlYWNoIHNjZW5lIG9iamVjdHMgdHJhbnNmb3JtYXRpb24gYnksIHRvIGRldGVybWluZSB3aGVyZSBpdCB3aWxsIGJlIGRyYXduLlxyXG4gICAgcHJpdmF0ZSBmaWVsZE9mVmlldzogbnVtYmVyID0gNDU7IC8vIFRoZSBjYW1lcmEncyBzZW5zb3JhbmdsZS5cclxuICAgIHByaXZhdGUgYXNwZWN0UmF0aW86IG51bWJlciA9IDEuMDtcclxuICAgIHByaXZhdGUgZGlyZWN0aW9uOiBGSUVMRF9PRl9WSUVXID0gRklFTERfT0ZfVklFVy5ESUFHT05BTDtcclxuICAgIHByaXZhdGUgYmFja2dyb3VuZEVuYWJsZWQ6IGJvb2xlYW4gPSB0cnVlOyAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHRoZSBiYWNrZ3JvdW5kIG9mIHRoaXMgY2FtZXJhIHdpbGwgYmUgcmVuZGVyZWQuXHJcbiAgICAvLyBUT0RPOiBleGFtaW5lLCBpZiBiYWNrZ3JvdW5kIHNob3VsZCBiZSBhbiBhdHRyaWJ1dGUgb2YgQ2FtZXJhIG9yIFZpZXdwb3J0XHJcblxyXG4gICAgcHVibGljIGdldFByb2plY3Rpb24oKTogUFJPSkVDVElPTiB7XHJcbiAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEJhY2tncm91bmRFbmFibGVkKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy5iYWNrZ3JvdW5kRW5hYmxlZDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0QXNwZWN0KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmFzcGVjdFJhdGlvO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRGaWVsZE9mVmlldygpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5maWVsZE9mVmlldztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0RGlyZWN0aW9uKCk6IEZJRUxEX09GX1ZJRVcge1xyXG4gICAgICByZXR1cm4gdGhpcy5kaXJlY3Rpb247XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBtdWx0aXBsaWthdGlvbiBvZiB0aGUgd29ybGR0cmFuc2Zvcm1hdGlvbiBvZiB0aGUgY2FtZXJhIGNvbnRhaW5lciB3aXRoIHRoZSBwcm9qZWN0aW9uIG1hdHJpeFxyXG4gICAgICogQHJldHVybnMgdGhlIHdvcmxkLXByb2plY3Rpb24tbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgVmlld1Byb2plY3Rpb25NYXRyaXgoKTogTWF0cml4NHg0IHtcclxuICAgICAgLy9UT0RPOiBvcHRpbWl6ZSwgbm8gbmVlZCB0byByZWNhbGN1bGF0ZSBpZiBuZWl0aGVyIG10eFdvcmxkIG5vciBwaXZvdCBoYXZlIGNoYW5nZWRcclxuICAgICAgbGV0IG10eENhbWVyYTogTWF0cml4NHg0ID0gdGhpcy5waXZvdDtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBtdHhDYW1lcmEgPSBNYXRyaXg0eDQuTVVMVElQTElDQVRJT04odGhpcy5nZXRDb250YWluZXIoKS5tdHhXb3JsZCwgdGhpcy5waXZvdCk7XHJcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xyXG4gICAgICAgIC8vIG5vIGNvbnRhaW5lciBub2RlIG9yIG5vIHdvcmxkIHRyYW5zZm9ybWF0aW9uIGZvdW5kIC0+IGNvbnRpbnVlIHdpdGggcGl2b3Qgb25seVxyXG4gICAgICB9XHJcbiAgICAgIGxldCBtdHhXb3JsZFByb2plY3Rpb246IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JTlZFUlNJT04obXR4Q2FtZXJhKTtcclxuICAgICAgbXR4V29ybGRQcm9qZWN0aW9uID0gTWF0cml4NHg0Lk1VTFRJUExJQ0FUSU9OKHRoaXMudHJhbnNmb3JtLCBtdHhXb3JsZFByb2plY3Rpb24pO1xyXG4gICAgICByZXR1cm4gbXR4V29ybGRQcm9qZWN0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBjYW1lcmEgdG8gcGVyc3BlY3RpdmUgcHJvamVjdGlvbi4gVGhlIHdvcmxkIG9yaWdpbiBpcyBpbiB0aGUgY2VudGVyIG9mIHRoZSBjYW52YXNlbGVtZW50LlxyXG4gICAgICogQHBhcmFtIF9hc3BlY3QgVGhlIGFzcGVjdCByYXRpbyBiZXR3ZWVuIHdpZHRoIGFuZCBoZWlnaHQgb2YgcHJvamVjdGlvbnNwYWNlLihEZWZhdWx0ID0gY2FudmFzLmNsaWVudFdpZHRoIC8gY2FudmFzLkNsaWVudEhlaWdodClcclxuICAgICAqIEBwYXJhbSBfZmllbGRPZlZpZXcgVGhlIGZpZWxkIG9mIHZpZXcgaW4gRGVncmVlcy4gKERlZmF1bHQgPSA0NSlcclxuICAgICAqIEBwYXJhbSBfZGlyZWN0aW9uIFRoZSBwbGFuZSBvbiB3aGljaCB0aGUgZmllbGRPZlZpZXctQW5nbGUgaXMgZ2l2ZW4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwcm9qZWN0Q2VudHJhbChfYXNwZWN0OiBudW1iZXIgPSB0aGlzLmFzcGVjdFJhdGlvLCBfZmllbGRPZlZpZXc6IG51bWJlciA9IHRoaXMuZmllbGRPZlZpZXcsIF9kaXJlY3Rpb246IEZJRUxEX09GX1ZJRVcgPSB0aGlzLmRpcmVjdGlvbik6IHZvaWQge1xyXG4gICAgICB0aGlzLmFzcGVjdFJhdGlvID0gX2FzcGVjdDtcclxuICAgICAgdGhpcy5maWVsZE9mVmlldyA9IF9maWVsZE9mVmlldztcclxuICAgICAgdGhpcy5kaXJlY3Rpb24gPSBfZGlyZWN0aW9uO1xyXG4gICAgICB0aGlzLnByb2plY3Rpb24gPSBQUk9KRUNUSU9OLkNFTlRSQUw7XHJcbiAgICAgIHRoaXMudHJhbnNmb3JtID0gTWF0cml4NHg0LlBST0pFQ1RJT05fQ0VOVFJBTChfYXNwZWN0LCB0aGlzLmZpZWxkT2ZWaWV3LCAxLCAyMDAwLCB0aGlzLmRpcmVjdGlvbik7IC8vIFRPRE86IHJlbW92ZSBtYWdpYyBudW1iZXJzXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgY2FtZXJhIHRvIG9ydGhvZ3JhcGhpYyBwcm9qZWN0aW9uLiBUaGUgb3JpZ2luIGlzIGluIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhcy5cclxuICAgICAqIEBwYXJhbSBfbGVmdCBUaGUgcG9zaXRpb252YWx1ZSBvZiB0aGUgcHJvamVjdGlvbnNwYWNlJ3MgbGVmdCBib3JkZXIuIChEZWZhdWx0ID0gMClcclxuICAgICAqIEBwYXJhbSBfcmlnaHQgVGhlIHBvc2l0aW9udmFsdWUgb2YgdGhlIHByb2plY3Rpb25zcGFjZSdzIHJpZ2h0IGJvcmRlci4gKERlZmF1bHQgPSBjYW52YXMuY2xpZW50V2lkdGgpXHJcbiAgICAgKiBAcGFyYW0gX2JvdHRvbSBUaGUgcG9zaXRpb252YWx1ZSBvZiB0aGUgcHJvamVjdGlvbnNwYWNlJ3MgYm90dG9tIGJvcmRlci4oRGVmYXVsdCA9IGNhbnZhcy5jbGllbnRIZWlnaHQpXHJcbiAgICAgKiBAcGFyYW0gX3RvcCBUaGUgcG9zaXRpb252YWx1ZSBvZiB0aGUgcHJvamVjdGlvbnNwYWNlJ3MgdG9wIGJvcmRlci4oRGVmYXVsdCA9IDApXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwcm9qZWN0T3J0aG9ncmFwaGljKF9sZWZ0OiBudW1iZXIgPSAwLCBfcmlnaHQ6IG51bWJlciA9IFJlbmRlck1hbmFnZXIuZ2V0Q2FudmFzKCkuY2xpZW50V2lkdGgsIF9ib3R0b206IG51bWJlciA9IFJlbmRlck1hbmFnZXIuZ2V0Q2FudmFzKCkuY2xpZW50SGVpZ2h0LCBfdG9wOiBudW1iZXIgPSAwKTogdm9pZCB7XHJcbiAgICAgIHRoaXMucHJvamVjdGlvbiA9IFBST0pFQ1RJT04uT1JUSE9HUkFQSElDO1xyXG4gICAgICB0aGlzLnRyYW5zZm9ybSA9IE1hdHJpeDR4NC5QUk9KRUNUSU9OX09SVEhPR1JBUEhJQyhfbGVmdCwgX3JpZ2h0LCBfYm90dG9tLCBfdG9wLCA0MDAsIC00MDApOyAvLyBUT0RPOiBleGFtaW5lIG1hZ2ljIG51bWJlcnMhXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIGNhbGN1bGF0ZWQgbm9ybWVkIGRpbWVuc2lvbiBvZiB0aGUgcHJvamVjdGlvbiBzdXJmYWNlLCB0aGF0IGlzIGluIHRoZSBoeXBvdGhldGljYWwgZGlzdGFuY2Ugb2YgMSB0byB0aGUgY2FtZXJhXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRQcm9qZWN0aW9uUmVjdGFuZ2xlKCk6IFJlY3RhbmdsZSB7XHJcbiAgICAgIGxldCB0YW5Gb3Y6IG51bWJlciA9IE1hdGgudGFuKE1hdGguUEkgKiB0aGlzLmZpZWxkT2ZWaWV3IC8gMzYwKTsgLy8gSGFsZiBvZiB0aGUgYW5nbGUsIHRvIGNhbGN1bGF0ZSBkaW1lbnNpb24gZnJvbSB0aGUgY2VudGVyIC0+IHJpZ2h0IGFuZ2xlXHJcbiAgICAgIGxldCB0YW5Ib3Jpem9udGFsOiBudW1iZXIgPSAwO1xyXG4gICAgICBsZXQgdGFuVmVydGljYWw6IG51bWJlciA9IDA7XHJcblxyXG4gICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT0gRklFTERfT0ZfVklFVy5ESUFHT05BTCkge1xyXG4gICAgICAgIGxldCBhc3BlY3Q6IG51bWJlciA9IE1hdGguc3FydCh0aGlzLmFzcGVjdFJhdGlvKTtcclxuICAgICAgICB0YW5Ib3Jpem9udGFsID0gdGFuRm92ICogYXNwZWN0O1xyXG4gICAgICAgIHRhblZlcnRpY2FsID0gdGFuRm92IC8gYXNwZWN0O1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKHRoaXMuZGlyZWN0aW9uID09IEZJRUxEX09GX1ZJRVcuVkVSVElDQUwpIHtcclxuICAgICAgICB0YW5WZXJ0aWNhbCA9IHRhbkZvdjtcclxuICAgICAgICB0YW5Ib3Jpem9udGFsID0gdGFuVmVydGljYWwgKiB0aGlzLmFzcGVjdFJhdGlvO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Ugey8vRk9WX0RJUkVDVElPTi5IT1JJWk9OVEFMXHJcbiAgICAgICAgdGFuSG9yaXpvbnRhbCA9IHRhbkZvdjtcclxuICAgICAgICB0YW5WZXJ0aWNhbCA9IHRhbkhvcml6b250YWwgLyB0aGlzLmFzcGVjdFJhdGlvO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gUmVjdGFuZ2xlLkdFVCgwLCAwLCB0YW5Ib3Jpem9udGFsICogMiwgdGFuVmVydGljYWwgKiAyKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcHJvamVjdChfcG9pbnRJbldvcmxkU3BhY2U6IFZlY3RvcjMpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMztcclxuICAgICAgcmVzdWx0ID0gVmVjdG9yMy5UUkFOU0ZPUk1BVElPTihfcG9pbnRJbldvcmxkU3BhY2UsIHRoaXMuVmlld1Byb2plY3Rpb25NYXRyaXgpO1xyXG4gICAgICBsZXQgbTogRmxvYXQzMkFycmF5ID0gdGhpcy5WaWV3UHJvamVjdGlvbk1hdHJpeC5nZXQoKTtcclxuICAgICAgbGV0IHc6IG51bWJlciA9IG1bM10gKiBfcG9pbnRJbldvcmxkU3BhY2UueCArIG1bN10gKiBfcG9pbnRJbldvcmxkU3BhY2UueSArIG1bMTFdICogX3BvaW50SW5Xb3JsZFNwYWNlLnogKyBtWzE1XTtcclxuICAgICAgcmVzdWx0LnNjYWxlKDEgLyB3KTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge1xyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5iYWNrZ3JvdW5kQ29sb3IsXHJcbiAgICAgICAgYmFja2dyb3VuZEVuYWJsZWQ6IHRoaXMuYmFja2dyb3VuZEVuYWJsZWQsXHJcbiAgICAgICAgcHJvamVjdGlvbjogdGhpcy5wcm9qZWN0aW9uLFxyXG4gICAgICAgIGZpZWxkT2ZWaWV3OiB0aGlzLmZpZWxkT2ZWaWV3LFxyXG4gICAgICAgIGRpcmVjdGlvbjogdGhpcy5kaXJlY3Rpb24sXHJcbiAgICAgICAgYXNwZWN0OiB0aGlzLmFzcGVjdFJhdGlvLFxyXG4gICAgICAgIHBpdm90OiB0aGlzLnBpdm90LnNlcmlhbGl6ZSgpLFxyXG4gICAgICAgIFtzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXTogc3VwZXIuc2VyaWFsaXplKClcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogU2VyaWFsaXphYmxlIHtcclxuICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBfc2VyaWFsaXphdGlvbi5iYWNrZ3JvdW5kQ29sb3I7XHJcbiAgICAgIHRoaXMuYmFja2dyb3VuZEVuYWJsZWQgPSBfc2VyaWFsaXphdGlvbi5iYWNrZ3JvdW5kRW5hYmxlZDtcclxuICAgICAgdGhpcy5wcm9qZWN0aW9uID0gX3NlcmlhbGl6YXRpb24ucHJvamVjdGlvbjtcclxuICAgICAgdGhpcy5maWVsZE9mVmlldyA9IF9zZXJpYWxpemF0aW9uLmZpZWxkT2ZWaWV3O1xyXG4gICAgICB0aGlzLmFzcGVjdFJhdGlvID0gX3NlcmlhbGl6YXRpb24uYXNwZWN0O1xyXG4gICAgICB0aGlzLmRpcmVjdGlvbiA9IF9zZXJpYWxpemF0aW9uLmRpcmVjdGlvbjtcclxuICAgICAgdGhpcy5waXZvdC5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5waXZvdCk7XHJcbiAgICAgIHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdKTtcclxuICAgICAgc3dpdGNoICh0aGlzLnByb2plY3Rpb24pIHtcclxuICAgICAgICBjYXNlIFBST0pFQ1RJT04uT1JUSE9HUkFQSElDOlxyXG4gICAgICAgICAgdGhpcy5wcm9qZWN0T3J0aG9ncmFwaGljKCk7IC8vIFRPRE86IHNlcmlhbGl6ZSBhbmQgZGVzZXJpYWxpemUgcGFyYW1ldGVyc1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBQUk9KRUNUSU9OLkNFTlRSQUw6XHJcbiAgICAgICAgICB0aGlzLnByb2plY3RDZW50cmFsKCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvckF0dHJpYnV0ZVR5cGVzKF9tdXRhdG9yOiBNdXRhdG9yKTogTXV0YXRvckF0dHJpYnV0ZVR5cGVzIHtcclxuICAgICAgbGV0IHR5cGVzOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMgPSBzdXBlci5nZXRNdXRhdG9yQXR0cmlidXRlVHlwZXMoX211dGF0b3IpO1xyXG4gICAgICBpZiAodHlwZXMuZGlyZWN0aW9uKVxyXG4gICAgICAgIHR5cGVzLmRpcmVjdGlvbiA9IEZJRUxEX09GX1ZJRVc7XHJcbiAgICAgIGlmICh0eXBlcy5wcm9qZWN0aW9uKVxyXG4gICAgICAgIHR5cGVzLnByb2plY3Rpb24gPSBQUk9KRUNUSU9OO1xyXG4gICAgICByZXR1cm4gdHlwZXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICBzdXBlci5tdXRhdGUoX211dGF0b3IpO1xyXG5cclxuICAgICAgc3dpdGNoICh0aGlzLnByb2plY3Rpb24pIHtcclxuICAgICAgICBjYXNlIFBST0pFQ1RJT04uQ0VOVFJBTDpcclxuICAgICAgICAgIHRoaXMucHJvamVjdENlbnRyYWwodGhpcy5hc3BlY3RSYXRpbywgdGhpcy5maWVsZE9mVmlldywgdGhpcy5kaXJlY3Rpb24pO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICBkZWxldGUgX211dGF0b3IudHJhbnNmb3JtO1xyXG4gICAgICBzdXBlci5yZWR1Y2VNdXRhdG9yKF9tdXRhdG9yKTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gIH1cclxufSIsIi8vIC88cmVmZXJlbmNlIHBhdGg9XCIuLi9MaWdodC9MaWdodC50c1wiLz5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgICAvKipcclxuICAgICAqIEF0dGFjaGVzIGEgW1tMaWdodF1dIHRvIHRoZSBub2RlXHJcbiAgICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIGlkZW50aWZpZXJzIGZvciB0aGUgdmFyaW91cyB0eXBlcyBvZiBsaWdodCB0aGlzIGNvbXBvbmVudCBjYW4gcHJvdmlkZS4gIFxyXG4gICAgICovXHJcbiAgICAvLyBleHBvcnQgZW51bSBMSUdIVF9UWVBFIHtcclxuICAgIC8vICAgICBBTUJJRU5UID0gXCJhbWJpZW50XCIsXHJcbiAgICAvLyAgICAgRElSRUNUSU9OQUwgPSBcImRpcmVjdGlvbmFsXCIsXHJcbiAgICAvLyAgICAgUE9JTlQgPSBcInBvaW50XCIsXHJcbiAgICAvLyAgICAgU1BPVCA9IFwic3BvdFwiXHJcbiAgICAvLyB9XHJcblxyXG4gICAgZXhwb3J0IGNsYXNzIENvbXBvbmVudExpZ2h0IGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IENvbXBvbmVudC5yZWdpc3RlclN1YmNsYXNzKENvbXBvbmVudExpZ2h0KTtcclxuICAgICAgICAvLyBwcml2YXRlIHN0YXRpYyBjb25zdHJ1Y3RvcnM6IHsgW3R5cGU6IHN0cmluZ106IEdlbmVyYWwgfSA9IHsgW0xJR0hUX1RZUEUuQU1CSUVOVF06IExpZ2h0QW1iaWVudCwgW0xJR0hUX1RZUEUuRElSRUNUSU9OQUxdOiBMaWdodERpcmVjdGlvbmFsLCBbTElHSFRfVFlQRS5QT0lOVF06IExpZ2h0UG9pbnQsIFtMSUdIVF9UWVBFLlNQT1RdOiBMaWdodFNwb3QgfTtcclxuICAgICAgICBwdWJsaWMgcGl2b3Q6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpO1xyXG4gICAgICAgIHB1YmxpYyBsaWdodDogTGlnaHQgPSBudWxsO1xyXG5cclxuICAgICAgICBjb25zdHJ1Y3RvcihfbGlnaHQ6IExpZ2h0ID0gbmV3IExpZ2h0QW1iaWVudCgpKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2luZ2xldG9uID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMubGlnaHQgPSBfbGlnaHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc2V0VHlwZTxUIGV4dGVuZHMgTGlnaHQ+KF9jbGFzczogbmV3ICgpID0+IFQpOiB2b2lkIHtcclxuICAgICAgICAgICAgbGV0IG10ck9sZDogTXV0YXRvciA9IHt9O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5saWdodClcclxuICAgICAgICAgICAgICAgIG10ck9sZCA9IHRoaXMubGlnaHQuZ2V0TXV0YXRvcigpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5saWdodCA9IG5ldyBfY2xhc3MoKTtcclxuICAgICAgICAgICAgdGhpcy5saWdodC5tdXRhdGUobXRyT2xkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgYSBbW01hdGVyaWFsXV0gdG8gdGhlIG5vZGVcclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb21wb25lbnRNYXRlcmlhbCBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gQ29tcG9uZW50LnJlZ2lzdGVyU3ViY2xhc3MoQ29tcG9uZW50TWF0ZXJpYWwpO1xyXG4gICAgcHVibGljIG1hdGVyaWFsOiBNYXRlcmlhbDtcclxuICAgIC8vIHB1YmxpYyBtdXRhdG9yQ29hdDogTXV0YXRvckZvckNvbXBvbmVudDtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX21hdGVyaWFsOiBNYXRlcmlhbCA9IG51bGwpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5tYXRlcmlhbCA9IF9tYXRlcmlhbDtcclxuICAgICAgLy8gdGhpcy5tdXRhdG9yQ29hdCA9IF9tYXRlcmlhbC5nZXRDb2F0KCkuZ2V0TXV0YXRvckZvckNvbXBvbmVudCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb247XHJcbiAgICAgIC8qIGF0IHRoaXMgcG9pbnQgb2YgdGltZSwgc2VyaWFsaXphdGlvbiBhcyByZXNvdXJjZSBhbmQgYXMgaW5saW5lIG9iamVjdCBpcyBwb3NzaWJsZS4gVE9ETzogY2hlY2sgaWYgaW5saW5lIGJlY29tZXMgb2Jzb2xldGUgKi9cclxuICAgICAgbGV0IGlkTWF0ZXJpYWw6IHN0cmluZyA9IHRoaXMubWF0ZXJpYWwuaWRSZXNvdXJjZTtcclxuICAgICAgaWYgKGlkTWF0ZXJpYWwpXHJcbiAgICAgICAgc2VyaWFsaXphdGlvbiA9IHsgaWRNYXRlcmlhbDogaWRNYXRlcmlhbCB9O1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgc2VyaWFsaXphdGlvbiA9IHsgbWF0ZXJpYWw6IFNlcmlhbGl6ZXIuc2VyaWFsaXplKHRoaXMubWF0ZXJpYWwpIH07XHJcblxyXG4gICAgICBzZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogU2VyaWFsaXphYmxlIHtcclxuICAgICAgbGV0IG1hdGVyaWFsOiBNYXRlcmlhbDtcclxuICAgICAgaWYgKF9zZXJpYWxpemF0aW9uLmlkTWF0ZXJpYWwpXHJcbiAgICAgICAgbWF0ZXJpYWwgPSA8TWF0ZXJpYWw+UmVzb3VyY2VNYW5hZ2VyLmdldChfc2VyaWFsaXphdGlvbi5pZE1hdGVyaWFsKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIG1hdGVyaWFsID0gPE1hdGVyaWFsPlNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24ubWF0ZXJpYWwpO1xyXG4gICAgICB0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWw7XHJcbiAgICAgIHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcHVibGljIGdldE11dGF0b3JGb3JVc2VySW50ZXJmYWNlKCk6IE11dGF0b3JGb3JVc2VySW50ZXJmYWNlIHtcclxuICAgIC8vICAgbGV0IG11dGF0b3JDb2F0OiBNdXRhdG9yRm9yQ29tcG9uZW50ID0gdGhpcy5tYXRlcmlhbC5nZXRDb2F0KCkuZ2V0TXV0YXRvckZvckNvbXBvbmVudCgpO1xyXG4gICAgLy8gICByZXR1cm4gPE11dGF0b3JGb3JVc2VySW50ZXJmYWNlPjx1bmtub3duPm11dGF0b3JDb2F0O1xyXG4gICAgLy8gfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgICAvKipcclxuICAgICAqIEF0dGFjaGVzIGEgW1tNZXNoXV0gdG8gdGhlIG5vZGVcclxuICAgICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICAgKi9cclxuICAgIGV4cG9ydCBjbGFzcyBDb21wb25lbnRNZXNoIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IENvbXBvbmVudC5yZWdpc3RlclN1YmNsYXNzKENvbXBvbmVudE1lc2gpO1xyXG4gICAgICAgIHB1YmxpYyBwaXZvdDogTWF0cml4NHg0ID0gTWF0cml4NHg0LklERU5USVRZKCk7XHJcbiAgICAgICAgcHVibGljIG1lc2g6IE1lc2ggPSBudWxsO1xyXG5cclxuICAgICAgICBwdWJsaWMgY29uc3RydWN0b3IoX21lc2g6IE1lc2ggPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgICAgIHRoaXMubWVzaCA9IF9tZXNoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICAgICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb247XHJcbiAgICAgICAgICAgIC8qIGF0IHRoaXMgcG9pbnQgb2YgdGltZSwgc2VyaWFsaXphdGlvbiBhcyByZXNvdXJjZSBhbmQgYXMgaW5saW5lIG9iamVjdCBpcyBwb3NzaWJsZS4gVE9ETzogY2hlY2sgaWYgaW5saW5lIGJlY29tZXMgb2Jzb2xldGUgKi9cclxuICAgICAgICAgICAgbGV0IGlkTWVzaDogc3RyaW5nID0gdGhpcy5tZXNoLmlkUmVzb3VyY2U7XHJcbiAgICAgICAgICAgIGlmIChpZE1lc2gpXHJcbiAgICAgICAgICAgICAgICBzZXJpYWxpemF0aW9uID0geyBpZE1lc2g6IGlkTWVzaCB9O1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBzZXJpYWxpemF0aW9uID0geyBtZXNoOiBTZXJpYWxpemVyLnNlcmlhbGl6ZSh0aGlzLm1lc2gpIH07XHJcblxyXG4gICAgICAgICAgICBzZXJpYWxpemF0aW9uLnBpdm90ID0gdGhpcy5waXZvdC5zZXJpYWxpemUoKTtcclxuICAgICAgICAgICAgc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFNlcmlhbGl6YWJsZSB7XHJcbiAgICAgICAgICAgIGxldCBtZXNoOiBNZXNoO1xyXG4gICAgICAgICAgICBpZiAoX3NlcmlhbGl6YXRpb24uaWRNZXNoKVxyXG4gICAgICAgICAgICAgICAgbWVzaCA9IDxNZXNoPlJlc291cmNlTWFuYWdlci5nZXQoX3NlcmlhbGl6YXRpb24uaWRNZXNoKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgbWVzaCA9IDxNZXNoPlNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24ubWVzaCk7XHJcbiAgICAgICAgICAgIHRoaXMubWVzaCA9IG1lc2g7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnBpdm90LmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLnBpdm90KTtcclxuICAgICAgICAgICAgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8jZW5kcmVnaW9uXHJcbiAgICB9XHJcbn1cclxuIiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQmFzZSBjbGFzcyBmb3Igc2NyaXB0cyB0aGUgdXNlciB3cml0ZXNcclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb21wb25lbnRTY3JpcHQgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgLy8gcmVnaXN0ZXJpbmcgdGhpcyBkb2Vzbid0IG1ha2Ugc2Vuc2UsIG9ubHkgaXRzIHN1YmNsYXNzZXMuIE9yIHRoaXMgY29tcG9uZW50IG11c3QgcmVmZXIgdG8gc2NyaXB0cyB0byBiZSBhdHRhY2hlZCB0byB0aGlzIGNvbXBvbmVudFxyXG4gICAgLy8gVE9ETzogcmV0aGluayAmIHJlZmFjdG9yXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gQ29tcG9uZW50LnJlZ2lzdGVyU3ViY2xhc3MoQ29tcG9uZW50U2NyaXB0KTtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLnNpbmdsZXRvbiA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldE11dGF0b3IoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBTZXJpYWxpemFibGUge1xyXG4gICAgICB0aGlzLm11dGF0ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIGEgdHJhbnNmb3JtLVtbTWF0cml4NHg0XV0gdG8gdGhlIG5vZGUsIG1vdmluZywgc2NhbGluZyBhbmQgcm90YXRpbmcgaXQgaW4gc3BhY2UgcmVsYXRpdmUgdG8gaXRzIHBhcmVudC5cclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb21wb25lbnRUcmFuc2Zvcm0gZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IENvbXBvbmVudC5yZWdpc3RlclN1YmNsYXNzKENvbXBvbmVudFRyYW5zZm9ybSk7XHJcbiAgICBwdWJsaWMgbG9jYWw6IE1hdHJpeDR4NDtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX21hdHJpeDogTWF0cml4NHg0ID0gTWF0cml4NHg0LklERU5USVRZKCkpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5sb2NhbCA9IF9tYXRyaXg7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHtcclxuICAgICAgICBsb2NhbDogdGhpcy5sb2NhbC5zZXJpYWxpemUoKSxcclxuICAgICAgICBbc3VwZXIuY29uc3RydWN0b3IubmFtZV06IHN1cGVyLnNlcmlhbGl6ZSgpXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogU2VyaWFsaXphYmxlIHtcclxuICAgICAgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xyXG4gICAgICB0aGlzLmxvY2FsLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLmxvY2FsKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcHVibGljIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgLy8gICAgIHRoaXMubG9jYWwubXV0YXRlKF9tdXRhdG9yKTtcclxuICAgIC8vIH1cclxuICAgIC8vIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3IgeyBcclxuICAgIC8vICAgICByZXR1cm4gdGhpcy5sb2NhbC5nZXRNdXRhdG9yKCk7XHJcbiAgICAvLyB9XHJcblxyXG4gICAgLy8gcHVibGljIGdldE11dGF0b3JBdHRyaWJ1dGVUeXBlcyhfbXV0YXRvcjogTXV0YXRvcik6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyB7XHJcbiAgICAvLyAgICAgbGV0IHR5cGVzOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMgPSB0aGlzLmxvY2FsLmdldE11dGF0b3JBdHRyaWJ1dGVUeXBlcyhfbXV0YXRvcik7XHJcbiAgICAvLyAgICAgcmV0dXJuIHR5cGVzO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci53b3JsZDtcclxuICAgICAgc3VwZXIucmVkdWNlTXV0YXRvcihfbXV0YXRvcik7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICB9XHJcbn1cclxuIiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGNvbnN0IGVudW0gRVZFTlRfQ09OVFJPTCB7XHJcbiAgICBJTlBVVCA9IFwiaW5wdXRcIixcclxuICAgIE9VVFBVVCA9IFwib3V0cHV0XCJcclxuICB9XHJcblxyXG4gIGV4cG9ydCBjb25zdCBlbnVtIEFYSVNfVFlQRSB7XHJcbiAgICBQUk9QT1JUSU9OQUwsIElOVEVHUkFMLCBESUZGRVJFTlRJQUxcclxuICB9XHJcblxyXG4gIGV4cG9ydCBjbGFzcyBBeGlzIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xyXG4gICAgcHVibGljIHJlYWRvbmx5IHR5cGU6IEFYSVNfVFlQRTtcclxuICAgIHByb3RlY3RlZCB2YWx1ZUJhc2U6IG51bWJlciA9IDA7XHJcbiAgICBwcm90ZWN0ZWQgaW5wdXRUYXJnZXQ6IG51bWJlciA9IDA7XHJcbiAgICBwcm90ZWN0ZWQgdmFsdWVQcmV2aW91czogbnVtYmVyID0gMDtcclxuICAgIHByb3RlY3RlZCBpbnB1dFByZXZpb3VzOiBudW1iZXIgPSAwO1xyXG4gICAgcHJvdGVjdGVkIHRpbWVJbnB1dERlbGF5OiBudW1iZXIgPSAwO1xyXG4gICAgcHJvdGVjdGVkIGZhY3RvcjogbnVtYmVyID0gMDtcclxuICAgIHByb3RlY3RlZCB0aW1lSW5wdXRUYXJnZXRTZXQ6IG51bWJlciA9IDA7XHJcblxyXG4gICAgcHJvdGVjdGVkIHRpbWU6IFRpbWUgPSBUaW1lLmdhbWU7XHJcblxyXG4gICAgY29uc3RydWN0b3IoX2ZhY3RvcjogbnVtYmVyID0gMSwgX3R5cGU6IEFYSVNfVFlQRSA9IEFYSVNfVFlQRS5QUk9QT1JUSU9OQUwpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5mYWN0b3IgPSBfZmFjdG9yO1xyXG4gICAgICB0aGlzLnR5cGUgPSBfdHlwZTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRUaW1lKF90aW1lOiBUaW1lKTogdm9pZCB7XHJcbiAgICAgIHRoaXMudGltZSA9IF90aW1lO1xyXG4gICAgICB0aGlzLmdldFZhbHVlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0SW5wdXQoX3RhcmdldDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIHRoaXMudmFsdWVCYXNlID0gdGhpcy5nZXRWYWx1ZSgpO1xyXG4gICAgICB0aGlzLmlucHV0UHJldmlvdXMgPSB0aGlzLmdldElucHV0RGVsYXllZCgpO1xyXG4gICAgICB0aGlzLmlucHV0VGFyZ2V0ID0gdGhpcy5mYWN0b3IgKiBfdGFyZ2V0O1xyXG4gICAgICB0aGlzLnRpbWVJbnB1dFRhcmdldFNldCA9IHRoaXMudGltZS5nZXQoKTtcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVF9DT05UUk9MLklOUFVUKSk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0RGVsYXkoX3RpbWU6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAvLyBUT0RPOiBjaGVjayBpZiB0aGlzIG5lZWRzIHRvIGJlIGRpc2FsbG93ZWQgZm9yIHR5cGUgRElGRkVSRU5USUFMXHJcbiAgICAgIHRoaXMudGltZUlucHV0RGVsYXkgPSBNYXRoLm1heCgwLCBfdGltZSk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0RmFjdG9yKF9mYWN0b3I6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICB0aGlzLmZhY3RvciA9IF9mYWN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFZhbHVlKCk6IG51bWJlciB7XHJcbiAgICAgIGxldCB2YWx1ZTogbnVtYmVyID0gMDtcclxuICAgICAgbGV0IGlucHV0OiBudW1iZXIgPSB0aGlzLmdldElucHV0RGVsYXllZCgpO1xyXG5cclxuICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcclxuICAgICAgICBjYXNlIEFYSVNfVFlQRS5JTlRFR1JBTDpcclxuICAgICAgICAgIGxldCB0aW1lQ3VycmVudDogbnVtYmVyID0gdGhpcy50aW1lLmdldCgpO1xyXG4gICAgICAgICAgbGV0IHRpbWVFbGFwc2VkU2luY2VJbnB1dDogbnVtYmVyID0gdGltZUN1cnJlbnQgLSB0aGlzLnRpbWVJbnB1dFRhcmdldFNldDtcclxuICAgICAgICAgIHZhbHVlID0gdGhpcy52YWx1ZUJhc2U7XHJcblxyXG4gICAgICAgICAgaWYgKHRoaXMudGltZUlucHV0RGVsYXkgPiAwKSB7XHJcbiAgICAgICAgICAgIGlmICh0aW1lRWxhcHNlZFNpbmNlSW5wdXQgPCB0aGlzLnRpbWVJbnB1dERlbGF5KSB7XHJcbiAgICAgICAgICAgICAgdmFsdWUgKz0gMC41ICogKHRoaXMuaW5wdXRQcmV2aW91cyArIGlucHV0KSAqIHRpbWVFbGFwc2VkU2luY2VJbnB1dDtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICB2YWx1ZSArPSAwLjUgKiAodGhpcy5pbnB1dFByZXZpb3VzICsgaW5wdXQpICogdGhpcy50aW1lSW5wdXREZWxheTtcclxuICAgICAgICAgICAgICB0aW1lRWxhcHNlZFNpbmNlSW5wdXQgLT0gdGhpcy50aW1lSW5wdXREZWxheTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdmFsdWUgKz0gaW5wdXQgKiB0aW1lRWxhcHNlZFNpbmNlSW5wdXQ7XHJcbiAgICAgICAgICAvLyB2YWx1ZSArPSAwLjUgKiAodGhpcy5pbnB1dFByZXZpb3VzIC0gaW5wdXQpICogdGhpcy50aW1lSW5wdXREZWxheSArIGlucHV0ICogdGltZUVsYXBzZWRTaW5jZUlucHV0O1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBBWElTX1RZUEUuRElGRkVSRU5USUFMOlxyXG4gICAgICAgICAgdmFsdWUgPSB0aGlzLnZhbHVlQmFzZSArIGlucHV0O1xyXG4gICAgICAgICAgdGhpcy5pbnB1dFRhcmdldCA9IDA7XHJcbiAgICAgICAgICB0aGlzLnZhbHVlQmFzZSA9IHZhbHVlO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBBWElTX1RZUEUuUFJPUE9SVElPTkFMOlxyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICB2YWx1ZSA9IGlucHV0O1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZ2V0SW5wdXREZWxheWVkKCk6IG51bWJlciB7XHJcbiAgICAgIGlmICh0aGlzLnRpbWVJbnB1dERlbGF5ID4gMCkge1xyXG4gICAgICAgIGxldCB0aW1lRWxhcHNlZFNpbmNlSW5wdXQ6IG51bWJlciA9IHRoaXMudGltZS5nZXQoKSAtIHRoaXMudGltZUlucHV0VGFyZ2V0U2V0O1xyXG4gICAgICAgIGlmICh0aW1lRWxhcHNlZFNpbmNlSW5wdXQgPCB0aGlzLnRpbWVJbnB1dERlbGF5KVxyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXRQcmV2aW91cyArICh0aGlzLmlucHV0VGFyZ2V0IC0gdGhpcy5pbnB1dFByZXZpb3VzKSAqIHRpbWVFbGFwc2VkU2luY2VJbnB1dCAvIHRoaXMudGltZUlucHV0RGVsYXk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMuaW5wdXRUYXJnZXQ7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwiLy8gPHJlZmVyZW5jZSBwYXRoPVwiRGVidWdBbGVydC50c1wiLz5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogVGhlIGZpbHRlcnMgY29ycmVzcG9uZGluZyB0byBkZWJ1ZyBhY3Rpdml0aWVzLCBtb3JlIHRvIGNvbWVcclxuICAgKi9cclxuICBleHBvcnQgZW51bSBERUJVR19GSUxURVIge1xyXG4gICAgTk9ORSA9IDB4MDAsXHJcbiAgICBJTkZPID0gMHgwMSxcclxuICAgIExPRyA9IDB4MDIsXHJcbiAgICBXQVJOID0gMHgwNCxcclxuICAgIEVSUk9SID0gMHgwOCxcclxuICAgIEZVREdFID0gMHgxMCxcclxuICAgIENMRUFSID0gMHgxMDAsXHJcbiAgICBHUk9VUCA9IDB4MTAxLFxyXG4gICAgR1JPVVBDT0xMQVBTRUQgPSAweDEwMixcclxuICAgIEdST1VQRU5EID0gMHgxMDQsXHJcbiAgICBNRVNTQUdFUyA9IElORk8gfCBMT0cgfCBXQVJOIHwgRVJST1IgfCBGVURHRSxcclxuICAgIEZPUk1BVCA9IENMRUFSIHwgR1JPVVAgfCBHUk9VUENPTExBUFNFRCB8IEdST1VQRU5ELFxyXG4gICAgQUxMID0gTUVTU0FHRVMgfCBGT1JNQVRcclxuICB9XHJcblxyXG4gIC8vIOKSviDik4Eg4pOMIOKSuiDimKAg4piiIOKaoCDinI4g4pyUIOKckyDinYwg4q2NIOKYiCDwn5uIIOKWoyDil6cg4pmiIOKZpiDimoIg4puLIOKdliDirJMg4qySIPCfjakg8J+NqyDwn42sIPCfjrIg4piVIPCfp4pcclxuICBleHBvcnQgY29uc3QgREVCVUdfU1lNQk9MOiB7IFtmaWx0ZXI6IG51bWJlcl06IHN0cmluZzsgfSA9IHtcclxuICAgIFtERUJVR19GSUxURVIuSU5GT106IFwi4pyTXCIsXHJcbiAgICBbREVCVUdfRklMVEVSLkxPR106IFwi4pyOXCIsXHJcbiAgICBbREVCVUdfRklMVEVSLldBUk5dOiBcIuKaoFwiLFxyXG4gICAgW0RFQlVHX0ZJTFRFUi5FUlJPUl06IFwi4p2MXCIsXHJcbiAgICBbREVCVUdfRklMVEVSLkZVREdFXTogXCLwn46yXCJcclxuICB9O1xyXG5cclxuICBleHBvcnQgdHlwZSBNYXBEZWJ1Z1RhcmdldFRvRGVsZWdhdGUgPSBNYXA8RGVidWdUYXJnZXQsIEZ1bmN0aW9uPjtcclxuICBleHBvcnQgaW50ZXJmYWNlIE1hcERlYnVnRmlsdGVyVG9EZWxlZ2F0ZSB7IFtmaWx0ZXI6IG51bWJlcl06IEZ1bmN0aW9uOyB9XHJcbn0iLCIvLyAvIDxyZWZlcmVuY2UgcGF0aD1cIkRlYnVnVGFyZ2V0LnRzXCIvPlxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBSb3V0aW5nIHRvIHRoZSBzdGFuZGFyZC1jb25zb2xlXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIERlYnVnQ29uc29sZSBleHRlbmRzIERlYnVnVGFyZ2V0IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgZGVsZWdhdGVzOiBNYXBEZWJ1Z0ZpbHRlclRvRGVsZWdhdGUgPSB7XHJcbiAgICAgIFtERUJVR19GSUxURVIuSU5GT106IGNvbnNvbGUuaW5mbyxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5MT0ddOiBjb25zb2xlLmxvZyxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5XQVJOXTogY29uc29sZS53YXJuLFxyXG4gICAgICBbREVCVUdfRklMVEVSLkVSUk9SXTogY29uc29sZS5lcnJvcixcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5GVURHRV06IERlYnVnQ29uc29sZS5mdWRnZSxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5DTEVBUl06IGNvbnNvbGUuY2xlYXIsXHJcbiAgICAgIFtERUJVR19GSUxURVIuR1JPVVBdOiBjb25zb2xlLmdyb3VwLFxyXG4gICAgICBbREVCVUdfRklMVEVSLkdST1VQQ09MTEFQU0VEXTogY29uc29sZS5ncm91cENvbGxhcHNlZCxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5HUk9VUEVORF06IGNvbnNvbGUuZ3JvdXBFbmRcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwbGF5cyBjcml0aWNhbCBpbmZvcm1hdGlvbiBhYm91dCBmYWlsdXJlcywgd2hpY2ggaXMgZW1waGFzaXplZCBlLmcuIGJ5IGNvbG9yXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZnVkZ2UoX21lc3NhZ2U6IE9iamVjdCwgLi4uX2FyZ3M6IE9iamVjdFtdKTogdm9pZCB7XHJcbiAgICAgIGNvbnNvbGUuZGVidWcoXCLwn46yXCIsIF9tZXNzYWdlLCAuLi5fYXJncyk7XHJcbiAgICAgIC8vIGxldCB0cmFjZTogc3RyaW5nW10gPSBuZXcgRXJyb3IoXCJUZXN0XCIpLnN0YWNrLnNwbGl0KFwiXFxuXCIpO1xyXG4gICAgICAvLyBjb25zb2xlLmxvZyh0cmFjZVs0XSk7XHJcbiAgICAgIC8vIGNvbnNvbGUudHJhY2UoXCJUZXN0XCIpO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiRGVidWdUYXJnZXQudHNcIi8+XHJcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJEZWJ1Z0ludGVyZmFjZXMudHNcIi8+XHJcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJEZWJ1Z0NvbnNvbGUudHNcIi8+XHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFRoZSBEZWJ1Zy1DbGFzcyBvZmZlcnMgZnVuY3Rpb25zIGtub3duIGZyb20gdGhlIGNvbnNvbGUtb2JqZWN0IGFuZCBhZGRpdGlvbnMsIFxyXG4gICAqIHJvdXRpbmcgdGhlIGluZm9ybWF0aW9uIHRvIHZhcmlvdXMgW1tEZWJ1Z1RhcmdldHNdXSB0aGF0IGNhbiBiZSBlYXNpbHkgZGVmaW5lZCBieSB0aGUgZGV2ZWxvcGVycyBhbmQgcmVnaXN0ZXJkIGJ5IHVzZXJzXHJcbiAgICogT3ZlcnJpZGUgZnVuY3Rpb25zIGluIHN1YmNsYXNzZXMgb2YgW1tEZWJ1Z1RhcmdldF1dIGFuZCByZWdpc3RlciB0aGVtIGFzIHRoZWlyIGRlbGVnYXRlc1xyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBEZWJ1ZyB7XHJcbiAgICAvKipcclxuICAgICAqIEZvciBlYWNoIHNldCBmaWx0ZXIsIHRoaXMgYXNzb2NpYXRpdmUgYXJyYXkga2VlcHMgcmVmZXJlbmNlcyB0byB0aGUgcmVnaXN0ZXJlZCBkZWxlZ2F0ZSBmdW5jdGlvbnMgb2YgdGhlIGNob3NlbiBbW0RlYnVnVGFyZ2V0c11dXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIGRlbGVnYXRlczogeyBbZmlsdGVyOiBudW1iZXJdOiBNYXBEZWJ1Z1RhcmdldFRvRGVsZWdhdGUgfSA9IERlYnVnLnNldHVwQ29uc29sZSgpO1xyXG5cclxuICAgIC8vIFRPRE86IGNyZWF0ZSBmaWx0ZXIgREVCVUdfRklMVEVSLkZVREdFIHNvbGVseSBmb3IgbWVzc2FnZXMgZnJvbSBGVURHRVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGUtIC8gQWN0aXZhdGUgYSBmaWx0ZXIgZm9yIHRoZSBnaXZlbiBEZWJ1Z1RhcmdldC4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc2V0RmlsdGVyKF90YXJnZXQ6IERlYnVnVGFyZ2V0LCBfZmlsdGVyOiBERUJVR19GSUxURVIpOiB2b2lkIHtcclxuICAgICAgZm9yIChsZXQgZmlsdGVyIGluIERlYnVnLmRlbGVnYXRlcylcclxuICAgICAgICBEZWJ1Zy5kZWxlZ2F0ZXNbZmlsdGVyXS5kZWxldGUoX3RhcmdldCk7XHJcblxyXG4gICAgICBmb3IgKGxldCBmaWx0ZXIgaW4gREVCVUdfRklMVEVSKSB7XHJcbiAgICAgICAgbGV0IHBhcnNlZDogbnVtYmVyID0gcGFyc2VJbnQoZmlsdGVyKTtcclxuICAgICAgICBpZiAoaXNOYU4ocGFyc2VkKSlcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGlmIChbREVCVUdfRklMVEVSLk1FU1NBR0VTLCBERUJVR19GSUxURVIuRk9STUFULCBERUJVR19GSUxURVIuQUxMXS5pbmRleE9mKHBhcnNlZCkgIT0gLTEpXHJcbiAgICAgICAgICAvLyBkb250IGRlbGVnYXRlIGNvbWJvcy4uLiBcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIGlmIChfZmlsdGVyICYgcGFyc2VkKVxyXG4gICAgICAgICAgRGVidWcuZGVsZWdhdGVzW3BhcnNlZF0uc2V0KF90YXJnZXQsIF90YXJnZXQuZGVsZWdhdGVzW3BhcnNlZF0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmZvKC4uLikgZGlzcGxheXMgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiB3aXRoIGxvdyBwcmlvcml0eVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGluZm8oX21lc3NhZ2U6IE9iamVjdCwgLi4uX2FyZ3M6IE9iamVjdFtdKTogdm9pZCB7XHJcbiAgICAgIERlYnVnLmRlbGVnYXRlKERFQlVHX0ZJTFRFUi5JTkZPLCBfbWVzc2FnZSwgX2FyZ3MpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwbGF5cyBpbmZvcm1hdGlvbiB3aXRoIG1lZGl1bSBwcmlvcml0eVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGxvZyhfbWVzc2FnZTogT2JqZWN0LCAuLi5fYXJnczogT2JqZWN0W10pOiB2b2lkIHtcclxuICAgICAgRGVidWcuZGVsZWdhdGUoREVCVUdfRklMVEVSLkxPRywgX21lc3NhZ2UsIF9hcmdzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGlzcGxheXMgaW5mb3JtYXRpb24gYWJvdXQgbm9uLWNvbmZvcm1pdGllcyBpbiB1c2FnZSwgd2hpY2ggaXMgZW1waGFzaXplZCBlLmcuIGJ5IGNvbG9yXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgd2FybihfbWVzc2FnZTogT2JqZWN0LCAuLi5fYXJnczogT2JqZWN0W10pOiB2b2lkIHtcclxuICAgICAgRGVidWcuZGVsZWdhdGUoREVCVUdfRklMVEVSLldBUk4sIF9tZXNzYWdlLCBfYXJncyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERpc3BsYXlzIGNyaXRpY2FsIGluZm9ybWF0aW9uIGFib3V0IGZhaWx1cmVzLCB3aGljaCBpcyBlbXBoYXNpemVkIGUuZy4gYnkgY29sb3JcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBlcnJvcihfbWVzc2FnZTogT2JqZWN0LCAuLi5fYXJnczogT2JqZWN0W10pOiB2b2lkIHtcclxuICAgICAgRGVidWcuZGVsZWdhdGUoREVCVUdfRklMVEVSLkVSUk9SLCBfbWVzc2FnZSwgX2FyZ3MpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwbGF5cyBtZXNzYWdlcyBmcm9tIEZVREdFXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZnVkZ2UoX21lc3NhZ2U6IE9iamVjdCwgLi4uX2FyZ3M6IE9iamVjdFtdKTogdm9pZCB7XHJcbiAgICAgIERlYnVnLmRlbGVnYXRlKERFQlVHX0ZJTFRFUi5GVURHRSwgX21lc3NhZ2UsIF9hcmdzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIHRoZSBvdXRwdXQgYW5kIHJlbW92ZXMgcHJldmlvdXMgbWVzc2FnZXMgaWYgcG9zc2libGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBjbGVhcigpOiB2b2lkIHtcclxuICAgICAgRGVidWcuZGVsZWdhdGUoREVCVUdfRklMVEVSLkNMRUFSLCBudWxsLCBudWxsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3BlbnMgYSBuZXcgZ3JvdXAgZm9yIG1lc3NhZ2VzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ3JvdXAoX25hbWU6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICBEZWJ1Zy5kZWxlZ2F0ZShERUJVR19GSUxURVIuR1JPVVAsIF9uYW1lLCBudWxsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3BlbnMgYSBuZXcgZ3JvdXAgZm9yIG1lc3NhZ2VzIHRoYXQgaXMgY29sbGFwc2VkIGF0IGZpcnN0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ3JvdXBDb2xsYXBzZWQoX25hbWU6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICBEZWJ1Zy5kZWxlZ2F0ZShERUJVR19GSUxURVIuR1JPVVBDT0xMQVBTRUQsIF9uYW1lLCBudWxsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2xvc2VzIHRoZSB5b3VuZ2VzdCBncm91cFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdyb3VwRW5kKCk6IHZvaWQge1xyXG4gICAgICBEZWJ1Zy5kZWxlZ2F0ZShERUJVR19GSUxURVIuR1JPVVBFTkQsIG51bGwsIG51bGwpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBMb29rdXAgYWxsIGRlbGVnYXRlcyByZWdpc3RlcmVkIHRvIHRoZSBmaWx0ZXIgYW5kIGNhbGwgdGhlbSB1c2luZyB0aGUgZ2l2ZW4gYXJndW1lbnRzXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIGRlbGVnYXRlKF9maWx0ZXI6IERFQlVHX0ZJTFRFUiwgX21lc3NhZ2U6IE9iamVjdCwgX2FyZ3M6IE9iamVjdFtdKTogdm9pZCB7XHJcbiAgICAgIGxldCBkZWxlZ2F0ZXM6IE1hcERlYnVnVGFyZ2V0VG9EZWxlZ2F0ZSA9IERlYnVnLmRlbGVnYXRlc1tfZmlsdGVyXTtcclxuICAgICAgZm9yIChsZXQgZGVsZWdhdGUgb2YgZGVsZWdhdGVzLnZhbHVlcygpKVxyXG4gICAgICAgIGlmIChkZWxlZ2F0ZSlcclxuICAgICAgICAgIGlmIChfYXJncyAmJiBfYXJncy5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICBkZWxlZ2F0ZShfbWVzc2FnZSwgLi4uX2FyZ3MpO1xyXG4gICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBkZWxlZ2F0ZShfbWVzc2FnZSk7XHJcblxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBzZXR1cCByb3V0aW5nIHRvIHN0YW5kYXJkIGNvbnNvbGVcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgc2V0dXBDb25zb2xlKCk6IHt9IHtcclxuICAgICAgbGV0IHJlc3VsdDogeyBbZmlsdGVyOiBudW1iZXJdOiBNYXBEZWJ1Z1RhcmdldFRvRGVsZWdhdGUgfSA9IHt9O1xyXG4gICAgICBsZXQgZmlsdGVyczogREVCVUdfRklMVEVSW10gPSBbXHJcbiAgICAgICAgREVCVUdfRklMVEVSLklORk8sIERFQlVHX0ZJTFRFUi5MT0csIERFQlVHX0ZJTFRFUi5XQVJOLCBERUJVR19GSUxURVIuRVJST1IsIERFQlVHX0ZJTFRFUi5GVURHRSxcclxuICAgICAgICBERUJVR19GSUxURVIuQ0xFQVIsIERFQlVHX0ZJTFRFUi5HUk9VUCwgREVCVUdfRklMVEVSLkdST1VQQ09MTEFQU0VELCBERUJVR19GSUxURVIuR1JPVVBFTkRcclxuICAgICAgXTtcclxuXHJcbiAgICAgIGZvciAobGV0IGZpbHRlciBvZiBmaWx0ZXJzKVxyXG4gICAgICAgIHJlc3VsdFtmaWx0ZXJdID0gbmV3IE1hcChbW0RlYnVnQ29uc29sZSwgRGVidWdDb25zb2xlLmRlbGVnYXRlc1tmaWx0ZXJdXV0pO1xyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICB9XHJcbn0iLCIvLyAvIDxyZWZlcmVuY2UgcGF0aD1cIkRlYnVnVGFyZ2V0LnRzXCIvPlxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBSb3V0aW5nIHRvIHRoZSBhbGVydCBib3hcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgRGVidWdBbGVydCBleHRlbmRzIERlYnVnVGFyZ2V0IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgZGVsZWdhdGVzOiBNYXBEZWJ1Z0ZpbHRlclRvRGVsZWdhdGUgPSB7XHJcbiAgICAgIFtERUJVR19GSUxURVIuSU5GT106IERlYnVnQWxlcnQuY3JlYXRlRGVsZWdhdGUoREVCVUdfU1lNQk9MW0RFQlVHX0ZJTFRFUi5JTkZPXSksXHJcbiAgICAgIFtERUJVR19GSUxURVIuTE9HXTogRGVidWdBbGVydC5jcmVhdGVEZWxlZ2F0ZShERUJVR19TWU1CT0xbREVCVUdfRklMVEVSLkxPR10pLFxyXG4gICAgICBbREVCVUdfRklMVEVSLldBUk5dOiBEZWJ1Z0FsZXJ0LmNyZWF0ZURlbGVnYXRlKERFQlVHX1NZTUJPTFtERUJVR19GSUxURVIuV0FSTl0pLFxyXG4gICAgICBbREVCVUdfRklMVEVSLkVSUk9SXTogRGVidWdBbGVydC5jcmVhdGVEZWxlZ2F0ZShERUJVR19TWU1CT0xbREVCVUdfRklMVEVSLkVSUk9SXSksXHJcbiAgICAgIFtERUJVR19GSUxURVIuRlVER0VdOiBEZWJ1Z0FsZXJ0LmNyZWF0ZURlbGVnYXRlKERFQlVHX1NZTUJPTFtERUJVR19GSUxURVIuRlVER0VdKVxyXG4gICAgfTtcclxuICAgIHB1YmxpYyBzdGF0aWMgY3JlYXRlRGVsZWdhdGUoX2hlYWRsaW5lOiBzdHJpbmcpOiBGdW5jdGlvbiB7XHJcbiAgICAgIGxldCBkZWxlZ2F0ZTogRnVuY3Rpb24gPSBmdW5jdGlvbiAoX21lc3NhZ2U6IE9iamVjdCwgLi4uX2FyZ3M6IE9iamVjdFtdKTogdm9pZCB7XHJcbiAgICAgICAgbGV0IGFyZ3M6IHN0cmluZ1tdID0gX2FyZ3MubWFwKF9hcmcgPT4gX2FyZy50b1N0cmluZygpKTtcclxuICAgICAgICBsZXQgb3V0OiBzdHJpbmcgPSBfaGVhZGxpbmUgKyBcIiBcIiArIERlYnVnVGFyZ2V0Lm1lcmdlQXJndW1lbnRzKF9tZXNzYWdlLCBhcmdzKTtcclxuICAgICAgICBhbGVydChvdXQpO1xyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gZGVsZWdhdGU7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwiLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCJEZWJ1Z1RhcmdldC50c1wiLz5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgICAvKipcclxuICAgICAqIFJvdXRpbmcgdG8gYSBIVE1MRGlhbG9nRWxlbWVudFxyXG4gICAgICovXHJcbiAgICBleHBvcnQgY2xhc3MgRGVidWdEaWFsb2cgZXh0ZW5kcyBEZWJ1Z1RhcmdldCB7XHJcbiAgICAgICAgLy8gVE9ETzogY2hlY2tvdXQgSFRNTERpYWxvZ0VsZW1lbnQ7ICEhIVxyXG4gICAgfVxyXG59IiwiLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCJEZWJ1Z1RhcmdldC50c1wiLz5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogUm91dGUgdG8gYW4gSFRNTFRleHRBcmVhLCBtYXkgYmUgb2Jzb2xldGUgd2hlbiB1c2luZyBIVE1MRGlhbG9nRWxlbWVudFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBEZWJ1Z1RleHRBcmVhIGV4dGVuZHMgRGVidWdUYXJnZXQge1xyXG4gICAgcHVibGljIHN0YXRpYyB0ZXh0QXJlYTogSFRNTFRleHRBcmVhRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKTtcclxuICAgIHB1YmxpYyBzdGF0aWMgYXV0b1Njcm9sbDogYm9vbGVhbiA9IHRydWU7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBkZWxlZ2F0ZXM6IE1hcERlYnVnRmlsdGVyVG9EZWxlZ2F0ZSA9IHtcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5JTkZPXTogRGVidWdUZXh0QXJlYS5jcmVhdGVEZWxlZ2F0ZShERUJVR19TWU1CT0xbREVCVUdfRklMVEVSLklORk9dKSxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5MT0ddOiBEZWJ1Z1RleHRBcmVhLmNyZWF0ZURlbGVnYXRlKERFQlVHX1NZTUJPTFtERUJVR19GSUxURVIuTE9HXSksXHJcbiAgICAgIFtERUJVR19GSUxURVIuV0FSTl06IERlYnVnVGV4dEFyZWEuY3JlYXRlRGVsZWdhdGUoREVCVUdfU1lNQk9MW0RFQlVHX0ZJTFRFUi5XQVJOXSksXHJcbiAgICAgIFtERUJVR19GSUxURVIuRVJST1JdOiBEZWJ1Z1RleHRBcmVhLmNyZWF0ZURlbGVnYXRlKERFQlVHX1NZTUJPTFtERUJVR19GSUxURVIuRVJST1JdKSxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5GVURHRV06IERlYnVnVGV4dEFyZWEuY3JlYXRlRGVsZWdhdGUoREVCVUdfU1lNQk9MW0RFQlVHX0ZJTFRFUi5GVURHRV0pLFxyXG4gICAgICBbREVCVUdfRklMVEVSLkNMRUFSXTogRGVidWdUZXh0QXJlYS5jbGVhcixcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5HUk9VUF06IERlYnVnVGV4dEFyZWEuZ3JvdXAsXHJcbiAgICAgIFtERUJVR19GSUxURVIuR1JPVVBDT0xMQVBTRURdOiBEZWJ1Z1RleHRBcmVhLmdyb3VwLFxyXG4gICAgICBbREVCVUdfRklMVEVSLkdST1VQRU5EXTogRGVidWdUZXh0QXJlYS5ncm91cEVuZFxyXG4gICAgfTtcclxuICAgIHByaXZhdGUgc3RhdGljIGdyb3Vwczogc3RyaW5nW10gPSBbXTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGNsZWFyKCk6IHZvaWQge1xyXG4gICAgICBEZWJ1Z1RleHRBcmVhLnRleHRBcmVhLnRleHRDb250ZW50ID0gXCJcIjtcclxuICAgICAgRGVidWdUZXh0QXJlYS5ncm91cHMgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdyb3VwKF9uYW1lOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgRGVidWdUZXh0QXJlYS5wcmludChcIuKWvCBcIiArIF9uYW1lKTtcclxuICAgICAgRGVidWdUZXh0QXJlYS5ncm91cHMucHVzaChfbmFtZSk7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc3RhdGljIGdyb3VwRW5kKCk6IHZvaWQge1xyXG4gICAgICBEZWJ1Z1RleHRBcmVhLmdyb3Vwcy5wb3AoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGNyZWF0ZURlbGVnYXRlKF9oZWFkbGluZTogc3RyaW5nKTogRnVuY3Rpb24ge1xyXG4gICAgICBsZXQgZGVsZWdhdGU6IEZ1bmN0aW9uID0gZnVuY3Rpb24gKF9tZXNzYWdlOiBPYmplY3QsIC4uLl9hcmdzOiBPYmplY3RbXSk6IHZvaWQge1xyXG4gICAgICAgIERlYnVnVGV4dEFyZWEucHJpbnQoX2hlYWRsaW5lICsgXCIgXCIgKyBEZWJ1Z1RhcmdldC5tZXJnZUFyZ3VtZW50cyhfbWVzc2FnZSwgX2FyZ3MpKTtcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIGRlbGVnYXRlO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGdldEluZGVudGF0aW9uKF9sZXZlbDogbnVtYmVyKTogc3RyaW5nIHtcclxuICAgICAgbGV0IHJlc3VsdDogc3RyaW5nID0gXCJcIjtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IF9sZXZlbDsgaSsrKVxyXG4gICAgICAgIHJlc3VsdCArPSBcInwgXCI7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcHJpbnQoX3RleHQ6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICBEZWJ1Z1RleHRBcmVhLnRleHRBcmVhLnRleHRDb250ZW50ICs9IERlYnVnVGV4dEFyZWEuZ2V0SW5kZW50YXRpb24oRGVidWdUZXh0QXJlYS5ncm91cHMubGVuZ3RoKSArIF90ZXh0ICsgXCJcXG5cIjtcclxuICAgICAgaWYgKERlYnVnVGV4dEFyZWEuYXV0b1Njcm9sbClcclxuICAgICAgICBEZWJ1Z1RleHRBcmVhLnRleHRBcmVhLnNjcm9sbFRvcCA9IERlYnVnVGV4dEFyZWEudGV4dEFyZWEuc2Nyb2xsSGVpZ2h0O1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIERlZmluZXMgYSBjb2xvciBhcyB2YWx1ZXMgaW4gdGhlIHJhbmdlIG9mIDAgdG8gMSBmb3IgdGhlIGZvdXIgY2hhbm5lbHMgcmVkLCBncmVlbiwgYmx1ZSBhbmQgYWxwaGEgKGZvciBvcGFjaXR5KVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb2xvciBleHRlbmRzIE11dGFibGUgeyAvL2ltcGxlbWVudHMgU2VyaWFsaXphYmxlIHtcclxuICAgIC8vIGNyYzIgb25seSB1c2VkIGZvciBjb252ZXJ0aW5nIGNvbG9ycyBmcm9tIHN0cmluZ3MgcHJlZGVmaW5lZCBieSBDU1NcclxuICAgIHByaXZhdGUgc3RhdGljIGNyYzI6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG5cclxuICAgIHB1YmxpYyByOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgZzogbnVtYmVyO1xyXG4gICAgcHVibGljIGI6IG51bWJlcjtcclxuICAgIHB1YmxpYyBhOiBudW1iZXI7XHJcblxyXG4gICAgY29uc3RydWN0b3IoX3I6IG51bWJlciA9IDEsIF9nOiBudW1iZXIgPSAxLCBfYjogbnVtYmVyID0gMSwgX2E6IG51bWJlciA9IDEpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5zZXROb3JtUkdCQShfciwgX2csIF9iLCBfYSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRIZXhGcm9tQ1NTS2V5d29yZChfa2V5d29yZDogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgQ29sb3IuY3JjMi5maWxsU3R5bGUgPSBfa2V5d29yZDtcclxuICAgICAgcmV0dXJuIENvbG9yLmNyYzIuZmlsbFN0eWxlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgQ1NTKF9rZXl3b3JkOiBzdHJpbmcsIF9hbHBoYTogbnVtYmVyID0gMSk6IENvbG9yIHtcclxuICAgICAgbGV0IGhleDogc3RyaW5nID0gQ29sb3IuZ2V0SGV4RnJvbUNTU0tleXdvcmQoX2tleXdvcmQpO1xyXG4gICAgICBsZXQgY29sb3I6IENvbG9yID0gbmV3IENvbG9yKFxyXG4gICAgICAgIHBhcnNlSW50KGhleC5zdWJzdHIoMSwgMiksIDE2KSAvIDI1NSxcclxuICAgICAgICBwYXJzZUludChoZXguc3Vic3RyKDMsIDIpLCAxNikgLyAyNTUsXHJcbiAgICAgICAgcGFyc2VJbnQoaGV4LnN1YnN0cig1LCAyKSwgMTYpIC8gMjU1LFxyXG4gICAgICAgIF9hbHBoYSk7XHJcbiAgICAgIHJldHVybiBjb2xvcjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBNVUxUSVBMWShfY29sb3IxOiBDb2xvciwgX2NvbG9yMjogQ29sb3IpOiBDb2xvciB7XHJcbiAgICAgIHJldHVybiBuZXcgQ29sb3IoX2NvbG9yMS5yICogX2NvbG9yMi5yLCBfY29sb3IxLmcgKiBfY29sb3IyLmcsIF9jb2xvcjEuYiAqIF9jb2xvcjIuYiwgX2NvbG9yMS5hICogX2NvbG9yMi5hKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0Tm9ybVJHQkEoX3I6IG51bWJlciwgX2c6IG51bWJlciwgX2I6IG51bWJlciwgX2E6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICB0aGlzLnIgPSBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBfcikpO1xyXG4gICAgICB0aGlzLmcgPSBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBfZykpO1xyXG4gICAgICB0aGlzLmIgPSBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBfYikpO1xyXG4gICAgICB0aGlzLmEgPSBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBfYSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXRCeXRlc1JHQkEoX3I6IG51bWJlciwgX2c6IG51bWJlciwgX2I6IG51bWJlciwgX2E6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICB0aGlzLnNldE5vcm1SR0JBKF9yIC8gMjU1LCBfZyAvIDI1NSwgX2IgLyAyNTUsIF9hIC8gMjU1KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0QXJyYXkoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW3RoaXMuciwgdGhpcy5nLCB0aGlzLmIsIHRoaXMuYV0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXRBcnJheU5vcm1SR0JBKF9jb2xvcjogRmxvYXQzMkFycmF5KTogdm9pZCB7XHJcbiAgICAgIHRoaXMuc2V0Tm9ybVJHQkEoX2NvbG9yWzBdLCBfY29sb3JbMV0sIF9jb2xvclsyXSwgX2NvbG9yWzNdKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0QXJyYXlCeXRlc1JHQkEoX2NvbG9yOiBVaW50OENsYW1wZWRBcnJheSk6IHZvaWQge1xyXG4gICAgICB0aGlzLnNldEJ5dGVzUkdCQShfY29sb3JbMF0sIF9jb2xvclsxXSwgX2NvbG9yWzJdLCBfY29sb3JbM10pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRBcnJheUJ5dGVzUkdCQSgpOiBVaW50OENsYW1wZWRBcnJheSB7XHJcbiAgICAgIHJldHVybiBuZXcgVWludDhDbGFtcGVkQXJyYXkoW3RoaXMuciAqIDI1NSwgdGhpcy5nICogMjU1LCB0aGlzLmIgKiAyNTUsIHRoaXMuYSAqIDI1NV0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhZGQoX2NvbG9yOiBDb2xvcik6IHZvaWQge1xyXG4gICAgICB0aGlzLnIgKz0gX2NvbG9yLnI7XHJcbiAgICAgIHRoaXMuZyArPSBfY29sb3IuZztcclxuICAgICAgdGhpcy5iICs9IF9jb2xvci5iO1xyXG4gICAgICB0aGlzLmEgKz0gX2NvbG9yLmE7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldENTUygpOiBzdHJpbmcge1xyXG4gICAgICBsZXQgYnl0ZXM6IFVpbnQ4Q2xhbXBlZEFycmF5ID0gdGhpcy5nZXRBcnJheUJ5dGVzUkdCQSgpO1xyXG4gICAgICByZXR1cm4gYFJHQkEoJHtieXRlc1swXX0sICR7Ynl0ZXNbMV19LCAke2J5dGVzWzJdfSwgJHtieXRlc1szXX0pYDtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQgey8qKiAqLyB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQmFzZWNsYXNzIGZvciBtYXRlcmlhbHMuIENvbWJpbmVzIGEgW1tTaGFkZXJdXSB3aXRoIGEgY29tcGF0aWJsZSBbW0NvYXRdXVxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE1hdGVyaWFsIGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZVJlc291cmNlIHtcclxuICAgIC8qKiBUaGUgbmFtZSB0byBjYWxsIHRoZSBNYXRlcmlhbCBieS4gKi9cclxuICAgIHB1YmxpYyBuYW1lOiBzdHJpbmc7XHJcbiAgICBwdWJsaWMgaWRSZXNvdXJjZTogc3RyaW5nID0gdW5kZWZpbmVkO1xyXG4gICAgcHJpdmF0ZSBzaGFkZXJUeXBlOiB0eXBlb2YgU2hhZGVyOyAvLyBUaGUgc2hhZGVyIHByb2dyYW0gdXNlZCBieSB0aGlzIEJhc2VNYXRlcmlhbFxyXG4gICAgcHJpdmF0ZSBjb2F0OiBDb2F0O1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nLCBfc2hhZGVyPzogdHlwZW9mIFNoYWRlciwgX2NvYXQ/OiBDb2F0KSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMubmFtZSA9IF9uYW1lO1xyXG4gICAgICB0aGlzLnNoYWRlclR5cGUgPSBfc2hhZGVyO1xyXG4gICAgICBpZiAoX3NoYWRlcikge1xyXG4gICAgICAgIGlmIChfY29hdClcclxuICAgICAgICAgIHRoaXMuc2V0Q29hdChfY29hdCk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgdGhpcy5zZXRDb2F0KHRoaXMuY3JlYXRlQ29hdE1hdGNoaW5nU2hhZGVyKCkpO1xyXG4gICAgICB9XHJcbiAgICAgIFJlc291cmNlTWFuYWdlci5yZWdpc3Rlcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgW1tDb2F0XV0gaW5zdGFuY2UgdGhhdCBpcyB2YWxpZCBmb3IgdGhlIFtbU2hhZGVyXV0gcmVmZXJlbmNlZCBieSB0aGlzIG1hdGVyaWFsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjcmVhdGVDb2F0TWF0Y2hpbmdTaGFkZXIoKTogQ29hdCB7XHJcbiAgICAgIGxldCBjb2F0OiBDb2F0ID0gbmV3ICh0aGlzLnNoYWRlclR5cGUuZ2V0Q29hdCgpKSgpO1xyXG4gICAgICByZXR1cm4gY29hdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1ha2VzIHRoaXMgbWF0ZXJpYWwgcmVmZXJlbmNlIHRoZSBnaXZlbiBbW0NvYXRdXSBpZiBpdCBpcyBjb21wYXRpYmxlIHdpdGggdGhlIHJlZmVyZW5jZWQgW1tTaGFkZXJdXVxyXG4gICAgICogQHBhcmFtIF9jb2F0IFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0Q29hdChfY29hdDogQ29hdCk6IHZvaWQge1xyXG4gICAgICBpZiAoX2NvYXQuY29uc3RydWN0b3IgIT0gdGhpcy5zaGFkZXJUeXBlLmdldENvYXQoKSlcclxuICAgICAgICB0aHJvdyAobmV3IEVycm9yKFwiU2hhZGVyIGFuZCBjb2F0IGRvbid0IG1hdGNoXCIpKTtcclxuICAgICAgdGhpcy5jb2F0ID0gX2NvYXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50bHkgcmVmZXJlbmNlZCBbW0NvYXRdXSBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Q29hdCgpOiBDb2F0IHtcclxuICAgICAgcmV0dXJuIHRoaXMuY29hdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZXMgdGhlIG1hdGVyaWFscyByZWZlcmVuY2UgdG8gdGhlIGdpdmVuIFtbU2hhZGVyXV0sIGNyZWF0ZXMgYW5kIHJlZmVyZW5jZXMgYSBuZXcgW1tDb2F0XV0gaW5zdGFuY2UgIFxyXG4gICAgICogYW5kIG11dGF0ZXMgdGhlIG5ldyBjb2F0IHRvIHByZXNlcnZlIG1hdGNoaW5nIHByb3BlcnRpZXMuXHJcbiAgICAgKiBAcGFyYW0gX3NoYWRlclR5cGUgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRTaGFkZXIoX3NoYWRlclR5cGU6IHR5cGVvZiBTaGFkZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy5zaGFkZXJUeXBlID0gX3NoYWRlclR5cGU7XHJcbiAgICAgIGxldCBjb2F0OiBDb2F0ID0gdGhpcy5jcmVhdGVDb2F0TWF0Y2hpbmdTaGFkZXIoKTtcclxuICAgICAgY29hdC5tdXRhdGUodGhpcy5jb2F0LmdldE11dGF0b3IoKSk7XHJcbiAgICAgIHRoaXMuc2V0Q29hdChjb2F0KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIFtbU2hhZGVyXV0gcmVmZXJlbmNlZCBieSB0aGlzIG1hdGVyaWFsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRTaGFkZXIoKTogdHlwZW9mIFNoYWRlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNoYWRlclR5cGU7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgLy8gVE9ETzogdGhpcyB0eXBlIG9mIHNlcmlhbGl6YXRpb24gd2FzIGltcGxlbWVudGVkIGZvciBpbXBsaWNpdCBNYXRlcmlhbCBjcmVhdGUuIENoZWNrIGlmIG9ic29sZXRlIHdoZW4gb25seSBvbmUgbWF0ZXJpYWwgY2xhc3MgZXhpc3RzIGFuZC9vciBtYXRlcmlhbHMgYXJlIHN0b3JlZCBzZXBhcmF0ZWx5XHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHtcclxuICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgaWRSZXNvdXJjZTogdGhpcy5pZFJlc291cmNlLFxyXG4gICAgICAgIHNoYWRlcjogdGhpcy5zaGFkZXJUeXBlLm5hbWUsXHJcbiAgICAgICAgY29hdDogU2VyaWFsaXplci5zZXJpYWxpemUodGhpcy5jb2F0KVxyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFNlcmlhbGl6YWJsZSB7XHJcbiAgICAgIHRoaXMubmFtZSA9IF9zZXJpYWxpemF0aW9uLm5hbWU7XHJcbiAgICAgIHRoaXMuaWRSZXNvdXJjZSA9IF9zZXJpYWxpemF0aW9uLmlkUmVzb3VyY2U7XHJcbiAgICAgIC8vIFRPRE86IHByb3ZpZGUgZm9yIHNoYWRlcnMgaW4gdGhlIHVzZXJzIG5hbWVzcGFjZS4gU2VlIFNlcmlhbGl6ZXIgZnVsbHBhdGggZXRjLlxyXG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLWFueVxyXG4gICAgICB0aGlzLnNoYWRlclR5cGUgPSAoPGFueT5GdWRnZUNvcmUpW19zZXJpYWxpemF0aW9uLnNoYWRlcl07XHJcbiAgICAgIGxldCBjb2F0OiBDb2F0ID0gPENvYXQ+U2VyaWFsaXplci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5jb2F0KTtcclxuICAgICAgdGhpcy5zZXRDb2F0KGNvYXQpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgLy9cclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBLZWVwcyBhIGRlcG90IG9mIG9iamVjdHMgdGhhdCBoYXZlIGJlZW4gbWFya2VkIGZvciByZXVzZSwgc29ydGVkIGJ5IHR5cGUuICBcclxuICAgICAqIFVzaW5nIFtbUmVjeWNsZXJdXSByZWR1Y2VzIGxvYWQgb24gdGhlIGNhcmJhZ2UgY29sbGVjdG9yIGFuZCB0aHVzIHN1cHBvcnRzIHNtb290aCBwZXJmb3JtYW5jZVxyXG4gICAgICovXHJcbiAgICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgUmVjeWNsZXIge1xyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIGRlcG90OiB7IFt0eXBlOiBzdHJpbmddOiBPYmplY3RbXSB9ID0ge307XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYW4gb2JqZWN0IG9mIHRoZSByZXF1ZXN0ZWQgdHlwZSBmcm9tIHRoZSBkZXBvdCwgb3IgYSBuZXcgb25lLCBpZiB0aGUgZGVwb3Qgd2FzIGVtcHR5IFxyXG4gICAgICAgICAqIEBwYXJhbSBfVCBUaGUgY2xhc3MgaWRlbnRpZmllciBvZiB0aGUgZGVzaXJlZCBvYmplY3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGdldDxUPihfVDogbmV3ICgpID0+IFQpOiBUIHtcclxuICAgICAgICAgICAgbGV0IGtleTogc3RyaW5nID0gX1QubmFtZTtcclxuICAgICAgICAgICAgbGV0IGluc3RhbmNlczogT2JqZWN0W10gPSBSZWN5Y2xlci5kZXBvdFtrZXldO1xyXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2VzICYmIGluc3RhbmNlcy5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDxUPmluc3RhbmNlcy5wb3AoKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfVCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3RvcmVzIHRoZSBvYmplY3QgaW4gdGhlIGRlcG90IGZvciBsYXRlciByZWN5Y2xpbmcuIFVzZXJzIGFyZSByZXNwb25zaWJsZSBmb3IgdGhyb3dpbmcgaW4gb2JqZWN0cyB0aGF0IGFyZSBhYm91dCB0byBsb29zZSBzY29wZSBhbmQgYXJlIG5vdCByZWZlcmVuY2VkIGJ5IGFueSBvdGhlclxyXG4gICAgICAgICAqIEBwYXJhbSBfaW5zdGFuY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBwdWJsaWMgc3RhdGljIHN0b3JlKF9pbnN0YW5jZTogT2JqZWN0KTogdm9pZCB7XHJcbiAgICAgICAgICAgIGxldCBrZXk6IHN0cmluZyA9IF9pbnN0YW5jZS5jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gICAgICAgICAgICAvL0RlYnVnLmxvZyhrZXkpO1xyXG4gICAgICAgICAgICBsZXQgaW5zdGFuY2VzOiBPYmplY3RbXSA9IFJlY3ljbGVyLmRlcG90W2tleV0gfHwgW107XHJcbiAgICAgICAgICAgIGluc3RhbmNlcy5wdXNoKF9pbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIFJlY3ljbGVyLmRlcG90W2tleV0gPSBpbnN0YW5jZXM7XHJcbiAgICAgICAgICAgIC8vIERlYnVnLmxvZyhgT2JqZWN0TWFuYWdlci5kZXBvdFske2tleX1dOiAke09iamVjdE1hbmFnZXIuZGVwb3Rba2V5XS5sZW5ndGh9YCk7XHJcbiAgICAgICAgICAgIC8vRGVidWcubG9nKHRoaXMuZGVwb3QpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW1wdHlzIHRoZSBkZXBvdCBvZiBhIGdpdmVuIHR5cGUsIGxlYXZpbmcgdGhlIG9iamVjdHMgZm9yIHRoZSBnYXJiYWdlIGNvbGxlY3Rvci4gTWF5IHJlc3VsdCBpbiBhIHNob3J0IHN0YWxsIHdoZW4gbWFueSBvYmplY3RzIHdlcmUgaW5cclxuICAgICAgICAgKiBAcGFyYW0gX1RcclxuICAgICAgICAgKi9cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGR1bXA8VD4oX1Q6IG5ldyAoKSA9PiBUKTogdm9pZCB7XHJcbiAgICAgICAgICAgIGxldCBrZXk6IHN0cmluZyA9IF9ULm5hbWU7XHJcbiAgICAgICAgICAgIFJlY3ljbGVyLmRlcG90W2tleV0gPSBbXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVtcHR5cyBhbGwgZGVwb3RzLCBsZWF2aW5nIGFsbCBvYmplY3RzIHRvIHRoZSBnYXJiYWdlIGNvbGxlY3Rvci4gTWF5IHJlc3VsdCBpbiBhIHNob3J0IHN0YWxsIHdoZW4gbWFueSBvYmplY3RzIHdlcmUgaW5cclxuICAgICAgICAgKi9cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGR1bXBBbGwoKTogdm9pZCB7XHJcbiAgICAgICAgICAgIFJlY3ljbGVyLmRlcG90ID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgICBleHBvcnQgaW50ZXJmYWNlIFNlcmlhbGl6YWJsZVJlc291cmNlIGV4dGVuZHMgU2VyaWFsaXphYmxlIHtcclxuICAgICAgICBpZFJlc291cmNlOiBzdHJpbmc7XHJcbiAgICB9XHJcblxyXG4gICAgZXhwb3J0IGludGVyZmFjZSBSZXNvdXJjZXMge1xyXG4gICAgICAgIFtpZFJlc291cmNlOiBzdHJpbmddOiBTZXJpYWxpemFibGVSZXNvdXJjZTtcclxuICAgIH1cclxuXHJcbiAgICBleHBvcnQgaW50ZXJmYWNlIFNlcmlhbGl6YXRpb25PZlJlc291cmNlcyB7XHJcbiAgICAgICAgW2lkUmVzb3VyY2U6IHN0cmluZ106IFNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGF0aWMgY2xhc3MgaGFuZGxpbmcgdGhlIHJlc291cmNlcyB1c2VkIHdpdGggdGhlIGN1cnJlbnQgRlVER0UtaW5zdGFuY2UuICBcclxuICAgICAqIEtlZXBzIGEgbGlzdCBvZiB0aGUgcmVzb3VyY2VzIGFuZCBnZW5lcmF0ZXMgaWRzIHRvIHJldHJpZXZlIHRoZW0uICBcclxuICAgICAqIFJlc291cmNlcyBhcmUgb2JqZWN0cyByZWZlcmVuY2VkIG11bHRpcGxlIHRpbWVzIGJ1dCBzdXBwb3NlZCB0byBiZSBzdG9yZWQgb25seSBvbmNlXHJcbiAgICAgKi9cclxuICAgIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBSZXNvdXJjZU1hbmFnZXIge1xyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgcmVzb3VyY2VzOiBSZXNvdXJjZXMgPSB7fTtcclxuICAgICAgICBwdWJsaWMgc3RhdGljIHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb25PZlJlc291cmNlcyA9IG51bGw7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdlbmVyYXRlcyBhbiBpZCBmb3IgdGhlIHJlc291cmNlcyBhbmQgcmVnaXN0ZXJzIGl0IHdpdGggdGhlIGxpc3Qgb2YgcmVzb3VyY2VzIFxyXG4gICAgICAgICAqIEBwYXJhbSBfcmVzb3VyY2UgXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyByZWdpc3RlcihfcmVzb3VyY2U6IFNlcmlhbGl6YWJsZVJlc291cmNlKTogdm9pZCB7XHJcbiAgICAgICAgICAgIGlmICghX3Jlc291cmNlLmlkUmVzb3VyY2UpXHJcbiAgICAgICAgICAgICAgICBfcmVzb3VyY2UuaWRSZXNvdXJjZSA9IFJlc291cmNlTWFuYWdlci5nZW5lcmF0ZUlkKF9yZXNvdXJjZSk7XHJcbiAgICAgICAgICAgIFJlc291cmNlTWFuYWdlci5yZXNvdXJjZXNbX3Jlc291cmNlLmlkUmVzb3VyY2VdID0gX3Jlc291cmNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2VuZXJhdGUgYSB1c2VyIHJlYWRhYmxlIGFuZCB1bmlxdWUgaWQgdXNpbmcgdGhlIHR5cGUgb2YgdGhlIHJlc291cmNlLCB0aGUgZGF0ZSBhbmQgcmFuZG9tIG51bWJlcnNcclxuICAgICAgICAgKiBAcGFyYW0gX3Jlc291cmNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBnZW5lcmF0ZUlkKF9yZXNvdXJjZTogU2VyaWFsaXphYmxlUmVzb3VyY2UpOiBzdHJpbmcge1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBidWlsZCBpZCBhbmQgaW50ZWdyYXRlIGluZm8gZnJvbSByZXNvdXJjZSwgbm90IGp1c3QgZGF0ZVxyXG4gICAgICAgICAgICBsZXQgaWRSZXNvdXJjZTogc3RyaW5nO1xyXG4gICAgICAgICAgICBkb1xyXG4gICAgICAgICAgICAgICAgaWRSZXNvdXJjZSA9IF9yZXNvdXJjZS5jb25zdHJ1Y3Rvci5uYW1lICsgXCJ8XCIgKyBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgKyBcInxcIiArIE1hdGgucmFuZG9tKCkudG9QcmVjaXNpb24oNSkuc3Vic3RyKDIsIDUpO1xyXG4gICAgICAgICAgICB3aGlsZSAoUmVzb3VyY2VNYW5hZ2VyLnJlc291cmNlc1tpZFJlc291cmNlXSk7XHJcbiAgICAgICAgICAgIHJldHVybiBpZFJlc291cmNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVzdHMsIGlmIGFuIG9iamVjdCBpcyBhIFtbU2VyaWFsaXphYmxlUmVzb3VyY2VdXVxyXG4gICAgICAgICAqIEBwYXJhbSBfb2JqZWN0IFRoZSBvYmplY3QgdG8gZXhhbWluZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgaXNSZXNvdXJjZShfb2JqZWN0OiBTZXJpYWxpemFibGUpOiBib29sZWFuIHtcclxuICAgICAgICAgICAgcmV0dXJuIChSZWZsZWN0Lmhhcyhfb2JqZWN0LCBcImlkUmVzb3VyY2VcIikpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0cmlldmVzIHRoZSByZXNvdXJjZSBzdG9yZWQgd2l0aCB0aGUgZ2l2ZW4gaWRcclxuICAgICAgICAgKiBAcGFyYW0gX2lkUmVzb3VyY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGdldChfaWRSZXNvdXJjZTogc3RyaW5nKTogU2VyaWFsaXphYmxlUmVzb3VyY2Uge1xyXG4gICAgICAgICAgICBsZXQgcmVzb3VyY2U6IFNlcmlhbGl6YWJsZVJlc291cmNlID0gUmVzb3VyY2VNYW5hZ2VyLnJlc291cmNlc1tfaWRSZXNvdXJjZV07XHJcbiAgICAgICAgICAgIGlmICghcmVzb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gUmVzb3VyY2VNYW5hZ2VyLnNlcmlhbGl6YXRpb25bX2lkUmVzb3VyY2VdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzZXJpYWxpemF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgRGVidWcuZXJyb3IoXCJSZXNvdXJjZSBub3QgZm91bmRcIiwgX2lkUmVzb3VyY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzb3VyY2UgPSBSZXNvdXJjZU1hbmFnZXIuZGVzZXJpYWxpemVSZXNvdXJjZShzZXJpYWxpemF0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzb3VyY2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGFuZCByZWdpc3RlcnMgYSByZXNvdXJjZSBmcm9tIGEgW1tOb2RlXV0sIGNvcHlpbmcgdGhlIGNvbXBsZXRlIGJyYW5jaCBzdGFydGluZyB3aXRoIGl0XHJcbiAgICAgICAgICogQHBhcmFtIF9ub2RlIEEgbm9kZSB0byBjcmVhdGUgdGhlIHJlc291cmNlIGZyb21cclxuICAgICAgICAgKiBAcGFyYW0gX3JlcGxhY2VXaXRoSW5zdGFuY2UgaWYgdHJ1ZSAoZGVmYXVsdCksIHRoZSBub2RlIHVzZWQgYXMgb3JpZ2luIGlzIHJlcGxhY2VkIGJ5IGEgW1tOb2RlUmVzb3VyY2VJbnN0YW5jZV1dIG9mIHRoZSBbW05vZGVSZXNvdXJjZV1dIGNyZWF0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBwdWJsaWMgc3RhdGljIHJlZ2lzdGVyTm9kZUFzUmVzb3VyY2UoX25vZGU6IE5vZGUsIF9yZXBsYWNlV2l0aEluc3RhbmNlOiBib29sZWFuID0gdHJ1ZSk6IE5vZGVSZXNvdXJjZSB7XHJcbiAgICAgICAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gX25vZGUuc2VyaWFsaXplKCk7XHJcbiAgICAgICAgICAgIGxldCBub2RlUmVzb3VyY2U6IE5vZGVSZXNvdXJjZSA9IG5ldyBOb2RlUmVzb3VyY2UoXCJOb2RlUmVzb3VyY2VcIik7XHJcbiAgICAgICAgICAgIG5vZGVSZXNvdXJjZS5kZXNlcmlhbGl6ZShzZXJpYWxpemF0aW9uKTtcclxuICAgICAgICAgICAgUmVzb3VyY2VNYW5hZ2VyLnJlZ2lzdGVyKG5vZGVSZXNvdXJjZSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoX3JlcGxhY2VXaXRoSW5zdGFuY2UgJiYgX25vZGUuZ2V0UGFyZW50KCkpIHtcclxuICAgICAgICAgICAgICAgIGxldCBpbnN0YW5jZTogTm9kZVJlc291cmNlSW5zdGFuY2UgPSBuZXcgTm9kZVJlc291cmNlSW5zdGFuY2Uobm9kZVJlc291cmNlKTtcclxuICAgICAgICAgICAgICAgIF9ub2RlLmdldFBhcmVudCgpLnJlcGxhY2VDaGlsZChfbm9kZSwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbm9kZVJlc291cmNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2VyaWFsaXplIGFsbCByZXNvdXJjZXNcclxuICAgICAgICAgKi9cclxuICAgICAgICBwdWJsaWMgc3RhdGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uT2ZSZXNvdXJjZXMge1xyXG4gICAgICAgICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbk9mUmVzb3VyY2VzID0ge307XHJcbiAgICAgICAgICAgIGZvciAobGV0IGlkUmVzb3VyY2UgaW4gUmVzb3VyY2VNYW5hZ2VyLnJlc291cmNlcykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlc291cmNlOiBTZXJpYWxpemFibGVSZXNvdXJjZSA9IFJlc291cmNlTWFuYWdlci5yZXNvdXJjZXNbaWRSZXNvdXJjZV07XHJcbiAgICAgICAgICAgICAgICBpZiAoaWRSZXNvdXJjZSAhPSByZXNvdXJjZS5pZFJlc291cmNlKVxyXG4gICAgICAgICAgICAgICAgICAgIERlYnVnLmVycm9yKFwiUmVzb3VyY2UtaWQgbWlzbWF0Y2hcIiwgcmVzb3VyY2UpO1xyXG4gICAgICAgICAgICAgICAgc2VyaWFsaXphdGlvbltpZFJlc291cmNlXSA9IFNlcmlhbGl6ZXIuc2VyaWFsaXplKHJlc291cmNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZSByZXNvdXJjZXMgZnJvbSBhIHNlcmlhbGl6YXRpb24sIGRlbGV0aW5nIGFsbCByZXNvdXJjZXMgcHJldmlvdXNseSByZWdpc3RlcmVkXHJcbiAgICAgICAgICogQHBhcmFtIF9zZXJpYWxpemF0aW9uIFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb25PZlJlc291cmNlcyk6IFJlc291cmNlcyB7XHJcbiAgICAgICAgICAgIFJlc291cmNlTWFuYWdlci5zZXJpYWxpemF0aW9uID0gX3NlcmlhbGl6YXRpb247XHJcbiAgICAgICAgICAgIFJlc291cmNlTWFuYWdlci5yZXNvdXJjZXMgPSB7fTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaWRSZXNvdXJjZSBpbiBfc2VyaWFsaXphdGlvbikge1xyXG4gICAgICAgICAgICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSBfc2VyaWFsaXphdGlvbltpZFJlc291cmNlXTtcclxuICAgICAgICAgICAgICAgIGxldCByZXNvdXJjZTogU2VyaWFsaXphYmxlUmVzb3VyY2UgPSBSZXNvdXJjZU1hbmFnZXIuZGVzZXJpYWxpemVSZXNvdXJjZShzZXJpYWxpemF0aW9uKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXNvdXJjZSlcclxuICAgICAgICAgICAgICAgICAgICBSZXNvdXJjZU1hbmFnZXIucmVzb3VyY2VzW2lkUmVzb3VyY2VdID0gcmVzb3VyY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFJlc291cmNlTWFuYWdlci5yZXNvdXJjZXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBkZXNlcmlhbGl6ZVJlc291cmNlKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogU2VyaWFsaXphYmxlUmVzb3VyY2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gPFNlcmlhbGl6YWJsZVJlc291cmNlPlNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vTGlnaHQvTGlnaHQudHNcIi8+XHJcbi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vRXZlbnQvRXZlbnQudHNcIi8+XHJcbi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vQ29tcG9uZW50L0NvbXBvbmVudExpZ2h0LnRzXCIvPlxyXG4vLyAvIDxyZWZlcmVuY2UgcGF0aD1cIi4uL01hdGgvUmVjdGFuZ2xlLnRzXCIvPlxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgdHlwZSBNYXBMaWdodFR5cGVUb0xpZ2h0TGlzdCA9IE1hcDxUeXBlT2ZMaWdodCwgQ29tcG9uZW50TGlnaHRbXT47XHJcbiAgLyoqXHJcbiAgICogQ29udHJvbHMgdGhlIHJlbmRlcmluZyBvZiBhIGJyYW5jaCBvZiBhIHNjZW5ldHJlZSwgdXNpbmcgdGhlIGdpdmVuIFtbQ29tcG9uZW50Q2FtZXJhXV0sXHJcbiAgICogYW5kIHRoZSBwcm9wYWdhdGlvbiBvZiB0aGUgcmVuZGVyZWQgaW1hZ2UgZnJvbSB0aGUgb2Zmc2NyZWVuIHJlbmRlcmJ1ZmZlciB0byB0aGUgdGFyZ2V0IGNhbnZhc1xyXG4gICAqIHRocm91Z2ggYSBzZXJpZXMgb2YgW1tGcmFtaW5nXV0gb2JqZWN0cy4gVGhlIHN0YWdlcyBpbnZvbHZlZCBhcmUgaW4gb3JkZXIgb2YgcmVuZGVyaW5nXHJcbiAgICogW1tSZW5kZXJNYW5hZ2VyXV0udmlld3BvcnQgLT4gW1tWaWV3cG9ydF1dLnNvdXJjZSAtPiBbW1ZpZXdwb3J0XV0uZGVzdGluYXRpb24gLT4gRE9NLUNhbnZhcyAtPiBDbGllbnQoQ1NTKVxyXG4gICAqIEBhdXRob3JzIEphc2NoYSBLYXJhZ8O2bCwgSEZVLCAyMDE5IHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgVmlld3BvcnQgZXh0ZW5kcyBFdmVudFRhcmdldMaSIHtcclxuICAgIHByaXZhdGUgc3RhdGljIGZvY3VzOiBWaWV3cG9ydDtcclxuXHJcbiAgICBwdWJsaWMgbmFtZTogc3RyaW5nID0gXCJWaWV3cG9ydFwiOyAvLyBUaGUgbmFtZSB0byBjYWxsIHRoaXMgdmlld3BvcnQgYnkuXHJcbiAgICBwdWJsaWMgY2FtZXJhOiBDb21wb25lbnRDYW1lcmEgPSBudWxsOyAvLyBUaGUgY2FtZXJhIHJlcHJlc2VudGluZyB0aGUgdmlldyBwYXJhbWV0ZXJzIHRvIHJlbmRlciB0aGUgYnJhbmNoLlxyXG5cclxuICAgIHB1YmxpYyByZWN0U291cmNlOiBSZWN0YW5nbGU7XHJcbiAgICBwdWJsaWMgcmVjdERlc3RpbmF0aW9uOiBSZWN0YW5nbGU7XHJcblxyXG4gICAgLy8gVE9ETzogdmVyaWZ5IGlmIGNsaWVudCB0byBjYW52YXMgc2hvdWxkIGJlIGluIFZpZXdwb3J0IG9yIHNvbWV3aGVyZSBlbHNlIChXaW5kb3csIENvbnRhaW5lcj8pXHJcbiAgICAvLyBNdWx0aXBsZSB2aWV3cG9ydHMgdXNpbmcgdGhlIHNhbWUgY2FudmFzIHNob3VsZG4ndCBkaWZmZXIgaGVyZS4uLlxyXG4gICAgLy8gZGlmZmVyZW50IGZyYW1pbmcgbWV0aG9kcyBjYW4gYmUgdXNlZCwgdGhpcyBpcyB0aGUgZGVmYXVsdFxyXG4gICAgcHVibGljIGZyYW1lQ2xpZW50VG9DYW52YXM6IEZyYW1pbmdTY2FsZWQgPSBuZXcgRnJhbWluZ1NjYWxlZCgpO1xyXG4gICAgcHVibGljIGZyYW1lQ2FudmFzVG9EZXN0aW5hdGlvbjogRnJhbWluZ0NvbXBsZXggPSBuZXcgRnJhbWluZ0NvbXBsZXgoKTtcclxuICAgIHB1YmxpYyBmcmFtZURlc3RpbmF0aW9uVG9Tb3VyY2U6IEZyYW1pbmdTY2FsZWQgPSBuZXcgRnJhbWluZ1NjYWxlZCgpO1xyXG4gICAgcHVibGljIGZyYW1lU291cmNlVG9SZW5kZXI6IEZyYW1pbmdTY2FsZWQgPSBuZXcgRnJhbWluZ1NjYWxlZCgpO1xyXG5cclxuICAgIHB1YmxpYyBhZGp1c3RpbmdGcmFtZXM6IGJvb2xlYW4gPSB0cnVlO1xyXG4gICAgcHVibGljIGFkanVzdGluZ0NhbWVyYTogYm9vbGVhbiA9IHRydWU7XHJcblxyXG4gICAgcHVibGljIGxpZ2h0czogTWFwTGlnaHRUeXBlVG9MaWdodExpc3QgPSBudWxsO1xyXG5cclxuICAgIHByaXZhdGUgYnJhbmNoOiBOb2RlID0gbnVsbDsgLy8gVGhlIGZpcnN0IG5vZGUgaW4gdGhlIHRyZWUoYnJhbmNoKSB0aGF0IHdpbGwgYmUgcmVuZGVyZWQuXHJcbiAgICBwcml2YXRlIGNyYzI6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCA9IG51bGw7XHJcbiAgICBwcml2YXRlIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQgPSBudWxsO1xyXG4gICAgcHJpdmF0ZSAgcGlja0J1ZmZlcnM6IFBpY2tCdWZmZXJbXSA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29ubmVjdHMgdGhlIHZpZXdwb3J0IHRvIHRoZSBnaXZlbiBjYW52YXMgdG8gcmVuZGVyIHRoZSBnaXZlbiBicmFuY2ggdG8gdXNpbmcgdGhlIGdpdmVuIGNhbWVyYS1jb21wb25lbnQsIGFuZCBuYW1lcyB0aGUgdmlld3BvcnQgYXMgZ2l2ZW4uXHJcbiAgICAgKiBAcGFyYW0gX25hbWUgXHJcbiAgICAgKiBAcGFyYW0gX2JyYW5jaCBcclxuICAgICAqIEBwYXJhbSBfY2FtZXJhIFxyXG4gICAgICogQHBhcmFtIF9jYW52YXMgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpbml0aWFsaXplKF9uYW1lOiBzdHJpbmcsIF9icmFuY2g6IE5vZGUsIF9jYW1lcmE6IENvbXBvbmVudENhbWVyYSwgX2NhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpOiB2b2lkIHtcclxuICAgICAgdGhpcy5uYW1lID0gX25hbWU7XHJcbiAgICAgIHRoaXMuY2FtZXJhID0gX2NhbWVyYTtcclxuICAgICAgdGhpcy5jYW52YXMgPSBfY2FudmFzO1xyXG4gICAgICB0aGlzLmNyYzIgPSBfY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuXHJcbiAgICAgIHRoaXMucmVjdFNvdXJjZSA9IFJlbmRlck1hbmFnZXIuZ2V0Q2FudmFzUmVjdCgpO1xyXG4gICAgICB0aGlzLnJlY3REZXN0aW5hdGlvbiA9IHRoaXMuZ2V0Q2xpZW50UmVjdGFuZ2xlKCk7XHJcblxyXG4gICAgICB0aGlzLnNldEJyYW5jaChfYnJhbmNoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmUgdGhlIDJELWNvbnRleHQgYXR0YWNoZWQgdG8gdGhlIGRlc3RpbmF0aW9uIGNhbnZhc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Q29udGV4dCgpOiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQge1xyXG4gICAgICByZXR1cm4gdGhpcy5jcmMyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZSB0aGUgc2l6ZSBvZiB0aGUgZGVzdGluYXRpb24gY2FudmFzIGFzIGEgcmVjdGFuZ2xlLCB4IGFuZCB5IGFyZSBhbHdheXMgMCBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldENhbnZhc1JlY3RhbmdsZSgpOiBSZWN0YW5nbGUge1xyXG4gICAgICByZXR1cm4gUmVjdGFuZ2xlLkdFVCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmUgdGhlIGNsaWVudCByZWN0YW5nbGUgdGhlIGNhbnZhcyBpcyBkaXNwbGF5ZWQgYW5kIGZpdCBpbiwgeCBhbmQgeSBhcmUgYWx3YXlzIDAgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRDbGllbnRSZWN0YW5nbGUoKTogUmVjdGFuZ2xlIHtcclxuICAgICAgLy8gRlVER0UgZG9lc24ndCBjYXJlIGFib3V0IHdoZXJlIHRoZSBjbGllbnQgcmVjdCBpcywgb25seSBhYm91dCB0aGUgc2l6ZSBtYXR0ZXJzLlxyXG4gICAgICAvLyByZXR1cm4gUmVjdGFuZ2xlLkdFVCh0aGlzLmNhbnZhcy5vZmZzZXRMZWZ0LCB0aGlzLmNhbnZhcy5vZmZzZXRUb3AsIHRoaXMuY2FudmFzLmNsaWVudFdpZHRoLCB0aGlzLmNhbnZhcy5jbGllbnRIZWlnaHQpO1xyXG4gICAgICByZXR1cm4gUmVjdGFuZ2xlLkdFVCgwLCAwLCB0aGlzLmNhbnZhcy5jbGllbnRXaWR0aCwgdGhpcy5jYW52YXMuY2xpZW50SGVpZ2h0KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgYnJhbmNoIHRvIGJlIGRyYXduIGluIHRoZSB2aWV3cG9ydC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldEJyYW5jaChfYnJhbmNoOiBOb2RlKTogdm9pZCB7XHJcbiAgICAgIGlmICh0aGlzLmJyYW5jaCkge1xyXG4gICAgICAgIHRoaXMuYnJhbmNoLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlQuQ09NUE9ORU5UX0FERCwgdGhpcy5obmRDb21wb25lbnRFdmVudCk7XHJcbiAgICAgICAgdGhpcy5icmFuY2gucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVC5DT01QT05FTlRfUkVNT1ZFLCB0aGlzLmhuZENvbXBvbmVudEV2ZW50KTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmJyYW5jaCA9IF9icmFuY2g7XHJcbiAgICAgIGlmICh0aGlzLmJyYW5jaCkge1xyXG4gICAgICAgIHRoaXMuY29sbGVjdExpZ2h0cygpO1xyXG4gICAgICAgIHRoaXMuYnJhbmNoLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuQ09NUE9ORU5UX0FERCwgdGhpcy5obmRDb21wb25lbnRFdmVudCk7XHJcbiAgICAgICAgdGhpcy5icmFuY2guYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5DT01QT05FTlRfUkVNT1ZFLCB0aGlzLmhuZENvbXBvbmVudEV2ZW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2dzIHRoaXMgdmlld3BvcnRzIHNjZW5lZ3JhcGggdG8gdGhlIGNvbnNvbGUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzaG93U2NlbmVHcmFwaCgpOiB2b2lkIHtcclxuICAgICAgLy8gVE9ETzogbW92ZSB0byBkZWJ1Zy1jbGFzc1xyXG4gICAgICBsZXQgb3V0cHV0OiBzdHJpbmcgPSBcIlNjZW5lR3JhcGggZm9yIHRoaXMgdmlld3BvcnQ6XCI7XHJcbiAgICAgIG91dHB1dCArPSBcIlxcbiBcXG5cIjtcclxuICAgICAgb3V0cHV0ICs9IHRoaXMuYnJhbmNoLm5hbWU7XHJcbiAgICAgIERlYnVnLmxvZyhvdXRwdXQgKyBcIiAgID0+IFJPT1ROT0RFXCIgKyB0aGlzLmNyZWF0ZVNjZW5lR3JhcGgodGhpcy5icmFuY2gpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAjcmVnaW9uIERyYXdpbmdcclxuICAgIC8qKlxyXG4gICAgICogRHJhdyB0aGlzIHZpZXdwb3J0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBkcmF3KCk6IHZvaWQge1xyXG4gICAgICBSZW5kZXJNYW5hZ2VyLnJlc2V0RnJhbWVCdWZmZXIoKTtcclxuICAgICAgaWYgKCF0aGlzLmNhbWVyYS5pc0FjdGl2ZSlcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIGlmICh0aGlzLmFkanVzdGluZ0ZyYW1lcylcclxuICAgICAgICB0aGlzLmFkanVzdEZyYW1lcygpO1xyXG4gICAgICBpZiAodGhpcy5hZGp1c3RpbmdDYW1lcmEpXHJcbiAgICAgICAgdGhpcy5hZGp1c3RDYW1lcmEoKTtcclxuXHJcbiAgICAgIFJlbmRlck1hbmFnZXIuY2xlYXIodGhpcy5jYW1lcmEuYmFja2dyb3VuZENvbG9yKTtcclxuICAgICAgaWYgKFJlbmRlck1hbmFnZXIuYWRkQnJhbmNoKHRoaXMuYnJhbmNoKSlcclxuICAgICAgICAvLyBicmFuY2ggaGFzIG5vdCB5ZXQgYmVlbiBwcm9jZXNzZWQgZnVsbHkgYnkgcmVuZGVybWFuYWdlciAtPiB1cGRhdGUgYWxsIHJlZ2lzdGVyZWQgbm9kZXNcclxuICAgICAgICBSZW5kZXJNYW5hZ2VyLnVwZGF0ZSgpO1xyXG4gICAgICBSZW5kZXJNYW5hZ2VyLnNldExpZ2h0cyh0aGlzLmxpZ2h0cyk7XHJcbiAgICAgIFJlbmRlck1hbmFnZXIuZHJhd0JyYW5jaCh0aGlzLmJyYW5jaCwgdGhpcy5jYW1lcmEpO1xyXG5cclxuICAgICAgdGhpcy5jcmMyLmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICB0aGlzLmNyYzIuZHJhd0ltYWdlKFxyXG4gICAgICAgIFJlbmRlck1hbmFnZXIuZ2V0Q2FudmFzKCksXHJcbiAgICAgICAgdGhpcy5yZWN0U291cmNlLngsIHRoaXMucmVjdFNvdXJjZS55LCB0aGlzLnJlY3RTb3VyY2Uud2lkdGgsIHRoaXMucmVjdFNvdXJjZS5oZWlnaHQsXHJcbiAgICAgICAgdGhpcy5yZWN0RGVzdGluYXRpb24ueCwgdGhpcy5yZWN0RGVzdGluYXRpb24ueSwgdGhpcy5yZWN0RGVzdGluYXRpb24ud2lkdGgsIHRoaXMucmVjdERlc3RpbmF0aW9uLmhlaWdodFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBEcmF3IHRoaXMgdmlld3BvcnQgZm9yIFJheUNhc3RcclxuICAgICovXHJcbiAgICBwdWJsaWMgY3JlYXRlUGlja0J1ZmZlcnMoKTogdm9pZCB7XHJcbiAgICAgIGlmICh0aGlzLmFkanVzdGluZ0ZyYW1lcylcclxuICAgICAgICB0aGlzLmFkanVzdEZyYW1lcygpO1xyXG4gICAgICBpZiAodGhpcy5hZGp1c3RpbmdDYW1lcmEpXHJcbiAgICAgICAgdGhpcy5hZGp1c3RDYW1lcmEoKTtcclxuXHJcbiAgICAgIGlmIChSZW5kZXJNYW5hZ2VyLmFkZEJyYW5jaCh0aGlzLmJyYW5jaCkpXHJcbiAgICAgICAgLy8gYnJhbmNoIGhhcyBub3QgeWV0IGJlZW4gcHJvY2Vzc2VkIGZ1bGx5IGJ5IHJlbmRlcm1hbmFnZXIgLT4gdXBkYXRlIGFsbCByZWdpc3RlcmVkIG5vZGVzXHJcbiAgICAgICAgUmVuZGVyTWFuYWdlci51cGRhdGUoKTtcclxuXHJcbiAgICAgIHRoaXMucGlja0J1ZmZlcnMgPSBSZW5kZXJNYW5hZ2VyLmRyYXdCcmFuY2hGb3JSYXlDYXN0KHRoaXMuYnJhbmNoLCB0aGlzLmNhbWVyYSk7XHJcbiAgICAgIERlYnVnLmxvZyh0aGlzLnBpY2tCdWZmZXJzWzBdLmZyYW1lQnVmZmVyKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHVibGljIHBpY2tOb2RlQXQoX3BvczogVmVjdG9yMik6IFJheUhpdFtdIHtcclxuICAgICAgLy8gdGhpcy5jcmVhdGVQaWNrQnVmZmVycygpO1xyXG4gICAgICBsZXQgaGl0czogUmF5SGl0W10gPSBSZW5kZXJNYW5hZ2VyLnBpY2tOb2RlQXQoX3BvcywgdGhpcy5waWNrQnVmZmVycywgdGhpcy5yZWN0U291cmNlKTtcclxuICAgICAgaGl0cy5zb3J0KChhOiBSYXlIaXQsIGI6IFJheUhpdCkgPT4gKGIuekJ1ZmZlciA+IDApID8gKGEuekJ1ZmZlciA+IDApID8gYS56QnVmZmVyIC0gYi56QnVmZmVyIDogMSA6IC0xKTtcclxuICAgICAgcmV0dXJuIGhpdHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGp1c3QgYWxsIGZyYW1lcyBpbnZvbHZlZCBpbiB0aGUgcmVuZGVyaW5nIHByb2Nlc3MgZnJvbSB0aGUgZGlzcGxheSBhcmVhIGluIHRoZSBjbGllbnQgdXAgdG8gdGhlIHJlbmRlcmVyIGNhbnZhc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWRqdXN0RnJhbWVzKCk6IHZvaWQge1xyXG4gICAgICAvLyBnZXQgdGhlIHJlY3RhbmdsZSBvZiB0aGUgY2FudmFzIGFyZWEgYXMgZGlzcGxheWVkIChjb25zaWRlciBjc3MpXHJcbiAgICAgIGxldCByZWN0Q2xpZW50OiBSZWN0YW5nbGUgPSB0aGlzLmdldENsaWVudFJlY3RhbmdsZSgpO1xyXG4gICAgICAvLyBhZGp1c3QgdGhlIGNhbnZhcyBzaXplIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gZnJhbWluZyBhcHBsaWVkIHRvIGNsaWVudFxyXG4gICAgICBsZXQgcmVjdENhbnZhczogUmVjdGFuZ2xlID0gdGhpcy5mcmFtZUNsaWVudFRvQ2FudmFzLmdldFJlY3QocmVjdENsaWVudCk7XHJcbiAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gcmVjdENhbnZhcy53aWR0aDtcclxuICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gcmVjdENhbnZhcy5oZWlnaHQ7XHJcbiAgICAgIC8vIGFkanVzdCB0aGUgZGVzdGluYXRpb24gYXJlYSBvbiB0aGUgdGFyZ2V0LWNhbnZhcyB0byByZW5kZXIgdG8gYnkgYXBwbHlpbmcgdGhlIGZyYW1pbmcgdG8gY2FudmFzXHJcbiAgICAgIHRoaXMucmVjdERlc3RpbmF0aW9uID0gdGhpcy5mcmFtZUNhbnZhc1RvRGVzdGluYXRpb24uZ2V0UmVjdChyZWN0Q2FudmFzKTtcclxuICAgICAgLy8gYWRqdXN0IHRoZSBhcmVhIG9uIHRoZSBzb3VyY2UtY2FudmFzIHRvIHJlbmRlciBmcm9tIGJ5IGFwcGx5aW5nIHRoZSBmcmFtaW5nIHRvIGRlc3RpbmF0aW9uIGFyZWFcclxuICAgICAgdGhpcy5yZWN0U291cmNlID0gdGhpcy5mcmFtZURlc3RpbmF0aW9uVG9Tb3VyY2UuZ2V0UmVjdCh0aGlzLnJlY3REZXN0aW5hdGlvbik7XHJcbiAgICAgIC8vIGhhdmluZyBhbiBvZmZzZXQgc291cmNlIGRvZXMgbWFrZSBzZW5zZSBvbmx5IHdoZW4gbXVsdGlwbGUgdmlld3BvcnRzIGRpc3BsYXkgcGFydHMgb2YgdGhlIHNhbWUgcmVuZGVyaW5nLiBGb3Igbm93OiBzaGlmdCBpdCB0byAwLDBcclxuICAgICAgdGhpcy5yZWN0U291cmNlLnggPSB0aGlzLnJlY3RTb3VyY2UueSA9IDA7XHJcbiAgICAgIC8vIHN0aWxsLCBhIHBhcnRpYWwgaW1hZ2Ugb2YgdGhlIHJlbmRlcmluZyBtYXkgYmUgcmV0cmlldmVkIGJ5IG1vdmluZyBhbmQgcmVzaXppbmcgdGhlIHJlbmRlciB2aWV3cG9ydFxyXG4gICAgICBsZXQgcmVjdFJlbmRlcjogUmVjdGFuZ2xlID0gdGhpcy5mcmFtZVNvdXJjZVRvUmVuZGVyLmdldFJlY3QodGhpcy5yZWN0U291cmNlKTtcclxuICAgICAgUmVuZGVyTWFuYWdlci5zZXRWaWV3cG9ydFJlY3RhbmdsZShyZWN0UmVuZGVyKTtcclxuICAgICAgLy8gbm8gbW9yZSB0cmFuc2Zvcm1hdGlvbiBhZnRlciB0aGlzIGZvciBub3csIG9mZnNjcmVlbiBjYW52YXMgYW5kIHJlbmRlci12aWV3cG9ydCBoYXZlIHRoZSBzYW1lIHNpemVcclxuICAgICAgUmVuZGVyTWFuYWdlci5zZXRDYW52YXNTaXplKHJlY3RSZW5kZXIud2lkdGgsIHJlY3RSZW5kZXIuaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRqdXN0IHRoZSBjYW1lcmEgcGFyYW1ldGVycyB0byBmaXQgdGhlIHJlbmRlcmluZyBpbnRvIHRoZSByZW5kZXIgdmllcG9ydFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWRqdXN0Q2FtZXJhKCk6IHZvaWQge1xyXG4gICAgICBsZXQgcmVjdDogUmVjdGFuZ2xlID0gUmVuZGVyTWFuYWdlci5nZXRWaWV3cG9ydFJlY3RhbmdsZSgpO1xyXG4gICAgICB0aGlzLmNhbWVyYS5wcm9qZWN0Q2VudHJhbChyZWN0LndpZHRoIC8gcmVjdC5oZWlnaHQsIHRoaXMuY2FtZXJhLmdldEZpZWxkT2ZWaWV3KCkpO1xyXG4gICAgfVxyXG4gICAgLy8gI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBQb2ludHNcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHBvaW50IG9uIHRoZSBzb3VyY2UtcmVjdGFuZ2xlIG1hdGNoaW5nIHRoZSBnaXZlbiBwb2ludCBvbiB0aGUgY2xpZW50IHJlY3RhbmdsZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcG9pbnRDbGllbnRUb1NvdXJjZShfY2xpZW50OiBWZWN0b3IyKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjIgPSB0aGlzLmZyYW1lQ2xpZW50VG9DYW52YXMuZ2V0UG9pbnQoX2NsaWVudCwgdGhpcy5nZXRDbGllbnRSZWN0YW5nbGUoKSk7XHJcbiAgICAgIHJlc3VsdCA9IHRoaXMuZnJhbWVDYW52YXNUb0Rlc3RpbmF0aW9uLmdldFBvaW50KHJlc3VsdCwgdGhpcy5nZXRDYW52YXNSZWN0YW5nbGUoKSk7XHJcbiAgICAgIHJlc3VsdCA9IHRoaXMuZnJhbWVEZXN0aW5hdGlvblRvU291cmNlLmdldFBvaW50KHJlc3VsdCwgdGhpcy5yZWN0U291cmNlKTtcclxuICAgICAgLy9UT0RPOiB3aGVuIFNvdXJjZSwgUmVuZGVyIGFuZCBSZW5kZXJWaWV3cG9ydCBkZXZpYXRlLCBjb250aW51ZSB0cmFuc2Zvcm1hdGlvbiBcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHBvaW50IG9uIHRoZSByZW5kZXItcmVjdGFuZ2xlIG1hdGNoaW5nIHRoZSBnaXZlbiBwb2ludCBvbiB0aGUgc291cmNlIHJlY3RhbmdsZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcG9pbnRTb3VyY2VUb1JlbmRlcihfc291cmNlOiBWZWN0b3IyKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCBwcm9qZWN0aW9uUmVjdGFuZ2xlOiBSZWN0YW5nbGUgPSB0aGlzLmNhbWVyYS5nZXRQcm9qZWN0aW9uUmVjdGFuZ2xlKCk7XHJcbiAgICAgIGxldCBwb2ludDogVmVjdG9yMiA9IHRoaXMuZnJhbWVTb3VyY2VUb1JlbmRlci5nZXRQb2ludChfc291cmNlLCBwcm9qZWN0aW9uUmVjdGFuZ2xlKTtcclxuICAgICAgcmV0dXJuIHBvaW50O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHBvaW50IG9uIHRoZSByZW5kZXItcmVjdGFuZ2xlIG1hdGNoaW5nIHRoZSBnaXZlbiBwb2ludCBvbiB0aGUgY2xpZW50IHJlY3RhbmdsZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcG9pbnRDbGllbnRUb1JlbmRlcihfY2xpZW50OiBWZWN0b3IyKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCBwb2ludDogVmVjdG9yMiA9IHRoaXMucG9pbnRDbGllbnRUb1NvdXJjZShfY2xpZW50KTtcclxuICAgICAgcG9pbnQgPSB0aGlzLnBvaW50U291cmNlVG9SZW5kZXIocG9pbnQpO1xyXG4gICAgICAvL1RPRE86IHdoZW4gUmVuZGVyIGFuZCBSZW5kZXJWaWV3cG9ydCBkZXZpYXRlLCBjb250aW51ZSB0cmFuc2Zvcm1hdGlvbiBcclxuICAgICAgcmV0dXJuIHBvaW50O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHBvaW50IGluIG5vcm1lZCB2aWV3LXJlY3RhbmdsZSBtYXRjaGluZyB0aGUgZ2l2ZW4gcG9pbnQgb24gdGhlIGNsaWVudCByZWN0YW5nbGVcclxuICAgICAqIFRoZSB2aWV3LXJlY3RhbmdsZSBtYXRjaGVzIHRoZSBjbGllbnQgc2l6ZSBpbiB0aGUgaHlwb3RoZXRpY2FsIGRpc3RhbmNlIG9mIDEgdG8gdGhlIGNhbWVyYSwgaXRzIG9yaWdpbiBpbiB0aGUgY2VudGVyIGFuZCB5LWF4aXMgcG9pbnRpbmcgdXBcclxuICAgICAqIFRPRE86IGV4YW1pbmUsIGlmIHRoaXMgc2hvdWxkIGJlIGEgY2FtZXJhLW1ldGhvZC4gQ3VycmVudCBpbXBsZW1lbnRhdGlvbiBpcyBmb3IgY2VudHJhbC1wcm9qZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwb2ludENsaWVudFRvUHJvamVjdGlvbihfY2xpZW50OiBWZWN0b3IyKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCBwb3NSZW5kZXI6IFZlY3RvcjIgPSB0aGlzLnBvaW50Q2xpZW50VG9SZW5kZXIoX2NsaWVudCk7XHJcbiAgICAgIGxldCByZWN0UmVuZGVyOiBSZWN0YW5nbGUgPSB0aGlzLmZyYW1lU291cmNlVG9SZW5kZXIuZ2V0UmVjdCh0aGlzLnJlY3RTb3VyY2UpO1xyXG4gICAgICBsZXQgcmVjdFByb2plY3Rpb246IFJlY3RhbmdsZSA9IHRoaXMuY2FtZXJhLmdldFByb2plY3Rpb25SZWN0YW5nbGUoKTtcclxuXHJcbiAgICAgIGxldCBwb3NQcm9qZWN0aW9uOiBWZWN0b3IyID0gbmV3IFZlY3RvcjIoXHJcbiAgICAgICAgcmVjdFByb2plY3Rpb24ud2lkdGggKiBwb3NSZW5kZXIueCAvIHJlY3RSZW5kZXIud2lkdGgsXHJcbiAgICAgICAgcmVjdFByb2plY3Rpb24uaGVpZ2h0ICogcG9zUmVuZGVyLnkgLyByZWN0UmVuZGVyLmhlaWdodFxyXG4gICAgICApO1xyXG5cclxuICAgICAgcG9zUHJvamVjdGlvbi5zdWJ0cmFjdChuZXcgVmVjdG9yMihyZWN0UHJvamVjdGlvbi53aWR0aCAvIDIsIHJlY3RQcm9qZWN0aW9uLmhlaWdodCAvIDIpKTtcclxuICAgICAgcG9zUHJvamVjdGlvbi55ICo9IC0xO1xyXG5cclxuICAgICAgcmV0dXJuIHBvc1Byb2plY3Rpb247XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcG9pbnQgaW4gdGhlIGNsaWVudCByZWN0YW5nbGUgbWF0Y2hpbmcgdGhlIGdpdmVuIHBvaW50IGluIG5vcm1lZCBjbGlwc3BhY2UgcmVjdGFuZ2xlLCBcclxuICAgICAqIHdoaWNoIHN0cmV0Y2hlcyBmcm9tIC0xIHRvIDEgaW4gYm90aCBkaW1lbnNpb25zLCB5IHBvaW50aW5nIHVwXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwb2ludENsaXBUb0NsaWVudChfbm9ybWVkOiBWZWN0b3IyKTogVmVjdG9yMiB7XHJcbiAgICAgIC8vIGxldCByZWN0Q2xpZW50OiBSZWN0YW5nbGUgPSB0aGlzLmdldENsaWVudFJlY3RhbmdsZSgpO1xyXG4gICAgICAvLyBsZXQgcmVzdWx0OiBWZWN0b3IyID0gVmVjdG9yMi5PTkUoMC41KTtcclxuICAgICAgLy8gcmVzdWx0LnggKj0gKF9ub3JtZWQueCArIDEpICogcmVjdENsaWVudC53aWR0aDtcclxuICAgICAgLy8gcmVzdWx0LnkgKj0gKDEgLSBfbm9ybWVkLnkpICogcmVjdENsaWVudC5oZWlnaHQ7XHJcbiAgICAgIC8vIHJlc3VsdC5hZGQocmVjdENsaWVudC5wb3NpdGlvbik7XHJcbiAgICAgIC8vVE9ETzogY2hlY2sgaWYgcmVjdERlc3RpbmF0aW9uIGNhbiBiZSBzYWZlbHkgKGFuZCBtb3JlIHBlcmZvbWFudCkgYmUgdXNlZCBpbnN0ZWFkIGdldENsaWVudFJlY3RhbmdsZVxyXG4gICAgICBsZXQgcG9pbnRDbGllbnQ6IFZlY3RvcjIgPSBSZW5kZXJNYW5hZ2VyLnJlY3RDbGlwLnBvaW50VG9SZWN0KF9ub3JtZWQsIHRoaXMucmVjdERlc3RpbmF0aW9uKTtcclxuICAgICAgcmV0dXJuIHBvaW50Q2xpZW50O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcG9pbnQgaW4gdGhlIGNsaWVudCByZWN0YW5nbGUgbWF0Y2hpbmcgdGhlIGdpdmVuIHBvaW50IGluIG5vcm1lZCBjbGlwc3BhY2UgcmVjdGFuZ2xlLCBcclxuICAgICAqIHdoaWNoIHN0cmV0Y2hlcyBmcm9tIC0xIHRvIDEgaW4gYm90aCBkaW1lbnNpb25zLCB5IHBvaW50aW5nIHVwXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwb2ludENsaXBUb0NhbnZhcyhfbm9ybWVkOiBWZWN0b3IyKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCBwb2ludENhbnZhczogVmVjdG9yMiA9IFJlbmRlck1hbmFnZXIucmVjdENsaXAucG9pbnRUb1JlY3QoX25vcm1lZCwgdGhpcy5nZXRDYW52YXNSZWN0YW5nbGUoKSk7XHJcbiAgICAgIHJldHVybiBwb2ludENhbnZhcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcG9pbnRDbGllbnRUb1NjcmVlbihfY2xpZW50OiBWZWN0b3IyKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCBzY3JlZW46IFZlY3RvcjIgPSBuZXcgVmVjdG9yMih0aGlzLmNhbnZhcy5vZmZzZXRMZWZ0ICsgX2NsaWVudC54LCB0aGlzLmNhbnZhcy5vZmZzZXRUb3AgKyBfY2xpZW50LnkpO1xyXG4gICAgICByZXR1cm4gc2NyZWVuO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8gI3JlZ2lvbiBFdmVudHMgKHBhc3NpbmcgZnJvbSBjYW52YXMgdG8gdmlld3BvcnQgYW5kIGZyb20gdGhlcmUgaW50byBicmFuY2gpXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHZpZXdwb3J0IGN1cnJlbnRseSBoYXMgZm9jdXMgYW5kIHRodXMgcmVjZWl2ZXMga2V5Ym9hcmQgZXZlbnRzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgaGFzRm9jdXMoKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiAoVmlld3BvcnQuZm9jdXMgPT0gdGhpcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN3aXRjaCB0aGUgdmlld3BvcnRzIGZvY3VzIG9uIG9yIG9mZi4gT25seSBvbmUgdmlld3BvcnQgaW4gb25lIEZVREdFIGluc3RhbmNlIGNhbiBoYXZlIHRoZSBmb2N1cywgdGh1cyByZWNlaXZpbmcga2V5Ym9hcmQgZXZlbnRzLiBcclxuICAgICAqIFNvIGEgdmlld3BvcnQgY3VycmVudGx5IGhhdmluZyB0aGUgZm9jdXMgd2lsbCBsb3NlIGl0LCB3aGVuIGFub3RoZXIgb25lIHJlY2VpdmVzIGl0LiBUaGUgdmlld3BvcnRzIGZpcmUgW1tFdmVudF1dcyBhY2NvcmRpbmdseS5cclxuICAgICAqICBcclxuICAgICAqIEBwYXJhbSBfb24gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRGb2N1cyhfb246IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgaWYgKF9vbikge1xyXG4gICAgICAgIGlmIChWaWV3cG9ydC5mb2N1cyA9PSB0aGlzKVxyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGlmIChWaWV3cG9ydC5mb2N1cylcclxuICAgICAgICAgIFZpZXdwb3J0LmZvY3VzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULkZPQ1VTX09VVCkpO1xyXG4gICAgICAgIFZpZXdwb3J0LmZvY3VzID0gdGhpcztcclxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULkZPQ1VTX0lOKSk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKFZpZXdwb3J0LmZvY3VzICE9IHRoaXMpXHJcbiAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuRk9DVVNfT1VUKSk7XHJcbiAgICAgICAgVmlld3BvcnQuZm9jdXMgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlLSAvIEFjdGl2YXRlcyB0aGUgZ2l2ZW4gcG9pbnRlciBldmVudCB0byBiZSBwcm9wYWdhdGVkIGludG8gdGhlIHZpZXdwb3J0IGFzIEZVREdFLUV2ZW50IFxyXG4gICAgICogQHBhcmFtIF90eXBlIFxyXG4gICAgICogQHBhcmFtIF9vbiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFjdGl2YXRlUG9pbnRlckV2ZW50KF90eXBlOiBFVkVOVF9QT0lOVEVSLCBfb246IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgdGhpcy5hY3RpdmF0ZUV2ZW50KHRoaXMuY2FudmFzLCBfdHlwZSwgdGhpcy5obmRQb2ludGVyRXZlbnQsIF9vbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlLSAvIEFjdGl2YXRlcyB0aGUgZ2l2ZW4ga2V5Ym9hcmQgZXZlbnQgdG8gYmUgcHJvcGFnYXRlZCBpbnRvIHRoZSB2aWV3cG9ydCBhcyBGVURHRS1FdmVudFxyXG4gICAgICogQHBhcmFtIF90eXBlIFxyXG4gICAgICogQHBhcmFtIF9vbiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFjdGl2YXRlS2V5Ym9hcmRFdmVudChfdHlwZTogRVZFTlRfS0VZQk9BUkQsIF9vbjogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICB0aGlzLmFjdGl2YXRlRXZlbnQodGhpcy5jYW52YXMub3duZXJEb2N1bWVudCwgX3R5cGUsIHRoaXMuaG5kS2V5Ym9hcmRFdmVudCwgX29uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGUtIC8gQWN0aXZhdGVzIHRoZSBnaXZlbiBkcmFnLWRyb3AgZXZlbnQgdG8gYmUgcHJvcGFnYXRlZCBpbnRvIHRoZSB2aWV3cG9ydCBhcyBGVURHRS1FdmVudFxyXG4gICAgICogQHBhcmFtIF90eXBlIFxyXG4gICAgICogQHBhcmFtIF9vbiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFjdGl2YXRlRHJhZ0Ryb3BFdmVudChfdHlwZTogRVZFTlRfRFJBR0RST1AsIF9vbjogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICBpZiAoX3R5cGUgPT0gRVZFTlRfRFJBR0RST1AuU1RBUlQpXHJcbiAgICAgICAgdGhpcy5jYW52YXMuZHJhZ2dhYmxlID0gX29uO1xyXG4gICAgICB0aGlzLmFjdGl2YXRlRXZlbnQodGhpcy5jYW52YXMsIF90eXBlLCB0aGlzLmhuZERyYWdEcm9wRXZlbnQsIF9vbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlLSAvIEFjdGl2YXRlcyB0aGUgd2hlZWwgZXZlbnQgdG8gYmUgcHJvcGFnYXRlZCBpbnRvIHRoZSB2aWV3cG9ydCBhcyBGVURHRS1FdmVudFxyXG4gICAgICogQHBhcmFtIF90eXBlIFxyXG4gICAgICogQHBhcmFtIF9vbiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFjdGl2YXRlV2hlZWxFdmVudChfdHlwZTogRVZFTlRfV0hFRUwsIF9vbjogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICB0aGlzLmFjdGl2YXRlRXZlbnQodGhpcy5jYW52YXMsIF90eXBlLCB0aGlzLmhuZFdoZWVsRXZlbnQsIF9vbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZSBkcmFnLWRyb3AgZXZlbnRzIGFuZCBkaXNwYXRjaCB0byB2aWV3cG9ydCBhcyBGVURHRS1FdmVudFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGhuZERyYWdEcm9wRXZlbnQ6IEV2ZW50TGlzdGVuZXIgPSAoX2V2ZW50OiBFdmVudCkgPT4ge1xyXG4gICAgICBsZXQgX2RyYWdldmVudDogRXZlbnREcmFnRHJvcCA9IDxFdmVudERyYWdEcm9wPl9ldmVudDtcclxuICAgICAgc3dpdGNoIChfZHJhZ2V2ZW50LnR5cGUpIHtcclxuICAgICAgICBjYXNlIFwiZHJhZ292ZXJcIjpcclxuICAgICAgICBjYXNlIFwiZHJvcFwiOlxyXG4gICAgICAgICAgX2RyYWdldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgX2RyYWdldmVudC5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9IFwibm9uZVwiO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcImRyYWdzdGFydFwiOlxyXG4gICAgICAgICAgLy8ganVzdCBkdW1teSBkYXRhLCAgdmFsaWQgZGF0YSBzaG91bGQgYmUgc2V0IGluIGhhbmRsZXIgcmVnaXN0ZXJlZCBieSB0aGUgdXNlclxyXG4gICAgICAgICAgX2RyYWdldmVudC5kYXRhVHJhbnNmZXIuc2V0RGF0YShcInRleHRcIiwgXCJIYWxsb1wiKTtcclxuICAgICAgICAgIC8vIFRPRE86IGNoZWNrIGlmIHRoZXJlIGlzIGEgYmV0dGVyIHNvbHV0aW9uIHRvIGhpZGUgdGhlIGdob3N0IGltYWdlIG9mIHRoZSBkcmFnZ2FibGUgb2JqZWN0XHJcbiAgICAgICAgICBfZHJhZ2V2ZW50LmRhdGFUcmFuc2Zlci5zZXREcmFnSW1hZ2UobmV3IEltYWdlKCksIDAsIDApO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgbGV0IGV2ZW50OiBFdmVudERyYWdEcm9wID0gbmV3IEV2ZW50RHJhZ0Ryb3AoXCLGklwiICsgX2V2ZW50LnR5cGUsIF9kcmFnZXZlbnQpO1xyXG4gICAgICB0aGlzLmFkZENhbnZhc1Bvc2l0aW9uKGV2ZW50KTtcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIG1hcHBlZCB0byBjYW52YXMtY29vcmRpbmF0ZXMgYXMgY2FudmFzWCwgY2FudmFzWSB0byB0aGUgZXZlbnRcclxuICAgICAqIEBwYXJhbSBldmVudFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGFkZENhbnZhc1Bvc2l0aW9uKGV2ZW50OiBFdmVudFBvaW50ZXIgfCBFdmVudERyYWdEcm9wKTogdm9pZCB7XHJcbiAgICAgIGV2ZW50LmNhbnZhc1ggPSB0aGlzLmNhbnZhcy53aWR0aCAqIGV2ZW50LnBvaW50ZXJYIC8gZXZlbnQuY2xpZW50UmVjdC53aWR0aDtcclxuICAgICAgZXZlbnQuY2FudmFzWSA9IHRoaXMuY2FudmFzLmhlaWdodCAqIGV2ZW50LnBvaW50ZXJZIC8gZXZlbnQuY2xpZW50UmVjdC5oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZSBwb2ludGVyIGV2ZW50cyBhbmQgZGlzcGF0Y2ggdG8gdmlld3BvcnQgYXMgRlVER0UtRXZlbnRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBobmRQb2ludGVyRXZlbnQ6IEV2ZW50TGlzdGVuZXIgPSAoX2V2ZW50OiBFdmVudCkgPT4ge1xyXG4gICAgICBsZXQgZXZlbnQ6IEV2ZW50UG9pbnRlciA9IG5ldyBFdmVudFBvaW50ZXIoXCLGklwiICsgX2V2ZW50LnR5cGUsIDxFdmVudFBvaW50ZXI+X2V2ZW50KTtcclxuICAgICAgdGhpcy5hZGRDYW52YXNQb3NpdGlvbihldmVudCk7XHJcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZSBrZXlib2FyZCBldmVudHMgYW5kIGRpc3BhdGNoIHRvIHZpZXdwb3J0IGFzIEZVREdFLUV2ZW50LCBpZiB0aGUgdmlld3BvcnQgaGFzIHRoZSBmb2N1c1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGhuZEtleWJvYXJkRXZlbnQ6IEV2ZW50TGlzdGVuZXIgPSAoX2V2ZW50OiBFdmVudCkgPT4ge1xyXG4gICAgICBpZiAoIXRoaXMuaGFzRm9jdXMpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBsZXQgZXZlbnQ6IEV2ZW50S2V5Ym9hcmQgPSBuZXcgRXZlbnRLZXlib2FyZChcIsaSXCIgKyBfZXZlbnQudHlwZSwgPEV2ZW50S2V5Ym9hcmQ+X2V2ZW50KTtcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlIHdoZWVsIGV2ZW50IGFuZCBkaXNwYXRjaCB0byB2aWV3cG9ydCBhcyBGVURHRS1FdmVudFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGhuZFdoZWVsRXZlbnQ6IEV2ZW50TGlzdGVuZXIgPSAoX2V2ZW50OiBFdmVudCkgPT4ge1xyXG4gICAgICBsZXQgZXZlbnQ6IEV2ZW50V2hlZWwgPSBuZXcgRXZlbnRXaGVlbChcIsaSXCIgKyBfZXZlbnQudHlwZSwgPEV2ZW50V2hlZWw+X2V2ZW50KTtcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFjdGl2YXRlRXZlbnQoX3RhcmdldDogRXZlbnRUYXJnZXQsIF90eXBlOiBzdHJpbmcsIF9oYW5kbGVyOiBFdmVudExpc3RlbmVyLCBfb246IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgX3R5cGUgPSBfdHlwZS5zbGljZSgxKTsgLy8gY2hpcCB0aGUgxpJsb3JlbnRpblxyXG4gICAgICBpZiAoX29uKVxyXG4gICAgICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihfdHlwZSwgX2hhbmRsZXIpO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKF90eXBlLCBfaGFuZGxlcik7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBobmRDb21wb25lbnRFdmVudChfZXZlbnQ6IEV2ZW50KTogdm9pZCB7XHJcbiAgICAgIERlYnVnLmxvZyhfZXZlbnQpO1xyXG4gICAgfVxyXG4gICAgLy8gI2VuZHJlZ2lvblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29sbGVjdCBhbGwgbGlnaHRzIGluIHRoZSBicmFuY2ggdG8gcGFzcyB0byBzaGFkZXJzXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY29sbGVjdExpZ2h0cygpOiB2b2lkIHtcclxuICAgICAgLy8gVE9ETzogbWFrZSBwcml2YXRlXHJcbiAgICAgIHRoaXMubGlnaHRzID0gbmV3IE1hcCgpO1xyXG4gICAgICBmb3IgKGxldCBub2RlIG9mIHRoaXMuYnJhbmNoLmJyYW5jaCkge1xyXG4gICAgICAgIGxldCBjbXBMaWdodHM6IENvbXBvbmVudExpZ2h0W10gPSBub2RlLmdldENvbXBvbmVudHMoQ29tcG9uZW50TGlnaHQpO1xyXG4gICAgICAgIGZvciAobGV0IGNtcExpZ2h0IG9mIGNtcExpZ2h0cykge1xyXG4gICAgICAgICAgbGV0IHR5cGU6IFR5cGVPZkxpZ2h0ID0gY21wTGlnaHQubGlnaHQuZ2V0VHlwZSgpO1xyXG4gICAgICAgICAgbGV0IGxpZ2h0c09mVHlwZTogQ29tcG9uZW50TGlnaHRbXSA9IHRoaXMubGlnaHRzLmdldCh0eXBlKTtcclxuICAgICAgICAgIGlmICghbGlnaHRzT2ZUeXBlKSB7XHJcbiAgICAgICAgICAgIGxpZ2h0c09mVHlwZSA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmxpZ2h0cy5zZXQodHlwZSwgbGlnaHRzT2ZUeXBlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGxpZ2h0c09mVHlwZS5wdXNoKGNtcExpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBvdXRwdXRzdHJpbmcgYXMgdmlzdWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdmlld3BvcnRzIHNjZW5lZ3JhcGguIENhbGxlZCBmb3IgdGhlIHBhc3NlZCBub2RlIGFuZCByZWN1cnNpdmUgZm9yIGFsbCBpdHMgY2hpbGRyZW4uXHJcbiAgICAgKiBAcGFyYW0gX2Z1ZGdlTm9kZSBUaGUgbm9kZSB0byBjcmVhdGUgYSBzY2VuZWdyYXBoZW50cnkgZm9yLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNyZWF0ZVNjZW5lR3JhcGgoX2Z1ZGdlTm9kZTogTm9kZSk6IHN0cmluZyB7XHJcbiAgICAgIC8vIFRPRE86IG1vdmUgdG8gZGVidWctY2xhc3NcclxuICAgICAgbGV0IG91dHB1dDogc3RyaW5nID0gXCJcIjtcclxuICAgICAgZm9yIChsZXQgbmFtZSBpbiBfZnVkZ2VOb2RlLmdldENoaWxkcmVuKCkpIHtcclxuICAgICAgICBsZXQgY2hpbGQ6IE5vZGUgPSBfZnVkZ2VOb2RlLmdldENoaWxkcmVuKClbbmFtZV07XHJcbiAgICAgICAgb3V0cHV0ICs9IFwiXFxuXCI7XHJcbiAgICAgICAgbGV0IGN1cnJlbnQ6IE5vZGUgPSBjaGlsZDtcclxuICAgICAgICBpZiAoY3VycmVudC5nZXRQYXJlbnQoKSAmJiBjdXJyZW50LmdldFBhcmVudCgpLmdldFBhcmVudCgpKVxyXG4gICAgICAgICAgb3V0cHV0ICs9IFwifFwiO1xyXG4gICAgICAgIHdoaWxlIChjdXJyZW50LmdldFBhcmVudCgpICYmIGN1cnJlbnQuZ2V0UGFyZW50KCkuZ2V0UGFyZW50KCkpIHtcclxuICAgICAgICAgIG91dHB1dCArPSBcIiAgIFwiO1xyXG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuZ2V0UGFyZW50KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG91dHB1dCArPSBcIictLVwiO1xyXG5cclxuICAgICAgICBvdXRwdXQgKz0gY2hpbGQubmFtZTtcclxuICAgICAgICBvdXRwdXQgKz0gdGhpcy5jcmVhdGVTY2VuZUdyYXBoKGNoaWxkKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAgIGV4cG9ydCBjb25zdCBlbnVtIEVWRU5UX0FVRElPIHtcclxuICAgICAgLyoqIGJyb2FkY2FzdCB0byBhIFtbTm9kZV1dIGFuZCBhbGwgW1tOb2Rlc11dIGluIHRoZSBicmFuY2ggaXQncyB0aGUgcm9vdCBvZiBhZnRlciBpdCB3YXMgYXBwZW5kZWQgdG8gYSBwYXJlbnQgKi9cclxuICAgICAgQ0hJTERfQVBQRU5EID0gXCJjaGlsZEFwcGVuZFRvQXVkaW9CcmFuY2hcIixcclxuICAgICAgLyoqIGJyb2FkY2FzdCB0byBhIFtbTm9kZV1dIGFuZCBhbGwgW1tOb2Rlc11dIGluIHRoZSBicmFuY2ggaXQncyB0aGUgcm9vdCBvZiBqdXN0IGJlZm9yZSBpdHMgYmVpbmcgcmVtb3ZlZCBmcm9tIGl0cyBwYXJlbnQgKi9cclxuICAgICAgQ0hJTERfUkVNT1ZFID0gXCJjaGlsZFJlbW92ZUZyb21BdWRpb0JyYW5jaFwiLFxyXG4gICAgICAvKiogYnJvYWRjYXN0IHRvIGEgW1tOb2RlXV0gYW5kIGFsbCBbW05vZGVzXV0gaW4gdGhlIGJyYW5jaCB0byB1cGRhdGUgdGhlIHBhbm5lcnMgaW4gQXVkaW9Db21wb25lbnRzICovXHJcbiAgICAgIFVQREFURSA9IFwidXBkYXRlQXVkaW9CcmFuY2hcIlxyXG4gICAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgICBleHBvcnQgY29uc3QgZW51bSBFVkVOVF9EUkFHRFJPUCB7XHJcbiAgICAgICAgRFJBRyA9IFwixpJkcmFnXCIsXHJcbiAgICAgICAgRFJPUCA9IFwixpJkcm9wXCIsXHJcbiAgICAgICAgU1RBUlQgPSBcIsaSZHJhZ3N0YXJ0XCIsXHJcbiAgICAgICAgRU5EID0gXCLGkmRyYWdlbmRcIixcclxuICAgICAgICBPVkVSID0gXCLGkmRyYWdvdmVyXCJcclxuICAgIH1cclxuXHJcbiAgICBleHBvcnQgY2xhc3MgRXZlbnREcmFnRHJvcCBleHRlbmRzIERyYWdFdmVudCB7XHJcbiAgICAgICAgcHVibGljIHBvaW50ZXJYOiBudW1iZXI7XHJcbiAgICAgICAgcHVibGljIHBvaW50ZXJZOiBudW1iZXI7XHJcbiAgICAgICAgcHVibGljIGNhbnZhc1g6IG51bWJlcjtcclxuICAgICAgICBwdWJsaWMgY2FudmFzWTogbnVtYmVyO1xyXG4gICAgICAgIHB1YmxpYyBjbGllbnRSZWN0OiBDbGllbnRSZWN0O1xyXG5cclxuICAgICAgICBjb25zdHJ1Y3Rvcih0eXBlOiBzdHJpbmcsIF9ldmVudDogRXZlbnREcmFnRHJvcCkge1xyXG4gICAgICAgICAgICBzdXBlcih0eXBlLCBfZXZlbnQpO1xyXG4gICAgICAgICAgICBsZXQgdGFyZ2V0OiBIVE1MRWxlbWVudCA9IDxIVE1MRWxlbWVudD5fZXZlbnQudGFyZ2V0O1xyXG4gICAgICAgICAgICB0aGlzLmNsaWVudFJlY3QgPSB0YXJnZXQuZ2V0Q2xpZW50UmVjdHMoKVswXTtcclxuICAgICAgICAgICAgdGhpcy5wb2ludGVyWCA9IF9ldmVudC5jbGllbnRYIC0gdGhpcy5jbGllbnRSZWN0LmxlZnQ7XHJcbiAgICAgICAgICAgIHRoaXMucG9pbnRlclkgPSBfZXZlbnQuY2xpZW50WSAtIHRoaXMuY2xpZW50UmVjdC50b3A7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgICBleHBvcnQgY2xhc3MgRXZlbnRLZXlib2FyZCBleHRlbmRzIEtleWJvYXJkRXZlbnQge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKHR5cGU6IHN0cmluZywgX2V2ZW50OiBFdmVudEtleWJvYXJkKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKHR5cGUsIF9ldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwcGluZ3Mgb2Ygc3RhbmRhcmQgRE9NL0Jyb3dzZXItRXZlbnRzIGFzIHBhc3NlZCBmcm9tIGEgY2FudmFzIHRvIHRoZSB2aWV3cG9ydFxyXG4gICAgICovXHJcbiAgICBleHBvcnQgY29uc3QgZW51bSBFVkVOVF9LRVlCT0FSRCB7XHJcbiAgICAgICAgVVAgPSBcIsaSa2V5dXBcIixcclxuICAgICAgICBET1dOID0gXCLGkmtleWRvd25cIlxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGNvZGVzIHNlbnQgZnJvbSBhIHN0YW5kYXJkIGVuZ2xpc2gga2V5Ym9hcmQgbGF5b3V0XHJcbiAgICAgKi9cclxuICAgIGV4cG9ydCBlbnVtIEtFWUJPQVJEX0NPREUge1xyXG4gICAgICAgIEEgPSBcIktleUFcIixcclxuICAgICAgICBCID0gXCJLZXlCXCIsXHJcbiAgICAgICAgQyA9IFwiS2V5Q1wiLFxyXG4gICAgICAgIEQgPSBcIktleURcIixcclxuICAgICAgICBFID0gXCJLZXlFXCIsXHJcbiAgICAgICAgRiA9IFwiS2V5RlwiLFxyXG4gICAgICAgIEcgPSBcIktleUdcIixcclxuICAgICAgICBIID0gXCJLZXlIXCIsXHJcbiAgICAgICAgSSA9IFwiS2V5SVwiLFxyXG4gICAgICAgIEogPSBcIktleUpcIixcclxuICAgICAgICBLID0gXCJLZXlLXCIsXHJcbiAgICAgICAgTCA9IFwiS2V5TFwiLFxyXG4gICAgICAgIE0gPSBcIktleU1cIixcclxuICAgICAgICBOID0gXCJLZXlOXCIsXHJcbiAgICAgICAgTyA9IFwiS2V5T1wiLFxyXG4gICAgICAgIFAgPSBcIktleVBcIixcclxuICAgICAgICBRID0gXCJLZXlRXCIsXHJcbiAgICAgICAgUiA9IFwiS2V5UlwiLFxyXG4gICAgICAgIFMgPSBcIktleVNcIixcclxuICAgICAgICBUID0gXCJLZXlUXCIsXHJcbiAgICAgICAgVSA9IFwiS2V5VVwiLFxyXG4gICAgICAgIFYgPSBcIktleVZcIixcclxuICAgICAgICBXID0gXCJLZXlXXCIsXHJcbiAgICAgICAgWCA9IFwiS2V5WFwiLFxyXG4gICAgICAgIFkgPSBcIktleVlcIixcclxuICAgICAgICBaID0gXCJLZXlaXCIsXHJcbiAgICAgICAgRVNDID0gXCJFc2NhcGVcIixcclxuICAgICAgICBaRVJPID0gXCJEaWdpdDBcIixcclxuICAgICAgICBPTkUgPSBcIkRpZ2l0MVwiLFxyXG4gICAgICAgIFRXTyA9IFwiRGlnaXQyXCIsXHJcbiAgICAgICAgVEhSRUUgPSBcIkRpZ2l0M1wiLFxyXG4gICAgICAgIEZPVVIgPSBcIkRpZ2l0NFwiLFxyXG4gICAgICAgIEZJVkUgPSBcIkRpZ2l0NVwiLFxyXG4gICAgICAgIFNJWCA9IFwiRGlnaXQ2XCIsXHJcbiAgICAgICAgU0VWRU4gPSBcIkRpZ2l0N1wiLFxyXG4gICAgICAgIEVJR0hUID0gXCJEaWdpdDhcIixcclxuICAgICAgICBOSU5FID0gXCJEaWdpdDlcIixcclxuICAgICAgICBNSU5VUyA9IFwiTWludXNcIixcclxuICAgICAgICBFUVVBTCA9IFwiRXF1YWxcIixcclxuICAgICAgICBCQUNLU1BBQ0UgPSBcIkJhY2tzcGFjZVwiLFxyXG4gICAgICAgIFRBQlVMQVRPUiA9IFwiVGFiXCIsXHJcbiAgICAgICAgQlJBQ0tFVF9MRUZUID0gXCJCcmFja2V0TGVmdFwiLFxyXG4gICAgICAgIEJSQUNLRVRfUklHSFQgPSBcIkJyYWNrZXRSaWdodFwiLFxyXG4gICAgICAgIEVOVEVSID0gXCJFbnRlclwiLFxyXG4gICAgICAgIENUUkxfTEVGVCA9IFwiQ29udHJvbExlZnRcIixcclxuICAgICAgICBTRU1JQ09MT04gPSBcIlNlbWljb2xvblwiLFxyXG4gICAgICAgIFFVT1RFID0gXCJRdW90ZVwiLFxyXG4gICAgICAgIEJBQ0tfUVVPVEUgPSBcIkJhY2txdW90ZVwiLFxyXG4gICAgICAgIFNISUZUX0xFRlQgPSBcIlNoaWZ0TGVmdFwiLFxyXG4gICAgICAgIEJBQ0tTTEFTSCA9IFwiQmFja3NsYXNoXCIsXHJcbiAgICAgICAgQ09NTUEgPSBcIkNvbW1hXCIsXHJcbiAgICAgICAgUEVSSU9EID0gXCJQZXJpb2RcIixcclxuICAgICAgICBTTEFTSCA9IFwiU2xhc2hcIixcclxuICAgICAgICBTSElGVF9SSUdIVCA9IFwiU2hpZnRSaWdodFwiLFxyXG4gICAgICAgIE5VTVBBRF9NVUxUSVBMWSA9IFwiTnVtcGFkTXVsdGlwbHlcIixcclxuICAgICAgICBBTFRfTEVGVCA9IFwiQWx0TGVmdFwiLFxyXG4gICAgICAgIFNQQUNFID0gXCJTcGFjZVwiLFxyXG4gICAgICAgIENBUFNfTE9DSyA9IFwiQ2Fwc0xvY2tcIixcclxuICAgICAgICBGMSA9IFwiRjFcIixcclxuICAgICAgICBGMiA9IFwiRjJcIixcclxuICAgICAgICBGMyA9IFwiRjNcIixcclxuICAgICAgICBGNCA9IFwiRjRcIixcclxuICAgICAgICBGNSA9IFwiRjVcIixcclxuICAgICAgICBGNiA9IFwiRjZcIixcclxuICAgICAgICBGNyA9IFwiRjdcIixcclxuICAgICAgICBGOCA9IFwiRjhcIixcclxuICAgICAgICBGOSA9IFwiRjlcIixcclxuICAgICAgICBGMTAgPSBcIkYxMFwiLFxyXG4gICAgICAgIFBBVVNFID0gXCJQYXVzZVwiLFxyXG4gICAgICAgIFNDUk9MTF9MT0NLID0gXCJTY3JvbGxMb2NrXCIsXHJcbiAgICAgICAgTlVNUEFENyA9IFwiTnVtcGFkN1wiLFxyXG4gICAgICAgIE5VTVBBRDggPSBcIk51bXBhZDhcIixcclxuICAgICAgICBOVU1QQUQ5ID0gXCJOdW1wYWQ5XCIsXHJcbiAgICAgICAgTlVNUEFEX1NVQlRSQUNUID0gXCJOdW1wYWRTdWJ0cmFjdFwiLFxyXG4gICAgICAgIE5VTVBBRDQgPSBcIk51bXBhZDRcIixcclxuICAgICAgICBOVU1QQUQ1ID0gXCJOdW1wYWQ1XCIsXHJcbiAgICAgICAgTlVNUEFENiA9IFwiTnVtcGFkNlwiLFxyXG4gICAgICAgIE5VTVBBRF9BREQgPSBcIk51bXBhZEFkZFwiLFxyXG4gICAgICAgIE5VTVBBRDEgPSBcIk51bXBhZDFcIixcclxuICAgICAgICBOVU1QQUQyID0gXCJOdW1wYWQyXCIsXHJcbiAgICAgICAgTlVNUEFEMyA9IFwiTnVtcGFkM1wiLFxyXG4gICAgICAgIE5VTVBBRDAgPSBcIk51bXBhZDBcIixcclxuICAgICAgICBOVU1QQURfREVDSU1BTCA9IFwiTnVtcGFkRGVjaW1hbFwiLFxyXG4gICAgICAgIFBSSU5UX1NDUkVFTiA9IFwiUHJpbnRTY3JlZW5cIixcclxuICAgICAgICBJTlRMX0JBQ0tfU0xBU0ggPSBcIkludGxCYWNrU2xhc2hcIixcclxuICAgICAgICBGMTEgPSBcIkYxMVwiLFxyXG4gICAgICAgIEYxMiA9IFwiRjEyXCIsXHJcbiAgICAgICAgTlVNUEFEX0VRVUFMID0gXCJOdW1wYWRFcXVhbFwiLFxyXG4gICAgICAgIEYxMyA9IFwiRjEzXCIsXHJcbiAgICAgICAgRjE0ID0gXCJGMTRcIixcclxuICAgICAgICBGMTUgPSBcIkYxNVwiLFxyXG4gICAgICAgIEYxNiA9IFwiRjE2XCIsXHJcbiAgICAgICAgRjE3ID0gXCJGMTdcIixcclxuICAgICAgICBGMTggPSBcIkYxOFwiLFxyXG4gICAgICAgIEYxOSA9IFwiRjE5XCIsXHJcbiAgICAgICAgRjIwID0gXCJGMjBcIixcclxuICAgICAgICBGMjEgPSBcIkYyMVwiLFxyXG4gICAgICAgIEYyMiA9IFwiRjIyXCIsXHJcbiAgICAgICAgRjIzID0gXCJGMjNcIixcclxuICAgICAgICBGMjQgPSBcIkYyNFwiLFxyXG4gICAgICAgIEtBTkFfTU9ERSA9IFwiS2FuYU1vZGVcIixcclxuICAgICAgICBMQU5HMiA9IFwiTGFuZzJcIixcclxuICAgICAgICBMQU5HMSA9IFwiTGFuZzFcIixcclxuICAgICAgICBJTlRMX1JPID0gXCJJbnRsUm9cIixcclxuICAgICAgICBDT05WRVJUID0gXCJDb252ZXJ0XCIsXHJcbiAgICAgICAgTk9OX0NPTlZFUlQgPSBcIk5vbkNvbnZlcnRcIixcclxuICAgICAgICBJTlRMX1lFTiA9IFwiSW50bFllblwiLFxyXG4gICAgICAgIE5VTVBBRF9DT01NQSA9IFwiTnVtcGFkQ29tbWFcIixcclxuICAgICAgICBVTkRPID0gXCJVbmRvXCIsXHJcbiAgICAgICAgUEFTVEUgPSBcIlBhc3RlXCIsXHJcbiAgICAgICAgTUVESUFfVFJBQ0tfUFJFVklPVVMgPSBcIk1lZGlhVHJhY2tQcmV2aW91c1wiLFxyXG4gICAgICAgIENVVCA9IFwiQ3V0XCIsXHJcbiAgICAgICAgQ09QWSA9IFwiQ29weVwiLFxyXG4gICAgICAgIE1FRElBX1RSQUNLX05FWFQgPSBcIk1lZGlhVHJhY2tOZXh0XCIsXHJcbiAgICAgICAgTlVNUEFEX0VOVEVSID0gXCJOdW1wYWRFbnRlclwiLFxyXG4gICAgICAgIENUUkxfUklHSFQgPSBcIkNvbnRyb2xSaWdodFwiLFxyXG4gICAgICAgIEFVRElPX1ZPTFVNRV9NVVRFID0gXCJBdWRpb1ZvbHVtZU11dGVcIixcclxuICAgICAgICBMQVVOQ0hfQVBQMiA9IFwiTGF1bmNoQXBwMlwiLFxyXG4gICAgICAgIE1FRElBX1BMQVlfUEFVU0UgPSBcIk1lZGlhUGxheVBhdXNlXCIsXHJcbiAgICAgICAgTUVESUFfU1RPUCA9IFwiTWVkaWFTdG9wXCIsXHJcbiAgICAgICAgRUpFQ1QgPSBcIkVqZWN0XCIsXHJcbiAgICAgICAgQVVESU9fVk9MVU1FX0RPV04gPSBcIkF1ZGlvVm9sdW1lRG93blwiLFxyXG4gICAgICAgIFZPTFVNRV9ET1dOID0gXCJWb2x1bWVEb3duXCIsXHJcbiAgICAgICAgQVVESU9fVk9MVU1FX1VQID0gXCJBdWRpb1ZvbHVtZVVwXCIsXHJcbiAgICAgICAgVk9MVU1FX1VQID0gXCJWb2x1bWVVcFwiLFxyXG4gICAgICAgIEJST1dTRVJfSE9NRSA9IFwiQnJvd3NlckhvbWVcIixcclxuICAgICAgICBOVU1QQURfRElWSURFID0gXCJOdW1wYWREaXZpZGVcIixcclxuICAgICAgICBBTFRfUklHSFQgPSBcIkFsdFJpZ2h0XCIsXHJcbiAgICAgICAgSEVMUCA9IFwiSGVscFwiLFxyXG4gICAgICAgIE5VTV9MT0NLID0gXCJOdW1Mb2NrXCIsXHJcbiAgICAgICAgSE9NRSA9IFwiSG9tZVwiLFxyXG4gICAgICAgIEFSUk9XX1VQID0gXCJBcnJvd1VwXCIsXHJcbiAgICAgICAgQVJST1dfUklHSFQgPSBcIkFycm93UmlnaHRcIixcclxuICAgICAgICBBUlJPV19ET1dOID0gXCJBcnJvd0Rvd25cIixcclxuICAgICAgICBBUlJPV19MRUZUID0gXCJBcnJvd0xlZnRcIixcclxuICAgICAgICBFTkQgPSBcIkVuZFwiLFxyXG4gICAgICAgIFBBR0VfVVAgPSBcIlBhZ2VVcFwiLFxyXG4gICAgICAgIFBBR0VfRE9XTiA9IFwiUGFnZURvd25cIixcclxuICAgICAgICBJTlNFUlQgPSBcIkluc2VydFwiLFxyXG4gICAgICAgIERFTEVURSA9IFwiRGVsZXRlXCIsXHJcbiAgICAgICAgTUVUQV9MRUZUID0gXCJNZXRhX0xlZnRcIixcclxuICAgICAgICBPU19MRUZUID0gXCJPU0xlZnRcIixcclxuICAgICAgICBNRVRBX1JJR0hUID0gXCJNZXRhUmlnaHRcIixcclxuICAgICAgICBPU19SSUdIVCA9IFwiT1NSaWdodFwiLFxyXG4gICAgICAgIENPTlRFWFRfTUVOVSA9IFwiQ29udGV4dE1lbnVcIixcclxuICAgICAgICBQT1dFUiA9IFwiUG93ZXJcIixcclxuICAgICAgICBCUk9XU0VSX1NFQVJDSCA9IFwiQnJvd3NlclNlYXJjaFwiLFxyXG4gICAgICAgIEJST1dTRVJfRkFWT1JJVEVTID0gXCJCcm93c2VyRmF2b3JpdGVzXCIsXHJcbiAgICAgICAgQlJPV1NFUl9SRUZSRVNIID0gXCJCcm93c2VyUmVmcmVzaFwiLFxyXG4gICAgICAgIEJST1dTRVJfU1RPUCA9IFwiQnJvd3NlclN0b3BcIixcclxuICAgICAgICBCUk9XU0VSX0ZPUldBUkQgPSBcIkJyb3dzZXJGb3J3YXJkXCIsXHJcbiAgICAgICAgQlJPV1NFUl9CQUNLID0gXCJCcm93c2VyQmFja1wiLFxyXG4gICAgICAgIExBVU5DSF9BUFAxID0gXCJMYXVuY2hBcHAxXCIsXHJcbiAgICAgICAgTEFVTkNIX01BSUwgPSBcIkxhdW5jaE1haWxcIixcclxuICAgICAgICBMQVVOQ0hfTUVESUFfUExBWUVSID0gXCJMYXVuY2hNZWRpYVBsYXllclwiLFxyXG5cclxuICAgICAgICAvL21hYyBicmluZ3MgdGhpcyBidXR0dG9uXHJcbiAgICAgICAgRk4gPSBcIkZuXCIsIC8vbm8gZXZlbnQgZmlyZWQgYWN0dWFsbHlcclxuXHJcbiAgICAgICAgLy9MaW51eCBicmluZ3MgdGhlc2VcclxuICAgICAgICBBR0FJTiA9IFwiQWdhaW5cIixcclxuICAgICAgICBQUk9QUyA9IFwiUHJvcHNcIixcclxuICAgICAgICBTRUxFQ1QgPSBcIlNlbGVjdFwiLFxyXG4gICAgICAgIE9QRU4gPSBcIk9wZW5cIixcclxuICAgICAgICBGSU5EID0gXCJGaW5kXCIsXHJcbiAgICAgICAgV0FLRV9VUCA9IFwiV2FrZVVwXCIsXHJcbiAgICAgICAgTlVNUEFEX1BBUkVOVF9MRUZUID0gXCJOdW1wYWRQYXJlbnRMZWZ0XCIsXHJcbiAgICAgICAgTlVNUEFEX1BBUkVOVF9SSUdIVCA9IFwiTnVtcGFkUGFyZW50UmlnaHRcIixcclxuXHJcbiAgICAgICAgLy9hbmRyb2lkXHJcbiAgICAgICAgU0xFRVAgPSBcIlNsZWVwXCJcclxuICAgIH1cclxuICAgIC8qIFxyXG4gICAgRmlyZWZveCBjYW4ndCBtYWtlIHVzZSBvZiB0aG9zZSBidXR0b25zIGFuZCBDb21iaW5hdGlvbnM6XHJcbiAgICBTSU5HRUxFX0JVVFRPTlM6XHJcbiAgICAgRHJ1Y2ssXHJcbiAgICBDT01CSU5BVElPTlM6XHJcbiAgICAgU2hpZnQgKyBGMTAsIFNoaWZ0ICsgTnVtcGFkNSxcclxuICAgICBDVFJMICsgcSwgQ1RSTCArIEY0LFxyXG4gICAgIEFMVCArIEYxLCBBTFQgKyBGMiwgQUxUICsgRjMsIEFMVCArIEY3LCBBTFQgKyBGOCwgQUxUICsgRjEwXHJcbiAgICBPcGVyYSB3b24ndCBkbyBnb29kIHdpdGggdGhlc2UgQnV0dG9ucyBhbmQgY29tYmluYXRpb25zOlxyXG4gICAgU0lOR0xFX0JVVFRPTlM6XHJcbiAgICAgRmxvYXQzMkFycmF5LCBGMTEsIEFMVCxcclxuICAgIENPTUJJTkFUSU9OUzpcclxuICAgICBDVFJMICsgcSwgQ1RSTCArIHQsIENUUkwgKyBoLCBDVFJMICsgZywgQ1RSTCArIG4sIENUUkwgKyBmIFxyXG4gICAgIEFMVCArIEYxLCBBTFQgKyBGMiwgQUxUICsgRjQsIEFMVCArIEY1LCBBTFQgKyBGNiwgQUxUICsgRjcsIEFMVCArIEY4LCBBTFQgKyBGMTBcclxuICAgICAqL1xyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgICBleHBvcnQgY29uc3QgZW51bSBFVkVOVF9QT0lOVEVSIHtcclxuICAgICAgICBVUCA9IFwixpJwb2ludGVydXBcIixcclxuICAgICAgICBET1dOID0gXCLGknBvaW50ZXJkb3duXCIsXHJcbiAgICAgICAgTU9WRSA9IFwixpJwb2ludGVybW92ZVwiLFxyXG4gICAgICAgIE9WRVIgPSBcIsaScG9pbnRlcm92ZXJcIixcclxuICAgICAgICBFTlRFUiA9IFwixpJwb2ludGVyZW50ZXJcIixcclxuICAgICAgICBDQU5DRUwgPSBcIsaScG9pbnRlcmNhbmNlbFwiLFxyXG4gICAgICAgIE9VVCA9IFwixpJwb2ludGVyb3V0XCIsXHJcbiAgICAgICAgTEVBVkUgPSBcIsaScG9pbnRlcmxlYXZlXCIsXHJcbiAgICAgICAgR09UQ0FQVFVSRSA9IFwixpJnb3Rwb2ludGVyY2FwdHVyZVwiLFxyXG4gICAgICAgIExPU1RDQVBUVVJFID0gXCLGkmxvc3Rwb2ludGVyY2FwdHVyZVwiXHJcbiAgICB9XHJcblxyXG4gICAgZXhwb3J0IGNsYXNzIEV2ZW50UG9pbnRlciBleHRlbmRzIFBvaW50ZXJFdmVudCB7XHJcbiAgICAgICAgcHVibGljIHBvaW50ZXJYOiBudW1iZXI7XHJcbiAgICAgICAgcHVibGljIHBvaW50ZXJZOiBudW1iZXI7XHJcbiAgICAgICAgcHVibGljIGNhbnZhc1g6IG51bWJlcjtcclxuICAgICAgICBwdWJsaWMgY2FudmFzWTogbnVtYmVyO1xyXG4gICAgICAgIHB1YmxpYyBjbGllbnRSZWN0OiBDbGllbnRSZWN0O1xyXG5cclxuICAgICAgICBjb25zdHJ1Y3Rvcih0eXBlOiBzdHJpbmcsIF9ldmVudDogRXZlbnRQb2ludGVyKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKHR5cGUsIF9ldmVudCk7XHJcbiAgICAgICAgICAgIGxldCB0YXJnZXQ6IEhUTUxFbGVtZW50ID0gPEhUTUxFbGVtZW50Pl9ldmVudC50YXJnZXQ7XHJcbiAgICAgICAgICAgIHRoaXMuY2xpZW50UmVjdCA9IHRhcmdldC5nZXRDbGllbnRSZWN0cygpWzBdO1xyXG4gICAgICAgICAgICB0aGlzLnBvaW50ZXJYID0gX2V2ZW50LmNsaWVudFggLSB0aGlzLmNsaWVudFJlY3QubGVmdDtcclxuICAgICAgICAgICAgdGhpcy5wb2ludGVyWSA9IF9ldmVudC5jbGllbnRZIC0gdGhpcy5jbGllbnRSZWN0LnRvcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAgIGV4cG9ydCBjb25zdCBlbnVtIEVWRU5UX1RJTUVSIHtcclxuICAgICAgICBDQUxMID0gXCLGkmxhcHNlXCJcclxuICAgIH1cclxuXHJcbiAgICBleHBvcnQgY2xhc3MgRXZlbnRUaW1lciB7XHJcbiAgICAgICAgcHVibGljIHR5cGU6IEVWRU5UX1RJTUVSID0gRVZFTlRfVElNRVIuQ0FMTDtcclxuICAgICAgICBwdWJsaWMgdGFyZ2V0OiBUaW1lcjtcclxuICAgICAgICBwdWJsaWMgYXJndW1lbnRzOiBPYmplY3RbXTtcclxuICAgICAgICBwdWJsaWMgZmlyc3RDYWxsOiBib29sZWFuID0gdHJ1ZTtcclxuICAgICAgICBwdWJsaWMgbGFzdENhbGw6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICAgICAgY29uc3RydWN0b3IoX3RpbWVyOiBUaW1lciwgLi4uX2FyZ3VtZW50czogT2JqZWN0W10pIHtcclxuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSBfdGltZXI7XHJcbiAgICAgICAgICAgIHRoaXMuYXJndW1lbnRzID0gX2FyZ3VtZW50cztcclxuICAgICAgICAgICAgdGhpcy5maXJzdENhbGwgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gICAgZXhwb3J0IGNvbnN0IGVudW0gRVZFTlRfV0hFRUwge1xyXG4gICAgICAgIFdIRUVMID0gXCLGkndoZWVsXCJcclxuICAgIH1cclxuICAgIFxyXG4gICAgZXhwb3J0IGNsYXNzIEV2ZW50V2hlZWwgZXh0ZW5kcyBXaGVlbEV2ZW50IHtcclxuICAgICAgICBjb25zdHJ1Y3Rvcih0eXBlOiBzdHJpbmcsIF9ldmVudDogRXZlbnRXaGVlbCkge1xyXG4gICAgICAgICAgICBzdXBlcih0eXBlLCBfZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gICAgZXhwb3J0IHR5cGUgVHlwZU9mTGlnaHQgPSBuZXcgKCkgPT4gTGlnaHQ7XHJcbiAgICAvKipcclxuICAgICAqIEJhc2VjbGFzcyBmb3IgZGlmZmVyZW50IGtpbmRzIG9mIGxpZ2h0cy4gXHJcbiAgICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAgICovXHJcbiAgICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgTGlnaHQgZXh0ZW5kcyBNdXRhYmxlIHtcclxuICAgICAgICBwdWJsaWMgY29sb3I6IENvbG9yO1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKF9jb2xvcjogQ29sb3IgPSBuZXcgQ29sb3IoMSwgMSwgMSwgMSkpIHtcclxuICAgICAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICAgICAgdGhpcy5jb2xvciA9IF9jb2xvcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBnZXRUeXBlKCk6IFR5cGVPZkxpZ2h0IHtcclxuICAgICAgICAgICAgcmV0dXJuIDxUeXBlT2ZMaWdodD50aGlzLmNvbnN0cnVjdG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcigpOiB2b2lkIHsvKiovIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFtYmllbnQgbGlnaHQsIGNvbWluZyBmcm9tIGFsbCBkaXJlY3Rpb25zLCBpbGx1bWluYXRpbmcgZXZlcnl0aGluZyB3aXRoIGl0cyBjb2xvciBpbmRlcGVuZGVudCBvZiBwb3NpdGlvbiBhbmQgb3JpZW50YXRpb24gKGxpa2UgYSBmb2dneSBkYXkgb3IgaW4gdGhlIHNoYWRlcykgIFxyXG4gICAgICogYGBgcGxhaW50ZXh0XHJcbiAgICAgKiB+IH4gfiAgXHJcbiAgICAgKiAgfiB+IH4gIFxyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIGV4cG9ydCBjbGFzcyBMaWdodEFtYmllbnQgZXh0ZW5kcyBMaWdodCB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoX2NvbG9yOiBDb2xvciA9IG5ldyBDb2xvcigxLCAxLCAxLCAxKSkge1xyXG4gICAgICAgICAgICBzdXBlcihfY29sb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGlyZWN0aW9uYWwgbGlnaHQsIGlsbHVtaW5hdGluZyBldmVyeXRoaW5nIGZyb20gYSBzcGVjaWZpZWQgZGlyZWN0aW9uIHdpdGggaXRzIGNvbG9yIChsaWtlIHN0YW5kaW5nIGluIGJyaWdodCBzdW5saWdodCkgIFxyXG4gICAgICogYGBgcGxhaW50ZXh0XHJcbiAgICAgKiAtLS0+ICBcclxuICAgICAqIC0tLT4gIFxyXG4gICAgICogLS0tPiAgXHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgZXhwb3J0IGNsYXNzIExpZ2h0RGlyZWN0aW9uYWwgZXh0ZW5kcyBMaWdodCB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoX2NvbG9yOiBDb2xvciA9IG5ldyBDb2xvcigxLCAxLCAxLCAxKSkge1xyXG4gICAgICAgICAgICBzdXBlcihfY29sb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT21uaWRpcmVjdGlvbmFsIGxpZ2h0IGVtaXR0aW5nIGZyb20gaXRzIHBvc2l0aW9uLCBpbGx1bWluYXRpbmcgb2JqZWN0cyBkZXBlbmRpbmcgb24gdGhlaXIgcG9zaXRpb24gYW5kIGRpc3RhbmNlIHdpdGggaXRzIGNvbG9yIChsaWtlIGEgY29sb3JlZCBsaWdodCBidWxiKSAgXHJcbiAgICAgKiBgYGBwbGFpbnRleHRcclxuICAgICAqICAgICAgICAgLlxcfC8uXHJcbiAgICAgKiAgICAgICAgLS0gbyAtLVxyXG4gICAgICogICAgICAgICDCtC98XFxgXHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgZXhwb3J0IGNsYXNzIExpZ2h0UG9pbnQgZXh0ZW5kcyBMaWdodCB7XHJcbiAgICAgICAgcHVibGljIHJhbmdlOiBudW1iZXIgPSAxMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3BvdCBsaWdodCBlbWl0dGluZyB3aXRoaW4gYSBzcGVjaWZpZWQgYW5nbGUgZnJvbSBpdHMgcG9zaXRpb24sIGlsbHVtaW5hdGluZyBvYmplY3RzIGRlcGVuZGluZyBvbiB0aGVpciBwb3NpdGlvbiBhbmQgZGlzdGFuY2Ugd2l0aCBpdHMgY29sb3IgIFxyXG4gICAgICogYGBgcGxhaW50ZXh0XHJcbiAgICAgKiAgICAgICAgICBvICBcclxuICAgICAqICAgICAgICAgL3xcXCAgXHJcbiAgICAgKiAgICAgICAgLyB8IFxcIFxyXG4gICAgICogYGBgICAgXHJcbiAgICAgKi9cclxuICAgIGV4cG9ydCBjbGFzcyBMaWdodFNwb3QgZXh0ZW5kcyBMaWdodCB7XHJcbiAgICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgaW50ZXJmYWNlIEJvcmRlciB7XHJcbiAgICBsZWZ0OiBudW1iZXI7XHJcbiAgICB0b3A6IG51bWJlcjtcclxuICAgIHJpZ2h0OiBudW1iZXI7XHJcbiAgICBib3R0b206IG51bWJlcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZyYW1pbmcgZGVzY3JpYmVzIGhvdyB0byBtYXAgYSByZWN0YW5nbGUgaW50byBhIGdpdmVuIGZyYW1lXHJcbiAgICogYW5kIGhvdyBwb2ludHMgaW4gdGhlIGZyYW1lIGNvcnJlc3BvbmQgdG8gcG9pbnRzIGluIHRoZSByZXN1bHRpbmcgcmVjdGFuZ2xlIFxyXG4gICAqL1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBGcmFtaW5nIGV4dGVuZHMgTXV0YWJsZSB7XHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgYSBwb2ludCBpbiB0aGUgZ2l2ZW4gZnJhbWUgYWNjb3JkaW5nIHRvIHRoaXMgZnJhbWluZ1xyXG4gICAgICogQHBhcmFtIF9wb2ludEluRnJhbWUgVGhlIHBvaW50IGluIHRoZSBmcmFtZSBnaXZlblxyXG4gICAgICogQHBhcmFtIF9yZWN0RnJhbWUgVGhlIGZyYW1lIHRoZSBwb2ludCBpcyByZWxhdGl2ZSB0b1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0UG9pbnQoX3BvaW50SW5GcmFtZTogVmVjdG9yMiwgX3JlY3RGcmFtZTogUmVjdGFuZ2xlKTogVmVjdG9yMjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgYSBwb2ludCBpbiBhIGdpdmVuIHJlY3RhbmdsZSBiYWNrIHRvIGEgY2FsY3VsYXRlZCBmcmFtZSBvZiBvcmlnaW5cclxuICAgICAqIEBwYXJhbSBfcG9pbnQgVGhlIHBvaW50IGluIHRoZSByZWN0YW5nbGVcclxuICAgICAqIEBwYXJhbSBfcmVjdCBUaGUgcmVjdGFuZ2xlIHRoZSBwb2ludCBpcyByZWxhdGl2ZSB0b1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0UG9pbnRJbnZlcnNlKF9wb2ludDogVmVjdG9yMiwgX3JlY3Q6IFJlY3RhbmdsZSk6IFZlY3RvcjI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUYWtlcyBhIHJlY3RhbmdsZSBhcyB0aGUgZnJhbWUgYW5kIGNyZWF0ZXMgYSBuZXcgcmVjdGFuZ2xlIGFjY29yZGluZyB0byB0aGUgZnJhbWluZ1xyXG4gICAgICogQHBhcmFtIF9yZWN0RnJhbWVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IGdldFJlY3QoX3JlY3RGcmFtZTogUmVjdGFuZ2xlKTogUmVjdGFuZ2xlO1xyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHsvKiogKi8gfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHJlc3VsdGluZyByZWN0YW5nbGUgaGFzIGEgZml4ZWQgd2lkdGggYW5kIGhlaWdodCBhbmQgZGlzcGxheSBzaG91bGQgc2NhbGUgdG8gZml0IHRoZSBmcmFtZVxyXG4gICAqIFBvaW50cyBhcmUgc2NhbGVkIGluIHRoZSBzYW1lIHJhdGlvXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEZyYW1pbmdGaXhlZCBleHRlbmRzIEZyYW1pbmcge1xyXG4gICAgcHVibGljIHdpZHRoOiBudW1iZXIgPSAzMDA7XHJcbiAgICBwdWJsaWMgaGVpZ2h0OiBudW1iZXIgPSAxNTA7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF93aWR0aDogbnVtYmVyID0gMzAwLCBfaGVpZ2h0OiBudW1iZXIgPSAxNTApIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5zZXRTaXplKF93aWR0aCwgX2hlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldFNpemUoX3dpZHRoOiBudW1iZXIsIF9oZWlnaHQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICB0aGlzLndpZHRoID0gX3dpZHRoO1xyXG4gICAgICB0aGlzLmhlaWdodCA9IF9oZWlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFBvaW50KF9wb2ludEluRnJhbWU6IFZlY3RvcjIsIF9yZWN0RnJhbWU6IFJlY3RhbmdsZSk6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IyID0gbmV3IFZlY3RvcjIoXHJcbiAgICAgICAgdGhpcy53aWR0aCAqIChfcG9pbnRJbkZyYW1lLnggLSBfcmVjdEZyYW1lLngpIC8gX3JlY3RGcmFtZS53aWR0aCxcclxuICAgICAgICB0aGlzLmhlaWdodCAqIChfcG9pbnRJbkZyYW1lLnkgLSBfcmVjdEZyYW1lLnkpIC8gX3JlY3RGcmFtZS5oZWlnaHRcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0UG9pbnRJbnZlcnNlKF9wb2ludDogVmVjdG9yMiwgX3JlY3Q6IFJlY3RhbmdsZSk6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IyID0gbmV3IFZlY3RvcjIoXHJcbiAgICAgICAgX3BvaW50LnggKiBfcmVjdC53aWR0aCAvIHRoaXMud2lkdGggKyBfcmVjdC54LFxyXG4gICAgICAgIF9wb2ludC55ICogX3JlY3QuaGVpZ2h0IC8gdGhpcy5oZWlnaHQgKyBfcmVjdC55XHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFJlY3QoX3JlY3RGcmFtZTogUmVjdGFuZ2xlKTogUmVjdGFuZ2xlIHtcclxuICAgICAgcmV0dXJuIFJlY3RhbmdsZS5HRVQoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKipcclxuICAgKiBXaWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSByZXN1bHRpbmcgcmVjdGFuZ2xlIGFyZSBmcmFjdGlvbnMgb2YgdGhvc2Ugb2YgdGhlIGZyYW1lLCBzY2FsZWQgYnkgbm9ybWVkIHZhbHVlcyBub3JtV2lkdGggYW5kIG5vcm1IZWlnaHQuXHJcbiAgICogRGlzcGxheSBzaG91bGQgc2NhbGUgdG8gZml0IHRoZSBmcmFtZSBhbmQgcG9pbnRzIGFyZSBzY2FsZWQgaW4gdGhlIHNhbWUgcmF0aW9cclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgRnJhbWluZ1NjYWxlZCBleHRlbmRzIEZyYW1pbmcge1xyXG4gICAgcHVibGljIG5vcm1XaWR0aDogbnVtYmVyID0gMS4wO1xyXG4gICAgcHVibGljIG5vcm1IZWlnaHQ6IG51bWJlciA9IDEuMDtcclxuXHJcbiAgICBwdWJsaWMgc2V0U2NhbGUoX25vcm1XaWR0aDogbnVtYmVyLCBfbm9ybUhlaWdodDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIHRoaXMubm9ybVdpZHRoID0gX25vcm1XaWR0aDtcclxuICAgICAgdGhpcy5ub3JtSGVpZ2h0ID0gX25vcm1IZWlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFBvaW50KF9wb2ludEluRnJhbWU6IFZlY3RvcjIsIF9yZWN0RnJhbWU6IFJlY3RhbmdsZSk6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IyID0gbmV3IFZlY3RvcjIoXHJcbiAgICAgICAgdGhpcy5ub3JtV2lkdGggKiAoX3BvaW50SW5GcmFtZS54IC0gX3JlY3RGcmFtZS54KSxcclxuICAgICAgICB0aGlzLm5vcm1IZWlnaHQgKiAoX3BvaW50SW5GcmFtZS55IC0gX3JlY3RGcmFtZS55KVxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRQb2ludEludmVyc2UoX3BvaW50OiBWZWN0b3IyLCBfcmVjdDogUmVjdGFuZ2xlKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjIgPSBuZXcgVmVjdG9yMihcclxuICAgICAgICBfcG9pbnQueCAvIHRoaXMubm9ybVdpZHRoICsgX3JlY3QueCxcclxuICAgICAgICBfcG9pbnQueSAvIHRoaXMubm9ybUhlaWdodCArIF9yZWN0LnlcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0UmVjdChfcmVjdEZyYW1lOiBSZWN0YW5nbGUpOiBSZWN0YW5nbGUge1xyXG4gICAgICByZXR1cm4gUmVjdGFuZ2xlLkdFVCgwLCAwLCB0aGlzLm5vcm1XaWR0aCAqIF9yZWN0RnJhbWUud2lkdGgsIHRoaXMubm9ybUhlaWdodCAqIF9yZWN0RnJhbWUuaGVpZ2h0KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSByZXN1bHRpbmcgcmVjdGFuZ2xlIGZpdHMgaW50byBhIG1hcmdpbiBnaXZlbiBhcyBmcmFjdGlvbnMgb2YgdGhlIHNpemUgb2YgdGhlIGZyYW1lIGdpdmVuIGJ5IG5vcm1BbmNob3JcclxuICAgKiBwbHVzIGFuIGFic29sdXRlIHBhZGRpbmcgZ2l2ZW4gYnkgcGl4ZWxCb3JkZXIuIERpc3BsYXkgc2hvdWxkIGZpdCBpbnRvIHRoaXMuXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEZyYW1pbmdDb21wbGV4IGV4dGVuZHMgRnJhbWluZyB7XHJcbiAgICBwdWJsaWMgbWFyZ2luOiBCb3JkZXIgPSB7IGxlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCB9O1xyXG4gICAgcHVibGljIHBhZGRpbmc6IEJvcmRlciA9IHsgbGVmdDogMCwgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwIH07XHJcblxyXG4gICAgcHVibGljIGdldFBvaW50KF9wb2ludEluRnJhbWU6IFZlY3RvcjIsIF9yZWN0RnJhbWU6IFJlY3RhbmdsZSk6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IyID0gbmV3IFZlY3RvcjIoXHJcbiAgICAgICAgX3BvaW50SW5GcmFtZS54IC0gdGhpcy5wYWRkaW5nLmxlZnQgLSB0aGlzLm1hcmdpbi5sZWZ0ICogX3JlY3RGcmFtZS53aWR0aCxcclxuICAgICAgICBfcG9pbnRJbkZyYW1lLnkgLSB0aGlzLnBhZGRpbmcudG9wIC0gdGhpcy5tYXJnaW4udG9wICogX3JlY3RGcmFtZS5oZWlnaHRcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHB1YmxpYyBnZXRQb2ludEludmVyc2UoX3BvaW50OiBWZWN0b3IyLCBfcmVjdDogUmVjdGFuZ2xlKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjIgPSBuZXcgVmVjdG9yMihcclxuICAgICAgICBfcG9pbnQueCArIHRoaXMucGFkZGluZy5sZWZ0ICsgdGhpcy5tYXJnaW4ubGVmdCAqIF9yZWN0LndpZHRoLFxyXG4gICAgICAgIF9wb2ludC55ICsgdGhpcy5wYWRkaW5nLnRvcCArIHRoaXMubWFyZ2luLnRvcCAqIF9yZWN0LmhlaWdodFxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRSZWN0KF9yZWN0RnJhbWU6IFJlY3RhbmdsZSk6IFJlY3RhbmdsZSB7XHJcbiAgICAgIGlmICghX3JlY3RGcmFtZSlcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgIGxldCBtaW5YOiBudW1iZXIgPSBfcmVjdEZyYW1lLnggKyB0aGlzLm1hcmdpbi5sZWZ0ICogX3JlY3RGcmFtZS53aWR0aCArIHRoaXMucGFkZGluZy5sZWZ0O1xyXG4gICAgICBsZXQgbWluWTogbnVtYmVyID0gX3JlY3RGcmFtZS55ICsgdGhpcy5tYXJnaW4udG9wICogX3JlY3RGcmFtZS5oZWlnaHQgKyB0aGlzLnBhZGRpbmcudG9wO1xyXG4gICAgICBsZXQgbWF4WDogbnVtYmVyID0gX3JlY3RGcmFtZS54ICsgKDEgLSB0aGlzLm1hcmdpbi5yaWdodCkgKiBfcmVjdEZyYW1lLndpZHRoIC0gdGhpcy5wYWRkaW5nLnJpZ2h0O1xyXG4gICAgICBsZXQgbWF4WTogbnVtYmVyID0gX3JlY3RGcmFtZS55ICsgKDEgLSB0aGlzLm1hcmdpbi5ib3R0b20pICogX3JlY3RGcmFtZS5oZWlnaHQgLSB0aGlzLnBhZGRpbmcuYm90dG9tO1xyXG5cclxuICAgICAgcmV0dXJuIFJlY3RhbmdsZS5HRVQobWluWCwgbWluWSwgbWF4WCAtIG1pblgsIG1heFkgLSBtaW5ZKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcclxuICAgICAgcmV0dXJuIHsgbWFyZ2luOiB0aGlzLm1hcmdpbiwgcGFkZGluZzogdGhpcy5wYWRkaW5nIH07XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlcHJlc2VudHMgdGhlIG1hdHJpeCBhcyB0cmFuc2xhdGlvbiwgcm90YXRpb24gYW5kIHNjYWxpbmcgdmVjdG9yLCBiZWluZyBjYWxjdWxhdGVkIGZyb20gdGhlIG1hdHJpeFxyXG4gICAqL1xyXG4gIGludGVyZmFjZSBWZWN0b3JSZXByZXNlbnRhdGlvbiB7XHJcbiAgICB0cmFuc2xhdGlvbjogVmVjdG9yMjtcclxuICAgIHJvdGF0aW9uOiBudW1iZXI7XHJcbiAgICBzY2FsaW5nOiBWZWN0b3IyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2ltcGxlIGNsYXNzIGZvciAzeDMgbWF0cml4IG9wZXJhdGlvbnNcclxuICAgKiBAYXV0aG9ycyBKYXNjaGEgS2FyYWfDtmwsIEhGVSwgMjAxOSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIwXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE1hdHJpeDN4MyBleHRlbmRzIE11dGFibGUgaW1wbGVtZW50cyBTZXJpYWxpemFibGUge1xyXG4gICAgcHJpdmF0ZSBkYXRhOiBGbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDMpOyAvLyBUaGUgZGF0YSBvZiB0aGUgbWF0cml4LlxyXG4gICAgcHJpdmF0ZSBtdXRhdG9yOiBNdXRhdG9yID0gbnVsbDsgLy8gcHJlcGFyZWQgZm9yIG9wdGltaXphdGlvbiwga2VlcCBtdXRhdG9yIHRvIHJlZHVjZSByZWR1bmRhbnQgY2FsY3VsYXRpb24gYW5kIGZvciBjb21wYXJpc29uLiBTZXQgdG8gbnVsbCB3aGVuIGRhdGEgY2hhbmdlcyFcclxuICAgIHByaXZhdGUgdmVjdG9yczogVmVjdG9yUmVwcmVzZW50YXRpb247IC8vIHZlY3RvciByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG1hdHJpeFxyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAgICAgMSwgMCwgMCxcclxuICAgICAgICAwLCAxLCAwLFxyXG4gICAgICAgIDAsIDAsIDFcclxuICAgICAgXSk7XHJcbiAgICAgIHRoaXMucmVzZXRDYWNoZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBcclxuICAgICAqIC0gZ2V0OiBhIGNvcHkgb2YgdGhlIGNhbGN1bGF0ZWQgdHJhbnNsYXRpb24gdmVjdG9yICAgXHJcbiAgICAgKiAtIHNldDogZWZmZWN0IHRoZSBtYXRyaXggaWdub3JpbmcgaXRzIHJvdGF0aW9uIGFuZCBzY2FsaW5nXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgdHJhbnNsYXRpb24oKTogVmVjdG9yMiB7XHJcbiAgICAgIGlmICghdGhpcy52ZWN0b3JzLnRyYW5zbGF0aW9uKVxyXG4gICAgICAgIHRoaXMudmVjdG9ycy50cmFuc2xhdGlvbiA9IG5ldyBWZWN0b3IyKHRoaXMuZGF0YVs2XSwgdGhpcy5kYXRhWzddKTtcclxuICAgICAgcmV0dXJuIHRoaXMudmVjdG9ycy50cmFuc2xhdGlvbi5jb3B5O1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCB0cmFuc2xhdGlvbihfdHJhbnNsYXRpb246IFZlY3RvcjIpIHtcclxuICAgICAgdGhpcy5kYXRhLnNldChfdHJhbnNsYXRpb24uZ2V0KCksIDEyKTtcclxuICAgICAgLy8gbm8gZnVsbCBjYWNoZSByZXNldCByZXF1aXJlZFxyXG4gICAgICB0aGlzLnZlY3RvcnMudHJhbnNsYXRpb24gPSBfdHJhbnNsYXRpb247XHJcbiAgICAgIHRoaXMubXV0YXRvciA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogLSBnZXQ6IGEgY29weSBvZiB0aGUgY2FsY3VsYXRlZCByb3RhdGlvbiB2ZWN0b3IgICBcclxuICAgICAqIC0gc2V0OiBlZmZlY3QgdGhlIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHJvdGF0aW9uKCk6IG51bWJlciB7XHJcbiAgICAgIGlmICghdGhpcy52ZWN0b3JzLnJvdGF0aW9uKVxyXG4gICAgICAgIHRoaXMudmVjdG9ycy5yb3RhdGlvbiA9IHRoaXMuZ2V0RXVsZXJBbmdsZXMoKTtcclxuICAgICAgcmV0dXJuIHRoaXMudmVjdG9ycy5yb3RhdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgcm90YXRpb24oX3JvdGF0aW9uOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5tdXRhdGUoeyBcInJvdGF0aW9uXCI6IF9yb3RhdGlvbiB9KTtcclxuICAgICAgdGhpcy5yZXNldENhY2hlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogLSBnZXQ6IGEgY29weSBvZiB0aGUgY2FsY3VsYXRlZCBzY2FsZSB2ZWN0b3IgICBcclxuICAgICAqIC0gc2V0OiBlZmZlY3QgdGhlIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHNjYWxpbmcoKTogVmVjdG9yMiB7XHJcbiAgICAgIGlmICghdGhpcy52ZWN0b3JzLnNjYWxpbmcpXHJcbiAgICAgICAgdGhpcy52ZWN0b3JzLnNjYWxpbmcgPSBuZXcgVmVjdG9yMihcclxuICAgICAgICAgIE1hdGguaHlwb3QodGhpcy5kYXRhWzBdLCB0aGlzLmRhdGFbMV0pLFxyXG4gICAgICAgICAgTWF0aC5oeXBvdCh0aGlzLmRhdGFbM10sIHRoaXMuZGF0YVs0XSlcclxuICAgICAgICApO1xyXG4gICAgICByZXR1cm4gdGhpcy52ZWN0b3JzLnNjYWxpbmcuY29weTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgc2NhbGluZyhfc2NhbGluZzogVmVjdG9yMikge1xyXG4gICAgICB0aGlzLm11dGF0ZSh7IFwic2NhbGluZ1wiOiBfc2NhbGluZyB9KTtcclxuICAgICAgdGhpcy5yZXNldENhY2hlKCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vVE9ETzogZmlndXJlIG91dCB3aGF0IHRoaXMgaXMgdXNlZCBmb3JcclxuICAgIHB1YmxpYyBzdGF0aWMgUFJPSkVDVElPTihfd2lkdGg6IG51bWJlciwgX2hlaWdodDogbnVtYmVyKTogTWF0cml4M3gzIHtcclxuICAgICAgbGV0IG1hdHJpeDogTWF0cml4M3gzID0gbmV3IE1hdHJpeDN4MztcclxuICAgICAgbWF0cml4LmRhdGEuc2V0KFtcclxuICAgICAgICAyIC8gX3dpZHRoLCAwLCAwLFxyXG4gICAgICAgIDAsIC0yIC8gX2hlaWdodCwgMCxcclxuICAgICAgICAtMSwgMSwgMVxyXG4gICAgICBdKTtcclxuICAgICAgcmV0dXJuIG1hdHJpeDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIElERU5USVRZKCk6IE1hdHJpeDN4MyB7XHJcbiAgICAgIGNvbnN0IHJlc3VsdDogTWF0cml4M3gzID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDN4Myk7XHJcbiAgICAgIHJlc3VsdC5kYXRhLnNldChbXHJcbiAgICAgICAgMSwgMCwgMCxcclxuICAgICAgICAwLCAxLCAwLFxyXG4gICAgICAgIDAsIDAsIDFcclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbWF0cml4IHRoYXQgdHJhbnNsYXRlcyBjb29yZGluYXRlcyBhbG9uZyB0aGUgeC0sIHktIGFuZCB6LWF4aXMgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgVFJBTlNMQVRJT04oX3RyYW5zbGF0ZTogVmVjdG9yMik6IE1hdHJpeDN4MyB7XHJcbiAgICAgIGNvbnN0IG1hdHJpeDogTWF0cml4M3gzID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDN4Myk7XHJcbiAgICAgIG1hdHJpeC5kYXRhLnNldChbXHJcbiAgICAgICAgMSwgMCwgMCxcclxuICAgICAgICAwLCAxLCAwLFxyXG4gICAgICAgIF90cmFuc2xhdGUueCwgX3RyYW5zbGF0ZS55LCAxXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gbWF0cml4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG1hdHJpeCB0aGF0IHJvdGF0ZXMgY29vcmRpbmF0ZXMgb24gdGhlIHotYXhpcyB3aGVuIG11bHRpcGxpZWQgYnkuXHJcbiAgICAgKiBAcGFyYW0gX2FuZ2xlSW5EZWdyZWVzIFRoZSB2YWx1ZSBvZiB0aGUgcm90YXRpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgUk9UQVRJT04oX2FuZ2xlSW5EZWdyZWVzOiBudW1iZXIpOiBNYXRyaXgzeDMge1xyXG4gICAgICAvLyBjb25zdCBtYXRyaXg6IE1hdHJpeDN4MyA9IG5ldyBNYXRyaXgzeDM7XHJcbiAgICAgIGNvbnN0IG1hdHJpeDogTWF0cml4M3gzID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDN4Myk7XHJcbiAgICAgIGxldCBhbmdsZUluUmFkaWFuczogbnVtYmVyID0gX2FuZ2xlSW5EZWdyZWVzICogTWF0aC5QSSAvIDE4MDtcclxuICAgICAgbGV0IHNpbjogbnVtYmVyID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xyXG4gICAgICBsZXQgY29zOiBudW1iZXIgPSBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyk7XHJcbiAgICAgIG1hdHJpeC5kYXRhLnNldChbXHJcbiAgICAgICAgY29zLCBzaW4sIDAsXHJcbiAgICAgICAgLXNpbiwgY29zLCAwLFxyXG4gICAgICAgIDAsIDAsIDFcclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiBtYXRyaXg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbWF0cml4IHRoYXQgc2NhbGVzIGNvb3JkaW5hdGVzIGFsb25nIHRoZSB4LSwgeS0gYW5kIHotYXhpcyBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFNDQUxJTkcoX3NjYWxhcjogVmVjdG9yMik6IE1hdHJpeDN4MyB7XHJcbiAgICAgIC8vIGNvbnN0IG1hdHJpeDogTWF0cml4M3gzID0gbmV3IE1hdHJpeDN4MztcclxuICAgICAgY29uc3QgbWF0cml4OiBNYXRyaXgzeDMgPSBSZWN5Y2xlci5nZXQoTWF0cml4M3gzKTtcclxuICAgICAgbWF0cml4LmRhdGEuc2V0KFtcclxuICAgICAgICBfc2NhbGFyLngsIDAsIDAsXHJcbiAgICAgICAgMCwgX3NjYWxhci55LCAwLFxyXG4gICAgICAgIDAsIDAsIDFcclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiBtYXRyaXg7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBNVUxUSVBMSUNBVElPTihfYTogTWF0cml4M3gzLCBfYjogTWF0cml4M3gzKTogTWF0cml4M3gzIHtcclxuICAgICAgbGV0IGEwMDogbnVtYmVyID0gX2EuZGF0YVswICogMyArIDBdO1xyXG4gICAgICBsZXQgYTAxOiBudW1iZXIgPSBfYS5kYXRhWzAgKiAzICsgMV07XHJcbiAgICAgIGxldCBhMDI6IG51bWJlciA9IF9hLmRhdGFbMCAqIDMgKyAyXTtcclxuICAgICAgbGV0IGExMDogbnVtYmVyID0gX2EuZGF0YVsxICogMyArIDBdO1xyXG4gICAgICBsZXQgYTExOiBudW1iZXIgPSBfYS5kYXRhWzEgKiAzICsgMV07XHJcbiAgICAgIGxldCBhMTI6IG51bWJlciA9IF9hLmRhdGFbMSAqIDMgKyAyXTtcclxuICAgICAgbGV0IGEyMDogbnVtYmVyID0gX2EuZGF0YVsyICogMyArIDBdO1xyXG4gICAgICBsZXQgYTIxOiBudW1iZXIgPSBfYS5kYXRhWzIgKiAzICsgMV07XHJcbiAgICAgIGxldCBhMjI6IG51bWJlciA9IF9hLmRhdGFbMiAqIDMgKyAyXTtcclxuICAgICAgbGV0IGIwMDogbnVtYmVyID0gX2IuZGF0YVswICogMyArIDBdO1xyXG4gICAgICBsZXQgYjAxOiBudW1iZXIgPSBfYi5kYXRhWzAgKiAzICsgMV07XHJcbiAgICAgIGxldCBiMDI6IG51bWJlciA9IF9iLmRhdGFbMCAqIDMgKyAyXTtcclxuICAgICAgbGV0IGIxMDogbnVtYmVyID0gX2IuZGF0YVsxICogMyArIDBdO1xyXG4gICAgICBsZXQgYjExOiBudW1iZXIgPSBfYi5kYXRhWzEgKiAzICsgMV07XHJcbiAgICAgIGxldCBiMTI6IG51bWJlciA9IF9iLmRhdGFbMSAqIDMgKyAyXTtcclxuICAgICAgbGV0IGIyMDogbnVtYmVyID0gX2IuZGF0YVsyICogMyArIDBdO1xyXG4gICAgICBsZXQgYjIxOiBudW1iZXIgPSBfYi5kYXRhWzIgKiAzICsgMV07XHJcbiAgICAgIGxldCBiMjI6IG51bWJlciA9IF9iLmRhdGFbMiAqIDMgKyAyXTtcclxuICAgICAgbGV0IG1hdHJpeDogTWF0cml4M3gzID0gbmV3IE1hdHJpeDN4MztcclxuICAgICAgbWF0cml4LmRhdGEuc2V0KFtcclxuICAgICAgICBiMDAgKiBhMDAgKyBiMDEgKiBhMTAgKyBiMDIgKiBhMjAsXHJcbiAgICAgICAgYjAwICogYTAxICsgYjAxICogYTExICsgYjAyICogYTIxLFxyXG4gICAgICAgIGIwMCAqIGEwMiArIGIwMSAqIGExMiArIGIwMiAqIGEyMixcclxuICAgICAgICBiMTAgKiBhMDAgKyBiMTEgKiBhMTAgKyBiMTIgKiBhMjAsXHJcbiAgICAgICAgYjEwICogYTAxICsgYjExICogYTExICsgYjEyICogYTIxLFxyXG4gICAgICAgIGIxMCAqIGEwMiArIGIxMSAqIGExMiArIGIxMiAqIGEyMixcclxuICAgICAgICBiMjAgKiBhMDAgKyBiMjEgKiBhMTAgKyBiMjIgKiBhMjAsXHJcbiAgICAgICAgYjIwICogYTAxICsgYjIxICogYTExICsgYjIyICogYTIxLFxyXG4gICAgICAgIGIyMCAqIGEwMiArIGIyMSAqIGExMiArIGIyMiAqIGEyMlxyXG4gICAgICBdKTtcclxuICAgICAgcmV0dXJuIG1hdHJpeDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zbGF0aW9uXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIHRyYW5zbGF0aW9uIGJ5IHRoZSBnaXZlbiB2ZWN0b3IgdG8gdGhpcyBtYXRyaXggXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0cmFuc2xhdGUoX2J5OiBWZWN0b3IyKTogdm9pZCB7XHJcbiAgICAgIGNvbnN0IG1hdHJpeDogTWF0cml4M3gzID0gTWF0cml4M3gzLk1VTFRJUExJQ0FUSU9OKHRoaXMsIE1hdHJpeDN4My5UUkFOU0xBVElPTihfYnkpKTtcclxuICAgICAgLy8gVE9ETzogcG9zc2libGUgb3B0aW1pemF0aW9uLCB0cmFuc2xhdGlvbiBtYXkgYWx0ZXIgbXV0YXRvciBpbnN0ZWFkIG9mIGRlbGV0aW5nIGl0LlxyXG4gICAgICB0aGlzLnNldChtYXRyaXgpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShtYXRyaXgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgdHJhbnNsYXRpb24gYWxvbmcgdGhlIHgtQXhpcyBieSB0aGUgZ2l2ZW4gYW1vdW50IHRvIHRoaXMgbWF0cml4IFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdHJhbnNsYXRlWChfeDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuZGF0YVs2XSArPSBfeDtcclxuICAgICAgdGhpcy5tdXRhdG9yID0gbnVsbDtcclxuICAgICAgdGhpcy52ZWN0b3JzLnRyYW5zbGF0aW9uID0gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgdHJhbnNsYXRpb24gYWxvbmcgdGhlIHktQXhpcyBieSB0aGUgZ2l2ZW4gYW1vdW50IHRvIHRoaXMgbWF0cml4IFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdHJhbnNsYXRlWShfeTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuZGF0YVs3XSArPSBfeTtcclxuICAgICAgdGhpcy5tdXRhdG9yID0gbnVsbDtcclxuICAgICAgdGhpcy52ZWN0b3JzLnRyYW5zbGF0aW9uID0gbnVsbDtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBTY2FsaW5nXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIHNjYWxpbmcgYnkgdGhlIGdpdmVuIHZlY3RvciB0byB0aGlzIG1hdHJpeCBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNjYWxlKF9ieTogVmVjdG9yMik6IHZvaWQge1xyXG4gICAgICBjb25zdCBtYXRyaXg6IE1hdHJpeDN4MyA9IE1hdHJpeDN4My5NVUxUSVBMSUNBVElPTih0aGlzLCBNYXRyaXgzeDMuU0NBTElORyhfYnkpKTtcclxuICAgICAgdGhpcy5zZXQobWF0cml4KTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUobWF0cml4KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgc2NhbGluZyBhbG9uZyB0aGUgeC1BeGlzIGJ5IHRoZSBnaXZlbiBhbW91bnQgdG8gdGhpcyBtYXRyaXggXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzY2FsZVgoX2J5OiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy5zY2FsZShuZXcgVmVjdG9yMihfYnksIDEpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgc2NhbGluZyBhbG9uZyB0aGUgeS1BeGlzIGJ5IHRoZSBnaXZlbiBhbW91bnQgdG8gdGhpcyBtYXRyaXggXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzY2FsZVkoX2J5OiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy5zY2FsZShuZXcgVmVjdG9yMigxLCBfYnkpKTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuXHJcbiAgICAvLyNyZWdpb24gUm90YXRpb25cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHJvdGF0aW9uIGFyb3VuZCB0aGUgei1BeGlzIHRvIHRoaXMgbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByb3RhdGUoX2FuZ2xlSW5EZWdyZWVzOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgY29uc3QgbWF0cml4OiBNYXRyaXgzeDMgPSBNYXRyaXgzeDMuTVVMVElQTElDQVRJT04odGhpcywgTWF0cml4M3gzLlJPVEFUSU9OKF9hbmdsZUluRGVncmVlcykpO1xyXG4gICAgICB0aGlzLnNldChtYXRyaXgpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShtYXRyaXgpO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZm9ybWF0aW9uXHJcbiAgICAvKipcclxuICAgICAqIE11bHRpcGx5IHRoaXMgbWF0cml4IHdpdGggdGhlIGdpdmVuIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbXVsdGlwbHkoX21hdHJpeDogTWF0cml4M3gzKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuc2V0KE1hdHJpeDN4My5NVUxUSVBMSUNBVElPTih0aGlzLCBfbWF0cml4KSk7XHJcbiAgICAgIHRoaXMubXV0YXRvciA9IG51bGw7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgYW5kIHJldHVybnMgdGhlIGV1bGVyLWFuZ2xlcyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgcm90YXRpb24gb2YgdGhpcyBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEV1bGVyQW5nbGVzKCk6IG51bWJlciB7XHJcbiAgICAgIGxldCBzY2FsaW5nOiBWZWN0b3IyID0gdGhpcy5zY2FsaW5nO1xyXG5cclxuICAgICAgbGV0IHMwOiBudW1iZXIgPSB0aGlzLmRhdGFbMF0gLyBzY2FsaW5nLng7XHJcbiAgICAgIGxldCBzMTogbnVtYmVyID0gdGhpcy5kYXRhWzFdIC8gc2NhbGluZy54O1xyXG4gICAgICBsZXQgczM6IG51bWJlciA9IHRoaXMuZGF0YVszXSAvIHNjYWxpbmcueTtcclxuICAgICAgbGV0IHM0OiBudW1iZXIgPSB0aGlzLmRhdGFbNF0gLyBzY2FsaW5nLnk7XHJcblxyXG4gICAgICBsZXQgeFNrZXc6IG51bWJlciA9IE1hdGguYXRhbjIoLXMzLCBzNCk7XHJcbiAgICAgIGxldCB5U2tldzogbnVtYmVyID0gTWF0aC5hdGFuMihzMCwgczEpO1xyXG5cclxuICAgICAgbGV0IHN5OiBudW1iZXIgPSBNYXRoLmh5cG90KHMwLCBzMSk7IC8vIHByb2JhYmx5IDIuIHBhcmFtIHNob3VsZCBiZSB0aGlzLmRhdGFbNF0gLyBzY2FsaW5nLnlcclxuICAgICAgbGV0IHJvdGF0aW9uOiBudW1iZXI7XHJcblxyXG4gICAgICBpZiAoIShzeSA+IDFlLTYpKVxyXG4gICAgICAgIHJvdGF0aW9uID0geVNrZXc7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICByb3RhdGlvbiA9IHhTa2V3O1xyXG5cclxuICAgICAgcm90YXRpb24gKj0gMTgwIC8gTWF0aC5QSTtcclxuXHJcbiAgICAgIHJldHVybiByb3RhdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGVsZW1lbnRzIG9mIHRoaXMgbWF0cml4IHRvIHRoZSB2YWx1ZXMgb2YgdGhlIGdpdmVuIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0KF90bzogTWF0cml4M3gzKTogdm9pZCB7XHJcbiAgICAgIC8vIHRoaXMuZGF0YSA9IF90by5nZXQoKTtcclxuICAgICAgdGhpcy5kYXRhLnNldChfdG8uZGF0YSk7XHJcbiAgICAgIHRoaXMucmVzZXRDYWNoZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gYMaSLk1hdHJpeDN4Myh0cmFuc2xhdGlvbjogJHt0aGlzLnRyYW5zbGF0aW9uLnRvU3RyaW5nKCl9LCByb3RhdGlvbjogJHt0aGlzLnJvdGF0aW9uLnRvU3RyaW5nKCl9LCBzY2FsaW5nOiAke3RoaXMuc2NhbGluZy50b1N0cmluZygpfWA7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgZWxlbWVudHMgb2YgdGhpcyBtYXRyaXggYXMgYSBGbG9hdDMyQXJyYXlcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCgpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIC8vIFRPRE86IHNhdmUgdHJhbnNsYXRpb24sIHJvdGF0aW9uIGFuZCBzY2FsZSBhcyB2ZWN0b3JzIGZvciByZWFkYWJpbGl0eSBhbmQgbWFuaXB1bGF0aW9uXHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gdGhpcy5nZXRNdXRhdG9yKCk7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogU2VyaWFsaXphYmxlIHtcclxuICAgICAgdGhpcy5tdXRhdGUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcclxuICAgICAgaWYgKHRoaXMubXV0YXRvcilcclxuICAgICAgICByZXR1cm4gdGhpcy5tdXRhdG9yO1xyXG5cclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSB7XHJcbiAgICAgICAgdHJhbnNsYXRpb246IHRoaXMudHJhbnNsYXRpb24uZ2V0TXV0YXRvcigpLFxyXG4gICAgICAgIHJvdGF0aW9uOiB0aGlzLnJvdGF0aW9uLFxyXG4gICAgICAgIHNjYWxpbmc6IHRoaXMuc2NhbGluZy5nZXRNdXRhdG9yKClcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIGNhY2hlIG11dGF0b3JcclxuICAgICAgdGhpcy5tdXRhdG9yID0gbXV0YXRvcjtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICBsZXQgb2xkVHJhbnNsYXRpb246IFZlY3RvcjIgPSB0aGlzLnRyYW5zbGF0aW9uO1xyXG4gICAgICBsZXQgb2xkUm90YXRpb246IG51bWJlciA9IHRoaXMucm90YXRpb247XHJcbiAgICAgIGxldCBvbGRTY2FsaW5nOiBWZWN0b3IyID0gdGhpcy5zY2FsaW5nO1xyXG4gICAgICBsZXQgbmV3VHJhbnNsYXRpb246IFZlY3RvcjIgPSA8VmVjdG9yMj5fbXV0YXRvcltcInRyYW5zbGF0aW9uXCJdO1xyXG4gICAgICBsZXQgbmV3Um90YXRpb246IG51bWJlciA9IDxudW1iZXI+X211dGF0b3JbXCJyb3RhdGlvblwiXTtcclxuICAgICAgbGV0IG5ld1NjYWxpbmc6IFZlY3RvcjIgPSA8VmVjdG9yMj5fbXV0YXRvcltcInNjYWxpbmdcIl07XHJcbiAgICAgIGxldCB2ZWN0b3JzOiBWZWN0b3JSZXByZXNlbnRhdGlvbiA9IHsgdHJhbnNsYXRpb246IG9sZFRyYW5zbGF0aW9uLCByb3RhdGlvbjogb2xkUm90YXRpb24sIHNjYWxpbmc6IG9sZFNjYWxpbmcgfTtcclxuICAgICAgaWYgKG5ld1RyYW5zbGF0aW9uKSB7XHJcbiAgICAgICAgdmVjdG9ycy50cmFuc2xhdGlvbiA9IG5ldyBWZWN0b3IyKFxyXG4gICAgICAgICAgbmV3VHJhbnNsYXRpb24ueCAhPSB1bmRlZmluZWQgPyBuZXdUcmFuc2xhdGlvbi54IDogb2xkVHJhbnNsYXRpb24ueCxcclxuICAgICAgICAgIG5ld1RyYW5zbGF0aW9uLnkgIT0gdW5kZWZpbmVkID8gbmV3VHJhbnNsYXRpb24ueSA6IG9sZFRyYW5zbGF0aW9uLnlcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2ZWN0b3JzLnJvdGF0aW9uID0gKG5ld1JvdGF0aW9uID09IHVuZGVmaW5lZCkgPyBvbGRSb3RhdGlvbiA6IG5ld1JvdGF0aW9uO1xyXG5cclxuICAgICAgaWYgKG5ld1NjYWxpbmcpIHtcclxuICAgICAgICB2ZWN0b3JzLnNjYWxpbmcgPSBuZXcgVmVjdG9yMihcclxuICAgICAgICAgIG5ld1NjYWxpbmcueCAhPSB1bmRlZmluZWQgPyBuZXdTY2FsaW5nLnggOiBvbGRTY2FsaW5nLngsXHJcbiAgICAgICAgICBuZXdTY2FsaW5nLnkgIT0gdW5kZWZpbmVkID8gbmV3U2NhbGluZy55IDogb2xkU2NhbGluZy55XHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVE9ETzogcG9zc2libGUgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIHdoZW4gb25seSBvbmUgb3IgdHdvIGNvbXBvbmVudHMgY2hhbmdlLCB0aGVuIHVzZSBvbGQgbWF0cml4IGluc3RlYWQgb2YgSURFTlRJVFkgYW5kIHRyYW5zZm9ybSBieSBkaWZmZXJlbmNlcy9xdW90aWVudHNcclxuICAgICAgbGV0IG1hdHJpeDogTWF0cml4M3gzID0gTWF0cml4M3gzLklERU5USVRZKCk7XHJcbiAgICAgIGlmICh2ZWN0b3JzLnRyYW5zbGF0aW9uKVxyXG4gICAgICAgIG1hdHJpeC50cmFuc2xhdGUodmVjdG9ycy50cmFuc2xhdGlvbik7XHJcbiAgICAgIGlmICh2ZWN0b3JzLnJvdGF0aW9uKSB7XHJcbiAgICAgICAgbWF0cml4LnJvdGF0ZSh2ZWN0b3JzLnJvdGF0aW9uKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodmVjdG9ycy5zY2FsaW5nKVxyXG4gICAgICAgIG1hdHJpeC5zY2FsZSh2ZWN0b3JzLnNjYWxpbmcpO1xyXG4gICAgICB0aGlzLnNldChtYXRyaXgpO1xyXG5cclxuICAgICAgdGhpcy52ZWN0b3JzID0gdmVjdG9ycztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvckF0dHJpYnV0ZVR5cGVzKF9tdXRhdG9yOiBNdXRhdG9yKTogTXV0YXRvckF0dHJpYnV0ZVR5cGVzIHtcclxuICAgICAgbGV0IHR5cGVzOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMgPSB7fTtcclxuICAgICAgaWYgKF9tdXRhdG9yLnRyYW5zbGF0aW9uKSB0eXBlcy50cmFuc2xhdGlvbiA9IFwiVmVjdG9yMlwiO1xyXG4gICAgICBpZiAoX211dGF0b3Iucm90YXRpb24pIHR5cGVzLnJvdGF0aW9uID0gXCJudW1iZXJcIjtcclxuICAgICAgaWYgKF9tdXRhdG9yLnNjYWxpbmcpIHR5cGVzLnNjYWxpbmcgPSBcIlZlY3RvcjJcIjtcclxuICAgICAgcmV0dXJuIHR5cGVzO1xyXG4gICAgfVxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHsvKiogKi8gfVxyXG5cclxuICAgIHByaXZhdGUgcmVzZXRDYWNoZSgpOiB2b2lkIHtcclxuICAgICAgdGhpcy52ZWN0b3JzID0geyB0cmFuc2xhdGlvbjogbnVsbCwgcm90YXRpb246IG51bGwsIHNjYWxpbmc6IG51bGwgfTtcclxuICAgICAgdGhpcy5tdXRhdG9yID0gbnVsbDtcclxuICAgIH1cclxuICB9XHJcbiAgLy8jZW5kcmVnaW9uXHJcblxyXG59XHJcbiIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG5cclxuICAvKipcclxuICAgKiBSZXByZXNlbnRzIHRoZSBtYXRyaXggYXMgdHJhbnNsYXRpb24sIHJvdGF0aW9uIGFuZCBzY2FsaW5nIHZlY3RvciwgYmVpbmcgY2FsY3VsYXRlZCBmcm9tIHRoZSBtYXRyaXhcclxuICAgKi9cclxuICBpbnRlcmZhY2UgVmVjdG9yUmVwcmVzZW50YXRpb24ge1xyXG4gICAgdHJhbnNsYXRpb246IFZlY3RvcjM7XHJcbiAgICByb3RhdGlvbjogVmVjdG9yMztcclxuICAgIHNjYWxpbmc6IFZlY3RvcjM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdG9yZXMgYSA0eDQgdHJhbnNmb3JtYXRpb24gbWF0cml4IGFuZCBwcm92aWRlcyBvcGVyYXRpb25zIGZvciBpdC5cclxuICAgKiBgYGBwbGFpbnRleHRcclxuICAgKiBbIDAsIDEsIDIsIDMgXSDihpAgcm93IHZlY3RvciB4XHJcbiAgICogWyA0LCA1LCA2LCA3IF0g4oaQIHJvdyB2ZWN0b3IgeVxyXG4gICAqIFsgOCwgOSwxMCwxMSBdIOKGkCByb3cgdmVjdG9yIHpcclxuICAgKiBbMTIsMTMsMTQsMTUgXSDihpAgdHJhbnNsYXRpb25cclxuICAgKiAgICAgICAgICAgIOKGkSAgaG9tb2dlbmVvdXMgY29sdW1uXHJcbiAgICogYGBgXHJcbiAgICogQGF1dGhvcnMgSmFzY2hhIEthcmFnw7ZsLCBIRlUsIDIwMTkgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG5cclxuICBleHBvcnQgY2xhc3MgTWF0cml4NHg0IGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZSB7XHJcbiAgICBwcml2YXRlIGRhdGE6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpOyAvLyBUaGUgZGF0YSBvZiB0aGUgbWF0cml4LlxyXG4gICAgcHJpdmF0ZSBtdXRhdG9yOiBNdXRhdG9yID0gbnVsbDsgLy8gcHJlcGFyZWQgZm9yIG9wdGltaXphdGlvbiwga2VlcCBtdXRhdG9yIHRvIHJlZHVjZSByZWR1bmRhbnQgY2FsY3VsYXRpb24gYW5kIGZvciBjb21wYXJpc29uLiBTZXQgdG8gbnVsbCB3aGVuIGRhdGEgY2hhbmdlcyFcclxuICAgIHByaXZhdGUgdmVjdG9yczogVmVjdG9yUmVwcmVzZW50YXRpb247IC8vIHZlY3RvciByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG1hdHJpeFxyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5kYXRhLnNldChbXHJcbiAgICAgICAgMSwgMCwgMCwgMCxcclxuICAgICAgICAwLCAxLCAwLCAwLFxyXG4gICAgICAgIDAsIDAsIDEsIDAsXHJcbiAgICAgICAgMCwgMCwgMCwgMVxyXG4gICAgICBdKTtcclxuICAgICAgdGhpcy5yZXNldENhY2hlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogLSBnZXQ6IGEgY29weSBvZiB0aGUgY2FsY3VsYXRlZCB0cmFuc2xhdGlvbiB2ZWN0b3IgICBcclxuICAgICAqIC0gc2V0OiBlZmZlY3QgdGhlIG1hdHJpeCBpZ25vcmluZyBpdHMgcm90YXRpb24gYW5kIHNjYWxpbmdcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCB0cmFuc2xhdGlvbigpOiBWZWN0b3IzIHtcclxuICAgICAgaWYgKCF0aGlzLnZlY3RvcnMudHJhbnNsYXRpb24pXHJcbiAgICAgICAgdGhpcy52ZWN0b3JzLnRyYW5zbGF0aW9uID0gbmV3IFZlY3RvcjModGhpcy5kYXRhWzEyXSwgdGhpcy5kYXRhWzEzXSwgdGhpcy5kYXRhWzE0XSk7XHJcbiAgICAgIHJldHVybiB0aGlzLnZlY3RvcnMudHJhbnNsYXRpb24uY29weTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgdHJhbnNsYXRpb24oX3RyYW5zbGF0aW9uOiBWZWN0b3IzKSB7XHJcbiAgICAgIHRoaXMuZGF0YS5zZXQoX3RyYW5zbGF0aW9uLmdldCgpLCAxMik7XHJcbiAgICAgIC8vIG5vIGZ1bGwgY2FjaGUgcmVzZXQgcmVxdWlyZWRcclxuICAgICAgdGhpcy52ZWN0b3JzLnRyYW5zbGF0aW9uID0gX3RyYW5zbGF0aW9uLmNvcHk7XHJcbiAgICAgIHRoaXMubXV0YXRvciA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogLSBnZXQ6IGEgY29weSBvZiB0aGUgY2FsY3VsYXRlZCByb3RhdGlvbiB2ZWN0b3IgICBcclxuICAgICAqIC0gc2V0OiBlZmZlY3QgdGhlIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHJvdGF0aW9uKCk6IFZlY3RvcjMge1xyXG4gICAgICBpZiAoIXRoaXMudmVjdG9ycy5yb3RhdGlvbilcclxuICAgICAgICB0aGlzLnZlY3RvcnMucm90YXRpb24gPSB0aGlzLmdldEV1bGVyQW5nbGVzKCk7XHJcbiAgICAgIHJldHVybiB0aGlzLnZlY3RvcnMucm90YXRpb24uY29weTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgcm90YXRpb24oX3JvdGF0aW9uOiBWZWN0b3IzKSB7XHJcbiAgICAgIHRoaXMubXV0YXRlKHsgXCJyb3RhdGlvblwiOiBfcm90YXRpb24gfSk7XHJcbiAgICAgIHRoaXMucmVzZXRDYWNoZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBcclxuICAgICAqIC0gZ2V0OiBhIGNvcHkgb2YgdGhlIGNhbGN1bGF0ZWQgc2NhbGUgdmVjdG9yICAgXHJcbiAgICAgKiAtIHNldDogZWZmZWN0IHRoZSBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBzY2FsaW5nKCk6IFZlY3RvcjMge1xyXG4gICAgICBpZiAoIXRoaXMudmVjdG9ycy5zY2FsaW5nKVxyXG4gICAgICAgIHRoaXMudmVjdG9ycy5zY2FsaW5nID0gbmV3IFZlY3RvcjMoXHJcbiAgICAgICAgICBNYXRoLmh5cG90KHRoaXMuZGF0YVswXSwgdGhpcy5kYXRhWzFdLCB0aGlzLmRhdGFbMl0pLFxyXG4gICAgICAgICAgTWF0aC5oeXBvdCh0aGlzLmRhdGFbNF0sIHRoaXMuZGF0YVs1XSwgdGhpcy5kYXRhWzZdKSxcclxuICAgICAgICAgIE1hdGguaHlwb3QodGhpcy5kYXRhWzhdLCB0aGlzLmRhdGFbOV0sIHRoaXMuZGF0YVsxMF0pXHJcbiAgICAgICAgKTtcclxuICAgICAgcmV0dXJuIHRoaXMudmVjdG9ycy5zY2FsaW5nLmNvcHk7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHNjYWxpbmcoX3NjYWxpbmc6IFZlY3RvcjMpIHtcclxuICAgICAgdGhpcy5tdXRhdGUoeyBcInNjYWxpbmdcIjogX3NjYWxpbmcgfSk7XHJcbiAgICAgIHRoaXMucmVzZXRDYWNoZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBTVEFUSUNTXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlIGEgbmV3IGlkZW50aXR5IG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIElERU5USVRZKCk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIC8vIGNvbnN0IHJlc3VsdDogTWF0cml4NHg0ID0gbmV3IE1hdHJpeDR4NCgpO1xyXG4gICAgICBjb25zdCByZXN1bHQ6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLmdldChNYXRyaXg0eDQpO1xyXG4gICAgICByZXN1bHQuZGF0YS5zZXQoW1xyXG4gICAgICAgIDEsIDAsIDAsIDAsXHJcbiAgICAgICAgMCwgMSwgMCwgMCxcclxuICAgICAgICAwLCAwLCAxLCAwLFxyXG4gICAgICAgIDAsIDAsIDAsIDFcclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBhbmQgcmV0dXJucyB0aGUgcHJvZHVjdCBvZiB0d28gcGFzc2VkIG1hdHJpY2VzLlxyXG4gICAgICogQHBhcmFtIF9hIFRoZSBtYXRyaXggdG8gbXVsdGlwbHkuXHJcbiAgICAgKiBAcGFyYW0gX2IgVGhlIG1hdHJpeCB0byBtdWx0aXBseSBieS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBNVUxUSVBMSUNBVElPTihfYTogTWF0cml4NHg0LCBfYjogTWF0cml4NHg0KTogTWF0cml4NHg0IHtcclxuICAgICAgbGV0IGE6IEZsb2F0MzJBcnJheSA9IF9hLmRhdGE7XHJcbiAgICAgIGxldCBiOiBGbG9hdDMyQXJyYXkgPSBfYi5kYXRhO1xyXG4gICAgICAvLyBsZXQgbWF0cml4OiBNYXRyaXg0eDQgPSBuZXcgTWF0cml4NHg0KCk7XHJcbiAgICAgIGNvbnN0IG1hdHJpeDogTWF0cml4NHg0ID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDR4NCk7XHJcbiAgICAgIGxldCBhMDA6IG51bWJlciA9IGFbMCAqIDQgKyAwXTtcclxuICAgICAgbGV0IGEwMTogbnVtYmVyID0gYVswICogNCArIDFdO1xyXG4gICAgICBsZXQgYTAyOiBudW1iZXIgPSBhWzAgKiA0ICsgMl07XHJcbiAgICAgIGxldCBhMDM6IG51bWJlciA9IGFbMCAqIDQgKyAzXTtcclxuICAgICAgbGV0IGExMDogbnVtYmVyID0gYVsxICogNCArIDBdO1xyXG4gICAgICBsZXQgYTExOiBudW1iZXIgPSBhWzEgKiA0ICsgMV07XHJcbiAgICAgIGxldCBhMTI6IG51bWJlciA9IGFbMSAqIDQgKyAyXTtcclxuICAgICAgbGV0IGExMzogbnVtYmVyID0gYVsxICogNCArIDNdO1xyXG4gICAgICBsZXQgYTIwOiBudW1iZXIgPSBhWzIgKiA0ICsgMF07XHJcbiAgICAgIGxldCBhMjE6IG51bWJlciA9IGFbMiAqIDQgKyAxXTtcclxuICAgICAgbGV0IGEyMjogbnVtYmVyID0gYVsyICogNCArIDJdO1xyXG4gICAgICBsZXQgYTIzOiBudW1iZXIgPSBhWzIgKiA0ICsgM107XHJcbiAgICAgIGxldCBhMzA6IG51bWJlciA9IGFbMyAqIDQgKyAwXTtcclxuICAgICAgbGV0IGEzMTogbnVtYmVyID0gYVszICogNCArIDFdO1xyXG4gICAgICBsZXQgYTMyOiBudW1iZXIgPSBhWzMgKiA0ICsgMl07XHJcbiAgICAgIGxldCBhMzM6IG51bWJlciA9IGFbMyAqIDQgKyAzXTtcclxuICAgICAgbGV0IGIwMDogbnVtYmVyID0gYlswICogNCArIDBdO1xyXG4gICAgICBsZXQgYjAxOiBudW1iZXIgPSBiWzAgKiA0ICsgMV07XHJcbiAgICAgIGxldCBiMDI6IG51bWJlciA9IGJbMCAqIDQgKyAyXTtcclxuICAgICAgbGV0IGIwMzogbnVtYmVyID0gYlswICogNCArIDNdO1xyXG4gICAgICBsZXQgYjEwOiBudW1iZXIgPSBiWzEgKiA0ICsgMF07XHJcbiAgICAgIGxldCBiMTE6IG51bWJlciA9IGJbMSAqIDQgKyAxXTtcclxuICAgICAgbGV0IGIxMjogbnVtYmVyID0gYlsxICogNCArIDJdO1xyXG4gICAgICBsZXQgYjEzOiBudW1iZXIgPSBiWzEgKiA0ICsgM107XHJcbiAgICAgIGxldCBiMjA6IG51bWJlciA9IGJbMiAqIDQgKyAwXTtcclxuICAgICAgbGV0IGIyMTogbnVtYmVyID0gYlsyICogNCArIDFdO1xyXG4gICAgICBsZXQgYjIyOiBudW1iZXIgPSBiWzIgKiA0ICsgMl07XHJcbiAgICAgIGxldCBiMjM6IG51bWJlciA9IGJbMiAqIDQgKyAzXTtcclxuICAgICAgbGV0IGIzMDogbnVtYmVyID0gYlszICogNCArIDBdO1xyXG4gICAgICBsZXQgYjMxOiBudW1iZXIgPSBiWzMgKiA0ICsgMV07XHJcbiAgICAgIGxldCBiMzI6IG51bWJlciA9IGJbMyAqIDQgKyAyXTtcclxuICAgICAgbGV0IGIzMzogbnVtYmVyID0gYlszICogNCArIDNdO1xyXG4gICAgICBtYXRyaXguZGF0YS5zZXQoXHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgYjAwICogYTAwICsgYjAxICogYTEwICsgYjAyICogYTIwICsgYjAzICogYTMwLFxyXG4gICAgICAgICAgYjAwICogYTAxICsgYjAxICogYTExICsgYjAyICogYTIxICsgYjAzICogYTMxLFxyXG4gICAgICAgICAgYjAwICogYTAyICsgYjAxICogYTEyICsgYjAyICogYTIyICsgYjAzICogYTMyLFxyXG4gICAgICAgICAgYjAwICogYTAzICsgYjAxICogYTEzICsgYjAyICogYTIzICsgYjAzICogYTMzLFxyXG4gICAgICAgICAgYjEwICogYTAwICsgYjExICogYTEwICsgYjEyICogYTIwICsgYjEzICogYTMwLFxyXG4gICAgICAgICAgYjEwICogYTAxICsgYjExICogYTExICsgYjEyICogYTIxICsgYjEzICogYTMxLFxyXG4gICAgICAgICAgYjEwICogYTAyICsgYjExICogYTEyICsgYjEyICogYTIyICsgYjEzICogYTMyLFxyXG4gICAgICAgICAgYjEwICogYTAzICsgYjExICogYTEzICsgYjEyICogYTIzICsgYjEzICogYTMzLFxyXG4gICAgICAgICAgYjIwICogYTAwICsgYjIxICogYTEwICsgYjIyICogYTIwICsgYjIzICogYTMwLFxyXG4gICAgICAgICAgYjIwICogYTAxICsgYjIxICogYTExICsgYjIyICogYTIxICsgYjIzICogYTMxLFxyXG4gICAgICAgICAgYjIwICogYTAyICsgYjIxICogYTEyICsgYjIyICogYTIyICsgYjIzICogYTMyLFxyXG4gICAgICAgICAgYjIwICogYTAzICsgYjIxICogYTEzICsgYjIyICogYTIzICsgYjIzICogYTMzLFxyXG4gICAgICAgICAgYjMwICogYTAwICsgYjMxICogYTEwICsgYjMyICogYTIwICsgYjMzICogYTMwLFxyXG4gICAgICAgICAgYjMwICogYTAxICsgYjMxICogYTExICsgYjMyICogYTIxICsgYjMzICogYTMxLFxyXG4gICAgICAgICAgYjMwICogYTAyICsgYjMxICogYTEyICsgYjMyICogYTIyICsgYjMzICogYTMyLFxyXG4gICAgICAgICAgYjMwICogYTAzICsgYjMxICogYTEzICsgYjMyICogYTIzICsgYjMzICogYTMzXHJcbiAgICAgICAgXSk7XHJcbiAgICAgIHJldHVybiBtYXRyaXg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBhbmQgcmV0dXJucyB0aGUgaW52ZXJzZSBvZiBhIHBhc3NlZCBtYXRyaXguXHJcbiAgICAgKiBAcGFyYW0gX21hdHJpeCBUaGUgbWF0cml4IHRvIGNvbXB1dGUgdGhlIGludmVyc2Ugb2YuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgSU5WRVJTSU9OKF9tYXRyaXg6IE1hdHJpeDR4NCk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIGxldCBtOiBGbG9hdDMyQXJyYXkgPSBfbWF0cml4LmRhdGE7XHJcbiAgICAgIGxldCBtMDA6IG51bWJlciA9IG1bMCAqIDQgKyAwXTtcclxuICAgICAgbGV0IG0wMTogbnVtYmVyID0gbVswICogNCArIDFdO1xyXG4gICAgICBsZXQgbTAyOiBudW1iZXIgPSBtWzAgKiA0ICsgMl07XHJcbiAgICAgIGxldCBtMDM6IG51bWJlciA9IG1bMCAqIDQgKyAzXTtcclxuICAgICAgbGV0IG0xMDogbnVtYmVyID0gbVsxICogNCArIDBdO1xyXG4gICAgICBsZXQgbTExOiBudW1iZXIgPSBtWzEgKiA0ICsgMV07XHJcbiAgICAgIGxldCBtMTI6IG51bWJlciA9IG1bMSAqIDQgKyAyXTtcclxuICAgICAgbGV0IG0xMzogbnVtYmVyID0gbVsxICogNCArIDNdO1xyXG4gICAgICBsZXQgbTIwOiBudW1iZXIgPSBtWzIgKiA0ICsgMF07XHJcbiAgICAgIGxldCBtMjE6IG51bWJlciA9IG1bMiAqIDQgKyAxXTtcclxuICAgICAgbGV0IG0yMjogbnVtYmVyID0gbVsyICogNCArIDJdO1xyXG4gICAgICBsZXQgbTIzOiBudW1iZXIgPSBtWzIgKiA0ICsgM107XHJcbiAgICAgIGxldCBtMzA6IG51bWJlciA9IG1bMyAqIDQgKyAwXTtcclxuICAgICAgbGV0IG0zMTogbnVtYmVyID0gbVszICogNCArIDFdO1xyXG4gICAgICBsZXQgbTMyOiBudW1iZXIgPSBtWzMgKiA0ICsgMl07XHJcbiAgICAgIGxldCBtMzM6IG51bWJlciA9IG1bMyAqIDQgKyAzXTtcclxuICAgICAgbGV0IHRtcDA6IG51bWJlciA9IG0yMiAqIG0zMztcclxuICAgICAgbGV0IHRtcDE6IG51bWJlciA9IG0zMiAqIG0yMztcclxuICAgICAgbGV0IHRtcDI6IG51bWJlciA9IG0xMiAqIG0zMztcclxuICAgICAgbGV0IHRtcDM6IG51bWJlciA9IG0zMiAqIG0xMztcclxuICAgICAgbGV0IHRtcDQ6IG51bWJlciA9IG0xMiAqIG0yMztcclxuICAgICAgbGV0IHRtcDU6IG51bWJlciA9IG0yMiAqIG0xMztcclxuICAgICAgbGV0IHRtcDY6IG51bWJlciA9IG0wMiAqIG0zMztcclxuICAgICAgbGV0IHRtcDc6IG51bWJlciA9IG0zMiAqIG0wMztcclxuICAgICAgbGV0IHRtcDg6IG51bWJlciA9IG0wMiAqIG0yMztcclxuICAgICAgbGV0IHRtcDk6IG51bWJlciA9IG0yMiAqIG0wMztcclxuICAgICAgbGV0IHRtcDEwOiBudW1iZXIgPSBtMDIgKiBtMTM7XHJcbiAgICAgIGxldCB0bXAxMTogbnVtYmVyID0gbTEyICogbTAzO1xyXG4gICAgICBsZXQgdG1wMTI6IG51bWJlciA9IG0yMCAqIG0zMTtcclxuICAgICAgbGV0IHRtcDEzOiBudW1iZXIgPSBtMzAgKiBtMjE7XHJcbiAgICAgIGxldCB0bXAxNDogbnVtYmVyID0gbTEwICogbTMxO1xyXG4gICAgICBsZXQgdG1wMTU6IG51bWJlciA9IG0zMCAqIG0xMTtcclxuICAgICAgbGV0IHRtcDE2OiBudW1iZXIgPSBtMTAgKiBtMjE7XHJcbiAgICAgIGxldCB0bXAxNzogbnVtYmVyID0gbTIwICogbTExO1xyXG4gICAgICBsZXQgdG1wMTg6IG51bWJlciA9IG0wMCAqIG0zMTtcclxuICAgICAgbGV0IHRtcDE5OiBudW1iZXIgPSBtMzAgKiBtMDE7XHJcbiAgICAgIGxldCB0bXAyMDogbnVtYmVyID0gbTAwICogbTIxO1xyXG4gICAgICBsZXQgdG1wMjE6IG51bWJlciA9IG0yMCAqIG0wMTtcclxuICAgICAgbGV0IHRtcDIyOiBudW1iZXIgPSBtMDAgKiBtMTE7XHJcbiAgICAgIGxldCB0bXAyMzogbnVtYmVyID0gbTEwICogbTAxO1xyXG5cclxuICAgICAgbGV0IHQwOiBudW1iZXIgPSAodG1wMCAqIG0xMSArIHRtcDMgKiBtMjEgKyB0bXA0ICogbTMxKSAtXHJcbiAgICAgICAgKHRtcDEgKiBtMTEgKyB0bXAyICogbTIxICsgdG1wNSAqIG0zMSk7XHJcblxyXG4gICAgICBsZXQgdDE6IG51bWJlciA9ICh0bXAxICogbTAxICsgdG1wNiAqIG0yMSArIHRtcDkgKiBtMzEpIC1cclxuICAgICAgICAodG1wMCAqIG0wMSArIHRtcDcgKiBtMjEgKyB0bXA4ICogbTMxKTtcclxuICAgICAgbGV0IHQyOiBudW1iZXIgPSAodG1wMiAqIG0wMSArIHRtcDcgKiBtMTEgKyB0bXAxMCAqIG0zMSkgLVxyXG4gICAgICAgICh0bXAzICogbTAxICsgdG1wNiAqIG0xMSArIHRtcDExICogbTMxKTtcclxuICAgICAgbGV0IHQzOiBudW1iZXIgPSAodG1wNSAqIG0wMSArIHRtcDggKiBtMTEgKyB0bXAxMSAqIG0yMSkgLVxyXG4gICAgICAgICh0bXA0ICogbTAxICsgdG1wOSAqIG0xMSArIHRtcDEwICogbTIxKTtcclxuXHJcbiAgICAgIGxldCBkOiBudW1iZXIgPSAxLjAgLyAobTAwICogdDAgKyBtMTAgKiB0MSArIG0yMCAqIHQyICsgbTMwICogdDMpO1xyXG5cclxuICAgICAgLy8gbGV0IG1hdHJpeDogTWF0cml4NHg0ID0gbmV3IE1hdHJpeDR4NDtcclxuICAgICAgY29uc3QgbWF0cml4OiBNYXRyaXg0eDQgPSBSZWN5Y2xlci5nZXQoTWF0cml4NHg0KTtcclxuICAgICAgbWF0cml4LmRhdGEuc2V0KFtcclxuICAgICAgICBkICogdDAsIC8vIFswXVxyXG4gICAgICAgIGQgKiB0MSwgLy8gWzFdXHJcbiAgICAgICAgZCAqIHQyLCAvLyBbMl1cclxuICAgICAgICBkICogdDMsIC8vIFszXVxyXG4gICAgICAgIGQgKiAoKHRtcDEgKiBtMTAgKyB0bXAyICogbTIwICsgdG1wNSAqIG0zMCkgLSAodG1wMCAqIG0xMCArIHRtcDMgKiBtMjAgKyB0bXA0ICogbTMwKSksICAgICAgICAvLyBbNF1cclxuICAgICAgICBkICogKCh0bXAwICogbTAwICsgdG1wNyAqIG0yMCArIHRtcDggKiBtMzApIC0gKHRtcDEgKiBtMDAgKyB0bXA2ICogbTIwICsgdG1wOSAqIG0zMCkpLCAgICAgICAgLy8gWzVdXHJcbiAgICAgICAgZCAqICgodG1wMyAqIG0wMCArIHRtcDYgKiBtMTAgKyB0bXAxMSAqIG0zMCkgLSAodG1wMiAqIG0wMCArIHRtcDcgKiBtMTAgKyB0bXAxMCAqIG0zMCkpLCAgICAgIC8vIFs2XVxyXG4gICAgICAgIGQgKiAoKHRtcDQgKiBtMDAgKyB0bXA5ICogbTEwICsgdG1wMTAgKiBtMjApIC0gKHRtcDUgKiBtMDAgKyB0bXA4ICogbTEwICsgdG1wMTEgKiBtMjApKSwgICAgICAvLyBbN11cclxuICAgICAgICBkICogKCh0bXAxMiAqIG0xMyArIHRtcDE1ICogbTIzICsgdG1wMTYgKiBtMzMpIC0gKHRtcDEzICogbTEzICsgdG1wMTQgKiBtMjMgKyB0bXAxNyAqIG0zMykpLCAgLy8gWzhdXHJcbiAgICAgICAgZCAqICgodG1wMTMgKiBtMDMgKyB0bXAxOCAqIG0yMyArIHRtcDIxICogbTMzKSAtICh0bXAxMiAqIG0wMyArIHRtcDE5ICogbTIzICsgdG1wMjAgKiBtMzMpKSwgIC8vIFs5XVxyXG4gICAgICAgIGQgKiAoKHRtcDE0ICogbTAzICsgdG1wMTkgKiBtMTMgKyB0bXAyMiAqIG0zMykgLSAodG1wMTUgKiBtMDMgKyB0bXAxOCAqIG0xMyArIHRtcDIzICogbTMzKSksICAvLyBbMTBdXHJcbiAgICAgICAgZCAqICgodG1wMTcgKiBtMDMgKyB0bXAyMCAqIG0xMyArIHRtcDIzICogbTIzKSAtICh0bXAxNiAqIG0wMyArIHRtcDIxICogbTEzICsgdG1wMjIgKiBtMjMpKSwgIC8vIFsxMV1cclxuICAgICAgICBkICogKCh0bXAxNCAqIG0yMiArIHRtcDE3ICogbTMyICsgdG1wMTMgKiBtMTIpIC0gKHRtcDE2ICogbTMyICsgdG1wMTIgKiBtMTIgKyB0bXAxNSAqIG0yMikpLCAgLy8gWzEyXVxyXG4gICAgICAgIGQgKiAoKHRtcDIwICogbTMyICsgdG1wMTIgKiBtMDIgKyB0bXAxOSAqIG0yMikgLSAodG1wMTggKiBtMjIgKyB0bXAyMSAqIG0zMiArIHRtcDEzICogbTAyKSksICAvLyBbMTNdXHJcbiAgICAgICAgZCAqICgodG1wMTggKiBtMTIgKyB0bXAyMyAqIG0zMiArIHRtcDE1ICogbTAyKSAtICh0bXAyMiAqIG0zMiArIHRtcDE0ICogbTAyICsgdG1wMTkgKiBtMTIpKSwgIC8vIFsxNF1cclxuICAgICAgICBkICogKCh0bXAyMiAqIG0yMiArIHRtcDE2ICogbTAyICsgdG1wMjEgKiBtMTIpIC0gKHRtcDIwICogbTEyICsgdG1wMjMgKiBtMjIgKyB0bXAxNyAqIG0wMikpICAvLyBbMTVdXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gbWF0cml4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgYW5kIHJldHVybnMgYSByb3RhdGlvbm1hdHJpeCB0aGF0IGFsaWducyBhIHRyYW5zZm9ybWF0aW9ucyB6LWF4aXMgd2l0aCB0aGUgdmVjdG9yIGJldHdlZW4gaXQgYW5kIGl0cyB0YXJnZXQuXHJcbiAgICAgKiBAcGFyYW0gX3RyYW5zZm9ybVBvc2l0aW9uIFRoZSB4LHkgYW5kIHotY29vcmRpbmF0ZXMgb2YgdGhlIG9iamVjdCB0byByb3RhdGUuXHJcbiAgICAgKiBAcGFyYW0gX3RhcmdldFBvc2l0aW9uIFRoZSBwb3NpdGlvbiB0byBsb29rIGF0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIExPT0tfQVQoX3RyYW5zZm9ybVBvc2l0aW9uOiBWZWN0b3IzLCBfdGFyZ2V0UG9zaXRpb246IFZlY3RvcjMsIF91cDogVmVjdG9yMyA9IFZlY3RvcjMuWSgpKTogTWF0cml4NHg0IHtcclxuICAgICAgLy8gY29uc3QgbWF0cml4OiBNYXRyaXg0eDQgPSBuZXcgTWF0cml4NHg0O1xyXG4gICAgICBjb25zdCBtYXRyaXg6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLmdldChNYXRyaXg0eDQpO1xyXG4gICAgICBsZXQgekF4aXM6IFZlY3RvcjMgPSBWZWN0b3IzLkRJRkZFUkVOQ0UoX3RhcmdldFBvc2l0aW9uLCBfdHJhbnNmb3JtUG9zaXRpb24pO1xyXG4gICAgICB6QXhpcy5ub3JtYWxpemUoKTtcclxuICAgICAgbGV0IHhBeGlzOiBWZWN0b3IzID0gVmVjdG9yMy5OT1JNQUxJWkFUSU9OKFZlY3RvcjMuQ1JPU1MoX3VwLCB6QXhpcykpO1xyXG4gICAgICBsZXQgeUF4aXM6IFZlY3RvcjMgPSBWZWN0b3IzLk5PUk1BTElaQVRJT04oVmVjdG9yMy5DUk9TUyh6QXhpcywgeEF4aXMpKTtcclxuICAgICAgbWF0cml4LmRhdGEuc2V0KFxyXG4gICAgICAgIFtcclxuICAgICAgICAgIHhBeGlzLngsIHhBeGlzLnksIHhBeGlzLnosIDAsXHJcbiAgICAgICAgICB5QXhpcy54LCB5QXhpcy55LCB5QXhpcy56LCAwLFxyXG4gICAgICAgICAgekF4aXMueCwgekF4aXMueSwgekF4aXMueiwgMCxcclxuICAgICAgICAgIF90cmFuc2Zvcm1Qb3NpdGlvbi54LFxyXG4gICAgICAgICAgX3RyYW5zZm9ybVBvc2l0aW9uLnksXHJcbiAgICAgICAgICBfdHJhbnNmb3JtUG9zaXRpb24ueixcclxuICAgICAgICAgIDFcclxuICAgICAgICBdKTtcclxuICAgICAgcmV0dXJuIG1hdHJpeDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBtYXRyaXggdGhhdCB0cmFuc2xhdGVzIGNvb3JkaW5hdGVzIGFsb25nIHRoZSB4LSwgeS0gYW5kIHotYXhpcyBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBUUkFOU0xBVElPTihfdHJhbnNsYXRlOiBWZWN0b3IzKTogTWF0cml4NHg0IHtcclxuICAgICAgLy8gbGV0IG1hdHJpeDogTWF0cml4NHg0ID0gbmV3IE1hdHJpeDR4NDtcclxuICAgICAgY29uc3QgbWF0cml4OiBNYXRyaXg0eDQgPSBSZWN5Y2xlci5nZXQoTWF0cml4NHg0KTtcclxuICAgICAgbWF0cml4LmRhdGEuc2V0KFtcclxuICAgICAgICAxLCAwLCAwLCAwLFxyXG4gICAgICAgIDAsIDEsIDAsIDAsXHJcbiAgICAgICAgMCwgMCwgMSwgMCxcclxuICAgICAgICBfdHJhbnNsYXRlLngsIF90cmFuc2xhdGUueSwgX3RyYW5zbGF0ZS56LCAxXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gbWF0cml4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG1hdHJpeCB0aGF0IHJvdGF0ZXMgY29vcmRpbmF0ZXMgb24gdGhlIHgtYXhpcyB3aGVuIG11bHRpcGxpZWQgYnkuXHJcbiAgICAgKiBAcGFyYW0gX2FuZ2xlSW5EZWdyZWVzIFRoZSB2YWx1ZSBvZiB0aGUgcm90YXRpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgUk9UQVRJT05fWChfYW5nbGVJbkRlZ3JlZXM6IG51bWJlcik6IE1hdHJpeDR4NCB7XHJcbiAgICAgIC8vIGNvbnN0IG1hdHJpeDogTWF0cml4NHg0ID0gbmV3IE1hdHJpeDR4NDtcclxuICAgICAgY29uc3QgbWF0cml4OiBNYXRyaXg0eDQgPSBSZWN5Y2xlci5nZXQoTWF0cml4NHg0KTtcclxuICAgICAgbGV0IGFuZ2xlSW5SYWRpYW5zOiBudW1iZXIgPSBfYW5nbGVJbkRlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwO1xyXG4gICAgICBsZXQgc2luOiBudW1iZXIgPSBNYXRoLnNpbihhbmdsZUluUmFkaWFucyk7XHJcbiAgICAgIGxldCBjb3M6IG51bWJlciA9IE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKTtcclxuICAgICAgbWF0cml4LmRhdGEuc2V0KFtcclxuICAgICAgICAxLCAwLCAwLCAwLFxyXG4gICAgICAgIDAsIGNvcywgc2luLCAwLFxyXG4gICAgICAgIDAsIC1zaW4sIGNvcywgMCxcclxuICAgICAgICAwLCAwLCAwLCAxXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gbWF0cml4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG1hdHJpeCB0aGF0IHJvdGF0ZXMgY29vcmRpbmF0ZXMgb24gdGhlIHktYXhpcyB3aGVuIG11bHRpcGxpZWQgYnkuXHJcbiAgICAgKiBAcGFyYW0gX2FuZ2xlSW5EZWdyZWVzIFRoZSB2YWx1ZSBvZiB0aGUgcm90YXRpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgUk9UQVRJT05fWShfYW5nbGVJbkRlZ3JlZXM6IG51bWJlcik6IE1hdHJpeDR4NCB7XHJcbiAgICAgIC8vIGNvbnN0IG1hdHJpeDogTWF0cml4NHg0ID0gbmV3IE1hdHJpeDR4NDtcclxuICAgICAgbGV0IG1hdHJpeDogTWF0cml4NHg0ID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDR4NCk7XHJcbiAgICAgIGxldCBhbmdsZUluUmFkaWFuczogbnVtYmVyID0gX2FuZ2xlSW5EZWdyZWVzICogTWF0aC5QSSAvIDE4MDtcclxuICAgICAgbGV0IHNpbjogbnVtYmVyID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xyXG4gICAgICBsZXQgY29zOiBudW1iZXIgPSBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyk7XHJcbiAgICAgIG1hdHJpeC5kYXRhLnNldChbXHJcbiAgICAgICAgY29zLCAwLCAtc2luLCAwLFxyXG4gICAgICAgIDAsIDEsIDAsIDAsXHJcbiAgICAgICAgc2luLCAwLCBjb3MsIDAsXHJcbiAgICAgICAgMCwgMCwgMCwgMVxyXG4gICAgICBdKTtcclxuICAgICAgcmV0dXJuIG1hdHJpeDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBtYXRyaXggdGhhdCByb3RhdGVzIGNvb3JkaW5hdGVzIG9uIHRoZSB6LWF4aXMgd2hlbiBtdWx0aXBsaWVkIGJ5LlxyXG4gICAgICogQHBhcmFtIF9hbmdsZUluRGVncmVlcyBUaGUgdmFsdWUgb2YgdGhlIHJvdGF0aW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFJPVEFUSU9OX1ooX2FuZ2xlSW5EZWdyZWVzOiBudW1iZXIpOiBNYXRyaXg0eDQge1xyXG4gICAgICAvLyBjb25zdCBtYXRyaXg6IE1hdHJpeDR4NCA9IG5ldyBNYXRyaXg0eDQ7XHJcbiAgICAgIGNvbnN0IG1hdHJpeDogTWF0cml4NHg0ID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDR4NCk7XHJcbiAgICAgIGxldCBhbmdsZUluUmFkaWFuczogbnVtYmVyID0gX2FuZ2xlSW5EZWdyZWVzICogTWF0aC5QSSAvIDE4MDtcclxuICAgICAgbGV0IHNpbjogbnVtYmVyID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xyXG4gICAgICBsZXQgY29zOiBudW1iZXIgPSBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyk7XHJcbiAgICAgIG1hdHJpeC5kYXRhLnNldChbXHJcbiAgICAgICAgY29zLCBzaW4sIDAsIDAsXHJcbiAgICAgICAgLXNpbiwgY29zLCAwLCAwLFxyXG4gICAgICAgIDAsIDAsIDEsIDAsXHJcbiAgICAgICAgMCwgMCwgMCwgMVxyXG4gICAgICBdKTtcclxuICAgICAgcmV0dXJuIG1hdHJpeDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBtYXRyaXggdGhhdCBzY2FsZXMgY29vcmRpbmF0ZXMgYWxvbmcgdGhlIHgtLCB5LSBhbmQgei1heGlzIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgU0NBTElORyhfc2NhbGFyOiBWZWN0b3IzKTogTWF0cml4NHg0IHtcclxuICAgICAgLy8gY29uc3QgbWF0cml4OiBNYXRyaXg0eDQgPSBuZXcgTWF0cml4NHg0O1xyXG4gICAgICBjb25zdCBtYXRyaXg6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLmdldChNYXRyaXg0eDQpO1xyXG4gICAgICBtYXRyaXguZGF0YS5zZXQoW1xyXG4gICAgICAgIF9zY2FsYXIueCwgMCwgMCwgMCxcclxuICAgICAgICAwLCBfc2NhbGFyLnksIDAsIDAsXHJcbiAgICAgICAgMCwgMCwgX3NjYWxhci56LCAwLFxyXG4gICAgICAgIDAsIDAsIDAsIDFcclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiBtYXRyaXg7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gUFJPSkVDVElPTlNcclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgYW5kIHJldHVybnMgYSBtYXRyaXggdGhhdCBhcHBsaWVzIHBlcnNwZWN0aXZlIHRvIGFuIG9iamVjdCwgaWYgaXRzIHRyYW5zZm9ybSBpcyBtdWx0aXBsaWVkIGJ5IGl0LlxyXG4gICAgICogQHBhcmFtIF9hc3BlY3QgVGhlIGFzcGVjdCByYXRpbyBiZXR3ZWVuIHdpZHRoIGFuZCBoZWlnaHQgb2YgcHJvamVjdGlvbnNwYWNlLihEZWZhdWx0ID0gY2FudmFzLmNsaWVudFdpZHRoIC8gY2FudmFzLkNsaWVudEhlaWdodClcclxuICAgICAqIEBwYXJhbSBfZmllbGRPZlZpZXdJbkRlZ3JlZXMgVGhlIGZpZWxkIG9mIHZpZXcgaW4gRGVncmVlcy4gKERlZmF1bHQgPSA0NSlcclxuICAgICAqIEBwYXJhbSBfbmVhciBUaGUgbmVhciBjbGlwc3BhY2UgYm9yZGVyIG9uIHRoZSB6LWF4aXMuXHJcbiAgICAgKiBAcGFyYW0gX2ZhciBUaGUgZmFyIGNsaXBzcGFjZSBib3JkZXIgb24gdGhlIHotYXhpcy5cclxuICAgICAqIEBwYXJhbSBfZGlyZWN0aW9uIFRoZSBwbGFuZSBvbiB3aGljaCB0aGUgZmllbGRPZlZpZXctQW5nbGUgaXMgZ2l2ZW4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgUFJPSkVDVElPTl9DRU5UUkFMKF9hc3BlY3Q6IG51bWJlciwgX2ZpZWxkT2ZWaWV3SW5EZWdyZWVzOiBudW1iZXIsIF9uZWFyOiBudW1iZXIsIF9mYXI6IG51bWJlciwgX2RpcmVjdGlvbjogRklFTERfT0ZfVklFVyk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIC8vVE9ETzogY2FtZXJhIGxvb2tzIGRvd24gbmVnYXRpdmUgei1kaXJlY3Rpb24sIHNob3VsZCBiZSBwb3NpdGl2ZVxyXG4gICAgICBsZXQgZmllbGRPZlZpZXdJblJhZGlhbnM6IG51bWJlciA9IF9maWVsZE9mVmlld0luRGVncmVlcyAqIE1hdGguUEkgLyAxODA7XHJcbiAgICAgIGxldCBmOiBudW1iZXIgPSBNYXRoLnRhbigwLjUgKiAoTWF0aC5QSSAtIGZpZWxkT2ZWaWV3SW5SYWRpYW5zKSk7XHJcbiAgICAgIGxldCByYW5nZUludjogbnVtYmVyID0gMS4wIC8gKF9uZWFyIC0gX2Zhcik7XHJcbiAgICAgIC8vIGNvbnN0IG1hdHJpeDogTWF0cml4NHg0ID0gbmV3IE1hdHJpeDR4NDtcclxuICAgICAgY29uc3QgbWF0cml4OiBNYXRyaXg0eDQgPSBSZWN5Y2xlci5nZXQoTWF0cml4NHg0KTtcclxuICAgICAgbWF0cml4LmRhdGEuc2V0KFtcclxuICAgICAgICBmLCAwLCAwLCAwLFxyXG4gICAgICAgIDAsIGYsIDAsIDAsXHJcbiAgICAgICAgMCwgMCwgKF9uZWFyICsgX2ZhcikgKiByYW5nZUludiwgLTEsXHJcbiAgICAgICAgMCwgMCwgX25lYXIgKiBfZmFyICogcmFuZ2VJbnYgKiAyLCAwXHJcbiAgICAgIF0pO1xyXG5cclxuICAgICAgaWYgKF9kaXJlY3Rpb24gPT0gRklFTERfT0ZfVklFVy5ESUFHT05BTCkge1xyXG4gICAgICAgIF9hc3BlY3QgPSBNYXRoLnNxcnQoX2FzcGVjdCk7XHJcbiAgICAgICAgbWF0cml4LmRhdGFbMF0gPSBmIC8gX2FzcGVjdDtcclxuICAgICAgICBtYXRyaXguZGF0YVs1XSA9IGYgKiBfYXNwZWN0O1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKF9kaXJlY3Rpb24gPT0gRklFTERfT0ZfVklFVy5WRVJUSUNBTClcclxuICAgICAgICBtYXRyaXguZGF0YVswXSA9IGYgLyBfYXNwZWN0O1xyXG4gICAgICBlbHNlIC8vRk9WX0RJUkVDVElPTi5IT1JJWk9OVEFMXHJcbiAgICAgICAgbWF0cml4LmRhdGFbNV0gPSBmICogX2FzcGVjdDtcclxuXHJcbiAgICAgIC8vIEhBQ0s6IG1hdHJpeCBzaG91bGQgbG9vayBpbiBwb3NpdGl2ZSB6LWRpcmVjdGlvbiwgcHJlZmVyYWJseSB0aGUgbWF0cml4IHNob3VsZCBiZSBjYWxjdWxhdGVkIGxpa2UgdGhhdCByaWdodCBhd2F5XHJcbiAgICAgIG1hdHJpeC5yb3RhdGVZKDE4MCk7XHJcblxyXG4gICAgICByZXR1cm4gbWF0cml4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgYW5kIHJldHVybnMgYSBtYXRyaXggdGhhdCBhcHBsaWVzIG9ydGhvZ3JhcGhpYyBwcm9qZWN0aW9uIHRvIGFuIG9iamVjdCwgaWYgaXRzIHRyYW5zZm9ybSBpcyBtdWx0aXBsaWVkIGJ5IGl0LlxyXG4gICAgICogQHBhcmFtIF9sZWZ0IFRoZSBwb3NpdGlvbnZhbHVlIG9mIHRoZSBwcm9qZWN0aW9uc3BhY2UncyBsZWZ0IGJvcmRlci5cclxuICAgICAqIEBwYXJhbSBfcmlnaHQgVGhlIHBvc2l0aW9udmFsdWUgb2YgdGhlIHByb2plY3Rpb25zcGFjZSdzIHJpZ2h0IGJvcmRlci5cclxuICAgICAqIEBwYXJhbSBfYm90dG9tIFRoZSBwb3NpdGlvbnZhbHVlIG9mIHRoZSBwcm9qZWN0aW9uc3BhY2UncyBib3R0b20gYm9yZGVyLlxyXG4gICAgICogQHBhcmFtIF90b3AgVGhlIHBvc2l0aW9udmFsdWUgb2YgdGhlIHByb2plY3Rpb25zcGFjZSdzIHRvcCBib3JkZXIuXHJcbiAgICAgKiBAcGFyYW0gX25lYXIgVGhlIHBvc2l0aW9udmFsdWUgb2YgdGhlIHByb2plY3Rpb25zcGFjZSdzIG5lYXIgYm9yZGVyLlxyXG4gICAgICogQHBhcmFtIF9mYXIgVGhlIHBvc2l0aW9udmFsdWUgb2YgdGhlIHByb2plY3Rpb25zcGFjZSdzIGZhciBib3JkZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBQUk9KRUNUSU9OX09SVEhPR1JBUEhJQyhfbGVmdDogbnVtYmVyLCBfcmlnaHQ6IG51bWJlciwgX2JvdHRvbTogbnVtYmVyLCBfdG9wOiBudW1iZXIsIF9uZWFyOiBudW1iZXIgPSAtNDAwLCBfZmFyOiBudW1iZXIgPSA0MDApOiBNYXRyaXg0eDQge1xyXG4gICAgICAvLyBjb25zdCBtYXRyaXg6IE1hdHJpeDR4NCA9IG5ldyBNYXRyaXg0eDQ7XHJcbiAgICAgIGNvbnN0IG1hdHJpeDogTWF0cml4NHg0ID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDR4NCk7XHJcbiAgICAgIG1hdHJpeC5kYXRhLnNldChbXHJcbiAgICAgICAgMiAvIChfcmlnaHQgLSBfbGVmdCksIDAsIDAsIDAsXHJcbiAgICAgICAgMCwgMiAvIChfdG9wIC0gX2JvdHRvbSksIDAsIDAsXHJcbiAgICAgICAgMCwgMCwgMiAvIChfbmVhciAtIF9mYXIpLCAwLFxyXG4gICAgICAgIChfbGVmdCArIF9yaWdodCkgLyAoX2xlZnQgLSBfcmlnaHQpLFxyXG4gICAgICAgIChfYm90dG9tICsgX3RvcCkgLyAoX2JvdHRvbSAtIF90b3ApLFxyXG4gICAgICAgIChfbmVhciArIF9mYXIpIC8gKF9uZWFyIC0gX2ZhciksXHJcbiAgICAgICAgMVxyXG4gICAgICBdKTtcclxuICAgICAgcmV0dXJuIG1hdHJpeDtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBSb3RhdGlvblxyXG4gICAgLyoqXHJcbiAgICAgKiBSb3RhdGUgdGhpcyBtYXRyaXggYnkgZ2l2ZW4gdmVjdG9yIGluIHRoZSBvcmRlciBaLCBZLCBYLiBSaWdodCBoYW5kIHJvdGF0aW9uIGlzIHVzZWQsIHRodW1iIHBvaW50cyBpbiBheGlzIGRpcmVjdGlvbiwgZmluZ2VycyBjdXJsaW5nIGluZGljYXRlIHJvdGF0aW9uXHJcbiAgICAgKiBAcGFyYW0gX2J5IFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcm90YXRlKF9ieTogVmVjdG9yMywgX2Zyb21MZWZ0OiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcclxuICAgICAgdGhpcy5yb3RhdGVaKF9ieS56LCBfZnJvbUxlZnQpO1xyXG4gICAgICB0aGlzLnJvdGF0ZVkoX2J5LnksIF9mcm9tTGVmdCk7XHJcbiAgICAgIHRoaXMucm90YXRlWChfYnkueCwgX2Zyb21MZWZ0KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSByb3RhdGlvbiBhcm91bmQgdGhlIHgtQXhpcyB0byB0aGlzIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcm90YXRlWChfYW5nbGVJbkRlZ3JlZXM6IG51bWJlciwgX2Zyb21MZWZ0OiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcclxuICAgICAgbGV0IHJvdGF0aW9uOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuUk9UQVRJT05fWChfYW5nbGVJbkRlZ3JlZXMpO1xyXG4gICAgICB0aGlzLm11bHRpcGx5KHJvdGF0aW9uLCBfZnJvbUxlZnQpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShyb3RhdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgcm90YXRpb24gYXJvdW5kIHRoZSB5LUF4aXMgdG8gdGhpcyBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgcHVibGljIHJvdGF0ZVkoX2FuZ2xlSW5EZWdyZWVzOiBudW1iZXIsIF9mcm9tTGVmdDogYm9vbGVhbiA9IGZhbHNlKTogdm9pZCB7XHJcbiAgICAgIGxldCByb3RhdGlvbjogTWF0cml4NHg0ID0gTWF0cml4NHg0LlJPVEFUSU9OX1koX2FuZ2xlSW5EZWdyZWVzKTtcclxuICAgICAgdGhpcy5tdWx0aXBseShyb3RhdGlvbiwgX2Zyb21MZWZ0KTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUocm90YXRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHJvdGF0aW9uIGFyb3VuZCB0aGUgei1BeGlzIHRvIHRoaXMgbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByb3RhdGVaKF9hbmdsZUluRGVncmVlczogbnVtYmVyLCBfZnJvbUxlZnQ6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xyXG4gICAgICBsZXQgcm90YXRpb246IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5ST1RBVElPTl9aKF9hbmdsZUluRGVncmVlcyk7XHJcbiAgICAgIHRoaXMubXVsdGlwbHkocm90YXRpb24sIF9mcm9tTGVmdCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKHJvdGF0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkanVzdHMgdGhlIHJvdGF0aW9uIG9mIHRoaXMgbWF0cml4IHRvIGZhY2UgdGhlIGdpdmVuIHRhcmdldCBhbmQgdGlsdHMgaXQgdG8gYWNjb3JkIHdpdGggdGhlIGdpdmVuIHVwIHZlY3RvciBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGxvb2tBdChfdGFyZ2V0OiBWZWN0b3IzLCBfdXA6IFZlY3RvcjMgPSBWZWN0b3IzLlkoKSk6IHZvaWQge1xyXG4gICAgICBjb25zdCBtYXRyaXg6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5MT09LX0FUKHRoaXMudHJhbnNsYXRpb24sIF90YXJnZXQpOyAvLyBUT0RPOiBIYW5kbGUgcm90YXRpb24gYXJvdW5kIHotYXhpc1xyXG4gICAgICB0aGlzLnNldChtYXRyaXgpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShtYXRyaXgpO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zbGF0aW9uXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIHRyYW5zbGF0aW9uIGJ5IHRoZSBnaXZlbiB2ZWN0b3IgdG8gdGhpcyBtYXRyaXggXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0cmFuc2xhdGUoX2J5OiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIGNvbnN0IG1hdHJpeDogTWF0cml4NHg0ID0gTWF0cml4NHg0Lk1VTFRJUExJQ0FUSU9OKHRoaXMsIE1hdHJpeDR4NC5UUkFOU0xBVElPTihfYnkpKTtcclxuICAgICAgLy8gVE9ETzogcG9zc2libGUgb3B0aW1pemF0aW9uLCB0cmFuc2xhdGlvbiBtYXkgYWx0ZXIgbXV0YXRvciBpbnN0ZWFkIG9mIGRlbGV0aW5nIGl0LlxyXG4gICAgICB0aGlzLnNldChtYXRyaXgpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShtYXRyaXgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgdHJhbnNsYXRpb24gYWxvbmcgdGhlIHgtQXhpcyBieSB0aGUgZ2l2ZW4gYW1vdW50IHRvIHRoaXMgbWF0cml4IFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdHJhbnNsYXRlWChfeDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuZGF0YVsxMl0gKz0gX3g7XHJcbiAgICAgIHRoaXMubXV0YXRvciA9IG51bGw7XHJcbiAgICAgIHRoaXMudmVjdG9ycy50cmFuc2xhdGlvbiA9IG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIHRyYW5zbGF0aW9uIGFsb25nIHRoZSB5LUF4aXMgYnkgdGhlIGdpdmVuIGFtb3VudCB0byB0aGlzIG1hdHJpeCBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHRyYW5zbGF0ZVkoX3k6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICB0aGlzLmRhdGFbMTNdICs9IF95O1xyXG4gICAgICB0aGlzLm11dGF0b3IgPSBudWxsO1xyXG4gICAgICB0aGlzLnZlY3RvcnMudHJhbnNsYXRpb24gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSB0cmFuc2xhdGlvbiBhbG9uZyB0aGUgeS1BeGlzIGJ5IHRoZSBnaXZlbiBhbW91bnQgdG8gdGhpcyBtYXRyaXggXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0cmFuc2xhdGVaKF96OiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy5kYXRhWzE0XSArPSBfejtcclxuICAgICAgdGhpcy5tdXRhdG9yID0gbnVsbDtcclxuICAgICAgdGhpcy52ZWN0b3JzLnRyYW5zbGF0aW9uID0gbnVsbDtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBTY2FsaW5nXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIHNjYWxpbmcgYnkgdGhlIGdpdmVuIHZlY3RvciB0byB0aGlzIG1hdHJpeCBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNjYWxlKF9ieTogVmVjdG9yMyk6IHZvaWQge1xyXG4gICAgICBjb25zdCBtYXRyaXg6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5NVUxUSVBMSUNBVElPTih0aGlzLCBNYXRyaXg0eDQuU0NBTElORyhfYnkpKTtcclxuICAgICAgdGhpcy5zZXQobWF0cml4KTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUobWF0cml4KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgc2NhbGluZyBhbG9uZyB0aGUgeC1BeGlzIGJ5IHRoZSBnaXZlbiBhbW91bnQgdG8gdGhpcyBtYXRyaXggXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzY2FsZVgoX2J5OiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy5zY2FsZShuZXcgVmVjdG9yMyhfYnksIDEsIDEpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgc2NhbGluZyBhbG9uZyB0aGUgeS1BeGlzIGJ5IHRoZSBnaXZlbiBhbW91bnQgdG8gdGhpcyBtYXRyaXggXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzY2FsZVkoX2J5OiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy5zY2FsZShuZXcgVmVjdG9yMygxLCBfYnksIDEpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgc2NhbGluZyBhbG9uZyB0aGUgei1BeGlzIGJ5IHRoZSBnaXZlbiBhbW91bnQgdG8gdGhpcyBtYXRyaXggXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzY2FsZVooX2J5OiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy5zY2FsZShuZXcgVmVjdG9yMygxLCAxLCBfYnkpKTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2Zvcm1hdGlvblxyXG4gICAgLyoqXHJcbiAgICAgKiBNdWx0aXBseSB0aGlzIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgcHVibGljIG11bHRpcGx5KF9tYXRyaXg6IE1hdHJpeDR4NCwgX2Zyb21MZWZ0OiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcclxuICAgICAgY29uc3QgbWF0cml4OiBNYXRyaXg0eDQgPSBfZnJvbUxlZnQgPyBNYXRyaXg0eDQuTVVMVElQTElDQVRJT04oX21hdHJpeCwgdGhpcykgOiBNYXRyaXg0eDQuTVVMVElQTElDQVRJT04odGhpcywgX21hdHJpeCk7XHJcbiAgICAgIHRoaXMuc2V0KG1hdHJpeCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG1hdHJpeCk7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyBhbmQgcmV0dXJucyB0aGUgZXVsZXItYW5nbGVzIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCByb3RhdGlvbiBvZiB0aGlzIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0RXVsZXJBbmdsZXMoKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCBzY2FsaW5nOiBWZWN0b3IzID0gdGhpcy5zY2FsaW5nO1xyXG5cclxuICAgICAgbGV0IHMwOiBudW1iZXIgPSB0aGlzLmRhdGFbMF0gLyBzY2FsaW5nLng7XHJcbiAgICAgIGxldCBzMTogbnVtYmVyID0gdGhpcy5kYXRhWzFdIC8gc2NhbGluZy54O1xyXG4gICAgICBsZXQgczI6IG51bWJlciA9IHRoaXMuZGF0YVsyXSAvIHNjYWxpbmcueDtcclxuICAgICAgbGV0IHM2OiBudW1iZXIgPSB0aGlzLmRhdGFbNl0gLyBzY2FsaW5nLnk7XHJcbiAgICAgIGxldCBzMTA6IG51bWJlciA9IHRoaXMuZGF0YVsxMF0gLyBzY2FsaW5nLno7XHJcblxyXG4gICAgICBsZXQgc3k6IG51bWJlciA9IE1hdGguaHlwb3QoczAsIHMxKTsgLy8gcHJvYmFibHkgMi4gcGFyYW0gc2hvdWxkIGJlIHRoaXMuZGF0YVs0XSAvIHNjYWxpbmcueVxyXG5cclxuICAgICAgbGV0IHNpbmd1bGFyOiBib29sZWFuID0gc3kgPCAxZS02OyAvLyBJZlxyXG5cclxuICAgICAgbGV0IHgxOiBudW1iZXIsIHkxOiBudW1iZXIsIHoxOiBudW1iZXI7XHJcbiAgICAgIGxldCB4MjogbnVtYmVyLCB5MjogbnVtYmVyLCB6MjogbnVtYmVyO1xyXG5cclxuICAgICAgaWYgKCFzaW5ndWxhcikge1xyXG4gICAgICAgIHgxID0gTWF0aC5hdGFuMihzNiwgczEwKTtcclxuICAgICAgICB5MSA9IE1hdGguYXRhbjIoLXMyLCBzeSk7XHJcbiAgICAgICAgejEgPSBNYXRoLmF0YW4yKHMxLCBzMCk7XHJcblxyXG4gICAgICAgIHgyID0gTWF0aC5hdGFuMigtczYsIC1zMTApO1xyXG4gICAgICAgIHkyID0gTWF0aC5hdGFuMigtczIsIC1zeSk7XHJcbiAgICAgICAgejIgPSBNYXRoLmF0YW4yKC1zMSwgLXMwKTtcclxuXHJcbiAgICAgICAgaWYgKE1hdGguYWJzKHgyKSArIE1hdGguYWJzKHkyKSArIE1hdGguYWJzKHoyKSA8IE1hdGguYWJzKHgxKSArIE1hdGguYWJzKHkxKSArIE1hdGguYWJzKHoxKSkge1xyXG4gICAgICAgICAgeDEgPSB4MjtcclxuICAgICAgICAgIHkxID0geTI7XHJcbiAgICAgICAgICB6MSA9IHoyO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICB4MSA9IE1hdGguYXRhbjIoLXRoaXMuZGF0YVs5XSAvIHNjYWxpbmcueiwgdGhpcy5kYXRhWzVdIC8gc2NhbGluZy55KTtcclxuICAgICAgICB5MSA9IE1hdGguYXRhbjIoLXRoaXMuZGF0YVsyXSAvIHNjYWxpbmcueCwgc3kpO1xyXG4gICAgICAgIHoxID0gMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IHJvdGF0aW9uOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoeDEsIHkxLCB6MSk7XHJcbiAgICAgIHJvdGF0aW9uLnNjYWxlKDE4MCAvIE1hdGguUEkpO1xyXG5cclxuICAgICAgcmV0dXJuIHJvdGF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgZWxlbWVudHMgb2YgdGhpcyBtYXRyaXggdG8gdGhlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQoX3RvOiBNYXRyaXg0eDQpOiB2b2lkIHtcclxuICAgICAgLy8gdGhpcy5kYXRhID0gX3RvLmdldCgpO1xyXG4gICAgICB0aGlzLmRhdGEuc2V0KF90by5kYXRhKTtcclxuICAgICAgdGhpcy5yZXNldENhY2hlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiBgxpIuTWF0cml4NHg0KHRyYW5zbGF0aW9uOiAke3RoaXMudHJhbnNsYXRpb24udG9TdHJpbmcoKX0sIHJvdGF0aW9uOiAke3RoaXMucm90YXRpb24udG9TdHJpbmcoKX0sIHNjYWxpbmc6ICR7dGhpcy5zY2FsaW5nLnRvU3RyaW5nKCl9YDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgZWxlbWVudHMgb2YgdGhpcyBtYXRyaXggYXMgYSBGbG9hdDMyQXJyYXlcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCgpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIC8vIFRPRE86IHNhdmUgdHJhbnNsYXRpb24sIHJvdGF0aW9uIGFuZCBzY2FsZSBhcyB2ZWN0b3JzIGZvciByZWFkYWJpbGl0eSBhbmQgbWFuaXB1bGF0aW9uXHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gdGhpcy5nZXRNdXRhdG9yKCk7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogU2VyaWFsaXphYmxlIHtcclxuICAgICAgdGhpcy5tdXRhdGUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcclxuICAgICAgaWYgKHRoaXMubXV0YXRvcilcclxuICAgICAgICByZXR1cm4gdGhpcy5tdXRhdG9yO1xyXG5cclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSB7XHJcbiAgICAgICAgdHJhbnNsYXRpb246IHRoaXMudHJhbnNsYXRpb24uZ2V0TXV0YXRvcigpLFxyXG4gICAgICAgIHJvdGF0aW9uOiB0aGlzLnJvdGF0aW9uLmdldE11dGF0b3IoKSxcclxuICAgICAgICBzY2FsaW5nOiB0aGlzLnNjYWxpbmcuZ2V0TXV0YXRvcigpXHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBjYWNoZSBtdXRhdG9yXHJcbiAgICAgIHRoaXMubXV0YXRvciA9IG11dGF0b3I7XHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgbGV0IG9sZFRyYW5zbGF0aW9uOiBWZWN0b3IzID0gdGhpcy50cmFuc2xhdGlvbjtcclxuICAgICAgbGV0IG9sZFJvdGF0aW9uOiBWZWN0b3IzID0gdGhpcy5yb3RhdGlvbjtcclxuICAgICAgbGV0IG9sZFNjYWxpbmc6IFZlY3RvcjMgPSB0aGlzLnNjYWxpbmc7XHJcbiAgICAgIGxldCBuZXdUcmFuc2xhdGlvbjogVmVjdG9yMyA9IDxWZWN0b3IzPl9tdXRhdG9yW1widHJhbnNsYXRpb25cIl07XHJcbiAgICAgIGxldCBuZXdSb3RhdGlvbjogVmVjdG9yMyA9IDxWZWN0b3IzPl9tdXRhdG9yW1wicm90YXRpb25cIl07XHJcbiAgICAgIGxldCBuZXdTY2FsaW5nOiBWZWN0b3IzID0gPFZlY3RvcjM+X211dGF0b3JbXCJzY2FsaW5nXCJdO1xyXG4gICAgICBsZXQgdmVjdG9yczogVmVjdG9yUmVwcmVzZW50YXRpb24gPSB7IHRyYW5zbGF0aW9uOiBvbGRUcmFuc2xhdGlvbiwgcm90YXRpb246IG9sZFJvdGF0aW9uLCBzY2FsaW5nOiBvbGRTY2FsaW5nIH07XHJcbiAgICAgIGlmIChuZXdUcmFuc2xhdGlvbikge1xyXG4gICAgICAgIHZlY3RvcnMudHJhbnNsYXRpb24gPSBuZXcgVmVjdG9yMyhcclxuICAgICAgICAgIG5ld1RyYW5zbGF0aW9uLnggIT0gdW5kZWZpbmVkID8gbmV3VHJhbnNsYXRpb24ueCA6IG9sZFRyYW5zbGF0aW9uLngsXHJcbiAgICAgICAgICBuZXdUcmFuc2xhdGlvbi55ICE9IHVuZGVmaW5lZCA/IG5ld1RyYW5zbGF0aW9uLnkgOiBvbGRUcmFuc2xhdGlvbi55LFxyXG4gICAgICAgICAgbmV3VHJhbnNsYXRpb24ueiAhPSB1bmRlZmluZWQgPyBuZXdUcmFuc2xhdGlvbi56IDogb2xkVHJhbnNsYXRpb24uelxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG5ld1JvdGF0aW9uKSB7XHJcbiAgICAgICAgdmVjdG9ycy5yb3RhdGlvbiA9IG5ldyBWZWN0b3IzKFxyXG4gICAgICAgICAgbmV3Um90YXRpb24ueCAhPSB1bmRlZmluZWQgPyBuZXdSb3RhdGlvbi54IDogb2xkUm90YXRpb24ueCxcclxuICAgICAgICAgIG5ld1JvdGF0aW9uLnkgIT0gdW5kZWZpbmVkID8gbmV3Um90YXRpb24ueSA6IG9sZFJvdGF0aW9uLnksXHJcbiAgICAgICAgICBuZXdSb3RhdGlvbi56ICE9IHVuZGVmaW5lZCA/IG5ld1JvdGF0aW9uLnogOiBvbGRSb3RhdGlvbi56XHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAobmV3U2NhbGluZykge1xyXG4gICAgICAgIHZlY3RvcnMuc2NhbGluZyA9IG5ldyBWZWN0b3IzKFxyXG4gICAgICAgICAgbmV3U2NhbGluZy54ICE9IHVuZGVmaW5lZCA/IG5ld1NjYWxpbmcueCA6IG9sZFNjYWxpbmcueCxcclxuICAgICAgICAgIG5ld1NjYWxpbmcueSAhPSB1bmRlZmluZWQgPyBuZXdTY2FsaW5nLnkgOiBvbGRTY2FsaW5nLnksXHJcbiAgICAgICAgICBuZXdTY2FsaW5nLnogIT0gdW5kZWZpbmVkID8gbmV3U2NhbGluZy56IDogb2xkU2NhbGluZy56XHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVE9ETzogcG9zc2libGUgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIHdoZW4gb25seSBvbmUgb3IgdHdvIGNvbXBvbmVudHMgY2hhbmdlLCB0aGVuIHVzZSBvbGQgbWF0cml4IGluc3RlYWQgb2YgSURFTlRJVFkgYW5kIHRyYW5zZm9ybSBieSBkaWZmZXJlbmNlcy9xdW90aWVudHNcclxuICAgICAgbGV0IG1hdHJpeDogTWF0cml4NHg0ID0gTWF0cml4NHg0LklERU5USVRZKCk7XHJcbiAgICAgIGlmICh2ZWN0b3JzLnRyYW5zbGF0aW9uKVxyXG4gICAgICAgIG1hdHJpeC50cmFuc2xhdGUodmVjdG9ycy50cmFuc2xhdGlvbik7XHJcbiAgICAgIGlmICh2ZWN0b3JzLnJvdGF0aW9uKSB7XHJcbiAgICAgICAgbWF0cml4LnJvdGF0ZVoodmVjdG9ycy5yb3RhdGlvbi56KTtcclxuICAgICAgICBtYXRyaXgucm90YXRlWSh2ZWN0b3JzLnJvdGF0aW9uLnkpO1xyXG4gICAgICAgIG1hdHJpeC5yb3RhdGVYKHZlY3RvcnMucm90YXRpb24ueCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHZlY3RvcnMuc2NhbGluZylcclxuICAgICAgICBtYXRyaXguc2NhbGUodmVjdG9ycy5zY2FsaW5nKTtcclxuICAgICAgdGhpcy5zZXQobWF0cml4KTtcclxuXHJcbiAgICAgIHRoaXMudmVjdG9ycyA9IHZlY3RvcnM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3JBdHRyaWJ1dGVUeXBlcyhfbXV0YXRvcjogTXV0YXRvcik6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyB7XHJcbiAgICAgIGxldCB0eXBlczogTXV0YXRvckF0dHJpYnV0ZVR5cGVzID0ge307XHJcbiAgICAgIGlmIChfbXV0YXRvci50cmFuc2xhdGlvbikgdHlwZXMudHJhbnNsYXRpb24gPSBcIlZlY3RvcjNcIjtcclxuICAgICAgaWYgKF9tdXRhdG9yLnJvdGF0aW9uKSB0eXBlcy5yb3RhdGlvbiA9IFwiVmVjdG9yM1wiO1xyXG4gICAgICBpZiAoX211dGF0b3Iuc2NhbGluZykgdHlwZXMuc2NhbGluZyA9IFwiVmVjdG9yM1wiO1xyXG4gICAgICByZXR1cm4gdHlwZXM7XHJcbiAgICB9XHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQgey8qKiAqLyB9XHJcblxyXG4gICAgcHJpdmF0ZSByZXNldENhY2hlKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLnZlY3RvcnMgPSB7IHRyYW5zbGF0aW9uOiBudWxsLCByb3RhdGlvbjogbnVsbCwgc2NhbGluZzogbnVsbCB9O1xyXG4gICAgICB0aGlzLm11dGF0b3IgPSBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuICAvLyNlbmRyZWdpb25cclxufVxyXG4iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBDbGFzcyBmb3IgY3JlYXRpbmcgcmFuZG9tIHZhbHVlcywgc3VwcG9ydGluZyBKYXZhc2NyaXB0J3MgTWF0aC5yYW5kb20gYW5kIGEgZGV0ZXJtaW5pc3RpZyBwc2V1ZG8tcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgKFBSTkcpIFxyXG4gICAqIHRoYXQgY2FuIGJlIGZlZCB3aXRoIGEgc2VlZCBhbmQgdGhlbiByZXR1cm5zIGEgcmVwcm9kdWNhYmxlIHNldCBvZiByYW5kb20gbnVtYmVycyAoaWYgdGhlIHByZWNpc2lvbiBvZiBKYXZhc2NyaXB0IGFsbG93cykgXHJcbiAgICogXHJcbiAgICogQGF1dGhvciBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBSYW5kb20ge1xyXG4gICAgcHVibGljIHN0YXRpYyBkZWZhdWx0OiBSYW5kb20gPSBuZXcgUmFuZG9tKCk7XHJcbiAgICBwcml2YXRlIGdlbmVyYXRlOiBGdW5jdGlvbiA9IE1hdGgucmFuZG9tO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIFtbUmFuZG9tXV0uIElmIGRlc2lyZWQsIGNyZWF0ZXMgYSBQUk5HIHdpdGggaXQgYW5kIGZlZWRzIHRoZSBnaXZlbiBzZWVkLlxyXG4gICAgICogQHBhcmFtIF9vd25HZW5lcmF0b3JcclxuICAgICAqIEBwYXJhbSBfc2VlZCBcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoX293bkdlbmVyYXRvcjogYm9vbGVhbiA9IGZhbHNlLCBfc2VlZDogbnVtYmVyID0gTWF0aC5yYW5kb20oKSkge1xyXG4gICAgICBpZiAoX293bkdlbmVyYXRvcilcclxuICAgICAgICB0aGlzLmdlbmVyYXRlID0gUmFuZG9tLmNyZWF0ZUdlbmVyYXRvcihfc2VlZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgZGVyZXJtaW5zdGljIFBSTkcgd2l0aCB0aGUgZ2l2ZW4gc2VlZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGNyZWF0ZUdlbmVyYXRvcihfc2VlZDogbnVtYmVyKTogRnVuY3Rpb24ge1xyXG4gICAgICAvLyBUT0RPOiByZXBsYWNlIHdpdGggcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgdG8gZ2VuZXJhdGUgcHJlZGljdGFibGUgc2VxdWVuY2VcclxuICAgICAgcmV0dXJuIE1hdGgucmFuZG9tO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG5vcm1lZCByYW5kb20gbnVtYmVyLCB0aHVzIGluIHRoZSByYW5nZSBvZiBbMCwgMVtcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldE5vcm0oKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSByYW5kb20gbnVtYmVyIGluIHRoZSByYW5nZSBvZiBnaXZlbiBbX21pbiwgX21heFtcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFJhbmdlKF9taW46IG51bWJlciwgX21heDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIF9taW4gKyB0aGlzLmdlbmVyYXRlKCkgKiAoX21heCAtIF9taW4pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHJhbmRvbSBpbnRlZ2VyIG51bWJlciBpbiB0aGUgcmFuZ2Ugb2YgZ2l2ZW4gZmxvb3JlZCBbX21pbiwgX21heFtcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFJhbmdlRmxvb3JlZChfbWluOiBudW1iZXIsIF9tYXg6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMuZ2V0UmFuZ2UoX21pbiwgX21heCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIG9yIGZhbHNlIHJhbmRvbWx5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRCb29sZWFuKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZSgpIDwgMC41O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyAtMSBvciAxIHJhbmRvbWx5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRTaWduKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldEJvb2xlYW4oKSA/IDEgOiAtMTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSByYW5kb21seSBzZWxlY3RlZCBpbmRleCBpbnRvIHRoZSBnaXZlbiBhcnJheVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0SW5kZXg8VD4oX2FycmF5OiBBcnJheTxUPik6IG51bWJlciB7XHJcbiAgICAgIGlmIChfYXJyYXkubGVuZ3RoID4gMClcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRSYW5nZUZsb29yZWQoMCwgX2FycmF5Lmxlbmd0aCk7XHJcbiAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgcmVtb3ZlcyBhIHJhbmRvbWx5IHNlbGVjdGVkIGVsZW1lbnQgZnJvbSB0aGUgZ2l2ZW4gYXJyYXkgYW5kIHJldHVybnMgaXRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNwbGljZTxUPihfYXJyYXk6IEFycmF5PFQ+KTogVCB7XHJcbiAgICAgIHJldHVybiBfYXJyYXkuc3BsaWNlKHRoaXMuZ2V0SW5kZXgoX2FycmF5KSwgMSlbMF07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcmFuZG9tbHkgc2VsZWN0ZWQga2V5IGZyb20gdGhlIGdpdmVuIE1hcC1pbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0S2V5PFQsIFU+KF9tYXA6IE1hcDxULCBVPik6IFQge1xyXG4gICAgICBsZXQga2V5czogR2VuZXJhbCA9IEFycmF5LmZyb20oX21hcC5rZXlzKCkpO1xyXG4gICAgICByZXR1cm4ga2V5c1t0aGlzLmdldEluZGV4KGtleXMpXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSByYW5kb21seSBzZWxlY3RlZCBwcm9wZXJ0eSBuYW1lIGZyb20gdGhlIGdpdmVuIG9iamVjdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0UHJvcGVydHlOYW1lKF9vYmplY3Q6IE9iamVjdCk6IHN0cmluZyB7XHJcbiAgICAgIGxldCBrZXlzOiBzdHJpbmdbXSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKF9vYmplY3QpO1xyXG4gICAgICByZXR1cm4ga2V5c1t0aGlzLmdldEluZGV4KGtleXMpXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSByYW5kb21seSBzZWxlY3RlZCBzeW1ib2wgZnJvbSB0aGUgZ2l2ZW4gb2JqZWN0LCBpZiBzeW1ib2xzIGFyZSB1c2VkIGFzIGtleXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFByb3BlcnR5U3ltYm9sKF9vYmplY3Q6IE9iamVjdCk6IHN5bWJvbCB7XHJcbiAgICAgIGxldCBrZXlzOiBzeW1ib2xbXSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoX29iamVjdCk7XHJcbiAgICAgIHJldHVybiBrZXlzW3RoaXMuZ2V0SW5kZXgoa2V5cyldO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhbmRhcmQgW1tSYW5kb21dXS1pbnN0YW5jZSB1c2luZyBNYXRoLnJhbmRvbSgpLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBjb25zdCByYW5kb206IFJhbmRvbSA9IG5ldyBSYW5kb20oKTtcclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIERlZmluZXMgdGhlIG9yaWdpbiBvZiBhIHJlY3RhbmdsZVxyXG4gICAqL1xyXG4gIGV4cG9ydCBlbnVtIE9SSUdJTjJEIHtcclxuICAgIFRPUExFRlQgPSAweDAwLFxyXG4gICAgVE9QQ0VOVEVSID0gMHgwMSxcclxuICAgIFRPUFJJR0hUID0gMHgwMixcclxuICAgIENFTlRFUkxFRlQgPSAweDEwLFxyXG4gICAgQ0VOVEVSID0gMHgxMSxcclxuICAgIENFTlRFUlJJR0hUID0gMHgxMixcclxuICAgIEJPVFRPTUxFRlQgPSAweDIwLFxyXG4gICAgQk9UVE9NQ0VOVEVSID0gMHgyMSxcclxuICAgIEJPVFRPTVJJR0hUID0gMHgyMlxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVmaW5lcyBhIHJlY3RhbmdsZSB3aXRoIHBvc2l0aW9uIGFuZCBzaXplIGFuZCBhZGQgY29tZm9ydGFibGUgbWV0aG9kcyB0byBpdFxyXG4gICAqIEBhdXRob3IgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgUmVjdGFuZ2xlIGV4dGVuZHMgTXV0YWJsZSB7XHJcbiAgICBwdWJsaWMgcG9zaXRpb246IFZlY3RvcjIgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMik7XHJcbiAgICBwdWJsaWMgc2l6ZTogVmVjdG9yMiA9IFJlY3ljbGVyLmdldChWZWN0b3IyKTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihfeDogbnVtYmVyID0gMCwgX3k6IG51bWJlciA9IDAsIF93aWR0aDogbnVtYmVyID0gMSwgX2hlaWdodDogbnVtYmVyID0gMSwgX29yaWdpbjogT1JJR0lOMkQgPSBPUklHSU4yRC5UT1BMRUZUKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuc2V0UG9zaXRpb25BbmRTaXplKF94LCBfeSwgX3dpZHRoLCBfaGVpZ2h0LCBfb3JpZ2luKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBuZXcgcmVjdGFuZ2xlIGNyZWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gcGFyYW1ldGVyc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIEdFVChfeDogbnVtYmVyID0gMCwgX3k6IG51bWJlciA9IDAsIF93aWR0aDogbnVtYmVyID0gMSwgX2hlaWdodDogbnVtYmVyID0gMSwgX29yaWdpbjogT1JJR0lOMkQgPSBPUklHSU4yRC5UT1BMRUZUKTogUmVjdGFuZ2xlIHtcclxuICAgICAgbGV0IHJlY3Q6IFJlY3RhbmdsZSA9IFJlY3ljbGVyLmdldChSZWN0YW5nbGUpO1xyXG4gICAgICByZWN0LnNldFBvc2l0aW9uQW5kU2l6ZShfeCwgX3ksIF93aWR0aCwgX2hlaWdodCk7XHJcbiAgICAgIHJldHVybiByZWN0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgcG9zaXRpb24gYW5kIHNpemUgb2YgdGhlIHJlY3RhbmdsZSBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIHBhcmFtZXRlcnNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFBvc2l0aW9uQW5kU2l6ZShfeDogbnVtYmVyID0gMCwgX3k6IG51bWJlciA9IDAsIF93aWR0aDogbnVtYmVyID0gMSwgX2hlaWdodDogbnVtYmVyID0gMSwgX29yaWdpbjogT1JJR0lOMkQgPSBPUklHSU4yRC5UT1BMRUZUKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuc2l6ZS5zZXQoX3dpZHRoLCBfaGVpZ2h0KTtcclxuICAgICAgc3dpdGNoIChfb3JpZ2luICYgMHgwMykge1xyXG4gICAgICAgIGNhc2UgMHgwMDogdGhpcy5wb3NpdGlvbi54ID0gX3g7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMHgwMTogdGhpcy5wb3NpdGlvbi54ID0gX3ggLSBfd2lkdGggLyAyOyBicmVhaztcclxuICAgICAgICBjYXNlIDB4MDI6IHRoaXMucG9zaXRpb24ueCA9IF94IC0gX3dpZHRoOyBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBzd2l0Y2ggKF9vcmlnaW4gJiAweDMwKSB7XHJcbiAgICAgICAgY2FzZSAweDAwOiB0aGlzLnBvc2l0aW9uLnkgPSBfeTsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAweDEwOiB0aGlzLnBvc2l0aW9uLnkgPSBfeSAtIF9oZWlnaHQgLyAyOyBicmVhaztcclxuICAgICAgICBjYXNlIDB4MjA6IHRoaXMucG9zaXRpb24ueSA9IF95IC0gX2hlaWdodDsgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcG9pbnRUb1JlY3QoX3BvaW50OiBWZWN0b3IyLCBfdGFyZ2V0OiBSZWN0YW5nbGUpOiBWZWN0b3IyIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMiA9IF9wb2ludC5jb3B5O1xyXG4gICAgICByZXN1bHQuc3VidHJhY3QodGhpcy5wb3NpdGlvbik7XHJcbiAgICAgIHJlc3VsdC54ICo9IF90YXJnZXQud2lkdGggLyB0aGlzLndpZHRoO1xyXG4gICAgICByZXN1bHQueSAqPSBfdGFyZ2V0LmhlaWdodCAvIHRoaXMuaGVpZ2h0O1xyXG4gICAgICByZXN1bHQuYWRkKF90YXJnZXQucG9zaXRpb24pO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIGdldCB4KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLng7XHJcbiAgICB9XHJcbiAgICBnZXQgeSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi55O1xyXG4gICAgfVxyXG4gICAgZ2V0IHdpZHRoKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNpemUueDtcclxuICAgIH1cclxuICAgIGdldCBoZWlnaHQoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc2l6ZS55O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBsZWZ0bW9zdCBleHBhbnNpb24sIHJlc3BlY3RpbmcgYWxzbyBuZWdhdGl2ZSB2YWx1ZXMgb2Ygd2lkdGhcclxuICAgICAqL1xyXG4gICAgZ2V0IGxlZnQoKTogbnVtYmVyIHtcclxuICAgICAgaWYgKHRoaXMuc2l6ZS54ID4gMClcclxuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi54O1xyXG4gICAgICByZXR1cm4gKHRoaXMucG9zaXRpb24ueCArIHRoaXMuc2l6ZS54KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSB0b3Btb3N0IGV4cGFuc2lvbiwgcmVzcGVjdGluZyBhbHNvIG5lZ2F0aXZlIHZhbHVlcyBvZiBoZWlnaHRcclxuICAgICAqL1xyXG4gICAgZ2V0IHRvcCgpOiBudW1iZXIge1xyXG4gICAgICBpZiAodGhpcy5zaXplLnkgPiAwKVxyXG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLnk7XHJcbiAgICAgIHJldHVybiAodGhpcy5wb3NpdGlvbi55ICsgdGhpcy5zaXplLnkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIHJpZ2h0bW9zdCBleHBhbnNpb24sIHJlc3BlY3RpbmcgYWxzbyBuZWdhdGl2ZSB2YWx1ZXMgb2Ygd2lkdGhcclxuICAgICAqL1xyXG4gICAgZ2V0IHJpZ2h0KCk6IG51bWJlciB7XHJcbiAgICAgIGlmICh0aGlzLnNpemUueCA+IDApXHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnBvc2l0aW9uLnggKyB0aGlzLnNpemUueCk7XHJcbiAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLng7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgbG93ZXN0IGV4cGFuc2lvbiwgcmVzcGVjdGluZyBhbHNvIG5lZ2F0aXZlIHZhbHVlcyBvZiBoZWlnaHRcclxuICAgICAqL1xyXG4gICAgZ2V0IGJvdHRvbSgpOiBudW1iZXIge1xyXG4gICAgICBpZiAodGhpcy5zaXplLnkgPiAwKVxyXG4gICAgICAgIHJldHVybiAodGhpcy5wb3NpdGlvbi55ICsgdGhpcy5zaXplLnkpO1xyXG4gICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi55O1xyXG4gICAgfVxyXG5cclxuICAgIHNldCB4KF94OiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5wb3NpdGlvbi54ID0gX3g7XHJcbiAgICB9XHJcbiAgICBzZXQgeShfeTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMucG9zaXRpb24ueSA9IF95O1xyXG4gICAgfVxyXG4gICAgc2V0IHdpZHRoKF93aWR0aDogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMucG9zaXRpb24ueCA9IF93aWR0aDtcclxuICAgIH1cclxuICAgIHNldCBoZWlnaHQoX2hlaWdodDogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMucG9zaXRpb24ueSA9IF9oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICBzZXQgbGVmdChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLnNpemUueCA9IHRoaXMucmlnaHQgLSBfdmFsdWU7XHJcbiAgICAgIHRoaXMucG9zaXRpb24ueCA9IF92YWx1ZTtcclxuICAgIH1cclxuICAgIHNldCB0b3AoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5zaXplLnkgPSB0aGlzLmJvdHRvbSAtIF92YWx1ZTtcclxuICAgICAgdGhpcy5wb3NpdGlvbi55ID0gX3ZhbHVlO1xyXG4gICAgfVxyXG4gICAgc2V0IHJpZ2h0KF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuc2l6ZS54ID0gdGhpcy5wb3NpdGlvbi54ICsgX3ZhbHVlO1xyXG4gICAgfVxyXG4gICAgc2V0IGJvdHRvbShfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLnNpemUueSA9IHRoaXMucG9zaXRpb24ueSArIF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGNvcHkoKTogUmVjdGFuZ2xlIHtcclxuICAgICAgcmV0dXJuIFJlY3RhbmdsZS5HRVQodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gcG9pbnQgaXMgaW5zaWRlIG9mIHRoaXMgcmVjdGFuZ2xlIG9yIG9uIHRoZSBib3JkZXJcclxuICAgICAqIEBwYXJhbSBfcG9pbnRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGlzSW5zaWRlKF9wb2ludDogVmVjdG9yMik6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gKF9wb2ludC54ID49IHRoaXMubGVmdCAmJiBfcG9pbnQueCA8PSB0aGlzLnJpZ2h0ICYmIF9wb2ludC55ID49IHRoaXMudG9wICYmIF9wb2ludC55IDw9IHRoaXMuYm90dG9tKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgY29sbGlkZXMoX3JlY3Q6IFJlY3RhbmdsZSk6IGJvb2xlYW4ge1xyXG4gICAgICBpZiAodGhpcy5sZWZ0ID4gX3JlY3QucmlnaHQpIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKHRoaXMucmlnaHQgPCBfcmVjdC5sZWZ0KSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmICh0aGlzLnRvcCA+IF9yZWN0LmJvdHRvbSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAodGhpcy5ib3R0b20gPCBfcmVjdC50b3ApIHJldHVybiBmYWxzZTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgIGxldCByZXN1bHQ6IHN0cmluZyA9IGDGki5SZWN0YW5nbGUocG9zaXRpb246JHt0aGlzLnBvc2l0aW9uLnRvU3RyaW5nKCl9LCBzaXplOiR7dGhpcy5zaXplLnRvU3RyaW5nKCl9YDtcclxuICAgICAgcmVzdWx0ICs9IGAsIGxlZnQ6JHt0aGlzLmxlZnQudG9QcmVjaXNpb24oNSl9LCB0b3A6JHt0aGlzLnRvcC50b1ByZWNpc2lvbig1KX0sIHJpZ2h0OiR7dGhpcy5yaWdodC50b1ByZWNpc2lvbig1KX0sIGJvdHRvbToke3RoaXMuYm90dG9tLnRvUHJlY2lzaW9uKDUpfWA7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHsvKiAqLyB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogU3RvcmVzIGFuZCBtYW5pcHVsYXRlcyBhIHR3b2RpbWVuc2lvbmFsIHZlY3RvciBjb21wcmlzZWQgb2YgdGhlIGNvbXBvbmVudHMgeCBhbmQgeVxyXG4gICAqIGBgYHBsYWludGV4dFxyXG4gICAqICAgICAgICAgICAgK3lcclxuICAgKiAgICAgICAgICAgICB8X18gK3hcclxuICAgKiBgYGBcclxuICAgKiBAYXV0aG9ycyBMdWthcyBTY2hldWVybGUsIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFZlY3RvcjIgZXh0ZW5kcyBNdXRhYmxlIHtcclxuICAgIHByaXZhdGUgZGF0YTogRmxvYXQzMkFycmF5O1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfeDogbnVtYmVyID0gMCwgX3k6IG51bWJlciA9IDApIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShbX3gsIF95XSk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHgoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZGF0YVswXTtcclxuICAgIH1cclxuICAgIGdldCB5KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmRhdGFbMV07XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IHgoX3g6IG51bWJlcikge1xyXG4gICAgICB0aGlzLmRhdGFbMF0gPSBfeDtcclxuICAgIH1cclxuICAgIHNldCB5KF95OiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5kYXRhWzFdID0gX3k7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBnZXQgbWFnbml0dWRlKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiBNYXRoLmh5cG90KC4uLnRoaXMuZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzcXVhcmUgb2YgdGhlIG1hZ25pdHVkZSBvZiB0aGUgdmVjdG9yIHdpdGhvdXQgY2FsY3VsYXRpbmcgYSBzcXVhcmUgcm9vdC4gRmFzdGVyIGZvciBzaW1wbGUgcHJveGltaXR5IGV2YWx1YXRpb24uXHJcbiAgICAgKi9cclxuICAgIGdldCBtYWduaXR1ZGVTcXVhcmVkKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiBWZWN0b3IyLkRPVCh0aGlzLCB0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBBIHNob3J0aGFuZCBmb3Igd3JpdGluZyBgbmV3IFZlY3RvcjIoMCwgMClgLlxyXG4gICAgICogQHJldHVybnMgQSBuZXcgdmVjdG9yIHdpdGggdGhlIHZhbHVlcyAoMCwgMClcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBaRVJPKCk6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgdmVjdG9yOiBWZWN0b3IyID0gbmV3IFZlY3RvcjIoKTtcclxuICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBBIHNob3J0aGFuZCBmb3Igd3JpdGluZyBgbmV3IFZlY3RvcjIoX3NjYWxlLCBfc2NhbGUpYC5cclxuICAgICAqIEBwYXJhbSBfc2NhbGUgdGhlIHNjYWxlIG9mIHRoZSB2ZWN0b3IuIERlZmF1bHQ6IDFcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBPTkUoX3NjYWxlOiBudW1iZXIgPSAxKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCB2ZWN0b3I6IFZlY3RvcjIgPSBuZXcgVmVjdG9yMihfc2NhbGUsIF9zY2FsZSk7XHJcbiAgICAgIHJldHVybiB2ZWN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQSBzaG9ydGhhbmQgZm9yIHdyaXRpbmcgYG5ldyBWZWN0b3IyKDAsIHkpYC5cclxuICAgICAqIEBwYXJhbSBfc2NhbGUgVGhlIG51bWJlciB0byB3cml0ZSBpbiB0aGUgeSBjb29yZGluYXRlLiBEZWZhdWx0OiAxXHJcbiAgICAgKiBAcmV0dXJucyBBIG5ldyB2ZWN0b3Igd2l0aCB0aGUgdmFsdWVzICgwLCBfc2NhbGUpXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgWShfc2NhbGU6IG51bWJlciA9IDEpOiBWZWN0b3IyIHtcclxuICAgICAgbGV0IHZlY3RvcjogVmVjdG9yMiA9IG5ldyBWZWN0b3IyKDAsIF9zY2FsZSk7XHJcbiAgICAgIHJldHVybiB2ZWN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQSBzaG9ydGhhbmQgZm9yIHdyaXRpbmcgYG5ldyBWZWN0b3IyKHgsIDApYC5cclxuICAgICAqIEBwYXJhbSBfc2NhbGUgVGhlIG51bWJlciB0byB3cml0ZSBpbiB0aGUgeCBjb29yZGluYXRlLiBEZWZhdWx0OiAxXHJcbiAgICAgKiBAcmV0dXJucyBBIG5ldyB2ZWN0b3Igd2l0aCB0aGUgdmFsdWVzIChfc2NhbGUsIDApXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgWChfc2NhbGU6IG51bWJlciA9IDEpOiBWZWN0b3IyIHtcclxuICAgICAgbGV0IHZlY3RvcjogVmVjdG9yMiA9IG5ldyBWZWN0b3IyKF9zY2FsZSwgMCk7XHJcbiAgICAgIHJldHVybiB2ZWN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBUUkFOU0ZPUk1BVElPTihfdmVjdG9yOiBWZWN0b3IyLCBfbWF0cml4OiBNYXRyaXgzeDMsIF9pbmNsdWRlVHJhbnNsYXRpb246IGJvb2xlYW4gPSB0cnVlKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjIgPSBuZXcgVmVjdG9yMigpO1xyXG4gICAgICBsZXQgbTogRmxvYXQzMkFycmF5ID0gX21hdHJpeC5nZXQoKTtcclxuICAgICAgbGV0IFt4LCB5XSA9IF92ZWN0b3IuZ2V0KCk7XHJcbiAgICAgIHJlc3VsdC54ID0gbVswXSAqIHggKyBtWzNdICogeTtcclxuICAgICAgcmVzdWx0LnkgPSBtWzFdICogeCArIG1bNF0gKiB5O1xyXG5cclxuICAgICAgaWYgKF9pbmNsdWRlVHJhbnNsYXRpb24pIHtcclxuICAgICAgICByZXN1bHQuYWRkKF9tYXRyaXgudHJhbnNsYXRpb24pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTm9ybWFsaXplcyBhIGdpdmVuIHZlY3RvciB0byB0aGUgZ2l2ZW4gbGVuZ3RoIHdpdGhvdXQgZWRpdGluZyB0aGUgb3JpZ2luYWwgdmVjdG9yLlxyXG4gICAgICogQHBhcmFtIF92ZWN0b3IgdGhlIHZlY3RvciB0byBub3JtYWxpemVcclxuICAgICAqIEBwYXJhbSBfbGVuZ3RoIHRoZSBsZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIGRlZmF1bHRzIHRvIDFcclxuICAgICAqIEByZXR1cm5zIGEgbmV3IHZlY3RvciByZXByZXNlbnRpbmcgdGhlIG5vcm1hbGlzZWQgdmVjdG9yIHNjYWxlZCBieSB0aGUgZ2l2ZW4gbGVuZ3RoXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgTk9STUFMSVpBVElPTihfdmVjdG9yOiBWZWN0b3IyLCBfbGVuZ3RoOiBudW1iZXIgPSAxKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCB2ZWN0b3I6IFZlY3RvcjIgPSBWZWN0b3IyLlpFUk8oKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBsZXQgW3gsIHldID0gX3ZlY3Rvci5kYXRhO1xyXG4gICAgICAgIGxldCBmYWN0b3I6IG51bWJlciA9IF9sZW5ndGggLyBNYXRoLmh5cG90KHgsIHkpO1xyXG4gICAgICAgIHZlY3Rvci5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShbX3ZlY3Rvci54ICogZmFjdG9yLCBfdmVjdG9yLnkgKiBmYWN0b3JdKTtcclxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XHJcbiAgICAgICAgRGVidWcuZnVkZ2UoX2Vycm9yKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2NhbGVzIGEgZ2l2ZW4gdmVjdG9yIGJ5IGEgZ2l2ZW4gc2NhbGUgd2l0aG91dCBjaGFuZ2luZyB0aGUgb3JpZ2luYWwgdmVjdG9yXHJcbiAgICAgKiBAcGFyYW0gX3ZlY3RvciBUaGUgdmVjdG9yIHRvIHNjYWxlLlxyXG4gICAgICogQHBhcmFtIF9zY2FsZSBUaGUgc2NhbGUgdG8gc2NhbGUgd2l0aC5cclxuICAgICAqIEByZXR1cm5zIEEgbmV3IHZlY3RvciByZXByZXNlbnRpbmcgdGhlIHNjYWxlZCB2ZXJzaW9uIG9mIHRoZSBnaXZlbiB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBTQ0FMRShfdmVjdG9yOiBWZWN0b3IyLCBfc2NhbGU6IG51bWJlcik6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgdmVjdG9yOiBWZWN0b3IyID0gbmV3IFZlY3RvcjIoX3ZlY3Rvci54ICogX3NjYWxlLCBfdmVjdG9yLnkgKiBfc2NhbGUpO1xyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3VtcyB1cCBtdWx0aXBsZSB2ZWN0b3JzLlxyXG4gICAgICogQHBhcmFtIF92ZWN0b3JzIEEgc2VyaWVzIG9mIHZlY3RvcnMgdG8gc3VtIHVwXHJcbiAgICAgKiBAcmV0dXJucyBBIG5ldyB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBzdW0gb2YgdGhlIGdpdmVuIHZlY3RvcnNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBTVU0oLi4uX3ZlY3RvcnM6IFZlY3RvcjJbXSk6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IyID0gbmV3IFZlY3RvcjIoKTtcclxuICAgICAgZm9yIChsZXQgdmVjdG9yIG9mIF92ZWN0b3JzKVxyXG4gICAgICAgIHJlc3VsdC5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShbcmVzdWx0LnggKyB2ZWN0b3IueCwgcmVzdWx0LnkgKyB2ZWN0b3IueV0pO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3VidHJhY3RzIHR3byB2ZWN0b3JzLlxyXG4gICAgICogQHBhcmFtIF9hIFRoZSB2ZWN0b3IgdG8gc3VidHJhY3QgZnJvbS5cclxuICAgICAqIEBwYXJhbSBfYiBUaGUgdmVjdG9yIHRvIHN1YnRyYWN0LlxyXG4gICAgICogQHJldHVybnMgQSBuZXcgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgZGlmZmVyZW5jZSBvZiB0aGUgZ2l2ZW4gdmVjdG9yc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIERJRkZFUkVOQ0UoX2E6IFZlY3RvcjIsIF9iOiBWZWN0b3IyKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCB2ZWN0b3I6IFZlY3RvcjIgPSBuZXcgVmVjdG9yMjtcclxuICAgICAgdmVjdG9yLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KFtfYS54IC0gX2IueCwgX2EueSAtIF9iLnldKTtcclxuICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIHRoZSBkb3Rwcm9kdWN0IG9mIDIgdmVjdG9ycy5cclxuICAgICAqIEBwYXJhbSBfYSBUaGUgdmVjdG9yIHRvIG11bHRpcGx5LlxyXG4gICAgICogQHBhcmFtIF9iIFRoZSB2ZWN0b3IgdG8gbXVsdGlwbHkgYnkuXHJcbiAgICAgKiBAcmV0dXJucyBBIG5ldyB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBkb3Rwcm9kdWN0IG9mIHRoZSBnaXZlbiB2ZWN0b3JzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgRE9UKF9hOiBWZWN0b3IyLCBfYjogVmVjdG9yMik6IG51bWJlciB7XHJcbiAgICAgIGxldCBzY2FsYXJQcm9kdWN0OiBudW1iZXIgPSBfYS54ICogX2IueCArIF9hLnkgKiBfYi55O1xyXG4gICAgICByZXR1cm4gc2NhbGFyUHJvZHVjdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIFZlY3RvcnMuIER1ZSB0byB0aGVtIGJlaW5nIG9ubHkgMiBEaW1lbnNpb25hbCwgdGhlIHJlc3VsdCBpcyBhIHNpbmdsZSBudW1iZXIsXHJcbiAgICAgKiB3aGljaCBpbXBsaWNpdGx5IGlzIG9uIHRoZSBaIGF4aXMuIEl0IGlzIGFsc28gdGhlIHNpZ25lZCBtYWduaXR1ZGUgb2YgdGhlIHJlc3VsdC5cclxuICAgICAqIEBwYXJhbSBfYSBWZWN0b3IgdG8gY29tcHV0ZSB0aGUgY3Jvc3MgcHJvZHVjdCBvblxyXG4gICAgICogQHBhcmFtIF9iIFZlY3RvciB0byBjb21wdXRlIHRoZSBjcm9zcyBwcm9kdWN0IHdpdGhcclxuICAgICAqIEByZXR1cm5zIEEgbnVtYmVyIHJlcHJlc2VudGluZyByZXN1bHQgb2YgdGhlIGNyb3NzIHByb2R1Y3QuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgQ1JPU1NQUk9EVUNUKF9hOiBWZWN0b3IyLCBfYjogVmVjdG9yMik6IG51bWJlciB7XHJcbiAgICAgIGxldCBjcm9zc1Byb2R1Y3Q6IG51bWJlciA9IF9hLnggKiBfYi55IC0gX2EueSAqIF9iLng7XHJcbiAgICAgIHJldHVybiBjcm9zc1Byb2R1Y3Q7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBvcnRob2dvbmFsIHZlY3RvciB0byB0aGUgZ2l2ZW4gdmVjdG9yLiBSb3RhdGVzIGNvdW50ZXJjbG9ja3dpc2UgYnkgZGVmYXVsdC5cclxuICAgICAqIGBgYHBsYWludGV4dFxyXG4gICAgICog4oaRID0+IOKGkCA9PiDihpMgPT4g4oaSID0+IOKGkVxyXG4gICAgICogYGBgXHJcbiAgICAgKiBAcGFyYW0gX3ZlY3RvciBWZWN0b3IgdG8gZ2V0IHRoZSBvcnRob2dvbmFsIGVxdWl2YWxlbnQgb2ZcclxuICAgICAqIEBwYXJhbSBfY2xvY2t3aXNlIFNob3VsZCB0aGUgcm90YXRpb24gYmUgY2xvY2t3aXNlIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgY291bnRlcmNsb2Nrd2lzZT8gZGVmYXVsdDogZmFsc2VcclxuICAgICAqIEByZXR1cm5zIEEgVmVjdG9yIHRoYXQgaXMgb3J0aG9nb25hbCB0byBhbmQgaGFzIHRoZSBzYW1lIG1hZ25pdHVkZSBhcyB0aGUgZ2l2ZW4gVmVjdG9yLiAgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgT1JUSE9HT05BTChfdmVjdG9yOiBWZWN0b3IyLCBfY2xvY2t3aXNlOiBib29sZWFuID0gZmFsc2UpOiBWZWN0b3IyIHtcclxuICAgICAgaWYgKF9jbG9ja3dpc2UpIHJldHVybiBuZXcgVmVjdG9yMihfdmVjdG9yLnksIC1fdmVjdG9yLngpO1xyXG4gICAgICBlbHNlIHJldHVybiBuZXcgVmVjdG9yMigtX3ZlY3Rvci55LCBfdmVjdG9yLngpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjb29yZGluYXRlcyBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gdmVjdG9yIGFyZSB0byBiZSBjb25zaWRlcmVkIGlkZW50aWNhbCB3aXRoaW4gdGhlIGdpdmVuIHRvbGVyYW5jZVxyXG4gICAgICogVE9ETzogZXhhbWluZSwgaWYgdG9sZXJhbmNlIGFzIGNyaXRlcml1bSBmb3IgdGhlIGRpZmZlcmVuY2UgaXMgYXBwcm9wcmlhdGUgd2l0aCB2ZXJ5IGxhcmdlIGNvb3JkaW5hdGUgdmFsdWVzIG9yIGlmIF90b2xlcmFuY2Ugc2hvdWxkIGJlIG11bHRpcGxpZWQgYnkgY29vcmRpbmF0ZSB2YWx1ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZXF1YWxzKF9jb21wYXJlOiBWZWN0b3IyLCBfdG9sZXJhbmNlOiBudW1iZXIgPSBOdW1iZXIuRVBTSUxPTik6IGJvb2xlYW4ge1xyXG4gICAgICBpZiAoTWF0aC5hYnModGhpcy54IC0gX2NvbXBhcmUueCkgPiBfdG9sZXJhbmNlKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmIChNYXRoLmFicyh0aGlzLnkgLSBfY29tcGFyZS55KSA+IF90b2xlcmFuY2UpIHJldHVybiBmYWxzZTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHRoZSBnaXZlbiB2ZWN0b3IgdG8gdGhlIGV4ZWN1dGluZyB2ZWN0b3IsIGNoYW5naW5nIHRoZSBleGVjdXRvci5cclxuICAgICAqIEBwYXJhbSBfYWRkZW5kIFRoZSB2ZWN0b3IgdG8gYWRkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWRkKF9hZGRlbmQ6IFZlY3RvcjIpOiB2b2lkIHtcclxuICAgICAgdGhpcy5kYXRhID0gbmV3IFZlY3RvcjIoX2FkZGVuZC54ICsgdGhpcy54LCBfYWRkZW5kLnkgKyB0aGlzLnkpLmRhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJ0cmFjdHMgdGhlIGdpdmVuIHZlY3RvciBmcm9tIHRoZSBleGVjdXRpbmcgdmVjdG9yLCBjaGFuZ2luZyB0aGUgZXhlY3V0b3IuXHJcbiAgICAgKiBAcGFyYW0gX3N1YnRyYWhlbmQgVGhlIHZlY3RvciB0byBzdWJ0cmFjdC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN1YnRyYWN0KF9zdWJ0cmFoZW5kOiBWZWN0b3IyKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuZGF0YSA9IG5ldyBWZWN0b3IyKHRoaXMueCAtIF9zdWJ0cmFoZW5kLngsIHRoaXMueSAtIF9zdWJ0cmFoZW5kLnkpLmRhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTY2FsZXMgdGhlIFZlY3RvciBieSB0aGUgX3NjYWxlLlxyXG4gICAgICogQHBhcmFtIF9zY2FsZSBUaGUgc2NhbGUgdG8gbXVsdGlwbHkgdGhlIHZlY3RvciB3aXRoLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2NhbGUoX3NjYWxlOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy5kYXRhID0gbmV3IFZlY3RvcjIoX3NjYWxlICogdGhpcy54LCBfc2NhbGUgKiB0aGlzLnkpLmRhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOb3JtYWxpemVzIHRoZSB2ZWN0b3IuXHJcbiAgICAgKiBAcGFyYW0gX2xlbmd0aCBBIG1vZGlmaWNhdG9yIHRvIGdldCBhIGRpZmZlcmVudCBsZW5ndGggb2Ygbm9ybWFsaXplZCB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBub3JtYWxpemUoX2xlbmd0aDogbnVtYmVyID0gMSk6IHZvaWQge1xyXG4gICAgICB0aGlzLmRhdGEgPSBWZWN0b3IyLk5PUk1BTElaQVRJT04odGhpcywgX2xlbmd0aCkuZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIFZlY3RvciB0byB0aGUgZ2l2ZW4gcGFyYW1ldGVycy4gT21taXR0ZWQgcGFyYW1ldGVycyBkZWZhdWx0IHRvIDAuXHJcbiAgICAgKiBAcGFyYW0gX3ggbmV3IHggdG8gc2V0XHJcbiAgICAgKiBAcGFyYW0gX3kgbmV3IHkgdG8gc2V0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQoX3g6IG51bWJlciA9IDAsIF95OiBudW1iZXIgPSAwKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoW194LCBfeV0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgdGhlIGRhdGEgb2YgdGhlIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0KCk6IEZsb2F0MzJBcnJheSB7XHJcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KHRoaXMuZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBBIGRlZXAgY29weSBvZiB0aGUgdmVjdG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGNvcHkoKTogVmVjdG9yMiB7XHJcbiAgICAgIHJldHVybiBuZXcgVmVjdG9yMih0aGlzLngsIHRoaXMueSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHRyYW5zZm9ybShfbWF0cml4OiBNYXRyaXgzeDMsIF9pbmNsdWRlVHJhbnNsYXRpb246IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuZGF0YSA9IFZlY3RvcjIuVFJBTlNGT1JNQVRJT04odGhpcywgX21hdHJpeCwgX2luY2x1ZGVUcmFuc2xhdGlvbikuZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSB6LWNvbXBvbmVudCB0byB0aGUgdmVjdG9yIGFuZCByZXR1cm5zIGEgbmV3IFZlY3RvcjNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHRvVmVjdG9yMygpOiBWZWN0b3IzIHtcclxuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKHRoaXMueCwgdGhpcy55LCAwKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuICAgICAgbGV0IHJlc3VsdDogc3RyaW5nID0gYCgke3RoaXMueC50b1ByZWNpc2lvbig1KX0sICR7dGhpcy55LnRvUHJlY2lzaW9uKDUpfSlgO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHtcclxuICAgICAgICB4OiB0aGlzLmRhdGFbMF0sIHk6IHRoaXMuZGF0YVsxXVxyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7LyoqICovIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBTdG9yZXMgYW5kIG1hbmlwdWxhdGVzIGEgdGhyZWVkaW1lbnNpb25hbCB2ZWN0b3IgY29tcHJpc2VkIG9mIHRoZSBjb21wb25lbnRzIHgsIHkgYW5kIHpcclxuICAgKiBgYGBwbGFpbnRleHRcclxuICAgKiAgICAgICAgICAgICt5XHJcbiAgICogICAgICAgICAgICAgfF9fICt4XHJcbiAgICogICAgICAgICAgICAvXHJcbiAgICogICAgICAgICAgK3ogICBcclxuICAgKiBgYGBcclxuICAgKiBAYXV0aG9ycyBKYXNjaGEgS2FyYWfDtmwsIEhGVSwgMjAxOSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFZlY3RvcjMgZXh0ZW5kcyBNdXRhYmxlIHtcclxuICAgIHByaXZhdGUgZGF0YTogRmxvYXQzMkFycmF5OyAvLyBUT0RPOiBjaGVjayB3aHkgdGhpcyBzaG91bGRuJ3QgYmUgeCx5LHogYXMgbnVtYmVycy4uLlxyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfeDogbnVtYmVyID0gMCwgX3k6IG51bWJlciA9IDAsIF96OiBudW1iZXIgPSAwKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoW194LCBfeSwgX3pdKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPOiBpbXBsZW1lbnQgZXF1YWxzLWZ1bmN0aW9uc1xyXG4gICAgZ2V0IHgoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZGF0YVswXTtcclxuICAgIH1cclxuICAgIGdldCB5KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmRhdGFbMV07XHJcbiAgICB9XHJcbiAgICBnZXQgeigpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5kYXRhWzJdO1xyXG4gICAgfVxyXG5cclxuICAgIHNldCB4KF94OiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5kYXRhWzBdID0gX3g7XHJcbiAgICB9XHJcbiAgICBzZXQgeShfeTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuZGF0YVsxXSA9IF95O1xyXG4gICAgfVxyXG4gICAgc2V0IHooX3o6IG51bWJlcikge1xyXG4gICAgICB0aGlzLmRhdGFbMl0gPSBfejtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIGdldCBtYWduaXR1ZGUoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIE1hdGguaHlwb3QoLi4udGhpcy5kYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHNxdWFyZSBvZiB0aGUgbWFnbml0dWRlIG9mIHRoZSB2ZWN0b3Igd2l0aG91dCBjYWxjdWxhdGluZyBhIHNxdWFyZSByb290LiBGYXN0ZXIgZm9yIHNpbXBsZSBwcm94aW1pdHkgZXZhbHVhdGlvbi5cclxuICAgICAqL1xyXG4gICAgZ2V0IG1hZ25pdHVkZVNxdWFyZWQoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIFZlY3RvcjMuRE9UKHRoaXMsIHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBsZW5ndGggcG9pbnRpbmcgaW4geC1kaXJlY3Rpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBYKF9zY2FsZTogbnVtYmVyID0gMSk6IFZlY3RvcjMge1xyXG4gICAgICBjb25zdCB2ZWN0b3I6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMyhfc2NhbGUsIDAsIDApO1xyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBsZW5ndGggcG9pbnRpbmcgaW4geS1kaXJlY3Rpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBZKF9zY2FsZTogbnVtYmVyID0gMSk6IFZlY3RvcjMge1xyXG4gICAgICBjb25zdCB2ZWN0b3I6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygwLCBfc2NhbGUsIDApO1xyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBsZW5ndGggcG9pbnRpbmcgaW4gei1kaXJlY3Rpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBaKF9zY2FsZTogbnVtYmVyID0gMSk6IFZlY3RvcjMge1xyXG4gICAgICBjb25zdCB2ZWN0b3I6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygwLCAwLCBfc2NhbGUpO1xyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIHZlY3RvciB3aXRoIHRoZSB2YWx1ZSAwIG9uIGVhY2ggYXhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFpFUk8oKTogVmVjdG9yMyB7XHJcbiAgICAgIGNvbnN0IHZlY3RvcjogVmVjdG9yMyA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIHZlY3RvciBvZiB0aGUgZ2l2ZW4gc2l6ZSBvbiBlYWNoIG9mIHRoZSB0aHJlZSBheGlzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgT05FKF9zY2FsZTogbnVtYmVyID0gMSk6IFZlY3RvcjMge1xyXG4gICAgICBjb25zdCB2ZWN0b3I6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMyhfc2NhbGUsIF9zY2FsZSwgX3NjYWxlKTtcclxuICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSB2ZWN0b3IgdGhyb3VnaCB0cmFuc2Zvcm1hdGlvbiBvZiB0aGUgZ2l2ZW4gdmVjdG9yIGJ5IHRoZSBnaXZlbiBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBUUkFOU0ZPUk1BVElPTihfdmVjdG9yOiBWZWN0b3IzLCBfbWF0cml4OiBNYXRyaXg0eDQsIF9pbmNsdWRlVHJhbnNsYXRpb246IGJvb2xlYW4gPSB0cnVlKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygpO1xyXG4gICAgICBsZXQgbTogRmxvYXQzMkFycmF5ID0gX21hdHJpeC5nZXQoKTtcclxuICAgICAgbGV0IFt4LCB5LCB6XSA9IF92ZWN0b3IuZ2V0KCk7XHJcbiAgICAgIHJlc3VsdC54ID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6O1xyXG4gICAgICByZXN1bHQueSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogejtcclxuICAgICAgcmVzdWx0LnogPSBtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6O1xyXG5cclxuICAgICAgaWYgKF9pbmNsdWRlVHJhbnNsYXRpb24pIHtcclxuICAgICAgICByZXN1bHQuYWRkKF9tYXRyaXgudHJhbnNsYXRpb24pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIHZlY3RvciB3aGljaCBpcyBhIGNvcHkgb2YgdGhlIGdpdmVuIHZlY3RvciBzY2FsZWQgdG8gdGhlIGdpdmVuIGxlbmd0aFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIE5PUk1BTElaQVRJT04oX3ZlY3RvcjogVmVjdG9yMywgX2xlbmd0aDogbnVtYmVyID0gMSk6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgdmVjdG9yOiBWZWN0b3IzID0gVmVjdG9yMy5aRVJPKCk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgbGV0IGZhY3RvcjogbnVtYmVyID0gX2xlbmd0aCAvIF92ZWN0b3IubWFnbml0dWRlO1xyXG4gICAgICAgIHZlY3Rvci5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShbX3ZlY3Rvci54ICogZmFjdG9yLCBfdmVjdG9yLnkgKiBmYWN0b3IsIF92ZWN0b3IueiAqIGZhY3Rvcl0pO1xyXG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcclxuICAgICAgICBEZWJ1Zy53YXJuKF9lcnJvcik7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN1bXMgdXAgbXVsdGlwbGUgdmVjdG9ycy5cclxuICAgICAqIEBwYXJhbSBfdmVjdG9ycyBBIHNlcmllcyBvZiB2ZWN0b3JzIHRvIHN1bSB1cFxyXG4gICAgICogQHJldHVybnMgQSBuZXcgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgc3VtIG9mIHRoZSBnaXZlbiB2ZWN0b3JzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgU1VNKC4uLl92ZWN0b3JzOiBWZWN0b3IzW10pOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMyA9IG5ldyBWZWN0b3IzKCk7XHJcbiAgICAgIGZvciAobGV0IHZlY3RvciBvZiBfdmVjdG9ycylcclxuICAgICAgICByZXN1bHQuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoW3Jlc3VsdC54ICsgdmVjdG9yLngsIHJlc3VsdC55ICsgdmVjdG9yLnksIHJlc3VsdC56ICsgdmVjdG9yLnpdKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3VidHJhY3RzIHR3byB2ZWN0b3JzLlxyXG4gICAgICogQHBhcmFtIF9hIFRoZSB2ZWN0b3IgdG8gc3VidHJhY3QgZnJvbS5cclxuICAgICAqIEBwYXJhbSBfYiBUaGUgdmVjdG9yIHRvIHN1YnRyYWN0LlxyXG4gICAgICogQHJldHVybnMgQSBuZXcgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgZGlmZmVyZW5jZSBvZiB0aGUgZ2l2ZW4gdmVjdG9yc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIERJRkZFUkVOQ0UoX2E6IFZlY3RvcjMsIF9iOiBWZWN0b3IzKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCB2ZWN0b3I6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMztcclxuICAgICAgdmVjdG9yLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KFtfYS54IC0gX2IueCwgX2EueSAtIF9iLnksIF9hLnogLSBfYi56XSk7XHJcbiAgICAgIHJldHVybiB2ZWN0b3I7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBuZXcgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gdmVjdG9yIHNjYWxlZCBieSB0aGUgZ2l2ZW4gc2NhbGluZyBmYWN0b3JcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBTQ0FMRShfdmVjdG9yOiBWZWN0b3IzLCBfc2NhbGluZzogbnVtYmVyKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCBzY2FsZWQ6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygpO1xyXG4gICAgICBzY2FsZWQuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoW192ZWN0b3IueCAqIF9zY2FsaW5nLCBfdmVjdG9yLnkgKiBfc2NhbGluZywgX3ZlY3Rvci56ICogX3NjYWxpbmddKTtcclxuICAgICAgcmV0dXJuIHNjYWxlZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgdGhlIGNyb3NzcHJvZHVjdCBvZiAyIHZlY3RvcnMuXHJcbiAgICAgKiBAcGFyYW0gX2EgVGhlIHZlY3RvciB0byBtdWx0aXBseS5cclxuICAgICAqIEBwYXJhbSBfYiBUaGUgdmVjdG9yIHRvIG11bHRpcGx5IGJ5LlxyXG4gICAgICogQHJldHVybnMgQSBuZXcgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgY3Jvc3Nwcm9kdWN0IG9mIHRoZSBnaXZlbiB2ZWN0b3JzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgQ1JPU1MoX2E6IFZlY3RvcjMsIF9iOiBWZWN0b3IzKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCB2ZWN0b3I6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMztcclxuICAgICAgdmVjdG9yLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KFtcclxuICAgICAgICBfYS55ICogX2IueiAtIF9hLnogKiBfYi55LFxyXG4gICAgICAgIF9hLnogKiBfYi54IC0gX2EueCAqIF9iLnosXHJcbiAgICAgICAgX2EueCAqIF9iLnkgLSBfYS55ICogX2IueF0pO1xyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyB0aGUgZG90cHJvZHVjdCBvZiAyIHZlY3RvcnMuXHJcbiAgICAgKiBAcGFyYW0gX2EgVGhlIHZlY3RvciB0byBtdWx0aXBseS5cclxuICAgICAqIEBwYXJhbSBfYiBUaGUgdmVjdG9yIHRvIG11bHRpcGx5IGJ5LlxyXG4gICAgICogQHJldHVybnMgQSBuZXcgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgZG90cHJvZHVjdCBvZiB0aGUgZ2l2ZW4gdmVjdG9yc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIERPVChfYTogVmVjdG9yMywgX2I6IFZlY3RvcjMpOiBudW1iZXIge1xyXG4gICAgICBsZXQgc2NhbGFyUHJvZHVjdDogbnVtYmVyID0gX2EueCAqIF9iLnggKyBfYS55ICogX2IueSArIF9hLnogKiBfYi56O1xyXG4gICAgICByZXR1cm4gc2NhbGFyUHJvZHVjdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgYW5kIHJldHVybnMgdGhlIHJlZmxlY3Rpb24gb2YgdGhlIGluY29taW5nIHZlY3RvciBhdCB0aGUgZ2l2ZW4gbm9ybWFsIHZlY3Rvci4gVGhlIGxlbmd0aCBvZiBub3JtYWwgc2hvdWxkIGJlIDEuXHJcbiAgICAgKiAgICAgX19fX19fX19fX19fX19fX19fXHJcbiAgICAgKiAgICAgICAgICAgL3xcXFxyXG4gICAgICogaW5jb21pbmcgLyB8IFxcIHJlZmxlY3Rpb25cclxuICAgICAqICAgICAgICAgLyAgfCAgXFwgICBcclxuICAgICAqICAgICAgICAgIG5vcm1hbFxyXG4gICAgICogXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgUkVGTEVDVElPTihfaW5jb21pbmc6IFZlY3RvcjMsIF9ub3JtYWw6IFZlY3RvcjMpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IGRvdDogbnVtYmVyID0gLVZlY3RvcjMuRE9UKF9pbmNvbWluZywgX25vcm1hbCk7XHJcbiAgICAgIGxldCByZWZsZWN0aW9uOiBWZWN0b3IzID0gVmVjdG9yMy5TVU0oX2luY29taW5nLCBWZWN0b3IzLlNDQUxFKF9ub3JtYWwsIDIgKiBkb3QpKTtcclxuICAgICAgcmV0dXJuIHJlZmxlY3Rpb247XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNvb3JkaW5hdGVzIG9mIHRoaXMgYW5kIHRoZSBnaXZlbiB2ZWN0b3IgYXJlIHRvIGJlIGNvbnNpZGVyZWQgaWRlbnRpY2FsIHdpdGhpbiB0aGUgZ2l2ZW4gdG9sZXJhbmNlXHJcbiAgICAgKiBUT0RPOiBleGFtaW5lLCBpZiB0b2xlcmFuY2UgYXMgY3JpdGVyaXVtIGZvciB0aGUgZGlmZmVyZW5jZSBpcyBhcHByb3ByaWF0ZSB3aXRoIHZlcnkgbGFyZ2UgY29vcmRpbmF0ZSB2YWx1ZXMgb3IgaWYgX3RvbGVyYW5jZSBzaG91bGQgYmUgbXVsdGlwbGllZCBieSBjb29yZGluYXRlIHZhbHVlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBlcXVhbHMoX2NvbXBhcmU6IFZlY3RvcjMsIF90b2xlcmFuY2U6IG51bWJlciA9IE51bWJlci5FUFNJTE9OKTogYm9vbGVhbiB7XHJcbiAgICAgIGlmIChNYXRoLmFicyh0aGlzLnggLSBfY29tcGFyZS54KSA+IF90b2xlcmFuY2UpIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKE1hdGguYWJzKHRoaXMueSAtIF9jb21wYXJlLnkpID4gX3RvbGVyYW5jZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAoTWF0aC5hYnModGhpcy56IC0gX2NvbXBhcmUueikgPiBfdG9sZXJhbmNlKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhZGQoX2FkZGVuZDogVmVjdG9yMyk6IHZvaWQge1xyXG4gICAgICB0aGlzLmRhdGEgPSBuZXcgVmVjdG9yMyhfYWRkZW5kLnggKyB0aGlzLngsIF9hZGRlbmQueSArIHRoaXMueSwgX2FkZGVuZC56ICsgdGhpcy56KS5kYXRhO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHN1YnRyYWN0KF9zdWJ0cmFoZW5kOiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuZGF0YSA9IG5ldyBWZWN0b3IzKHRoaXMueCAtIF9zdWJ0cmFoZW5kLngsIHRoaXMueSAtIF9zdWJ0cmFoZW5kLnksIHRoaXMueiAtIF9zdWJ0cmFoZW5kLnopLmRhdGE7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2NhbGUoX3NjYWxlOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy5kYXRhID0gbmV3IFZlY3RvcjMoX3NjYWxlICogdGhpcy54LCBfc2NhbGUgKiB0aGlzLnksIF9zY2FsZSAqIHRoaXMueikuZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgbm9ybWFsaXplKF9sZW5ndGg6IG51bWJlciA9IDEpOiB2b2lkIHtcclxuICAgICAgdGhpcy5kYXRhID0gVmVjdG9yMy5OT1JNQUxJWkFUSU9OKHRoaXMsIF9sZW5ndGgpLmRhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldChfeDogbnVtYmVyID0gMCwgX3k6IG51bWJlciA9IDAsIF96OiBudW1iZXIgPSAwKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoW194LCBfeSwgX3pdKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0KCk6IEZsb2F0MzJBcnJheSB7XHJcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KHRoaXMuZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBjb3B5KCk6IFZlY3RvcjMge1xyXG4gICAgICByZXR1cm4gbmV3IFZlY3RvcjModGhpcy54LCB0aGlzLnksIHRoaXMueik7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHRyYW5zZm9ybShfbWF0cml4OiBNYXRyaXg0eDQsIF9pbmNsdWRlVHJhbnNsYXRpb246IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuZGF0YSA9IFZlY3RvcjMuVFJBTlNGT1JNQVRJT04odGhpcywgX21hdHJpeCwgX2luY2x1ZGVUcmFuc2xhdGlvbikuZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyb3BzIHRoZSB6LWNvbXBvbmVudCBhbmQgcmV0dXJucyBhIFZlY3RvcjIgY29uc2lzdGluZyBvZiB0aGUgeC0gYW5kIHktY29tcG9uZW50c1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdG9WZWN0b3IyKCk6IFZlY3RvcjIge1xyXG4gICAgICByZXR1cm4gbmV3IFZlY3RvcjIodGhpcy54LCB0aGlzLnkpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyByZWZsZWN0KF9ub3JtYWw6IFZlY3RvcjMpOiB2b2lkIHtcclxuICAgICAgY29uc3QgcmVmbGVjdGVkOiBWZWN0b3IzID0gVmVjdG9yMy5SRUZMRUNUSU9OKHRoaXMsIF9ub3JtYWwpO1xyXG4gICAgICB0aGlzLnNldChyZWZsZWN0ZWQueCwgcmVmbGVjdGVkLnksIHJlZmxlY3RlZC56KTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUocmVmbGVjdGVkKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuICAgICAgbGV0IHJlc3VsdDogc3RyaW5nID0gYCgke3RoaXMueC50b1ByZWNpc2lvbig1KX0sICR7dGhpcy55LnRvUHJlY2lzaW9uKDUpfSwgJHt0aGlzLnoudG9QcmVjaXNpb24oNSl9KWA7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG1hcChfZnVuY3Rpb246ICh2YWx1ZTogbnVtYmVyLCBpbmRleDogbnVtYmVyLCBhcnJheTogRmxvYXQzMkFycmF5KSA9PiBudW1iZXIpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IGNvcHk6IFZlY3RvcjMgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XHJcbiAgICAgIGNvcHkuZGF0YSA9IHRoaXMuZGF0YS5tYXAoX2Z1bmN0aW9uKTtcclxuICAgICAgcmV0dXJuIGNvcHk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0ge1xyXG4gICAgICAgIHg6IHRoaXMuZGF0YVswXSwgeTogdGhpcy5kYXRhWzFdLCB6OiB0aGlzLmRhdGFbMl1cclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQgey8qKiAqLyB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgYWxsIG1lc2hlcy4gXHJcbiAgICogTWVzaGVzIHByb3ZpZGUgaW5kZXhlZCB2ZXJ0aWNlcywgdGhlIG9yZGVyIG9mIGluZGljZXMgdG8gY3JlYXRlIHRyaWdvbnMgYW5kIG5vcm1hbHMsIGFuZCB0ZXh0dXJlIGNvb3JkaW5hdGVzXHJcbiAgICogXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBAUmVuZGVySW5qZWN0b3JNZXNoLmRlY29yYXRlXHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIE1lc2ggaW1wbGVtZW50cyBTZXJpYWxpemFibGVSZXNvdXJjZSB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IHN1YmNsYXNzZXM6IHR5cGVvZiBNZXNoW10gPSBbXTtcclxuXHJcbiAgICAvLyBUT0RPOiBjaGVjayBpZiB0aGVzZSBhcnJheXMgbXVzdCBiZSBjYWNoZWQgbGlrZSB0aGlzIG9yIGlmIGNhbGxpbmcgdGhlIG1ldGhvZHMgaXMgYmV0dGVyLlxyXG4gICAgcHVibGljIHZlcnRpY2VzOiBGbG9hdDMyQXJyYXk7XHJcbiAgICBwdWJsaWMgaW5kaWNlczogVWludDE2QXJyYXk7XHJcbiAgICBwdWJsaWMgdGV4dHVyZVVWczogRmxvYXQzMkFycmF5O1xyXG4gICAgcHVibGljIG5vcm1hbHNGYWNlOiBGbG9hdDMyQXJyYXk7XHJcblxyXG4gICAgcHVibGljIGlkUmVzb3VyY2U6IHN0cmluZyA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyQnVmZmVyczogUmVuZGVyQnVmZmVyczsgLyogZGVmaW5lZCBieSBSZW5kZXJJbmplY3RvciovXHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRCdWZmZXJTcGVjaWZpY2F0aW9uKCk6IEJ1ZmZlclNwZWNpZmljYXRpb24ge1xyXG4gICAgICByZXR1cm4geyBzaXplOiAzLCBkYXRhVHlwZTogV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GTE9BVCwgbm9ybWFsaXplOiBmYWxzZSwgc3RyaWRlOiAwLCBvZmZzZXQ6IDAgfTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHJlZ2lzdGVyU3ViY2xhc3MoX3N1YmNsYXNzOiB0eXBlb2YgTWVzaCk6IG51bWJlciB7IHJldHVybiBNZXNoLnN1YmNsYXNzZXMucHVzaChfc3ViY2xhc3MpIC0gMTsgfVxyXG5cclxuICAgIHB1YmxpYyB1c2VSZW5kZXJCdWZmZXJzKF9yZW5kZXJTaGFkZXI6IFJlbmRlclNoYWRlciwgX3dvcmxkOiBNYXRyaXg0eDQsIF9wcm9qZWN0aW9uOiBNYXRyaXg0eDQsIF9pZD86IG51bWJlcik6IHZvaWQgey8qIGluamVjdGVkIGJ5IFJlbmRlckluamVjdG9yKi8gfVxyXG4gICAgcHVibGljIGNyZWF0ZVJlbmRlckJ1ZmZlcnMoX3JlbmRlclNoYWRlcjogUmVuZGVyU2hhZGVyKTogdm9pZCB7LyogaW5qZWN0ZWQgYnkgUmVuZGVySW5qZWN0b3IqLyB9XHJcbiAgICBwdWJsaWMgZGVsZXRlUmVuZGVyQnVmZmVycyhfcmVuZGVyU2hhZGVyOiBSZW5kZXJTaGFkZXIpOiB2b2lkIHsvKiBpbmplY3RlZCBieSBSZW5kZXJJbmplY3RvciovIH1cclxuXHJcbiAgICBcclxuICAgIHB1YmxpYyBnZXRWZXJ0ZXhDb3VudCgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMudmVydGljZXMubGVuZ3RoIC8gTWVzaC5nZXRCdWZmZXJTcGVjaWZpY2F0aW9uKCkuc2l6ZTtcclxuICB9XHJcbiAgICBwdWJsaWMgZ2V0SW5kZXhDb3VudCgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuaW5kaWNlcy5sZW5ndGg7XHJcbiAgfVxyXG5cclxuXHJcbiAgICAvLyBTZXJpYWxpemUvRGVzZXJpYWxpemUgZm9yIGFsbCBtZXNoZXMgdGhhdCBjYWxjdWxhdGUgd2l0aG91dCBwYXJhbWV0ZXJzXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgIGlkUmVzb3VyY2U6IHRoaXMuaWRSZXNvdXJjZVxyXG4gICAgfTsgLy8gbm8gZGF0YSBuZWVkZWQgLi4uXHJcbiAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICB9XHJcbiAgICBwdWJsaWMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBTZXJpYWxpemFibGUge1xyXG4gICAgdGhpcy5jcmVhdGUoKTsgLy8gVE9ETzogbXVzdCBub3QgYmUgY3JlYXRlZCwgaWYgYW4gaWRlbnRpY2FsIG1lc2ggYWxyZWFkeSBleGlzdHNcclxuICAgIHRoaXMuaWRSZXNvdXJjZSA9IF9zZXJpYWxpemF0aW9uLmlkUmVzb3VyY2U7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcbiAgICBcclxuICAgIHB1YmxpYyBhYnN0cmFjdCBjcmVhdGUoKTogdm9pZDtcclxuICAgIFxyXG4gICAgcHJvdGVjdGVkIGNhbGN1bGF0ZUZhY2VOb3JtYWxzKCk6IEZsb2F0MzJBcnJheSB7XHJcbiAgICBsZXQgbm9ybWFsczogbnVtYmVyW10gPSBbXTtcclxuICAgIGxldCB2ZXJ0aWNlczogVmVjdG9yM1tdID0gW107XHJcblxyXG4gICAgZm9yIChsZXQgdjogbnVtYmVyID0gMDsgdiA8IHRoaXMudmVydGljZXMubGVuZ3RoOyB2ICs9IDMpXHJcbiAgICAgIHZlcnRpY2VzLnB1c2gobmV3IFZlY3RvcjModGhpcy52ZXJ0aWNlc1t2XSwgdGhpcy52ZXJ0aWNlc1t2ICsgMV0sIHRoaXMudmVydGljZXNbdiArIDJdKSk7XHJcblxyXG4gICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMuaW5kaWNlcy5sZW5ndGg7IGkgKz0gMykge1xyXG4gICAgICBsZXQgdmVydGV4OiBudW1iZXJbXSA9IFt0aGlzLmluZGljZXNbaV0sIHRoaXMuaW5kaWNlc1tpICsgMV0sIHRoaXMuaW5kaWNlc1tpICsgMl1dO1xyXG5cclxuICAgICAgbGV0IHYwOiBWZWN0b3IzID0gVmVjdG9yMy5ESUZGRVJFTkNFKHZlcnRpY2VzW3ZlcnRleFswXV0sIHZlcnRpY2VzW3ZlcnRleFsxXV0pO1xyXG4gICAgICBsZXQgdjE6IFZlY3RvcjMgPSBWZWN0b3IzLkRJRkZFUkVOQ0UodmVydGljZXNbdmVydGV4WzBdXSwgdmVydGljZXNbdmVydGV4WzJdXSk7XHJcbiAgICAgIGxldCBub3JtYWw6IFZlY3RvcjMgPSBWZWN0b3IzLk5PUk1BTElaQVRJT04oVmVjdG9yMy5DUk9TUyh2MCwgdjEpKTtcclxuICAgICAgbGV0IGluZGV4OiBudW1iZXIgPSB2ZXJ0ZXhbMl0gKiAzO1xyXG4gICAgICBub3JtYWxzW2luZGV4XSA9IG5vcm1hbC54O1xyXG4gICAgICBub3JtYWxzW2luZGV4ICsgMV0gPSBub3JtYWwueTtcclxuICAgICAgbm9ybWFsc1tpbmRleCArIDJdID0gbm9ybWFsLno7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShub3JtYWxzKTtcclxuICB9XHJcbiAgICBcclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBjcmVhdGVWZXJ0aWNlcygpOiBGbG9hdDMyQXJyYXk7XHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgY3JlYXRlVGV4dHVyZVVWcygpOiBGbG9hdDMyQXJyYXk7XHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgY3JlYXRlSW5kaWNlcygpOiBVaW50MTZBcnJheTtcclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBjcmVhdGVGYWNlTm9ybWFscygpOiBGbG9hdDMyQXJyYXk7XHJcbn1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlIGEgc2ltcGxlIGN1YmUgd2l0aCBlZGdlcyBvZiBsZW5ndGggMSwgZWFjaCBmYWNlIGNvbnNpc3Rpbmcgb2YgdHdvIHRyaWdvbnNcclxuICAgKiBgYGBwbGFpbnRleHRcclxuICAgKiAgICAgICAgICAgIDRfX19fN1xyXG4gICAqICAgICAgICAgICAwL19fMy98XHJcbiAgICogICAgICAgICAgICB8fDVffHw2XHJcbiAgICogICAgICAgICAgIDF8L18yfC8gXHJcbiAgICogYGBgXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgTWVzaEN1YmUgZXh0ZW5kcyBNZXNoIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBNZXNoLnJlZ2lzdGVyU3ViY2xhc3MoTWVzaEN1YmUpO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5jcmVhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgY3JlYXRlKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLnZlcnRpY2VzID0gdGhpcy5jcmVhdGVWZXJ0aWNlcygpO1xyXG4gICAgICB0aGlzLmluZGljZXMgPSB0aGlzLmNyZWF0ZUluZGljZXMoKTtcclxuICAgICAgdGhpcy50ZXh0dXJlVVZzID0gdGhpcy5jcmVhdGVUZXh0dXJlVVZzKCk7XHJcbiAgICAgIHRoaXMubm9ybWFsc0ZhY2UgPSB0aGlzLmNyZWF0ZUZhY2VOb3JtYWxzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZVZlcnRpY2VzKCk6IEZsb2F0MzJBcnJheSB7XHJcbiAgICAgIGxldCB2ZXJ0aWNlczogRmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAgICAgICAgICAgICAvLyBGaXJzdCB3cmFwXHJcbiAgICAgICAgICAgICAgICAvLyBmcm9udFxyXG4gICAgICAgICAgICAgICAgLyowKi8gLTEsIDEsIDEsIC8qMSovIC0xLCAtMSwgMSwgIC8qMiovIDEsIC0xLCAxLCAvKjMqLyAxLCAxLCAxLFxyXG4gICAgICAgICAgICAgICAgLy8gYmFja1xyXG4gICAgICAgICAgICAgICAgLyo0Ki8gLTEsIDEsIC0xLCAvKiA1Ki8gLTEsIC0xLCAtMSwgIC8qIDYqLyAxLCAtMSwgLTEsIC8qIDcqLyAxLCAxLCAtMSxcclxuICAgICAgICAgICAgICAgIC8vIFNlY29uZCB3cmFwXHJcbiAgICAgICAgICAgICAgICAvLyBmcm9udFxyXG4gICAgICAgICAgICAgICAgLyowKi8gLTEsIDEsIDEsIC8qMSovIC0xLCAtMSwgMSwgIC8qMiovIDEsIC0xLCAxLCAvKjMqLyAxLCAxLCAxLFxyXG4gICAgICAgICAgICAgICAgLy8gYmFja1xyXG4gICAgICAgICAgICAgICAgLyo0Ki8gLTEsIDEsIC0xLCAvKiA1Ki8gLTEsIC0xLCAtMSwgIC8qIDYqLyAxLCAtMSwgLTEsIC8qIDcqLyAxLCAxLCAtMVxyXG4gICAgICBdKTtcclxuXHJcbiAgICAgIC8vIHNjYWxlIGRvd24gdG8gYSBsZW5ndGggb2YgMSBmb3IgYWxsIGVkZ2VzXHJcbiAgICAgIHZlcnRpY2VzID0gdmVydGljZXMubWFwKF92YWx1ZSA9PiBfdmFsdWUgLyAyKTtcclxuXHJcbiAgICAgIHJldHVybiB2ZXJ0aWNlcztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlSW5kaWNlcygpOiBVaW50MTZBcnJheSB7XHJcbiAgICAgIGxldCBpbmRpY2VzOiBVaW50MTZBcnJheSA9IG5ldyBVaW50MTZBcnJheShbXHJcbiAgICAgICAgLy8gRmlyc3Qgd3JhcFxyXG4gICAgICAgIC8vIGZyb250XHJcbiAgICAgICAgMSwgMiwgMCwgMiwgMywgMCxcclxuICAgICAgICAvLyByaWdodFxyXG4gICAgICAgIDIsIDYsIDMsIDYsIDcsIDMsXHJcbiAgICAgICAgLy8gYmFja1xyXG4gICAgICAgIDYsIDUsIDcsIDUsIDQsIDcsXHJcblxyXG4gICAgICAgIC8vIFNlY29uZCB3cmFwXHJcbiAgICAgICAgLy8gbGVmdFxyXG4gICAgICAgIDUgKyA4LCAxICsgOCwgNCArIDgsIDEgKyA4LCAwICsgOCwgNCArIDgsXHJcbiAgICAgICAgLy8gdG9wXHJcbiAgICAgICAgNCArIDgsIDAgKyA4LCAzICsgOCwgNyArIDgsIDQgKyA4LCAzICsgOCxcclxuICAgICAgICAvLyBib3R0b21cclxuICAgICAgICA1ICsgOCwgNiArIDgsIDEgKyA4LCA2ICsgOCwgMiArIDgsIDEgKyA4XHJcblxyXG4gICAgICAgIC8qLFxyXG4gICAgICAgIC8vIGxlZnRcclxuICAgICAgICA0LCA1LCAxLCA0LCAxLCAwLFxyXG4gICAgICAgIC8vIHRvcFxyXG4gICAgICAgIDQsIDAsIDMsIDQsIDMsIDcsXHJcbiAgICAgICAgLy8gYm90dG9tXHJcbiAgICAgICAgMSwgNSwgNiwgMSwgNiwgMlxyXG4gICAgICAgICovXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gaW5kaWNlcztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlVGV4dHVyZVVWcygpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICBsZXQgdGV4dHVyZVVWczogRmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAgICAgICAgICAgICAvLyBGaXJzdCB3cmFwXHJcbiAgICAgICAgICAgICAgICAvLyBmcm9udFxyXG4gICAgICAgICAgICAgICAgLyowKi8gMCwgMCwgLyoxKi8gMCwgMSwgIC8qMiovIDEsIDEsIC8qMyovIDEsIDAsXHJcbiAgICAgICAgICAgICAgICAvLyBiYWNrXHJcbiAgICAgICAgICAgICAgICAvKjQqLyAzLCAwLCAvKjUqLyAzLCAxLCAgLyo2Ki8gMiwgMSwgLyo3Ki8gMiwgMCxcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTZWNvbmQgd3JhcFxyXG4gICAgICAgICAgICAgICAgLy8gZnJvbnRcclxuICAgICAgICAgICAgICAgIC8qMCovIDEsIDAsIC8qMSovIDEsIDEsICAvKjIqLyAxLCAyLCAvKjMqLyAxLCAtMSxcclxuICAgICAgICAgICAgICAgIC8vIGJhY2tcclxuICAgICAgICAgICAgICAgIC8qNCovIDAsIDAsIC8qNSovIDAsIDEsICAvKjYqLyAwLCAyLCAvKjcqLyAwLCAtMVxyXG4gICAgICBdKTtcclxuICAgICAgcmV0dXJuIHRleHR1cmVVVnM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZUZhY2VOb3JtYWxzKCk6IEZsb2F0MzJBcnJheSB7XHJcbiAgICAgIGxldCBub3JtYWxzOiBGbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KFtcclxuICAgICAgICAgICAgICAgIC8vIGZvciBlYWNoIHRyaWFuZ2xlLCB0aGUgbGFzdCB2ZXJ0ZXggb2YgdGhlIHRocmVlIGRlZmluaW5nIHJlZmVycyB0byB0aGUgbm9ybWFsdmVjdG9yIHdoZW4gdXNpbmcgZmxhdCBzaGFkaW5nXHJcbiAgICAgICAgICAgICAgICAvLyBGaXJzdCB3cmFwXHJcbiAgICAgICAgICAgICAgICAvLyBmcm9udFxyXG4gICAgICAgICAgICAgICAgLyowKi8gMCwgMCwgMSwgLyoxKi8gMCwgMCwgMCwgLyoyKi8gMCwgMCwgMCwgLyozKi8gMSwgMCwgMCxcclxuICAgICAgICAgICAgICAgIC8vIGJhY2tcclxuICAgICAgICAgICAgICAgIC8qNCovIDAsIDAsIDAsIC8qNSovIDAsIDAsIDAsIC8qNiovIDAsIDAsIDAsIC8qNyovIDAsIDAsIC0xLFxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNlY29uZCB3cmFwXHJcbiAgICAgICAgICAgICAgICAvLyBmcm9udFxyXG4gICAgICAgICAgICAgICAgLyowKi8gMCwgMCwgMCwgLyoxKi8gMCwgLTEsIDAsIC8qMiovIDAsIDAsIDAsIC8qMyovIDAsIDEsIDAsXHJcbiAgICAgICAgICAgICAgICAvLyBiYWNrXHJcbiAgICAgICAgICAgICAgICAvKjQqLyAtMSwgMCwgMCwgLyo1Ki8gMCwgMCwgMCwgLyo2Ki8gMCwgMCwgMCwgLyo3Ki8gMCwgMCwgMFxyXG4gICAgICBdKTtcclxuXHJcbiAgICAgIC8vbm9ybWFscyA9IHRoaXMuY3JlYXRlVmVydGljZXMoKTtcclxuXHJcbiAgICAgIHJldHVybiBub3JtYWxzO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG5cclxuICAvKiogVGhpcyBmdW5jdGlvbiB0eXBlIHRha2VzIHggYW5kIHogYXMgUGFyYW1ldGVycyBhbmQgcmV0dXJucyBhIG51bWJlciAtIHRvIGJlIHVzZWQgYXMgYSBoZWlnaHRtYXAuIFxyXG4gICAqIHggYW5kIHogYXJlIG1hcHBlZCBmcm9tIDAgdG8gMSB3aGVuIHVzZWQgdG8gZ2VuZXJhdGUgYSBIZWlnaHRtYXAgTWVzaFxyXG4gICAqIEBhdXRob3JzIFNpbW9uIFN0b3JsLVNjaHVsa2UsIEhGVSwgMjAyMCovXHJcbiAgZXhwb3J0IHR5cGUgaGVpZ2h0TWFwRnVuY3Rpb24gPSAoeDogbnVtYmVyLCB6OiBudW1iZXIpID0+IG51bWJlcjtcclxuXHJcbiAgLyoqXHJcbiAgICogR2VuZXJhdGVzIGEgcGxhbmFyIEdyaWQgYW5kIGFwcGxpZXMgYSBIZWlnaHRtYXAtRnVuY3Rpb24gdG8gaXQuXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBTaW1vbiBTdG9ybC1TY2h1bGtlLCBIRlUsIDIwMjBcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgTWVzaEhlaWdodE1hcCBleHRlbmRzIE1lc2gge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IE1lc2gucmVnaXN0ZXJTdWJjbGFzcyhNZXNoSGVpZ2h0TWFwKTtcclxuXHJcbiAgICBwcml2YXRlIHJlc29sdXRpb25YOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIHJlc29sdXRpb25aOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIGhlaWdodE1hcEZ1bmN0aW9uOiBoZWlnaHRNYXBGdW5jdGlvbjtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3Jlc29sdXRpb25YOiBudW1iZXIgPSAxNiwgX3Jlc29sdXRpb25aOiBudW1iZXIgPSAxNiwgX2hlaWdodE1hcEZ1bmN0aW9uPzogaGVpZ2h0TWFwRnVuY3Rpb24pIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5yZXNvbHV0aW9uWCA9IF9yZXNvbHV0aW9uWDtcclxuICAgICAgdGhpcy5yZXNvbHV0aW9uWiA9IF9yZXNvbHV0aW9uWjtcclxuXHJcbiAgICAgIGlmIChfcmVzb2x1dGlvblogfHwgX3Jlc29sdXRpb25YIDw9IDApIHtcclxuICAgICAgICBEZWJ1Zy53YXJuKFwiSGVpZ2h0TWFwIE1lc2ggY2Fubm90IGhhdmUgcmVzb2x1dGlvbiB2YWx1ZXMgPCAxLiBcIik7XHJcbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uWCA9IE1hdGgubWF4KDEsIHRoaXMucmVzb2x1dGlvblgpO1xyXG4gICAgICAgIHRoaXMucmVzb2x1dGlvblogPSBNYXRoLm1heCgxLCB0aGlzLnJlc29sdXRpb25aKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKF9oZWlnaHRNYXBGdW5jdGlvbikgdGhpcy5oZWlnaHRNYXBGdW5jdGlvbiA9IF9oZWlnaHRNYXBGdW5jdGlvbjtcclxuICAgICAgZWxzZSB0aGlzLmhlaWdodE1hcEZ1bmN0aW9uID0gZnVuY3Rpb24gKF94OiBudW1iZXIsIF95OiBudW1iZXIpOiBudW1iZXIgeyByZXR1cm4gMDsgfTtcclxuXHJcbiAgICAgIHRoaXMuY3JlYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGNyZWF0ZSgpOiB2b2lkIHtcclxuICAgICAgdGhpcy52ZXJ0aWNlcyA9IHRoaXMuY3JlYXRlVmVydGljZXMoKTtcclxuICAgICAgdGhpcy5pbmRpY2VzID0gdGhpcy5jcmVhdGVJbmRpY2VzKCk7XHJcbiAgICAgIHRoaXMudGV4dHVyZVVWcyA9IHRoaXMuY3JlYXRlVGV4dHVyZVVWcygpO1xyXG4gICAgICB0aGlzLm5vcm1hbHNGYWNlID0gdGhpcy5jcmVhdGVGYWNlTm9ybWFscygpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBjcmVhdGVWZXJ0aWNlcygpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICBsZXQgdmVydGljZXM6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoKHRoaXMucmVzb2x1dGlvblggKyAxKSAqICh0aGlzLnJlc29sdXRpb25aICsgMSkgKiAzKTtcclxuXHJcbiAgICAgIC8vSXRlcmF0ZSBvdmVyIGVhY2ggY2VsbCB0byBnZW5lcmF0ZSBncmlkIG9mIHZlcnRpY2VzXHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDAsIHo6IG51bWJlciA9IDA7IHogPD0gdGhpcy5yZXNvbHV0aW9uWjsgeisrKSB7XHJcbiAgICAgICAgZm9yIChsZXQgeDogbnVtYmVyID0gMDsgeCA8PSB0aGlzLnJlc29sdXRpb25YOyB4KyspIHtcclxuICAgICAgICAgIC8vIFhcclxuICAgICAgICAgIHZlcnRpY2VzW2ldID0geCAvIHRoaXMucmVzb2x1dGlvblggLSAwLjU7XHJcbiAgICAgICAgICAvLyBBcHBseSBoZWlnaHRtYXAgdG8geSBjb29yZGluYXRlXHJcbiAgICAgICAgICB2ZXJ0aWNlc1tpICsgMV0gPSB0aGlzLmhlaWdodE1hcEZ1bmN0aW9uKHggLyB0aGlzLnJlc29sdXRpb25YLCB6IC8gdGhpcy5yZXNvbHV0aW9uWik7XHJcbiAgICAgICAgICAvLyBaXHJcbiAgICAgICAgICB2ZXJ0aWNlc1tpICsgMl0gPSB6IC8gdGhpcy5yZXNvbHV0aW9uWiAtIDAuNTtcclxuICAgICAgICAgIGkgKz0gMztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHZlcnRpY2VzO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBjcmVhdGVJbmRpY2VzKCk6IFVpbnQxNkFycmF5IHtcclxuICAgICAgbGV0IHZlcnQ6IG51bWJlciA9IDA7XHJcbiAgICAgIGxldCB0cmlzOiBudW1iZXIgPSAwO1xyXG5cclxuICAgICAgbGV0IGluZGljZXM6IFVpbnQxNkFycmF5ID0gbmV3IFVpbnQxNkFycmF5KHRoaXMucmVzb2x1dGlvblggKiB0aGlzLnJlc29sdXRpb25aICogNik7XHJcbiAgICAgIGZvciAobGV0IHo6IG51bWJlciA9IDA7IHogPCB0aGlzLnJlc29sdXRpb25aOyB6KyspIHtcclxuICAgICAgICBmb3IgKGxldCB4OiBudW1iZXIgPSAwOyB4IDwgdGhpcy5yZXNvbHV0aW9uWDsgeCsrKSB7XHJcblxyXG4gICAgICAgICAgLy8gRmlyc3QgdHJpYW5nbGUgb2YgZWFjaCBncmlkLWNlbGxcclxuICAgICAgICAgIGluZGljZXNbdHJpcyArIDBdID0gdmVydCArIDA7XHJcbiAgICAgICAgICBpbmRpY2VzW3RyaXMgKyAxXSA9IHZlcnQgKyB0aGlzLnJlc29sdXRpb25YICsgMTtcclxuICAgICAgICAgIGluZGljZXNbdHJpcyArIDJdID0gdmVydCArIDE7XHJcblxyXG4gICAgICAgICAgLy8gU2Vjb25kIHRyaWFuZ2xlIG9mIGVhY2ggZ3JpZC1jZWxsXHJcbiAgICAgICAgICBpbmRpY2VzW3RyaXMgKyAzXSA9IHZlcnQgKyAxO1xyXG4gICAgICAgICAgaW5kaWNlc1t0cmlzICsgNF0gPSB2ZXJ0ICsgdGhpcy5yZXNvbHV0aW9uWCArIDE7XHJcbiAgICAgICAgICBpbmRpY2VzW3RyaXMgKyA1XSA9IHZlcnQgKyB0aGlzLnJlc29sdXRpb25YICsgMjtcclxuICAgICAgICAgIHZlcnQrKztcclxuICAgICAgICAgIHRyaXMgKz0gNjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmVydCsrO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBpbmRpY2VzO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBjcmVhdGVUZXh0dXJlVVZzKCk6IEZsb2F0MzJBcnJheSB7XHJcbiAgICAgIGxldCB0ZXh0dXJlVVZzOiBGbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuaW5kaWNlcy5sZW5ndGggKiAyKTtcclxuXHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDAsIHo6IG51bWJlciA9IDA7IHogPD0gdGhpcy5yZXNvbHV0aW9uWjsgeisrKSB7XHJcbiAgICAgICAgZm9yIChsZXQgeDogbnVtYmVyID0gMDsgeCA8PSB0aGlzLnJlc29sdXRpb25YOyB4KyspIHtcclxuICAgICAgICAgIHRleHR1cmVVVnNbaV0gPSB4IC8gdGhpcy5yZXNvbHV0aW9uWDtcclxuICAgICAgICAgIHRleHR1cmVVVnNbaSArIDFdID0geiAvIHRoaXMucmVzb2x1dGlvblo7XHJcbiAgICAgICAgICBpICs9IDI7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0ZXh0dXJlVVZzO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBjcmVhdGVGYWNlTm9ybWFscygpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICByZXR1cm4gdGhpcy5jYWxjdWxhdGVGYWNlTm9ybWFscygpO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIlxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlIGEgc2ltcGxlIHB5cmFtaWQgd2l0aCBlZGdlcyBhdCB0aGUgYmFzZSBvZiBsZW5ndGggMSBhbmQgYSBoZWlnaHQgb2YgMS4gVGhlIHNpZGVzIGNvbnNpc3Rpbmcgb2Ygb25lLCB0aGUgYmFzZSBvZiB0d28gdHJpZ29uc1xyXG4gICAqIGBgYHBsYWludGV4dFxyXG4gICAqICAgICAgICAgICAgICAgNFxyXG4gICAqICAgICAgICAgICAgICAvXFxgLlxyXG4gICAqICAgICAgICAgICAgMy9fX1xcX1xcIDJcclxuICAgKiAgICAgICAgICAgMC9fX19fXFwvMVxyXG4gICAqIGBgYFxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE1lc2hQeXJhbWlkIGV4dGVuZHMgTWVzaCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gTWVzaC5yZWdpc3RlclN1YmNsYXNzKE1lc2hQeXJhbWlkKTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuY3JlYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGNyZWF0ZSgpOiB2b2lkIHtcclxuICAgICAgdGhpcy52ZXJ0aWNlcyA9IHRoaXMuY3JlYXRlVmVydGljZXMoKTtcclxuICAgICAgdGhpcy5pbmRpY2VzID0gdGhpcy5jcmVhdGVJbmRpY2VzKCk7XHJcbiAgICAgIHRoaXMudGV4dHVyZVVWcyA9IHRoaXMuY3JlYXRlVGV4dHVyZVVWcygpO1xyXG4gICAgICB0aGlzLm5vcm1hbHNGYWNlID0gdGhpcy5jcmVhdGVGYWNlTm9ybWFscygpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBjcmVhdGVWZXJ0aWNlcygpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICBsZXQgdmVydGljZXM6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoW1xyXG4gICAgICAgICAgICAgICAgLy8gZmxvb3JcclxuICAgICAgICAgICAgICAgIC8qMCovIC0xLCAwLCAxLCAvKjEqLyAxLCAwLCAxLCAgLyoyKi8gMSwgMCwgLTEsIC8qMyovIC0xLCAwLCAtMSxcclxuICAgICAgICAgICAgICAgIC8vIHRpcFxyXG4gICAgICAgICAgICAgICAgLyo0Ki8gMCwgMiwgMCwgIC8vIGRvdWJsZSBoZWlnaHQgd2lsbCBiZSBzY2FsZWQgZG93blxyXG4gICAgICAgICAgICAgICAgLy8gZmxvb3IgYWdhaW4gZm9yIHRleHR1cmluZyBhbmQgbm9ybWFsc1xyXG4gICAgICAgICAgICAgICAgLyo1Ki8gLTEsIDAsIDEsIC8qNiovIDEsIDAsIDEsICAvKjcqLyAxLCAwLCAtMSwgLyo4Ki8gLTEsIDAsIC0xXHJcbiAgICAgIF0pO1xyXG5cclxuICAgICAgLy8gc2NhbGUgZG93biB0byBhIGxlbmd0aCBvZiAxIGZvciBib3R0b20gZWRnZXMgYW5kIGhlaWdodFxyXG4gICAgICB2ZXJ0aWNlcyA9IHZlcnRpY2VzLm1hcChfdmFsdWUgPT4gX3ZhbHVlIC8gMik7XHJcbiAgICAgIHJldHVybiB2ZXJ0aWNlcztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlSW5kaWNlcygpOiBVaW50MTZBcnJheSB7XHJcbiAgICAgIGxldCBpbmRpY2VzOiBVaW50MTZBcnJheSA9IG5ldyBVaW50MTZBcnJheShbXHJcbiAgICAgICAgLy8gZnJvbnRcclxuICAgICAgICA0LCAwLCAxLFxyXG4gICAgICAgIC8vIHJpZ2h0XHJcbiAgICAgICAgNCwgMSwgMixcclxuICAgICAgICAvLyBiYWNrXHJcbiAgICAgICAgNCwgMiwgMyxcclxuICAgICAgICAvLyBsZWZ0XHJcbiAgICAgICAgNCwgMywgMCxcclxuICAgICAgICAvLyBib3R0b21cclxuICAgICAgICA1ICsgMCwgNSArIDIsIDUgKyAxLCA1ICsgMCwgNSArIDMsIDUgKyAyXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gaW5kaWNlcztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlVGV4dHVyZVVWcygpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICBsZXQgdGV4dHVyZVVWczogRmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAgICAgICAgICAgICAvLyBmcm9udFxyXG4gICAgICAgICAgICAgICAgLyowKi8gMCwgMSwgLyoxKi8gMC41LCAxLCAgLyoyKi8gMSwgMSwgLyozKi8gMC41LCAxLFxyXG4gICAgICAgICAgICAgICAgLy8gYmFja1xyXG4gICAgICAgICAgICAgICAgLyo0Ki8gMC41LCAwLFxyXG4gICAgICAgICAgICAgICAgLyo1Ki8gMCwgMCwgLyo2Ki8gMSwgMCwgIC8qNyovIDEsIDEsIC8qOCovIDAsIDFcclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiB0ZXh0dXJlVVZzO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBjcmVhdGVGYWNlTm9ybWFscygpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmNhbGN1bGF0ZUZhY2VOb3JtYWxzKCkpO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlIGEgc2ltcGxlIHF1YWQgd2l0aCBlZGdlcyBvZiBsZW5ndGggMSwgdGhlIGZhY2UgY29uc2lzdGluZyBvZiB0d28gdHJpZ29uc1xyXG4gICAqIGBgYHBsYWludGV4dFxyXG4gICAqICAgICAgICAwIF9fIDNcclxuICAgKiAgICAgICAgIHxfX3xcclxuICAgKiAgICAgICAgMSAgICAyICAgICAgICAgICAgIFxyXG4gICAqIGBgYCBcclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBNZXNoUXVhZCBleHRlbmRzIE1lc2gge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IE1lc2gucmVnaXN0ZXJTdWJjbGFzcyhNZXNoUXVhZCk7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLmNyZWF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBjcmVhdGUoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMudmVydGljZXMgPSB0aGlzLmNyZWF0ZVZlcnRpY2VzKCk7XHJcbiAgICAgIHRoaXMuaW5kaWNlcyA9IHRoaXMuY3JlYXRlSW5kaWNlcygpO1xyXG4gICAgICB0aGlzLnRleHR1cmVVVnMgPSB0aGlzLmNyZWF0ZVRleHR1cmVVVnMoKTtcclxuICAgICAgdGhpcy5ub3JtYWxzRmFjZSA9IHRoaXMuY3JlYXRlRmFjZU5vcm1hbHMoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlVmVydGljZXMoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgbGV0IHZlcnRpY2VzOiBGbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KFtcclxuICAgICAgICAgICAgICAgIC8qMCovIC0xLCAxLCAwLCAvKjEqLyAtMSwgLTEsIDAsICAvKjIqLyAxLCAtMSwgMCwgLyozKi8gMSwgMSwgMFxyXG4gICAgICBdKTtcclxuXHJcbiAgICAgIHZlcnRpY2VzID0gdmVydGljZXMubWFwKF92YWx1ZSA9PiBfdmFsdWUgLyAyKTtcclxuXHJcbiAgICAgIHJldHVybiB2ZXJ0aWNlcztcclxuICAgIH1cclxuICAgIHByb3RlY3RlZCBjcmVhdGVJbmRpY2VzKCk6IFVpbnQxNkFycmF5IHtcclxuICAgICAgbGV0IGluZGljZXM6IFVpbnQxNkFycmF5ID0gbmV3IFVpbnQxNkFycmF5KFtcclxuICAgICAgICAxLCAyLCAwLCAyLCAzLCAwXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gaW5kaWNlcztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlVGV4dHVyZVVWcygpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICBsZXQgdGV4dHVyZVVWczogRmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAgICAgICAgICAgICAvLyBmcm9udFxyXG4gICAgICAgICAgICAgICAgLyowKi8gMCwgMCwgLyoxKi8gMCwgMSwgIC8qMiovIDEsIDEsIC8qMyovIDEsIDBcclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiB0ZXh0dXJlVVZzO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBjcmVhdGVGYWNlTm9ybWFscygpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAgICAgICAgICAgICAvKjAqLyAwLCAwLCAxLCAvKjEqLyAwLCAwLCAwLCAvKjIqLyAwLCAwLCAwLCAvKjMqLyAwLCAwLCAwXHJcbiAgICAgIF0pO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlIGEgVVYgU3BoZXJlIHdpdGggYSBnaXZlbiBudW1iZXIgb2Ygc2VjdG9ycyBhbmQgc3RhY2tzIChjbGFtcGVkIGF0IDEyOCoxMjgpXHJcbiAgICogSW1wbGVtZW50YXRpb24gYmFzZWQgb24gaHR0cDovL3d3dy5zb25naG8uY2Evb3BlbmdsL2dsX3NwaGVyZS5odG1sXHJcbiAgICogQGF1dGhvcnMgU2ltb24gU3RvcmwtU2NodWxrZSwgSEZVLCAyMDIwIHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjBcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgTWVzaFNwaGVyZSBleHRlbmRzIE1lc2gge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IE1lc2gucmVnaXN0ZXJTdWJjbGFzcyhNZXNoU3BoZXJlKTtcclxuXHJcbiAgICBwdWJsaWMgbm9ybWFsczogRmxvYXQzMkFycmF5O1xyXG5cclxuICAgIHByaXZhdGUgc2VjdG9yczogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBzdGFja3M6IG51bWJlcjtcclxuXHJcbiAgICAvLyBEaXJ0eSBXb3JrYXJvdW5kIHRvIGhhdmUgYWNjZXNzIHRvIHRoZSBub3JtYWxzIGZyb20gY3JlYXRlVmVydGljZXMoKVxyXG4gICAgLy8gcHJpdmF0ZSBub3JtYWxzOiBBcnJheTxudW1iZXI+ID0gW107XHJcbiAgICAvLyBwcml2YXRlIHRleHR1cmVVVnM6IEFycmF5PG51bWJlcj4gPSBbXTtcclxuICAgIC8vIHB1YmxpYyB0ZXh0dXJlVVZzOiBGbG9hdDMyQXJyYXk7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9zZWN0b3JzOiBudW1iZXIgPSAxMiwgX3N0YWNrczogbnVtYmVyID0gOCkge1xyXG4gICAgICBzdXBlcigpO1xyXG5cclxuICAgICAgLy9DbGFtcCByZXNvbHV0aW9uIHRvIHByZXZlbnQgcGVyZm9ybWFuY2UgaXNzdWVzXHJcbiAgICAgIHRoaXMuc2VjdG9ycyA9IE1hdGgubWluKF9zZWN0b3JzLCAxMjgpO1xyXG4gICAgICB0aGlzLnN0YWNrcyA9IE1hdGgubWluKF9zdGFja3MsIDEyOCk7XHJcblxyXG4gICAgICBpZiAoX3NlY3RvcnMgPCAzIHx8IF9zdGFja3MgPCAyKSB7XHJcbiAgICAgICAgRGVidWcud2FybihcIlVWIFNwaGVyZSBtdXN0IGhhdmUgYXQgbGVhc3QgMyBzZWN0b3JzIGFuZCAyIHN0YWNrcyB0byBmb3JtIGEgMy1kaW1lbnNpb25hbCBzaGFwZS5cIik7XHJcbiAgICAgICAgdGhpcy5zZWN0b3JzID0gTWF0aC5tYXgoMywgX3NlY3RvcnMpO1xyXG4gICAgICAgIHRoaXMuc3RhY2tzID0gTWF0aC5tYXgoMiwgX3N0YWNrcyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuY3JlYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGNyZWF0ZSgpOiB2b2lkIHtcclxuICAgICAgbGV0IHZlcnRpY2VzOiBBcnJheTxudW1iZXI+ID0gW107XHJcbiAgICAgIGxldCBub3JtYWxzOiBudW1iZXJbXSA9IFtdO1xyXG4gICAgICBsZXQgdGV4dHVyZVVWczogbnVtYmVyW10gPSBbXTtcclxuXHJcbiAgICAgIGxldCB4OiBudW1iZXI7XHJcbiAgICAgIGxldCB6OiBudW1iZXI7XHJcbiAgICAgIGxldCB4ejogbnVtYmVyO1xyXG4gICAgICBsZXQgeTogbnVtYmVyO1xyXG5cclxuXHJcbiAgICAgIGxldCBzZWN0b3JTdGVwOiBudW1iZXIgPSAyICogTWF0aC5QSSAvIHRoaXMuc2VjdG9ycztcclxuICAgICAgbGV0IHN0YWNrU3RlcDogbnVtYmVyID0gTWF0aC5QSSAvIHRoaXMuc3RhY2tzO1xyXG4gICAgICBsZXQgc3RhY2tBbmdsZTogbnVtYmVyO1xyXG4gICAgICBsZXQgc2VjdG9yQW5nbGU6IG51bWJlcjtcclxuXHJcbiAgICAgIC8qIGFkZCAoc2VjdG9yQ291bnQrMSkgdmVydGljZXMgcGVyIHN0YWNrLlxyXG4gICAgICB0aGUgZmlyc3QgYW5kIGxhc3QgdmVydGljZXMgaGF2ZSBzYW1lIHBvc2l0aW9uIGFuZCBub3JtYWwsIFxyXG4gICAgICBidXQgZGlmZmVyZW50IHRleCBjb29yZHMgKi9cclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8PSB0aGlzLnN0YWNrczsgKytpKSB7XHJcbiAgICAgICAgc3RhY2tBbmdsZSA9IE1hdGguUEkgLyAyIC0gaSAqIHN0YWNrU3RlcDtcclxuICAgICAgICB4eiA9IE1hdGguY29zKHN0YWNrQW5nbGUpO1xyXG4gICAgICAgIHkgPSBNYXRoLnNpbihzdGFja0FuZ2xlKTtcclxuXHJcbiAgICAgICAgLy8gYWRkIChzZWN0b3JDb3VudCsxKSB2ZXJ0aWNlcyBwZXIgc3RhY2tcclxuICAgICAgICAvLyB0aGUgZmlyc3QgYW5kIGxhc3QgdmVydGljZXMgaGF2ZSBzYW1lIHBvc2l0aW9uIGFuZCBub3JtYWwsIGJ1dCBkaWZmZXJlbnQgdGV4IGNvb3Jkc1xyXG4gICAgICAgIGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPD0gdGhpcy5zZWN0b3JzOyArK2opIHtcclxuICAgICAgICAgIHNlY3RvckFuZ2xlID0gaiAqIHNlY3RvclN0ZXA7XHJcblxyXG4gICAgICAgICAgLy92ZXJ0ZXggcG9zaXRpb25cclxuICAgICAgICAgIHggPSB4eiAqIE1hdGguY29zKHNlY3RvckFuZ2xlKTtcclxuICAgICAgICAgIHogPSB4eiAqIE1hdGguc2luKHNlY3RvckFuZ2xlKTtcclxuICAgICAgICAgIHZlcnRpY2VzLnB1c2goeCwgeSwgeik7XHJcblxyXG4gICAgICAgICAgLy9ub3JtYWxzXHJcbiAgICAgICAgICBub3JtYWxzLnB1c2goeCwgeSwgeik7XHJcblxyXG4gICAgICAgICAgLy9VViBDb29yZHNcclxuICAgICAgICAgIHRleHR1cmVVVnMucHVzaChqIC8gdGhpcy5zZWN0b3JzICogLTEpO1xyXG4gICAgICAgICAgdGV4dHVyZVVWcy5wdXNoKGkgLyB0aGlzLnN0YWNrcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBzY2FsZSBkb3duXHJcbiAgICAgIHZlcnRpY2VzID0gdmVydGljZXMubWFwKF92YWx1ZSA9PiBfdmFsdWUgLyAyKTtcclxuXHJcbiAgICAgIHRoaXMudGV4dHVyZVVWcyA9IG5ldyBGbG9hdDMyQXJyYXkodGV4dHVyZVVWcyk7XHJcbiAgICAgIHRoaXMubm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkobm9ybWFscyk7XHJcbiAgICAgIHRoaXMudmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KHZlcnRpY2VzKTtcclxuICAgICAgdGhpcy5ub3JtYWxzRmFjZSA9IHRoaXMuY3JlYXRlRmFjZU5vcm1hbHMoKTtcclxuICAgICAgdGhpcy5pbmRpY2VzID0gdGhpcy5jcmVhdGVJbmRpY2VzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZUluZGljZXMoKTogVWludDE2QXJyYXkge1xyXG4gICAgICBsZXQgaW5kczogQXJyYXk8bnVtYmVyPiA9IFtdO1xyXG5cclxuICAgICAgbGV0IGsxOiBudW1iZXI7XHJcbiAgICAgIGxldCBrMjogbnVtYmVyO1xyXG5cclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMuc3RhY2tzOyArK2kpIHtcclxuICAgICAgICBrMSA9IGkgKiAodGhpcy5zZWN0b3JzICsgMSk7ICAgLy8gYmVnaW5uaW5nIG9mIGN1cnJlbnQgc3RhY2tcclxuICAgICAgICBrMiA9IGsxICsgdGhpcy5zZWN0b3JzICsgMTsgICAgLy8gYmVnaW5uaW5nIG9mIG5leHQgc3RhY2tcclxuXHJcbiAgICAgICAgZm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IHRoaXMuc2VjdG9yczsgKytqLCArK2sxLCArK2syKSB7XHJcblxyXG4gICAgICAgICAgLy8gMiB0cmlhbmdsZXMgcGVyIHNlY3RvciBleGNsdWRpbmcgZmlyc3QgYW5kIGxhc3Qgc3RhY2tzXHJcbiAgICAgICAgICAvLyBrMSA9PiBrMiA9PiBrMSsxXHJcbiAgICAgICAgICBpZiAoaSAhPSAwKSB7XHJcbiAgICAgICAgICAgIGluZHMucHVzaChrMSk7XHJcbiAgICAgICAgICAgIGluZHMucHVzaChrMSArIDEpO1xyXG4gICAgICAgICAgICBpbmRzLnB1c2goazIpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmIChpICE9ICh0aGlzLnN0YWNrcyAtIDEpKSB7XHJcbiAgICAgICAgICAgIGluZHMucHVzaChrMSArIDEpO1xyXG4gICAgICAgICAgICBpbmRzLnB1c2goazIgKyAxKTtcclxuICAgICAgICAgICAgaW5kcy5wdXNoKGsyKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgbGV0IGluZGljZXM6IFVpbnQxNkFycmF5ID0gbmV3IFVpbnQxNkFycmF5KGluZHMpO1xyXG4gICAgICByZXR1cm4gaW5kaWNlcztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlVmVydGljZXMoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgcmV0dXJuIHRoaXMudmVydGljZXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZVRleHR1cmVVVnMoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZVVWcztcclxuICAgIH1cclxuXHJcbiAgICAvL1RPRE86IHdlIGFsc28gbmVlZCBSRUFMIGZhY2Ugbm9ybWFsc1xyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZUZhY2VOb3JtYWxzKCk6IEZsb2F0MzJBcnJheSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm5vcm1hbHM7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogR2VuZXJhdGUgdHdvIHF1YWRzIHBsYWNlZCBiYWNrIHRvIGJhY2ssIHRoZSBvbmUgZmFjaW5nIGluIG5lZ2F0aXZlIFotZGlyZWN0aW9uIGlzIHRleHR1cmVkIHJldmVyc2VkXHJcbiAgICogYGBgcGxhaW50ZXh0XHJcbiAgICogICAgICAgIDAgX18gM1xyXG4gICAqICAgICAgICAgfF9ffFxyXG4gICAqICAgICAgICAxICAgIDIgICAgICAgICAgICAgXHJcbiAgICogYGBgIFxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIwXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE1lc2hTcHJpdGUgZXh0ZW5kcyBNZXNoIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBNZXNoLnJlZ2lzdGVyU3ViY2xhc3MoTWVzaFNwcml0ZSk7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLmNyZWF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBjcmVhdGUoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMudmVydGljZXMgPSB0aGlzLmNyZWF0ZVZlcnRpY2VzKCk7XHJcbiAgICAgIHRoaXMuaW5kaWNlcyA9IHRoaXMuY3JlYXRlSW5kaWNlcygpO1xyXG4gICAgICB0aGlzLnRleHR1cmVVVnMgPSB0aGlzLmNyZWF0ZVRleHR1cmVVVnMoKTtcclxuICAgICAgdGhpcy5ub3JtYWxzRmFjZSA9IHRoaXMuY3JlYXRlRmFjZU5vcm1hbHMoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlVmVydGljZXMoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgbGV0IHZlcnRpY2VzOiBGbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KFtcclxuICAgICAgICAvKjAqLyAtMSwgMSwgMCwgLyoxKi8gLTEsIC0xLCAwLCAgLyoyKi8gMSwgLTEsIDAsIC8qMyovIDEsIDEsIDBcclxuICAgICAgXSk7XHJcblxyXG4gICAgICB2ZXJ0aWNlcyA9IHZlcnRpY2VzLm1hcChfdmFsdWUgPT4gX3ZhbHVlIC8gMik7XHJcblxyXG4gICAgICByZXR1cm4gdmVydGljZXM7XHJcbiAgICB9XHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlSW5kaWNlcygpOiBVaW50MTZBcnJheSB7XHJcbiAgICAgIGxldCBpbmRpY2VzOiBVaW50MTZBcnJheSA9IG5ldyBVaW50MTZBcnJheShbXHJcbiAgICAgICAgMSwgMiwgMCwgMiwgMywgMCwgLy9mcm9udFxyXG4gICAgICAgIDAsIDMsIDEsIDMsIDIsIDEgIC8vYmFja1xyXG4gICAgICBdKTtcclxuICAgICAgcmV0dXJuIGluZGljZXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZVRleHR1cmVVVnMoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgbGV0IHRleHR1cmVVVnM6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoW1xyXG4gICAgICAgIC8vIGZyb250XHJcbiAgICAgICAgLyowKi8gMCwgMCwgLyoxKi8gMCwgMSwgIC8qMiovIDEsIDEsIC8qMyovIDEsIDBcclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiB0ZXh0dXJlVVZzO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBjcmVhdGVGYWNlTm9ybWFscygpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAgICAgLyowOiBub3JtYWwgb2YgZnJvbnQgZmFjZSovXHJcbiAgICAgICAgMCwgMCwgMSxcclxuICAgICAgICAvKjE6IG5vcm1hbCBvZiBiYWNrIGZhY2UqL1xyXG4gICAgICAgIDAsIDAsIC0xLFxyXG4gICAgICAgIC8qMiovXHJcbiAgICAgICAgMCwgMCwgMCxcclxuICAgICAgICAvKjMqL1xyXG4gICAgICAgIDAsIDAsIDBcclxuICAgICAgXSk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGludGVyZmFjZSBNYXBDbGFzc1RvQ29tcG9uZW50cyB7XHJcbiAgICBbY2xhc3NOYW1lOiBzdHJpbmddOiBDb21wb25lbnRbXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlcHJlc2VudHMgYSBub2RlIGluIHRoZSBzY2VuZXRyZWUuXHJcbiAgICogQGF1dGhvcnMgSmFzY2hhIEthcmFnw7ZsLCBIRlUsIDIwMTkgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBOb2RlIGV4dGVuZHMgRXZlbnRUYXJnZXTGkiBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZSB7XHJcbiAgICBwdWJsaWMgbmFtZTogc3RyaW5nOyAvLyBUaGUgbmFtZSB0byBjYWxsIHRoaXMgbm9kZSBieS5cclxuICAgIHB1YmxpYyBtdHhXb3JsZDogTWF0cml4NHg0ID0gTWF0cml4NHg0LklERU5USVRZKCk7XHJcbiAgICBwdWJsaWMgdGltZXN0YW1wVXBkYXRlOiBudW1iZXIgPSAwO1xyXG5cclxuICAgIHByaXZhdGUgcGFyZW50OiBOb2RlIHwgbnVsbCA9IG51bGw7IC8vIFRoZSBwYXJlbnQgb2YgdGhpcyBub2RlLlxyXG4gICAgcHJpdmF0ZSBjaGlsZHJlbjogTm9kZVtdID0gW107IC8vIGFycmF5IG9mIGNoaWxkIG5vZGVzIGFwcGVuZGVkIHRvIHRoaXMgbm9kZS5cclxuICAgIHByaXZhdGUgY29tcG9uZW50czogTWFwQ2xhc3NUb0NvbXBvbmVudHMgPSB7fTtcclxuICAgIC8vIHByaXZhdGUgdGFnczogc3RyaW5nW10gPSBbXTsgLy8gTmFtZXMgb2YgdGFncyB0aGF0IGFyZSBhdHRhY2hlZCB0byB0aGlzIG5vZGUuIChUT0RPOiBBcyBvZiB5ZXQgbm8gZnVuY3Rpb25hbGl0eSlcclxuICAgIC8vIHByaXZhdGUgbGF5ZXJzOiBzdHJpbmdbXSA9IFtdOyAvLyBOYW1lcyBvZiB0aGUgbGF5ZXJzIHRoaXMgbm9kZSBpcyBvbi4gKFRPRE86IEFzIG9mIHlldCBubyBmdW5jdGlvbmFsaXR5KVxyXG4gICAgcHJpdmF0ZSBsaXN0ZW5lcnM6IE1hcEV2ZW50VHlwZVRvTGlzdGVuZXIgPSB7fTtcclxuICAgIHByaXZhdGUgY2FwdHVyZXM6IE1hcEV2ZW50VHlwZVRvTGlzdGVuZXIgPSB7fTtcclxuICAgIHByaXZhdGUgYWN0aXZlOiBib29sZWFuID0gdHJ1ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgbm9kZSB3aXRoIGEgbmFtZSBhbmQgaW5pdGlhbGl6ZXMgYWxsIGF0dHJpYnV0ZXNcclxuICAgICAqIEBwYXJhbSBfbmFtZSBUaGUgbmFtZSBieSB3aGljaCB0aGUgbm9kZSBjYW4gYmUgY2FsbGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX25hbWU6IHN0cmluZykge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLm5hbWUgPSBfbmFtZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYWN0aXZhdGUoX29uOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuYWN0aXZlID0gX29uO1xyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KF9vbiA/IEVWRU5ULkNPTVBPTkVOVF9BQ1RJVkFURSA6IEVWRU5ULkNPTVBPTkVOVF9ERUFDVElWQVRFKSk7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgZ2V0IGlzQWN0aXZlKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy5hY3RpdmU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoaXMgbm9kZXMgcGFyZW50IG5vZGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFBhcmVudCgpOiBOb2RlIHwgbnVsbCB7XHJcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYWNlcyBiYWNrIHRoZSBhbmNlc3RvcnMgb2YgdGhpcyBub2RlIGFuZCByZXR1cm5zIHRoZSBmaXJzdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0QW5jZXN0b3IoKTogTm9kZSB8IG51bGwge1xyXG4gICAgICBsZXQgYW5jZXN0b3I6IE5vZGUgPSB0aGlzO1xyXG4gICAgICB3aGlsZSAoYW5jZXN0b3IuZ2V0UGFyZW50KCkpXHJcbiAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5nZXRQYXJlbnQoKTtcclxuICAgICAgcmV0dXJuIGFuY2VzdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvcnRjdXQgdG8gcmV0cmlldmUgdGhpcyBub2RlcyBbW0NvbXBvbmVudFRyYW5zZm9ybV1dXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgY21wVHJhbnNmb3JtKCk6IENvbXBvbmVudFRyYW5zZm9ybSB7XHJcbiAgICAgIHJldHVybiA8Q29tcG9uZW50VHJhbnNmb3JtPnRoaXMuZ2V0Q29tcG9uZW50cyhDb21wb25lbnRUcmFuc2Zvcm0pWzBdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG9ydGN1dCB0byByZXRyaWV2ZSB0aGUgbG9jYWwgW1tNYXRyaXg0eDRdXSBhdHRhY2hlZCB0byB0aGlzIG5vZGVzIFtbQ29tcG9uZW50VHJhbnNmb3JtXV0gIFxyXG4gICAgICogUmV0dXJucyBudWxsIGlmIG5vIFtbQ29tcG9uZW50VHJhbnNmb3JtXV0gaXMgYXR0YWNoZWRcclxuICAgICAqL1xyXG4gICAgLy8gVE9ETzogcmVqZWN0ZWQgZm9yIG5vdywgc2luY2UgdGhlcmUgaXMgc29tZSBjb21wdXRhdGlvbmFsIG92ZXJoZWFkLCBzbyBub2RlLm10eExvY2FsIHNob3VsZCBub3QgYmUgdXNlZCBjYXJlbGVzc2x5XHJcbiAgICAvLyBwdWJsaWMgZ2V0IG10eExvY2FsKCk6IE1hdHJpeDR4NCB7XHJcbiAgICAvLyAgICAgbGV0IGNtcFRyYW5zZm9ybTogQ29tcG9uZW50VHJhbnNmb3JtID0gdGhpcy5jbXBUcmFuc2Zvcm07XHJcbiAgICAvLyAgICAgaWYgKGNtcFRyYW5zZm9ybSlcclxuICAgIC8vICAgICAgICAgcmV0dXJuIGNtcFRyYW5zZm9ybS5sb2NhbDtcclxuICAgIC8vICAgICBlbHNlXHJcbiAgICAvLyAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIC8vICNyZWdpb24gU2NlbmV0cmVlXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgbGlzdCBvZiBjaGlsZHJlblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Q2hpbGRyZW4oKTogTm9kZVtdIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4uc2xpY2UoMCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgcmVmZXJlbmNlcyB0byBjaGlsZG5vZGVzIHdpdGggdGhlIHN1cHBsaWVkIG5hbWUuIFxyXG4gICAgICogQHBhcmFtIF9uYW1lIFRoZSBuYW1lIG9mIHRoZSBub2RlcyB0byBiZSBmb3VuZC5cclxuICAgICAqIEByZXR1cm4gQW4gYXJyYXkgd2l0aCByZWZlcmVuY2VzIHRvIG5vZGVzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRDaGlsZHJlbkJ5TmFtZShfbmFtZTogc3RyaW5nKTogTm9kZVtdIHtcclxuICAgICAgbGV0IGZvdW5kOiBOb2RlW10gPSBbXTtcclxuICAgICAgZm91bmQgPSB0aGlzLmNoaWxkcmVuLmZpbHRlcigoX25vZGU6IE5vZGUpID0+IF9ub2RlLm5hbWUgPT0gX25hbWUpO1xyXG4gICAgICByZXR1cm4gZm91bmQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaW1wbHkgY2FsbHMgW1thZGRDaGlsZF1dLiBUaGlzIHJlZmVyZW5jZSBpcyBoZXJlIHNvbGVseSBiZWNhdXNlIGFwcGVuZENoaWxkIGlzIHRoZSBlcXVpdmFsZW50IG1ldGhvZCBpbiBET00uXHJcbiAgICAgKiBTZWUgYW5kIHByZWZlcmFibHkgdXNlIFtbYWRkQ2hpbGRdXVxyXG4gICAgICovXHJcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG1lbWJlci1vcmRlcmluZ1xyXG4gICAgcHVibGljIHJlYWRvbmx5IGFwcGVuZENoaWxkOiAoX25vZGU6IE5vZGUpID0+IHZvaWQgPSB0aGlzLmFkZENoaWxkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgZ2l2ZW4gcmVmZXJlbmNlIHRvIGEgbm9kZSB0byB0aGUgbGlzdCBvZiBjaGlsZHJlbiwgaWYgbm90IGFscmVhZHkgaW5cclxuICAgICAqIEBwYXJhbSBfbm9kZSBUaGUgbm9kZSB0byBiZSBhZGRlZCBhcyBhIGNoaWxkXHJcbiAgICAgKiBAdGhyb3dzIEVycm9yIHdoZW4gdHJ5aW5nIHRvIGFkZCBhbiBhbmNlc3RvciBvZiB0aGlzIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWRkQ2hpbGQoX25vZGU6IE5vZGUpOiB2b2lkIHtcclxuICAgICAgaWYgKHRoaXMuY2hpbGRyZW4uaW5jbHVkZXMoX25vZGUpKVxyXG4gICAgICAgIC8vIF9ub2RlIGlzIGFscmVhZHkgYSBjaGlsZCBvZiB0aGlzXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgbGV0IGluQXVkaW9CcmFuY2g6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgICAgbGV0IGJyYW5jaExpc3RlbmVkOiBOb2RlID0gQXVkaW9NYW5hZ2VyLmRlZmF1bHQuZ2V0QnJhbmNoTGlzdGVuaW5nVG8oKTtcclxuICAgICAgbGV0IGFuY2VzdG9yOiBOb2RlID0gdGhpcztcclxuICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XHJcbiAgICAgICAgYW5jZXN0b3IudGltZXN0YW1wVXBkYXRlID0gMDtcclxuICAgICAgICBpbkF1ZGlvQnJhbmNoID0gaW5BdWRpb0JyYW5jaCB8fCAoYW5jZXN0b3IgPT0gYnJhbmNoTGlzdGVuZWQpO1xyXG4gICAgICAgIGlmIChhbmNlc3RvciA9PSBfbm9kZSlcclxuICAgICAgICAgIHRocm93IChuZXcgRXJyb3IoXCJDeWNsaWMgcmVmZXJlbmNlIHByb2hpYml0ZWQgaW4gbm9kZSBoaWVyYXJjaHksIGFuY2VzdG9ycyBtdXN0IG5vdCBiZSBhZGRlZCBhcyBjaGlsZHJlblwiKSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBwcmV2aW91c1BhcmVudDogTm9kZSA9IF9ub2RlLnBhcmVudDtcclxuICAgICAgaWYgKHByZXZpb3VzUGFyZW50KVxyXG4gICAgICAgIHByZXZpb3VzUGFyZW50LnJlbW92ZUNoaWxkKF9ub2RlKTtcclxuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKF9ub2RlKTtcclxuICAgICAgX25vZGUucGFyZW50ID0gdGhpcztcclxuICAgICAgX25vZGUuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuQ0hJTERfQVBQRU5ELCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xyXG4gICAgICBpZiAoaW5BdWRpb0JyYW5jaClcclxuICAgICAgICBfbm9kZS5icm9hZGNhc3RFdmVudChuZXcgRXZlbnQoRVZFTlRfQVVESU8uQ0hJTERfQVBQRU5EKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSByZWZlcmVuY2UgdG8gdGhlIGdpdmUgbm9kZSBmcm9tIHRoZSBsaXN0IG9mIGNoaWxkcmVuXHJcbiAgICAgKiBAcGFyYW0gX25vZGUgVGhlIG5vZGUgdG8gYmUgcmVtb3ZlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlbW92ZUNoaWxkKF9ub2RlOiBOb2RlKTogdm9pZCB7XHJcbiAgICAgIGxldCBmb3VuZDogbnVtYmVyID0gdGhpcy5maW5kQ2hpbGQoX25vZGUpO1xyXG4gICAgICBpZiAoZm91bmQgPCAwKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIF9ub2RlLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULkNISUxEX1JFTU9WRSwgeyBidWJibGVzOiB0cnVlIH0pKTtcclxuICAgICAgaWYgKHRoaXMuaXNEZXNjZW5kYW50T2YoQXVkaW9NYW5hZ2VyLmRlZmF1bHQuZ2V0QnJhbmNoTGlzdGVuaW5nVG8oKSkpXHJcbiAgICAgICAgX25vZGUuYnJvYWRjYXN0RXZlbnQobmV3IEV2ZW50KEVWRU5UX0FVRElPLkNISUxEX1JFTU9WRSkpO1xyXG4gICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShmb3VuZCwgMSk7XHJcbiAgICAgIF9ub2RlLnBhcmVudCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgbm9kZSBpbiB0aGUgbGlzdCBvZiBjaGlsZHJlbiBvciAtMSBpZiBub3QgZm91bmRcclxuICAgICAqIEBwYXJhbSBfbm9kZSBUaGUgbm9kZSB0byBiZSBmb3VuZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGZpbmRDaGlsZChfbm9kZTogTm9kZSk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmluZGV4T2YoX25vZGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVwbGFjZXMgYSBjaGlsZCBub2RlIHdpdGggYW5vdGhlciwgcHJlc2VydmluZyB0aGUgcG9zaXRpb24gaW4gdGhlIGxpc3Qgb2YgY2hpbGRyZW5cclxuICAgICAqIEBwYXJhbSBfcmVwbGFjZSBUaGUgbm9kZSB0byBiZSByZXBsYWNlZFxyXG4gICAgICogQHBhcmFtIF93aXRoIFRoZSBub2RlIHRvIHJlcGxhY2Ugd2l0aFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVwbGFjZUNoaWxkKF9yZXBsYWNlOiBOb2RlLCBfd2l0aDogTm9kZSk6IGJvb2xlYW4ge1xyXG4gICAgICBsZXQgZm91bmQ6IG51bWJlciA9IHRoaXMuZmluZENoaWxkKF9yZXBsYWNlKTtcclxuICAgICAgaWYgKGZvdW5kIDwgMClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICBsZXQgcHJldmlvdXNQYXJlbnQ6IE5vZGUgPSBfd2l0aC5nZXRQYXJlbnQoKTtcclxuICAgICAgaWYgKHByZXZpb3VzUGFyZW50KVxyXG4gICAgICAgIHByZXZpb3VzUGFyZW50LnJlbW92ZUNoaWxkKF93aXRoKTtcclxuXHJcbiAgICAgIF9yZXBsYWNlLnBhcmVudCA9IG51bGw7XHJcbiAgICAgIHRoaXMuY2hpbGRyZW5bZm91bmRdID0gX3dpdGg7XHJcbiAgICAgIF93aXRoLnBhcmVudCA9IHRoaXM7XHJcblxyXG4gICAgICBfd2l0aC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVC5DSElMRF9BUFBFTkQsIHsgYnViYmxlczogdHJ1ZSB9KSk7XHJcbiAgICAgIGlmICh0aGlzLmlzRGVzY2VuZGFudE9mKEF1ZGlvTWFuYWdlci5kZWZhdWx0LmdldEJyYW5jaExpc3RlbmluZ1RvKCkpKVxyXG4gICAgICAgIF93aXRoLmJyb2FkY2FzdEV2ZW50KG5ldyBFdmVudChFVkVOVF9BVURJTy5DSElMRF9BUFBFTkQpKTtcclxuXHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdG9yIHlpZWxkaW5nIHRoZSBub2RlIGFuZCBhbGwgc3VjY2Vzc29ycyBpbiB0aGUgYnJhbmNoIGJlbG93IGZvciBpdGVyYXRpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBicmFuY2goKTogSXRlcmFibGVJdGVyYXRvcjxOb2RlPiB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldEJyYW5jaEdlbmVyYXRvcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBpc1VwZGF0ZWQoX3RpbWVzdGFtcFVwZGF0ZTogbnVtYmVyKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiAodGhpcy50aW1lc3RhbXBVcGRhdGUgPT0gX3RpbWVzdGFtcFVwZGF0ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGlzRGVzY2VuZGFudE9mKF9hbmNlc3RvcjogTm9kZSk6IGJvb2xlYW4ge1xyXG4gICAgICBsZXQgbm9kZTogTm9kZSA9IHRoaXM7XHJcbiAgICAgIHdoaWxlIChub2RlICYmIG5vZGUgIT0gX2FuY2VzdG9yKVxyXG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcclxuICAgICAgcmV0dXJuIChub2RlICE9IG51bGwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyBhIE11dGF0b3IgZnJvbSBbW0FuaW1hdGlvbl1dIHRvIGFsbCBpdHMgY29tcG9uZW50cyBhbmQgdHJhbnNmZXJzIGl0IHRvIGl0cyBjaGlsZHJlbi5cclxuICAgICAqIEBwYXJhbSBfbXV0YXRvciBUaGUgbXV0YXRvciBnZW5lcmF0ZWQgZnJvbSBhbiBbW0FuaW1hdGlvbl1dXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhcHBseUFuaW1hdGlvbihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICBpZiAoX211dGF0b3IuY29tcG9uZW50cykge1xyXG4gICAgICAgIGZvciAobGV0IGNvbXBvbmVudE5hbWUgaW4gX211dGF0b3IuY29tcG9uZW50cykge1xyXG4gICAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50c1tjb21wb25lbnROYW1lXSkge1xyXG4gICAgICAgICAgICBsZXQgbXV0YXRvck9mQ29tcG9uZW50OiBNdXRhdG9yID0gPE11dGF0b3I+X211dGF0b3IuY29tcG9uZW50cztcclxuICAgICAgICAgICAgZm9yIChsZXQgaSBpbiBtdXRhdG9yT2ZDb21wb25lbnRbY29tcG9uZW50TmFtZV0pIHtcclxuICAgICAgICAgICAgICBpZiAodGhpcy5jb21wb25lbnRzW2NvbXBvbmVudE5hbWVdWytpXSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvbXBvbmVudFRvTXV0YXRlOiBDb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudHNbY29tcG9uZW50TmFtZV1bK2ldO1xyXG4gICAgICAgICAgICAgICAgbGV0IG11dGF0b3JBcnJheTogTXV0YXRvcltdID0gKDxBcnJheTxNdXRhdG9yPj5tdXRhdG9yT2ZDb21wb25lbnRbY29tcG9uZW50TmFtZV0pO1xyXG4gICAgICAgICAgICAgICAgbGV0IG11dGF0b3JXaXRoQ29tcG9uZW50TmFtZTogTXV0YXRvciA9IDxNdXRhdG9yPm11dGF0b3JBcnJheVsraV07XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjbmFtZSBpbiBtdXRhdG9yV2l0aENvbXBvbmVudE5hbWUpIHsgICAvLyB0cmljayB1c2VkIHRvIGdldCB0aGUgb25seSBlbnRyeSBpbiB0aGUgbGlzdFxyXG4gICAgICAgICAgICAgICAgICBsZXQgbXV0YXRvclRvR2l2ZTogTXV0YXRvciA9IDxNdXRhdG9yPm11dGF0b3JXaXRoQ29tcG9uZW50TmFtZVtjbmFtZV07XHJcbiAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFRvTXV0YXRlLm11dGF0ZShtdXRhdG9yVG9HaXZlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKF9tdXRhdG9yLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8ICg8QXJyYXk8T2JqZWN0Pj5fbXV0YXRvci5jaGlsZHJlbikubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGxldCBuYW1lOiBzdHJpbmcgPSAoPE5vZGU+KDxBcnJheTxNdXRhdG9yPj5fbXV0YXRvci5jaGlsZHJlbilbaV1bXCLGki5Ob2RlXCJdKS5uYW1lO1xyXG4gICAgICAgICAgbGV0IGNoaWxkTm9kZXM6IE5vZGVbXSA9IHRoaXMuZ2V0Q2hpbGRyZW5CeU5hbWUobmFtZSk7XHJcbiAgICAgICAgICBmb3IgKGxldCBjaGlsZE5vZGUgb2YgY2hpbGROb2Rlcykge1xyXG4gICAgICAgICAgICBjaGlsZE5vZGUuYXBwbHlBbmltYXRpb24oPE11dGF0b3I+KDxBcnJheTxNdXRhdG9yPj5fbXV0YXRvci5jaGlsZHJlbilbaV1bXCLGki5Ob2RlXCJdKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vICNlbmRyZWdpb25cclxuXHJcbiAgICAvLyAjcmVnaW9uIENvbXBvbmVudHNcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgYWxsIGNvbXBvbmVudHMgYXR0YWNoZWQgdG8gdGhpcyBub2RlLCBpbmRlcGVuZGVudCBvZiB0eXBlLiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEFsbENvbXBvbmVudHMoKTogQ29tcG9uZW50W10ge1xyXG4gICAgICBsZXQgYWxsOiBDb21wb25lbnRbXSA9IFtdO1xyXG4gICAgICBmb3IgKGxldCB0eXBlIGluIHRoaXMuY29tcG9uZW50cykge1xyXG4gICAgICAgIGFsbCA9IGFsbC5jb25jYXQodGhpcy5jb21wb25lbnRzW3R5cGVdKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBsaXN0IG9mIGNvbXBvbmVudHMgb2YgdGhlIGdpdmVuIGNsYXNzIGF0dGFjaGVkIHRvIHRoaXMgbm9kZS4gXHJcbiAgICAgKiBAcGFyYW0gX2NsYXNzIFRoZSBjbGFzcyBvZiB0aGUgY29tcG9uZW50cyB0byBiZSBmb3VuZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldENvbXBvbmVudHM8VCBleHRlbmRzIENvbXBvbmVudD4oX2NsYXNzOiBuZXcgKCkgPT4gVCk6IFRbXSB7XHJcbiAgICAgIHJldHVybiA8VFtdPih0aGlzLmNvbXBvbmVudHNbX2NsYXNzLm5hbWVdIHx8IFtdKS5zbGljZSgwKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgY29tcG9udGVudCBmb3VuZCBvZiB0aGUgZ2l2ZW4gY2xhc3MgYXR0YWNoZWQgdGhpcyBub2RlIG9yIG51bGwsIGlmIGxpc3QgaXMgZW1wdHkgb3IgZG9lc24ndCBleGlzdFxyXG4gICAgICogQHBhcmFtIF9jbGFzcyBUaGUgY2xhc3Mgb2YgdGhlIGNvbXBvbmVudHMgdG8gYmUgZm91bmQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRDb21wb25lbnQ8VCBleHRlbmRzIENvbXBvbmVudD4oX2NsYXNzOiBuZXcgKCkgPT4gVCk6IFQge1xyXG4gICAgICBsZXQgbGlzdDogVFtdID0gPFRbXT50aGlzLmNvbXBvbmVudHNbX2NsYXNzLm5hbWVdO1xyXG4gICAgICBpZiAobGlzdClcclxuICAgICAgICByZXR1cm4gbGlzdFswXTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHRoZSBzdXBwbGllZCBjb21wb25lbnQgaW50byB0aGUgbm9kZXMgY29tcG9uZW50IG1hcC5cclxuICAgICAqIEBwYXJhbSBfY29tcG9uZW50IFRoZSBjb21wb25lbnQgdG8gYmUgcHVzaGVkIGludG8gdGhlIGFycmF5LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWRkQ29tcG9uZW50KF9jb21wb25lbnQ6IENvbXBvbmVudCk6IHZvaWQge1xyXG4gICAgICBpZiAoX2NvbXBvbmVudC5nZXRDb250YWluZXIoKSA9PSB0aGlzKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgaWYgKHRoaXMuY29tcG9uZW50c1tfY29tcG9uZW50LnR5cGVdID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgdGhpcy5jb21wb25lbnRzW19jb21wb25lbnQudHlwZV0gPSBbX2NvbXBvbmVudF07XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBpZiAoX2NvbXBvbmVudC5pc1NpbmdsZXRvbilcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbXBvbmVudCBpcyBtYXJrZWQgc2luZ2xldG9uIGFuZCBjYW4ndCBiZSBhdHRhY2hlZCwgbm8gbW9yZSB0aGFuIG9uZSBhbGxvd2VkXCIpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIHRoaXMuY29tcG9uZW50c1tfY29tcG9uZW50LnR5cGVdLnB1c2goX2NvbXBvbmVudCk7XHJcblxyXG4gICAgICBfY29tcG9uZW50LnNldENvbnRhaW5lcih0aGlzKTtcclxuICAgICAgX2NvbXBvbmVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVC5DT01QT05FTlRfQUREKSk7XHJcbiAgICB9XHJcbiAgICAvKiogXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBjb21wb25lbnQgZnJvbSB0aGUgbm9kZSwgaWYgaXQgd2FzIGF0dGFjaGVkLCBhbmQgc2V0cyBpdHMgcGFyZW50IHRvIG51bGwuIFxyXG4gICAgICogQHBhcmFtIF9jb21wb25lbnQgVGhlIGNvbXBvbmVudCB0byBiZSByZW1vdmVkXHJcbiAgICAgKiBAdGhyb3dzIEV4Y2VwdGlvbiB3aGVuIGNvbXBvbmVudCBpcyBub3QgZm91bmRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlbW92ZUNvbXBvbmVudChfY29tcG9uZW50OiBDb21wb25lbnQpOiB2b2lkIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBsZXQgY29tcG9uZW50c09mVHlwZTogQ29tcG9uZW50W10gPSB0aGlzLmNvbXBvbmVudHNbX2NvbXBvbmVudC50eXBlXTtcclxuICAgICAgICBsZXQgZm91bmRBdDogbnVtYmVyID0gY29tcG9uZW50c09mVHlwZS5pbmRleE9mKF9jb21wb25lbnQpO1xyXG4gICAgICAgIGlmIChmb3VuZEF0IDwgMClcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBfY29tcG9uZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULkNPTVBPTkVOVF9SRU1PVkUpKTtcclxuICAgICAgICBjb21wb25lbnRzT2ZUeXBlLnNwbGljZShmb3VuZEF0LCAxKTtcclxuICAgICAgICBfY29tcG9uZW50LnNldENvbnRhaW5lcihudWxsKTtcclxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gcmVtb3ZlIGNvbXBvbmVudCAnJHtfY29tcG9uZW50fSdpbiBub2RlIG5hbWVkICcke3RoaXMubmFtZX0nYCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vICNlbmRyZWdpb25cclxuXHJcbiAgICAvLyAjcmVnaW9uIFNlcmlhbGl6YXRpb25cclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge1xyXG4gICAgICAgIG5hbWU6IHRoaXMubmFtZVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgbGV0IGNvbXBvbmVudHM6IFNlcmlhbGl6YXRpb24gPSB7fTtcclxuICAgICAgZm9yIChsZXQgdHlwZSBpbiB0aGlzLmNvbXBvbmVudHMpIHtcclxuICAgICAgICBjb21wb25lbnRzW3R5cGVdID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgY29tcG9uZW50IG9mIHRoaXMuY29tcG9uZW50c1t0eXBlXSkge1xyXG4gICAgICAgICAgLy8gY29tcG9uZW50c1t0eXBlXS5wdXNoKGNvbXBvbmVudC5zZXJpYWxpemUoKSk7XHJcbiAgICAgICAgICBjb21wb25lbnRzW3R5cGVdLnB1c2goU2VyaWFsaXplci5zZXJpYWxpemUoY29tcG9uZW50KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHNlcmlhbGl6YXRpb25bXCJjb21wb25lbnRzXCJdID0gY29tcG9uZW50cztcclxuXHJcbiAgICAgIGxldCBjaGlsZHJlbjogU2VyaWFsaXphdGlvbltdID0gW107XHJcbiAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcclxuICAgICAgICBjaGlsZHJlbi5wdXNoKFNlcmlhbGl6ZXIuc2VyaWFsaXplKGNoaWxkKSk7XHJcbiAgICAgIH1cclxuICAgICAgc2VyaWFsaXphdGlvbltcImNoaWxkcmVuXCJdID0gY2hpbGRyZW47XHJcblxyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULk5PREVfU0VSSUFMSVpFRCkpO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBTZXJpYWxpemFibGUge1xyXG4gICAgICB0aGlzLm5hbWUgPSBfc2VyaWFsaXphdGlvbi5uYW1lO1xyXG4gICAgICAvLyB0aGlzLnBhcmVudCA9IGlzIHNldCB3aGVuIHRoZSBub2RlcyBhcmUgYWRkZWRcclxuXHJcbiAgICAgIC8vIGRlc2VyaWFsaXplIGNvbXBvbmVudHMgZmlyc3Qgc28gc2NyaXB0cyBjYW4gcmVhY3QgdG8gY2hpbGRyZW4gYmVpbmcgYXBwZW5kZWRcclxuICAgICAgZm9yIChsZXQgdHlwZSBpbiBfc2VyaWFsaXphdGlvbi5jb21wb25lbnRzKSB7XHJcbiAgICAgICAgZm9yIChsZXQgc2VyaWFsaXplZENvbXBvbmVudCBvZiBfc2VyaWFsaXphdGlvbi5jb21wb25lbnRzW3R5cGVdKSB7XHJcbiAgICAgICAgICBsZXQgZGVzZXJpYWxpemVkQ29tcG9uZW50OiBDb21wb25lbnQgPSA8Q29tcG9uZW50PlNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoc2VyaWFsaXplZENvbXBvbmVudCk7XHJcbiAgICAgICAgICB0aGlzLmFkZENvbXBvbmVudChkZXNlcmlhbGl6ZWRDb21wb25lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yIChsZXQgc2VyaWFsaXplZENoaWxkIG9mIF9zZXJpYWxpemF0aW9uLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgbGV0IGRlc2VyaWFsaXplZENoaWxkOiBOb2RlID0gPE5vZGU+U2VyaWFsaXplci5kZXNlcmlhbGl6ZShzZXJpYWxpemVkQ2hpbGQpO1xyXG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoZGVzZXJpYWxpemVkQ2hpbGQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULk5PREVfREVTRVJJQUxJWkVEKSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLy8gI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vICNyZWdpb24gRXZlbnRzXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgdG8gdGhlIG5vZGUuIFRoZSBnaXZlbiBoYW5kbGVyIHdpbGwgYmUgY2FsbGVkIHdoZW4gYSBtYXRjaGluZyBldmVudCBpcyBwYXNzZWQgdG8gdGhlIG5vZGUuXHJcbiAgICAgKiBEZXZpYXRpbmcgZnJvbSB0aGUgc3RhbmRhcmQgRXZlbnRUYXJnZXQsIGhlcmUgdGhlIF9oYW5kbGVyIG11c3QgYmUgYSBmdW5jdGlvbiBhbmQgX2NhcHR1cmUgaXMgdGhlIG9ubHkgb3B0aW9uLlxyXG4gICAgICogQHBhcmFtIF90eXBlIFRoZSB0eXBlIG9mIHRoZSBldmVudCwgc2hvdWxkIGJlIGFuIGVudW1lcmF0ZWQgdmFsdWUgb2YgTk9ERV9FVkVOVCwgY2FuIGJlIGFueSBzdHJpbmdcclxuICAgICAqIEBwYXJhbSBfaGFuZGxlciBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBldmVudCByZWFjaGVzIHRoaXMgbm9kZVxyXG4gICAgICogQHBhcmFtIF9jYXB0dXJlIFdoZW4gdHJ1ZSwgdGhlIGxpc3RlbmVyIGxpc3RlbnMgaW4gdGhlIGNhcHR1cmUgcGhhc2UsIHdoZW4gdGhlIGV2ZW50IHRyYXZlbHMgZGVlcGVyIGludG8gdGhlIGhpZXJhcmNoeSBvZiBub2Rlcy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFkZEV2ZW50TGlzdGVuZXIoX3R5cGU6IEVWRU5UIHwgc3RyaW5nLCBfaGFuZGxlcjogRXZlbnRMaXN0ZW5lciwgX2NhcHR1cmU6IGJvb2xlYW4gLyp8IEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zKi8gPSBmYWxzZSk6IHZvaWQge1xyXG4gICAgICBsZXQgbGlzdExpc3RlbmVyczogTWFwRXZlbnRUeXBlVG9MaXN0ZW5lciA9IF9jYXB0dXJlID8gdGhpcy5jYXB0dXJlcyA6IHRoaXMubGlzdGVuZXJzO1xyXG4gICAgICBpZiAoIWxpc3RMaXN0ZW5lcnNbX3R5cGVdKVxyXG4gICAgICAgIGxpc3RMaXN0ZW5lcnNbX3R5cGVdID0gW107XHJcbiAgICAgIGxpc3RMaXN0ZW5lcnNbX3R5cGVdLnB1c2goX2hhbmRsZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGFuIGV2ZW50IGxpc3RlbmVyIGZyb20gdGhlIG5vZGUuIFRoZSBzaWduYXR1ciBtdXN0IG1hdGNoIHRoZSBvbmUgdXNlZCB3aXRoIGFkZEV2ZW50TGlzdGVuZXJcclxuICAgICAqIEBwYXJhbSBfdHlwZSBUaGUgdHlwZSBvZiB0aGUgZXZlbnQsIHNob3VsZCBiZSBhbiBlbnVtZXJhdGVkIHZhbHVlIG9mIE5PREVfRVZFTlQsIGNhbiBiZSBhbnkgc3RyaW5nXHJcbiAgICAgKiBAcGFyYW0gX2hhbmRsZXIgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgZXZlbnQgcmVhY2hlcyB0aGlzIG5vZGVcclxuICAgICAqIEBwYXJhbSBfY2FwdHVyZSBXaGVuIHRydWUsIHRoZSBsaXN0ZW5lciBsaXN0ZW5zIGluIHRoZSBjYXB0dXJlIHBoYXNlLCB3aGVuIHRoZSBldmVudCB0cmF2ZWxzIGRlZXBlciBpbnRvIHRoZSBoaWVyYXJjaHkgb2Ygbm9kZXMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZW1vdmVFdmVudExpc3RlbmVyKF90eXBlOiBFVkVOVCB8IHN0cmluZywgX2hhbmRsZXI6IEV2ZW50TGlzdGVuZXIsIF9jYXB0dXJlOiBib29sZWFuIC8qfCBBZGRFdmVudExpc3RlbmVyT3B0aW9ucyovID0gZmFsc2UpOiB2b2lkIHtcclxuICAgICAgbGV0IGxpc3RlbmVyc0ZvclR5cGU6IEV2ZW50TGlzdGVuZXJbXSA9IF9jYXB0dXJlID8gdGhpcy5jYXB0dXJlc1tfdHlwZV0gOiB0aGlzLmxpc3RlbmVyc1tfdHlwZV07XHJcbiAgICAgIGlmIChsaXN0ZW5lcnNGb3JUeXBlKVxyXG4gICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IGxpc3RlbmVyc0ZvclR5cGUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXHJcbiAgICAgICAgICBpZiAobGlzdGVuZXJzRm9yVHlwZVtpXSA9PSBfaGFuZGxlcilcclxuICAgICAgICAgICAgbGlzdGVuZXJzRm9yVHlwZS5zcGxpY2UoaSwgMSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERpc3BhdGNoZXMgYSBzeW50aGV0aWMgZXZlbnQgdG8gdGFyZ2V0LiBUaGlzIGltcGxlbWVudGF0aW9uIGFsd2F5cyByZXR1cm5zIHRydWUgKHN0YW5kYXJkOiByZXR1cm4gdHJ1ZSBvbmx5IGlmIGVpdGhlciBldmVudCdzIGNhbmNlbGFibGUgYXR0cmlidXRlIHZhbHVlIGlzIGZhbHNlIG9yIGl0cyBwcmV2ZW50RGVmYXVsdCgpIG1ldGhvZCB3YXMgbm90IGludm9rZWQpXHJcbiAgICAgKiBUaGUgZXZlbnQgdHJhdmVscyBpbnRvIHRoZSBoaWVyYXJjaHkgdG8gdGhpcyBub2RlIGRpc3BhdGNoaW5nIHRoZSBldmVudCwgaW52b2tpbmcgbWF0Y2hpbmcgaGFuZGxlcnMgb2YgdGhlIG5vZGVzIGFuY2VzdG9ycyBsaXN0ZW5pbmcgdG8gdGhlIGNhcHR1cmUgcGhhc2UsIFxyXG4gICAgICogdGhhbiB0aGUgbWF0Y2hpbmcgaGFuZGxlciBvZiB0aGUgdGFyZ2V0IG5vZGUgaW4gdGhlIHRhcmdldCBwaGFzZSwgYW5kIGJhY2sgb3V0IG9mIHRoZSBoaWVyYXJjaHkgaW4gdGhlIGJ1YmJsaW5nIHBoYXNlLCBpbnZva2luZyBhcHByb3ByaWF0ZSBoYW5kbGVycyBvZiB0aGUgYW52ZXN0b3JzXHJcbiAgICAgKiBAcGFyYW0gX2V2ZW50IFRoZSBldmVudCB0byBkaXNwYXRjaFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZGlzcGF0Y2hFdmVudChfZXZlbnQ6IEV2ZW50KTogYm9vbGVhbiB7XHJcbiAgICAgIGxldCBhbmNlc3RvcnM6IE5vZGVbXSA9IFtdO1xyXG4gICAgICBsZXQgdXBjb21pbmc6IE5vZGUgPSB0aGlzO1xyXG4gICAgICAvLyBvdmVyd3JpdGUgZXZlbnQgdGFyZ2V0XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXZlbnQsIFwidGFyZ2V0XCIsIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB0aGlzIH0pO1xyXG4gICAgICAvLyBUT0RPOiBjb25zaWRlciB1c2luZyBSZWZsZWN0IGluc3RlYWQgb2YgT2JqZWN0IHRocm91Z2hvdXQuIFNlZSBhbHNvIFJlbmRlciBhbmQgTXV0YWJsZS4uLlxyXG4gICAgICB3aGlsZSAodXBjb21pbmcucGFyZW50KVxyXG4gICAgICAgIGFuY2VzdG9ycy5wdXNoKHVwY29taW5nID0gdXBjb21pbmcucGFyZW50KTtcclxuXHJcbiAgICAgIC8vIGNhcHR1cmUgcGhhc2VcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9ldmVudCwgXCJldmVudFBoYXNlXCIsIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBFdmVudC5DQVBUVVJJTkdfUEhBU0UgfSk7XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IGFuY2VzdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgIGxldCBhbmNlc3RvcjogTm9kZSA9IGFuY2VzdG9yc1tpXTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V2ZW50LCBcImN1cnJlbnRUYXJnZXRcIiwgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGFuY2VzdG9yIH0pO1xyXG4gICAgICAgIGxldCBjYXB0dXJlczogRXZlbnRMaXN0ZW5lcltdID0gYW5jZXN0b3IuY2FwdHVyZXNbX2V2ZW50LnR5cGVdIHx8IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGhhbmRsZXIgb2YgY2FwdHVyZXMpXHJcbiAgICAgICAgICBoYW5kbGVyKF9ldmVudCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghX2V2ZW50LmJ1YmJsZXMpXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAvLyB0YXJnZXQgcGhhc2VcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9ldmVudCwgXCJldmVudFBoYXNlXCIsIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBFdmVudC5BVF9UQVJHRVQgfSk7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXZlbnQsIFwiY3VycmVudFRhcmdldFwiLCB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogdGhpcyB9KTtcclxuICAgICAgbGV0IGxpc3RlbmVyczogRXZlbnRMaXN0ZW5lcltdID0gdGhpcy5saXN0ZW5lcnNbX2V2ZW50LnR5cGVdIHx8IFtdO1xyXG4gICAgICBmb3IgKGxldCBoYW5kbGVyIG9mIGxpc3RlbmVycylcclxuICAgICAgICBoYW5kbGVyKF9ldmVudCk7XHJcblxyXG4gICAgICAvLyBidWJibGUgcGhhc2VcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9ldmVudCwgXCJldmVudFBoYXNlXCIsIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBFdmVudC5CVUJCTElOR19QSEFTRSB9KTtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IGFuY2VzdG9ycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCBhbmNlc3RvcjogTm9kZSA9IGFuY2VzdG9yc1tpXTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V2ZW50LCBcImN1cnJlbnRUYXJnZXRcIiwgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGFuY2VzdG9yIH0pO1xyXG4gICAgICAgIGxldCBsaXN0ZW5lcnM6IEZ1bmN0aW9uW10gPSBhbmNlc3Rvci5saXN0ZW5lcnNbX2V2ZW50LnR5cGVdIHx8IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGhhbmRsZXIgb2YgbGlzdGVuZXJzKVxyXG4gICAgICAgICAgaGFuZGxlcihfZXZlbnQpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cnVlOyAvL1RPRE86IHJldHVybiBhIG1lYW5pbmdmdWwgdmFsdWUsIHNlZSBkb2N1bWVudGF0aW9uIG9mIGRpc3BhdGNoIGV2ZW50XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJyb2FkY2FzdHMgYSBzeW50aGV0aWMgZXZlbnQgdG8gdGhpcyBub2RlIGFuZCBmcm9tIHRoZXJlIHRvIGFsbCBub2RlcyBkZWVwZXIgaW4gdGhlIGhpZXJhcmNoeSxcclxuICAgICAqIGludm9raW5nIG1hdGNoaW5nIGhhbmRsZXJzIG9mIHRoZSBub2RlcyBsaXN0ZW5pbmcgdG8gdGhlIGNhcHR1cmUgcGhhc2UuIFdhdGNoIHBlcmZvcm1hbmNlIHdoZW4gdGhlcmUgYXJlIG1hbnkgbm9kZXMgaW52b2x2ZWRcclxuICAgICAqIEBwYXJhbSBfZXZlbnQgVGhlIGV2ZW50IHRvIGJyb2FkY2FzdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYnJvYWRjYXN0RXZlbnQoX2V2ZW50OiBFdmVudCk6IHZvaWQge1xyXG4gICAgICAvLyBvdmVyd3JpdGUgZXZlbnQgdGFyZ2V0IGFuZCBwaGFzZVxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V2ZW50LCBcImV2ZW50UGhhc2VcIiwgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IEV2ZW50LkNBUFRVUklOR19QSEFTRSB9KTtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9ldmVudCwgXCJ0YXJnZXRcIiwgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHRoaXMgfSk7XHJcbiAgICAgIHRoaXMuYnJvYWRjYXN0RXZlbnRSZWN1cnNpdmUoX2V2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGJyb2FkY2FzdEV2ZW50UmVjdXJzaXZlKF9ldmVudDogRXZlbnQpOiB2b2lkIHtcclxuICAgICAgLy8gY2FwdHVyZSBwaGFzZSBvbmx5XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXZlbnQsIFwiY3VycmVudFRhcmdldFwiLCB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogdGhpcyB9KTtcclxuICAgICAgbGV0IGNhcHR1cmVzOiBGdW5jdGlvbltdID0gdGhpcy5jYXB0dXJlc1tfZXZlbnQudHlwZV0gfHwgW107XHJcbiAgICAgIGZvciAobGV0IGhhbmRsZXIgb2YgY2FwdHVyZXMpXHJcbiAgICAgICAgaGFuZGxlcihfZXZlbnQpO1xyXG4gICAgICAvLyBhcHBlYXJzIHRvIGJlIHNsb3dlciwgYXN0b25pc2hpbmdseS4uLlxyXG4gICAgICAvLyBjYXB0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyOiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgICAvLyAgICAgaGFuZGxlcihfZXZlbnQpO1xyXG4gICAgICAvLyB9KTtcclxuXHJcbiAgICAgIC8vIHNhbWUgZm9yIGNoaWxkcmVuXHJcbiAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcclxuICAgICAgICBjaGlsZC5icm9hZGNhc3RFdmVudFJlY3Vyc2l2ZShfZXZlbnQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyAjZW5kcmVnaW9uXHJcblxyXG4gICAgcHJpdmF0ZSAqIGdldEJyYW5jaEdlbmVyYXRvcigpOiBJdGVyYWJsZUl0ZXJhdG9yPE5vZGU+IHtcclxuICAgICAgeWllbGQgdGhpcztcclxuICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbilcclxuICAgICAgICB5aWVsZCogY2hpbGQuYnJhbmNoO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIG5vZGUgbWFuYWdlZCBieSBbW1Jlc291cmNlTWFuYWdlcl1dIHRoYXQgZnVuY3Rpb25zIGFzIGEgdGVtcGxhdGUgZm9yIFtbTm9kZVJlc291cmNlSW5zdGFuY2VdXXMgXHJcbiAgICAgKi9cclxuICAgIGV4cG9ydCBjbGFzcyBOb2RlUmVzb3VyY2UgZXh0ZW5kcyBOb2RlIGltcGxlbWVudHMgU2VyaWFsaXphYmxlUmVzb3VyY2Uge1xyXG4gICAgICAgIHB1YmxpYyBpZFJlc291cmNlOiBzdHJpbmcgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAgIC8qKlxyXG4gICAgICogQW4gaW5zdGFuY2Ugb2YgYSBbW05vZGVSZXNvdXJjZV1dLiAgXHJcbiAgICAgKiBUaGlzIG5vZGUga2VlcHMgYSByZWZlcmVuY2UgdG8gaXRzIHJlc291cmNlIGFuIGNhbiB0aHVzIG9wdGltaXplIHNlcmlhbGl6YXRpb25cclxuICAgICAqL1xyXG4gICAgZXhwb3J0IGNsYXNzIE5vZGVSZXNvdXJjZUluc3RhbmNlIGV4dGVuZHMgTm9kZSB7XHJcbiAgICAgICAgLyoqIGlkIG9mIHRoZSByZXNvdXJjZSB0aGF0IGluc3RhbmNlIHdhcyBjcmVhdGVkIGZyb20gKi9cclxuICAgICAgICAvLyBUT0RPOiBleGFtaW5lLCBpZiB0aGlzIHNob3VsZCBiZSBhIGRpcmVjdCByZWZlcmVuY2UgdG8gdGhlIE5vZGVSZXNvdXJjZSwgaW5zdGVhZCBvZiB0aGUgaWRcclxuICAgICAgICBwcml2YXRlIGlkU291cmNlOiBzdHJpbmcgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIGNvbnN0cnVjdG9yKF9ub2RlUmVzb3VyY2U6IE5vZGVSZXNvdXJjZSkge1xyXG4gICAgICAgICAgICBzdXBlcihcIk5vZGVSZXNvdXJjZUluc3RhbmNlXCIpO1xyXG4gICAgICAgICAgICBpZiAoX25vZGVSZXNvdXJjZSlcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0KF9ub2RlUmVzb3VyY2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVjcmVhdGUgdGhpcyBub2RlIGZyb20gdGhlIFtbTm9kZVJlc291cmNlXV0gcmVmZXJlbmNlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHB1YmxpYyByZXNldCgpOiB2b2lkIHtcclxuICAgICAgICAgICAgbGV0IHJlc291cmNlOiBOb2RlUmVzb3VyY2UgPSA8Tm9kZVJlc291cmNlPlJlc291cmNlTWFuYWdlci5nZXQodGhpcy5pZFNvdXJjZSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0KHJlc291cmNlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vVE9ETzogb3B0aW1pemUgdXNpbmcgdGhlIHJlZmVyZW5jZWQgTm9kZVJlc291cmNlLCBzZXJpYWxpemUvZGVzZXJpYWxpemUgb25seSB0aGUgZGlmZmVyZW5jZXNcclxuICAgICAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICAgICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICAgICAgICBzZXJpYWxpemF0aW9uLmlkU291cmNlID0gdGhpcy5pZFNvdXJjZTtcclxuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBTZXJpYWxpemFibGUge1xyXG4gICAgICAgICAgICBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICAgICAgICAgIHRoaXMuaWRTb3VyY2UgPSBfc2VyaWFsaXphdGlvbi5pZFNvdXJjZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXQgdGhpcyBub2RlIHRvIGJlIGEgcmVjcmVhdGlvbiBvZiB0aGUgW1tOb2RlUmVzb3VyY2VdXSBnaXZlblxyXG4gICAgICAgICAqIEBwYXJhbSBfbm9kZVJlc291cmNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHJpdmF0ZSBzZXQoX25vZGVSZXNvdXJjZTogTm9kZVJlc291cmNlKTogdm9pZCB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IGV4YW1pbmUsIGlmIHRoZSBzZXJpYWxpemF0aW9uIHNob3VsZCBiZSBzdG9yZWQgaW4gdGhlIE5vZGVSZXNvdXJjZSBmb3Igb3B0aW1pemF0aW9uXHJcbiAgICAgICAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gU2VyaWFsaXplci5zZXJpYWxpemUoX25vZGVSZXNvdXJjZSk7XHJcbiAgICAgICAgICAgIC8vU2VyaWFsaXplci5kZXNlcmlhbGl6ZShzZXJpYWxpemF0aW9uKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgcGF0aCBpbiBzZXJpYWxpemF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlc2VyaWFsaXplKHNlcmlhbGl6YXRpb25bcGF0aF0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5pZFNvdXJjZSA9IF9ub2RlUmVzb3VyY2UuaWRSZXNvdXJjZTtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVC5OT0RFUkVTT1VSQ0VfSU5TVEFOVElBVEVEKSk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAgIGV4cG9ydCBjbGFzcyBSYXkge1xyXG4gICAgICAgIHB1YmxpYyBvcmlnaW46IFZlY3RvcjM7XHJcbiAgICAgICAgcHVibGljIGRpcmVjdGlvbjogVmVjdG9yMztcclxuICAgICAgICBwdWJsaWMgbGVuZ3RoOiBudW1iZXI7XHJcblxyXG4gICAgICAgIGNvbnN0cnVjdG9yKF9kaXJlY3Rpb246IFZlY3RvcjMgPSBWZWN0b3IzLlooLTEpLCBfb3JpZ2luOiBWZWN0b3IzID0gVmVjdG9yMy5aRVJPKCksIF9sZW5ndGg6IG51bWJlciA9IDEpIHtcclxuICAgICAgICAgICAgdGhpcy5vcmlnaW4gPSBfb3JpZ2luO1xyXG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IF9kaXJlY3Rpb247XHJcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gX2xlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAgIGV4cG9ydCBjbGFzcyBSYXlIaXQge1xyXG4gICAgICAgIHB1YmxpYyBub2RlOiBOb2RlO1xyXG4gICAgICAgIHB1YmxpYyBmYWNlOiBudW1iZXI7XHJcbiAgICAgICAgcHVibGljIHpCdWZmZXI6IG51bWJlcjtcclxuXHJcbiAgICAgICAgY29uc3RydWN0b3IoX25vZGU6IE5vZGUgPSBudWxsLCBfZmFjZTogbnVtYmVyID0gMCwgX3pCdWZmZXI6IG51bWJlciA9IDApIHtcclxuICAgICAgICAgICAgdGhpcy5ub2RlID0gX25vZGU7XHJcbiAgICAgICAgICAgIHRoaXMuZmFjZSA9IF9mYWNlO1xyXG4gICAgICAgICAgICB0aGlzLnpCdWZmZXIgPSBfekJ1ZmZlcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCIvLyAvIDxyZWZlcmVuY2UgcGF0aD1cIlJlbmRlck9wZXJhdG9yLnRzXCIvPlxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBpbnRlcmZhY2UgTm9kZVJlZmVyZW5jZXMge1xyXG4gICAgc2hhZGVyOiB0eXBlb2YgU2hhZGVyO1xyXG4gICAgLy8gY29hdDogQ29hdDtcclxuICAgIG1lc2g6IE1lc2g7XHJcbiAgICAvLyBkb25lVHJhbnNmb3JtVG9Xb3JsZDogYm9vbGVhbjtcclxuICB9XHJcbiAgdHlwZSBNYXBOb2RlVG9Ob2RlUmVmZXJlbmNlcyA9IE1hcDxOb2RlLCBOb2RlUmVmZXJlbmNlcz47XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgUGlja0J1ZmZlciB7XHJcbiAgICBub2RlOiBOb2RlO1xyXG4gICAgdGV4dHVyZTogV2ViR0xUZXh0dXJlO1xyXG4gICAgZnJhbWVCdWZmZXI6IFdlYkdMRnJhbWVidWZmZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGNsYXNzIG1hbmFnZXMgdGhlIHJlZmVyZW5jZXMgdG8gcmVuZGVyIGRhdGEgdXNlZCBieSBub2Rlcy5cclxuICAgKiBNdWx0aXBsZSBub2RlcyBtYXkgcmVmZXIgdG8gdGhlIHNhbWUgZGF0YSB2aWEgdGhlaXIgcmVmZXJlbmNlcyB0byBzaGFkZXIsIGNvYXQgYW5kIG1lc2ggXHJcbiAgICovXHJcbiAgY2xhc3MgUmVmZXJlbmNlPFQ+IHtcclxuICAgIHByaXZhdGUgcmVmZXJlbmNlOiBUO1xyXG4gICAgcHJpdmF0ZSBjb3VudDogbnVtYmVyID0gMDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihfcmVmZXJlbmNlOiBUKSB7XHJcbiAgICAgIHRoaXMucmVmZXJlbmNlID0gX3JlZmVyZW5jZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0UmVmZXJlbmNlKCk6IFQge1xyXG4gICAgICByZXR1cm4gdGhpcy5yZWZlcmVuY2U7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGluY3JlYXNlQ291bnRlcigpOiBudW1iZXIge1xyXG4gICAgICB0aGlzLmNvdW50Kys7XHJcbiAgICAgIHJldHVybiB0aGlzLmNvdW50O1xyXG4gICAgfVxyXG4gICAgcHVibGljIGRlY3JlYXNlQ291bnRlcigpOiBudW1iZXIge1xyXG4gICAgICBpZiAodGhpcy5jb3VudCA9PSAwKSB0aHJvdyAobmV3IEVycm9yKFwiTmVnYXRpdmUgcmVmZXJlbmNlIGNvdW50ZXJcIikpO1xyXG4gICAgICB0aGlzLmNvdW50LS07XHJcbiAgICAgIHJldHVybiB0aGlzLmNvdW50O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTWFuYWdlcyB0aGUgaGFuZGxpbmcgb2YgdGhlIHJlc3NvdXJjZXMgdGhhdCBhcmUgZ29pbmcgdG8gYmUgcmVuZGVyZWQgYnkgW1tSZW5kZXJPcGVyYXRvcl1dLlxyXG4gICAqIFN0b3JlcyB0aGUgcmVmZXJlbmNlcyB0byB0aGUgc2hhZGVyLCB0aGUgY29hdCBhbmQgdGhlIG1lc2ggdXNlZCBmb3IgZWFjaCBub2RlIHJlZ2lzdGVyZWQuIFxyXG4gICAqIFdpdGggdGhlc2UgcmVmZXJlbmNlcywgdGhlIGFscmVhZHkgYnVmZmVyZWQgZGF0YSBpcyByZXRyaWV2ZWQgd2hlbiByZW5kZXJpbmcuXHJcbiAgICovXHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFJlbmRlck1hbmFnZXIgZXh0ZW5kcyBSZW5kZXJPcGVyYXRvciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlY3RDbGlwOiBSZWN0YW5nbGUgPSBuZXcgUmVjdGFuZ2xlKC0xLCAxLCAyLCAtMik7XHJcbiAgICAvKiogU3RvcmVzIHJlZmVyZW5jZXMgdG8gdGhlIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtcyBhbmQgbWFrZXMgdGhlbSBhdmFpbGFibGUgdmlhIHRoZSByZWZlcmVuY2VzIHRvIHNoYWRlcnMgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIHJlbmRlclNoYWRlcnM6IE1hcDx0eXBlb2YgU2hhZGVyLCBSZWZlcmVuY2U8UmVuZGVyU2hhZGVyPj4gPSBuZXcgTWFwKCk7XHJcbiAgICAvKiogU3RvcmVzIHJlZmVyZW5jZXMgdG8gdGhlIHZlcnRleCBhcnJheSBvYmplY3RzIGFuZCBtYWtlcyB0aGVtIGF2YWlsYWJsZSB2aWEgdGhlIHJlZmVyZW5jZXMgdG8gY29hdHMgKi9cclxuICAgIC8vIHByaXZhdGUgc3RhdGljIHJlbmRlckNvYXRzOiBNYXA8Q29hdCwgUmVmZXJlbmNlPFJlbmRlckNvYXQ+PiA9IG5ldyBNYXAoKTtcclxuICAgIC8qKiBTdG9yZXMgcmVmZXJlbmNlcyB0byB0aGUgdmVydGV4IGJ1ZmZlcnMgYW5kIG1ha2VzIHRoZW0gYXZhaWxhYmxlIHZpYSB0aGUgcmVmZXJlbmNlcyB0byBtZXNoZXMgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIHJlbmRlckJ1ZmZlcnM6IE1hcDxNZXNoLCBSZWZlcmVuY2U8UmVuZGVyQnVmZmVycz4+ID0gbmV3IE1hcCgpO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgbm9kZXM6IE1hcE5vZGVUb05vZGVSZWZlcmVuY2VzID0gbmV3IE1hcCgpO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgdGltZXN0YW1wVXBkYXRlOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBwaWNrQnVmZmVyczogUGlja0J1ZmZlcltdO1xyXG5cclxuICAgIC8vICNyZWdpb24gQWRkaW5nXHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVyIHRoZSBub2RlIGZvciByZW5kZXJpbmcuIENyZWF0ZSBhIHJlZmVyZW5jZSBmb3IgaXQgYW5kIGluY3JlYXNlIHRoZSBtYXRjaGluZyByZW5kZXItZGF0YSByZWZlcmVuY2VzIG9yIGNyZWF0ZSB0aGVtIGZpcnN0IGlmIG5lY2Vzc2FyeVxyXG4gICAgICogQHBhcmFtIF9ub2RlIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGFkZE5vZGUoX25vZGU6IE5vZGUpOiB2b2lkIHtcclxuICAgICAgaWYgKFJlbmRlck1hbmFnZXIubm9kZXMuZ2V0KF9ub2RlKSlcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBsZXQgY21wTWF0ZXJpYWw6IENvbXBvbmVudE1hdGVyaWFsID0gX25vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudE1hdGVyaWFsKTtcclxuICAgICAgaWYgKCFjbXBNYXRlcmlhbClcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBsZXQgc2hhZGVyOiB0eXBlb2YgU2hhZGVyID0gY21wTWF0ZXJpYWwubWF0ZXJpYWwuZ2V0U2hhZGVyKCk7XHJcbiAgICAgIFJlbmRlck1hbmFnZXIuY3JlYXRlUmVmZXJlbmNlPHR5cGVvZiBTaGFkZXIsIFJlbmRlclNoYWRlcj4oUmVuZGVyTWFuYWdlci5yZW5kZXJTaGFkZXJzLCBzaGFkZXIsIFJlbmRlck1hbmFnZXIuY3JlYXRlUHJvZ3JhbSk7XHJcblxyXG4gICAgICAvLyBsZXQgY29hdDogQ29hdCA9IGNtcE1hdGVyaWFsLm1hdGVyaWFsLmdldENvYXQoKTtcclxuICAgICAgLy8gUmVuZGVyTWFuYWdlci5jcmVhdGVSZWZlcmVuY2U8Q29hdCwgUmVuZGVyQ29hdD4oUmVuZGVyTWFuYWdlci5yZW5kZXJDb2F0cywgY29hdCwgUmVuZGVyTWFuYWdlci5jcmVhdGVQYXJhbWV0ZXIpO1xyXG5cclxuICAgICAgbGV0IG1lc2g6IE1lc2ggPSAoPENvbXBvbmVudE1lc2g+X25vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudE1lc2gpKS5tZXNoO1xyXG4gICAgICBSZW5kZXJNYW5hZ2VyLmNyZWF0ZVJlZmVyZW5jZTxNZXNoLCBSZW5kZXJCdWZmZXJzPihSZW5kZXJNYW5hZ2VyLnJlbmRlckJ1ZmZlcnMsIG1lc2gsIFJlbmRlck1hbmFnZXIuY3JlYXRlQnVmZmVycyk7XHJcbiAgICAgIG1lc2guY3JlYXRlUmVuZGVyQnVmZmVycyhudWxsKTtcclxuXHJcbiAgICAgIC8vIFRPRE86IGJ1ZmZlcnMgZm9yIHNoYWRlcnMsIGNvYXRzIGFuZCBtZXNoZXMgbXVzdCBiZSByZWZlcmVuY2VkIGJ5IHRoZSBub2RlcyBjb21wb25lbnRzL3JlZmVyZW5jZWQgaW5zdGFuY2VzIGRpcmVjdGx5IVxyXG4gICAgICBsZXQgbm9kZVJlZmVyZW5jZXM6IE5vZGVSZWZlcmVuY2VzID0geyBzaGFkZXI6IHNoYWRlciwgLypjb2F0OiBjb2F0LCovIG1lc2g6IG1lc2ggfTsgLy8sIGRvbmVUcmFuc2Zvcm1Ub1dvcmxkOiBmYWxzZSB9O1xyXG4gICAgICBSZW5kZXJNYW5hZ2VyLm5vZGVzLnNldChfbm9kZSwgbm9kZVJlZmVyZW5jZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXIgdGhlIG5vZGUgYW5kIGl0cyB2YWxpZCBzdWNjZXNzb3JzIGluIHRoZSBicmFuY2ggZm9yIHJlbmRlcmluZyB1c2luZyBbW2FkZE5vZGVdXVxyXG4gICAgICogQHBhcmFtIF9ub2RlIFxyXG4gICAgICogQHJldHVybnMgZmFsc2UsIGlmIHRoZSBnaXZlbiBub2RlIGhhcyBhIGN1cnJlbnQgdGltZXN0YW1wIHRodXMgaGF2aW5nIGJlaW5nIHByb2Nlc3NlZCBkdXJpbmcgbGF0ZXN0IFJlbmRlck1hbmFnZXIudXBkYXRlIGFuZCBubyBhZGRpdGlvbiBpcyBuZWVkZWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBhZGRCcmFuY2goX25vZGU6IE5vZGUpOiBib29sZWFuIHtcclxuICAgICAgLy8gVE9ETzogcmV0aGluayBvcHRpbWl6YXRpb24hIVxyXG4gICAgICAvLyBpZiAoX25vZGUuaXNVcGRhdGVkKFJlbmRlck1hbmFnZXIudGltZXN0YW1wVXBkYXRlKSlcclxuICAgICAgLy8gICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgZm9yIChsZXQgbm9kZSBvZiBfbm9kZS5icmFuY2gpXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIC8vIG1heSBmYWlsIHdoZW4gc29tZSBjb21wb25lbnRzIGFyZSBtaXNzaW5nLiBUT0RPOiBjbGVhbnVwXHJcbiAgICAgICAgICBSZW5kZXJNYW5hZ2VyLmFkZE5vZGUobm9kZSk7XHJcbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XHJcbiAgICAgICAgICBEZWJ1Zy5sb2coX2Vycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLy8gI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vICNyZWdpb24gUmVtb3ZpbmdcclxuICAgIC8qKlxyXG4gICAgICogVW5yZWdpc3RlciB0aGUgbm9kZSBzbyB0aGF0IGl0IHdvbid0IGJlIHJlbmRlcmVkIGFueSBtb3JlLiBEZWNyZWFzZSB0aGUgcmVuZGVyLWRhdGEgcmVmZXJlbmNlcyBhbmQgZGVsZXRlIHRoZSBub2RlIHJlZmVyZW5jZS5cclxuICAgICAqIEBwYXJhbSBfbm9kZSBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZW1vdmVOb2RlKF9ub2RlOiBOb2RlKTogdm9pZCB7XHJcbiAgICAgIGxldCBub2RlUmVmZXJlbmNlczogTm9kZVJlZmVyZW5jZXMgPSBSZW5kZXJNYW5hZ2VyLm5vZGVzLmdldChfbm9kZSk7XHJcbiAgICAgIGlmICghbm9kZVJlZmVyZW5jZXMpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgUmVuZGVyTWFuYWdlci5yZW1vdmVSZWZlcmVuY2U8dHlwZW9mIFNoYWRlciwgUmVuZGVyU2hhZGVyPihSZW5kZXJNYW5hZ2VyLnJlbmRlclNoYWRlcnMsIG5vZGVSZWZlcmVuY2VzLnNoYWRlciwgUmVuZGVyTWFuYWdlci5kZWxldGVQcm9ncmFtKTtcclxuICAgICAgLy8gUmVuZGVyTWFuYWdlci5yZW1vdmVSZWZlcmVuY2U8Q29hdCwgUmVuZGVyQ29hdD4oUmVuZGVyTWFuYWdlci5yZW5kZXJDb2F0cywgbm9kZVJlZmVyZW5jZXMuY29hdCwgUmVuZGVyTWFuYWdlci5kZWxldGVQYXJhbWV0ZXIpO1xyXG4gICAgICBSZW5kZXJNYW5hZ2VyLnJlbW92ZVJlZmVyZW5jZTxNZXNoLCBSZW5kZXJCdWZmZXJzPihSZW5kZXJNYW5hZ2VyLnJlbmRlckJ1ZmZlcnMsIG5vZGVSZWZlcmVuY2VzLm1lc2gsIFJlbmRlck1hbmFnZXIuZGVsZXRlQnVmZmVycyk7XHJcblxyXG4gICAgICBSZW5kZXJNYW5hZ2VyLm5vZGVzLmRlbGV0ZShfbm9kZSk7XHJcbiAgICAgIFxyXG4gICAgICBub2RlUmVmZXJlbmNlcy5tZXNoLmRlbGV0ZVJlbmRlckJ1ZmZlcnMobnVsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVbnJlZ2lzdGVyIHRoZSBub2RlIGFuZCBpdHMgdmFsaWQgc3VjY2Vzc29ycyBpbiB0aGUgYnJhbmNoIHRvIGZyZWUgcmVuZGVyZXIgcmVzb3VyY2VzLiBVc2VzIFtbcmVtb3ZlTm9kZV1dXHJcbiAgICAgKiBAcGFyYW0gX25vZGUgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVtb3ZlQnJhbmNoKF9ub2RlOiBOb2RlKTogdm9pZCB7XHJcbiAgICAgIGZvciAobGV0IG5vZGUgb2YgX25vZGUuYnJhbmNoKVxyXG4gICAgICAgIFJlbmRlck1hbmFnZXIucmVtb3ZlTm9kZShub2RlKTtcclxuICAgIH1cclxuICAgIC8vICNlbmRyZWdpb25cclxuXHJcbiAgICAvLyAjcmVnaW9uIFVwZGF0aW5nXHJcbiAgICAvKipcclxuICAgICAqIFJlZmxlY3QgY2hhbmdlcyBpbiB0aGUgbm9kZSBjb25jZXJuaW5nIHNoYWRlciwgY29hdCBhbmQgbWVzaCwgbWFuYWdlIHRoZSByZW5kZXItZGF0YSByZWZlcmVuY2VzIGFjY29yZGluZ2x5IGFuZCB1cGRhdGUgdGhlIG5vZGUgcmVmZXJlbmNlc1xyXG4gICAgICogQHBhcmFtIF9ub2RlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgdXBkYXRlTm9kZShfbm9kZTogTm9kZSk6IHZvaWQge1xyXG4gICAgICBsZXQgbm9kZVJlZmVyZW5jZXM6IE5vZGVSZWZlcmVuY2VzID0gUmVuZGVyTWFuYWdlci5ub2Rlcy5nZXQoX25vZGUpO1xyXG4gICAgICBpZiAoIW5vZGVSZWZlcmVuY2VzKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGxldCBjbXBNYXRlcmlhbDogQ29tcG9uZW50TWF0ZXJpYWwgPSBfbm9kZS5nZXRDb21wb25lbnQoQ29tcG9uZW50TWF0ZXJpYWwpO1xyXG5cclxuICAgICAgbGV0IHNoYWRlcjogdHlwZW9mIFNoYWRlciA9IGNtcE1hdGVyaWFsLm1hdGVyaWFsLmdldFNoYWRlcigpO1xyXG4gICAgICBpZiAoc2hhZGVyICE9PSBub2RlUmVmZXJlbmNlcy5zaGFkZXIpIHtcclxuICAgICAgICBSZW5kZXJNYW5hZ2VyLnJlbW92ZVJlZmVyZW5jZTx0eXBlb2YgU2hhZGVyLCBSZW5kZXJTaGFkZXI+KFJlbmRlck1hbmFnZXIucmVuZGVyU2hhZGVycywgbm9kZVJlZmVyZW5jZXMuc2hhZGVyLCBSZW5kZXJNYW5hZ2VyLmRlbGV0ZVByb2dyYW0pO1xyXG4gICAgICAgIFJlbmRlck1hbmFnZXIuY3JlYXRlUmVmZXJlbmNlPHR5cGVvZiBTaGFkZXIsIFJlbmRlclNoYWRlcj4oUmVuZGVyTWFuYWdlci5yZW5kZXJTaGFkZXJzLCBzaGFkZXIsIFJlbmRlck1hbmFnZXIuY3JlYXRlUHJvZ3JhbSk7XHJcbiAgICAgICAgbm9kZVJlZmVyZW5jZXMuc2hhZGVyID0gc2hhZGVyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBsZXQgY29hdDogQ29hdCA9IGNtcE1hdGVyaWFsLm1hdGVyaWFsLmdldENvYXQoKTtcclxuICAgICAgLy8gaWYgKGNvYXQgIT09IG5vZGVSZWZlcmVuY2VzLmNvYXQpIHtcclxuICAgICAgLy8gICBSZW5kZXJNYW5hZ2VyLnJlbW92ZVJlZmVyZW5jZTxDb2F0LCBSZW5kZXJDb2F0PihSZW5kZXJNYW5hZ2VyLnJlbmRlckNvYXRzLCBub2RlUmVmZXJlbmNlcy5jb2F0LCBSZW5kZXJNYW5hZ2VyLmRlbGV0ZVBhcmFtZXRlcik7XHJcbiAgICAgIC8vICAgUmVuZGVyTWFuYWdlci5jcmVhdGVSZWZlcmVuY2U8Q29hdCwgUmVuZGVyQ29hdD4oUmVuZGVyTWFuYWdlci5yZW5kZXJDb2F0cywgY29hdCwgUmVuZGVyTWFuYWdlci5jcmVhdGVQYXJhbWV0ZXIpO1xyXG4gICAgICAvLyAgIG5vZGVSZWZlcmVuY2VzLmNvYXQgPSBjb2F0O1xyXG4gICAgICAvLyB9XHJcblxyXG4gICAgICBsZXQgbWVzaDogTWVzaCA9ICg8Q29tcG9uZW50TWVzaD4oX25vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudE1lc2gpKSkubWVzaDtcclxuICAgICAgaWYgKG1lc2ggIT09IG5vZGVSZWZlcmVuY2VzLm1lc2gpIHtcclxuICAgICAgICBSZW5kZXJNYW5hZ2VyLnJlbW92ZVJlZmVyZW5jZTxNZXNoLCBSZW5kZXJCdWZmZXJzPihSZW5kZXJNYW5hZ2VyLnJlbmRlckJ1ZmZlcnMsIG5vZGVSZWZlcmVuY2VzLm1lc2gsIFJlbmRlck1hbmFnZXIuZGVsZXRlQnVmZmVycyk7XHJcbiAgICAgICAgUmVuZGVyTWFuYWdlci5jcmVhdGVSZWZlcmVuY2U8TWVzaCwgUmVuZGVyQnVmZmVycz4oUmVuZGVyTWFuYWdlci5yZW5kZXJCdWZmZXJzLCBtZXNoLCBSZW5kZXJNYW5hZ2VyLmNyZWF0ZUJ1ZmZlcnMpO1xyXG4gICAgICAgIG5vZGVSZWZlcmVuY2VzLm1lc2ggPSBtZXNoO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgdGhlIG5vZGUgYW5kIGl0cyB2YWxpZCBzdWNjZXNzb3JzIGluIHRoZSBicmFuY2ggdXNpbmcgW1t1cGRhdGVOb2RlXV1cclxuICAgICAqIEBwYXJhbSBfbm9kZSBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyB1cGRhdGVCcmFuY2goX25vZGU6IE5vZGUpOiB2b2lkIHtcclxuICAgICAgZm9yIChsZXQgbm9kZSBvZiBfbm9kZS5icmFuY2gpXHJcbiAgICAgICAgUmVuZGVyTWFuYWdlci51cGRhdGVOb2RlKG5vZGUpO1xyXG4gICAgfVxyXG4gICAgLy8gI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vICNyZWdpb24gTGlnaHRzXHJcbiAgICAvKipcclxuICAgICAqIFZpZXdwb3J0cyBjb2xsZWN0IHRoZSBsaWdodHMgcmVsZXZhbnQgdG8gdGhlIGJyYW5jaCB0byByZW5kZXIgYW5kIGNhbGxzIHNldExpZ2h0cyB0byBwYXNzIHRoZSBjb2xsZWN0aW9uLiAgXHJcbiAgICAgKiBSZW5kZXJNYW5hZ2VyIHBhc3NlcyBpdCBvbiB0byBhbGwgc2hhZGVycyB1c2VkIHRoYXQgY2FuIHByb2Nlc3MgbGlnaHRcclxuICAgICAqIEBwYXJhbSBfbGlnaHRzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc2V0TGlnaHRzKF9saWdodHM6IE1hcExpZ2h0VHlwZVRvTGlnaHRMaXN0KTogdm9pZCB7XHJcbiAgICAgIC8vIGxldCByZW5kZXJMaWdodHM6IFJlbmRlckxpZ2h0cyA9IFJlbmRlck1hbmFnZXIuY3JlYXRlUmVuZGVyTGlnaHRzKF9saWdodHMpO1xyXG4gICAgICBmb3IgKGxldCBlbnRyeSBvZiBSZW5kZXJNYW5hZ2VyLnJlbmRlclNoYWRlcnMpIHtcclxuICAgICAgICBsZXQgcmVuZGVyU2hhZGVyOiBSZW5kZXJTaGFkZXIgPSBlbnRyeVsxXS5nZXRSZWZlcmVuY2UoKTtcclxuICAgICAgICBSZW5kZXJNYW5hZ2VyLnNldExpZ2h0c0luU2hhZGVyKHJlbmRlclNoYWRlciwgX2xpZ2h0cyk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gZGVidWdnZXI7XHJcbiAgICB9XHJcbiAgICAvLyAjZW5kcmVnaW9uXHJcblxyXG4gICAgLy8gI3JlZ2lvbiBSZW5kZXJpbmdcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIGFsbCByZW5kZXIgZGF0YS4gQWZ0ZXIgUmVuZGVyTWFuYWdlciwgbXVsdGlwbGUgdmlld3BvcnRzIGNhbiByZW5kZXIgdGhlaXIgYXNzb2NpYXRlZCBkYXRhIHdpdGhvdXQgdXBkYXRpbmcgdGhlIHNhbWUgZGF0YSBtdWx0aXBsZSB0aW1lc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHVwZGF0ZSgpOiB2b2lkIHtcclxuICAgICAgUmVuZGVyTWFuYWdlci50aW1lc3RhbXBVcGRhdGUgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgUmVuZGVyTWFuYWdlci5yZWNhbGN1bGF0ZUFsbE5vZGVUcmFuc2Zvcm1zKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhciB0aGUgb2Zmc2NyZWVuIHJlbmRlcmJ1ZmZlciB3aXRoIHRoZSBnaXZlbiBbW0NvbG9yXV1cclxuICAgICAqIEBwYXJhbSBfY29sb3IgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgY2xlYXIoX2NvbG9yOiBDb2xvciA9IG51bGwpOiB2b2lkIHtcclxuICAgICAgUmVuZGVyTWFuYWdlci5jcmMzLmNsZWFyQ29sb3IoX2NvbG9yLnIsIF9jb2xvci5nLCBfY29sb3IuYiwgX2NvbG9yLmEpO1xyXG4gICAgICBSZW5kZXJNYW5hZ2VyLmNyYzMuY2xlYXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5DT0xPUl9CVUZGRVJfQklUIHwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ERVBUSF9CVUZGRVJfQklUKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0IHRoZSBvZmZzY3JlZW4gZnJhbWVidWZmZXIgdG8gdGhlIG9yaWdpbmFsIFJlbmRlcmluZ0NvbnRleHRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZXNldEZyYW1lQnVmZmVyKF9jb2xvcjogQ29sb3IgPSBudWxsKTogdm9pZCB7XHJcbiAgICAgIFJlbmRlck1hbmFnZXIuY3JjMy5iaW5kRnJhbWVidWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GUkFNRUJVRkZFUiwgbnVsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyB0aGUgYnJhbmNoIHN0YXJ0aW5nIHdpdGggdGhlIGdpdmVuIFtbTm9kZV1dIHVzaW5nIHRoZSBjYW1lcmEgZ2l2ZW4gW1tDb21wb25lbnRDYW1lcmFdXS5cclxuICAgICAqIEBwYXJhbSBfbm9kZSBcclxuICAgICAqIEBwYXJhbSBfY21wQ2FtZXJhIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGRyYXdCcmFuY2goX25vZGU6IE5vZGUsIF9jbXBDYW1lcmE6IENvbXBvbmVudENhbWVyYSwgX2RyYXdOb2RlOiBGdW5jdGlvbiA9IFJlbmRlck1hbmFnZXIuZHJhd05vZGUpOiB2b2lkIHsgLy8gVE9ETzogc2VlIGlmIHRoaXJkIHBhcmFtZXRlciBfd29ybGQ/OiBNYXRyaXg0eDQgd291bGQgYmUgdXNlZnVsbFxyXG4gICAgICBpZiAoIV9ub2RlLmlzQWN0aXZlKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgaWYgKF9kcmF3Tm9kZSA9PSBSZW5kZXJNYW5hZ2VyLmRyYXdOb2RlKVxyXG4gICAgICAgIFJlbmRlck1hbmFnZXIucmVzZXRGcmFtZUJ1ZmZlcigpO1xyXG5cclxuICAgICAgbGV0IGZpbmFsVHJhbnNmb3JtOiBNYXRyaXg0eDQ7XHJcblxyXG4gICAgICBsZXQgY21wTWVzaDogQ29tcG9uZW50TWVzaCA9IF9ub2RlLmdldENvbXBvbmVudChDb21wb25lbnRNZXNoKTtcclxuICAgICAgaWYgKGNtcE1lc2gpXHJcbiAgICAgICAgZmluYWxUcmFuc2Zvcm0gPSBNYXRyaXg0eDQuTVVMVElQTElDQVRJT04oX25vZGUubXR4V29ybGQsIGNtcE1lc2gucGl2b3QpO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgZmluYWxUcmFuc2Zvcm0gPSBfbm9kZS5tdHhXb3JsZDsgLy8gY2F1dGlvbiwgUmVuZGVyTWFuYWdlciBpcyBhIHJlZmVyZW5jZS4uLlxyXG5cclxuICAgICAgLy8gbXVsdGlwbHkgY2FtZXJhIG1hdHJpeFxyXG4gICAgICBsZXQgcHJvamVjdGlvbjogTWF0cml4NHg0ID0gTWF0cml4NHg0Lk1VTFRJUExJQ0FUSU9OKF9jbXBDYW1lcmEuVmlld1Byb2plY3Rpb25NYXRyaXgsIGZpbmFsVHJhbnNmb3JtKTtcclxuXHJcbiAgICAgIF9kcmF3Tm9kZShfbm9kZSwgZmluYWxUcmFuc2Zvcm0sIHByb2plY3Rpb24pO1xyXG5cclxuICAgICAgZm9yIChsZXQgbmFtZSBpbiBfbm9kZS5nZXRDaGlsZHJlbigpKSB7XHJcbiAgICAgICAgbGV0IGNoaWxkTm9kZTogTm9kZSA9IF9ub2RlLmdldENoaWxkcmVuKClbbmFtZV07XHJcbiAgICAgICAgUmVuZGVyTWFuYWdlci5kcmF3QnJhbmNoKGNoaWxkTm9kZSwgX2NtcENhbWVyYSwgX2RyYXdOb2RlKTsgLy8sIHdvcmxkKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgUmVjeWNsZXIuc3RvcmUocHJvamVjdGlvbik7XHJcbiAgICAgIGlmIChmaW5hbFRyYW5zZm9ybSAhPSBfbm9kZS5tdHhXb3JsZClcclxuICAgICAgICBSZWN5Y2xlci5zdG9yZShmaW5hbFRyYW5zZm9ybSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFJheUNhc3QgJiBQaWNraW5nXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyB0aGUgYnJhbmNoIGZvciBSYXlDYXN0aW5nIHN0YXJ0aW5nIHdpdGggdGhlIGdpdmVuIFtbTm9kZV1dIHVzaW5nIHRoZSBjYW1lcmEgZ2l2ZW4gW1tDb21wb25lbnRDYW1lcmFdXS5cclxuICAgICAqIEBwYXJhbSBfbm9kZSBcclxuICAgICAqIEBwYXJhbSBfY21wQ2FtZXJhIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGRyYXdCcmFuY2hGb3JSYXlDYXN0KF9ub2RlOiBOb2RlLCBfY21wQ2FtZXJhOiBDb21wb25lbnRDYW1lcmEpOiBQaWNrQnVmZmVyW10geyAvLyBUT0RPOiBzZWUgaWYgdGhpcmQgcGFyYW1ldGVyIF93b3JsZD86IE1hdHJpeDR4NCB3b3VsZCBiZSB1c2VmdWxsXHJcbiAgICAgIFJlbmRlck1hbmFnZXIucGlja0J1ZmZlcnMgPSBbXTtcclxuICAgICAgaWYgKCFSZW5kZXJNYW5hZ2VyLnJlbmRlclNoYWRlcnMuZ2V0KFNoYWRlclJheUNhc3QpKVxyXG4gICAgICAgIFJlbmRlck1hbmFnZXIuY3JlYXRlUmVmZXJlbmNlPHR5cGVvZiBTaGFkZXIsIFJlbmRlclNoYWRlcj4oUmVuZGVyTWFuYWdlci5yZW5kZXJTaGFkZXJzLCBTaGFkZXJSYXlDYXN0LCBSZW5kZXJNYW5hZ2VyLmNyZWF0ZVByb2dyYW0pO1xyXG5cclxuICAgICAgLy9UT0RPOiBleGFtaW5lLCB3aHkgc3dpdGNoaW5nIGJsZW5kRnVuY3Rpb24gaXMgbmVjZXNzYXJ5IFxyXG4gICAgICBSZW5kZXJPcGVyYXRvci5jcmMzLmJsZW5kRnVuYygxLCAwKTtcclxuICAgICAgUmVuZGVyTWFuYWdlci5kcmF3QnJhbmNoKF9ub2RlLCBfY21wQ2FtZXJhLCBSZW5kZXJNYW5hZ2VyLmRyYXdOb2RlRm9yUmF5Q2FzdCk7XHJcbiAgICAgIFJlbmRlck9wZXJhdG9yLmNyYzMuYmxlbmRGdW5jKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRFNUX0FMUEhBLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk9ORV9NSU5VU19EU1RfQUxQSEEpO1xyXG5cclxuICAgICAgUmVuZGVyTWFuYWdlci5yZXNldEZyYW1lQnVmZmVyKCk7XHJcbiAgICAgIHJldHVybiBSZW5kZXJNYW5hZ2VyLnBpY2tCdWZmZXJzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgcGlja05vZGVBdChfcG9zOiBWZWN0b3IyLCBfcGlja0J1ZmZlcnM6IFBpY2tCdWZmZXJbXSwgX3JlY3Q6IFJlY3RhbmdsZSk6IFJheUhpdFtdIHtcclxuICAgICAgbGV0IGhpdHM6IFJheUhpdFtdID0gW107XHJcblxyXG4gICAgICBmb3IgKGxldCBwaWNrQnVmZmVyIG9mIF9waWNrQnVmZmVycykge1xyXG4gICAgICAgIFJlbmRlck1hbmFnZXIuY3JjMy5iaW5kRnJhbWVidWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GUkFNRUJVRkZFUiwgcGlja0J1ZmZlci5mcmFtZUJ1ZmZlcik7XHJcbiAgICAgICAgLy8gVE9ETzogaW5zdGVhZCBvZiByZWFkaW5nIGFsbCBkYXRhIGFuZCBhZnRlcndhcmRzIHBpY2sgdGhlIHBpeGVsLCByZWFkIG9ubHkgdGhlIHBpeGVsIVxyXG4gICAgICAgIGxldCBkYXRhOiBVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoX3JlY3Qud2lkdGggKiBfcmVjdC5oZWlnaHQgKiA0KTtcclxuICAgICAgICBSZW5kZXJNYW5hZ2VyLmNyYzMucmVhZFBpeGVscygwLCAwLCBfcmVjdC53aWR0aCwgX3JlY3QuaGVpZ2h0LCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlJHQkEsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5TSUdORURfQllURSwgZGF0YSk7XHJcbiAgICAgICAgbGV0IHBpeGVsOiBudW1iZXIgPSBfcG9zLnggKyBfcmVjdC53aWR0aCAqIF9wb3MueTtcclxuXHJcbiAgICAgICAgLy8gbGV0IHpCdWZmZXI6IG51bWJlciA9IGRhdGFbNCAqIHBpeGVsICsgMV0gKyBkYXRhWzQgKiBwaXhlbCArIDJdIC8gMjU2O1xyXG4gICAgICAgIGxldCB6QnVmZmVyOiBudW1iZXIgPSBkYXRhWzQgKiBwaXhlbCArIDBdO1xyXG4gICAgICAgIGxldCBoaXQ6IFJheUhpdCA9IG5ldyBSYXlIaXQocGlja0J1ZmZlci5ub2RlLCAwLCB6QnVmZmVyKTtcclxuXHJcbiAgICAgICAgaGl0cy5wdXNoKGhpdCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBoaXRzO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBkcmF3Tm9kZShfbm9kZTogTm9kZSwgX2ZpbmFsVHJhbnNmb3JtOiBNYXRyaXg0eDQsIF9wcm9qZWN0aW9uOiBNYXRyaXg0eDQpOiB2b2lkIHtcclxuICAgICAgbGV0IHJlZmVyZW5jZXM6IE5vZGVSZWZlcmVuY2VzID0gUmVuZGVyTWFuYWdlci5ub2Rlcy5nZXQoX25vZGUpO1xyXG4gICAgICBpZiAoIXJlZmVyZW5jZXMpXHJcbiAgICAgICAgcmV0dXJuOyBcclxuICAgICAgICBcclxuICAgICAgbGV0IGNvYXQ6IENvYXQgPSBfbm9kZS5nZXRDb21wb25lbnQoQ29tcG9uZW50TWF0ZXJpYWwpLm1hdGVyaWFsLmdldENvYXQoKTtcclxuICAgICAgbGV0IHNoYWRlckluZm86IFJlbmRlclNoYWRlciA9IFJlbmRlck1hbmFnZXIucmVuZGVyU2hhZGVycy5nZXQocmVmZXJlbmNlcy5zaGFkZXIpLmdldFJlZmVyZW5jZSgpO1xyXG4gICAgICBSZW5kZXJNYW5hZ2VyLmRyYXcoc2hhZGVySW5mbywgcmVmZXJlbmNlcy5tZXNoLCBjb2F0LCBfZmluYWxUcmFuc2Zvcm0sIF9wcm9qZWN0aW9uKTtcclxuICAgICAgLy8gUmVuZGVyTWFuYWdlci5kcmF3KHNoYWRlckluZm8sIGJ1ZmZlckluZm8sIGNvYXRJbmZvLCBfZmluYWxUcmFuc2Zvcm0sIF9wcm9qZWN0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBkcmF3Tm9kZUZvclJheUNhc3QoX25vZGU6IE5vZGUsIF9maW5hbFRyYW5zZm9ybTogTWF0cml4NHg0LCBfcHJvamVjdGlvbjogTWF0cml4NHg0KTogdm9pZCB7IC8vIGNyZWF0ZSBUZXh0dXJlIHRvIHJlbmRlciB0bywgaW50LXJnYmFcclxuICAgICAgLy8gVE9ETzogbG9vayBpbnRvIFNTQk9zIVxyXG4gICAgICBsZXQgdGFyZ2V0OiBXZWJHTFRleHR1cmUgPSBSZW5kZXJNYW5hZ2VyLmdldFJheUNhc3RUZXh0dXJlKCk7XHJcblxyXG4gICAgICBjb25zdCBmcmFtZWJ1ZmZlcjogV2ViR0xGcmFtZWJ1ZmZlciA9IFJlbmRlck1hbmFnZXIuY3JjMy5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xyXG4gICAgICAvLyByZW5kZXIgdG8gb3VyIHRhcmdldFRleHR1cmUgYnkgYmluZGluZyB0aGUgZnJhbWVidWZmZXJcclxuICAgICAgUmVuZGVyTWFuYWdlci5jcmMzLmJpbmRGcmFtZWJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlcik7XHJcbiAgICAgIC8vIGF0dGFjaCB0aGUgdGV4dHVyZSBhcyB0aGUgZmlyc3QgY29sb3IgYXR0YWNobWVudFxyXG4gICAgICBjb25zdCBhdHRhY2htZW50UG9pbnQ6IG51bWJlciA9IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ09MT1JfQVRUQUNITUVOVDA7XHJcbiAgICAgIFJlbmRlck1hbmFnZXIuY3JjMy5mcmFtZWJ1ZmZlclRleHR1cmUyRChXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZSQU1FQlVGRkVSLCBhdHRhY2htZW50UG9pbnQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgdGFyZ2V0LCAwKTtcclxuXHJcbiAgICAgIGxldCByZWZlcmVuY2VzOiBOb2RlUmVmZXJlbmNlcyA9IFJlbmRlck1hbmFnZXIubm9kZXMuZ2V0KF9ub2RlKTtcclxuICAgICAgaWYgKCFyZWZlcmVuY2VzKVxyXG4gICAgICAgIHJldHVybjsgLy8gVE9ETzogZGVhbCB3aXRoIHBhcnRpYWwgcmVmZXJlbmNlc1xyXG5cclxuICAgICAgbGV0IHBpY2tCdWZmZXI6IFBpY2tCdWZmZXIgPSB7IG5vZGU6IF9ub2RlLCB0ZXh0dXJlOiB0YXJnZXQsIGZyYW1lQnVmZmVyOiBmcmFtZWJ1ZmZlciB9O1xyXG4gICAgICBSZW5kZXJNYW5hZ2VyLnBpY2tCdWZmZXJzLnB1c2gocGlja0J1ZmZlcik7XHJcblxyXG4gICAgICBsZXQgcmVuZGVyU2hhZGVyOiBSZW5kZXJTaGFkZXIgPSBSZW5kZXJPcGVyYXRvci5yZW5kZXJTaGFkZXJSYXlDYXN0O1xyXG4gICAgICBSZW5kZXJPcGVyYXRvci51c2VQcm9ncmFtKHJlbmRlclNoYWRlcik7XHJcbiAgICAgIHJlZmVyZW5jZXMubWVzaC51c2VSZW5kZXJCdWZmZXJzKHJlbmRlclNoYWRlciwgX2ZpbmFsVHJhbnNmb3JtLCBfcHJvamVjdGlvbiwgUmVuZGVyTWFuYWdlci5waWNrQnVmZmVycy5sZW5ndGgpO1xyXG5cclxuICAgICAgUmVuZGVyT3BlcmF0b3IuY3JjMy5kcmF3RWxlbWVudHMoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5UUklBTkdMRVMsIHJlZmVyZW5jZXMubWVzaC5yZW5kZXJCdWZmZXJzLm5JbmRpY2VzLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOU0lHTkVEX1NIT1JULCAwKTtcclxuXHJcbiAgICAgIC8vIG1ha2UgdGV4dHVyZSBhdmFpbGFibGUgdG8gb25zY3JlZW4tZGlzcGxheVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGdldFJheUNhc3RUZXh0dXJlKCk6IFdlYkdMVGV4dHVyZSB7XHJcbiAgICAgIC8vIGNyZWF0ZSB0byByZW5kZXIgdG9cclxuICAgICAgY29uc3QgdGFyZ2V0VGV4dHVyZVdpZHRoOiBudW1iZXIgPSBSZW5kZXJNYW5hZ2VyLmdldFZpZXdwb3J0UmVjdGFuZ2xlKCkud2lkdGg7XHJcbiAgICAgIGNvbnN0IHRhcmdldFRleHR1cmVIZWlnaHQ6IG51bWJlciA9IFJlbmRlck1hbmFnZXIuZ2V0Vmlld3BvcnRSZWN0YW5nbGUoKS5oZWlnaHQ7XHJcbiAgICAgIGNvbnN0IHRhcmdldFRleHR1cmU6IFdlYkdMVGV4dHVyZSA9IFJlbmRlck1hbmFnZXIuY3JjMy5jcmVhdGVUZXh0dXJlKCk7XHJcbiAgICAgIFJlbmRlck1hbmFnZXIuY3JjMy5iaW5kVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIHRhcmdldFRleHR1cmUpO1xyXG5cclxuICAgICAge1xyXG4gICAgICAgIGNvbnN0IGludGVybmFsRm9ybWF0OiBudW1iZXIgPSBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlJHQkE4O1xyXG4gICAgICAgIGNvbnN0IGZvcm1hdDogbnVtYmVyID0gV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5SR0JBO1xyXG4gICAgICAgIGNvbnN0IHR5cGU6IG51bWJlciA9IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5TSUdORURfQllURTtcclxuICAgICAgICBSZW5kZXJNYW5hZ2VyLmNyYzMudGV4SW1hZ2UyRChcclxuICAgICAgICAgIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgMCwgaW50ZXJuYWxGb3JtYXQsIHRhcmdldFRleHR1cmVXaWR0aCwgdGFyZ2V0VGV4dHVyZUhlaWdodCwgMCwgZm9ybWF0LCB0eXBlLCBudWxsXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gc2V0IHRoZSBmaWx0ZXJpbmcgc28gd2UgZG9uJ3QgbmVlZCBtaXBzXHJcbiAgICAgICAgUmVuZGVyTWFuYWdlci5jcmMzLnRleFBhcmFtZXRlcmkoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfTUlOX0ZJTFRFUiwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5MSU5FQVIpO1xyXG4gICAgICAgIFJlbmRlck1hbmFnZXIuY3JjMy50ZXhQYXJhbWV0ZXJpKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFX1dSQVBfUywgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgICBSZW5kZXJNYW5hZ2VyLmNyYzMudGV4UGFyYW1ldGVyaShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV9XUkFQX1QsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0YXJnZXRUZXh0dXJlO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZm9ybWF0aW9uIG9mIGJyYW5jaFxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWNhbGN1bGF0ZSB0aGUgd29ybGQgbWF0cml4IG9mIGFsbCByZWdpc3RlcmVkIG5vZGVzIHJlc3BlY3RpbmcgdGhlaXIgaGllcmFyY2hpY2FsIHJlbGF0aW9uLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyByZWNhbGN1bGF0ZUFsbE5vZGVUcmFuc2Zvcm1zKCk6IHZvaWQge1xyXG4gICAgICAvLyBpbm5lciBmdW5jdGlvbiB0byBiZSBjYWxsZWQgaW4gYSBmb3IgZWFjaCBub2RlIGF0IHRoZSBib3R0b20gb2YgUmVuZGVyTWFuYWdlciBmdW5jdGlvblxyXG4gICAgICAvLyBmdW5jdGlvbiBtYXJrTm9kZVRvQmVUcmFuc2Zvcm1lZChfbm9kZVJlZmVyZW5jZXM6IE5vZGVSZWZlcmVuY2VzLCBfbm9kZTogTm9kZSwgX21hcDogTWFwTm9kZVRvTm9kZVJlZmVyZW5jZXMpOiB2b2lkIHtcclxuICAgICAgLy8gICAgIF9ub2RlUmVmZXJlbmNlcy5kb25lVHJhbnNmb3JtVG9Xb3JsZCA9IGZhbHNlO1xyXG4gICAgICAvLyB9XHJcblxyXG4gICAgICAvLyBpbm5lciBmdW5jdGlvbiB0byBiZSBjYWxsZWQgaW4gYSBmb3IgZWFjaCBub2RlIGF0IHRoZSBib3R0b20gb2YgUmVuZGVyTWFuYWdlciBmdW5jdGlvblxyXG4gICAgICBsZXQgcmVjYWxjdWxhdGVCcmFuY2hDb250YWluaW5nTm9kZTogKF9yOiBOb2RlUmVmZXJlbmNlcywgX246IE5vZGUsIF9tOiBNYXBOb2RlVG9Ob2RlUmVmZXJlbmNlcykgPT4gdm9pZCA9IChfbm9kZVJlZmVyZW5jZXM6IE5vZGVSZWZlcmVuY2VzLCBfbm9kZTogTm9kZSwgX21hcDogTWFwTm9kZVRvTm9kZVJlZmVyZW5jZXMpID0+IHtcclxuICAgICAgICAvLyBmaW5kIHVwcGVybW9zdCBhbmNlc3RvciBub3QgcmVjYWxjdWxhdGVkIHlldFxyXG4gICAgICAgIGxldCBhbmNlc3RvcjogTm9kZSA9IF9ub2RlO1xyXG4gICAgICAgIGxldCBwYXJlbnQ6IE5vZGU7XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgIHBhcmVudCA9IGFuY2VzdG9yLmdldFBhcmVudCgpO1xyXG4gICAgICAgICAgaWYgKCFwYXJlbnQpXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgaWYgKF9ub2RlLmlzVXBkYXRlZChSZW5kZXJNYW5hZ2VyLnRpbWVzdGFtcFVwZGF0ZSkpXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgYW5jZXN0b3IgPSBwYXJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE86IGNoZWNrIGlmIG5vZGVzIHdpdGhvdXQgbWVzaGVzIG11c3QgYmUgcmVnaXN0ZXJlZFxyXG5cclxuICAgICAgICAvLyB1c2UgdGhlIGFuY2VzdG9ycyBwYXJlbnQgd29ybGQgbWF0cml4IHRvIHN0YXJ0IHdpdGgsIG9yIGlkZW50aXR5IGlmIG5vIHBhcmVudCBleGlzdHMgb3IgaXQncyBtaXNzaW5nIGEgQ29tcG9uZW5UcmFuc2Zvcm1cclxuICAgICAgICBsZXQgbWF0cml4OiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKTtcclxuICAgICAgICBpZiAocGFyZW50KVxyXG4gICAgICAgICAgbWF0cml4ID0gcGFyZW50Lm10eFdvcmxkO1xyXG5cclxuICAgICAgICAvLyBzdGFydCByZWN1cnNpdmUgcmVjYWxjdWxhdGlvbiBvZiB0aGUgd2hvbGUgYnJhbmNoIHN0YXJ0aW5nIGZyb20gdGhlIGFuY2VzdG9yIGZvdW5kXHJcbiAgICAgICAgUmVuZGVyTWFuYWdlci5yZWNhbGN1bGF0ZVRyYW5zZm9ybXNPZk5vZGVBbmRDaGlsZHJlbihhbmNlc3RvciwgbWF0cml4KTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIGNhbGwgdGhlIGZ1bmN0aW9ucyBhYm92ZSBmb3IgZWFjaCByZWdpc3RlcmVkIG5vZGVcclxuICAgICAgLy8gUmVuZGVyTWFuYWdlci5ub2Rlcy5mb3JFYWNoKG1hcmtOb2RlVG9CZVRyYW5zZm9ybWVkKTtcclxuICAgICAgUmVuZGVyTWFuYWdlci5ub2Rlcy5mb3JFYWNoKHJlY2FsY3VsYXRlQnJhbmNoQ29udGFpbmluZ05vZGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVjdXJzaXZlIG1ldGhvZCByZWNlaXZpbmcgYSBjaGlsZG5vZGUgYW5kIGl0cyBwYXJlbnRzIHVwZGF0ZWQgd29ybGQgdHJhbnNmb3JtLiAgXHJcbiAgICAgKiBJZiB0aGUgY2hpbGRub2RlIG93bnMgYSBDb21wb25lbnRUcmFuc2Zvcm0sIGl0cyB3b3JsZG1hdHJpeCBpcyByZWNhbGN1bGF0ZWQgYW5kIHBhc3NlZCBvbiB0byBpdHMgY2hpbGRyZW4sIG90aGVyd2lzZSBpdHMgcGFyZW50cyBtYXRyaXhcclxuICAgICAqIEBwYXJhbSBfbm9kZSBcclxuICAgICAqIEBwYXJhbSBfd29ybGQgXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIHJlY2FsY3VsYXRlVHJhbnNmb3Jtc09mTm9kZUFuZENoaWxkcmVuKF9ub2RlOiBOb2RlLCBfd29ybGQ6IE1hdHJpeDR4NCk6IHZvaWQge1xyXG4gICAgICBsZXQgd29ybGQ6IE1hdHJpeDR4NCA9IF93b3JsZDtcclxuICAgICAgbGV0IGNtcFRyYW5zZm9ybTogQ29tcG9uZW50VHJhbnNmb3JtID0gX25vZGUuY21wVHJhbnNmb3JtO1xyXG4gICAgICBpZiAoY21wVHJhbnNmb3JtKVxyXG4gICAgICAgIHdvcmxkID0gTWF0cml4NHg0Lk1VTFRJUExJQ0FUSU9OKF93b3JsZCwgY21wVHJhbnNmb3JtLmxvY2FsKTtcclxuXHJcbiAgICAgIF9ub2RlLm10eFdvcmxkID0gd29ybGQ7XHJcbiAgICAgIF9ub2RlLnRpbWVzdGFtcFVwZGF0ZSA9IFJlbmRlck1hbmFnZXIudGltZXN0YW1wVXBkYXRlO1xyXG5cclxuICAgICAgZm9yIChsZXQgY2hpbGQgb2YgX25vZGUuZ2V0Q2hpbGRyZW4oKSkge1xyXG4gICAgICAgIFJlbmRlck1hbmFnZXIucmVjYWxjdWxhdGVUcmFuc2Zvcm1zT2ZOb2RlQW5kQ2hpbGRyZW4oY2hpbGQsIHdvcmxkKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vICNyZWdpb24gTWFuYWdlIHJlZmVyZW5jZXMgdG8gcmVuZGVyIGRhdGFcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhIHJlZmVyZW5jZSB0byBhIHByb2dyYW0sIHBhcmFtZXRlciBvciBidWZmZXIgYnkgZGVjcmVhc2luZyBpdHMgcmVmZXJlbmNlIGNvdW50ZXIgYW5kIGRlbGV0aW5nIGl0LCBpZiB0aGUgY291bnRlciByZWFjaGVzIDBcclxuICAgICAqIEBwYXJhbSBfaW4gXHJcbiAgICAgKiBAcGFyYW0gX2tleSBcclxuICAgICAqIEBwYXJhbSBfZGVsZXRvciBcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVtb3ZlUmVmZXJlbmNlPEtleVR5cGUsIFJlZmVyZW5jZVR5cGU+KF9pbjogTWFwPEtleVR5cGUsIFJlZmVyZW5jZTxSZWZlcmVuY2VUeXBlPj4sIF9rZXk6IEtleVR5cGUsIF9kZWxldG9yOiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgICBsZXQgcmVmZXJlbmNlOiBSZWZlcmVuY2U8UmVmZXJlbmNlVHlwZT47XHJcbiAgICAgIHJlZmVyZW5jZSA9IF9pbi5nZXQoX2tleSk7XHJcbiAgICAgIGlmIChyZWZlcmVuY2UuZGVjcmVhc2VDb3VudGVyKCkgPT0gMCkge1xyXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgZGVsZXRpb25zIG1heSBiZSBhbiBvcHRpbWl6YXRpb24sIG5vdCBuZWNlc3NhcnkgdG8gc3RhcnQgd2l0aCBhbmQgbWF5YmUgY291bnRlcnByb2R1Y3RpdmUuXHJcbiAgICAgICAgLy8gSWYgZGF0YSBzaG91bGQgYmUgdXNlZCBsYXRlciBhZ2FpbiwgaXQgbXVzdCB0aGVuIGJlIHJlY29uc3RydWN0ZWQuLi5cclxuICAgICAgICBfZGVsZXRvcihyZWZlcmVuY2UuZ2V0UmVmZXJlbmNlKCkpO1xyXG4gICAgICAgIF9pbi5kZWxldGUoX2tleSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluY3JlYXNlcyB0aGUgY291bnRlciBvZiB0aGUgcmVmZXJlbmNlIHRvIGEgcHJvZ3JhbSwgcGFyYW1ldGVyIG9yIGJ1ZmZlci4gQ3JlYXRlcyB0aGUgcmVmZXJlbmNlLCBpZiBpdCdzIG5vdCBleGlzdGVudC5cclxuICAgICAqIEBwYXJhbSBfaW4gXHJcbiAgICAgKiBAcGFyYW0gX2tleSBcclxuICAgICAqIEBwYXJhbSBfY3JlYXRvciBcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgY3JlYXRlUmVmZXJlbmNlPEtleVR5cGUsIFJlZmVyZW5jZVR5cGU+KF9pbjogTWFwPEtleVR5cGUsIFJlZmVyZW5jZTxSZWZlcmVuY2VUeXBlPj4sIF9rZXk6IEtleVR5cGUsIF9jcmVhdG9yOiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgICBsZXQgcmVmZXJlbmNlOiBSZWZlcmVuY2U8UmVmZXJlbmNlVHlwZT47XHJcbiAgICAgIHJlZmVyZW5jZSA9IF9pbi5nZXQoX2tleSk7XHJcbiAgICAgIGlmIChyZWZlcmVuY2UpXHJcbiAgICAgICAgcmVmZXJlbmNlLmluY3JlYXNlQ291bnRlcigpO1xyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBsZXQgY29udGVudDogUmVmZXJlbmNlVHlwZSA9IF9jcmVhdG9yKF9rZXkpO1xyXG4gICAgICAgIHJlZmVyZW5jZSA9IG5ldyBSZWZlcmVuY2U8UmVmZXJlbmNlVHlwZT4oY29udGVudCk7XHJcbiAgICAgICAgcmVmZXJlbmNlLmluY3JlYXNlQ291bnRlcigpO1xyXG4gICAgICAgIF9pbi5zZXQoX2tleSwgcmVmZXJlbmNlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gI2VuZHJlZ2lvblxyXG4gIH1cclxufSIsIi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vQ29hdC9Db2F0LnRzXCIvPlxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBTdGF0aWMgc3VwZXJjbGFzcyBmb3IgdGhlIHJlcHJlc2VudGF0aW9uIG9mIFdlYkdsIHNoYWRlcnByb2dyYW1zLiBcclxuICAgKiBAYXV0aG9ycyBKYXNjaGEgS2FyYWfDtmwsIEhGVSwgMjAxOSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcblxyXG4gIC8vIFRPRE86IGRlZmluZSBhdHRyaWJ1dGUvdW5pZm9ybXMgYXMgbGF5b3V0IGFuZCB1c2UgdGhvc2UgY29uc2lzdGVudGx5IGluIHNoYWRlcnNcclxuXHJcbiAgZXhwb3J0IGNsYXNzIFNoYWRlciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IHN1YmNsYXNzZXM6IHR5cGVvZiBTaGFkZXJbXSA9IFtdO1xyXG4gICAgLyoqIFRoZSB0eXBlIG9mIGNvYXQgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIHRoaXMgc2hhZGVyIHRvIGNyZWF0ZSBhIG1hdGVyaWFsICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQgeyByZXR1cm4gbnVsbDsgfVxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRWZXJ0ZXhTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHsgcmV0dXJuIG51bGw7IH1cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHsgcmV0dXJuIG51bGw7IH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHJlZ2lzdGVyU3ViY2xhc3MoX3N1YmNsYXNzOiB0eXBlb2YgU2hhZGVyKTogbnVtYmVyIHsgcmV0dXJuIFNoYWRlci5zdWJjbGFzc2VzLnB1c2goX3N1YmNsYXNzKSAtIDE7IH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBTaW5nbGUgY29sb3Igc2hhZGluZ1xyXG4gICAqIEBhdXRob3JzIEphc2NoYSBLYXJhZ8O2bCwgSEZVLCAyMDE5IHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgU2hhZGVyRmxhdCBleHRlbmRzIFNoYWRlciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gU2hhZGVyLnJlZ2lzdGVyU3ViY2xhc3MoU2hhZGVyRmxhdCk7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRDb2F0KCk6IHR5cGVvZiBDb2F0IHtcclxuICAgICAgcmV0dXJuIENvYXRDb2xvcmVkO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0VmVydGV4U2hhZGVyU291cmNlKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiBgI3ZlcnNpb24gMzAwIGVzXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHN0cnVjdCBMaWdodEFtYmllbnQge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IGNvbG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgc3RydWN0IExpZ2h0RGlyZWN0aW9uYWwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IGNvbG9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMzIGRpcmVjdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB1aW50IE1BWF9MSUdIVFNfRElSRUNUSU9OQUwgPSAxMHU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGluIHZlYzMgYV9wb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBpbiB2ZWMzIGFfbm9ybWFsO1xyXG4gICAgICAgICAgICAgICAgICAgIHVuaWZvcm0gbWF0NCB1X3dvcmxkO1xyXG4gICAgICAgICAgICAgICAgICAgIHVuaWZvcm0gbWF0NCB1X3Byb2plY3Rpb247XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHVuaWZvcm0gTGlnaHRBbWJpZW50IHVfYW1iaWVudDtcclxuICAgICAgICAgICAgICAgICAgICB1bmlmb3JtIHVpbnQgdV9uTGlnaHRzRGlyZWN0aW9uYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybSBMaWdodERpcmVjdGlvbmFsIHVfZGlyZWN0aW9uYWxbTUFYX0xJR0hUU19ESVJFQ1RJT05BTF07XHJcbiAgICAgICAgICAgICAgICAgICAgZmxhdCBvdXQgdmVjNCB2X2NvbG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIHZvaWQgbWFpbigpIHsgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB1X3Byb2plY3Rpb24gKiB2ZWM0KGFfcG9zaXRpb24sIDEuMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzMgbm9ybWFsID0gbm9ybWFsaXplKG1hdDModV93b3JsZCkgKiBhX25vcm1hbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2X2NvbG9yID0gdV9hbWJpZW50LmNvbG9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHVpbnQgaSA9IDB1OyBpIDwgdV9uTGlnaHRzRGlyZWN0aW9uYWw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgaWxsdW1pbmF0aW9uID0gLWRvdChub3JtYWwsIHVfZGlyZWN0aW9uYWxbaV0uZGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbGx1bWluYXRpb24gPiAwLjBmKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZfY29sb3IgKz0gaWxsdW1pbmF0aW9uICogdV9kaXJlY3Rpb25hbFtpXS5jb2xvcjsgLy8gdmVjNCgxLDEsMSwxKTsgLy8gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdl9jb2xvci5hID0gMS4wO1xyXG4gICAgICAgICAgICAgICAgICAgIH1gO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gYCN2ZXJzaW9uIDMwMCBlc1xyXG4gICAgICAgICAgICAgICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB1bmlmb3JtIHZlYzQgdV9jb2xvcjtcclxuICAgICAgICAgICAgICAgICAgICBmbGF0IGluIHZlYzQgdl9jb2xvcjtcclxuICAgICAgICAgICAgICAgICAgICBvdXQgdmVjNCBmcmFnO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZyA9IHVfY29sb3IgKiB2X2NvbG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIH1gO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIlxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBNYXRjYXAgKE1hdGVyaWFsIENhcHR1cmUpIHNoYWRpbmcuIFRoZSB0ZXh0dXJlIHByb3ZpZGVkIGJ5IHRoZSBjb2F0IGlzIHVzZWQgYXMgYSBtYXRjYXAgbWF0ZXJpYWwuIFxyXG4gICAqIEltcGxlbWVudGF0aW9uIGJhc2VkIG9uIGh0dHBzOi8vd3d3LmNsaWNrdG9yZWxlYXNlLmNvbS9ibG9nL2NyZWF0aW5nLXNwaGVyaWNhbC1lbnZpcm9ubWVudC1tYXBwaW5nLXNoYWRlci9cclxuICAgKiBAYXV0aG9ycyBTaW1vbiBTdG9ybC1TY2h1bGtlLCBIRlUsIDIwMTkgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBTaGFkZXJNYXRDYXAgZXh0ZW5kcyBTaGFkZXIge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IFNoYWRlci5yZWdpc3RlclN1YmNsYXNzKFNoYWRlck1hdENhcCk7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRDb2F0KCk6IHR5cGVvZiBDb2F0IHtcclxuICAgICAgcmV0dXJuIENvYXRNYXRDYXA7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRWZXJ0ZXhTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIGAjdmVyc2lvbiAzMDAgZXNcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaW4gdmVjMyBhX3Bvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGluIHZlYzMgYV9ub3JtYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybSBtYXQ0IHVfcHJvamVjdGlvbjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0IHZlYzIgdGV4X2Nvb3Jkc19zbW9vdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxhdCBvdXQgdmVjMiB0ZXhfY29vcmRzX2ZsYXQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0NCBub3JtYWxNYXRyaXggPSB0cmFuc3Bvc2UoaW52ZXJzZSh1X3Byb2plY3Rpb24pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCBwID0gdmVjNChhX3Bvc2l0aW9uLCAxLjApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IG5vcm1hbDQgPSB2ZWM0KGFfbm9ybWFsLCAxLjApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMzIGUgPSBub3JtYWxpemUoIHZlYzMoIHVfcHJvamVjdGlvbiAqIHAgKSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMzIG4gPSBub3JtYWxpemUoIHZlYzMobm9ybWFsTWF0cml4ICogbm9ybWFsNCkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzMgciA9IHJlZmxlY3QoIGUsIG4gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgbSA9IDIuICogc3FydChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvdyggci54LCAyLiApICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvdyggci55LCAyLiApICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvdyggci56ICsgMS4sIDIuIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleF9jb29yZHNfc21vb3RoID0gci54eSAvIG0gKyAuNTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4X2Nvb3Jkc19mbGF0ID0gci54eSAvIG0gKyAuNTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdV9wcm9qZWN0aW9uICogdmVjNChhX3Bvc2l0aW9uLCAxLjApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1gO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gYCN2ZXJzaW9uIDMwMCBlc1xyXG4gICAgICAgICAgICAgICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIHVuaWZvcm0gdmVjNCB1X3RpbnRfY29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB1X2ZsYXRtaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIGluIHZlYzIgdGV4X2Nvb3Jkc19zbW9vdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxhdCBpbiB2ZWMyIHRleF9jb29yZHNfZmxhdDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0IHZlYzQgZnJhZztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdm9pZCBtYWluKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMyIHRjID0gbWl4KHRleF9jb29yZHNfc21vb3RoLCB0ZXhfY29vcmRzX2ZsYXQsIHVfZmxhdG1peCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcgPSB1X3RpbnRfY29sb3IgKiB0ZXh0dXJlKHVfdGV4dHVyZSwgdGMpICogMi4wO1xyXG4gICAgICAgICAgICAgICAgICAgIH1gO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFJlbmRlcnMgZm9yIFJheWNhc3RpbmdcclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBTaGFkZXJSYXlDYXN0IGV4dGVuZHMgU2hhZGVyIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0VmVydGV4U2hhZGVyU291cmNlKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiBgI3ZlcnNpb24gMzAwIGVzXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGluIHZlYzMgYV9wb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICB1bmlmb3JtIG1hdDQgdV9wcm9qZWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIHZvaWQgbWFpbigpIHsgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB1X3Byb2plY3Rpb24gKiB2ZWM0KGFfcG9zaXRpb24sIDEuMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfWA7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc3RhdGljIGdldEZyYWdtZW50U2hhZGVyU291cmNlKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiBgI3ZlcnNpb24gMzAwIGVzXHJcbiAgICAgICAgICAgICAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJlY2lzaW9uIGhpZ2hwIGludDtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICB1bmlmb3JtIGludCB1X2lkO1xyXG4gICAgICAgICAgICAgICAgICAgIG91dCB2ZWM0IGZyYWc7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgdm9pZCBtYWluKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IGlkID0gZmxvYXQodV9pZCkvIDI1Ni4wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHVwcGVyYnl0ZSA9IHRydW5jKGdsX0ZyYWdDb29yZC56ICogMjU2LjApIC8gMjU2LjA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgbG93ZXJieXRlID0gZnJhY3QoZ2xfRnJhZ0Nvb3JkLnogKiAyNTYuMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgZnJhZyA9IHZlYzQoZ2xfRnJhZ0Nvb3JkLnosIHVwcGVyYnl0ZSwgbG93ZXJieXRlLCAxLjApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1gO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFRleHR1cmVkIHNoYWRpbmdcclxuICAgKiBAYXV0aG9ycyBKYXNjaGEgS2FyYWfDtmwsIEhGVSwgMjAxOSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFNoYWRlclRleHR1cmUgZXh0ZW5kcyBTaGFkZXIge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IFNoYWRlci5yZWdpc3RlclN1YmNsYXNzKFNoYWRlclRleHR1cmUpO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0Q29hdCgpOiB0eXBlb2YgQ29hdCB7XHJcbiAgICAgIHJldHVybiBDb2F0VGV4dHVyZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRWZXJ0ZXhTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIGAjdmVyc2lvbiAzMDAgZXNcclxuXHJcbiAgICAgICAgICAgICAgICBpbiB2ZWMzIGFfcG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICBpbiB2ZWMyIGFfdGV4dHVyZVVWcztcclxuICAgICAgICAgICAgICAgIHVuaWZvcm0gbWF0NCB1X3Byb2plY3Rpb247XHJcbiAgICAgICAgICAgICAgICB1bmlmb3JtIHZlYzQgdV9jb2xvcjtcclxuICAgICAgICAgICAgICAgIHVuaWZvcm0gbWF0MyB1X3Bpdm90O1xyXG4gICAgICAgICAgICAgICAgb3V0IHZlYzIgdl90ZXh0dXJlVVZzO1xyXG5cclxuICAgICAgICAgICAgICAgIHZvaWQgbWFpbigpIHsgIFxyXG4gICAgICAgICAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdV9wcm9qZWN0aW9uICogdmVjNChhX3Bvc2l0aW9uLCAxLjApO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHZfdGV4dHVyZVVWcyA9IGFfdGV4dHVyZVVWcztcclxuICAgICAgICAgICAgICAgICAgICB2X3RleHR1cmVVVnMgPSB2ZWMyKHVfcGl2b3QgKiB2ZWMzKGFfdGV4dHVyZVVWcywgMS4wKSkueHk7XHJcbiAgICAgICAgICAgICAgICB9YDtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIGAjdmVyc2lvbiAzMDAgZXNcclxuICAgICAgICAgICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpbiB2ZWMyIHZfdGV4dHVyZVVWcztcclxuICAgICAgICAgICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcclxuICAgICAgICAgICAgICAgIG91dCB2ZWM0IGZyYWc7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBmcmFnID0gdGV4dHVyZSh1X3RleHR1cmUsIHZfdGV4dHVyZVVWcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWcuYSA8IDAuMDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICBkaXNjYXJkO1xyXG4gICAgICAgICAgICB9YDtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBTaW5nbGUgY29sb3Igc2hhZGluZ1xyXG4gICAqIEBhdXRob3JzIEphc2NoYSBLYXJhZ8O2bCwgSEZVLCAyMDE5IHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgU2hhZGVyVW5pQ29sb3IgZXh0ZW5kcyBTaGFkZXIge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IFNoYWRlci5yZWdpc3RlclN1YmNsYXNzKFNoYWRlclVuaUNvbG9yKTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQge1xyXG4gICAgICByZXR1cm4gQ29hdENvbG9yZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRWZXJ0ZXhTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIGAjdmVyc2lvbiAzMDAgZXNcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaW4gdmVjMyBhX3Bvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIHVuaWZvcm0gbWF0NCB1X3Byb2plY3Rpb247XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgdm9pZCBtYWluKCkgeyAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHVfcHJvamVjdGlvbiAqIHZlYzQoYV9wb3NpdGlvbiwgMS4wKTtcclxuICAgICAgICAgICAgICAgICAgICB9YDtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIGAjdmVyc2lvbiAzMDAgZXNcclxuICAgICAgICAgICAgICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICB1bmlmb3JtIHZlYzQgdV9jb2xvcjtcclxuICAgICAgICAgICAgICAgICAgICBvdXQgdmVjNCBmcmFnO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBmcmFnID0gdV9jb2xvcjtcclxuICAgICAgICAgICAgICAgICAgICB9YDtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAgIC8qKlxyXG4gICAgICogQmFzZWNsYXNzIGZvciBkaWZmZXJlbnQga2luZHMgb2YgdGV4dHVyZXMuIFxyXG4gICAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgICAqL1xyXG4gICAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFRleHR1cmUgZXh0ZW5kcyBNdXRhYmxlIHtcclxuICAgICAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcigpOiB2b2lkIHsvKiovIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRleHR1cmUgY3JlYXRlZCBmcm9tIGFuIGV4aXN0aW5nIGltYWdlXHJcbiAgICAgKi9cclxuICAgIGV4cG9ydCBjbGFzcyBUZXh0dXJlSW1hZ2UgZXh0ZW5kcyBUZXh0dXJlIHtcclxuICAgICAgICBwdWJsaWMgaW1hZ2U6IEhUTUxJbWFnZUVsZW1lbnQgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXh0dXJlIGNyZWF0ZWQgZnJvbSBhIGNhbnZhc1xyXG4gICAgICovXHJcbiAgICBleHBvcnQgY2xhc3MgVGV4dHVyZUNhbnZhcyBleHRlbmRzIFRleHR1cmUge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXh0dXJlIGNyZWF0ZWQgZnJvbSBhIEZVREdFLVNrZXRjaFxyXG4gICAgICovXHJcbiAgICBleHBvcnQgY2xhc3MgVGV4dHVyZVNrZXRjaCBleHRlbmRzIFRleHR1cmVDYW52YXMge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXh0dXJlIGNyZWF0ZWQgZnJvbSBhbiBIVE1MLXBhZ2VcclxuICAgICAqL1xyXG4gICAgZXhwb3J0IGNsYXNzIFRleHR1cmVIVE1MIGV4dGVuZHMgVGV4dHVyZUNhbnZhcyB7XHJcbiAgICB9XHJcbn0iLCIvLyAvPHJlZmVyZW5jZSBwYXRoPVwiLi4vRXZlbnQvRXZlbnQudHNcIi8+XHJcbi8vIC88cmVmZXJlbmNlIHBhdGg9XCIuLi9UaW1lL1RpbWUudHNcIi8+XHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIERldGVybWluZXMgdGhlIG1vZGUgYSBsb29wIHJ1bnMgaW5cclxuICAgKi9cclxuICBleHBvcnQgZW51bSBMT09QX01PREUge1xyXG4gICAgLyoqIExvb3AgY3ljbGVzIGNvbnRyb2xsZWQgYnkgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSAqL1xyXG4gICAgRlJBTUVfUkVRVUVTVCA9IFwiZnJhbWVSZXF1ZXN0XCIsXHJcbiAgICAvKiogTG9vcCBjeWNsZXMgd2l0aCB0aGUgZ2l2ZW4gZnJhbWVyYXRlIGluIFtbVGltZV1dLmdhbWUgKi9cclxuICAgIFRJTUVfR0FNRSA9IFwidGltZUdhbWVcIixcclxuICAgIC8qKiBMb29wIGN5Y2xlcyB3aXRoIHRoZSBnaXZlbiBmcmFtZXJhdGUgaW4gcmVhbHRpbWUsIGluZGVwZW5kZW50IG9mIFtbVGltZV1dLmdhbWUgKi9cclxuICAgIFRJTUVfUkVBTCA9IFwidGltZVJlYWxcIlxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29yZSBsb29wIG9mIGEgRnVkZ2UgYXBwbGljYXRpb24uIEluaXRpYWxpemVzIGF1dG9tYXRpY2FsbHkgYW5kIG11c3QgYmUgc3RhcnRlZCBleHBsaWNpdGx5LlxyXG4gICAqIEl0IHRoZW4gZmlyZXMgW1tFVkVOVF1dLkxPT1BcXF9GUkFNRSB0byBhbGwgYWRkZWQgbGlzdGVuZXJzIGF0IGVhY2ggZnJhbWVcclxuICAgKiBcclxuICAgKiBAYXV0aG9yIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIExvb3AgZXh0ZW5kcyBFdmVudFRhcmdldFN0YXRpYyB7XHJcbiAgICAvKiogVGhlIGdhbWV0aW1lIHRoZSBsb29wIHdhcyBzdGFydGVkLCBvdmVyd3JpdHRlbiBhdCBlYWNoIHN0YXJ0ICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHRpbWVTdGFydEdhbWU6IG51bWJlciA9IDA7XHJcbiAgICAvKiogVGhlIHJlYWx0aW1lIHRoZSBsb29wIHdhcyBzdGFydGVkLCBvdmVyd3JpdHRlbiBhdCBlYWNoIHN0YXJ0ICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHRpbWVTdGFydFJlYWw6IG51bWJlciA9IDA7XHJcbiAgICAvKiogVGhlIGdhbWV0aW1lIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgbG9vcCBjeWNsZSAqL1xyXG4gICAgcHVibGljIHN0YXRpYyB0aW1lRnJhbWVHYW1lOiBudW1iZXIgPSAwO1xyXG4gICAgLyoqIFRoZSByZWFsdGltZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IGxvb3AgY3ljbGUgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgdGltZUZyYW1lUmVhbDogbnVtYmVyID0gMDtcclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyB0aW1lTGFzdEZyYW1lR2FtZTogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgc3RhdGljIHRpbWVMYXN0RnJhbWVSZWFsOiBudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgdGltZUxhc3RGcmFtZUdhbWVBdmc6IG51bWJlciA9IDA7XHJcbiAgICBwcml2YXRlIHN0YXRpYyB0aW1lTGFzdEZyYW1lUmVhbEF2ZzogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgc3RhdGljIHJ1bm5pbmc6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIHByaXZhdGUgc3RhdGljIG1vZGU6IExPT1BfTU9ERSA9IExPT1BfTU9ERS5GUkFNRV9SRVFVRVNUO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgaWRJbnRlcnZhbGw6IG51bWJlciA9IDA7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBpZFJlcXVlc3Q6IG51bWJlciA9IDA7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBmcHNEZXNpcmVkOiBudW1iZXIgPSAzMDtcclxuICAgIHByaXZhdGUgc3RhdGljIGZyYW1lc1RvQXZlcmFnZTogbnVtYmVyID0gMzA7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBzeW5jV2l0aEFuaW1hdGlvbkZyYW1lOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgdGhlIGxvb3Agd2l0aCB0aGUgZ2l2ZW4gbW9kZSBhbmQgZnBzXHJcbiAgICAgKiBAcGFyYW0gX21vZGUgXHJcbiAgICAgKiBAcGFyYW0gX2ZwcyBJcyBvbmx5IGFwcGxpY2FibGUgaW4gVElNRS1tb2Rlc1xyXG4gICAgICogQHBhcmFtIF9zeW5jV2l0aEFuaW1hdGlvbkZyYW1lIEV4cGVyaW1lbnRhbCBhbmQgb25seSBhcHBsaWNhYmxlIGluIFRJTUUtbW9kZXMuIFNob3VsZCBkZWZlciB0aGUgbG9vcC1jeWNsZSB1bnRpbCB0aGUgbmV4dCBwb3NzaWJsZSBhbmltYXRpb24gZnJhbWUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc3RhcnQoX21vZGU6IExPT1BfTU9ERSA9IExPT1BfTU9ERS5GUkFNRV9SRVFVRVNULCBfZnBzOiBudW1iZXIgPSA2MCwgX3N5bmNXaXRoQW5pbWF0aW9uRnJhbWU6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xyXG4gICAgICBMb29wLnN0b3AoKTtcclxuXHJcbiAgICAgIExvb3AudGltZVN0YXJ0R2FtZSA9IFRpbWUuZ2FtZS5nZXQoKTtcclxuICAgICAgTG9vcC50aW1lU3RhcnRSZWFsID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgIExvb3AudGltZUxhc3RGcmFtZUdhbWUgPSBMb29wLnRpbWVTdGFydEdhbWU7XHJcbiAgICAgIExvb3AudGltZUxhc3RGcmFtZVJlYWwgPSBMb29wLnRpbWVTdGFydFJlYWw7XHJcbiAgICAgIExvb3AuZnBzRGVzaXJlZCA9IChfbW9kZSA9PSBMT09QX01PREUuRlJBTUVfUkVRVUVTVCkgPyA2MCA6IF9mcHM7XHJcbiAgICAgIExvb3AuZnJhbWVzVG9BdmVyYWdlID0gTG9vcC5mcHNEZXNpcmVkO1xyXG4gICAgICBMb29wLnRpbWVMYXN0RnJhbWVHYW1lQXZnID0gTG9vcC50aW1lTGFzdEZyYW1lUmVhbEF2ZyA9IDEwMDAgLyBMb29wLmZwc0Rlc2lyZWQ7XHJcbiAgICAgIExvb3AubW9kZSA9IF9tb2RlO1xyXG4gICAgICBMb29wLnN5bmNXaXRoQW5pbWF0aW9uRnJhbWUgPSBfc3luY1dpdGhBbmltYXRpb25GcmFtZTtcclxuXHJcbiAgICAgIGxldCBsb2c6IHN0cmluZyA9IGBMb29wIHN0YXJ0aW5nIGluIG1vZGUgJHtMb29wLm1vZGV9YDtcclxuICAgICAgaWYgKExvb3AubW9kZSAhPSBMT09QX01PREUuRlJBTUVfUkVRVUVTVClcclxuICAgICAgICBsb2cgKz0gYCB3aXRoIGF0dGVtcHRlZCAke19mcHN9IGZwc2A7XHJcbiAgICAgIERlYnVnLmxvZyhsb2cpO1xyXG5cclxuICAgICAgc3dpdGNoIChfbW9kZSkge1xyXG4gICAgICAgIGNhc2UgTE9PUF9NT0RFLkZSQU1FX1JFUVVFU1Q6XHJcbiAgICAgICAgICBMb29wLmxvb3BGcmFtZSgpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBMT09QX01PREUuVElNRV9SRUFMOlxyXG4gICAgICAgICAgTG9vcC5pZEludGVydmFsbCA9IHdpbmRvdy5zZXRJbnRlcnZhbChMb29wLmxvb3BUaW1lLCAxMDAwIC8gTG9vcC5mcHNEZXNpcmVkKTtcclxuICAgICAgICAgIExvb3AubG9vcFRpbWUoKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgTE9PUF9NT0RFLlRJTUVfR0FNRTpcclxuICAgICAgICAgIExvb3AuaWRJbnRlcnZhbGwgPSBUaW1lLmdhbWUuc2V0VGltZXIoMTAwMCAvIExvb3AuZnBzRGVzaXJlZCwgMCwgTG9vcC5sb29wVGltZSk7XHJcbiAgICAgICAgICBMb29wLmxvb3BUaW1lKCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIExvb3AucnVubmluZyA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wcyB0aGUgbG9vcFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHN0b3AoKTogdm9pZCB7XHJcbiAgICAgIGlmICghTG9vcC5ydW5uaW5nKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIHN3aXRjaCAoTG9vcC5tb2RlKSB7XHJcbiAgICAgICAgY2FzZSBMT09QX01PREUuRlJBTUVfUkVRVUVTVDpcclxuICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShMb29wLmlkUmVxdWVzdCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIExPT1BfTU9ERS5USU1FX1JFQUw6XHJcbiAgICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbChMb29wLmlkSW50ZXJ2YWxsKTtcclxuICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShMb29wLmlkUmVxdWVzdCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIExPT1BfTU9ERS5USU1FX0dBTUU6XHJcbiAgICAgICAgICBUaW1lLmdhbWUuZGVsZXRlVGltZXIoTG9vcC5pZEludGVydmFsbCk7XHJcbiAgICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoTG9vcC5pZFJlcXVlc3QpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBMb29wLnJ1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgRGVidWcubG9nKFwiTG9vcCBzdG9wcGVkIVwiKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldEZwc0dhbWVBdmVyYWdlKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiAxMDAwIC8gTG9vcC50aW1lTGFzdEZyYW1lR2FtZUF2ZztcclxuICAgIH1cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0RnBzUmVhbEF2ZXJhZ2UoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIDEwMDAgLyBMb29wLnRpbWVMYXN0RnJhbWVSZWFsQXZnO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGxvb3AoKTogdm9pZCB7XHJcbiAgICAgIGxldCB0aW1lOiBudW1iZXI7XHJcbiAgICAgIHRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgTG9vcC50aW1lRnJhbWVSZWFsID0gdGltZSAtIExvb3AudGltZUxhc3RGcmFtZVJlYWw7XHJcbiAgICAgIExvb3AudGltZUxhc3RGcmFtZVJlYWwgPSB0aW1lO1xyXG5cclxuICAgICAgdGltZSA9IFRpbWUuZ2FtZS5nZXQoKTtcclxuICAgICAgTG9vcC50aW1lRnJhbWVHYW1lID0gdGltZSAtIExvb3AudGltZUxhc3RGcmFtZUdhbWU7XHJcbiAgICAgIExvb3AudGltZUxhc3RGcmFtZUdhbWUgPSB0aW1lO1xyXG5cclxuICAgICAgTG9vcC50aW1lTGFzdEZyYW1lR2FtZUF2ZyA9ICgoTG9vcC5mcmFtZXNUb0F2ZXJhZ2UgLSAxKSAqIExvb3AudGltZUxhc3RGcmFtZUdhbWVBdmcgKyBMb29wLnRpbWVGcmFtZUdhbWUpIC8gTG9vcC5mcmFtZXNUb0F2ZXJhZ2U7XHJcbiAgICAgIExvb3AudGltZUxhc3RGcmFtZVJlYWxBdmcgPSAoKExvb3AuZnJhbWVzVG9BdmVyYWdlIC0gMSkgKiBMb29wLnRpbWVMYXN0RnJhbWVSZWFsQXZnICsgTG9vcC50aW1lRnJhbWVSZWFsKSAvIExvb3AuZnJhbWVzVG9BdmVyYWdlO1xyXG5cclxuICAgICAgbGV0IGV2ZW50OiBFdmVudCA9IG5ldyBFdmVudChFVkVOVC5MT09QX0ZSQU1FKTtcclxuICAgICAgTG9vcC50YXJnZXRTdGF0aWMuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgbG9vcEZyYW1lKCk6IHZvaWQge1xyXG4gICAgICBMb29wLmxvb3AoKTtcclxuICAgICAgTG9vcC5pZFJlcXVlc3QgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKExvb3AubG9vcEZyYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBsb29wVGltZSgpOiB2b2lkIHtcclxuICAgICAgaWYgKExvb3Auc3luY1dpdGhBbmltYXRpb25GcmFtZSlcclxuICAgICAgICBMb29wLmlkUmVxdWVzdCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoTG9vcC5sb29wKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIExvb3AubG9vcCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgaW50ZXJmYWNlIFRpbWVVbml0cyB7XHJcbiAgICBob3Vycz86IG51bWJlcjtcclxuICAgIG1pbnV0ZXM/OiBudW1iZXI7XHJcbiAgICBzZWNvbmRzPzogbnVtYmVyO1xyXG4gICAgdGVudGhzPzogbnVtYmVyO1xyXG4gICAgaHVuZHJlZHM/OiBudW1iZXI7XHJcbiAgICB0aG91c2FuZHM/OiBudW1iZXI7XHJcbiAgICBmcmFjdGlvbj86IG51bWJlcjtcclxuICAgIGFzSG91cnM/OiBudW1iZXI7XHJcbiAgICBhc01pbnV0ZXM/OiBudW1iZXI7XHJcbiAgICBhc1NlY29uZHM/OiBudW1iZXI7XHJcbiAgfVxyXG5cclxuICBleHBvcnQgaW50ZXJmYWNlIFRpbWVycyBleHRlbmRzIE9iamVjdCB7XHJcbiAgICBbaWQ6IG51bWJlcl06IFRpbWVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MgZ2VuZXJhdGUgYSB0aW1lc3RhbXAgdGhhdCBjb3JyZWxhdGVzIHdpdGggdGhlIHRpbWUgZWxhcHNlZCBzaW5jZSB0aGUgc3RhcnQgb2YgdGhlIHByb2dyYW0gYnV0IGFsbG93cyBmb3IgcmVzZXR0aW5nIGFuZCBzY2FsaW5nLiAgXHJcbiAgICogU3VwcG9ydHMgW1tUaW1lcl1dcyBzaW1pbGFyIHRvIHdpbmRvdy5zZXRJbnRlcnZhbCBidXQgd2l0aCByZXNwZWN0IHRvIHRoZSBzY2FsZWQgdGltZS5cclxuICAgKiBBbGwgdGltZSB2YWx1ZXMgYXJlIGdpdmVuIGluIG1pbGxpc2Vjb25kc1xyXG4gICAqIFxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFRpbWUgZXh0ZW5kcyBFdmVudFRhcmdldMaSIHtcclxuICAgIC8qKiBTdGFuZGFyZCBnYW1lIHRpbWUgc3RhcnRpbmcgYXV0b21hdGljYWxseSB3aXRoIHRoZSBhcHBsaWNhdGlvbiAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBnYW1lOiBUaW1lID0gbmV3IFRpbWUoKTtcclxuICAgIHByaXZhdGUgc3RhcnQ6IG51bWJlcjtcclxuICAgIHByaXZhdGUgc2NhbGU6IG51bWJlcjtcclxuICAgIHByaXZhdGUgb2Zmc2V0OiBudW1iZXI7XHJcbiAgICBwcml2YXRlIGxhc3RDYWxsVG9FbGFwc2VkOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIHRpbWVyczogVGltZXJzID0ge307XHJcbiAgICBwcml2YXRlIGlkVGltZXJOZXh0OiBudW1iZXIgPSAwO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLnN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgIHRoaXMuc2NhbGUgPSAxLjA7XHJcbiAgICAgIHRoaXMub2Zmc2V0ID0gMC4wO1xyXG4gICAgICB0aGlzLmxhc3RDYWxsVG9FbGFwc2VkID0gMC4wO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZ2FtZS10aW1lLW9iamVjdCB3aGljaCBzdGFydHMgYXV0b21hdGljYWxseSBhbmQgc2VydmVzIGFzIGJhc2UgZm9yIHZhcmlvdXMgaW50ZXJuYWwgb3BlcmF0aW9ucy4gXHJcbiAgICAgKi9cclxuICAgIC8vIHB1YmxpYyBzdGF0aWMgZ2V0IGdhbWUoKTogVGltZSB7XHJcbiAgICAvLyAgIHJldHVybiBUaW1lLmdhbWVUaW1lO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0VW5pdHMoX21pbGxpc2Vjb25kczogbnVtYmVyKTogVGltZVVuaXRzIHtcclxuICAgICAgbGV0IHVuaXRzOiBUaW1lVW5pdHMgPSB7fTtcclxuXHJcbiAgICAgIHVuaXRzLmFzU2Vjb25kcyA9IF9taWxsaXNlY29uZHMgLyAxMDAwO1xyXG4gICAgICB1bml0cy5hc01pbnV0ZXMgPSB1bml0cy5hc1NlY29uZHMgLyA2MDtcclxuICAgICAgdW5pdHMuYXNIb3VycyA9IHVuaXRzLmFzTWludXRlcyAvIDYwO1xyXG5cclxuICAgICAgdW5pdHMuaG91cnMgPSBNYXRoLmZsb29yKHVuaXRzLmFzSG91cnMpO1xyXG4gICAgICB1bml0cy5taW51dGVzID0gTWF0aC5mbG9vcih1bml0cy5hc01pbnV0ZXMpICUgNjA7XHJcbiAgICAgIHVuaXRzLnNlY29uZHMgPSBNYXRoLmZsb29yKHVuaXRzLmFzU2Vjb25kcykgJSA2MDtcclxuXHJcbiAgICAgIHVuaXRzLmZyYWN0aW9uID0gX21pbGxpc2Vjb25kcyAlIDEwMDA7XHJcbiAgICAgIHVuaXRzLnRob3VzYW5kcyA9IF9taWxsaXNlY29uZHMgJSAxMDtcclxuICAgICAgdW5pdHMuaHVuZHJlZHMgPSBfbWlsbGlzZWNvbmRzICUgMTAwIC0gdW5pdHMudGhvdXNhbmRzO1xyXG4gICAgICB1bml0cy50ZW50aHMgPSB1bml0cy5mcmFjdGlvbiAtIHVuaXRzLmh1bmRyZWRzIC0gdW5pdHMudGhvdXNhbmRzO1xyXG5cclxuICAgICAgcmV0dXJuIHVuaXRzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBHZXQvU2V0IHRpbWUgYW5kIHNjYWxpbmdcclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIHRoZSBjdXJyZW50IHNjYWxlZCB0aW1lc3RhbXAgb2YgdGhpcyBpbnN0YW5jZSBpbiBtaWxsaXNlY29uZHNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5vZmZzZXQgKyB0aGlzLnNjYWxlICogKHBlcmZvcm1hbmNlLm5vdygpIC0gdGhpcy5zdGFydCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSByZW1haW5pbmcgdGltZSB0byB0aGUgZ2l2ZW4gcG9pbnQgb2YgdGltZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0UmVtYWluZGVyKF90bzogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIF90byAtIHRoaXMuZ2V0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAoUmUtKSBTZXRzIHRoZSB0aW1lc3RhbXAgb2YgdGhpcyBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIF90aW1lIFRoZSB0aW1lc3RhbXAgdG8gcmVwcmVzZW50IHRoZSBjdXJyZW50IHRpbWUgKGRlZmF1bHQgMC4wKVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0KF90aW1lOiBudW1iZXIgPSAwKTogdm9pZCB7XHJcbiAgICAgIHRoaXMub2Zmc2V0ID0gX3RpbWU7XHJcbiAgICAgIHRoaXMuc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgdGhpcy5nZXRFbGFwc2VkU2luY2VQcmV2aW91c0NhbGwoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHNjYWxpbmcgb2YgdGhpcyB0aW1lLCBhbGxvd2luZyBmb3Igc2xvd21vdGlvbiAoPDEpIG9yIGZhc3Rmb3J3YXJkICg+MSkgXHJcbiAgICAgKiBAcGFyYW0gX3NjYWxlIFRoZSBkZXNpcmVkIHNjYWxpbmcgKGRlZmF1bHQgMS4wKVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0U2NhbGUoX3NjYWxlOiBudW1iZXIgPSAxLjApOiB2b2lkIHtcclxuICAgICAgdGhpcy5zZXQodGhpcy5nZXQoKSk7XHJcbiAgICAgIHRoaXMuc2NhbGUgPSBfc2NhbGU7XHJcbiAgICAgIC8vVE9ETzogY2F0Y2ggc2NhbGU9MFxyXG4gICAgICB0aGlzLnJlc2NhbGVBbGxUaW1lcnMoKTtcclxuICAgICAgdGhpcy5nZXRFbGFwc2VkU2luY2VQcmV2aW91c0NhbGwoKTtcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVC5USU1FX1NDQUxFRCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIHRoZSBjdXJyZW50IHNjYWxpbmcgb2YgdGhpcyB0aW1lXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRTY2FsZSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5zY2FsZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyB0aGUgb2Zmc2V0IG9mIHRoaXMgdGltZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0T2Zmc2V0KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLm9mZnNldDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyB0aGUgc2NhbGVkIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHBhc3NlZCBzaW5jZSB0aGUgbGFzdCBjYWxsIHRvIHRoaXMgbWV0aG9kXHJcbiAgICAgKiBBdXRvbWF0aWNhbGx5IHJlc2V0IGF0IGV2ZXJ5IGNhbGwgdG8gc2V0KC4uLikgYW5kIHNldFNjYWxlKC4uLilcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEVsYXBzZWRTaW5jZVByZXZpb3VzQ2FsbCgpOiBudW1iZXIge1xyXG4gICAgICBsZXQgY3VycmVudDogbnVtYmVyID0gdGhpcy5nZXQoKTtcclxuICAgICAgbGV0IGVsYXBzZWQ6IG51bWJlciA9IGN1cnJlbnQgLSB0aGlzLmxhc3RDYWxsVG9FbGFwc2VkO1xyXG4gICAgICB0aGlzLmxhc3RDYWxsVG9FbGFwc2VkID0gY3VycmVudDtcclxuICAgICAgcmV0dXJuIGVsYXBzZWQ7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcblxyXG4gICAgLy8jcmVnaW9uIFRpbWVyc1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgUHJvbWlzZTx2b2lkPiB0byBiZSByZXNvbHZlZCBhZnRlciB0aGUgdGltZSBnaXZlbi4gVG8gYmUgdXNlZCB3aXRoIGFzeW5jL2F3YWl0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBkZWxheShfbGFwc2U6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoX3Jlc29sdmUgPT4gdGhpcy5zZXRUaW1lcihfbGFwc2UsIDEsICgpID0+IF9yZXNvbHZlKCkpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPOiBleGFtaW5lIGlmIHdlYi13b3JrZXJzIHdvdWxkIGVuaGFuY2UgcGVyZm9ybWFuY2UgaGVyZSFcclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgYW5kIGRlbGV0ZXMgYWxsIFtbVGltZXJdXXMgYXR0YWNoZWQuIFNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIHRoaXMgVGltZS1vYmplY3QgbGVhdmVzIHNjb3BlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjbGVhckFsbFRpbWVycygpOiB2b2lkIHtcclxuICAgICAgZm9yIChsZXQgaWQgaW4gdGhpcy50aW1lcnMpIHtcclxuICAgICAgICB0aGlzLmRlbGV0ZVRpbWVyKE51bWJlcihpZCkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGVzIFtbVGltZXJdXSBmb3VuZCB1c2luZyB0aGUgaW50ZXJuYWwgaWQgb2YgdGhlIGNvbm5lY3RlZCBpbnRlcnZhbC1vYmplY3RcclxuICAgICAqIEBwYXJhbSBfaWQgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBkZWxldGVUaW1lckJ5SXRzSW50ZXJuYWxJZChfaWQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICBmb3IgKGxldCBpZCBpbiB0aGlzLnRpbWVycykge1xyXG4gICAgICAgIGxldCB0aW1lcjogVGltZXIgPSB0aGlzLnRpbWVyc1tpZF07XHJcbiAgICAgICAgaWYgKHRpbWVyLmlkID09IF9pZCkge1xyXG4gICAgICAgICAgdGltZXIuY2xlYXIoKTtcclxuICAgICAgICAgIGRlbGV0ZSB0aGlzLnRpbWVyc1tpZF07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnN0YWxscyBhIHRpbWVyIGF0IHRoaXMgdGltZSBvYmplY3RcclxuICAgICAqIEBwYXJhbSBfbGFwc2UgVGhlIG9iamVjdC10aW1lIHRvIGVsYXBzZSBiZXR3ZWVuIHRoZSBjYWxscyB0byBfY2FsbGJhY2tcclxuICAgICAqIEBwYXJhbSBfY291bnQgVGhlIG51bWJlciBvZiBjYWxscyBkZXNpcmVkLCAwID0gSW5maW5pdGVcclxuICAgICAqIEBwYXJhbSBfaGFuZGxlciBUaGUgZnVuY3Rpb24gdG8gY2FsbCBlYWNoIHRoZSBnaXZlbiBsYXBzZSBoYXMgZWxhcHNlZFxyXG4gICAgICogQHBhcmFtIF9hcmd1bWVudHMgQWRkaXRpb25hbCBwYXJhbWV0ZXJzIHRvIHBhc3MgdG8gY2FsbGJhY2sgZnVuY3Rpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFRpbWVyKF9sYXBzZTogbnVtYmVyLCBfY291bnQ6IG51bWJlciwgX2hhbmRsZXI6IFRpbWVySGFuZGxlciwgLi4uX2FyZ3VtZW50czogT2JqZWN0W10pOiBudW1iZXIge1xyXG4gICAgICBsZXQgdGltZXI6IFRpbWVyID0gbmV3IFRpbWVyKHRoaXMsIF9sYXBzZSwgX2NvdW50LCBfaGFuZGxlciwgX2FyZ3VtZW50cyk7XHJcbiAgICAgIHRoaXMudGltZXJzWysrdGhpcy5pZFRpbWVyTmV4dF0gPSB0aW1lcjtcclxuICAgICAgcmV0dXJuIHRoaXMuaWRUaW1lck5leHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGVzIHRoZSB0aW1lciB3aXRoIHRoZSBpZCBnaXZlbiBieSB0aGlzIHRpbWUgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBkZWxldGVUaW1lcihfaWQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICB0aGlzLnRpbWVyc1tfaWRdLmNsZWFyKCk7XHJcbiAgICAgIGRlbGV0ZSB0aGlzLnRpbWVyc1tfaWRdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIGxpc3Qgb2YgdGltZXJzIGN1cnJlbnRseSBpbnN0YWxsZWQgb24gdGhpcyB0aW1lIG9iamVjdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0VGltZXJzKCk6IFRpbWVycyB7XHJcbiAgICAgIGxldCByZXN1bHQ6IFRpbWVycyA9IHt9O1xyXG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihyZXN1bHQsIHRoaXMudGltZXJzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGVyZSBhcmUgW1tUaW1lcnNdXSBpbnN0YWxsZWQgdG8gdGhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaGFzVGltZXJzKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gKE9iamVjdC5rZXlzKHRoaXMudGltZXJzKS5sZW5ndGggPiAwKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlY3JlYXRlcyBbW1RpbWVyXV1zIHdoZW4gc2NhbGluZyBjaGFuZ2VzXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcmVzY2FsZUFsbFRpbWVycygpOiB2b2lkIHtcclxuICAgICAgZm9yIChsZXQgaWQgaW4gdGhpcy50aW1lcnMpIHtcclxuICAgICAgICBsZXQgdGltZXI6IFRpbWVyID0gdGhpcy50aW1lcnNbaWRdO1xyXG4gICAgICAgIHRpbWVyLmNsZWFyKCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLnNjYWxlKVxyXG4gICAgICAgICAgLy8gVGltZSBoYXMgc3RvcHBlZCwgbm8gbmVlZCB0byByZXBsYWNlIGNsZWFyZWQgdGltZXJzXHJcbiAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgdGhpcy50aW1lcnNbaWRdID0gdGltZXIuaW5zdGFsbENvcHkoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICAvLyNlbmRyZWdpb25cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIERlZmluZXMgdGhlIHNpZ25hdHVyZSBvZiBoYW5kbGVyIGZ1bmN0aW9ucyBmb3IgW1tUaW1lckV2ZW50xpJdXXMsIHZlcnkgc2ltaWxhciB0byB1c3VhbCBldmVudCBoYW5kbGVyXHJcbiAgICovXHJcbiAgZXhwb3J0IHR5cGUgVGltZXJIYW5kbGVyID0gKF9ldmVudDogRXZlbnRUaW1lcikgPT4gdm9pZDtcclxuXHJcbiAgLyoqXHJcbiAgICogQSBbW1RpbWVyXV0taW5zdGFuY2UgaW50ZXJuYWxseSB1c2VzIHdpbmRvdy5zZXRJbnRlcnZhbCB0byBjYWxsIGEgZ2l2ZW4gaGFuZGxlciB3aXRoIGEgZ2l2ZW4gZnJlcXVlbmN5IGEgZ2l2ZW4gbnVtYmVyIG9mIHRpbWVzLFxyXG4gICAqIHBhc3NpbmcgYW4gW1tUaW1lckV2ZW50xpJdXS1pbnN0YW5jZSB3aXRoIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYW5kIGdpdmVuIGFyZ3VtZW50cy4gXHJcbiAgICogVGhlIGZyZXF1ZW5jeSBzY2FsZXMgd2l0aCB0aGUgW1tUaW1lXV0taW5zdGFuY2UgdGhlIFtbVGltZXJdXS1pbnN0YW5jZSBpcyBhdHRhY2hlZCB0by5cclxuICAgKiBcclxuICAgKiBAYXV0aG9yIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFRpbWVyIHtcclxuICAgIHB1YmxpYyBhY3RpdmU6IGJvb2xlYW47XHJcbiAgICBwdWJsaWMgY291bnQ6IG51bWJlcjtcclxuICAgIHByaXZhdGUgaGFuZGxlcjogVGltZXJIYW5kbGVyO1xyXG4gICAgcHJpdmF0ZSB0aW1lOiBUaW1lO1xyXG4gICAgcHJpdmF0ZSBlbGFwc2U6IG51bWJlcjtcclxuICAgIHByaXZhdGUgZXZlbnQ6IEV2ZW50VGltZXI7XHJcbiAgICBwcml2YXRlIHRpbWVvdXRSZWFsOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIGlkV2luZG93OiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgW1tUaW1lcl1dIGluc3RhbmNlLlxyXG4gICAgICogQHBhcmFtIF90aW1lIFRoZSBbW1RpbWVdXSBpbnN0YW5jZSwgdGhlIHRpbWVyIGF0dGFjaGVzIHRvXHJcbiAgICAgKiBAcGFyYW0gX2VsYXBzZSBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgdG8gZWxhcHNlLCB0byB0aGUgbmV4dCBjYWxsIG9mIF9oYW5kbGVyLCBtZWFzdXJlZCBpbiBfdGltZVxyXG4gICAgICogQHBhcmFtIF9jb3VudCBUaGUgZGVzaXJlZCBudW1iZXIgb2YgY2FsbHMgdG8gX2hhbmRsZXIsIFRpbWVyIGRlaW5zdGFsbHMgYXV0b21hdGljYWxseSBhZnRlciBsYXN0IGNhbGwuIFBhc3NpbmcgMCBpbnZva2VzIGluZmluaXRlIGNhbGxzXHJcbiAgICAgKiBAcGFyYW0gX2hhbmRsZXIgVGhlIFtbVGltZXJIYW5kbGVyXV0gaW5zdGFuY2UgdG8gY2FsbFxyXG4gICAgICogQHBhcmFtIF9hcmd1bWVudHMgQWRkaXRpb25hbCBhcmd1bWVudHMgdG8gcGFzcyB0byBfaGFuZGxlclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihfdGltZTogVGltZSwgX2VsYXBzZTogbnVtYmVyLCBfY291bnQ6IG51bWJlciwgX2hhbmRsZXI6IFRpbWVySGFuZGxlciwgLi4uX2FyZ3VtZW50czogT2JqZWN0W10pIHtcclxuICAgICAgdGhpcy50aW1lID0gX3RpbWU7XHJcbiAgICAgIHRoaXMuZWxhcHNlID0gX2VsYXBzZTtcclxuICAgICAgdGhpcy5ldmVudCA9IG5ldyBFdmVudFRpbWVyKHRoaXMsIF9hcmd1bWVudHMpO1xyXG4gICAgICB0aGlzLmhhbmRsZXIgPSBfaGFuZGxlcjtcclxuICAgICAgdGhpcy5jb3VudCA9IF9jb3VudDtcclxuXHJcbiAgICAgIGxldCBzY2FsZTogbnVtYmVyID0gTWF0aC5hYnMoX3RpbWUuZ2V0U2NhbGUoKSk7XHJcblxyXG4gICAgICBpZiAoIXNjYWxlKSB7XHJcbiAgICAgICAgLy8gVGltZSBpcyBzdG9wcGVkLCB0aW1lciB3b24ndCBiZSBhY3RpdmVcclxuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy50aW1lb3V0UmVhbCA9IHRoaXMuZWxhcHNlIC8gc2NhbGU7XHJcblxyXG4gICAgICBsZXQgY2FsbGJhY2s6IEZ1bmN0aW9uID0gKCk6IHZvaWQgPT4ge1xyXG4gICAgICAgIHRoaXMuZXZlbnQubGFzdENhbGwgPSAodGhpcy5jb3VudCA9PSAxKTtcclxuICAgICAgICBfaGFuZGxlcih0aGlzLmV2ZW50KTtcclxuICAgICAgICB0aGlzLmV2ZW50LmZpcnN0Q2FsbCA9IGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5jb3VudCA+IDApXHJcbiAgICAgICAgICBpZiAoLS10aGlzLmNvdW50ID09IDApXHJcbiAgICAgICAgICAgIF90aW1lLmRlbGV0ZVRpbWVyQnlJdHNJbnRlcm5hbElkKHRoaXMuaWRXaW5kb3cpO1xyXG5cclxuICAgICAgfTtcclxuXHJcbiAgICAgIHRoaXMuaWRXaW5kb3cgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoY2FsbGJhY2ssIHRoaXMudGltZW91dFJlYWwsIF9hcmd1bWVudHMpO1xyXG4gICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB3aW5kb3ctaWQgb2YgdGhlIHRpbWVyLCB3aGljaCB3YXMgcmV0dXJuZWQgYnkgc2V0SW50ZXJ2YWxcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBpZCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5pZFdpbmRvdztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHRpbWUtaW50ZXJ2YWxsIGZvciBjYWxscyB0byB0aGUgaGFuZGxlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGxhcHNlKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmVsYXBzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEF0dGFjaGVzIGEgY29weSBvZiB0aGlzIGF0IGl0cyBjdXJyZW50IHN0YXRlIHRvIHRoZSBzYW1lIFtbVGltZV1dLWluc3RhbmNlLiBVc2VkIGludGVybmFsbHkgd2hlbiByZXNjYWxpbmcgW1tUaW1lXV1cclxuICAgICAqL1xyXG4gICAgcHVibGljIGluc3RhbGxDb3B5KCk6IFRpbWVyIHtcclxuICAgICAgcmV0dXJuIG5ldyBUaW1lcih0aGlzLnRpbWUsIHRoaXMuZWxhcHNlLCB0aGlzLmNvdW50LCB0aGlzLmhhbmRsZXIsIHRoaXMuZXZlbnQuYXJndW1lbnRzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyB0aGUgdGltZXIsIHJlbW92aW5nIGl0IGZyb20gdGhlIGludGVydmFsLXRpbWVycyBoYW5kbGVkIGJ5IHdpbmRvd1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY2xlYXIoKTogdm9pZCB7XHJcbiAgICAgIC8vIGlmICh0aGlzLnR5cGUgPT0gVElNRVJfVFlQRS5USU1FT1VUKSB7XHJcbiAgICAgIC8vICAgICBpZiAodGhpcy5hY3RpdmUpXHJcbiAgICAgIC8vICAgICAgICAgLy8gc2F2ZSByZW1haW5pbmcgdGltZSB0byB0aW1lb3V0IGFzIG5ldyB0aW1lb3V0IGZvciByZXN0YXJ0XHJcbiAgICAgIC8vICAgICAgICAgdGhpcy50aW1lb3V0ID0gdGhpcy50aW1lb3V0ICogKDEgLSAocGVyZm9ybWFuY2Uubm93KCkgLSB0aGlzLnN0YXJ0VGltZVJlYWwpIC8gdGhpcy50aW1lb3V0UmVhbCk7XHJcbiAgICAgIC8vICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuaWQpO1xyXG4gICAgICAvLyB9XHJcbiAgICAgIC8vIGVsc2VcclxuICAgICAgLy8gVE9ETzogcmV1c2luZyB0aW1lciBzdGFydHMgaW50ZXJ2YWwgYW5ldy4gU2hvdWxkIGJlIHJlbWFpbmluZyBpbnRlcnZhbCBhcyB0aW1lb3V0LCB0aGVuIHN0YXJ0aW5nIGludGVydmFsIGFuZXcgXHJcbiAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuaWRXaW5kb3cpO1xyXG4gICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gICAgZXhwb3J0IGludGVyZmFjZSBNYXBGaWxlbmFtZVRvQ29udGVudCB7XHJcbiAgICAgICAgW2ZpbGVuYW1lOiBzdHJpbmddOiBzdHJpbmc7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXMgZmlsZSB0cmFuc2ZlciBmcm9tIGEgRnVkZ2UtQnJvd3NlcmFwcCB0byB0aGUgbG9jYWwgZmlsZXN5c3RlbSB3aXRob3V0IGEgbG9jYWwgc2VydmVyLiAgXHJcbiAgICAgKiBTYXZlcyB0byB0aGUgZG93bmxvYWQtcGF0aCBnaXZlbiBieSB0aGUgYnJvd3NlciwgbG9hZHMgZnJvbSB0aGUgcGxheWVyJ3MgY2hvaWNlLlxyXG4gICAgICovXHJcbiAgICBleHBvcnQgY2xhc3MgRmlsZUlvQnJvd3NlckxvY2FsIGV4dGVuZHMgRXZlbnRUYXJnZXRTdGF0aWMge1xyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIHNlbGVjdG9yOiBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgIC8vIFRPRE86IHJlZmFjdG9yIHRvIGFzeW5jIGZ1bmN0aW9uIHRvIGJlIGhhbmRsZWQgdXNpbmcgcHJvbWlzZSwgaW5zdGVhZCBvZiB1c2luZyBldmVudCB0YXJnZXRcclxuICAgICAgICBwdWJsaWMgc3RhdGljIGxvYWQoKTogdm9pZCB7XHJcbiAgICAgICAgICAgIEZpbGVJb0Jyb3dzZXJMb2NhbC5zZWxlY3RvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcclxuICAgICAgICAgICAgRmlsZUlvQnJvd3NlckxvY2FsLnNlbGVjdG9yLnR5cGUgPSBcImZpbGVcIjtcclxuICAgICAgICAgICAgRmlsZUlvQnJvd3NlckxvY2FsLnNlbGVjdG9yLm11bHRpcGxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgRmlsZUlvQnJvd3NlckxvY2FsLnNlbGVjdG9yLmhpZGRlbiA9IHRydWU7XHJcbiAgICAgICAgICAgIEZpbGVJb0Jyb3dzZXJMb2NhbC5zZWxlY3Rvci5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIEZpbGVJb0Jyb3dzZXJMb2NhbC5oYW5kbGVGaWxlU2VsZWN0KTtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChGaWxlSW9Ccm93c2VyTG9jYWwuc2VsZWN0b3IpO1xyXG4gICAgICAgICAgICBGaWxlSW9Ccm93c2VyTG9jYWwuc2VsZWN0b3IuY2xpY2soKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRPRE86IHJlZmFjdG9yIHRvIGFzeW5jIGZ1bmN0aW9uIHRvIGJlIGhhbmRsZWQgdXNpbmcgcHJvbWlzZSwgaW5zdGVhZCBvZiB1c2luZyBldmVudCB0YXJnZXRcclxuICAgICAgICBwdWJsaWMgc3RhdGljIHNhdmUoX3RvU2F2ZTogTWFwRmlsZW5hbWVUb0NvbnRlbnQpOiB2b2lkIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgZmlsZW5hbWUgaW4gX3RvU2F2ZSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvbnRlbnQ6IHN0cmluZyA9IF90b1NhdmVbZmlsZW5hbWVdO1xyXG4gICAgICAgICAgICAgICAgbGV0IGJsb2I6IEJsb2IgPSBuZXcgQmxvYihbY29udGVudF0sIHsgdHlwZTogXCJ0ZXh0L3BsYWluXCIgfSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgdXJsOiBzdHJpbmcgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcclxuICAgICAgICAgICAgICAgIC8vKi8gdXNpbmcgYW5jaG9yIGVsZW1lbnQgZm9yIGRvd25sb2FkXHJcbiAgICAgICAgICAgICAgICBsZXQgZG93bmxvYWRlcjogSFRNTEFuY2hvckVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICBkb3dubG9hZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XHJcbiAgICAgICAgICAgICAgICBkb3dubG9hZGVyLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgdXJsKTtcclxuICAgICAgICAgICAgICAgIGRvd25sb2FkZXIuc2V0QXR0cmlidXRlKFwiZG93bmxvYWRcIiwgZmlsZW5hbWUpO1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkb3dubG9hZGVyKTtcclxuICAgICAgICAgICAgICAgIGRvd25sb2FkZXIuY2xpY2soKTtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZG93bmxvYWRlcik7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cuVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgZXZlbnQ6IEN1c3RvbUV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KEVWRU5ULkZJTEVfU0FWRUQsIHsgZGV0YWlsOiB7IG1hcEZpbGVuYW1lVG9Db250ZW50OiBfdG9TYXZlIH0gfSk7XHJcbiAgICAgICAgICAgIEZpbGVJb0Jyb3dzZXJMb2NhbC50YXJnZXRTdGF0aWMuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGFzeW5jIGhhbmRsZUZpbGVTZWxlY3QoX2V2ZW50OiBFdmVudCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgICAgICBEZWJ1Zy5mdWRnZShcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGhhbmRsZUZpbGVTZWxlY3RcIik7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoRmlsZUlvQnJvd3NlckxvY2FsLnNlbGVjdG9yKTtcclxuICAgICAgICAgICAgbGV0IGZpbGVMaXN0OiBGaWxlTGlzdCA9ICg8SFRNTElucHV0RWxlbWVudD5fZXZlbnQudGFyZ2V0KS5maWxlcztcclxuICAgICAgICAgICAgRGVidWcuZnVkZ2UoZmlsZUxpc3QsIGZpbGVMaXN0Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGlmIChmaWxlTGlzdC5sZW5ndGggPT0gMClcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGxldCBsb2FkZWQ6IE1hcEZpbGVuYW1lVG9Db250ZW50ID0ge307XHJcbiAgICAgICAgICAgIGF3YWl0IEZpbGVJb0Jyb3dzZXJMb2NhbC5sb2FkRmlsZXMoZmlsZUxpc3QsIGxvYWRlZCk7XHJcblxyXG4gICAgICAgICAgICBsZXQgZXZlbnQ6IEN1c3RvbUV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KEVWRU5ULkZJTEVfTE9BREVELCB7IGRldGFpbDogeyBtYXBGaWxlbmFtZVRvQ29udGVudDogbG9hZGVkIH0gfSk7XHJcbiAgICAgICAgICAgIEZpbGVJb0Jyb3dzZXJMb2NhbC50YXJnZXRTdGF0aWMuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGFzeW5jIGxvYWRGaWxlcyhfZmlsZUxpc3Q6IEZpbGVMaXN0LCBfbG9hZGVkOiBNYXBGaWxlbmFtZVRvQ29udGVudCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBmaWxlIG9mIF9maWxlTGlzdCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudDogc3RyaW5nID0gYXdhaXQgbmV3IFJlc3BvbnNlKGZpbGUpLnRleHQoKTtcclxuICAgICAgICAgICAgICAgIF9sb2FkZWRbZmlsZS5uYW1lXSA9IGNvbnRlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0gIl19