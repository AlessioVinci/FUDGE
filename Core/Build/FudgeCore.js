"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var FudgeCore;
(function (FudgeCore) {
    /**
     * Base class for the different DebugTargets, mainly for technical purpose of inheritance
     */
    class DebugTarget {
        static mergeArguments(_message, ..._args) {
            let out = _message.toString(); //JSON.stringify(_message);
            for (let arg of _args)
                if (arg instanceof Number)
                    out += ", " + arg.toPrecision(2).toString(); //JSON.stringify(arg, null, 2);
                else
                    out += ", " + arg.toString(); //JSON.stringify(arg, null, 2);
            return out;
        }
    }
    FudgeCore.DebugTarget = DebugTarget;
})(FudgeCore || (FudgeCore = {}));
// <reference path="DebugAlert.ts"/>
var FudgeCore;
// <reference path="DebugAlert.ts"/>
(function (FudgeCore) {
    /**
     * The filters corresponding to debug activities, more to come
     */
    let DEBUG_FILTER;
    (function (DEBUG_FILTER) {
        DEBUG_FILTER[DEBUG_FILTER["NONE"] = 0] = "NONE";
        DEBUG_FILTER[DEBUG_FILTER["INFO"] = 1] = "INFO";
        DEBUG_FILTER[DEBUG_FILTER["LOG"] = 2] = "LOG";
        DEBUG_FILTER[DEBUG_FILTER["WARN"] = 4] = "WARN";
        DEBUG_FILTER[DEBUG_FILTER["ERROR"] = 8] = "ERROR";
        DEBUG_FILTER[DEBUG_FILTER["FUDGE"] = 16] = "FUDGE";
        DEBUG_FILTER[DEBUG_FILTER["CLEAR"] = 256] = "CLEAR";
        DEBUG_FILTER[DEBUG_FILTER["GROUP"] = 257] = "GROUP";
        DEBUG_FILTER[DEBUG_FILTER["GROUPCOLLAPSED"] = 258] = "GROUPCOLLAPSED";
        DEBUG_FILTER[DEBUG_FILTER["GROUPEND"] = 260] = "GROUPEND";
        DEBUG_FILTER[DEBUG_FILTER["MESSAGES"] = 31] = "MESSAGES";
        DEBUG_FILTER[DEBUG_FILTER["FORMAT"] = 263] = "FORMAT";
        DEBUG_FILTER[DEBUG_FILTER["ALL"] = 287] = "ALL";
    })(DEBUG_FILTER = FudgeCore.DEBUG_FILTER || (FudgeCore.DEBUG_FILTER = {}));
    FudgeCore.DEBUG_SYMBOL = {
        [DEBUG_FILTER.INFO]: "‚úì",
        [DEBUG_FILTER.LOG]: "‚úé",
        [DEBUG_FILTER.WARN]: "‚ö†",
        [DEBUG_FILTER.ERROR]: "‚ùå",
        [DEBUG_FILTER.FUDGE]: "üé≤"
    };
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
(function (FudgeCore) {
    /**
     * Routing to the standard-console
     */
    class DebugConsole extends FudgeCore.DebugTarget {
        /**
         * Displays critical information about failures, which is emphasized e.g. by color
         */
        static fudge(_message, ..._args) {
            console.debug("üé≤", _message, ..._args);
            // let trace: string[] = new Error("Test").stack.split("\n");
            // console.log(trace[4]);
            // console.trace("Test");
        }
    }
    DebugConsole.delegates = {
        [FudgeCore.DEBUG_FILTER.INFO]: console.info,
        [FudgeCore.DEBUG_FILTER.LOG]: console.log,
        [FudgeCore.DEBUG_FILTER.WARN]: console.warn,
        [FudgeCore.DEBUG_FILTER.ERROR]: console.error,
        [FudgeCore.DEBUG_FILTER.FUDGE]: DebugConsole.fudge,
        [FudgeCore.DEBUG_FILTER.CLEAR]: console.clear,
        [FudgeCore.DEBUG_FILTER.GROUP]: console.group,
        [FudgeCore.DEBUG_FILTER.GROUPCOLLAPSED]: console.groupCollapsed,
        [FudgeCore.DEBUG_FILTER.GROUPEND]: console.groupEnd
    };
    FudgeCore.DebugConsole = DebugConsole;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
/// <reference path="DebugInterfaces.ts"/>
/// <reference path="DebugConsole.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
/// <reference path="DebugInterfaces.ts"/>
/// <reference path="DebugConsole.ts"/>
(function (FudgeCore) {
    /**
     * The Debug-Class offers functions known from the console-object and additions,
     * routing the information to various [[DebugTargets]] that can be easily defined by the developers and registerd by users
     * Override functions in subclasses of [[DebugTarget]] and register them as their delegates
     */
    class Debug {
        // TODO: create filter DEBUG_FILTER.FUDGE solely for messages from FUDGE
        /**
         * De- / Activate a filter for the given DebugTarget.
         */
        static setFilter(_target, _filter) {
            for (let filter in Debug.delegates)
                Debug.delegates[filter].delete(_target);
            for (let filter in FudgeCore.DEBUG_FILTER) {
                let parsed = parseInt(filter);
                if (isNaN(parsed))
                    break;
                if ([FudgeCore.DEBUG_FILTER.MESSAGES, FudgeCore.DEBUG_FILTER.FORMAT, FudgeCore.DEBUG_FILTER.ALL].indexOf(parsed) != -1)
                    // dont delegate combos... 
                    continue;
                if (_filter & parsed)
                    Debug.delegates[parsed].set(_target, _target.delegates[parsed]);
            }
        }
        /**
         * Info(...) displays additional information with low priority
         */
        static info(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.INFO, _message, _args);
        }
        /**
         * Displays information with medium priority
         */
        static log(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.LOG, _message, _args);
        }
        /**
         * Displays information about non-conformities in usage, which is emphasized e.g. by color
         */
        static warn(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.WARN, _message, _args);
        }
        /**
         * Displays critical information about failures, which is emphasized e.g. by color
         */
        static error(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.ERROR, _message, _args);
        }
        /**
         * Displays messages from FUDGE
         */
        static fudge(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.FUDGE, _message, _args);
        }
        /**
         * Clears the output and removes previous messages if possible
         */
        static clear() {
            Debug.delegate(FudgeCore.DEBUG_FILTER.CLEAR, null, null);
        }
        /**
         * Opens a new group for messages
         */
        static group(_name) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.GROUP, _name, null);
        }
        /**
         * Opens a new group for messages that is collapsed at first
         */
        static groupCollapsed(_name) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.GROUPCOLLAPSED, _name, null);
        }
        /**
         * Closes the youngest group
         */
        static groupEnd() {
            Debug.delegate(FudgeCore.DEBUG_FILTER.GROUPEND, null, null);
        }
        /**
         * Lookup all delegates registered to the filter and call them using the given arguments
         */
        static delegate(_filter, _message, _args) {
            let delegates = Debug.delegates[_filter];
            for (let delegate of delegates.values())
                if (delegate)
                    if (_args && _args.length > 0)
                        delegate(_message, ..._args);
                    else
                        delegate(_message);
        }
        /**
         * setup routing to standard console
         */
        static setupConsole() {
            let result = {};
            let filters = [
                FudgeCore.DEBUG_FILTER.INFO, FudgeCore.DEBUG_FILTER.LOG, FudgeCore.DEBUG_FILTER.WARN, FudgeCore.DEBUG_FILTER.ERROR, FudgeCore.DEBUG_FILTER.FUDGE,
                FudgeCore.DEBUG_FILTER.CLEAR, FudgeCore.DEBUG_FILTER.GROUP, FudgeCore.DEBUG_FILTER.GROUPCOLLAPSED, FudgeCore.DEBUG_FILTER.GROUPEND
            ];
            for (let filter of filters)
                result[filter] = new Map([[FudgeCore.DebugConsole, FudgeCore.DebugConsole.delegates[filter]]]);
            return result;
        }
    }
    /**
     * For each set filter, this associative array keeps references to the registered delegate functions of the chosen [[DebugTargets]]
     */
    Debug.delegates = Debug.setupConsole();
    FudgeCore.Debug = Debug;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class EventTarget∆í extends EventTarget {
        addEventListener(_type, _handler, _options) {
            super.addEventListener(_type, _handler, _options);
        }
        removeEventListener(_type, _handler, _options) {
            super.removeEventListener(_type, _handler, _options);
        }
        dispatchEvent(_event) {
            return super.dispatchEvent(_event);
        }
    }
    FudgeCore.EventTarget∆í = EventTarget∆í;
    /**
     * Base class for EventTarget singletons, which are fixed entities in the structure of Fudge, such as the core loop
     */
    class EventTargetStatic extends EventTarget∆í {
        constructor() {
            super();
        }
        static addEventListener(_type, _handler) {
            EventTargetStatic.targetStatic.addEventListener(_type, _handler);
        }
        static removeEventListener(_type, _handler) {
            EventTargetStatic.targetStatic.removeEventListener(_type, _handler);
        }
        static dispatchEvent(_event) {
            EventTargetStatic.targetStatic.dispatchEvent(_event);
            return true;
        }
    }
    EventTargetStatic.targetStatic = new EventTargetStatic();
    FudgeCore.EventTargetStatic = EventTargetStatic;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="../Event/Event.ts"/>
var FudgeCore;
// / <reference path="../Event/Event.ts"/>
(function (FudgeCore) {
    // export interface MutatorForComponent extends Mutator { readonly forUserComponent: null; }
    /**
     * Collect applicable attributes of the instance and copies of their values in a Mutator-object
     */
    function getMutatorOfArbitrary(_object) {
        let mutator = {};
        let attributes = Reflect.ownKeys(Reflect.getPrototypeOf(_object));
        for (let attribute of attributes) {
            let value = Reflect.get(_object, attribute);
            if (value instanceof Function)
                continue;
            // if (value instanceof Object && !(value instanceof Mutable))
            //   continue;
            mutator[attribute.toString()] = value;
        }
        return mutator;
    }
    FudgeCore.getMutatorOfArbitrary = getMutatorOfArbitrary;
    /**
     * Base class for all types being mutable using [[Mutator]]-objects, thus providing and using interfaces created at runtime.
     * Mutables provide a [[Mutator]] that is build by collecting all object-properties that are either of a primitive type or again Mutable.
     * Subclasses can either reduce the standard [[Mutator]] built by this base class by deleting properties or implement an individual getMutator-method.
     * The provided properties of the [[Mutator]] must match public properties or getters/setters of the object.
     * Otherwise, they will be ignored if not handled by an override of the mutate-method in the subclass and throw errors in an automatically generated user-interface for the object.
     */
    class Mutable extends FudgeCore.EventTarget∆í {
        /**
         * Retrieves the type of this mutable subclass as the name of the runtime class
         * @returns The type of the mutable
         */
        get type() {
            return this.constructor.name;
        }
        /**
         * Collect applicable attributes of the instance and copies of their values in a Mutator-object
         */
        getMutator() {
            let mutator = {};
            // collect primitive and mutable attributes
            for (let attribute in this) {
                let value = this[attribute];
                if (value instanceof Function)
                    continue;
                if (value instanceof Object && !(value instanceof Mutable) && !(value.hasOwnProperty("idResource")))
                    continue;
                mutator[attribute] = this[attribute];
            }
            // mutator can be reduced but not extended!
            Object.preventExtensions(mutator);
            // delete unwanted attributes
            this.reduceMutator(mutator);
            // replace references to mutable objects with references to copies
            for (let attribute in mutator) {
                let value = mutator[attribute];
                if (value instanceof Mutable)
                    mutator[attribute] = value.getMutator();
            }
            return mutator;
        }
        /**
         * Collect the attributes of the instance and their values applicable for animation.
         * Basic functionality is identical to [[getMutator]], returned mutator should then be reduced by the subclassed instance
         */
        getMutatorForAnimation() {
            return this.getMutator();
        }
        /**
         * Collect the attributes of the instance and their values applicable for the user interface.
         * Basic functionality is identical to [[getMutator]], returned mutator should then be reduced by the subclassed instance
         */
        getMutatorForUserInterface() {
            return this.getMutator();
        }
        /**
         * Collect the attributes of the instance and their values applicable for indiviualization by the component.
         * Basic functionality is identical to [[getMutator]], returned mutator should then be reduced by the subclassed instance
         */
        // public getMutatorForComponent(): MutatorForComponent {
        //     return <MutatorForComponent>this.getMutator();
        // }
        /**
         * Returns an associative array with the same attributes as the given mutator, but with the corresponding types as string-values
         * Does not recurse into objects!
         * @param _mutator
         */
        getMutatorAttributeTypes(_mutator) {
            let types = {};
            for (let attribute in _mutator) {
                let type = null;
                let value = _mutator[attribute];
                if (_mutator[attribute] != undefined)
                    if (typeof (value) == "object")
                        type = this[attribute].constructor.name;
                    else if (typeof (value) == "function")
                        type = value["name"];
                    else
                        type = _mutator[attribute].constructor.name;
                types[attribute] = type;
            }
            return types;
        }
        /**
         * Updates the values of the given mutator according to the current state of the instance
         * @param _mutator
         */
        updateMutator(_mutator) {
            for (let attribute in _mutator) {
                let value = _mutator[attribute];
                if (value instanceof Mutable)
                    value = value.getMutator();
                else
                    _mutator[attribute] = this[attribute];
            }
        }
        /**
         * Updates the attribute values of the instance according to the state of the mutator. Must be protected...!
         * @param _mutator
         */
        mutate(_mutator) {
            // TODO: don't assign unknown properties
            for (let attribute in _mutator) {
                let value = _mutator[attribute];
                let mutant = this[attribute];
                if (mutant instanceof Mutable)
                    mutant.mutate(value);
                else
                    this[attribute] = value;
            }
            this.dispatchEvent(new Event("mutate" /* MUTATE */));
        }
    }
    FudgeCore.Mutable = Mutable;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Handles the external serialization and deserialization of [[Serializable]] objects. The internal process is handled by the objects themselves.
     * A [[Serialization]] object can be created from a [[Serializable]] object and a JSON-String may be created from that.
     * Vice versa, a JSON-String can be parsed to a [[Serialization]] which can be deserialized to a [[Serializable]] object.
     * ```plaintext
     *  [Serializable] ‚Üí (serialize) ‚Üí [Serialization] ‚Üí (stringify)
     *                                                        ‚Üì
     *                                                    [String]
     *                                                        ‚Üì
     *  [Serializable] ‚Üê (deserialize) ‚Üê [Serialization] ‚Üê (parse)
     * ```
     * While the internal serialize/deserialize methods of the objects care of the selection of information needed to recreate the object and its structure,
     * the [[Serializer]] keeps track of the namespaces and classes in order to recreate [[Serializable]] objects. The general structure of a [[Serialization]] is as follows
     * ```plaintext
     * {
     *      namespaceName.className: {
     *          propertyName: propertyValue,
     *          ...,
     *          propertyNameOfReference: SerializationOfTheReferencedObject,
     *          ...,
     *          constructorNameOfSuperclass: SerializationOfSuperClass
     *      }
     * }
     * ```
     * Since the instance of the superclass is created automatically when an object is created,
     * the SerializationOfSuperClass omits the the namespaceName.className key and consists only of its value.
     * The constructorNameOfSuperclass is given instead as a property name in the serialization of the subclass.
     */
    class Serializer {
        /**
         * Registers a namespace to the [[Serializer]], to enable automatic instantiation of classes defined within
         * @param _namespace
         */
        static registerNamespace(_namespace) {
            for (let name in Serializer.namespaces)
                if (Serializer.namespaces[name] == _namespace)
                    return;
            let name = Serializer.findNamespaceIn(_namespace, window);
            if (!name)
                for (let parentName in Serializer.namespaces) {
                    name = Serializer.findNamespaceIn(_namespace, Serializer.namespaces[parentName]);
                    if (name) {
                        name = parentName + "." + name;
                        break;
                    }
                }
            if (!name)
                throw new Error("Namespace not found. Maybe parent namespace hasn't been registered before?");
            Serializer.namespaces[name] = _namespace;
        }
        /**
         * Returns a javascript object representing the serializable FUDGE-object given,
         * including attached components, children, superclass-objects all information needed for reconstruction
         * @param _object An object to serialize, implementing the [[Serializable]] interface
         */
        static serialize(_object) {
            let serialization = {};
            // TODO: save the namespace with the constructors name
            // serialization[_object.constructor.name] = _object.serialize();
            let path = this.getFullPath(_object);
            if (!path)
                throw new Error(`Namespace of serializable object of type ${_object.constructor.name} not found. Maybe the namespace hasn't been registered or the class not exported?`);
            serialization[path] = _object.serialize();
            return serialization;
            // return _object.serialize();
        }
        /**
         * Returns a FUDGE-object reconstructed from the information in the [[Serialization]] given,
         * including attached components, children, superclass-objects
         * @param _serialization
         */
        static deserialize(_serialization) {
            let reconstruct;
            try {
                // loop constructed solely to access type-property. Only one expected!
                for (let path in _serialization) {
                    // reconstruct = new (<General>Fudge)[typeName];
                    reconstruct = Serializer.reconstruct(path);
                    reconstruct = reconstruct.deserialize(_serialization[path]);
                    return reconstruct;
                }
            }
            catch (_error) {
                throw new Error("Deserialization failed: " + _error);
            }
            return null;
        }
        //TODO: implement prettifier to make JSON-Stringification of serializations more readable, e.g. placing x, y and z in one line
        static prettify(_json) { return _json; }
        /**
         * Returns a formatted, human readable JSON-String, representing the given [[Serializaion]] that may have been created by [[Serializer]].serialize
         * @param _serialization
         */
        static stringify(_serialization) {
            // adjustments to serialization can be made here before stringification, if desired
            let json = JSON.stringify(_serialization, null, 2);
            let pretty = Serializer.prettify(json);
            return pretty;
        }
        /**
         * Returns a [[Serialization]] created from the given JSON-String. Result may be passed to [[Serializer]].deserialize
         * @param _json
         */
        static parse(_json) {
            return JSON.parse(_json);
        }
        /**
         * Creates an object of the class defined with the full path including the namespaceName(s) and the className seperated by dots(.)
         * @param _path
         */
        static reconstruct(_path) {
            let typeName = _path.substr(_path.lastIndexOf(".") + 1);
            let namespace = Serializer.getNamespace(_path);
            if (!namespace)
                throw new Error(`Namespace of serializable object of type ${typeName} not found. Maybe the namespace hasn't been registered?`);
            let reconstruction = new namespace[typeName];
            return reconstruction;
        }
        /**
         * Returns the full path to the class of the object, if found in the registered namespaces
         * @param _object
         */
        static getFullPath(_object) {
            let typeName = _object.constructor.name;
            // Debug.log("Searching namespace of: " + typeName);
            for (let namespaceName in Serializer.namespaces) {
                let found = Serializer.namespaces[namespaceName][typeName];
                if (found && _object instanceof found)
                    return namespaceName + "." + typeName;
            }
            return null;
        }
        /**
         * Returns the namespace-object defined within the full path, if registered
         * @param _path
         */
        static getNamespace(_path) {
            let namespaceName = _path.substr(0, _path.lastIndexOf("."));
            return Serializer.namespaces[namespaceName];
        }
        /**
         * Finds the namespace-object in properties of the parent-object (e.g. window), if present
         * @param _namespace
         * @param _parent
         */
        static findNamespaceIn(_namespace, _parent) {
            for (let prop in _parent)
                if (_parent[prop] == _namespace)
                    return prop;
            return null;
        }
    }
    /** In order for the Serializer to create class instances, it needs access to the appropriate namespaces */
    Serializer.namespaces = { "∆í": FudgeCore };
    FudgeCore.Serializer = Serializer;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class RenderInjector {
        static inject(_constructor, _injector) {
            let injection = Reflect.get(_injector, "inject" + _constructor.name);
            if (!injection) {
                console.error("No injection decorator defined for " + _constructor.name);
            }
            Object.defineProperty(_constructor.prototype, "useRenderData", {
                value: injection
            });
        }
    }
    FudgeCore.RenderInjector = RenderInjector;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class RenderInjectorShader {
        static decorate(_constructor) {
            Object.defineProperty(_constructor, "useProgram", {
                value: RenderInjectorShader.useProgram
            });
            Object.defineProperty(_constructor, "deleteProgram", {
                value: RenderInjectorShader.deleteProgram
            });
            Object.defineProperty(_constructor, "createProgram", {
                value: RenderInjectorShader.createProgram
            });
        }
        static useProgram() {
            if (!this.program)
                this.createProgram();
            let crc3 = FudgeCore.RenderOperator.getRenderingContext();
            crc3.useProgram(this.program);
            crc3.enableVertexAttribArray(this.attributes["a_position"]);
        }
        static deleteProgram() {
            let crc3 = FudgeCore.RenderOperator.getRenderingContext();
            if (this.program) {
                crc3.deleteProgram(this.program);
                delete this.attributes;
                delete this.uniforms;
            }
        }
        static createProgram() {
            FudgeCore.Debug.fudge("Create shader program", this.name);
            let crc3 = FudgeCore.RenderOperator.getRenderingContext();
            let program = crc3.createProgram();
            try {
                crc3.attachShader(program, FudgeCore.RenderOperator.assert(compileShader(this.getVertexShaderSource(), WebGL2RenderingContext.VERTEX_SHADER)));
                crc3.attachShader(program, FudgeCore.RenderOperator.assert(compileShader(this.getFragmentShaderSource(), WebGL2RenderingContext.FRAGMENT_SHADER)));
                crc3.linkProgram(program);
                let error = FudgeCore.RenderOperator.assert(crc3.getProgramInfoLog(program));
                if (error !== "") {
                    throw new Error("Error linking Shader: " + error);
                }
                this.program = program;
                this.attributes = detectAttributes();
                this.uniforms = detectUniforms();
            }
            catch (_error) {
                FudgeCore.Debug.error(_error);
                debugger;
            }
            function compileShader(_shaderCode, _shaderType) {
                let webGLShader = crc3.createShader(_shaderType);
                crc3.shaderSource(webGLShader, _shaderCode);
                crc3.compileShader(webGLShader);
                let error = FudgeCore.RenderOperator.assert(crc3.getShaderInfoLog(webGLShader));
                if (error !== "") {
                    throw new Error("Error compiling shader: " + error);
                }
                // Check for any compilation errors.
                if (!crc3.getShaderParameter(webGLShader, WebGL2RenderingContext.COMPILE_STATUS)) {
                    alert(crc3.getShaderInfoLog(webGLShader));
                    return null;
                }
                return webGLShader;
            }
            function detectAttributes() {
                let detectedAttributes = {};
                let attributeCount = crc3.getProgramParameter(program, WebGL2RenderingContext.ACTIVE_ATTRIBUTES);
                for (let i = 0; i < attributeCount; i++) {
                    let attributeInfo = FudgeCore.RenderOperator.assert(crc3.getActiveAttrib(program, i));
                    if (!attributeInfo) {
                        break;
                    }
                    detectedAttributes[attributeInfo.name] = crc3.getAttribLocation(program, attributeInfo.name);
                }
                return detectedAttributes;
            }
            function detectUniforms() {
                let detectedUniforms = {};
                let uniformCount = crc3.getProgramParameter(program, WebGL2RenderingContext.ACTIVE_UNIFORMS);
                for (let i = 0; i < uniformCount; i++) {
                    let info = FudgeCore.RenderOperator.assert(crc3.getActiveUniform(program, i));
                    if (!info) {
                        break;
                    }
                    detectedUniforms[info.name] = FudgeCore.RenderOperator.assert(crc3.getUniformLocation(program, info.name));
                }
                return detectedUniforms;
            }
        }
    }
    FudgeCore.RenderInjectorShader = RenderInjectorShader;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class RenderInjectorCoat extends FudgeCore.RenderInjector {
        static decorate(_constructor) {
            FudgeCore.RenderInjector.inject(_constructor, RenderInjectorCoat);
        }
        static injectCoatColored(_shader, _cmpMaterial) {
            let colorUniformLocation = _shader.uniforms["u_color"];
            let color = FudgeCore.Color.MULTIPLY(this.color, _cmpMaterial.clrPrimary);
            FudgeCore.RenderOperator.getRenderingContext().uniform4fv(colorUniformLocation, color.getArray());
        }
        static injectCoatTextured(_shader, _cmpMaterial) {
            let crc3 = FudgeCore.RenderOperator.getRenderingContext();
            if (this.renderData) {
                // buffers exist
                let colorUniformLocation = _shader.uniforms["u_color"];
                let color = FudgeCore.Color.MULTIPLY(this.color, _cmpMaterial.clrPrimary);
                FudgeCore.RenderOperator.getRenderingContext().uniform4fv(colorUniformLocation, color.getArray());
                crc3.activeTexture(WebGL2RenderingContext.TEXTURE0);
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, this.renderData["texture0"]);
                crc3.uniform1i(_shader.uniforms["u_texture"], 0);
                crc3.uniformMatrix3fv(_shader.uniforms["u_pivot"], false, this.pivot.get());
            }
            else {
                this.renderData = {};
                // TODO: check if all WebGL-Creations are asserted
                const texture = FudgeCore.RenderManager.assert(crc3.createTexture());
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, texture);
                try {
                    crc3.texImage2D(crc3.TEXTURE_2D, 0, crc3.RGBA, crc3.RGBA, crc3.UNSIGNED_BYTE, this.texture.image);
                    crc3.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.UNSIGNED_BYTE, this.texture.image);
                }
                catch (_error) {
                    FudgeCore.Debug.error(_error);
                }
                crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, WebGL2RenderingContext.NEAREST);
                crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.NEAREST);
                crc3.generateMipmap(crc3.TEXTURE_2D);
                this.renderData["texture0"] = texture;
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
                this.useRenderData(_shader, _cmpMaterial);
            }
        }
        static injectCoatMatCap(_shader, _cmpMaterial) {
            let crc3 = FudgeCore.RenderOperator.getRenderingContext();
            let colorUniformLocation = _shader.uniforms["u_tint_color"];
            let { r, g, b, a } = this.color;
            let tintColorArray = new Float32Array([r, g, b, a]);
            crc3.uniform4fv(colorUniformLocation, tintColorArray);
            let floatUniformLocation = _shader.uniforms["shade_smooth"];
            let shadeSmooth = this.shadeSmooth;
            crc3.uniform1i(floatUniformLocation, shadeSmooth);
            if (this.renderData) {
                // buffers exist
                crc3.activeTexture(WebGL2RenderingContext.TEXTURE0);
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, this.renderData["texture0"]);
                crc3.uniform1i(_shader.uniforms["u_texture"], 0);
            }
            else {
                this.renderData = {};
                // TODO: check if all WebGL-Creations are asserted
                const texture = FudgeCore.RenderManager.assert(crc3.createTexture());
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, texture);
                try {
                    crc3.texImage2D(crc3.TEXTURE_2D, 0, crc3.RGBA, crc3.RGBA, crc3.UNSIGNED_BYTE, this.texture.image);
                    crc3.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.UNSIGNED_BYTE, this.texture.image);
                }
                catch (_error) {
                    FudgeCore.Debug.error(_error);
                }
                crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, WebGL2RenderingContext.NEAREST);
                crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.NEAREST);
                crc3.generateMipmap(crc3.TEXTURE_2D);
                this.renderData["texture0"] = texture;
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
                this.useRenderData(_shader, _cmpMaterial);
            }
        }
    }
    FudgeCore.RenderInjectorCoat = RenderInjectorCoat;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class RenderInjectorMesh {
        static decorate(_constructor) {
            Object.defineProperty(_constructor.prototype, "useRenderBuffers", {
                value: RenderInjectorMesh.useRenderBuffers
            });
            Object.defineProperty(_constructor.prototype, "createRenderBuffers", {
                value: RenderInjectorMesh.createRenderBuffers
            });
            Object.defineProperty(_constructor.prototype, "deleteRenderBuffers", {
                value: RenderInjectorMesh.deleteRenderBuffers
            });
        }
        static createRenderBuffers() {
            // console.log("createRenderBuffers", this);
            // return;
            let crc3 = FudgeCore.RenderOperator.getRenderingContext();
            let vertices = FudgeCore.RenderOperator.assert(crc3.createBuffer());
            crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, vertices);
            crc3.bufferData(WebGL2RenderingContext.ARRAY_BUFFER, this.vertices, WebGL2RenderingContext.STATIC_DRAW);
            let indices = FudgeCore.RenderOperator.assert(crc3.createBuffer());
            crc3.bindBuffer(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, indices);
            crc3.bufferData(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, this.indices, WebGL2RenderingContext.STATIC_DRAW);
            let textureUVs = crc3.createBuffer();
            crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, textureUVs);
            crc3.bufferData(WebGL2RenderingContext.ARRAY_BUFFER, this.textureUVs, WebGL2RenderingContext.STATIC_DRAW);
            let normalsFace = FudgeCore.RenderOperator.assert(crc3.createBuffer());
            crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, normalsFace);
            crc3.bufferData(WebGL2RenderingContext.ARRAY_BUFFER, this.normalsFace, WebGL2RenderingContext.STATIC_DRAW);
            let renderBuffers = {
                vertices: vertices,
                indices: indices,
                nIndices: this.getIndexCount(),
                textureUVs: textureUVs,
                normalsFace: normalsFace
            };
            this.renderBuffers = renderBuffers;
        }
        static useRenderBuffers(_shader, _world, _projection, _id) {
            // console.log("useRenderBuffers", this);
            // return;
            let crc3 = FudgeCore.RenderOperator.getRenderingContext();
            let aPosition = _shader.attributes["a_position"];
            crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.renderBuffers.vertices);
            crc3.enableVertexAttribArray(aPosition);
            FudgeCore.RenderOperator.setAttributeStructure(aPosition, FudgeCore.Mesh.getBufferSpecification());
            crc3.bindBuffer(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, this.renderBuffers.indices);
            let uProjection = _shader.uniforms["u_projection"];
            crc3.uniformMatrix4fv(uProjection, false, _projection.get());
            // feed in face normals if shader accepts u_world. 
            let uWorld = _shader.uniforms["u_world"];
            if (uWorld) {
                crc3.uniformMatrix4fv(uWorld, false, _world.get());
            }
            let aNormal = _shader.attributes["a_normal"];
            if (aNormal) {
                crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.renderBuffers.normalsFace);
                crc3.enableVertexAttribArray(aNormal);
                FudgeCore.RenderOperator.setAttributeStructure(aNormal, FudgeCore.Mesh.getBufferSpecification());
            }
            // feed in texture coordinates if shader accepts a_textureUVs
            let aTextureUVs = _shader.attributes["a_textureUVs"];
            if (aTextureUVs) {
                crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.renderBuffers.textureUVs);
                crc3.enableVertexAttribArray(aTextureUVs); // enable the buffer
                crc3.vertexAttribPointer(aTextureUVs, 2, WebGL2RenderingContext.FLOAT, false, 0, 0);
            }
            // feed in an id of the node if shader accepts u_id. Used for picking
            let uId = _shader.uniforms["u_id"];
            if (uId)
                FudgeCore.RenderOperator.getRenderingContext().uniform1i(uId, _id);
        }
        static deleteRenderBuffers(_renderBuffers) {
            // console.log("deleteRenderBuffers", this);
            // return;
            let crc3 = FudgeCore.RenderOperator.getRenderingContext();
            if (_renderBuffers) {
                crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, null);
                crc3.deleteBuffer(_renderBuffers.vertices);
                crc3.deleteBuffer(_renderBuffers.textureUVs);
                crc3.bindBuffer(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, null);
                crc3.deleteBuffer(_renderBuffers.indices);
            }
        }
    }
    FudgeCore.RenderInjectorMesh = RenderInjectorMesh;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Keeps a depot of objects that have been marked for reuse, sorted by type.
     * Using [[Recycler]] reduces load on the carbage collector and thus supports smooth performance
     */
    class Recycler {
        /**
         * Fetches an object of the requested type from the depot, or returns a new one, if the depot was empty
         * @param _T The class identifier of the desired object
         */
        static get(_T) {
            let key = _T.name;
            let instances = Recycler.depot[key];
            if (instances && instances.length > 0)
                return instances.pop();
            else
                return new _T();
        }
        /**
         * Returns a reference to an object of the requested type in the depot, but does not remove it there.
         * If no object of the requested type was in the depot, one is created, stored and borrowed.
         * For short term usage of objects in a local scope, when there will be no other call to Recycler.get or .borrow!
         * @param _T The class identifier of the desired object
         */
        static borrow(_T) {
            let t;
            let key = _T.name;
            let instances = Recycler.depot[key];
            if (!instances || instances.length == 0) {
                t = new _T();
                Recycler.store(t);
                return t;
            }
            return instances[0];
        }
        /**
         * Stores the object in the depot for later recycling. Users are responsible for throwing in objects that are about to loose scope and are not referenced by any other
         * @param _instance
         */
        static store(_instance) {
            let key = _instance.constructor.name;
            //Debug.log(key);
            let instances = Recycler.depot[key] || [];
            instances.push(_instance);
            Recycler.depot[key] = instances;
            // Debug.log(`ObjectManager.depot[${key}]: ${ObjectManager.depot[key].length}`);
            //Debug.log(this.depot);
        }
        /**
         * Emptys the depot of a given type, leaving the objects for the garbage collector. May result in a short stall when many objects were in
         * @param _T
         */
        static dump(_T) {
            let key = _T.name;
            Recycler.depot[key] = [];
        }
        /**
         * Emptys all depots, leaving all objects to the garbage collector. May result in a short stall when many objects were in
         */
        static dumpAll() {
            Recycler.depot = {};
        }
    }
    Recycler.depot = {};
    FudgeCore.Recycler = Recycler;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Stores and manipulates a twodimensional vector comprised of the components x and y
     * ```plaintext
     *            +y
     *             |__ +x
     * ```
     * @authors Lukas Scheuerle, Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Vector2 extends FudgeCore.Mutable {
        constructor(_x = 0, _y = 0) {
            super();
            this.data = new Float32Array([_x, _y]);
        }
        get x() {
            return this.data[0];
        }
        get y() {
            return this.data[1];
        }
        set x(_x) {
            this.data[0] = _x;
        }
        set y(_y) {
            this.data[1] = _y;
        }
        /**
         * Returns the length of the vector
         */
        get magnitude() {
            return Math.hypot(...this.data);
        }
        /**
         * Returns the square of the magnitude of the vector without calculating a square root. Faster for simple proximity evaluation.
         */
        get magnitudeSquared() {
            return Vector2.DOT(this, this);
        }
        /**
         * A shorthand for writing `new Vector2(0, 0)`.
         * @returns A new vector with the values (0, 0)
         */
        static ZERO() {
            let vector = new Vector2();
            return vector;
        }
        /**
         * A shorthand for writing `new Vector2(_scale, _scale)`.
         * @param _scale the scale of the vector. Default: 1
         */
        static ONE(_scale = 1) {
            let vector = new Vector2(_scale, _scale);
            return vector;
        }
        /**
         * A shorthand for writing `new Vector2(0, y)`.
         * @param _scale The number to write in the y coordinate. Default: 1
         * @returns A new vector with the values (0, _scale)
         */
        static Y(_scale = 1) {
            let vector = new Vector2(0, _scale);
            return vector;
        }
        /**
         * A shorthand for writing `new Vector2(x, 0)`.
         * @param _scale The number to write in the x coordinate. Default: 1
         * @returns A new vector with the values (_scale, 0)
         */
        static X(_scale = 1) {
            let vector = new Vector2(_scale, 0);
            return vector;
        }
        static TRANSFORMATION(_vector, _matrix, _includeTranslation = true) {
            let result = new Vector2();
            let m = _matrix.get();
            let [x, y] = _vector.get();
            result.x = m[0] * x + m[3] * y;
            result.y = m[1] * x + m[4] * y;
            if (_includeTranslation) {
                result.add(_matrix.translation);
            }
            return result;
        }
        /**
         * Normalizes a given vector to the given length without editing the original vector.
         * @param _vector the vector to normalize
         * @param _length the length of the resulting vector. defaults to 1
         * @returns a new vector representing the normalised vector scaled by the given length
         */
        static NORMALIZATION(_vector, _length = 1) {
            let vector = Vector2.ZERO();
            try {
                let [x, y] = _vector.data;
                let factor = _length / Math.hypot(x, y);
                vector.data = new Float32Array([_vector.x * factor, _vector.y * factor]);
            }
            catch (_error) {
                FudgeCore.Debug.fudge(_error);
            }
            return vector;
        }
        /**
         * Scales a given vector by a given scale without changing the original vector
         * @param _vector The vector to scale.
         * @param _scale The scale to scale with.
         * @returns A new vector representing the scaled version of the given vector
         */
        static SCALE(_vector, _scale) {
            let vector = new Vector2(_vector.x * _scale, _vector.y * _scale);
            return vector;
        }
        /**
         * Sums up multiple vectors.
         * @param _vectors A series of vectors to sum up
         * @returns A new vector representing the sum of the given vectors
         */
        static SUM(..._vectors) {
            let result = new Vector2();
            for (let vector of _vectors)
                result.data = new Float32Array([result.x + vector.x, result.y + vector.y]);
            return result;
        }
        /**
         * Subtracts two vectors.
         * @param _a The vector to subtract from.
         * @param _b The vector to subtract.
         * @returns A new vector representing the difference of the given vectors
         */
        static DIFFERENCE(_a, _b) {
            let vector = new Vector2;
            vector.data = new Float32Array([_a.x - _b.x, _a.y - _b.y]);
            return vector;
        }
        /**
         * Computes the dotproduct of 2 vectors.
         * @param _a The vector to multiply.
         * @param _b The vector to multiply by.
         * @returns A new vector representing the dotproduct of the given vectors
         */
        static DOT(_a, _b) {
            let scalarProduct = _a.x * _b.x + _a.y * _b.y;
            return scalarProduct;
        }
        /**
         * Calculates the cross product of two Vectors. Due to them being only 2 Dimensional, the result is a single number,
         * which implicitly is on the Z axis. It is also the signed magnitude of the result.
         * @param _a Vector to compute the cross product on
         * @param _b Vector to compute the cross product with
         * @returns A number representing result of the cross product.
         */
        static CROSSPRODUCT(_a, _b) {
            let crossProduct = _a.x * _b.y - _a.y * _b.x;
            return crossProduct;
        }
        /**
         * Calculates the orthogonal vector to the given vector. Rotates counterclockwise by default.
         * ```plaintext
         * ‚Üë => ‚Üê => ‚Üì => ‚Üí => ‚Üë
         * ```
         * @param _vector Vector to get the orthogonal equivalent of
         * @param _clockwise Should the rotation be clockwise instead of the default counterclockwise? default: false
         * @returns A Vector that is orthogonal to and has the same magnitude as the given Vector.
         */
        static ORTHOGONAL(_vector, _clockwise = false) {
            if (_clockwise)
                return new Vector2(_vector.y, -_vector.x);
            else
                return new Vector2(-_vector.y, _vector.x);
        }
        /**
         * Returns true if the coordinates of this and the given vector are to be considered identical within the given tolerance
         * TODO: examine, if tolerance as criterium for the difference is appropriate with very large coordinate values or if _tolerance should be multiplied by coordinate value
         */
        equals(_compare, _tolerance = Number.EPSILON) {
            if (Math.abs(this.x - _compare.x) > _tolerance)
                return false;
            if (Math.abs(this.y - _compare.y) > _tolerance)
                return false;
            return true;
        }
        /**
         * Adds the given vector to the executing vector, changing the executor.
         * @param _addend The vector to add.
         */
        add(_addend) {
            this.data = new Vector2(_addend.x + this.x, _addend.y + this.y).data;
        }
        /**
         * Subtracts the given vector from the executing vector, changing the executor.
         * @param _subtrahend The vector to subtract.
         */
        subtract(_subtrahend) {
            this.data = new Vector2(this.x - _subtrahend.x, this.y - _subtrahend.y).data;
        }
        /**
         * Scales the Vector by the _scale.
         * @param _scale The scale to multiply the vector with.
         */
        scale(_scale) {
            this.data = new Vector2(_scale * this.x, _scale * this.y).data;
        }
        /**
         * Normalizes the vector.
         * @param _length A modificator to get a different length of normalized vector.
         */
        normalize(_length = 1) {
            this.data = Vector2.NORMALIZATION(this, _length).data;
        }
        /**
         * Sets the Vector to the given parameters. Ommitted parameters default to 0.
         * @param _x new x to set
         * @param _y new y to set
         */
        set(_x = 0, _y = 0) {
            this.data = new Float32Array([_x, _y]);
        }
        /**
         * @returns An array of the data of the vector
         */
        get() {
            return new Float32Array(this.data);
        }
        /**
         * @returns A deep copy of the vector.
         */
        get copy() {
            return new Vector2(this.x, this.y);
        }
        transform(_matrix, _includeTranslation = true) {
            this.data = Vector2.TRANSFORMATION(this, _matrix, _includeTranslation).data;
        }
        /**
         * Adds a z-component to the vector and returns a new Vector3
         */
        toVector3() {
            return new FudgeCore.Vector3(this.x, this.y, 0);
        }
        toString() {
            let result = `(${this.x.toPrecision(5)}, ${this.y.toPrecision(5)})`;
            return result;
        }
        getMutator() {
            let mutator = {
                x: this.data[0], y: this.data[1]
            };
            return mutator;
        }
        reduceMutator(_mutator) { }
    }
    FudgeCore.Vector2 = Vector2;
})(FudgeCore || (FudgeCore = {}));
///<reference path="../Engine/Recycler.ts"/>
///<reference path="Vector2.ts"/>
var FudgeCore;
///<reference path="../Engine/Recycler.ts"/>
///<reference path="Vector2.ts"/>
(function (FudgeCore) {
    /**
     * Defines the origin of a rectangle
     */
    let ORIGIN2D;
    (function (ORIGIN2D) {
        ORIGIN2D[ORIGIN2D["TOPLEFT"] = 0] = "TOPLEFT";
        ORIGIN2D[ORIGIN2D["TOPCENTER"] = 1] = "TOPCENTER";
        ORIGIN2D[ORIGIN2D["TOPRIGHT"] = 2] = "TOPRIGHT";
        ORIGIN2D[ORIGIN2D["CENTERLEFT"] = 16] = "CENTERLEFT";
        ORIGIN2D[ORIGIN2D["CENTER"] = 17] = "CENTER";
        ORIGIN2D[ORIGIN2D["CENTERRIGHT"] = 18] = "CENTERRIGHT";
        ORIGIN2D[ORIGIN2D["BOTTOMLEFT"] = 32] = "BOTTOMLEFT";
        ORIGIN2D[ORIGIN2D["BOTTOMCENTER"] = 33] = "BOTTOMCENTER";
        ORIGIN2D[ORIGIN2D["BOTTOMRIGHT"] = 34] = "BOTTOMRIGHT";
    })(ORIGIN2D = FudgeCore.ORIGIN2D || (FudgeCore.ORIGIN2D = {}));
    /**
     * Defines a rectangle with position and size and add comfortable methods to it
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Rectangle extends FudgeCore.Mutable {
        constructor(_x = 0, _y = 0, _width = 1, _height = 1, _origin = ORIGIN2D.TOPLEFT) {
            super();
            this.position = FudgeCore.Recycler.get(FudgeCore.Vector2);
            this.size = FudgeCore.Recycler.get(FudgeCore.Vector2);
            this.setPositionAndSize(_x, _y, _width, _height, _origin);
        }
        /**
         * Returns a new rectangle created with the given parameters
         */
        static GET(_x = 0, _y = 0, _width = 1, _height = 1, _origin = ORIGIN2D.TOPLEFT) {
            let rect = FudgeCore.Recycler.get(Rectangle);
            rect.setPositionAndSize(_x, _y, _width, _height);
            return rect;
        }
        /**
         * Sets the position and size of the rectangle according to the given parameters
         */
        setPositionAndSize(_x = 0, _y = 0, _width = 1, _height = 1, _origin = ORIGIN2D.TOPLEFT) {
            this.size.set(_width, _height);
            switch (_origin & 0x03) {
                case 0x00:
                    this.position.x = _x;
                    break;
                case 0x01:
                    this.position.x = _x - _width / 2;
                    break;
                case 0x02:
                    this.position.x = _x - _width;
                    break;
            }
            switch (_origin & 0x30) {
                case 0x00:
                    this.position.y = _y;
                    break;
                case 0x10:
                    this.position.y = _y - _height / 2;
                    break;
                case 0x20:
                    this.position.y = _y - _height;
                    break;
            }
        }
        pointToRect(_point, _target) {
            let result = _point.copy;
            result.subtract(this.position);
            result.x *= _target.width / this.width;
            result.y *= _target.height / this.height;
            result.add(_target.position);
            return result;
        }
        get x() {
            return this.position.x;
        }
        get y() {
            return this.position.y;
        }
        get width() {
            return this.size.x;
        }
        get height() {
            return this.size.y;
        }
        /**
         * Return the leftmost expansion, respecting also negative values of width
         */
        get left() {
            if (this.size.x > 0)
                return this.position.x;
            return (this.position.x + this.size.x);
        }
        /**
         * Return the topmost expansion, respecting also negative values of height
         */
        get top() {
            if (this.size.y > 0)
                return this.position.y;
            return (this.position.y + this.size.y);
        }
        /**
         * Return the rightmost expansion, respecting also negative values of width
         */
        get right() {
            if (this.size.x > 0)
                return (this.position.x + this.size.x);
            return this.position.x;
        }
        /**
         * Return the lowest expansion, respecting also negative values of height
         */
        get bottom() {
            if (this.size.y > 0)
                return (this.position.y + this.size.y);
            return this.position.y;
        }
        set x(_x) {
            this.position.x = _x;
        }
        set y(_y) {
            this.position.y = _y;
        }
        set width(_width) {
            this.position.x = _width;
        }
        set height(_height) {
            this.position.y = _height;
        }
        set left(_value) {
            this.size.x = this.right - _value;
            this.position.x = _value;
        }
        set top(_value) {
            this.size.y = this.bottom - _value;
            this.position.y = _value;
        }
        set right(_value) {
            this.size.x = this.position.x + _value;
        }
        set bottom(_value) {
            this.size.y = this.position.y + _value;
        }
        get copy() {
            return Rectangle.GET(this.x, this.y, this.width, this.height);
        }
        /**
         * Returns true if the given point is inside of this rectangle or on the border
         * @param _point
         */
        isInside(_point) {
            return (_point.x >= this.left && _point.x <= this.right && _point.y >= this.top && _point.y <= this.bottom);
        }
        collides(_rect) {
            if (this.left > _rect.right)
                return false;
            if (this.right < _rect.left)
                return false;
            if (this.top > _rect.bottom)
                return false;
            if (this.bottom < _rect.top)
                return false;
            return true;
        }
        toString() {
            let result = `∆í.Rectangle(position:${this.position.toString()}, size:${this.size.toString()}`;
            result += `, left:${this.left.toPrecision(5)}, top:${this.top.toPrecision(5)}, right:${this.right.toPrecision(5)}, bottom:${this.bottom.toPrecision(5)}`;
            return result;
        }
        reduceMutator(_mutator) { }
    }
    FudgeCore.Rectangle = Rectangle;
})(FudgeCore || (FudgeCore = {}));
///<reference path="RenderInjector.ts"/>
///<reference path="RenderInjectorShader.ts"/>
///<reference path="RenderInjectorCoat.ts"/>
///<reference path="RenderInjectorMesh.ts"/>
///<reference path="../Math/Rectangle.ts"/>
var FudgeCore;
///<reference path="RenderInjector.ts"/>
///<reference path="RenderInjectorShader.ts"/>
///<reference path="RenderInjectorCoat.ts"/>
///<reference path="RenderInjectorMesh.ts"/>
///<reference path="../Math/Rectangle.ts"/>
(function (FudgeCore) {
    let BLEND;
    (function (BLEND) {
        BLEND[BLEND["OPAQUE"] = 0] = "OPAQUE";
        BLEND[BLEND["TRANSPARENT"] = 1] = "TRANSPARENT";
        BLEND[BLEND["PARTICLE"] = 2] = "PARTICLE";
    })(BLEND = FudgeCore.BLEND || (FudgeCore.BLEND = {}));
    /**
     * Base class for RenderManager, handling the connection to the rendering system, in this case WebGL.
     * Methods and attributes of this class should not be called directly, only through [[RenderManager]]
     */
    class RenderOperator {
        /**
         * Wrapper function to utilize the bufferSpecification interface when passing data to the shader via a buffer.
         * @param _attributeLocation  The location of the attribute on the shader, to which they data will be passed.
         * @param _bufferSpecification  Interface passing datapullspecifications to the buffer.
         */
        static setAttributeStructure(_attributeLocation, _bufferSpecification) {
            RenderOperator.crc3.vertexAttribPointer(_attributeLocation, _bufferSpecification.size, _bufferSpecification.dataType, _bufferSpecification.normalize, _bufferSpecification.stride, _bufferSpecification.offset);
        }
        /**
        * Checks the first parameter and throws an exception with the WebGL-errorcode if the value is null
        * @param _value  value to check against null
        * @param _message  optional, additional message for the exception
        */
        static assert(_value, _message = "") {
            if (_value === null)
                throw new Error(`Assertion failed. ${_message}, WebGL-Error: ${RenderOperator.crc3 ? RenderOperator.crc3.getError() : ""}`);
            return _value;
        }
        /**
         * Initializes offscreen-canvas, renderingcontext and hardware viewport. Call once before creating any resources like meshes or shaders
         */
        static initialize(_antialias, _alpha) {
            FudgeCore.fudgeConfig = FudgeCore.fudgeConfig || {};
            let contextAttributes = {
                alpha: (_alpha != undefined) ? _alpha : FudgeCore.fudgeConfig.alpha || false,
                antialias: (_antialias != undefined) ? _antialias : FudgeCore.fudgeConfig.antialias || false,
                premultipliedAlpha: false
            };
            FudgeCore.Debug.fudge("Initialize RenderManager", contextAttributes);
            let canvas = document.createElement("canvas");
            let crc3;
            crc3 = RenderOperator.assert(canvas.getContext("webgl2", contextAttributes), "WebGL-context couldn't be created");
            RenderOperator.crc3 = crc3;
            // Enable backface- and zBuffer-culling.
            crc3.enable(WebGL2RenderingContext.CULL_FACE);
            crc3.enable(WebGL2RenderingContext.DEPTH_TEST);
            crc3.enable(WebGL2RenderingContext.BLEND);
            crc3.blendEquation(WebGL2RenderingContext.FUNC_ADD);
            RenderOperator.setBlendMode(BLEND.TRANSPARENT);
            // RenderOperator.crc3.pixelStorei(WebGL2RenderingContext.UNPACK_FLIP_Y_WEBGL, true);
            RenderOperator.rectViewport = RenderOperator.getCanvasRect();
            return crc3;
        }
        /**
         * Return a reference to the offscreen-canvas
         */
        static getCanvas() {
            return RenderOperator.crc3.canvas; // TODO: enable OffscreenCanvas
        }
        /**
         * Return a reference to the rendering context
         */
        static getRenderingContext() {
            return RenderOperator.crc3;
        }
        /**
         * Return a rectangle describing the size of the offscreen-canvas. x,y are 0 at all times.
         */
        static getCanvasRect() {
            let canvas = RenderOperator.crc3.canvas;
            return FudgeCore.Rectangle.GET(0, 0, canvas.width, canvas.height);
        }
        /**
         * Set the size of the offscreen-canvas.
         */
        static setCanvasSize(_width, _height) {
            RenderOperator.crc3.canvas.width = _width;
            RenderOperator.crc3.canvas.height = _height;
        }
        /**
         * Set the area on the offscreen-canvas to render the camera image to.
         * @param _rect
         */
        static setViewportRectangle(_rect) {
            Object.assign(RenderOperator.rectViewport, _rect);
            RenderOperator.crc3.viewport(_rect.x, _rect.y, _rect.width, _rect.height);
        }
        /**
         * Retrieve the area on the offscreen-canvas the camera image gets rendered to.
         */
        static getViewportRectangle() {
            return RenderOperator.rectViewport;
        }
        static setDepthTest(_test) {
            if (_test)
                RenderOperator.crc3.enable(WebGL2RenderingContext.DEPTH_TEST);
            else
                RenderOperator.crc3.disable(WebGL2RenderingContext.DEPTH_TEST);
        }
        static setBlendMode(_mode) {
            switch (_mode) {
                case BLEND.OPAQUE:
                    RenderOperator.crc3.blendFunc(WebGL2RenderingContext.ONE, WebGL2RenderingContext.ZERO);
                    break;
                case BLEND.TRANSPARENT:
                    RenderOperator.crc3.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
                    break;
                case BLEND.PARTICLE:
                    RenderOperator.crc3.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.DST_ALPHA);
                    break;
                default:
                    break;
            }
        }
        /**
         * Draw a mesh buffer using the given infos and the complete projection matrix
         */
        static draw(_mesh, cmpMaterial, _final, _projection) {
            let shader = cmpMaterial.material.getShader();
            let coat = cmpMaterial.material.getCoat();
            shader.useProgram();
            _mesh.useRenderBuffers(shader, _final, _projection);
            coat.useRenderData(shader, cmpMaterial);
            RenderOperator.crc3.drawElements(WebGL2RenderingContext.TRIANGLES, _mesh.renderBuffers.nIndices, WebGL2RenderingContext.UNSIGNED_SHORT, 0);
        }
    }
    RenderOperator.crc3 = RenderOperator.initialize();
    RenderOperator.rectViewport = RenderOperator.getCanvasRect();
    FudgeCore.RenderOperator = RenderOperator;
})(FudgeCore || (FudgeCore = {}));
/// <reference path="Debug/DebugTarget.ts"/>
/// <reference path="Debug/Debug.ts"/>
/// <reference path="Event/Event.ts"/>
/// <reference path="Transfer/Mutable.ts"/>  
/// <reference path="Transfer/Serializer.ts"/> 
/// <reference path="Render/RenderOperator.ts"/>
// / <reference path="../Transfer/Mutable.ts"/>
var FudgeCore;
// / <reference path="../Transfer/Mutable.ts"/>
(function (FudgeCore) {
    /**
     * Internally used to differentiate between the various generated structures and events.
     * @author Lukas Scheuerle, HFU, 2019
     */
    let ANIMATION_STRUCTURE_TYPE;
    (function (ANIMATION_STRUCTURE_TYPE) {
        /**Default: forward, continous */
        ANIMATION_STRUCTURE_TYPE[ANIMATION_STRUCTURE_TYPE["NORMAL"] = 0] = "NORMAL";
        /**backward, continous */
        ANIMATION_STRUCTURE_TYPE[ANIMATION_STRUCTURE_TYPE["REVERSE"] = 1] = "REVERSE";
        /**forward, rastered */
        ANIMATION_STRUCTURE_TYPE[ANIMATION_STRUCTURE_TYPE["RASTERED"] = 2] = "RASTERED";
        /**backward, rastered */
        ANIMATION_STRUCTURE_TYPE[ANIMATION_STRUCTURE_TYPE["RASTEREDREVERSE"] = 3] = "RASTEREDREVERSE";
    })(ANIMATION_STRUCTURE_TYPE || (ANIMATION_STRUCTURE_TYPE = {}));
    /**
     * Animation Class to hold all required Objects that are part of an Animation.
     * Also holds functions to play said Animation.
     * Can be added to a Node and played through [[ComponentAnimator]].
     * @author Lukas Scheuerle, HFU, 2019
     */
    class Animation extends FudgeCore.Mutable {
        constructor(_name, _animStructure = {}, _fps = 60) {
            super();
            this.totalTime = 0;
            this.labels = {};
            this.stepsPerSecond = 10;
            this.events = {};
            this.framesPerSecond = 60;
            // processed eventlist and animation strucutres for playback.
            this.eventsProcessed = new Map();
            this.animationStructuresProcessed = new Map();
            this.name = _name;
            this.animationStructure = _animStructure;
            this.animationStructuresProcessed.set(ANIMATION_STRUCTURE_TYPE.NORMAL, _animStructure);
            this.framesPerSecond = _fps;
            this.calculateTotalTime();
        }
        /**
         * Generates a new "Mutator" with the information to apply to the [[Node]] the [[ComponentAnimator]] is attached to with [[Node.applyAnimation()]].
         * @param _time The time at which the animation currently is at
         * @param _direction The direction in which the animation is supposed to be playing back. >0 == forward, 0 == stop, <0 == backwards
         * @param _playback The playbackmode the animation is supposed to be calculated with.
         * @returns a "Mutator" to apply.
         */
        getMutated(_time, _direction, _playback) {
            let m = {};
            if (_playback == FudgeCore.ANIMATION_PLAYBACK.TIMEBASED_CONTINOUS) {
                if (_direction >= 0) {
                    m = this.traverseStructureForMutator(this.getProcessedAnimationStructure(ANIMATION_STRUCTURE_TYPE.NORMAL), _time);
                }
                else {
                    m = this.traverseStructureForMutator(this.getProcessedAnimationStructure(ANIMATION_STRUCTURE_TYPE.REVERSE), _time);
                }
            }
            else {
                if (_direction >= 0) {
                    m = this.traverseStructureForMutator(this.getProcessedAnimationStructure(ANIMATION_STRUCTURE_TYPE.RASTERED), _time);
                }
                else {
                    m = this.traverseStructureForMutator(this.getProcessedAnimationStructure(ANIMATION_STRUCTURE_TYPE.RASTEREDREVERSE), _time);
                }
            }
            return m;
        }
        /**
         * Returns a list of the names of the events the [[ComponentAnimator]] needs to fire between _min and _max.
         * @param _min The minimum time (inclusive) to check between
         * @param _max The maximum time (exclusive) to check between
         * @param _playback The playback mode to check in. Has an effect on when the Events are fired.
         * @param _direction The direction the animation is supposed to run in. >0 == forward, 0 == stop, <0 == backwards
         * @returns a list of strings with the names of the custom events to fire.
         */
        getEventsToFire(_min, _max, _playback, _direction) {
            let eventList = [];
            let minSection = Math.floor(_min / this.totalTime);
            let maxSection = Math.floor(_max / this.totalTime);
            _min = _min % this.totalTime;
            _max = _max % this.totalTime;
            while (minSection <= maxSection) {
                let eventTriggers = this.getCorrectEventList(_direction, _playback);
                if (minSection == maxSection) {
                    eventList = eventList.concat(this.checkEventsBetween(eventTriggers, _min, _max));
                }
                else {
                    eventList = eventList.concat(this.checkEventsBetween(eventTriggers, _min, this.totalTime));
                    _min = 0;
                }
                minSection++;
            }
            return eventList;
        }
        /**
         * Adds an Event to the List of events.
         * @param _name The name of the event (needs to be unique per Animation).
         * @param _time The timestamp of the event (in milliseconds).
         */
        setEvent(_name, _time) {
            this.events[_name] = _time;
            this.eventsProcessed.clear();
        }
        /**
         * Removes the event with the given name from the list of events.
         * @param _name name of the event to remove.
         */
        removeEvent(_name) {
            delete this.events[_name];
            this.eventsProcessed.clear();
        }
        get getLabels() {
            //TODO: this actually needs testing
            let en = new Enumerator(this.labels);
            return en;
        }
        get fps() {
            return this.framesPerSecond;
        }
        set fps(_fps) {
            this.framesPerSecond = _fps;
            this.eventsProcessed.clear();
            this.animationStructuresProcessed.clear();
        }
        /**
         * (Re-)Calculate the total time of the Animation. Calculation-heavy, use only if actually needed.
         */
        calculateTotalTime() {
            this.totalTime = 0;
            this.traverseStructureForTime(this.animationStructure);
        }
        //#region transfer
        serialize() {
            let s = {
                idResource: this.idResource,
                name: this.name,
                labels: {},
                events: {},
                fps: this.framesPerSecond,
                sps: this.stepsPerSecond
            };
            for (let name in this.labels) {
                s.labels[name] = this.labels[name];
            }
            for (let name in this.events) {
                s.events[name] = this.events[name];
            }
            s.animationStructure = this.traverseStructureForSerialisation(this.animationStructure);
            return s;
        }
        deserialize(_serialization) {
            this.idResource = _serialization.idResource;
            this.name = _serialization.name;
            this.framesPerSecond = _serialization.fps;
            this.stepsPerSecond = _serialization.sps;
            this.labels = {};
            for (let name in _serialization.labels) {
                this.labels[name] = _serialization.labels[name];
            }
            this.events = {};
            for (let name in _serialization.events) {
                this.events[name] = _serialization.events[name];
            }
            this.eventsProcessed = new Map();
            this.animationStructure = this.traverseStructureForDeserialisation(_serialization.animationStructure);
            this.animationStructuresProcessed = new Map();
            this.calculateTotalTime();
            return this;
        }
        getMutator() {
            return this.serialize();
        }
        reduceMutator(_mutator) {
            delete _mutator.totalTime;
        }
        /**
         * Traverses an AnimationStructure and returns the Serialization of said Structure.
         * @param _structure The Animation Structure at the current level to transform into the Serialization.
         * @returns the filled Serialization.
         */
        traverseStructureForSerialisation(_structure) {
            let newSerialization = {};
            for (let n in _structure) {
                if (_structure[n] instanceof FudgeCore.AnimationSequence) {
                    newSerialization[n] = _structure[n].serialize();
                }
                else {
                    newSerialization[n] = this.traverseStructureForSerialisation(_structure[n]);
                }
            }
            return newSerialization;
        }
        /**
         * Traverses a Serialization to create a new AnimationStructure.
         * @param _serialization The serialization to transfer into an AnimationStructure
         * @returns the newly created AnimationStructure.
         */
        traverseStructureForDeserialisation(_serialization) {
            let newStructure = {};
            for (let n in _serialization) {
                if (_serialization[n].animationSequence) {
                    let animSeq = new FudgeCore.AnimationSequence();
                    newStructure[n] = animSeq.deserialize(_serialization[n]);
                }
                else {
                    newStructure[n] = this.traverseStructureForDeserialisation(_serialization[n]);
                }
            }
            return newStructure;
        }
        //#endregion
        /**
         * Finds the list of events to be used with these settings.
         * @param _direction The direction the animation is playing in.
         * @param _playback The playbackmode the animation is playing in.
         * @returns The correct AnimationEventTrigger Object to use
         */
        getCorrectEventList(_direction, _playback) {
            if (_playback != FudgeCore.ANIMATION_PLAYBACK.FRAMEBASED) {
                if (_direction >= 0) {
                    return this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.NORMAL);
                }
                else {
                    return this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.REVERSE);
                }
            }
            else {
                if (_direction >= 0) {
                    return this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.RASTERED);
                }
                else {
                    return this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.RASTEREDREVERSE);
                }
            }
        }
        /**
         * Traverses an AnimationStructure to turn it into the "Mutator" to return to the Component.
         * @param _structure The strcuture to traverse
         * @param _time the point in time to write the animation numbers into.
         * @returns The "Mutator" filled with the correct values at the given time.
         */
        traverseStructureForMutator(_structure, _time) {
            let newMutator = {};
            for (let n in _structure) {
                if (_structure[n] instanceof FudgeCore.AnimationSequence) {
                    newMutator[n] = _structure[n].evaluate(_time);
                }
                else {
                    newMutator[n] = this.traverseStructureForMutator(_structure[n], _time);
                }
            }
            return newMutator;
        }
        /**
         * Traverses the current AnimationStrcuture to find the totalTime of this animation.
         * @param _structure The structure to traverse
         */
        traverseStructureForTime(_structure) {
            for (let n in _structure) {
                if (_structure[n] instanceof FudgeCore.AnimationSequence) {
                    let sequence = _structure[n];
                    if (sequence.length > 0) {
                        let sequenceTime = sequence.getKey(sequence.length - 1).Time;
                        this.totalTime = sequenceTime > this.totalTime ? sequenceTime : this.totalTime;
                    }
                }
                else {
                    this.traverseStructureForTime(_structure[n]);
                }
            }
        }
        /**
         * Ensures the existance of the requested [[AnimationStrcuture]] and returns it.
         * @param _type the type of the structure to get
         * @returns the requested [[AnimationStructure]]
         */
        getProcessedAnimationStructure(_type) {
            if (!this.animationStructuresProcessed.has(_type)) {
                this.calculateTotalTime();
                let ae = {};
                switch (_type) {
                    case ANIMATION_STRUCTURE_TYPE.NORMAL:
                        ae = this.animationStructure;
                        break;
                    case ANIMATION_STRUCTURE_TYPE.REVERSE:
                        ae = this.traverseStructureForNewStructure(this.animationStructure, this.calculateReverseSequence.bind(this));
                        break;
                    case ANIMATION_STRUCTURE_TYPE.RASTERED:
                        ae = this.traverseStructureForNewStructure(this.animationStructure, this.calculateRasteredSequence.bind(this));
                        break;
                    case ANIMATION_STRUCTURE_TYPE.RASTEREDREVERSE:
                        ae = this.traverseStructureForNewStructure(this.getProcessedAnimationStructure(ANIMATION_STRUCTURE_TYPE.REVERSE), this.calculateRasteredSequence.bind(this));
                        break;
                    default:
                        return {};
                }
                this.animationStructuresProcessed.set(_type, ae);
            }
            return this.animationStructuresProcessed.get(_type);
        }
        /**
         * Ensures the existance of the requested [[AnimationEventTrigger]] and returns it.
         * @param _type The type of AnimationEventTrigger to get
         * @returns the requested [[AnimationEventTrigger]]
         */
        getProcessedEventTrigger(_type) {
            if (!this.eventsProcessed.has(_type)) {
                this.calculateTotalTime();
                let ev = {};
                switch (_type) {
                    case ANIMATION_STRUCTURE_TYPE.NORMAL:
                        ev = this.events;
                        break;
                    case ANIMATION_STRUCTURE_TYPE.REVERSE:
                        ev = this.calculateReverseEventTriggers(this.events);
                        break;
                    case ANIMATION_STRUCTURE_TYPE.RASTERED:
                        ev = this.calculateRasteredEventTriggers(this.events);
                        break;
                    case ANIMATION_STRUCTURE_TYPE.RASTEREDREVERSE:
                        ev = this.calculateRasteredEventTriggers(this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.REVERSE));
                        break;
                    default:
                        return {};
                }
                this.eventsProcessed.set(_type, ev);
            }
            return this.eventsProcessed.get(_type);
        }
        /**
         * Traverses an existing structure to apply a recalculation function to the AnimationStructure to store in a new Structure.
         * @param _oldStructure The old structure to traverse
         * @param _functionToUse The function to use to recalculated the structure.
         * @returns A new Animation Structure with the recalulated Animation Sequences.
         */
        traverseStructureForNewStructure(_oldStructure, _functionToUse) {
            let newStructure = {};
            for (let n in _oldStructure) {
                if (_oldStructure[n] instanceof FudgeCore.AnimationSequence) {
                    newStructure[n] = _functionToUse(_oldStructure[n]);
                }
                else {
                    newStructure[n] = this.traverseStructureForNewStructure(_oldStructure[n], _functionToUse);
                }
            }
            return newStructure;
        }
        /**
         * Creates a reversed Animation Sequence out of a given Sequence.
         * @param _sequence The sequence to calculate the new sequence out of
         * @returns The reversed Sequence
         */
        calculateReverseSequence(_sequence) {
            let seq = new FudgeCore.AnimationSequence();
            for (let i = 0; i < _sequence.length; i++) {
                let oldKey = _sequence.getKey(i);
                let key = new FudgeCore.AnimationKey(this.totalTime - oldKey.Time, oldKey.Value, oldKey.SlopeOut, oldKey.SlopeIn, oldKey.Constant);
                seq.addKey(key);
            }
            return seq;
        }
        /**
         * Creates a rastered [[AnimationSequence]] out of a given sequence.
         * @param _sequence The sequence to calculate the new sequence out of
         * @returns the rastered sequence.
         */
        calculateRasteredSequence(_sequence) {
            let seq = new FudgeCore.AnimationSequence();
            let frameTime = 1000 / this.framesPerSecond;
            for (let i = 0; i < this.totalTime; i += frameTime) {
                let key = new FudgeCore.AnimationKey(i, _sequence.evaluate(i), 0, 0, true);
                seq.addKey(key);
            }
            return seq;
        }
        /**
         * Creates a new reversed [[AnimationEventTrigger]] object based on the given one.
         * @param _events the event object to calculate the new one out of
         * @returns the reversed event object
         */
        calculateReverseEventTriggers(_events) {
            let ae = {};
            for (let name in _events) {
                ae[name] = this.totalTime - _events[name];
            }
            return ae;
        }
        /**
         * Creates a rastered [[AnimationEventTrigger]] object based on the given one.
         * @param _events the event object to calculate the new one out of
         * @returns the rastered event object
         */
        calculateRasteredEventTriggers(_events) {
            let ae = {};
            let frameTime = 1000 / this.framesPerSecond;
            for (let name in _events) {
                ae[name] = _events[name] - (_events[name] % frameTime);
            }
            return ae;
        }
        /**
         * Checks which events lay between two given times and returns the names of the ones that do.
         * @param _eventTriggers The event object to check the events inside of
         * @param _min the minimum of the range to check between (inclusive)
         * @param _max the maximum of the range to check between (exclusive)
         * @returns an array of the names of the events in the given range.
         */
        checkEventsBetween(_eventTriggers, _min, _max) {
            let eventsToTrigger = [];
            for (let name in _eventTriggers) {
                if (_min <= _eventTriggers[name] && _eventTriggers[name] < _max) {
                    eventsToTrigger.push(name);
                }
            }
            return eventsToTrigger;
        }
    }
    FudgeCore.Animation = Animation;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="../Transfer/Serializer.ts"/>
// / <reference path="../Transfer/Mutable.ts"/>
var FudgeCore;
// / <reference path="../Transfer/Serializer.ts"/>
// / <reference path="../Transfer/Mutable.ts"/>
(function (FudgeCore) {
    /**
     * Calculates the values between [[AnimationKey]]s.
     * Represented internally by a cubic function (`f(x) = ax¬≥ + bx¬≤ + cx + d`).
     * Only needs to be recalculated when the keys change, so at runtime it should only be calculated once.
     * @author Lukas Scheuerle, HFU, 2019
     */
    class AnimationFunction {
        constructor(_keyIn, _keyOut = null) {
            this.a = 0;
            this.b = 0;
            this.c = 0;
            this.d = 0;
            this.keyIn = _keyIn;
            this.keyOut = _keyOut;
            this.calculate();
        }
        /**
         * Calculates the value of the function at the given time.
         * @param _time the point in time at which to evaluate the function in milliseconds. Will be corrected for offset internally.
         * @returns the value at the given time
         */
        evaluate(_time) {
            _time -= this.keyIn.Time;
            let time2 = _time * _time;
            let time3 = time2 * _time;
            return this.a * time3 + this.b * time2 + this.c * _time + this.d;
        }
        set setKeyIn(_keyIn) {
            this.keyIn = _keyIn;
            this.calculate();
        }
        set setKeyOut(_keyOut) {
            this.keyOut = _keyOut;
            this.calculate();
        }
        /**
         * (Re-)Calculates the parameters of the cubic function.
         * See https://math.stackexchange.com/questions/3173469/calculate-cubic-equation-from-two-points-and-two-slopes-variably
         * and https://jirkadelloro.github.io/FUDGE/Documentation/Logs/190410_Notizen_LS
         */
        calculate() {
            if (!this.keyIn) {
                this.d = this.c = this.b = this.a = 0;
                return;
            }
            if (!this.keyOut || this.keyIn.Constant) {
                this.d = this.keyIn.Value;
                this.c = this.b = this.a = 0;
                return;
            }
            let x1 = this.keyOut.Time - this.keyIn.Time;
            this.d = this.keyIn.Value;
            this.c = this.keyIn.SlopeOut;
            this.a = (-x1 * (this.keyIn.SlopeOut + this.keyOut.SlopeIn) - 2 * this.keyIn.Value + 2 * this.keyOut.Value) / -Math.pow(x1, 3);
            this.b = (this.keyOut.SlopeIn - this.keyIn.SlopeOut - 3 * this.a * Math.pow(x1, 2)) / (2 * x1);
        }
    }
    FudgeCore.AnimationFunction = AnimationFunction;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="../Transfer/Serializer.ts"/>
// / <reference path="../Transfer/Mutable.ts"/>
var FudgeCore;
// / <reference path="../Transfer/Serializer.ts"/>
// / <reference path="../Transfer/Mutable.ts"/>
(function (FudgeCore) {
    /**
     * Holds information about set points in time, their accompanying values as well as their slopes.
     * Also holds a reference to the [[AnimationFunction]]s that come in and out of the sides. The [[AnimationFunction]]s are handled by the [[AnimationSequence]]s.
     * Saved inside an [[AnimationSequence]].
     * @author Lukas Scheuerle, HFU, 2019
     */
    class AnimationKey extends FudgeCore.Mutable {
        constructor(_time = 0, _value = 0, _slopeIn = 0, _slopeOut = 0, _constant = false) {
            super();
            this.constant = false;
            this.slopeIn = 0;
            this.slopeOut = 0;
            this.time = _time;
            this.value = _value;
            this.slopeIn = _slopeIn;
            this.slopeOut = _slopeOut;
            this.constant = _constant;
            this.broken = this.slopeIn != -this.slopeOut;
            this.functionOut = new FudgeCore.AnimationFunction(this, null);
        }
        get Time() {
            return this.time;
        }
        set Time(_time) {
            this.time = _time;
            this.functionIn.calculate();
            this.functionOut.calculate();
        }
        get Value() {
            return this.value;
        }
        set Value(_value) {
            this.value = _value;
            this.functionIn.calculate();
            this.functionOut.calculate();
        }
        get Constant() {
            return this.constant;
        }
        set Constant(_constant) {
            this.constant = _constant;
            this.functionIn.calculate();
            this.functionOut.calculate();
        }
        get SlopeIn() {
            return this.slopeIn;
        }
        set SlopeIn(_slope) {
            this.slopeIn = _slope;
            this.functionIn.calculate();
        }
        get SlopeOut() {
            return this.slopeOut;
        }
        set SlopeOut(_slope) {
            this.slopeOut = _slope;
            this.functionOut.calculate();
        }
        /**
         * Static comparation function to use in an array sort function to sort the keys by their time.
         * @param _a the animation key to check
         * @param _b the animation key to check against
         * @returns >0 if a>b, 0 if a=b, <0 if a<b
         */
        static compare(_a, _b) {
            return _a.time - _b.time;
        }
        //#region transfer
        serialize() {
            let s = {};
            s.time = this.time;
            s.value = this.value;
            s.slopeIn = this.slopeIn;
            s.slopeOut = this.slopeOut;
            s.constant = this.constant;
            return s;
        }
        deserialize(_serialization) {
            this.time = _serialization.time;
            this.value = _serialization.value;
            this.slopeIn = _serialization.slopeIn;
            this.slopeOut = _serialization.slopeOut;
            this.constant = _serialization.constant;
            this.broken = this.slopeIn != -this.slopeOut;
            return this;
        }
        getMutator() {
            return this.serialize();
        }
        reduceMutator(_mutator) {
            //
        }
    }
    FudgeCore.AnimationKey = AnimationKey;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A sequence of [[AnimationKey]]s that is mapped to an attribute of a [[Node]] or its [[Component]]s inside the [[Animation]].
     * Provides functions to modify said keys
     * @author Lukas Scheuerle, HFU, 2019
     */
    class AnimationSequence extends FudgeCore.Mutable {
        constructor() {
            super(...arguments);
            this.keys = [];
        }
        /**
         * Evaluates the sequence at the given point in time.
         * @param _time the point in time at which to evaluate the sequence in milliseconds.
         * @returns the value of the sequence at the given time. 0 if there are no keys.
         */
        evaluate(_time) {
            if (this.keys.length == 0)
                return 0; //TODO: shouldn't return 0 but something indicating no change, like null. probably needs to be changed in Node as well to ignore non-numeric values in the applyAnimation function
            if (this.keys.length == 1 || this.keys[0].Time >= _time)
                return this.keys[0].Value;
            for (let i = 0; i < this.keys.length - 1; i++) {
                if (this.keys[i].Time <= _time && this.keys[i + 1].Time > _time) {
                    return this.keys[i].functionOut.evaluate(_time);
                }
            }
            return this.keys[this.keys.length - 1].Value;
        }
        /**
         * Adds a new key to the sequence.
         * @param _key the key to add
         */
        addKey(_key) {
            this.keys.push(_key);
            this.keys.sort(FudgeCore.AnimationKey.compare);
            this.regenerateFunctions();
        }
        /**
         * Removes a given key from the sequence.
         * @param _key the key to remove
         */
        removeKey(_key) {
            for (let i = 0; i < this.keys.length; i++) {
                if (this.keys[i] == _key) {
                    this.keys.splice(i, 1);
                    this.regenerateFunctions();
                    return;
                }
            }
        }
        /**
         * Removes the Animation Key at the given index from the keys.
         * @param _index the zero-based index at which to remove the key
         * @returns the removed AnimationKey if successful, null otherwise.
         */
        removeKeyAtIndex(_index) {
            if (_index < 0 || _index >= this.keys.length) {
                return null;
            }
            let ak = this.keys[_index];
            this.keys.splice(_index, 1);
            this.regenerateFunctions();
            return ak;
        }
        /**
         * Gets a key from the sequence at the desired index.
         * @param _index the zero-based index at which to get the key
         * @returns the AnimationKey at the index if it exists, null otherwise.
         */
        getKey(_index) {
            if (_index < 0 || _index >= this.keys.length)
                return null;
            return this.keys[_index];
        }
        get length() {
            return this.keys.length;
        }
        //#region transfer
        serialize() {
            let s = {
                keys: [],
                animationSequence: true
            };
            for (let i = 0; i < this.keys.length; i++) {
                s.keys[i] = this.keys[i].serialize();
            }
            return s;
        }
        deserialize(_serialization) {
            for (let i = 0; i < _serialization.keys.length; i++) {
                // this.keys.push(<AnimationKey>Serializer.deserialize(_serialization.keys[i]));
                let k = new FudgeCore.AnimationKey();
                k.deserialize(_serialization.keys[i]);
                this.keys[i] = k;
            }
            this.regenerateFunctions();
            return this;
        }
        reduceMutator(_mutator) {
            //
        }
        //#endregion
        /**
         * Utility function that (re-)generates all functions in the sequence.
         */
        regenerateFunctions() {
            for (let i = 0; i < this.keys.length; i++) {
                let f = new FudgeCore.AnimationFunction(this.keys[i]);
                this.keys[i].functionOut = f;
                if (i == this.keys.length - 1) {
                    //TODO: check if this is even useful. Maybe update the runcondition to length - 1 instead. Might be redundant if functionIn is removed, see TODO in AnimationKey.
                    f.setKeyOut = this.keys[0];
                    this.keys[0].functionIn = f;
                    break;
                }
                f.setKeyOut = this.keys[i + 1];
                this.keys[i + 1].functionIn = f;
            }
        }
    }
    FudgeCore.AnimationSequence = AnimationSequence;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Extension of AudioBuffer with a load method that creates a buffer in the [[AudioManager]].default to be used with [[ComponentAudio]]
     * @authors Thomas Dorner, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2020
     */
    class Audio extends AudioBuffer {
        /**
         * Asynchronously loads the audio (mp3) from the given url
         */
        static async load(_url) {
            const response = await window.fetch(_url);
            const arrayBuffer = await response.arrayBuffer();
            return (await FudgeCore.AudioManager.default.decodeAudioData(arrayBuffer));
        }
    }
    FudgeCore.Audio = Audio;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Extends the standard AudioContext for integration with FUDGE-graphs.
     * Creates a default object at startup to be addressed as AudioManager default.
     * Other objects of this class may be create for special purposes.
     */
    class AudioManager extends AudioContext {
        constructor(contextOptions) {
            super(contextOptions);
            this.graph = null;
            this.cmpListener = null;
            /**
             * Determines FUDGE-graph to listen to. Each [[ComponentAudio]] in the graph will connect to this contexts master gain, all others disconnect.
             */
            this.listenTo = (_graph) => {
                if (this.graph)
                    this.graph.broadcastEvent(new Event("childRemoveFromAudioGraph" /* CHILD_REMOVE */));
                if (!_graph)
                    return;
                this.graph = _graph;
                this.graph.broadcastEvent(new Event("childAppendToAudioGraph" /* CHILD_APPEND */));
            };
            /**
             * Retrieve the FUDGE-graph currently listening to
             */
            this.getGraphListeningTo = () => {
                return this.graph;
            };
            /**
             * Set the [[ComponentAudioListener]] that serves the spatial location and orientation for this contexts listener
             */
            this.listen = (_cmpListener) => {
                this.cmpListener = _cmpListener;
            };
            /**
             * Updates the spatial settings of the AudioNodes effected in the current FUDGE-graph
             */
            this.update = () => {
                this.graph.broadcastEvent(new Event("updateAudioGraph" /* UPDATE */));
                if (this.cmpListener)
                    this.cmpListener.update(this.listener);
            };
            this.gain = this.createGain();
            this.gain.connect(this.destination);
        }
        /**
         * Set the master volume
         */
        set volume(_value) {
            this.gain.gain.value = _value;
        }
        /**
         * Get the master volume
         */
        get volume() {
            return this.gain.gain.value;
        }
    }
    /** The default context that may be used throughout the project without the need to create others */
    AudioManager.default = new AudioManager({ latencyHint: "interactive", sampleRate: 44100 });
    FudgeCore.AudioManager = AudioManager;
})(FudgeCore || (FudgeCore = {}));
// namespace FudgeCore {
//     /**
//      * Enumerator for all possible Oscillator Types
//      */
//     type OSCILLATOR_TYPE = "sine" | "square" | "sawtooth" | "triangle" | "custom";
//     /**
//      * Interface to create Custom Oscillator Types.
//      * Start-/Endpoint of a custum curve e.g. sine curve.
//      * Both parameters need to be inbetween -1 and 1.
//      * @param startpoint startpoint of a curve 
//      * @param endpoint Endpoint of a curve 
//      */
//     interface OscillatorWave {
//         startpoint: number;
//         endpoint: number;
//     }
//     /**
//      * Add an [[AudioFilter]] to an [[Audio]]
//      * @authors Thomas Dorner, HFU, 2019
//      */
//     export class AudioOscillator {
//         public audioOscillator: OscillatorNode; 
//         private frequency: number;
//         private oscillatorType: OSCILLATOR_TYPE;
//         private oscillatorWave: PeriodicWave;
//         private localGain: GainNode;
//         private localGainValue: number;
//         constructor(_audioSettings: AudioSettings, _oscillatorType?: OSCILLATOR_TYPE) {
//             this.audioOscillator = _audioSettings.getAudioContext().createOscillator();
//             this.localGain = _audioSettings.getAudioContext().createGain();
//             this.oscillatorType = _oscillatorType;
//             if (this.oscillatorType != "custom") {
//                 this.audioOscillator.type = this.oscillatorType;
//             }
//             else {
//                 if (!this.oscillatorWave) {
//                     this.audioOscillator.setPeriodicWave(this.oscillatorWave);
//                 }
//                 else {
//                     console.log("Create a Custom Periodic Wave first to use Custom Type");
//                 }
//             }
//         }
//         public setOscillatorType(_oscillatorType: OSCILLATOR_TYPE): void {
//             if (this.oscillatorType != "custom") {
//                 this.audioOscillator.type = this.oscillatorType;
//             }
//             else {
//                 if (!this.oscillatorWave) {
//                     this.audioOscillator.setPeriodicWave(this.oscillatorWave);
//                 }
//             }
//         }
//         public getOscillatorType(): OSCILLATOR_TYPE {
//             return this.oscillatorType;
//         }
//         public createPeriodicWave(_audioSettings: AudioSettings, _real: OscillatorWave, _imag: OscillatorWave): void {
//             let waveReal: Float32Array = new Float32Array(2);
//             waveReal[0] = _real.startpoint;
//             waveReal[1] = _real.endpoint;
//             let waveImag: Float32Array = new Float32Array(2);
//             waveImag[0] = _imag.startpoint;
//             waveImag[1] = _imag.endpoint;
//             this.oscillatorWave = _audioSettings.getAudioContext().createPeriodicWave(waveReal, waveImag);
//         }
//         public setLocalGain(_localGain: GainNode): void {
//             this.localGain = _localGain;
//         }
//         public getLocalGain(): GainNode {
//             return this.localGain;
//         }
//         public setLocalGainValue(_localGainValue: number): void {
//             this.localGainValue = _localGainValue;
//             this.localGain.gain.value = this.localGainValue;
//         }
//         public getLocalGainValue(): number {
//             return this.localGainValue;
//         }
//         public setFrequency(_audioSettings: AudioSettings, _frequency: number): void {
//             this.frequency = _frequency;
//             this.audioOscillator.frequency.setValueAtTime(this.frequency, _audioSettings.getAudioContext().currentTime);
//         }
//         public getFrequency(): number {
//             return this.frequency;
//         }
//         public createSnare(_audioSettings: AudioSettings): void {
//             this.setOscillatorType("triangle");
//             this.setFrequency(_audioSettings, 100);
//             this.setLocalGainValue(0);
//             this.localGain.gain.setValueAtTime(0, _audioSettings.getAudioContext().currentTime);
//             this.localGain.gain.exponentialRampToValueAtTime(0.01, _audioSettings.getAudioContext().currentTime + .1);
//             this.audioOscillator.connect(this.localGain);
//         }
//     }
// }
var FudgeCore;
(function (FudgeCore) {
    /**
     * Holds data to feed into a [[Shader]] to describe the surface of [[Mesh]].
     * [[Material]]s reference [[Coat]] and [[Shader]].
     * The method useRenderData will be injected by [[RenderInjector]] at runtime, extending the functionality of this class to deal with the renderer.
     */
    class Coat extends FudgeCore.Mutable {
        constructor() {
            super(...arguments);
            this.name = "Coat";
            //#endregion
        }
        mutate(_mutator) {
            super.mutate(_mutator);
        }
        useRenderData(_shader, _cmpMaterial) { }
        //#region Transfer
        serialize() {
            let serialization = this.getMutator();
            return serialization;
        }
        deserialize(_serialization) {
            this.mutate(_serialization);
            return this;
        }
        reduceMutator() { }
    }
    FudgeCore.Coat = Coat;
    /**
     * The simplest [[Coat]] providing just a color
     */
    let CoatColored = class CoatColored extends Coat {
        constructor(_color) {
            super();
            this.color = _color || new FudgeCore.Color(0.5, 0.5, 0.5, 1);
        }
    };
    CoatColored = __decorate([
        FudgeCore.RenderInjectorCoat.decorate
    ], CoatColored);
    FudgeCore.CoatColored = CoatColored;
    /**
     * A [[Coat]] to be used by the MatCap Shader providing a texture, a tint color (0.5 grey is neutral). Set shadeSmooth to 1 for smooth shading.
     */
    let CoatMatCap = class CoatMatCap extends Coat {
        constructor(_texture, _color, _shadeSmooth) {
            super();
            this.texture = null;
            this.color = new FudgeCore.Color(0.5, 0.5, 0.5, 1);
            this.texture = _texture || new FudgeCore.TextureImage();
            this.color = _color || new FudgeCore.Color(0.5, 0.5, 0.5, 1);
            this.shadeSmooth = _shadeSmooth || 0;
        }
    };
    CoatMatCap = __decorate([
        FudgeCore.RenderInjectorCoat.decorate
    ], CoatMatCap);
    FudgeCore.CoatMatCap = CoatMatCap;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A [[Coat]] providing a texture and additional data for texturing
     */
    let CoatTextured = class CoatTextured extends FudgeCore.Coat {
        constructor() {
            super(...arguments);
            // TODO: see if color should be generalized
            this.color = new FudgeCore.Color(1, 1, 1, 1);
            this.texture = null;
            this.pivot = FudgeCore.Matrix3x3.IDENTITY();
            // constructor(_texture: TextureImage, _color?: Color) {
            //   super();
            //   this.texture = _texture;
            //   this.color = _color || new Color(1, 1, 1, 1);
            // }
            // public getMutatorForComponent(): MutatorForComponent {
            //   let mutatorPivot: MutatorForComponent = <MutatorForComponent><unknown>this.pivot.getMutator();
            //   return mutatorPivot;
            // }
            // public mutate(_mutator: MutatorForComponent): void {
            //   this.pivot.mutate(_mutator);
            // }
        }
    };
    CoatTextured = __decorate([
        FudgeCore.RenderInjectorCoat.decorate
    ], CoatTextured);
    FudgeCore.CoatTextured = CoatTextured;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="../Transfer/Serializer.ts"/>
// / <reference path="../Transfer/Mutable.ts"/>
var FudgeCore;
// / <reference path="../Transfer/Serializer.ts"/>
// / <reference path="../Transfer/Mutable.ts"/>
(function (FudgeCore) {
    /**
     * Superclass for all [[Component]]s that can be attached to [[Node]]s.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2020 | Jascha Karag√∂l, HFU, 2019
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Component
     */
    class Component extends FudgeCore.Mutable {
        constructor() {
            super(...arguments);
            this.singleton = true;
            this.container = null;
            this.active = true;
            //#endregion
        }
        static registerSubclass(_subclass) { return Component.subclasses.push(_subclass) - 1; }
        activate(_on) {
            this.active = _on;
            this.dispatchEvent(new Event(_on ? "componentActivate" /* COMPONENT_ACTIVATE */ : "componentDeactivate" /* COMPONENT_DEACTIVATE */));
        }
        get isActive() {
            return this.active;
        }
        /**
         * Is true, when only one instance of the component class can be attached to a node
         */
        get isSingleton() {
            return this.singleton;
        }
        /**
         * Retrieves the node, this component is currently attached to
         * @returns The container node or null, if the component is not attached to
         */
        getContainer() {
            return this.container;
        }
        /**
         * Tries to add the component to the given node, removing it from the previous container if applicable
         * @param _container The node to attach this component to
         */
        setContainer(_container) {
            if (this.container == _container)
                return;
            let previousContainer = this.container;
            try {
                if (previousContainer)
                    previousContainer.removeComponent(this);
                this.container = _container;
                if (this.container)
                    this.container.addComponent(this);
            }
            catch (_error) {
                this.container = previousContainer;
            }
        }
        //#region Transfer
        serialize() {
            let serialization = {
                active: this.active
            };
            return serialization;
        }
        deserialize(_serialization) {
            this.active = _serialization.active;
            return this;
        }
        reduceMutator(_mutator) {
            delete _mutator.singleton;
            delete _mutator.container;
        }
    }
    /** refers back to this class from any subclass e.g. in order to find compatible other resources*/
    Component.baseClass = Component;
    /** list of all the subclasses derived from this class, if they registered properly*/
    Component.subclasses = [];
    FudgeCore.Component = Component;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="../Time/Loop.ts"/>
// / <reference path="../Animation/Animation.ts"/>
var FudgeCore;
// / <reference path="../Time/Loop.ts"/>
// / <reference path="../Animation/Animation.ts"/>
(function (FudgeCore) {
    /**
     * Holds different playmodes the animation uses to play back its animation.
     * @author Lukas Scheuerle, HFU, 2019
     */
    let ANIMATION_PLAYMODE;
    (function (ANIMATION_PLAYMODE) {
        /**Plays animation in a loop: it restarts once it hit the end.*/
        ANIMATION_PLAYMODE[ANIMATION_PLAYMODE["LOOP"] = 0] = "LOOP";
        /**Plays animation once and stops at the last key/frame*/
        ANIMATION_PLAYMODE[ANIMATION_PLAYMODE["PLAYONCE"] = 1] = "PLAYONCE";
        /**Plays animation once and stops on the first key/frame */
        ANIMATION_PLAYMODE[ANIMATION_PLAYMODE["PLAYONCESTOPAFTER"] = 2] = "PLAYONCESTOPAFTER";
        /**Plays animation like LOOP, but backwards.*/
        ANIMATION_PLAYMODE[ANIMATION_PLAYMODE["REVERSELOOP"] = 3] = "REVERSELOOP";
        /**Causes the animation not to play at all. Useful for jumping to various positions in the animation without proceeding in the animation.*/
        ANIMATION_PLAYMODE[ANIMATION_PLAYMODE["STOP"] = 4] = "STOP";
        //TODO: add an INHERIT and a PINGPONG mode
    })(ANIMATION_PLAYMODE = FudgeCore.ANIMATION_PLAYMODE || (FudgeCore.ANIMATION_PLAYMODE = {}));
    let ANIMATION_PLAYBACK;
    (function (ANIMATION_PLAYBACK) {
        //TODO: add an in-depth description of what happens to the animation (and events) depending on the Playback. Use Graphs to explain.
        /**Calculates the state of the animation at the exact position of time. Ignores FPS value of animation.*/
        ANIMATION_PLAYBACK[ANIMATION_PLAYBACK["TIMEBASED_CONTINOUS"] = 0] = "TIMEBASED_CONTINOUS";
        /**Limits the calculation of the state of the animation to the FPS value of the animation. Skips frames if needed.*/
        ANIMATION_PLAYBACK[ANIMATION_PLAYBACK["TIMEBASED_RASTERED_TO_FPS"] = 1] = "TIMEBASED_RASTERED_TO_FPS";
        /**Uses the FPS value of the animation to advance once per frame, no matter the speed of the frames. Doesn't skip any frames.*/
        ANIMATION_PLAYBACK[ANIMATION_PLAYBACK["FRAMEBASED"] = 2] = "FRAMEBASED";
    })(ANIMATION_PLAYBACK = FudgeCore.ANIMATION_PLAYBACK || (FudgeCore.ANIMATION_PLAYBACK = {}));
    /**
     * Holds a reference to an [[Animation]] and controls it. Controls playback and playmode as well as speed.
     * @authors Lukas Scheuerle, HFU, 2019
     */
    class ComponentAnimator extends FudgeCore.Component {
        constructor(_animation = new FudgeCore.Animation(""), _playmode = ANIMATION_PLAYMODE.LOOP, _playback = ANIMATION_PLAYBACK.TIMEBASED_CONTINOUS) {
            super();
            this.speedScalesWithGlobalSpeed = true;
            this.speedScale = 1;
            this.lastTime = 0;
            this.animation = _animation;
            this.playmode = _playmode;
            this.playback = _playback;
            this.localTime = new FudgeCore.Time();
            //TODO: update animation total time when loading a different animation?
            this.animation.calculateTotalTime();
            FudgeCore.Loop.addEventListener("loopFrame" /* LOOP_FRAME */, this.updateAnimationLoop.bind(this));
            FudgeCore.Time.game.addEventListener("timeScaled" /* TIME_SCALED */, this.updateScale.bind(this));
        }
        set speed(_s) {
            this.speedScale = _s;
            this.updateScale();
        }
        /**
         * Jumps to a certain time in the animation to play from there.
         * @param _time The time to jump to
         */
        jumpTo(_time) {
            this.localTime.set(_time);
            this.lastTime = _time;
            _time = _time % this.animation.totalTime;
            let mutator = this.animation.getMutated(_time, this.calculateDirection(_time), this.playback);
            this.getContainer().applyAnimation(mutator);
        }
        /**
         * Returns the current time of the animation, modulated for animation length.
         */
        getCurrentTime() {
            return this.localTime.get() % this.animation.totalTime;
        }
        /**
         * Forces an update of the animation from outside. Used in the ViewAnimation. Shouldn't be used during the game.
         * @param _time the (unscaled) time to update the animation with.
         * @returns a Tupel containing the Mutator for Animation and the playmode corrected time.
         */
        updateAnimation(_time) {
            return this.updateAnimationLoop(null, _time);
        }
        //#region transfer
        serialize() {
            let s = super.serialize();
            s["animation"] = this.animation.serialize();
            s["playmode"] = this.playmode;
            s["playback"] = this.playback;
            s["speedScale"] = this.speedScale;
            s["speedScalesWithGlobalSpeed"] = this.speedScalesWithGlobalSpeed;
            s[super.constructor.name] = super.serialize();
            return s;
        }
        deserialize(_s) {
            this.animation = new FudgeCore.Animation("");
            this.animation.deserialize(_s.animation);
            this.playback = _s.playback;
            this.playmode = _s.playmode;
            this.speedScale = _s.speedScale;
            this.speedScalesWithGlobalSpeed = _s.speedScalesWithGlobalSpeed;
            super.deserialize(_s[super.constructor.name]);
            return this;
        }
        //#endregion
        //#region updateAnimation
        /**
         * Updates the Animation.
         * Gets called every time the Loop fires the LOOP_FRAME Event.
         * Uses the built-in time unless a different time is specified.
         * May also be called from updateAnimation().
         */
        updateAnimationLoop(_e, _time) {
            if (this.animation.totalTime == 0)
                return [null, 0];
            let time = _time || this.localTime.get();
            if (this.playback == ANIMATION_PLAYBACK.FRAMEBASED) {
                time = this.lastTime + (1000 / this.animation.fps);
            }
            let direction = this.calculateDirection(time);
            time = this.applyPlaymodes(time);
            this.executeEvents(this.animation.getEventsToFire(this.lastTime, time, this.playback, direction));
            if (this.lastTime != time) {
                this.lastTime = time;
                time = time % this.animation.totalTime;
                let mutator = this.animation.getMutated(time, direction, this.playback);
                if (this.getContainer()) {
                    this.getContainer().applyAnimation(mutator);
                }
                return [mutator, time];
            }
            return [null, time];
        }
        /**
         * Fires all custom events the Animation should have fired between the last frame and the current frame.
         * @param events a list of names of custom events to fire
         */
        executeEvents(events) {
            for (let i = 0; i < events.length; i++) {
                this.dispatchEvent(new Event(events[i]));
            }
        }
        /**
         * Calculates the actual time to use, using the current playmodes.
         * @param _time the time to apply the playmodes to
         * @returns the recalculated time
         */
        applyPlaymodes(_time) {
            switch (this.playmode) {
                case ANIMATION_PLAYMODE.STOP:
                    return this.localTime.getOffset();
                case ANIMATION_PLAYMODE.PLAYONCE:
                    if (_time >= this.animation.totalTime)
                        return this.animation.totalTime - 0.01; //TODO: this might cause some issues
                    else
                        return _time;
                case ANIMATION_PLAYMODE.PLAYONCESTOPAFTER:
                    if (_time >= this.animation.totalTime)
                        return this.animation.totalTime + 0.01; //TODO: this might cause some issues
                    else
                        return _time;
                default:
                    return _time;
            }
        }
        /**
         * Calculates and returns the direction the animation should currently be playing in.
         * @param _time the time at which to calculate the direction
         * @returns 1 if forward, 0 if stop, -1 if backwards
         */
        calculateDirection(_time) {
            switch (this.playmode) {
                case ANIMATION_PLAYMODE.STOP:
                    return 0;
                // case ANIMATION_PLAYMODE.PINGPONG:
                //   if (Math.floor(_time / this.animation.totalTime) % 2 == 0)
                //     return 1;
                //   else
                //     return -1;
                case ANIMATION_PLAYMODE.REVERSELOOP:
                    return -1;
                case ANIMATION_PLAYMODE.PLAYONCE:
                case ANIMATION_PLAYMODE.PLAYONCESTOPAFTER:
                    if (_time >= this.animation.totalTime) {
                        return 0;
                    }
                default:
                    return 1;
            }
        }
        /**
         * Updates the scale of the animation if the user changes it or if the global game timer changed its scale.
         */
        updateScale() {
            let newScale = this.speedScale;
            if (this.speedScalesWithGlobalSpeed)
                newScale *= FudgeCore.Time.game.getScale();
            this.localTime.setScale(newScale);
        }
    }
    ComponentAnimator.iSubclass = FudgeCore.Component.registerSubclass(ComponentAnimator);
    FudgeCore.ComponentAnimator = ComponentAnimator;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let AUDIO_PANNER;
    (function (AUDIO_PANNER) {
        AUDIO_PANNER["CONE_INNER_ANGLE"] = "coneInnerAngle";
        AUDIO_PANNER["CONE_OUTER_ANGLE"] = "coneOuterAngle";
        AUDIO_PANNER["CONE_OUTER_GAIN"] = "coneOuterGain";
        AUDIO_PANNER["DISTANCE_MODEL"] = "distanceModel";
        AUDIO_PANNER["MAX_DISTANCE"] = "maxDistance";
        AUDIO_PANNER["PANNING_MODEL"] = "panningModel";
        AUDIO_PANNER["REF_DISTANCE"] = "refDistance";
        AUDIO_PANNER["ROLLOFF_FACTOR"] = "rolloffFactor";
    })(AUDIO_PANNER = FudgeCore.AUDIO_PANNER || (FudgeCore.AUDIO_PANNER = {}));
    let AUDIO_NODE_TYPE;
    (function (AUDIO_NODE_TYPE) {
        AUDIO_NODE_TYPE[AUDIO_NODE_TYPE["SOURCE"] = 0] = "SOURCE";
        AUDIO_NODE_TYPE[AUDIO_NODE_TYPE["PANNER"] = 1] = "PANNER";
        AUDIO_NODE_TYPE[AUDIO_NODE_TYPE["GAIN"] = 2] = "GAIN";
    })(AUDIO_NODE_TYPE = FudgeCore.AUDIO_NODE_TYPE || (FudgeCore.AUDIO_NODE_TYPE = {}));
    /**
     * Builds a minimal audio graph (by default in [[AudioManager]].default) and synchronizes it with the containing [[Node]]
     * ```plaintext
     * ‚îå AudioManager(.default) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     * ‚îÇ ‚îå ComponentAudio ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îÇ
     * ‚îÇ ‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
     * ‚îÇ ‚îÇ    ‚îÇsource‚îÇ ‚Üí ‚îÇpanner‚îÇ ‚Üí ‚îÇ gain ‚îÇ ‚Üí ‚îÇ gain ‚îÇ ‚îÇ
     * ‚îÇ ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
     * ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ
     * ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     * ```
     * @authors Thomas Dorner, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ComponentAudio extends FudgeCore.Component {
        constructor(_audio = null, _loop = false, _start = false, _audioManager = FudgeCore.AudioManager.default) {
            super();
            /** places and directs the panner relative to the world transform of the [[Node]]  */
            this.pivot = FudgeCore.Matrix4x4.IDENTITY();
            this.singleton = false;
            this.playing = false;
            this.listened = false;
            /**
             * Automatically connects/disconnects AudioNodes when adding/removing this component to/from a node.
             * Therefore unused AudioNodes may be garbage collected when an unused component is collected
             */
            this.handleAttach = (_event) => {
                // Debug.log(_event);
                if (_event.type == "componentAdd" /* COMPONENT_ADD */) {
                    this.getContainer().addEventListener("childAppendToAudioGraph" /* CHILD_APPEND */, this.handleGraph, true);
                    this.getContainer().addEventListener("childRemoveFromAudioGraph" /* CHILD_REMOVE */, this.handleGraph, true);
                    this.getContainer().addEventListener("updateAudioGraph" /* UPDATE */, this.update, true);
                    this.listened = this.getContainer().isDescendantOf(FudgeCore.AudioManager.default.getGraphListeningTo());
                }
                else {
                    this.getContainer().removeEventListener("childAppendToAudioGraph" /* CHILD_APPEND */, this.handleGraph, true);
                    this.getContainer().removeEventListener("childRemoveFromAudioGraph" /* CHILD_REMOVE */, this.handleGraph, true);
                    this.getContainer().removeEventListener("updateAudioGraph" /* UPDATE */, this.update, true);
                    this.listened = false;
                }
                this.updateConnection();
            };
            /**
             * Automatically connects/disconnects AudioNodes when appending/removing the FUDGE-graph the component is in.
             */
            this.handleGraph = (_event) => {
                // Debug.log(_event);
                this.listened = (_event.type == "childAppendToAudioGraph" /* CHILD_APPEND */);
                this.updateConnection();
            };
            /**
             * Updates the panner node, its position and direction, using the worldmatrix of the container and the pivot of this component.
             */
            this.update = (_event) => {
                let mtxResult = this.pivot;
                if (this.getContainer())
                    mtxResult = FudgeCore.Matrix4x4.MULTIPLICATION(this.getContainer().mtxWorld, this.pivot);
                // Debug.log(mtxResult.toString());
                let position = mtxResult.translation;
                let forward = FudgeCore.Vector3.TRANSFORMATION(FudgeCore.Vector3.Z(1), mtxResult, false);
                this.panner.positionX.value = position.x;
                this.panner.positionY.value = position.y;
                this.panner.positionZ.value = position.z;
                this.panner.orientationX.value = forward.x;
                this.panner.orientationY.value = forward.y;
                this.panner.orientationZ.value = forward.z;
            };
            this.install(_audioManager);
            this.createSource(_audio, _loop);
            this.addEventListener("componentAdd" /* COMPONENT_ADD */, this.handleAttach);
            this.addEventListener("componentRemove" /* COMPONENT_REMOVE */, this.handleAttach);
            if (_start)
                this.play(_start);
        }
        set audio(_audio) {
            this.source.buffer = _audio;
        }
        get audio() {
            return this.source.buffer;
        }
        set volume(_value) {
            this.gain.gain.value = _value;
        }
        get volume() {
            return this.gain.gain.value;
        }
        /**
         * Set the property of the panner to the given value. Use to manipulate range and rolloff etc.
         */
        setPanner(_property, _value) {
            Object.assign(this.panner, { [_property]: _value });
        }
        // TODO: may be used for serialization of AudioNodes
        getMutatorOfNode(_type) {
            let node = this.getAudioNode(_type);
            let mutator = FudgeCore.getMutatorOfArbitrary(node);
            return mutator;
        }
        /**
         * Returns the specified AudioNode of the standard graph for further manipulation
         */
        getAudioNode(_type) {
            switch (_type) {
                case AUDIO_NODE_TYPE.SOURCE: return this.source;
                case AUDIO_NODE_TYPE.PANNER: return this.panner;
                case AUDIO_NODE_TYPE.GAIN: return this.gain;
            }
        }
        /**
         * Start or stop playing the audio
         */
        play(_on) {
            if (_on) {
                this.createSource(this.audio, this.source.loop);
                this.source.start(0, 0);
            }
            else
                this.source.stop();
            this.playing = _on;
        }
        get isPlaying() {
            return this.playing;
        }
        get isAttached() {
            return this.getContainer() != null;
        }
        get isListened() {
            return this.listened;
        }
        /**
         * Inserts AudioNodes between the panner and the local gain of this [[ComponentAudio]]
         * _input and _output may be the same AudioNode, if there is only one to insert,
         * or may have multiple AudioNode between them to create an effect-graph.\
         * Note that [[ComponentAudio]] does not keep track of inserted AudioNodes!
         * ```plaintext
         * ‚îå AudioManager(.default) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         * ‚îÇ ‚îå ComponentAudio ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îÇ
         * ‚îÇ ‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
         * ‚îÇ ‚îÇ    ‚îÇsource‚îÇ ‚Üí ‚îÇpanner‚îÇ ‚Üí ‚îÇ_input‚îÇ ‚Üí ...  ‚Üí ‚îÇ_output‚îÇ ‚Üí ‚îÇ gain ‚îÇ ‚Üí ‚îÇ gain ‚îÇ ‚îÇ
         * ‚îÇ ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
         * ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ
         * ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         * ```
         */
        insertAudioNodes(_input, _output) {
            this.panner.disconnect(0);
            if (!_input && !_output) {
                this.panner.connect(this.gain);
                return;
            }
            this.panner.connect(_input);
            _output.connect(this.gain);
        }
        /**
         * Activate override. Connects or disconnects AudioNodes
         */
        activate(_on) {
            super.activate(_on);
            this.updateConnection();
        }
        /**
         * Connects this components gain-node to the gain node of the AudioManager this component runs on.
         * Only call this method if the component is not attached to a [[Node]] but needs to be heard.
         */
        connect(_on) {
            if (_on)
                this.gain.connect(this.audioManager.gain);
            else
                this.gain.disconnect(this.audioManager.gain);
        }
        install(_audioManager = FudgeCore.AudioManager.default) {
            let active = this.isActive;
            this.activate(false);
            this.audioManager = _audioManager;
            this.panner = _audioManager.createPanner();
            this.gain = _audioManager.createGain();
            this.panner.connect(this.gain);
            this.gain.connect(_audioManager.gain);
            this.activate(active);
        }
        createSource(_audio, _loop) {
            if (this.source) {
                this.source.disconnect();
                this.source.buffer = null;
            }
            this.source = this.audioManager.createBufferSource();
            this.source.connect(this.panner);
            if (_audio)
                this.audio = _audio;
            this.source.loop = _loop;
        }
        updateConnection() {
            try {
                this.connect(this.isActive && this.isAttached && this.listened);
            }
            catch (_error) {
                // nop
            }
        }
    }
    ComponentAudio.iSubclass = FudgeCore.Component.registerSubclass(ComponentAudio);
    FudgeCore.ComponentAudio = ComponentAudio;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Serves to set the spatial location and orientation of AudioListeners relative to the
     * world transform of the [[Node]] it is attached to.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ComponentAudioListener extends FudgeCore.Component {
        constructor() {
            super(...arguments);
            this.pivot = FudgeCore.Matrix4x4.IDENTITY();
        }
        /**
         * Updates the position and orientation of the given AudioListener
         */
        update(_listener) {
            let mtxResult = this.pivot;
            if (this.getContainer())
                mtxResult = FudgeCore.Matrix4x4.MULTIPLICATION(this.getContainer().mtxWorld, this.pivot);
            // Debug.log(mtxResult.toString());
            let position = mtxResult.translation;
            let forward = FudgeCore.Vector3.TRANSFORMATION(FudgeCore.Vector3.Z(1), mtxResult, false);
            let up = FudgeCore.Vector3.TRANSFORMATION(FudgeCore.Vector3.Y(), mtxResult, false);
            _listener.positionX.value = position.x;
            _listener.positionY.value = position.y;
            _listener.positionZ.value = position.z;
            _listener.forwardX.value = forward.x;
            _listener.forwardY.value = forward.y;
            _listener.forwardZ.value = forward.z;
            _listener.upX.value = up.x;
            _listener.upY.value = up.y;
            _listener.upZ.value = up.z;
            // Debug.log(mtxResult.translation.toString(), forward.toString(), up.toString());
        }
    }
    ComponentAudioListener.iSubclass = FudgeCore.Component.registerSubclass(ComponentAudioListener);
    FudgeCore.ComponentAudioListener = ComponentAudioListener;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="Component.ts"/>
var FudgeCore;
// / <reference path="Component.ts"/>
(function (FudgeCore) {
    let FIELD_OF_VIEW;
    (function (FIELD_OF_VIEW) {
        FIELD_OF_VIEW[FIELD_OF_VIEW["HORIZONTAL"] = 0] = "HORIZONTAL";
        FIELD_OF_VIEW[FIELD_OF_VIEW["VERTICAL"] = 1] = "VERTICAL";
        FIELD_OF_VIEW[FIELD_OF_VIEW["DIAGONAL"] = 2] = "DIAGONAL";
    })(FIELD_OF_VIEW = FudgeCore.FIELD_OF_VIEW || (FudgeCore.FIELD_OF_VIEW = {}));
    /**
     * Defines identifiers for the various projections a camera can provide.
     * TODO: change back to number enum if strings not needed
     */
    let PROJECTION;
    (function (PROJECTION) {
        PROJECTION["CENTRAL"] = "central";
        PROJECTION["ORTHOGRAPHIC"] = "orthographic";
        PROJECTION["DIMETRIC"] = "dimetric";
        PROJECTION["STEREO"] = "stereo";
    })(PROJECTION = FudgeCore.PROJECTION || (FudgeCore.PROJECTION = {}));
    /**
     * The camera component holds the projection-matrix and other data needed to render a scene from the perspective of the node it is attached to.
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ComponentCamera extends FudgeCore.Component {
        constructor() {
            super(...arguments);
            this.pivot = FudgeCore.Matrix4x4.IDENTITY();
            this.backgroundColor = new FudgeCore.Color(0, 0, 0, 1); // The color of the background the camera will render.
            //private orthographic: boolean = false; // Determines whether the image will be rendered with perspective or orthographic projection.
            this.projection = PROJECTION.CENTRAL;
            this.transform = new FudgeCore.Matrix4x4; // The matrix to multiply each scene objects transformation by, to determine where it will be drawn.
            this.fieldOfView = 45; // The camera's sensorangle.
            this.aspectRatio = 1.0;
            this.direction = FIELD_OF_VIEW.DIAGONAL;
            this.backgroundEnabled = true; // Determines whether or not the background of this camera will be rendered.
            //#endregion
        }
        // TODO: examine, if background should be an attribute of Camera or Viewport
        getProjection() {
            return this.projection;
        }
        getBackgroundEnabled() {
            return this.backgroundEnabled;
        }
        getAspect() {
            return this.aspectRatio;
        }
        getFieldOfView() {
            return this.fieldOfView;
        }
        getDirection() {
            return this.direction;
        }
        /**
         * Returns the multiplikation of the worldtransformation of the camera container with the projection matrix
         * @returns the world-projection-matrix
         */
        get ViewProjectionMatrix() {
            //TODO: optimize, no need to recalculate if neither mtxWorld nor pivot have changed
            let mtxCamera = this.pivot;
            try {
                mtxCamera = FudgeCore.Matrix4x4.MULTIPLICATION(this.getContainer().mtxWorld, this.pivot);
            }
            catch (_error) {
                // no container node or no world transformation found -> continue with pivot only
            }
            let mtxWorldProjection = FudgeCore.Matrix4x4.INVERSION(mtxCamera);
            mtxWorldProjection = FudgeCore.Matrix4x4.MULTIPLICATION(this.transform, mtxWorldProjection);
            return mtxWorldProjection;
        }
        /**
         * Set the camera to perspective projection. The world origin is in the center of the canvaselement.
         * @param _aspect The aspect ratio between width and height of projectionspace.(Default = canvas.clientWidth / canvas.ClientHeight)
         * @param _fieldOfView The field of view in Degrees. (Default = 45)
         * @param _direction The plane on which the fieldOfView-Angle is given
         */
        projectCentral(_aspect = this.aspectRatio, _fieldOfView = this.fieldOfView, _direction = this.direction) {
            this.aspectRatio = _aspect;
            this.fieldOfView = _fieldOfView;
            this.direction = _direction;
            this.projection = PROJECTION.CENTRAL;
            this.transform = FudgeCore.Matrix4x4.PROJECTION_CENTRAL(_aspect, this.fieldOfView, 1, 2000, this.direction); // TODO: remove magic numbers
        }
        /**
         * Set the camera to orthographic projection. The origin is in the top left corner of the canvas.
         * @param _left The positionvalue of the projectionspace's left border. (Default = 0)
         * @param _right The positionvalue of the projectionspace's right border. (Default = canvas.clientWidth)
         * @param _bottom The positionvalue of the projectionspace's bottom border.(Default = canvas.clientHeight)
         * @param _top The positionvalue of the projectionspace's top border.(Default = 0)
         */
        projectOrthographic(_left = 0, _right = FudgeCore.RenderManager.getCanvas().clientWidth, _bottom = FudgeCore.RenderManager.getCanvas().clientHeight, _top = 0) {
            this.projection = PROJECTION.ORTHOGRAPHIC;
            this.transform = FudgeCore.Matrix4x4.PROJECTION_ORTHOGRAPHIC(_left, _right, _bottom, _top, 400, -400); // TODO: examine magic numbers!
        }
        /**
         * Return the calculated normed dimension of the projection surface, that is in the hypothetical distance of 1 to the camera
         */
        getProjectionRectangle() {
            let tanFov = Math.tan(Math.PI * this.fieldOfView / 360); // Half of the angle, to calculate dimension from the center -> right angle
            let tanHorizontal = 0;
            let tanVertical = 0;
            if (this.direction == FIELD_OF_VIEW.DIAGONAL) {
                let aspect = Math.sqrt(this.aspectRatio);
                tanHorizontal = tanFov * aspect;
                tanVertical = tanFov / aspect;
            }
            else if (this.direction == FIELD_OF_VIEW.VERTICAL) {
                tanVertical = tanFov;
                tanHorizontal = tanVertical * this.aspectRatio;
            }
            else { //FOV_DIRECTION.HORIZONTAL
                tanHorizontal = tanFov;
                tanVertical = tanHorizontal / this.aspectRatio;
            }
            return FudgeCore.Rectangle.GET(0, 0, tanHorizontal * 2, tanVertical * 2);
        }
        project(_pointInWorldSpace) {
            let result;
            result = FudgeCore.Vector3.TRANSFORMATION(_pointInWorldSpace, this.ViewProjectionMatrix);
            let m = this.ViewProjectionMatrix.get();
            let w = m[3] * _pointInWorldSpace.x + m[7] * _pointInWorldSpace.y + m[11] * _pointInWorldSpace.z + m[15];
            result.scale(1 / w);
            return result;
        }
        //#region Transfer
        serialize() {
            let serialization = {
                backgroundColor: this.backgroundColor,
                backgroundEnabled: this.backgroundEnabled,
                projection: this.projection,
                fieldOfView: this.fieldOfView,
                direction: this.direction,
                aspect: this.aspectRatio,
                pivot: this.pivot.serialize(),
                [super.constructor.name]: super.serialize()
            };
            return serialization;
        }
        deserialize(_serialization) {
            this.backgroundColor = _serialization.backgroundColor;
            this.backgroundEnabled = _serialization.backgroundEnabled;
            this.projection = _serialization.projection;
            this.fieldOfView = _serialization.fieldOfView;
            this.aspectRatio = _serialization.aspect;
            this.direction = _serialization.direction;
            this.pivot.deserialize(_serialization.pivot);
            super.deserialize(_serialization[super.constructor.name]);
            switch (this.projection) {
                case PROJECTION.ORTHOGRAPHIC:
                    this.projectOrthographic(); // TODO: serialize and deserialize parameters
                    break;
                case PROJECTION.CENTRAL:
                    this.projectCentral();
                    break;
            }
            return this;
        }
        getMutatorAttributeTypes(_mutator) {
            let types = super.getMutatorAttributeTypes(_mutator);
            if (types.direction)
                types.direction = FIELD_OF_VIEW;
            if (types.projection)
                types.projection = PROJECTION;
            return types;
        }
        mutate(_mutator) {
            super.mutate(_mutator);
            switch (this.projection) {
                case PROJECTION.CENTRAL:
                    this.projectCentral(this.aspectRatio, this.fieldOfView, this.direction);
                    break;
            }
        }
        reduceMutator(_mutator) {
            delete _mutator.transform;
            super.reduceMutator(_mutator);
        }
    }
    ComponentCamera.iSubclass = FudgeCore.Component.registerSubclass(ComponentCamera);
    FudgeCore.ComponentCamera = ComponentCamera;
})(FudgeCore || (FudgeCore = {}));
// /<reference path="../Light/Light.ts"/>
var FudgeCore;
// /<reference path="../Light/Light.ts"/>
(function (FudgeCore) {
    /**
     * Attaches a [[Light]] to the node
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    /**
     * Defines identifiers for the various types of light this component can provide.
     */
    // export enum LIGHT_TYPE {
    //     AMBIENT = "ambient",
    //     DIRECTIONAL = "directional",
    //     POINT = "point",
    //     SPOT = "spot"
    // }
    class ComponentLight extends FudgeCore.Component {
        constructor(_light = new FudgeCore.LightAmbient()) {
            super();
            // private static constructors: { [type: string]: General } = { [LIGHT_TYPE.AMBIENT]: LightAmbient, [LIGHT_TYPE.DIRECTIONAL]: LightDirectional, [LIGHT_TYPE.POINT]: LightPoint, [LIGHT_TYPE.SPOT]: LightSpot };
            this.pivot = FudgeCore.Matrix4x4.IDENTITY();
            this.light = null;
            this.singleton = false;
            this.light = _light;
        }
        setType(_class) {
            let mtrOld = {};
            if (this.light)
                mtrOld = this.light.getMutator();
            this.light = new _class();
            this.light.mutate(mtrOld);
        }
    }
    ComponentLight.iSubclass = FudgeCore.Component.registerSubclass(ComponentLight);
    FudgeCore.ComponentLight = ComponentLight;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Attaches a [[Material]] to the node
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ComponentMaterial extends FudgeCore.Component {
        // public mutatorCoat: MutatorForComponent;
        constructor(_material = null) {
            super();
            this.clrPrimary = FudgeCore.Color.CSS("white");
            this.clrSecondary = FudgeCore.Color.CSS("white");
            this.material = _material;
            // this.mutatorCoat = _material.getCoat().getMutatorForComponent();
        }
        //#region Transfer
        serialize() {
            let serialization;
            /* at this point of time, serialization as resource and as inline object is possible. TODO: check if inline becomes obsolete */
            let idMaterial = this.material.idResource;
            if (idMaterial)
                serialization = { idMaterial: idMaterial };
            else
                serialization = { material: FudgeCore.Serializer.serialize(this.material) };
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        deserialize(_serialization) {
            let material;
            if (_serialization.idMaterial)
                material = FudgeCore.ResourceManager.get(_serialization.idMaterial);
            else
                material = FudgeCore.Serializer.deserialize(_serialization.material);
            this.material = material;
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
    }
    ComponentMaterial.iSubclass = FudgeCore.Component.registerSubclass(ComponentMaterial);
    FudgeCore.ComponentMaterial = ComponentMaterial;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Attaches a [[Mesh]] to the node
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ComponentMesh extends FudgeCore.Component {
        constructor(_mesh = null) {
            super();
            this.pivot = FudgeCore.Matrix4x4.IDENTITY();
            this.mesh = null;
            this.mesh = _mesh;
        }
        //#region Transfer
        serialize() {
            let serialization;
            /* at this point of time, serialization as resource and as inline object is possible. TODO: check if inline becomes obsolete */
            let idMesh = this.mesh.idResource;
            if (idMesh)
                serialization = { idMesh: idMesh };
            else
                serialization = { mesh: FudgeCore.Serializer.serialize(this.mesh) };
            serialization.pivot = this.pivot.serialize();
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        deserialize(_serialization) {
            let mesh;
            if (_serialization.idMesh)
                mesh = FudgeCore.ResourceManager.get(_serialization.idMesh);
            else
                mesh = FudgeCore.Serializer.deserialize(_serialization.mesh);
            this.mesh = mesh;
            this.pivot.deserialize(_serialization.pivot);
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        getMutatorForUserInterface() {
            let mutator = this.getMutator();
            if (!this.mesh)
                mutator.mesh = FudgeCore.Mesh;
            return mutator;
        }
    }
    ComponentMesh.iSubclass = FudgeCore.Component.registerSubclass(ComponentMesh);
    FudgeCore.ComponentMesh = ComponentMesh;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ComponentParticleSystem extends FudgeCore.Component {
        // color
        constructor(_filename = null, _numberOfParticles = null) {
            super();
            this.storedValues = {}; // TODO: make private
            this.randomNumbers = [];
            for (let i = 0; i < 2000 /* TODO: don't hardcode this number, number should be bigger than number of particles */; i++) {
                this.randomNumbers.push(Math.random());
            }
            this.storedValues = {
                "time": 0,
                "index": 0,
                "size": _numberOfParticles
            };
            let effectImporter = new FudgeCore.ParticleEffectImporter(this.storedValues, this.randomNumbers);
            this.effectData = effectImporter.importFile(_filename);
            // evaluate system storage
            if (this.effectData["storage"])
                this.evaluateClosureStorage(this.effectData["storage"]["system"]);
        }
        updateParticleEffect(_time) {
            this.storedValues["time"] = _time;
        }
        evaluateClosureStorage(_storageData) {
            for (const key in _storageData) {
                this.storedValues[key] = _storageData[key]();
            }
        }
    }
    ComponentParticleSystem.iSubclass = FudgeCore.Component.registerSubclass(ComponentParticleSystem);
    FudgeCore.ComponentParticleSystem = ComponentParticleSystem;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Base class for scripts the user writes
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Component
     */
    class ComponentScript extends FudgeCore.Component {
        constructor() {
            super();
            this.singleton = false;
        }
        serialize() {
            return this.getMutator();
        }
        deserialize(_serialization) {
            this.mutate(_serialization);
            return this;
        }
    }
    // registering this doesn't make sense, only its subclasses. Or this component must refer to scripts to be attached to this component
    // TODO: rethink & refactor
    ComponentScript.iSubclass = FudgeCore.Component.registerSubclass(ComponentScript);
    FudgeCore.ComponentScript = ComponentScript;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Attaches a transform-[[Matrix4x4]] to the node, moving, scaling and rotating it in space relative to its parent.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ComponentTransform extends FudgeCore.Component {
        constructor(_matrix = FudgeCore.Matrix4x4.IDENTITY()) {
            super();
            this.local = _matrix;
        }
        //#region Transfer
        serialize() {
            let serialization = {
                local: this.local.serialize(),
                [super.constructor.name]: super.serialize()
            };
            return serialization;
        }
        deserialize(_serialization) {
            super.deserialize(_serialization[super.constructor.name]);
            this.local.deserialize(_serialization.local);
            return this;
        }
        // public mutate(_mutator: Mutator): void {
        //     this.local.mutate(_mutator);
        // }
        // public getMutator(): Mutator { 
        //     return this.local.getMutator();
        // }
        // public getMutatorAttributeTypes(_mutator: Mutator): MutatorAttributeTypes {
        //     let types: MutatorAttributeTypes = this.local.getMutatorAttributeTypes(_mutator);
        //     return types;
        // }
        reduceMutator(_mutator) {
            delete _mutator.world;
            super.reduceMutator(_mutator);
        }
    }
    ComponentTransform.iSubclass = FudgeCore.Component.registerSubclass(ComponentTransform);
    FudgeCore.ComponentTransform = ComponentTransform;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Processes input signals of type number and generates an output signal of the same type using
     * proportional, integral or differential mapping, an amplification factor and a linear dampening/delay
     * ```plaintext
     *          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     *          ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      pass through (Proportional)      ‚îÇ
     *  Input ‚Üí ‚îÇ ‚Üí ‚îÇamplify‚îÇ ‚Üí ‚îÇdelay‚îÇ ‚Üí ‚öü sum up over time (Integral) ‚öû ‚Üí ‚îÇ ‚Üí Output
     *          ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      pass change  (Differential)      ‚îÇ
     *          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     * ```
     */
    class Control extends EventTarget {
        constructor(_name, _factor = 1, _type = 0 /* PROPORTIONAL */, _active = true) {
            super();
            this.rateDispatchOutput = 0;
            this.valuePrevious = 0;
            this.outputBase = 0;
            this.outputTarget = 0;
            this.outputPrevious = 0;
            this.outputTargetPrevious = 0;
            this.factor = 0;
            this.time = FudgeCore.Time.game;
            this.timeValueDelay = 0;
            this.timeOutputTargetSet = 0;
            this.idTimer = undefined;
            this.dispatchOutput = (_eventOrValue) => {
                let timer = this.time.getTimer(this.idTimer);
                let output;
                if (typeof (_eventOrValue) == "number")
                    output = _eventOrValue;
                else
                    output = this.calculateOutput();
                let outputChanged = (output != this.outputPrevious);
                if (timer)
                    timer.active = outputChanged;
                if (!outputChanged)
                    return;
                this.outputPrevious = output;
                let event = new CustomEvent("output" /* OUTPUT */, {
                    detail: {
                        output: output
                    }
                });
                this.dispatchEvent(event);
            };
            this.factor = _factor;
            this.type = _type;
            this.active = _active;
            this.name = _name;
        }
        /**
         * Set the time-object to be used when calculating the output in [[CONTROL_TYPE.INTEGRAL]]
         */
        setTimebase(_time) {
            this.time = _time;
            this.calculateOutput();
        }
        /**
         * Feed an input value into this control and fire the events [[EVENT_CONTROL.INPUT]] and [[EVENT_CONTROL.OUTPUT]]
         */
        setInput(_input) {
            this.outputBase = this.calculateOutput();
            this.valuePrevious = this.getValueDelayed();
            this.outputTarget = this.factor * _input;
            this.timeOutputTargetSet = this.time.get();
            if (this.type == 2 /* DIFFERENTIAL */) {
                this.valuePrevious = this.outputTarget - this.outputTargetPrevious;
                this.outputTargetPrevious = this.outputTarget;
                this.outputTarget = 0;
            }
            this.dispatchEvent(new Event("input" /* INPUT */));
            if (this.type == 2 /* DIFFERENTIAL */)
                this.dispatchOutput(this.valuePrevious);
            else
                this.dispatchOutput(null);
        }
        /**
         * Set the time to take for the internal linear dampening until the final ouput value is reached
         */
        setDelay(_time) {
            this.timeValueDelay = Math.max(0, _time);
        }
        /**
         * Set the number of output-events to dispatch per second.
         * At the default of 0, the control output must be polled and will only actively dispatched once each time input occurs and the output changes.
         */
        setRateDispatchOutput(_rateDispatchOutput = 0) {
            this.rateDispatchOutput = _rateDispatchOutput;
            this.time.deleteTimer(this.idTimer);
            this.idTimer = undefined;
            if (this.rateDispatchOutput)
                this.idTimer = this.time.setTimer(1000 / this.rateDispatchOutput, 0, this.dispatchOutput);
        }
        /**
         * Set the factor to multiply the input value given with [[setInput]] with
         */
        setFactor(_factor) {
            this.factor = _factor;
        }
        /**
         * Get the value from the output of this control
         */
        getOutput() {
            return this.calculateOutput();
        }
        /**
         * Calculates the output of this control
         */
        calculateOutput() {
            let output = 0;
            let value = this.getValueDelayed();
            switch (this.type) {
                case 1 /* INTEGRAL */:
                    let timeCurrent = this.time.get();
                    let timeElapsedSinceInput = timeCurrent - this.timeOutputTargetSet;
                    output = this.outputBase;
                    if (this.timeValueDelay > 0) {
                        if (timeElapsedSinceInput < this.timeValueDelay) {
                            output += 0.5 * (this.valuePrevious + value) * timeElapsedSinceInput;
                            break;
                        }
                        else {
                            output += 0.5 * (this.valuePrevious + value) * this.timeValueDelay;
                            timeElapsedSinceInput -= this.timeValueDelay;
                        }
                    }
                    output += value * timeElapsedSinceInput;
                    // value += 0.5 * (this.inputPrevious - input) * this.timeInputDelay + input * timeElapsedSinceInput;
                    break;
                case 2 /* DIFFERENTIAL */:
                case 0 /* PROPORTIONAL */:
                default:
                    output = value;
                    break;
            }
            return output;
        }
        getValueDelayed() {
            if (this.timeValueDelay > 0) {
                let timeElapsedSinceInput = this.time.get() - this.timeOutputTargetSet;
                if (timeElapsedSinceInput < this.timeValueDelay)
                    return this.valuePrevious + (this.outputTarget - this.valuePrevious) * timeElapsedSinceInput / this.timeValueDelay;
            }
            return this.outputTarget;
        }
    }
    FudgeCore.Control = Control;
})(FudgeCore || (FudgeCore = {}));
///<reference path="Control.ts"/>
var FudgeCore;
///<reference path="Control.ts"/>
(function (FudgeCore) {
    /**
     * Handles multiple controls as inputs and creates an output from that.
     * As a subclass of [[Control]], axis calculates the ouput summing up the inputs and processing the result using its own settings.
     * Dispatches [[EVENT_CONTROL.OUTPUT]] and [[EVENT_CONTROL.INPUT]] when one of the controls dispatches them.
     * ```plaintext
     *           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     *           ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                 ‚îÇ
     *   Input ‚Üí ‚îÇ ‚îÇcontrol‚îÇ\                                ‚îÇ
     *           ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò \                               ‚îÇ
     *           ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  \‚îå‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
     *   Input ‚Üí ‚îÇ ‚îÇcontrol‚îÇ---‚îÇsum‚îÇ ‚Üí ‚îÇinternal control ‚îÇ ‚Üí ‚îÇ ‚Üí Output
     *           ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  /‚îî‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
     *           ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê /                               ‚îÇ
     *   Input ‚Üí ‚îÇ ‚îÇcontrol‚îÇ/                                ‚îÇ
     *           ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                 ‚îÇ
     *           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     * ```
     */
    class Axis extends FudgeCore.Control {
        constructor() {
            super(...arguments);
            this.controls = new Map();
            this.sumPrevious = 0;
            this.hndOutputEvent = (_event) => {
                let control = _event.target;
                let event = new CustomEvent("output" /* OUTPUT */, { detail: {
                        control: control,
                        input: _event.detail.output,
                        output: this.getOutput()
                    } });
                this.dispatchEvent(event);
            };
            this.hndInputEvent = (_event) => {
                let event = new Event("input" /* INPUT */, _event);
                this.dispatchEvent(event);
            };
        }
        /**
         * Add the control given to the list of controls feeding into this axis
         */
        addControl(_control) {
            this.controls.set(_control.name, _control);
            _control.addEventListener("input" /* INPUT */, this.hndInputEvent);
            _control.addEventListener("output" /* OUTPUT */, this.hndOutputEvent);
        }
        /**
         * Returns the control with the given name
         */
        getControl(_name) {
            return this.controls.get(_name);
        }
        /**
         * Removes the control with the given name
         */
        removeControl(_name) {
            let control = this.getControl(_name);
            if (control) {
                control.removeEventListener("input" /* INPUT */, this.hndInputEvent);
                control.removeEventListener("output" /* OUTPUT */, this.hndOutputEvent);
                this.controls.delete(_name);
            }
        }
        /**
         * Returns the value of this axis after summing up all inputs and processing the sum according to the axis' settings
         */
        getOutput() {
            let sumInput = 0;
            for (let control of this.controls) {
                if (control[1].active)
                    sumInput += control[1].getOutput();
            }
            if (sumInput != this.sumPrevious)
                super.setInput(sumInput);
            this.sumPrevious = sumInput;
            return super.getOutput();
        }
    }
    FudgeCore.Axis = Axis;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Collects the keys pressed on the keyboard and stores their status.
     */
    class Keyboard {
        /**
         * Returns true if one of the given keys is is currently being pressed.
         */
        static isPressedOne(_keys) {
            for (let code of _keys) {
                if (Keyboard.keysPressed[code])
                    return true;
            }
            return false;
        }
        /**
         * Returns true if all of the given keys are currently being pressed
         */
        static isPressedCombo(_keys) {
            for (let code of _keys) {
                if (!Keyboard.keysPressed[code])
                    return false;
            }
            return true;
        }
        /**
         * Returns the value given as _active if one or, when _combo is true, all of the given keys are pressed.
         * Returns the value given as _inactive if not.
         */
        static mapToValue(_active, _inactive, _keys, _combo = false) {
            if (!_combo && Keyboard.isPressedOne(_keys))
                return _active;
            if (Keyboard.isPressedCombo(_keys))
                return _active;
            return _inactive;
        }
        static initialize() {
            let store = {};
            document.addEventListener("keydown", Keyboard.hndKeyInteraction);
            document.addEventListener("keyup", Keyboard.hndKeyInteraction);
            return store;
        }
        static hndKeyInteraction(_event) {
            Keyboard.keysPressed[_event.code] = (_event.type == "keydown");
        }
    }
    Keyboard.keysPressed = Keyboard.initialize();
    FudgeCore.Keyboard = Keyboard;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
(function (FudgeCore) {
    /**
     * Routing to the alert box
     */
    class DebugAlert extends FudgeCore.DebugTarget {
        static createDelegate(_headline) {
            let delegate = function (_message, ..._args) {
                let args = _args.map(_arg => _arg.toString());
                let out = _headline + " " + FudgeCore.DebugTarget.mergeArguments(_message, args);
                alert(out);
            };
            return delegate;
        }
    }
    DebugAlert.delegates = {
        [FudgeCore.DEBUG_FILTER.INFO]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.INFO]),
        [FudgeCore.DEBUG_FILTER.LOG]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.LOG]),
        [FudgeCore.DEBUG_FILTER.WARN]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.WARN]),
        [FudgeCore.DEBUG_FILTER.ERROR]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.ERROR]),
        [FudgeCore.DEBUG_FILTER.FUDGE]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.FUDGE])
    };
    FudgeCore.DebugAlert = DebugAlert;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
(function (FudgeCore) {
    /**
     * Routing to a HTMLDialogElement
     */
    class DebugDialog extends FudgeCore.DebugTarget {
    }
    FudgeCore.DebugDialog = DebugDialog;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
(function (FudgeCore) {
    /**
     * Route to an HTMLTextArea, may be obsolete when using HTMLDialogElement
     */
    class DebugTextArea extends FudgeCore.DebugTarget {
        static clear() {
            DebugTextArea.textArea.textContent = "";
            DebugTextArea.groups = [];
        }
        static group(_name) {
            DebugTextArea.print("‚ñº " + _name);
            DebugTextArea.groups.push(_name);
        }
        static groupEnd() {
            DebugTextArea.groups.pop();
        }
        static createDelegate(_headline) {
            let delegate = function (_message, ..._args) {
                DebugTextArea.print(_headline + " " + FudgeCore.DebugTarget.mergeArguments(_message, _args));
            };
            return delegate;
        }
        static getIndentation(_level) {
            let result = "";
            for (let i = 0; i < _level; i++)
                result += "| ";
            return result;
        }
        static print(_text) {
            DebugTextArea.textArea.textContent += DebugTextArea.getIndentation(DebugTextArea.groups.length) + _text + "\n";
            if (DebugTextArea.autoScroll)
                DebugTextArea.textArea.scrollTop = DebugTextArea.textArea.scrollHeight;
        }
    }
    DebugTextArea.textArea = document.createElement("textarea");
    DebugTextArea.autoScroll = true;
    DebugTextArea.delegates = {
        [FudgeCore.DEBUG_FILTER.INFO]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.INFO]),
        [FudgeCore.DEBUG_FILTER.LOG]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.LOG]),
        [FudgeCore.DEBUG_FILTER.WARN]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.WARN]),
        [FudgeCore.DEBUG_FILTER.ERROR]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.ERROR]),
        [FudgeCore.DEBUG_FILTER.FUDGE]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.FUDGE]),
        [FudgeCore.DEBUG_FILTER.CLEAR]: DebugTextArea.clear,
        [FudgeCore.DEBUG_FILTER.GROUP]: DebugTextArea.group,
        [FudgeCore.DEBUG_FILTER.GROUPCOLLAPSED]: DebugTextArea.group,
        [FudgeCore.DEBUG_FILTER.GROUPEND]: DebugTextArea.groupEnd
    };
    DebugTextArea.groups = [];
    FudgeCore.DebugTextArea = DebugTextArea;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Defines a color as values in the range of 0 to 1 for the four channels red, green, blue and alpha (for opacity)
     */
    class Color extends FudgeCore.Mutable {
        constructor(_r = 1, _g = 1, _b = 1, _a = 1) {
            super();
            this.setNormRGBA(_r, _g, _b, _a);
        }
        static getHexFromCSSKeyword(_keyword) {
            Color.crc2.fillStyle = _keyword;
            return Color.crc2.fillStyle;
        }
        static CSS(_keyword, _alpha = 1) {
            let hex = Color.getHexFromCSSKeyword(_keyword);
            let color = new Color(parseInt(hex.substr(1, 2), 16) / 255, parseInt(hex.substr(3, 2), 16) / 255, parseInt(hex.substr(5, 2), 16) / 255, _alpha);
            return color;
        }
        static MULTIPLY(_color1, _color2) {
            return new Color(_color1.r * _color2.r, _color1.g * _color2.g, _color1.b * _color2.b, _color1.a * _color2.a);
        }
        setNormRGBA(_r, _g, _b, _a) {
            this.r = Math.min(1, Math.max(0, _r));
            this.g = Math.min(1, Math.max(0, _g));
            this.b = Math.min(1, Math.max(0, _b));
            this.a = Math.min(1, Math.max(0, _a));
        }
        setBytesRGBA(_r, _g, _b, _a) {
            this.setNormRGBA(_r / 255, _g / 255, _b / 255, _a / 255);
        }
        getArray() {
            return new Float32Array([this.r, this.g, this.b, this.a]);
        }
        setArrayNormRGBA(_color) {
            this.setNormRGBA(_color[0], _color[1], _color[2], _color[3]);
        }
        setArrayBytesRGBA(_color) {
            this.setBytesRGBA(_color[0], _color[1], _color[2], _color[3]);
        }
        getArrayBytesRGBA() {
            return new Uint8ClampedArray([this.r * 255, this.g * 255, this.b * 255, this.a * 255]);
        }
        add(_color) {
            this.r += _color.r;
            this.g += _color.g;
            this.b += _color.b;
            this.a += _color.a;
        }
        getCSS() {
            let bytes = this.getArrayBytesRGBA();
            return `RGBA(${bytes[0]}, ${bytes[1]}, ${bytes[2]}, ${bytes[3]})`;
        }
        getHex() {
            let bytes = this.getArrayBytesRGBA();
            let hex = "";
            for (let byte of bytes)
                hex += byte.toString(16).padStart(2, "0");
            return hex;
        }
        setHex(_hex) {
            let bytes = this.getArrayBytesRGBA();
            let channel = 0;
            for (let byte in bytes)
                bytes[byte] = parseInt(_hex.substr(channel++ * 2, 2), 16);
            this.setArrayBytesRGBA(bytes);
        }
        reduceMutator(_mutator) { }
    }
    // crc2 only used for converting colors from strings predefined by CSS
    Color.crc2 = document.createElement("canvas").getContext("2d");
    FudgeCore.Color = Color;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Baseclass for materials. Combines a [[Shader]] with a compatible [[Coat]]
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Material extends FudgeCore.Mutable {
        constructor(_name, _shader, _coat) {
            super();
            this.idResource = undefined;
            this.name = _name;
            this.shaderType = _shader;
            if (_shader) {
                if (_coat)
                    this.setCoat(_coat);
                else
                    this.setCoat(this.createCoatMatchingShader());
            }
            FudgeCore.ResourceManager.register(this);
        }
        /**
         * Creates a new [[Coat]] instance that is valid for the [[Shader]] referenced by this material
         */
        createCoatMatchingShader() {
            let coat = new (this.shaderType.getCoat())();
            return coat;
        }
        /**
         * Makes this material reference the given [[Coat]] if it is compatible with the referenced [[Shader]]
         * @param _coat
         */
        setCoat(_coat) {
            if (_coat.constructor != this.shaderType.getCoat())
                throw (new Error("Shader and coat don't match"));
            this.coat = _coat;
        }
        /**
         * Returns the currently referenced [[Coat]] instance
         */
        getCoat() {
            return this.coat;
        }
        /**
         * Changes the materials reference to the given [[Shader]], creates and references a new [[Coat]] instance
         * and mutates the new coat to preserve matching properties.
         * @param _shaderType
         */
        setShader(_shaderType) {
            this.shaderType = _shaderType;
            let coat = this.createCoatMatchingShader();
            coat.mutate(this.coat.getMutator());
            this.setCoat(coat);
        }
        /**
         * Returns the [[Shader]] referenced by this material
         */
        getShader() {
            return this.shaderType;
        }
        //#region Transfer
        // TODO: this type of serialization was implemented for implicit Material create. Check if obsolete when only one material class exists and/or materials are stored separately
        serialize() {
            let serialization = {
                name: this.name,
                idResource: this.idResource,
                shader: this.shaderType.name,
                coat: FudgeCore.Serializer.serialize(this.coat)
            };
            return serialization;
        }
        deserialize(_serialization) {
            this.name = _serialization.name;
            this.idResource = _serialization.idResource;
            // TODO: provide for shaders in the users namespace. See Serializer fullpath etc.
            // tslint:disable-next-line: no-any
            this.shaderType = FudgeCore[_serialization.shader];
            let coat = FudgeCore.Serializer.deserialize(_serialization.coat);
            this.setCoat(coat);
            return this;
        }
        reduceMutator(_mutator) {
            //
        }
    }
    FudgeCore.Material = Material;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Static class handling the resources used with the current FUDGE-instance.
     * Keeps a list of the resources and generates ids to retrieve them.
     * Resources are objects referenced multiple times but supposed to be stored only once
     */
    class ResourceManager {
        /**
         * Generates an id for the resources and registers it with the list of resources
         * @param _resource
         */
        static register(_resource) {
            if (!_resource.idResource)
                _resource.idResource = ResourceManager.generateId(_resource);
            ResourceManager.resources[_resource.idResource] = _resource;
        }
        /**
         * Generate a user readable and unique id using the type of the resource, the date and random numbers
         * @param _resource
         */
        static generateId(_resource) {
            // TODO: build id and integrate info from resource, not just date
            let idResource;
            do
                idResource = _resource.constructor.name + "|" + new Date().toISOString() + "|" + Math.random().toPrecision(5).substr(2, 5);
            while (ResourceManager.resources[idResource]);
            return idResource;
        }
        /**
         * Tests, if an object is a [[SerializableResource]]
         * @param _object The object to examine
         */
        static isResource(_object) {
            return (Reflect.has(_object, "idResource"));
        }
        /**
         * Retrieves the resource stored with the given id
         * @param _idResource
         */
        static get(_idResource) {
            let resource = ResourceManager.resources[_idResource];
            if (!resource) {
                let serialization = ResourceManager.serialization[_idResource];
                if (!serialization) {
                    FudgeCore.Debug.error("Resource not found", _idResource);
                    return null;
                }
                resource = ResourceManager.deserializeResource(serialization);
            }
            return resource;
        }
        /**
         * Creates and registers a resource from a [[Node]], copying the complete graph starting with it
         * @param _node A node to create the resource from
         * @param _replaceWithInstance if true (default), the node used as origin is replaced by a [[NodeResourceInstance]] of the [[NodeResource]] created
         */
        static registerNodeAsResource(_node, _replaceWithInstance = true) {
            let serialization = _node.serialize();
            let nodeResource = new FudgeCore.NodeResource("NodeResource");
            nodeResource.deserialize(serialization);
            ResourceManager.register(nodeResource);
            if (_replaceWithInstance && _node.getParent()) {
                let instance = new FudgeCore.NodeResourceInstance(nodeResource);
                _node.getParent().replaceChild(_node, instance);
            }
            return nodeResource;
        }
        /**
         * Serialize all resources
         */
        static serialize() {
            let serialization = {};
            for (let idResource in ResourceManager.resources) {
                let resource = ResourceManager.resources[idResource];
                if (idResource != resource.idResource)
                    FudgeCore.Debug.error("Resource-id mismatch", resource);
                serialization[idResource] = FudgeCore.Serializer.serialize(resource);
            }
            return serialization;
        }
        /**
         * Create resources from a serialization, deleting all resources previously registered
         * @param _serialization
         */
        static deserialize(_serialization) {
            ResourceManager.serialization = _serialization;
            ResourceManager.resources = {};
            for (let idResource in _serialization) {
                let serialization = _serialization[idResource];
                let resource = ResourceManager.deserializeResource(serialization);
                if (resource)
                    ResourceManager.resources[idResource] = resource;
            }
            return ResourceManager.resources;
        }
        static deserializeResource(_serialization) {
            return FudgeCore.Serializer.deserialize(_serialization);
        }
    }
    ResourceManager.resources = {};
    ResourceManager.serialization = null;
    FudgeCore.ResourceManager = ResourceManager;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Controls the rendering of a graph, using the given [[ComponentCamera]],
     * and the propagation of the rendered image from the offscreen renderbuffer to the target canvas
     * through a series of [[Framing]] objects. The stages involved are in order of rendering
     * [[RenderManager]].viewport -> [[Viewport]].source -> [[Viewport]].destination -> DOM-Canvas -> Client(CSS)
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Viewport extends FudgeCore.EventTarget∆í {
        constructor() {
            super(...arguments);
            this.name = "Viewport"; // The name to call this viewport by.
            this.camera = null; // The camera representing the view parameters to render the graph.
            // TODO: verify if client to canvas should be in Viewport or somewhere else (Window, Container?)
            // Multiple viewports using the same canvas shouldn't differ here...
            // different framing methods can be used, this is the default
            this.frameClientToCanvas = new FudgeCore.FramingScaled();
            this.frameCanvasToDestination = new FudgeCore.FramingComplex();
            this.frameDestinationToSource = new FudgeCore.FramingScaled();
            this.frameSourceToRender = new FudgeCore.FramingScaled();
            this.adjustingFrames = true;
            this.adjustingCamera = true;
            this.graph = null; // The first node in the graph that will be rendered.
            this.crc2 = null;
            this.canvas = null;
            this.pickBuffers = [];
            /**
             * Handle drag-drop events and dispatch to viewport as FUDGE-Event
             */
            this.hndDragDropEvent = (_event) => {
                let _dragevent = _event;
                switch (_dragevent.type) {
                    case "dragover":
                    case "drop":
                        _dragevent.preventDefault();
                        _dragevent.dataTransfer.effectAllowed = "none";
                        break;
                    case "dragstart":
                        // just dummy data,  valid data should be set in handler registered by the user
                        _dragevent.dataTransfer.setData("text", "Hallo");
                        // TODO: check if there is a better solution to hide the ghost image of the draggable object
                        _dragevent.dataTransfer.setDragImage(new Image(), 0, 0);
                        break;
                }
                let event = new FudgeCore.EventDragDrop("∆í" + _event.type, _dragevent);
                this.addCanvasPosition(event);
                this.dispatchEvent(event);
            };
            /**
             * Handle pointer events and dispatch to viewport as FUDGE-Event
             */
            this.hndPointerEvent = (_event) => {
                let event = new FudgeCore.EventPointer("∆í" + _event.type, _event);
                this.addCanvasPosition(event);
                this.dispatchEvent(event);
            };
            /**
             * Handle keyboard events and dispatch to viewport as FUDGE-Event, if the viewport has the focus
             */
            this.hndKeyboardEvent = (_event) => {
                if (!this.hasFocus)
                    return;
                let event = new FudgeCore.EventKeyboard("∆í" + _event.type, _event);
                this.dispatchEvent(event);
            };
            /**
             * Handle wheel event and dispatch to viewport as FUDGE-Event
             */
            this.hndWheelEvent = (_event) => {
                let event = new FudgeCore.EventWheel("∆í" + _event.type, _event);
                this.dispatchEvent(event);
            };
        }
        /**
         * Connects the viewport to the given canvas to render the given graph to using the given camera-component, and names the viewport as given.
         */
        initialize(_name, _graph, _camera, _canvas) {
            this.name = _name;
            this.camera = _camera;
            this.canvas = _canvas;
            this.crc2 = _canvas.getContext("2d");
            this.rectSource = FudgeCore.RenderManager.getCanvasRect();
            this.rectDestination = this.getClientRectangle();
            this.setGraph(_graph);
        }
        /**
         * Retrieve the 2D-context attached to the destination canvas
         */
        getContext() {
            return this.crc2;
        }
        /**
         * Retrieve the size of the destination canvas as a rectangle, x and y are always 0
         */
        getCanvasRectangle() {
            return FudgeCore.Rectangle.GET(0, 0, this.canvas.width, this.canvas.height);
        }
        /**
         * Retrieve the client rectangle the canvas is displayed and fit in, x and y are always 0
         */
        getClientRectangle() {
            // FUDGE doesn't care about where the client rect is, only about the size matters.
            // return Rectangle.GET(this.canvas.offsetLeft, this.canvas.offsetTop, this.canvas.clientWidth, this.canvas.clientHeight);
            return FudgeCore.Rectangle.GET(0, 0, this.canvas.clientWidth, this.canvas.clientHeight);
        }
        /**
         * Set the graph to be drawn in the viewport.
         */
        setGraph(_graph) {
            if (this.graph) {
                this.graph.removeEventListener("componentAdd" /* COMPONENT_ADD */, this.hndComponentEvent);
                this.graph.removeEventListener("componentRemove" /* COMPONENT_REMOVE */, this.hndComponentEvent);
            }
            this.graph = _graph;
            if (this.graph) {
                this.graph.addEventListener("componentAdd" /* COMPONENT_ADD */, this.hndComponentEvent);
                this.graph.addEventListener("componentRemove" /* COMPONENT_REMOVE */, this.hndComponentEvent);
            }
        }
        /**
         * Logs this viewports scenegraph to the console.
         */
        showSceneGraph() {
            // TODO: move to debug-class
            let output = "SceneGraph for this viewport:";
            output += "\n \n";
            output += this.graph.name;
            FudgeCore.Debug.log(output + "   => ROOTNODE" + this.createSceneGraph(this.graph));
        }
        // #region Drawing
        /**
         * Draw this viewport
         */
        draw() {
            FudgeCore.RenderManager.resetFrameBuffer();
            if (!this.camera.isActive)
                return;
            if (this.adjustingFrames)
                this.adjustFrames();
            if (this.adjustingCamera)
                this.adjustCamera();
            FudgeCore.RenderManager.clear(this.camera.backgroundColor);
            FudgeCore.RenderManager.drawGraph(this.graph, this.camera);
            this.crc2.imageSmoothingEnabled = false;
            this.crc2.drawImage(FudgeCore.RenderManager.getCanvas(), this.rectSource.x, this.rectSource.y, this.rectSource.width, this.rectSource.height, this.rectDestination.x, this.rectDestination.y, this.rectDestination.width, this.rectDestination.height);
        }
        /**
        * Draw this viewport for RayCast
        */
        createPickBuffers() {
            if (this.adjustingFrames)
                this.adjustFrames();
            if (this.adjustingCamera)
                this.adjustCamera();
            this.pickBuffers = FudgeCore.RenderManager.drawGraphForRayCast(this.graph, this.camera);
        }
        pickNodeAt(_pos) {
            // this.createPickBuffers();
            let hits = FudgeCore.RenderManager.pickNodeAt(_pos, this.pickBuffers, this.rectSource);
            hits.sort((a, b) => (b.zBuffer > 0) ? (a.zBuffer > 0) ? a.zBuffer - b.zBuffer : 1 : -1);
            return hits;
        }
        /**
         * Adjust all frames involved in the rendering process from the display area in the client up to the renderer canvas
         */
        adjustFrames() {
            // get the rectangle of the canvas area as displayed (consider css)
            let rectClient = this.getClientRectangle();
            // adjust the canvas size according to the given framing applied to client
            let rectCanvas = this.frameClientToCanvas.getRect(rectClient);
            this.canvas.width = rectCanvas.width;
            this.canvas.height = rectCanvas.height;
            // adjust the destination area on the target-canvas to render to by applying the framing to canvas
            this.rectDestination = this.frameCanvasToDestination.getRect(rectCanvas);
            // adjust the area on the source-canvas to render from by applying the framing to destination area
            this.rectSource = this.frameDestinationToSource.getRect(this.rectDestination);
            // having an offset source does make sense only when multiple viewports display parts of the same rendering. For now: shift it to 0,0
            this.rectSource.x = this.rectSource.y = 0;
            // still, a partial image of the rendering may be retrieved by moving and resizing the render viewport
            let rectRender = this.frameSourceToRender.getRect(this.rectSource);
            FudgeCore.RenderManager.setViewportRectangle(rectRender);
            // no more transformation after this for now, offscreen canvas and render-viewport have the same size
            FudgeCore.RenderManager.setCanvasSize(rectRender.width, rectRender.height);
        }
        /**
         * Adjust the camera parameters to fit the rendering into the render vieport
         */
        adjustCamera() {
            let rect = FudgeCore.RenderManager.getViewportRectangle();
            this.camera.projectCentral(rect.width / rect.height, this.camera.getFieldOfView());
        }
        // #endregion
        //#region Points
        /**
         * Returns a point on the source-rectangle matching the given point on the client rectangle
         */
        pointClientToSource(_client) {
            let result = this.frameClientToCanvas.getPoint(_client, this.getClientRectangle());
            result = this.frameCanvasToDestination.getPoint(result, this.getCanvasRectangle());
            result = this.frameDestinationToSource.getPoint(result, this.rectSource);
            //TODO: when Source, Render and RenderViewport deviate, continue transformation 
            return result;
        }
        /**
         * Returns a point on the render-rectangle matching the given point on the source rectangle
         */
        pointSourceToRender(_source) {
            let projectionRectangle = this.camera.getProjectionRectangle();
            let point = this.frameSourceToRender.getPoint(_source, projectionRectangle);
            return point;
        }
        /**
         * Returns a point on the render-rectangle matching the given point on the client rectangle
         */
        pointClientToRender(_client) {
            let point = this.pointClientToSource(_client);
            point = this.pointSourceToRender(point);
            //TODO: when Render and RenderViewport deviate, continue transformation 
            return point;
        }
        /**
         * Returns a point in normed view-rectangle matching the given point on the client rectangle
         * The view-rectangle matches the client size in the hypothetical distance of 1 to the camera, its origin in the center and y-axis pointing up
         * TODO: examine, if this should be a camera-method. Current implementation is for central-projection
         */
        pointClientToProjection(_client) {
            let posRender = this.pointClientToRender(_client);
            let rectRender = this.frameSourceToRender.getRect(this.rectSource);
            let rectProjection = this.camera.getProjectionRectangle();
            let posProjection = new FudgeCore.Vector2(rectProjection.width * posRender.x / rectRender.width, rectProjection.height * posRender.y / rectRender.height);
            posProjection.subtract(new FudgeCore.Vector2(rectProjection.width / 2, rectProjection.height / 2));
            posProjection.y *= -1;
            return posProjection;
        }
        /**
         * Returns a point in the client rectangle matching the given point in normed clipspace rectangle,
         * which stretches from -1 to 1 in both dimensions, y pointing up
         */
        pointClipToClient(_normed) {
            // let rectClient: Rectangle = this.getClientRectangle();
            // let result: Vector2 = Vector2.ONE(0.5);
            // result.x *= (_normed.x + 1) * rectClient.width;
            // result.y *= (1 - _normed.y) * rectClient.height;
            // result.add(rectClient.position);
            //TODO: check if rectDestination can be safely (and more perfomant) be used instead getClientRectangle
            let pointClient = FudgeCore.RenderManager.rectClip.pointToRect(_normed, this.rectDestination);
            return pointClient;
        }
        /**
         * Returns a point in the client rectangle matching the given point in normed clipspace rectangle,
         * which stretches from -1 to 1 in both dimensions, y pointing up
         */
        pointClipToCanvas(_normed) {
            let pointCanvas = FudgeCore.RenderManager.rectClip.pointToRect(_normed, this.getCanvasRectangle());
            return pointCanvas;
        }
        pointClientToScreen(_client) {
            let screen = new FudgeCore.Vector2(this.canvas.offsetLeft + _client.x, this.canvas.offsetTop + _client.y);
            return screen;
        }
        //#endregion
        // #region Events (passing from canvas to viewport and from there into graph)
        /**
         * Returns true if this viewport currently has focus and thus receives keyboard events
         */
        get hasFocus() {
            return (Viewport.focus == this);
        }
        /**
         * Switch the viewports focus on or off. Only one viewport in one FUDGE instance can have the focus, thus receiving keyboard events.
         * So a viewport currently having the focus will lose it, when another one receives it. The viewports fire [[Event]]s accordingly.
         *
         * @param _on
         */
        setFocus(_on) {
            if (_on) {
                if (Viewport.focus == this)
                    return;
                if (Viewport.focus)
                    Viewport.focus.dispatchEvent(new Event("focusout" /* FOCUS_OUT */));
                Viewport.focus = this;
                this.dispatchEvent(new Event("focusin" /* FOCUS_IN */));
            }
            else {
                if (Viewport.focus != this)
                    return;
                this.dispatchEvent(new Event("focusout" /* FOCUS_OUT */));
                Viewport.focus = null;
            }
        }
        /**
         * De- / Activates the given pointer event to be propagated into the viewport as FUDGE-Event
         * @param _type
         * @param _on
         */
        activatePointerEvent(_type, _on) {
            this.activateEvent(this.canvas, _type, this.hndPointerEvent, _on);
        }
        /**
         * De- / Activates the given keyboard event to be propagated into the viewport as FUDGE-Event
         * @param _type
         * @param _on
         */
        activateKeyboardEvent(_type, _on) {
            this.activateEvent(this.canvas.ownerDocument, _type, this.hndKeyboardEvent, _on);
        }
        /**
         * De- / Activates the given drag-drop event to be propagated into the viewport as FUDGE-Event
         * @param _type
         * @param _on
         */
        activateDragDropEvent(_type, _on) {
            if (_type == "\u0192dragstart" /* START */)
                this.canvas.draggable = _on;
            this.activateEvent(this.canvas, _type, this.hndDragDropEvent, _on);
        }
        /**
         * De- / Activates the wheel event to be propagated into the viewport as FUDGE-Event
         * @param _type
         * @param _on
         */
        activateWheelEvent(_type, _on) {
            this.activateEvent(this.canvas, _type, this.hndWheelEvent, _on);
        }
        /**
         * Add position of the pointer mapped to canvas-coordinates as canvasX, canvasY to the event
         * @param event
         */
        addCanvasPosition(event) {
            event.canvasX = this.canvas.width * event.pointerX / event.clientRect.width;
            event.canvasY = this.canvas.height * event.pointerY / event.clientRect.height;
        }
        activateEvent(_target, _type, _handler, _on) {
            _type = _type.slice(1); // chip the ∆ílorentin
            if (_on)
                _target.addEventListener(_type, _handler);
            else
                _target.removeEventListener(_type, _handler);
        }
        hndComponentEvent(_event) {
            FudgeCore.Debug.fudge(_event);
        }
        // #endregion
        /**
         * Creates an outputstring as visual representation of this viewports scenegraph. Called for the passed node and recursive for all its children.
         * @param _fudgeNode The node to create a scenegraphentry for.
         */
        createSceneGraph(_fudgeNode) {
            // TODO: move to debug-class
            let output = "";
            for (let name in _fudgeNode.getChildren()) {
                let child = _fudgeNode.getChildren()[name];
                output += "\n";
                let current = child;
                if (current.getParent() && current.getParent().getParent())
                    output += "|";
                while (current.getParent() && current.getParent().getParent()) {
                    output += "   ";
                    current = current.getParent();
                }
                output += "'--";
                output += child.name;
                output += this.createSceneGraph(child);
            }
            return output;
        }
    }
    FudgeCore.Viewport = Viewport;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class EventDragDrop extends DragEvent {
        constructor(type, _event) {
            super(type, _event);
            let target = _event.target;
            this.clientRect = target.getClientRects()[0];
            this.pointerX = _event.clientX - this.clientRect.left;
            this.pointerY = _event.clientY - this.clientRect.top;
        }
    }
    FudgeCore.EventDragDrop = EventDragDrop;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class EventKeyboard extends KeyboardEvent {
        constructor(type, _event) {
            super(type, _event);
        }
    }
    FudgeCore.EventKeyboard = EventKeyboard;
    /**
     * The codes sent from a standard english keyboard layout
     */
    let KEYBOARD_CODE;
    (function (KEYBOARD_CODE) {
        KEYBOARD_CODE["A"] = "KeyA";
        KEYBOARD_CODE["B"] = "KeyB";
        KEYBOARD_CODE["C"] = "KeyC";
        KEYBOARD_CODE["D"] = "KeyD";
        KEYBOARD_CODE["E"] = "KeyE";
        KEYBOARD_CODE["F"] = "KeyF";
        KEYBOARD_CODE["G"] = "KeyG";
        KEYBOARD_CODE["H"] = "KeyH";
        KEYBOARD_CODE["I"] = "KeyI";
        KEYBOARD_CODE["J"] = "KeyJ";
        KEYBOARD_CODE["K"] = "KeyK";
        KEYBOARD_CODE["L"] = "KeyL";
        KEYBOARD_CODE["M"] = "KeyM";
        KEYBOARD_CODE["N"] = "KeyN";
        KEYBOARD_CODE["O"] = "KeyO";
        KEYBOARD_CODE["P"] = "KeyP";
        KEYBOARD_CODE["Q"] = "KeyQ";
        KEYBOARD_CODE["R"] = "KeyR";
        KEYBOARD_CODE["S"] = "KeyS";
        KEYBOARD_CODE["T"] = "KeyT";
        KEYBOARD_CODE["U"] = "KeyU";
        KEYBOARD_CODE["V"] = "KeyV";
        KEYBOARD_CODE["W"] = "KeyW";
        KEYBOARD_CODE["X"] = "KeyX";
        KEYBOARD_CODE["Y"] = "KeyY";
        KEYBOARD_CODE["Z"] = "KeyZ";
        KEYBOARD_CODE["ESC"] = "Escape";
        KEYBOARD_CODE["ZERO"] = "Digit0";
        KEYBOARD_CODE["ONE"] = "Digit1";
        KEYBOARD_CODE["TWO"] = "Digit2";
        KEYBOARD_CODE["THREE"] = "Digit3";
        KEYBOARD_CODE["FOUR"] = "Digit4";
        KEYBOARD_CODE["FIVE"] = "Digit5";
        KEYBOARD_CODE["SIX"] = "Digit6";
        KEYBOARD_CODE["SEVEN"] = "Digit7";
        KEYBOARD_CODE["EIGHT"] = "Digit8";
        KEYBOARD_CODE["NINE"] = "Digit9";
        KEYBOARD_CODE["MINUS"] = "Minus";
        KEYBOARD_CODE["EQUAL"] = "Equal";
        KEYBOARD_CODE["BACKSPACE"] = "Backspace";
        KEYBOARD_CODE["TABULATOR"] = "Tab";
        KEYBOARD_CODE["BRACKET_LEFT"] = "BracketLeft";
        KEYBOARD_CODE["BRACKET_RIGHT"] = "BracketRight";
        KEYBOARD_CODE["ENTER"] = "Enter";
        KEYBOARD_CODE["CTRL_LEFT"] = "ControlLeft";
        KEYBOARD_CODE["SEMICOLON"] = "Semicolon";
        KEYBOARD_CODE["QUOTE"] = "Quote";
        KEYBOARD_CODE["BACK_QUOTE"] = "Backquote";
        KEYBOARD_CODE["SHIFT_LEFT"] = "ShiftLeft";
        KEYBOARD_CODE["BACKSLASH"] = "Backslash";
        KEYBOARD_CODE["COMMA"] = "Comma";
        KEYBOARD_CODE["PERIOD"] = "Period";
        KEYBOARD_CODE["SLASH"] = "Slash";
        KEYBOARD_CODE["SHIFT_RIGHT"] = "ShiftRight";
        KEYBOARD_CODE["NUMPAD_MULTIPLY"] = "NumpadMultiply";
        KEYBOARD_CODE["ALT_LEFT"] = "AltLeft";
        KEYBOARD_CODE["SPACE"] = "Space";
        KEYBOARD_CODE["CAPS_LOCK"] = "CapsLock";
        KEYBOARD_CODE["F1"] = "F1";
        KEYBOARD_CODE["F2"] = "F2";
        KEYBOARD_CODE["F3"] = "F3";
        KEYBOARD_CODE["F4"] = "F4";
        KEYBOARD_CODE["F5"] = "F5";
        KEYBOARD_CODE["F6"] = "F6";
        KEYBOARD_CODE["F7"] = "F7";
        KEYBOARD_CODE["F8"] = "F8";
        KEYBOARD_CODE["F9"] = "F9";
        KEYBOARD_CODE["F10"] = "F10";
        KEYBOARD_CODE["PAUSE"] = "Pause";
        KEYBOARD_CODE["SCROLL_LOCK"] = "ScrollLock";
        KEYBOARD_CODE["NUMPAD7"] = "Numpad7";
        KEYBOARD_CODE["NUMPAD8"] = "Numpad8";
        KEYBOARD_CODE["NUMPAD9"] = "Numpad9";
        KEYBOARD_CODE["NUMPAD_SUBTRACT"] = "NumpadSubtract";
        KEYBOARD_CODE["NUMPAD4"] = "Numpad4";
        KEYBOARD_CODE["NUMPAD5"] = "Numpad5";
        KEYBOARD_CODE["NUMPAD6"] = "Numpad6";
        KEYBOARD_CODE["NUMPAD_ADD"] = "NumpadAdd";
        KEYBOARD_CODE["NUMPAD1"] = "Numpad1";
        KEYBOARD_CODE["NUMPAD2"] = "Numpad2";
        KEYBOARD_CODE["NUMPAD3"] = "Numpad3";
        KEYBOARD_CODE["NUMPAD0"] = "Numpad0";
        KEYBOARD_CODE["NUMPAD_DECIMAL"] = "NumpadDecimal";
        KEYBOARD_CODE["PRINT_SCREEN"] = "PrintScreen";
        KEYBOARD_CODE["INTL_BACK_SLASH"] = "IntlBackSlash";
        KEYBOARD_CODE["F11"] = "F11";
        KEYBOARD_CODE["F12"] = "F12";
        KEYBOARD_CODE["NUMPAD_EQUAL"] = "NumpadEqual";
        KEYBOARD_CODE["F13"] = "F13";
        KEYBOARD_CODE["F14"] = "F14";
        KEYBOARD_CODE["F15"] = "F15";
        KEYBOARD_CODE["F16"] = "F16";
        KEYBOARD_CODE["F17"] = "F17";
        KEYBOARD_CODE["F18"] = "F18";
        KEYBOARD_CODE["F19"] = "F19";
        KEYBOARD_CODE["F20"] = "F20";
        KEYBOARD_CODE["F21"] = "F21";
        KEYBOARD_CODE["F22"] = "F22";
        KEYBOARD_CODE["F23"] = "F23";
        KEYBOARD_CODE["F24"] = "F24";
        KEYBOARD_CODE["KANA_MODE"] = "KanaMode";
        KEYBOARD_CODE["LANG2"] = "Lang2";
        KEYBOARD_CODE["LANG1"] = "Lang1";
        KEYBOARD_CODE["INTL_RO"] = "IntlRo";
        KEYBOARD_CODE["CONVERT"] = "Convert";
        KEYBOARD_CODE["NON_CONVERT"] = "NonConvert";
        KEYBOARD_CODE["INTL_YEN"] = "IntlYen";
        KEYBOARD_CODE["NUMPAD_COMMA"] = "NumpadComma";
        KEYBOARD_CODE["UNDO"] = "Undo";
        KEYBOARD_CODE["PASTE"] = "Paste";
        KEYBOARD_CODE["MEDIA_TRACK_PREVIOUS"] = "MediaTrackPrevious";
        KEYBOARD_CODE["CUT"] = "Cut";
        KEYBOARD_CODE["COPY"] = "Copy";
        KEYBOARD_CODE["MEDIA_TRACK_NEXT"] = "MediaTrackNext";
        KEYBOARD_CODE["NUMPAD_ENTER"] = "NumpadEnter";
        KEYBOARD_CODE["CTRL_RIGHT"] = "ControlRight";
        KEYBOARD_CODE["AUDIO_VOLUME_MUTE"] = "AudioVolumeMute";
        KEYBOARD_CODE["LAUNCH_APP2"] = "LaunchApp2";
        KEYBOARD_CODE["MEDIA_PLAY_PAUSE"] = "MediaPlayPause";
        KEYBOARD_CODE["MEDIA_STOP"] = "MediaStop";
        KEYBOARD_CODE["EJECT"] = "Eject";
        KEYBOARD_CODE["AUDIO_VOLUME_DOWN"] = "AudioVolumeDown";
        KEYBOARD_CODE["VOLUME_DOWN"] = "VolumeDown";
        KEYBOARD_CODE["AUDIO_VOLUME_UP"] = "AudioVolumeUp";
        KEYBOARD_CODE["VOLUME_UP"] = "VolumeUp";
        KEYBOARD_CODE["BROWSER_HOME"] = "BrowserHome";
        KEYBOARD_CODE["NUMPAD_DIVIDE"] = "NumpadDivide";
        KEYBOARD_CODE["ALT_RIGHT"] = "AltRight";
        KEYBOARD_CODE["HELP"] = "Help";
        KEYBOARD_CODE["NUM_LOCK"] = "NumLock";
        KEYBOARD_CODE["HOME"] = "Home";
        KEYBOARD_CODE["ARROW_UP"] = "ArrowUp";
        KEYBOARD_CODE["ARROW_RIGHT"] = "ArrowRight";
        KEYBOARD_CODE["ARROW_DOWN"] = "ArrowDown";
        KEYBOARD_CODE["ARROW_LEFT"] = "ArrowLeft";
        KEYBOARD_CODE["END"] = "End";
        KEYBOARD_CODE["PAGE_UP"] = "PageUp";
        KEYBOARD_CODE["PAGE_DOWN"] = "PageDown";
        KEYBOARD_CODE["INSERT"] = "Insert";
        KEYBOARD_CODE["DELETE"] = "Delete";
        KEYBOARD_CODE["META_LEFT"] = "Meta_Left";
        KEYBOARD_CODE["OS_LEFT"] = "OSLeft";
        KEYBOARD_CODE["META_RIGHT"] = "MetaRight";
        KEYBOARD_CODE["OS_RIGHT"] = "OSRight";
        KEYBOARD_CODE["CONTEXT_MENU"] = "ContextMenu";
        KEYBOARD_CODE["POWER"] = "Power";
        KEYBOARD_CODE["BROWSER_SEARCH"] = "BrowserSearch";
        KEYBOARD_CODE["BROWSER_FAVORITES"] = "BrowserFavorites";
        KEYBOARD_CODE["BROWSER_REFRESH"] = "BrowserRefresh";
        KEYBOARD_CODE["BROWSER_STOP"] = "BrowserStop";
        KEYBOARD_CODE["BROWSER_FORWARD"] = "BrowserForward";
        KEYBOARD_CODE["BROWSER_BACK"] = "BrowserBack";
        KEYBOARD_CODE["LAUNCH_APP1"] = "LaunchApp1";
        KEYBOARD_CODE["LAUNCH_MAIL"] = "LaunchMail";
        KEYBOARD_CODE["LAUNCH_MEDIA_PLAYER"] = "LaunchMediaPlayer";
        //mac brings this buttton
        KEYBOARD_CODE["FN"] = "Fn";
        //Linux brings these
        KEYBOARD_CODE["AGAIN"] = "Again";
        KEYBOARD_CODE["PROPS"] = "Props";
        KEYBOARD_CODE["SELECT"] = "Select";
        KEYBOARD_CODE["OPEN"] = "Open";
        KEYBOARD_CODE["FIND"] = "Find";
        KEYBOARD_CODE["WAKE_UP"] = "WakeUp";
        KEYBOARD_CODE["NUMPAD_PARENT_LEFT"] = "NumpadParentLeft";
        KEYBOARD_CODE["NUMPAD_PARENT_RIGHT"] = "NumpadParentRight";
        //android
        KEYBOARD_CODE["SLEEP"] = "Sleep";
    })(KEYBOARD_CODE = FudgeCore.KEYBOARD_CODE || (FudgeCore.KEYBOARD_CODE = {}));
    /*
    Firefox can't make use of those buttons and Combinations:
    SINGELE_BUTTONS:
     Druck,
    COMBINATIONS:
     Shift + F10, Shift + Numpad5,
     CTRL + q, CTRL + F4,
     ALT + F1, ALT + F2, ALT + F3, ALT + F7, ALT + F8, ALT + F10
    Opera won't do good with these Buttons and combinations:
    SINGLE_BUTTONS:
     Float32Array, F11, ALT,
    COMBINATIONS:
     CTRL + q, CTRL + t, CTRL + h, CTRL + g, CTRL + n, CTRL + f
     ALT + F1, ALT + F2, ALT + F4, ALT + F5, ALT + F6, ALT + F7, ALT + F8, ALT + F10
     */
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class EventPointer extends PointerEvent {
        constructor(type, _event) {
            super(type, _event);
            let target = _event.target;
            this.clientRect = target.getClientRects()[0];
            this.pointerX = _event.clientX - this.clientRect.left;
            this.pointerY = _event.clientY - this.clientRect.top;
        }
    }
    FudgeCore.EventPointer = EventPointer;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class EventTimer {
        constructor(_timer, ..._arguments) {
            this.type = "\u0192lapse" /* CALL */;
            this.firstCall = true;
            this.lastCall = false;
            this.target = _timer;
            this.arguments = _arguments;
            this.firstCall = true;
        }
    }
    FudgeCore.EventTimer = EventTimer;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class EventWheel extends WheelEvent {
        constructor(type, _event) {
            super(type, _event);
        }
    }
    FudgeCore.EventWheel = EventWheel;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Baseclass for different kinds of lights.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Light extends FudgeCore.Mutable {
        constructor(_color = new FudgeCore.Color(1, 1, 1, 1)) {
            super();
            this.color = _color;
        }
        getType() {
            return this.constructor;
        }
        reduceMutator() { }
    }
    FudgeCore.Light = Light;
    /**
     * Ambient light, coming from all directions, illuminating everything with its color independent of position and orientation (like a foggy day or in the shades)
     * ```plaintext
     * ~ ~ ~
     *  ~ ~ ~
     * ```
     */
    class LightAmbient extends Light {
        constructor(_color = new FudgeCore.Color(1, 1, 1, 1)) {
            super(_color);
        }
    }
    FudgeCore.LightAmbient = LightAmbient;
    /**
     * Directional light, illuminating everything from a specified direction with its color (like standing in bright sunlight)
     * ```plaintext
     * --->
     * --->
     * --->
     * ```
     */
    class LightDirectional extends Light {
        constructor(_color = new FudgeCore.Color(1, 1, 1, 1)) {
            super(_color);
        }
    }
    FudgeCore.LightDirectional = LightDirectional;
    /**
     * Omnidirectional light emitting from its position, illuminating objects depending on their position and distance with its color (like a colored light bulb)
     * ```plaintext
     *         .\|/.
     *        -- o --
     *         ¬¥/|\`
     * ```
     */
    class LightPoint extends Light {
        constructor() {
            super(...arguments);
            this.range = 10;
        }
    }
    FudgeCore.LightPoint = LightPoint;
    /**
     * Spot light emitting within a specified angle from its position, illuminating objects depending on their position and distance with its color
     * ```plaintext
     *          o
     *         /|\
     *        / | \
     * ```
     */
    class LightSpot extends Light {
    }
    FudgeCore.LightSpot = LightSpot;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Framing describes how to map a rectangle into a given frame
     * and how points in the frame correspond to points in the resulting rectangle and vice versa
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Framing
     */
    class Framing extends FudgeCore.Mutable {
        reduceMutator(_mutator) { }
    }
    FudgeCore.Framing = Framing;
    /**
     * The resulting rectangle has a fixed width and height and display should scale to fit the frame
     * Points are scaled in the same ratio
     */
    class FramingFixed extends Framing {
        constructor(_width = 300, _height = 150) {
            super();
            this.width = 300;
            this.height = 150;
            this.setSize(_width, _height);
        }
        setSize(_width, _height) {
            this.width = _width;
            this.height = _height;
        }
        getPoint(_pointInFrame, _rectFrame) {
            let result = new FudgeCore.Vector2(this.width * (_pointInFrame.x - _rectFrame.x) / _rectFrame.width, this.height * (_pointInFrame.y - _rectFrame.y) / _rectFrame.height);
            return result;
        }
        getPointInverse(_point, _rect) {
            let result = new FudgeCore.Vector2(_point.x * _rect.width / this.width + _rect.x, _point.y * _rect.height / this.height + _rect.y);
            return result;
        }
        getRect(_rectFrame) {
            return FudgeCore.Rectangle.GET(0, 0, this.width, this.height);
        }
    }
    FudgeCore.FramingFixed = FramingFixed;
    /**
     * Width and height of the resulting rectangle are fractions of those of the frame, scaled by normed values normWidth and normHeight.
     * Display should scale to fit the frame and points are scaled in the same ratio
     */
    class FramingScaled extends Framing {
        constructor() {
            super(...arguments);
            this.normWidth = 1.0;
            this.normHeight = 1.0;
        }
        setScale(_normWidth, _normHeight) {
            this.normWidth = _normWidth;
            this.normHeight = _normHeight;
        }
        getPoint(_pointInFrame, _rectFrame) {
            let result = new FudgeCore.Vector2(this.normWidth * (_pointInFrame.x - _rectFrame.x), this.normHeight * (_pointInFrame.y - _rectFrame.y));
            return result;
        }
        getPointInverse(_point, _rect) {
            let result = new FudgeCore.Vector2(_point.x / this.normWidth + _rect.x, _point.y / this.normHeight + _rect.y);
            return result;
        }
        getRect(_rectFrame) {
            return FudgeCore.Rectangle.GET(0, 0, this.normWidth * _rectFrame.width, this.normHeight * _rectFrame.height);
        }
    }
    FudgeCore.FramingScaled = FramingScaled;
    /**
     * The resulting rectangle fits into a margin given as fractions of the size of the frame given by normAnchor
     * plus an absolute padding given by pixelBorder. Display should fit into this.
     */
    class FramingComplex extends Framing {
        constructor() {
            super(...arguments);
            this.margin = { left: 0, top: 0, right: 0, bottom: 0 };
            this.padding = { left: 0, top: 0, right: 0, bottom: 0 };
        }
        getPoint(_pointInFrame, _rectFrame) {
            let result = new FudgeCore.Vector2(_pointInFrame.x - this.padding.left - this.margin.left * _rectFrame.width, _pointInFrame.y - this.padding.top - this.margin.top * _rectFrame.height);
            return result;
        }
        getPointInverse(_point, _rect) {
            let result = new FudgeCore.Vector2(_point.x + this.padding.left + this.margin.left * _rect.width, _point.y + this.padding.top + this.margin.top * _rect.height);
            return result;
        }
        getRect(_rectFrame) {
            if (!_rectFrame)
                return null;
            let minX = _rectFrame.x + this.margin.left * _rectFrame.width + this.padding.left;
            let minY = _rectFrame.y + this.margin.top * _rectFrame.height + this.padding.top;
            let maxX = _rectFrame.x + (1 - this.margin.right) * _rectFrame.width - this.padding.right;
            let maxY = _rectFrame.y + (1 - this.margin.bottom) * _rectFrame.height - this.padding.bottom;
            return FudgeCore.Rectangle.GET(minX, minY, maxX - minX, maxY - minY);
        }
        getMutator() {
            return { margin: this.margin, padding: this.padding };
        }
    }
    FudgeCore.FramingComplex = FramingComplex;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Simple class for 3x3 matrix operations
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2020
     */
    class Matrix3x3 extends FudgeCore.Mutable {
        constructor() {
            super();
            this.data = new Float32Array(3); // The data of the matrix.
            this.mutator = null; // prepared for optimization, keep mutator to reduce redundant calculation and for comparison. Set to null when data changes!
            this.data = new Float32Array([
                1, 0, 0,
                0, 1, 0,
                0, 0, 1
            ]);
            this.resetCache();
        }
        /**
         * - get: a copy of the calculated translation vector
         * - set: effect the matrix ignoring its rotation and scaling
         */
        get translation() {
            if (!this.vectors.translation)
                this.vectors.translation = new FudgeCore.Vector2(this.data[6], this.data[7]);
            return this.vectors.translation.copy;
        }
        set translation(_translation) {
            this.data.set(_translation.get(), 12);
            // no full cache reset required
            this.vectors.translation = _translation;
            this.mutator = null;
        }
        /**
         * - get: a copy of the calculated rotation vector
         * - set: effect the matrix
         */
        get rotation() {
            if (!this.vectors.rotation)
                this.vectors.rotation = this.getEulerAngles();
            return this.vectors.rotation;
        }
        set rotation(_rotation) {
            this.mutate({ "rotation": _rotation });
            this.resetCache();
        }
        /**
         * - get: a copy of the calculated scale vector
         * - set: effect the matrix
         */
        get scaling() {
            if (!this.vectors.scaling)
                this.vectors.scaling = new FudgeCore.Vector2(Math.hypot(this.data[0], this.data[1]), Math.hypot(this.data[3], this.data[4]));
            return this.vectors.scaling.copy;
        }
        set scaling(_scaling) {
            this.mutate({ "scaling": _scaling });
            this.resetCache();
        }
        //TODO: figure out what this is used for
        static PROJECTION(_width, _height) {
            let matrix = new Matrix3x3;
            matrix.data.set([
                2 / _width, 0, 0,
                0, -2 / _height, 0,
                -1, 1, 1
            ]);
            return matrix;
        }
        static IDENTITY() {
            const result = FudgeCore.Recycler.get(Matrix3x3);
            result.data.set([
                1, 0, 0,
                0, 1, 0,
                0, 0, 1
            ]);
            return result;
        }
        /**
         * Returns a matrix that translates coordinates along the x-, y- and z-axis according to the given vector.
         */
        static TRANSLATION(_translate) {
            const matrix = FudgeCore.Recycler.get(Matrix3x3);
            matrix.data.set([
                1, 0, 0,
                0, 1, 0,
                _translate.x, _translate.y, 1
            ]);
            return matrix;
        }
        /**
         * Returns a matrix that rotates coordinates on the z-axis when multiplied by.
         * @param _angleInDegrees The value of the rotation.
         */
        static ROTATION(_angleInDegrees) {
            // const matrix: Matrix3x3 = new Matrix3x3;
            const matrix = FudgeCore.Recycler.get(Matrix3x3);
            let angleInRadians = _angleInDegrees * Math.PI / 180;
            let sin = Math.sin(angleInRadians);
            let cos = Math.cos(angleInRadians);
            matrix.data.set([
                cos, sin, 0,
                -sin, cos, 0,
                0, 0, 1
            ]);
            return matrix;
        }
        /**
         * Returns a matrix that scales coordinates along the x-, y- and z-axis according to the given vector
         */
        static SCALING(_scalar) {
            // const matrix: Matrix3x3 = new Matrix3x3;
            const matrix = FudgeCore.Recycler.get(Matrix3x3);
            matrix.data.set([
                _scalar.x, 0, 0,
                0, _scalar.y, 0,
                0, 0, 1
            ]);
            return matrix;
        }
        //#endregion
        static MULTIPLICATION(_a, _b) {
            let a00 = _a.data[0 * 3 + 0];
            let a01 = _a.data[0 * 3 + 1];
            let a02 = _a.data[0 * 3 + 2];
            let a10 = _a.data[1 * 3 + 0];
            let a11 = _a.data[1 * 3 + 1];
            let a12 = _a.data[1 * 3 + 2];
            let a20 = _a.data[2 * 3 + 0];
            let a21 = _a.data[2 * 3 + 1];
            let a22 = _a.data[2 * 3 + 2];
            let b00 = _b.data[0 * 3 + 0];
            let b01 = _b.data[0 * 3 + 1];
            let b02 = _b.data[0 * 3 + 2];
            let b10 = _b.data[1 * 3 + 0];
            let b11 = _b.data[1 * 3 + 1];
            let b12 = _b.data[1 * 3 + 2];
            let b20 = _b.data[2 * 3 + 0];
            let b21 = _b.data[2 * 3 + 1];
            let b22 = _b.data[2 * 3 + 2];
            let matrix = new Matrix3x3;
            matrix.data.set([
                b00 * a00 + b01 * a10 + b02 * a20,
                b00 * a01 + b01 * a11 + b02 * a21,
                b00 * a02 + b01 * a12 + b02 * a22,
                b10 * a00 + b11 * a10 + b12 * a20,
                b10 * a01 + b11 * a11 + b12 * a21,
                b10 * a02 + b11 * a12 + b12 * a22,
                b20 * a00 + b21 * a10 + b22 * a20,
                b20 * a01 + b21 * a11 + b22 * a21,
                b20 * a02 + b21 * a12 + b22 * a22
            ]);
            return matrix;
        }
        //#region Translation
        /**
         * Add a translation by the given vector to this matrix
         */
        translate(_by) {
            const matrix = Matrix3x3.MULTIPLICATION(this, Matrix3x3.TRANSLATION(_by));
            // TODO: possible optimization, translation may alter mutator instead of deleting it.
            this.set(matrix);
            FudgeCore.Recycler.store(matrix);
        }
        /**
         * Add a translation along the x-Axis by the given amount to this matrix
         */
        translateX(_x) {
            this.data[6] += _x;
            this.mutator = null;
            this.vectors.translation = null;
        }
        /**
         * Add a translation along the y-Axis by the given amount to this matrix
         */
        translateY(_y) {
            this.data[7] += _y;
            this.mutator = null;
            this.vectors.translation = null;
        }
        //#endregion
        //#region Scaling
        /**
         * Add a scaling by the given vector to this matrix
         */
        scale(_by) {
            const matrix = Matrix3x3.MULTIPLICATION(this, Matrix3x3.SCALING(_by));
            this.set(matrix);
            FudgeCore.Recycler.store(matrix);
        }
        /**
         * Add a scaling along the x-Axis by the given amount to this matrix
         */
        scaleX(_by) {
            let vector = FudgeCore.Recycler.borrow(FudgeCore.Vector2);
            vector.set(_by, 1);
            this.scale(vector);
        }
        /**
         * Add a scaling along the y-Axis by the given amount to this matrix
         */
        scaleY(_by) {
            let vector = FudgeCore.Recycler.borrow(FudgeCore.Vector2);
            vector.set(1, _by);
            this.scale(vector);
        }
        //#endregion
        //#region Rotation
        /**
         * Adds a rotation around the z-Axis to this matrix
         */
        rotate(_angleInDegrees) {
            const matrix = Matrix3x3.MULTIPLICATION(this, Matrix3x3.ROTATION(_angleInDegrees));
            this.set(matrix);
            FudgeCore.Recycler.store(matrix);
        }
        //#endregion
        //#region Transformation
        /**
         * Multiply this matrix with the given matrix
         */
        multiply(_matrix) {
            this.set(Matrix3x3.MULTIPLICATION(this, _matrix));
            this.mutator = null;
        }
        //#endregion
        //#region Transfer
        /**
         * Calculates and returns the euler-angles representing the current rotation of this matrix
         */
        getEulerAngles() {
            let scaling = this.scaling;
            let s0 = this.data[0] / scaling.x;
            let s1 = this.data[1] / scaling.x;
            let s3 = this.data[3] / scaling.y;
            let s4 = this.data[4] / scaling.y;
            let xSkew = Math.atan2(-s3, s4);
            let ySkew = Math.atan2(s0, s1);
            let sy = Math.hypot(s0, s1); // probably 2. param should be this.data[4] / scaling.y
            let rotation;
            if (!(sy > 1e-6))
                rotation = ySkew;
            else
                rotation = xSkew;
            rotation *= 180 / Math.PI;
            return rotation;
        }
        /**
         * Sets the elements of this matrix to the values of the given matrix
         */
        set(_to) {
            // this.data = _to.get();
            this.data.set(_to.data);
            this.resetCache();
        }
        toString() {
            return `∆í.Matrix3x3(translation: ${this.translation.toString()}, rotation: ${this.rotation.toString()}, scaling: ${this.scaling.toString()}`;
        }
        /**
         * Return the elements of this matrix as a Float32Array
         */
        get() {
            return new Float32Array(this.data);
        }
        /**
         * Return a copy of this
         */
        get copy() {
            let copy = new Matrix3x3();
            copy.set(this);
            return copy;
        }
        serialize() {
            // TODO: save translation, rotation and scale as vectors for readability and manipulation
            let serialization = this.getMutator();
            return serialization;
        }
        deserialize(_serialization) {
            this.mutate(_serialization);
            return this;
        }
        getMutator() {
            if (this.mutator)
                return this.mutator;
            let mutator = {
                translation: this.translation.getMutator(),
                rotation: this.rotation,
                scaling: this.scaling.getMutator()
            };
            // cache mutator
            this.mutator = mutator;
            return mutator;
        }
        mutate(_mutator) {
            let oldTranslation = this.translation;
            let oldRotation = this.rotation;
            let oldScaling = this.scaling;
            let newTranslation = _mutator["translation"];
            let newRotation = _mutator["rotation"];
            let newScaling = _mutator["scaling"];
            let vectors = { translation: oldTranslation, rotation: oldRotation, scaling: oldScaling };
            if (newTranslation) {
                vectors.translation = new FudgeCore.Vector2(newTranslation.x != undefined ? newTranslation.x : oldTranslation.x, newTranslation.y != undefined ? newTranslation.y : oldTranslation.y);
            }
            vectors.rotation = (newRotation == undefined) ? oldRotation : newRotation;
            if (newScaling) {
                vectors.scaling = new FudgeCore.Vector2(newScaling.x != undefined ? newScaling.x : oldScaling.x, newScaling.y != undefined ? newScaling.y : oldScaling.y);
            }
            // TODO: possible performance optimization when only one or two components change, then use old matrix instead of IDENTITY and transform by differences/quotients
            let matrix = Matrix3x3.IDENTITY();
            if (vectors.translation)
                matrix.translate(vectors.translation);
            if (vectors.rotation) {
                matrix.rotate(vectors.rotation);
            }
            if (vectors.scaling)
                matrix.scale(vectors.scaling);
            this.set(matrix);
            this.vectors = vectors;
        }
        getMutatorAttributeTypes(_mutator) {
            let types = {};
            if (_mutator.translation)
                types.translation = "Vector2";
            if (_mutator.rotation)
                types.rotation = "number";
            if (_mutator.scaling)
                types.scaling = "Vector2";
            return types;
        }
        reduceMutator(_mutator) { }
        resetCache() {
            this.vectors = { translation: null, rotation: null, scaling: null };
            this.mutator = null;
        }
    }
    FudgeCore.Matrix3x3 = Matrix3x3;
    //#endregion
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Stores a 4x4 transformation matrix and provides operations for it.
     * ```plaintext
     * [ 0, 1, 2, 3 ] ‚Üê row vector x
     * [ 4, 5, 6, 7 ] ‚Üê row vector y
     * [ 8, 9,10,11 ] ‚Üê row vector z
     * [12,13,14,15 ] ‚Üê translation
     *            ‚Üë  homogeneous column
     * ```
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Matrix4x4 extends FudgeCore.Mutable {
        constructor() {
            super();
            this.data = new Float32Array(16); // The data of the matrix.
            this.mutator = null; // prepared for optimization, keep mutator to reduce redundant calculation and for comparison. Set to null when data changes!
            this.data.set([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]);
            this.resetCache();
        }
        /**
         * - get: a copy of the calculated translation vector
         * - set: effect the matrix ignoring its rotation and scaling
         */
        get translation() {
            if (!this.vectors.translation) {
                this.vectors.translation = FudgeCore.Recycler.get(FudgeCore.Vector3);
                this.vectors.translation.set(this.data[12], this.data[13], this.data[14]);
            }
            return this.vectors.translation.copy;
        }
        set translation(_translation) {
            this.data.set(_translation.get(), 12);
            // no full cache reset required
            this.vectors.translation = _translation.copy;
            this.mutator = null;
        }
        /**
         * - get: a copy of the calculated rotation vector
         * - set: effect the matrix
         */
        get rotation() {
            if (!this.vectors.rotation)
                this.vectors.rotation = this.getEulerAngles();
            return this.vectors.rotation.copy;
        }
        set rotation(_rotation) {
            this.mutate({ "rotation": _rotation });
            this.resetCache();
        }
        /**
         * - get: a copy of the calculated scale vector
         * - set: effect the matrix
         */
        get scaling() {
            if (!this.vectors.scaling) {
                this.vectors.scaling = FudgeCore.Recycler.get(FudgeCore.Vector3);
                this.vectors.scaling.set(Math.hypot(this.data[0], this.data[1], this.data[2]), Math.hypot(this.data[4], this.data[5], this.data[6]), Math.hypot(this.data[8], this.data[9], this.data[10]));
            }
            return this.vectors.scaling.copy;
        }
        set scaling(_scaling) {
            this.mutate({ "scaling": _scaling });
            this.resetCache();
        }
        //#region STATICS
        /**
         * Retrieve a new identity matrix
         */
        static IDENTITY() {
            // const result: Matrix4x4 = new Matrix4x4();
            const result = FudgeCore.Recycler.get(Matrix4x4);
            result.data.set([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]);
            return result;
        }
        /**
         * Computes and returns the product of two passed matrices.
         * @param _a The matrix to multiply.
         * @param _b The matrix to multiply by.
         */
        static MULTIPLICATION(_a, _b) {
            let a = _a.data;
            let b = _b.data;
            // let matrix: Matrix4x4 = new Matrix4x4();
            const matrix = FudgeCore.Recycler.get(Matrix4x4);
            let a00 = a[0 * 4 + 0];
            let a01 = a[0 * 4 + 1];
            let a02 = a[0 * 4 + 2];
            let a03 = a[0 * 4 + 3];
            let a10 = a[1 * 4 + 0];
            let a11 = a[1 * 4 + 1];
            let a12 = a[1 * 4 + 2];
            let a13 = a[1 * 4 + 3];
            let a20 = a[2 * 4 + 0];
            let a21 = a[2 * 4 + 1];
            let a22 = a[2 * 4 + 2];
            let a23 = a[2 * 4 + 3];
            let a30 = a[3 * 4 + 0];
            let a31 = a[3 * 4 + 1];
            let a32 = a[3 * 4 + 2];
            let a33 = a[3 * 4 + 3];
            let b00 = b[0 * 4 + 0];
            let b01 = b[0 * 4 + 1];
            let b02 = b[0 * 4 + 2];
            let b03 = b[0 * 4 + 3];
            let b10 = b[1 * 4 + 0];
            let b11 = b[1 * 4 + 1];
            let b12 = b[1 * 4 + 2];
            let b13 = b[1 * 4 + 3];
            let b20 = b[2 * 4 + 0];
            let b21 = b[2 * 4 + 1];
            let b22 = b[2 * 4 + 2];
            let b23 = b[2 * 4 + 3];
            let b30 = b[3 * 4 + 0];
            let b31 = b[3 * 4 + 1];
            let b32 = b[3 * 4 + 2];
            let b33 = b[3 * 4 + 3];
            matrix.data.set([
                b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30,
                b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31,
                b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32,
                b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33,
                b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30,
                b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31,
                b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32,
                b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33,
                b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30,
                b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31,
                b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32,
                b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33,
                b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30,
                b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31,
                b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32,
                b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33
            ]);
            return matrix;
        }
        /**
         * Computes and returns the inverse of a passed matrix.
         * @param _matrix The matrix to compute the inverse of.
         */
        static INVERSION(_matrix) {
            let m = _matrix.data;
            let m00 = m[0 * 4 + 0];
            let m01 = m[0 * 4 + 1];
            let m02 = m[0 * 4 + 2];
            let m03 = m[0 * 4 + 3];
            let m10 = m[1 * 4 + 0];
            let m11 = m[1 * 4 + 1];
            let m12 = m[1 * 4 + 2];
            let m13 = m[1 * 4 + 3];
            let m20 = m[2 * 4 + 0];
            let m21 = m[2 * 4 + 1];
            let m22 = m[2 * 4 + 2];
            let m23 = m[2 * 4 + 3];
            let m30 = m[3 * 4 + 0];
            let m31 = m[3 * 4 + 1];
            let m32 = m[3 * 4 + 2];
            let m33 = m[3 * 4 + 3];
            let tmp0 = m22 * m33;
            let tmp1 = m32 * m23;
            let tmp2 = m12 * m33;
            let tmp3 = m32 * m13;
            let tmp4 = m12 * m23;
            let tmp5 = m22 * m13;
            let tmp6 = m02 * m33;
            let tmp7 = m32 * m03;
            let tmp8 = m02 * m23;
            let tmp9 = m22 * m03;
            let tmp10 = m02 * m13;
            let tmp11 = m12 * m03;
            let tmp12 = m20 * m31;
            let tmp13 = m30 * m21;
            let tmp14 = m10 * m31;
            let tmp15 = m30 * m11;
            let tmp16 = m10 * m21;
            let tmp17 = m20 * m11;
            let tmp18 = m00 * m31;
            let tmp19 = m30 * m01;
            let tmp20 = m00 * m21;
            let tmp21 = m20 * m01;
            let tmp22 = m00 * m11;
            let tmp23 = m10 * m01;
            let t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) -
                (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);
            let t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) -
                (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);
            let t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) -
                (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);
            let t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) -
                (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);
            let d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);
            // let matrix: Matrix4x4 = new Matrix4x4;
            const matrix = FudgeCore.Recycler.get(Matrix4x4);
            matrix.data.set([
                d * t0,
                d * t1,
                d * t2,
                d * t3,
                d * ((tmp1 * m10 + tmp2 * m20 + tmp5 * m30) - (tmp0 * m10 + tmp3 * m20 + tmp4 * m30)),
                d * ((tmp0 * m00 + tmp7 * m20 + tmp8 * m30) - (tmp1 * m00 + tmp6 * m20 + tmp9 * m30)),
                d * ((tmp3 * m00 + tmp6 * m10 + tmp11 * m30) - (tmp2 * m00 + tmp7 * m10 + tmp10 * m30)),
                d * ((tmp4 * m00 + tmp9 * m10 + tmp10 * m20) - (tmp5 * m00 + tmp8 * m10 + tmp11 * m20)),
                d * ((tmp12 * m13 + tmp15 * m23 + tmp16 * m33) - (tmp13 * m13 + tmp14 * m23 + tmp17 * m33)),
                d * ((tmp13 * m03 + tmp18 * m23 + tmp21 * m33) - (tmp12 * m03 + tmp19 * m23 + tmp20 * m33)),
                d * ((tmp14 * m03 + tmp19 * m13 + tmp22 * m33) - (tmp15 * m03 + tmp18 * m13 + tmp23 * m33)),
                d * ((tmp17 * m03 + tmp20 * m13 + tmp23 * m23) - (tmp16 * m03 + tmp21 * m13 + tmp22 * m23)),
                d * ((tmp14 * m22 + tmp17 * m32 + tmp13 * m12) - (tmp16 * m32 + tmp12 * m12 + tmp15 * m22)),
                d * ((tmp20 * m32 + tmp12 * m02 + tmp19 * m22) - (tmp18 * m22 + tmp21 * m32 + tmp13 * m02)),
                d * ((tmp18 * m12 + tmp23 * m32 + tmp15 * m02) - (tmp22 * m32 + tmp14 * m02 + tmp19 * m12)),
                d * ((tmp22 * m22 + tmp16 * m02 + tmp21 * m12) - (tmp20 * m12 + tmp23 * m22 + tmp17 * m02)) // [15]
            ]);
            return matrix;
        }
        /**
         * Computes and returns a matrix with the given translation, its z-axis pointing directly at the given target,
         * and a minimal angle between its y-axis and the given up-Vector, respetively calculating yaw and pitch.
         */
        static LOOK_AT(_translation, _target, _up = FudgeCore.Vector3.Y()) {
            // const matrix: Matrix4x4 = new Matrix4x4;
            const matrix = FudgeCore.Recycler.get(Matrix4x4);
            let zAxis = FudgeCore.Vector3.DIFFERENCE(_target, _translation);
            zAxis.normalize();
            let xAxis = FudgeCore.Vector3.NORMALIZATION(FudgeCore.Vector3.CROSS(_up, zAxis));
            let yAxis = FudgeCore.Vector3.NORMALIZATION(FudgeCore.Vector3.CROSS(zAxis, xAxis));
            matrix.data.set([
                xAxis.x, xAxis.y, xAxis.z, 0,
                yAxis.x, yAxis.y, yAxis.z, 0,
                zAxis.x, zAxis.y, zAxis.z, 0,
                _translation.x,
                _translation.y,
                _translation.z,
                1
            ]);
            return matrix;
        }
        /**
         * Computes and returns a matrix with the given translation, its y-axis matching the given up-vector
         * and its z-axis facing towards the given target at a minimal angle, respetively calculating yaw only.
         */
        static SHOW_TO(_translation, _target, _up = FudgeCore.Vector3.Y()) {
            // const matrix: Matrix4x4 = new Matrix4x4;
            const matrix = FudgeCore.Recycler.get(Matrix4x4);
            let zAxis = FudgeCore.Vector3.DIFFERENCE(_target, _translation);
            zAxis.normalize();
            let xAxis = FudgeCore.Vector3.NORMALIZATION(FudgeCore.Vector3.CROSS(_up, zAxis));
            // let yAxis: Vector3 = Vector3.NORMALIZATION(Vector3.CROSS(zAxis, xAxis));
            zAxis = FudgeCore.Vector3.NORMALIZATION(FudgeCore.Vector3.CROSS(xAxis, _up));
            matrix.data.set([
                xAxis.x, xAxis.y, xAxis.z, 0,
                _up.x, _up.y, _up.z, 0,
                zAxis.x, zAxis.y, zAxis.z, 0,
                _translation.x,
                _translation.y,
                _translation.z,
                1
            ]);
            return matrix;
        }
        /**
         * Returns a matrix that translates coordinates along the x-, y- and z-axis according to the given vector.
         */
        static TRANSLATION(_translate) {
            // let matrix: Matrix4x4 = new Matrix4x4;
            const matrix = FudgeCore.Recycler.get(Matrix4x4);
            matrix.data.set([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                _translate.x, _translate.y, _translate.z, 1
            ]);
            return matrix;
        }
        /**
         * Returns a matrix that rotates coordinates on the x-axis when multiplied by.
         * @param _angleInDegrees The value of the rotation.
         */
        static ROTATION_X(_angleInDegrees) {
            // const matrix: Matrix4x4 = new Matrix4x4;
            const matrix = FudgeCore.Recycler.get(Matrix4x4);
            let angleInRadians = _angleInDegrees * Math.PI / 180;
            let sin = Math.sin(angleInRadians);
            let cos = Math.cos(angleInRadians);
            matrix.data.set([
                1, 0, 0, 0,
                0, cos, sin, 0,
                0, -sin, cos, 0,
                0, 0, 0, 1
            ]);
            return matrix;
        }
        /**
         * Returns a matrix that rotates coordinates on the y-axis when multiplied by.
         * @param _angleInDegrees The value of the rotation.
         */
        static ROTATION_Y(_angleInDegrees) {
            // const matrix: Matrix4x4 = new Matrix4x4;
            let matrix = FudgeCore.Recycler.get(Matrix4x4);
            let angleInRadians = _angleInDegrees * Math.PI / 180;
            let sin = Math.sin(angleInRadians);
            let cos = Math.cos(angleInRadians);
            matrix.data.set([
                cos, 0, -sin, 0,
                0, 1, 0, 0,
                sin, 0, cos, 0,
                0, 0, 0, 1
            ]);
            return matrix;
        }
        /**
         * Returns a matrix that rotates coordinates on the z-axis when multiplied by.
         * @param _angleInDegrees The value of the rotation.
         */
        static ROTATION_Z(_angleInDegrees) {
            // const matrix: Matrix4x4 = new Matrix4x4;
            const matrix = FudgeCore.Recycler.get(Matrix4x4);
            let angleInRadians = _angleInDegrees * Math.PI / 180;
            let sin = Math.sin(angleInRadians);
            let cos = Math.cos(angleInRadians);
            matrix.data.set([
                cos, sin, 0, 0,
                -sin, cos, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]);
            return matrix;
        }
        /**
         * Returns a matrix that scales coordinates along the x-, y- and z-axis according to the given vector
         */
        static SCALING(_scalar) {
            // const matrix: Matrix4x4 = new Matrix4x4;
            const matrix = FudgeCore.Recycler.get(Matrix4x4);
            matrix.data.set([
                _scalar.x, 0, 0, 0,
                0, _scalar.y, 0, 0,
                0, 0, _scalar.z, 0,
                0, 0, 0, 1
            ]);
            return matrix;
        }
        //#endregion
        //#region PROJECTIONS
        /**
         * Computes and returns a matrix that applies perspective to an object, if its transform is multiplied by it.
         * @param _aspect The aspect ratio between width and height of projectionspace.(Default = canvas.clientWidth / canvas.ClientHeight)
         * @param _fieldOfViewInDegrees The field of view in Degrees. (Default = 45)
         * @param _near The near clipspace border on the z-axis.
         * @param _far The far clipspace border on the z-axis.
         * @param _direction The plane on which the fieldOfView-Angle is given
         */
        static PROJECTION_CENTRAL(_aspect, _fieldOfViewInDegrees, _near, _far, _direction) {
            //TODO: camera looks down negative z-direction, should be positive
            let fieldOfViewInRadians = _fieldOfViewInDegrees * Math.PI / 180;
            let f = Math.tan(0.5 * (Math.PI - fieldOfViewInRadians));
            let rangeInv = 1.0 / (_near - _far);
            // const matrix: Matrix4x4 = new Matrix4x4;
            const matrix = FudgeCore.Recycler.get(Matrix4x4);
            matrix.data.set([
                f, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (_near + _far) * rangeInv, -1,
                0, 0, _near * _far * rangeInv * 2, 0
            ]);
            if (_direction == FudgeCore.FIELD_OF_VIEW.DIAGONAL) {
                _aspect = Math.sqrt(_aspect);
                matrix.data[0] = f / _aspect;
                matrix.data[5] = f * _aspect;
            }
            else if (_direction == FudgeCore.FIELD_OF_VIEW.VERTICAL)
                matrix.data[0] = f / _aspect;
            else //FOV_DIRECTION.HORIZONTAL
                matrix.data[5] = f * _aspect;
            // HACK: matrix should look in positive z-direction, preferably the matrix should be calculated like that right away
            matrix.rotateY(180);
            return matrix;
        }
        /**
         * Computes and returns a matrix that applies orthographic projection to an object, if its transform is multiplied by it.
         * @param _left The positionvalue of the projectionspace's left border.
         * @param _right The positionvalue of the projectionspace's right border.
         * @param _bottom The positionvalue of the projectionspace's bottom border.
         * @param _top The positionvalue of the projectionspace's top border.
         * @param _near The positionvalue of the projectionspace's near border.
         * @param _far The positionvalue of the projectionspace's far border
         */
        static PROJECTION_ORTHOGRAPHIC(_left, _right, _bottom, _top, _near = -400, _far = 400) {
            // const matrix: Matrix4x4 = new Matrix4x4;
            const matrix = FudgeCore.Recycler.get(Matrix4x4);
            matrix.data.set([
                2 / (_right - _left), 0, 0, 0,
                0, 2 / (_top - _bottom), 0, 0,
                0, 0, 2 / (_near - _far), 0,
                (_left + _right) / (_left - _right),
                (_bottom + _top) / (_bottom - _top),
                (_near + _far) / (_near - _far),
                1
            ]);
            return matrix;
        }
        //#endregion
        //#region Rotation
        /**
         * Rotate this matrix by given vector in the order Z, Y, X. Right hand rotation is used, thumb points in axis direction, fingers curling indicate rotation
         * @param _by
         */
        rotate(_by, _fromLeft = false) {
            this.rotateZ(_by.z, _fromLeft);
            this.rotateY(_by.y, _fromLeft);
            this.rotateX(_by.x, _fromLeft);
        }
        /**
         * Adds a rotation around the x-axis to this matrix
         */
        rotateX(_angleInDegrees, _fromLeft = false) {
            let rotation = Matrix4x4.ROTATION_X(_angleInDegrees);
            this.multiply(rotation, _fromLeft);
            FudgeCore.Recycler.store(rotation);
        }
        /**
         * Adds a rotation around the y-axis to this matrix
         */
        rotateY(_angleInDegrees, _fromLeft = false) {
            let rotation = Matrix4x4.ROTATION_Y(_angleInDegrees);
            this.multiply(rotation, _fromLeft);
            FudgeCore.Recycler.store(rotation);
        }
        /**
         * Adds a rotation around the z-axis to this matrix
         */
        rotateZ(_angleInDegrees, _fromLeft = false) {
            let rotation = Matrix4x4.ROTATION_Z(_angleInDegrees);
            this.multiply(rotation, _fromLeft);
            FudgeCore.Recycler.store(rotation);
        }
        /**
         * Adjusts the rotation of this matrix to point the y-axis directly at the given target and tilts it to accord with the given up vector,
         * respectively calculating yaw and pitch. If no up vector is given, the previous up-vector is used.
         * When _preserveScaling is false, a rotated identity matrix is the result.
         */
        lookAt(_target, _up, _preserveScaling = true) {
            if (!_up)
                _up = this.getY();
            const matrix = Matrix4x4.LOOK_AT(this.translation, _target, _up);
            if (_preserveScaling)
                matrix.scale(this.scaling);
            this.set(matrix);
            FudgeCore.Recycler.store(matrix);
        }
        /**
         * Adjusts the rotation of this matrix to match its y-axis with the given up-vector and facing its z-axis toward the given target at minimal angle,
         * respectively calculating yaw only. If no up vector is given, the previous up-vector is used.
         * When _preserveScaling is false, a rotated identity matrix is the result.
         */
        showTo(_target, _up, _preserveScaling = true) {
            if (!_up)
                _up = this.getY();
            const matrix = Matrix4x4.SHOW_TO(this.translation, _target, _up);
            if (_preserveScaling)
                matrix.scale(this.scaling);
            this.set(matrix);
            FudgeCore.Recycler.store(matrix);
        }
        //#endregion
        //#region Translation
        /**
         * Add a translation by the given vector to this matrix
         */
        translate(_by, _local = true) {
            if (_local) {
                let translation = Matrix4x4.TRANSLATION(_by);
                this.multiply(translation);
                FudgeCore.Recycler.store(translation);
            }
            else {
                this.data[12] += _by.x;
                this.data[13] += _by.y;
                this.data[14] += _by.z;
                this.mutator = null;
                if (this.vectors.translation)
                    FudgeCore.Recycler.store(this.vectors.translation);
                this.vectors.translation = null;
            }
            // const matrix: Matrix4x4 = Matrix4x4.MULTIPLICATION(this, Matrix4x4.TRANSLATION(_by));
            // // TODO: possible optimization, translation may alter mutator instead of deleting it.
            // this.set(matrix);
            // Recycler.store(matrix);
        }
        /**
         * Add a translation along the x-axis by the given amount to this matrix
         */
        translateX(_x, _local = true) {
            let translation = FudgeCore.Vector3.X(_x);
            this.translate(translation, _local);
            FudgeCore.Recycler.store(translation);
        }
        /**
         * Add a translation along the y-axis by the given amount to this matrix
         */
        translateY(_y, _local = true) {
            let translation = FudgeCore.Vector3.Y(_y);
            this.translate(translation, _local);
            FudgeCore.Recycler.store(translation);
        }
        /**
         * Add a translation along the z-axis by the given amount to this matrix
         */
        translateZ(_z, _local = true) {
            let translation = FudgeCore.Vector3.Z(_z);
            this.translate(translation, _local);
            FudgeCore.Recycler.store(translation);
        }
        //#endregion
        //#region Scaling
        /**
         * Add a scaling by the given vector to this matrix
         */
        scale(_by) {
            const matrix = Matrix4x4.MULTIPLICATION(this, Matrix4x4.SCALING(_by));
            this.set(matrix);
            FudgeCore.Recycler.store(matrix);
        }
        /**
         * Add a scaling along the x-axis by the given amount to this matrix
         */
        scaleX(_by) {
            let vector = FudgeCore.Recycler.borrow(FudgeCore.Vector3);
            vector.set(_by, 1, 1);
            this.scale(vector);
        }
        /**
         * Add a scaling along the y-axis by the given amount to this matrix
         */
        scaleY(_by) {
            let vector = FudgeCore.Recycler.borrow(FudgeCore.Vector3);
            vector.set(1, _by, 1);
            this.scale(vector);
        }
        /**
         * Add a scaling along the z-axis by the given amount to this matrix
         */
        scaleZ(_by) {
            let vector = FudgeCore.Recycler.borrow(FudgeCore.Vector3);
            vector.set(1, 1, _by);
            this.scale(vector);
        }
        //#endregion
        //#region Transformation
        /**
         * Multiply this matrix with the given matrix
         */
        multiply(_matrix, _fromLeft = false) {
            const matrix = _fromLeft ? Matrix4x4.MULTIPLICATION(_matrix, this) : Matrix4x4.MULTIPLICATION(this, _matrix);
            this.set(matrix);
            FudgeCore.Recycler.store(matrix);
        }
        //#endregion
        //#region Transfer
        /**
         * Calculates and returns the euler-angles representing the current rotation of this matrix
         */
        getEulerAngles() {
            let scaling = this.scaling;
            let s0 = this.data[0] / scaling.x;
            let s1 = this.data[1] / scaling.x;
            let s2 = this.data[2] / scaling.x;
            let s6 = this.data[6] / scaling.y;
            let s10 = this.data[10] / scaling.z;
            let sy = Math.hypot(s0, s1); // probably 2. param should be this.data[4] / scaling.y
            let singular = sy < 1e-6; // If
            let x1, y1, z1;
            let x2, y2, z2;
            if (!singular) {
                x1 = Math.atan2(s6, s10);
                y1 = Math.atan2(-s2, sy);
                z1 = Math.atan2(s1, s0);
                x2 = Math.atan2(-s6, -s10);
                y2 = Math.atan2(-s2, -sy);
                z2 = Math.atan2(-s1, -s0);
                if (Math.abs(x2) + Math.abs(y2) + Math.abs(z2) < Math.abs(x1) + Math.abs(y1) + Math.abs(z1)) {
                    x1 = x2;
                    y1 = y2;
                    z1 = z2;
                }
            }
            else {
                x1 = Math.atan2(-this.data[9] / scaling.z, this.data[5] / scaling.y);
                y1 = Math.atan2(-this.data[2] / scaling.x, sy);
                z1 = 0;
            }
            let rotation = FudgeCore.Recycler.get(FudgeCore.Vector3);
            rotation.set(x1, y1, z1);
            rotation.scale(180 / Math.PI);
            return rotation;
        }
        /**
         * Sets the elements of this matrix to the values of the given matrix
         */
        set(_to) {
            // this.data = _to.get();
            this.data.set(_to.data);
            this.resetCache();
        }
        toString() {
            return `∆í.Matrix4x4(translation: ${this.translation.toString()}, rotation: ${this.rotation.toString()}, scaling: ${this.scaling.toString()}`;
        }
        /**
         * Return the elements of this matrix as a Float32Array
         */
        get() {
            return new Float32Array(this.data);
        }
        /**
         * Return cardinal x-axis
         */
        getX() {
            let result = FudgeCore.Recycler.get(FudgeCore.Vector3);
            result.set(this.data[0], this.data[1], this.data[2]);
            return result;
        }
        /**
         * Return cardinal y-axis
         */
        getY() {
            let result = FudgeCore.Recycler.get(FudgeCore.Vector3);
            result.set(this.data[4], this.data[5], this.data[6]);
            return result;
        }
        /**
         * Return cardinal z-axis
         */
        getZ() {
            let result = FudgeCore.Recycler.get(FudgeCore.Vector3);
            result.set(this.data[8], this.data[9], this.data[10]);
            return result;
        }
        /**
         * Swaps the two cardinal axis and reverses the third, effectively rotating the transform 180 degrees around one and 90 degrees around a second axis
         */
        swapXY() {
            let temp = [this.data[0], this.data[1], this.data[2]]; // store x-axis
            this.data.set([this.data[4], this.data[5], this.data[6]], 0); // overwrite x-axis with y-axis
            this.data.set(temp, 4); // overwrite Y with temp
            this.data.set([-this.data[8], -this.data[9], -this.data[10]], 8); // reverse z-axis
        }
        /**
         * Swaps the two cardinal axis and reverses the third, effectively rotating the transform 180 degrees around one and 90 degrees around a second axis
         */
        swapXZ() {
            let temp = [this.data[0], this.data[1], this.data[2]]; // store x-axis
            this.data.set([this.data[8], this.data[9], this.data[10]], 0); // overwrite x-axis with z-axis
            this.data.set(temp, 8); // overwrite Z with temp
            this.data.set([-this.data[4], -this.data[5], -this.data[6]], 4); // reverse y-axis
        }
        /**
         * Swaps the two cardinal axis and reverses the third, effectively rotating the transform 180 degrees around one and 90 degrees around a second axis
         */
        swapYZ() {
            let temp = [this.data[4], this.data[5], this.data[6]]; // store y-axis
            this.data.set([this.data[8], this.data[9], this.data[10]], 4); // overwrite y-axis with z-axis
            this.data.set(temp, 8); // overwrite Z with temp
            this.data.set([-this.data[0], -this.data[1], -this.data[2]], 0); // reverse x-axis
        }
        /**
         * Return a copy of this
         */
        get copy() {
            let copy = new Matrix4x4();
            copy.set(this);
            return copy;
        }
        getTranslationTo(_target) {
            let difference = FudgeCore.Recycler.get(FudgeCore.Vector3);
            difference.set(_target.data[12] - this.data[12], _target.data[13] - this.data[13], _target.data[14] - this.data[14]);
            return difference;
        }
        serialize() {
            // TODO: save translation, rotation and scale as vectors for readability and manipulation
            let serialization = this.getMutator();
            return serialization;
        }
        deserialize(_serialization) {
            this.mutate(_serialization);
            return this;
        }
        getMutator() {
            if (this.mutator)
                return this.mutator;
            let mutator = {
                translation: this.translation.getMutator(),
                rotation: this.rotation.getMutator(),
                scaling: this.scaling.getMutator()
            };
            // cache mutator
            this.mutator = mutator;
            return mutator;
        }
        mutate(_mutator) {
            let oldTranslation = this.translation;
            let oldRotation = this.rotation;
            let oldScaling = this.scaling;
            let newTranslation = _mutator["translation"];
            let newRotation = _mutator["rotation"];
            let newScaling = _mutator["scaling"];
            let vectors = { translation: oldTranslation, rotation: oldRotation, scaling: oldScaling };
            if (newTranslation) {
                vectors.translation = FudgeCore.Recycler.get(FudgeCore.Vector3);
                vectors.translation.set(newTranslation.x != undefined ? newTranslation.x : oldTranslation.x, newTranslation.y != undefined ? newTranslation.y : oldTranslation.y, newTranslation.z != undefined ? newTranslation.z : oldTranslation.z);
            }
            if (newRotation) {
                vectors.rotation = FudgeCore.Recycler.get(FudgeCore.Vector3);
                vectors.rotation.set(newRotation.x != undefined ? newRotation.x : oldRotation.x, newRotation.y != undefined ? newRotation.y : oldRotation.y, newRotation.z != undefined ? newRotation.z : oldRotation.z);
            }
            if (newScaling) {
                vectors.scaling = FudgeCore.Recycler.get(FudgeCore.Vector3);
                vectors.scaling.set(newScaling.x != undefined ? newScaling.x : oldScaling.x, newScaling.y != undefined ? newScaling.y : oldScaling.y, newScaling.z != undefined ? newScaling.z : oldScaling.z);
            }
            // TODO: possible performance optimization when only one or two components change, then use old matrix instead of IDENTITY and transform by differences/quotients
            let matrix = Matrix4x4.IDENTITY();
            if (vectors.translation)
                matrix.translate(vectors.translation);
            if (vectors.rotation) {
                matrix.rotateZ(vectors.rotation.z);
                matrix.rotateY(vectors.rotation.y);
                matrix.rotateX(vectors.rotation.x);
            }
            if (vectors.scaling)
                matrix.scale(vectors.scaling);
            this.set(matrix);
            this.vectors = vectors;
            FudgeCore.Recycler.store(matrix);
        }
        getMutatorAttributeTypes(_mutator) {
            let types = {};
            if (_mutator.translation)
                types.translation = "Vector3";
            if (_mutator.rotation)
                types.rotation = "Vector3";
            if (_mutator.scaling)
                types.scaling = "Vector3";
            return types;
        }
        reduceMutator(_mutator) { }
        resetCache() {
            this.vectors = { translation: null, rotation: null, scaling: null };
            this.mutator = null;
        }
    }
    FudgeCore.Matrix4x4 = Matrix4x4;
    //#endregion
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Class for creating random values, supporting Javascript's Math.random and a deterministig pseudo-random number generator (PRNG)
     * that can be fed with a seed and then returns a reproducable set of random numbers (if the precision of Javascript allows)
     *
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Random {
        /**
         * Create an instance of [[Random]]. If desired, creates a PRNG with it and feeds the given seed.
         * @param _ownGenerator
         * @param _seed
         */
        constructor(_ownGenerator = false, _seed = Math.random()) {
            this.generate = Math.random;
            if (_ownGenerator)
                this.generate = Random.createGenerator(_seed);
        }
        /**
         * Creates a dererminstic PRNG with the given seed
         */
        static createGenerator(_seed) {
            // TODO: replace with random number generator to generate predictable sequence
            return Math.random;
        }
        /**
         * Returns a normed random number, thus in the range of [0, 1[
         */
        getNorm() {
            return this.generate();
        }
        /**
         * Returns a random number in the range of given [_min, _max[
         */
        getRange(_min, _max) {
            return _min + this.generate() * (_max - _min);
        }
        /**
         * Returns a random integer number in the range of given floored [_min, _max[
         */
        getRangeFloored(_min, _max) {
            return Math.floor(this.getRange(_min, _max));
        }
        /**
         * Returns true or false randomly
         */
        getBoolean() {
            return this.generate() < 0.5;
        }
        /**
         * Returns -1 or 1 randomly
         */
        getSign() {
            return this.getBoolean() ? 1 : -1;
        }
        /**
         * Returns a randomly selected index into the given array
         */
        getIndex(_array) {
            if (_array.length > 0)
                return this.getRangeFloored(0, _array.length);
            return -1;
        }
        /**
         * Removes a randomly selected element from the given array and returns it
         */
        splice(_array) {
            return _array.splice(this.getIndex(_array), 1)[0];
        }
        /**
         * Returns a randomly selected key from the given Map-instance
         */
        getKey(_map) {
            let keys = Array.from(_map.keys());
            return keys[this.getIndex(keys)];
        }
        /**
         * Returns a randomly selected property name from the given object
         */
        getPropertyName(_object) {
            let keys = Object.getOwnPropertyNames(_object);
            return keys[this.getIndex(keys)];
        }
        /**
         * Returns a randomly selected symbol from the given object, if symbols are used as keys
         */
        getPropertySymbol(_object) {
            let keys = Object.getOwnPropertySymbols(_object);
            return keys[this.getIndex(keys)];
        }
    }
    Random.default = new Random();
    FudgeCore.Random = Random;
    /**
     * Standard [[Random]]-instance using Math.random().
     */
    FudgeCore.random = new Random();
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Stores and manipulates a threedimensional vector comprised of the components x, y and z
     * ```plaintext
     *            +y
     *             |__ +x
     *            /
     *          +z
     * ```
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Vector3 extends FudgeCore.Mutable {
        constructor(_x = 0, _y = 0, _z = 0) {
            super();
            this.data = new Float32Array([_x, _y, _z]);
        }
        // TODO: implement equals-functions
        get x() {
            return this.data[0];
        }
        get y() {
            return this.data[1];
        }
        get z() {
            return this.data[2];
        }
        set x(_x) {
            this.data[0] = _x;
        }
        set y(_y) {
            this.data[1] = _y;
        }
        set z(_z) {
            this.data[2] = _z;
        }
        /**
         * Returns the length of the vector
         */
        get magnitude() {
            return Math.hypot(...this.data);
        }
        /**
         * Returns the square of the magnitude of the vector without calculating a square root. Faster for simple proximity evaluation.
         */
        get magnitudeSquared() {
            return Vector3.DOT(this, this);
        }
        /**
         * Creates and returns a vector with the given length pointing in x-direction
         */
        static X(_scale = 1) {
            const vector = FudgeCore.Recycler.get(Vector3);
            vector.data.set([_scale, 0, 0]);
            return vector;
        }
        /**
         * Creates and returns a vector with the given length pointing in y-direction
         */
        static Y(_scale = 1) {
            const vector = FudgeCore.Recycler.get(Vector3);
            vector.data.set([0, _scale, 0]);
            return vector;
        }
        /**
         * Creates and returns a vector with the given length pointing in z-direction
         */
        static Z(_scale = 1) {
            const vector = FudgeCore.Recycler.get(Vector3);
            vector.data.set([0, 0, _scale]);
            return vector;
        }
        /**
         * Creates and returns a vector with the value 0 on each axis
         */
        static ZERO() {
            const vector = FudgeCore.Recycler.get(Vector3);
            vector.data.set([0, 0, 0]);
            return vector;
        }
        /**
         * Creates and returns a vector of the given size on each of the three axis
         */
        static ONE(_scale = 1) {
            const vector = FudgeCore.Recycler.get(Vector3);
            vector.data.set([_scale, _scale, _scale]);
            return vector;
        }
        /**
         * Creates and returns a vector through transformation of the given vector by the given matrix
         */
        static TRANSFORMATION(_vector, _matrix, _includeTranslation = true) {
            let result = FudgeCore.Recycler.get(Vector3);
            let m = _matrix.get();
            let [x, y, z] = _vector.get();
            result.x = m[0] * x + m[4] * y + m[8] * z;
            result.y = m[1] * x + m[5] * y + m[9] * z;
            result.z = m[2] * x + m[6] * y + m[10] * z;
            if (_includeTranslation) {
                result.add(_matrix.translation);
            }
            return result;
        }
        /**
         * Creates and returns a vector which is a copy of the given vector scaled to the given length
         */
        static NORMALIZATION(_vector, _length = 1) {
            let magnitude = _vector.magnitude;
            let vector;
            try {
                if (magnitude == 0)
                    throw (new RangeError("Impossible normalization"));
                vector = Vector3.ZERO();
                let factor = _length / _vector.magnitude;
                vector.data = new Float32Array([_vector.x * factor, _vector.y * factor, _vector.z * factor]);
            }
            catch (_error) {
                FudgeCore.Debug.warn(_error);
            }
            return vector;
        }
        /**
         * Returns the resulting vector attained by addition of all given vectors.
         */
        static SUM(..._vectors) {
            let result = FudgeCore.Recycler.get(Vector3);
            for (let vector of _vectors)
                result.data = new Float32Array([result.x + vector.x, result.y + vector.y, result.z + vector.z]);
            return result;
        }
        /**
         * Returns the result of the subtraction of two vectors.
         */
        static DIFFERENCE(_minuend, _subtrahend) {
            let vector = FudgeCore.Recycler.get(Vector3);
            vector.data = new Float32Array([_minuend.x - _subtrahend.x, _minuend.y - _subtrahend.y, _minuend.z - _subtrahend.z]);
            return vector;
        }
        /**
         * Returns a new vector representing the given vector scaled by the given scaling factor
         */
        static SCALE(_vector, _scaling) {
            let scaled = FudgeCore.Recycler.get(Vector3);
            scaled.data = new Float32Array([_vector.x * _scaling, _vector.y * _scaling, _vector.z * _scaling]);
            return scaled;
        }
        /**
         * Computes the crossproduct of 2 vectors.
         */
        static CROSS(_a, _b) {
            let vector = FudgeCore.Recycler.get(Vector3);
            vector.data = new Float32Array([
                _a.y * _b.z - _a.z * _b.y,
                _a.z * _b.x - _a.x * _b.z,
                _a.x * _b.y - _a.y * _b.x
            ]);
            return vector;
        }
        /**
         * Computes the dotproduct of 2 vectors.
         */
        static DOT(_a, _b) {
            let scalarProduct = _a.x * _b.x + _a.y * _b.y + _a.z * _b.z;
            return scalarProduct;
        }
        /**
         * Calculates and returns the reflection of the incoming vector at the given normal vector. The length of normal should be 1.
         *     __________________
         *           /|\
         * incoming / | \ reflection
         *         /  |  \
         *          normal
         *
         */
        static REFLECTION(_incoming, _normal) {
            let dot = -Vector3.DOT(_incoming, _normal);
            let reflection = Vector3.SUM(_incoming, Vector3.SCALE(_normal, 2 * dot));
            return reflection;
        }
        /**
         * Divides the dividend by the divisor component by component and returns the result
         */
        static RATIO(_dividend, _divisor) {
            let vector = FudgeCore.Recycler.get(Vector3);
            vector.data = new Float32Array([_dividend.x / _divisor.x, _dividend.y / _divisor.y, _dividend.z / _divisor.z]);
            return vector;
        }
        /**
         * Returns true if the coordinates of this and the given vector are to be considered identical within the given tolerance
         * TODO: examine, if tolerance as criterium for the difference is appropriate with very large coordinate values or if _tolerance should be multiplied by coordinate value
         */
        equals(_compare, _tolerance = Number.EPSILON) {
            if (Math.abs(this.x - _compare.x) > _tolerance)
                return false;
            if (Math.abs(this.y - _compare.y) > _tolerance)
                return false;
            if (Math.abs(this.z - _compare.z) > _tolerance)
                return false;
            return true;
        }
        /**
         * Returns true if the position described by this is within a cube with the opposite corners 1 and 2
         */
        isInsideCube(_corner1, _corner2) {
            let diagonal = Vector3.DIFFERENCE(_corner2, _corner1);
            let relative = Vector3.DIFFERENCE(this, _corner1);
            let ratio = Vector3.RATIO(relative, diagonal);
            if (ratio.x > 1 || ratio.x < 0)
                return false;
            if (ratio.y > 1 || ratio.y < 0)
                return false;
            if (ratio.z > 1 || ratio.z < 0)
                return false;
            return true;
        }
        /**
         * Returns true if the position described by this is within a sphere with the given center and radius
         */
        isInsideSphere(_center, _radius) {
            let difference = Vector3.DIFFERENCE(this, _center);
            return difference.magnitudeSquared < (_radius * _radius);
        }
        /**
         * Adds the given vector to this
         */
        add(_addend) {
            this.data.set([_addend.x + this.x, _addend.y + this.y, _addend.z + this.z]);
        }
        /**
         * Subtracts the given vector from this
         */
        subtract(_subtrahend) {
            this.data.set([this.x - _subtrahend.x, this.y - _subtrahend.y, this.z - _subtrahend.z]);
        }
        /**
         * Scales this vector by the given scalar
         */
        scale(_scalar) {
            this.data.set([_scalar * this.x, _scalar * this.y, _scalar * this.z]);
        }
        /**
         * Normalizes this to the given length, 1 by default
         */
        normalize(_length = 1) {
            this.data = Vector3.NORMALIZATION(this, _length).data;
        }
        /**
         * Defines the components of this vector with the given numbers
         */
        set(_x = 0, _y = 0, _z = 0) {
            this.data = new Float32Array([_x, _y, _z]);
        }
        /**
         * Returns this vector as a new Float32Array (copy)
         */
        get() {
            return new Float32Array(this.data);
        }
        /**
         * Returns a copy of this vector
         */
        get copy() {
            let copy = FudgeCore.Recycler.get(Vector3);
            copy.data.set(this.data);
            return copy;
        }
        /**
         * Transforms this vector by the given matrix, including or exluding the translation.
         * Including is the default, excluding will only rotate and scale this vector.
         */
        transform(_matrix, _includeTranslation = true) {
            this.data = Vector3.TRANSFORMATION(this, _matrix, _includeTranslation).data;
        }
        /**
         * Drops the z-component and returns a Vector2 consisting of the x- and y-components
         */
        toVector2() {
            return new FudgeCore.Vector2(this.x, this.y);
        }
        /**
         * Reflects this vector at a given normal. See [[REFLECTION]]
         */
        reflect(_normal) {
            const reflected = Vector3.REFLECTION(this, _normal);
            this.set(reflected.x, reflected.y, reflected.z);
            FudgeCore.Recycler.store(reflected);
        }
        /**
         * Shuffles the components of this vector
         */
        shuffle() {
            let a = Array.from(this.data);
            this.set(FudgeCore.Random.default.splice(a), FudgeCore.Random.default.splice(a), a[0]);
        }
        /**
         * Returns a formatted string representation of this vector
         */
        toString() {
            let result = `(${this.x.toPrecision(5)}, ${this.y.toPrecision(5)}, ${this.z.toPrecision(5)})`;
            return result;
        }
        /**
         * Uses the standard array.map functionality to perform the given function on all components of this vector
         */
        map(_function) {
            let copy = FudgeCore.Recycler.get(Vector3);
            copy.data = this.data.map(_function);
            return copy;
        }
        getMutator() {
            let mutator = {
                x: this.data[0], y: this.data[1], z: this.data[2]
            };
            return mutator;
        }
        reduceMutator(_mutator) { }
    }
    FudgeCore.Vector3 = Vector3;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    var Mesh_1;
    /**
     * Abstract base class for all meshes.
     * Meshes provide indexed vertices, the order of indices to create trigons and normals, and texture coordinates
     *
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    let Mesh = Mesh_1 = class Mesh {
        constructor() {
            this.idResource = undefined;
        }
        static getBufferSpecification() {
            return { size: 3, dataType: WebGL2RenderingContext.FLOAT, normalize: false, stride: 0, offset: 0 };
        }
        static registerSubclass(_subClass) { return Mesh_1.subclasses.push(_subClass) - 1; }
        useRenderBuffers(_shader, _world, _projection, _id) { }
        createRenderBuffers() { }
        deleteRenderBuffers(_shader) { }
        getVertexCount() {
            return this.vertices.length / Mesh_1.getBufferSpecification().size;
        }
        getIndexCount() {
            return this.indices.length;
        }
        create() {
            this.vertices = this.createVertices();
            this.indices = this.createIndices();
            this.textureUVs = this.createTextureUVs();
            this.normalsFace = this.createFaceNormals();
            this.createRenderBuffers();
        }
        // Serialize/Deserialize for all meshes that calculate without parameters
        serialize() {
            let serialization = {
                idResource: this.idResource
            }; // no data needed ...
            return serialization;
        }
        deserialize(_serialization) {
            this.create(); // TODO: must not be created, if an identical mesh already exists
            this.idResource = _serialization.idResource;
            return this;
        }
        // public abstract create(): void;
        calculateFaceNormals() {
            let normals = [];
            let vertices = [];
            for (let v = 0; v < this.vertices.length; v += 3)
                vertices.push(new FudgeCore.Vector3(this.vertices[v], this.vertices[v + 1], this.vertices[v + 2]));
            for (let i = 0; i < this.indices.length; i += 3) {
                let vertex = [this.indices[i], this.indices[i + 1], this.indices[i + 2]];
                let v0 = FudgeCore.Vector3.DIFFERENCE(vertices[vertex[0]], vertices[vertex[1]]);
                let v1 = FudgeCore.Vector3.DIFFERENCE(vertices[vertex[0]], vertices[vertex[2]]);
                let normal = FudgeCore.Vector3.NORMALIZATION(FudgeCore.Vector3.CROSS(v0, v1));
                let index = vertex[2] * 3;
                normals[index] = normal.x;
                normals[index + 1] = normal.y;
                normals[index + 2] = normal.z;
            }
            return new Float32Array(normals);
        }
    };
    /** refers back to this class from any subclass e.g. in order to find compatible other resources*/
    Mesh.baseClass = Mesh_1;
    /** list of all the subclasses derived from this class, if they registered properly*/
    Mesh.subclasses = [];
    Mesh = Mesh_1 = __decorate([
        FudgeCore.RenderInjectorMesh.decorate
    ], Mesh);
    FudgeCore.Mesh = Mesh;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a simple cube with edges of length 1, each face consisting of two trigons
     * ```plaintext
     *            4____7
     *           0/__3/|
     *            ||5_||6
     *           1|/_2|/
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class MeshCube extends FudgeCore.Mesh {
        constructor() {
            super();
            this.create();
        }
        createVertices() {
            let vertices = new Float32Array([
                // First wrap
                // front
                /*0*/ -1, 1, 1, /*1*/ -1, -1, 1, /*2*/ 1, -1, 1, /*3*/ 1, 1, 1,
                // back
                /*4*/ -1, 1, -1, /* 5*/ -1, -1, -1, /* 6*/ 1, -1, -1, /* 7*/ 1, 1, -1,
                // Second wrap
                // front
                /*0*/ -1, 1, 1, /*1*/ -1, -1, 1, /*2*/ 1, -1, 1, /*3*/ 1, 1, 1,
                // back
                /*4*/ -1, 1, -1, /* 5*/ -1, -1, -1, /* 6*/ 1, -1, -1, /* 7*/ 1, 1, -1
            ]);
            // scale down to a length of 1 for all edges
            vertices = vertices.map(_value => _value / 2);
            return vertices;
        }
        createIndices() {
            let indices = new Uint16Array([
                // First wrap
                // front
                1, 2, 0, 2, 3, 0,
                // right
                2, 6, 3, 6, 7, 3,
                // back
                6, 5, 7, 5, 4, 7,
                // Second wrap
                // left
                5 + 8, 1 + 8, 4 + 8, 1 + 8, 0 + 8, 4 + 8,
                // top
                4 + 8, 0 + 8, 3 + 8, 7 + 8, 4 + 8, 3 + 8,
                // bottom
                5 + 8, 6 + 8, 1 + 8, 6 + 8, 2 + 8, 1 + 8
                /*,
                // left
                4, 5, 1, 4, 1, 0,
                // top
                4, 0, 3, 4, 3, 7,
                // bottom
                1, 5, 6, 1, 6, 2
                */
            ]);
            return indices;
        }
        createTextureUVs() {
            let textureUVs = new Float32Array([
                // First wrap
                // front
                /*0*/ 0, 0, /*1*/ 0, 1, /*2*/ 1, 1, /*3*/ 1, 0,
                // back
                /*4*/ 3, 0, /*5*/ 3, 1, /*6*/ 2, 1, /*7*/ 2, 0,
                // Second wrap
                // front
                /*0*/ 1, 0, /*1*/ 1, 1, /*2*/ 1, 2, /*3*/ 1, -1,
                // back
                /*4*/ 0, 0, /*5*/ 0, 1, /*6*/ 0, 2, /*7*/ 0, -1
            ]);
            return textureUVs;
        }
        createFaceNormals() {
            let normals = new Float32Array([
                // for each triangle, the last vertex of the three defining refers to the normalvector when using flat shading
                // First wrap
                // front
                /*0*/ 0, 0, 1, /*1*/ 0, 0, 0, /*2*/ 0, 0, 0, /*3*/ 1, 0, 0,
                // back
                /*4*/ 0, 0, 0, /*5*/ 0, 0, 0, /*6*/ 0, 0, 0, /*7*/ 0, 0, -1,
                // Second wrap
                // front
                /*0*/ 0, 0, 0, /*1*/ 0, -1, 0, /*2*/ 0, 0, 0, /*3*/ 0, 1, 0,
                // back
                /*4*/ -1, 0, 0, /*5*/ 0, 0, 0, /*6*/ 0, 0, 0, /*7*/ 0, 0, 0
            ]);
            //normals = this.createVertices();
            return normals;
        }
    }
    MeshCube.iSubclass = FudgeCore.Mesh.registerSubclass(MeshCube);
    FudgeCore.MeshCube = MeshCube;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generates a planar Grid and applies a Heightmap-Function to it.
     * @authors Jirka Dell'Oro-Friedl, Simon Storl-Schulke, HFU, 2020
     */
    class MeshHeightMap extends FudgeCore.Mesh {
        constructor(_resolutionX = 16, _resolutionZ = 16, _heightMapFunction) {
            super();
            this.resolutionX = _resolutionX;
            this.resolutionZ = _resolutionZ;
            if (_resolutionZ || _resolutionX <= 0) {
                FudgeCore.Debug.warn("HeightMap Mesh cannot have resolution values < 1. ");
                this.resolutionX = Math.max(1, this.resolutionX);
                this.resolutionZ = Math.max(1, this.resolutionZ);
            }
            if (_heightMapFunction)
                this.heightMapFunction = _heightMapFunction;
            else
                this.heightMapFunction = function (_x, _y) { return 0; };
            this.create();
        }
        createVertices() {
            let vertices = new Float32Array((this.resolutionX + 1) * (this.resolutionZ + 1) * 3);
            //Iterate over each cell to generate grid of vertices
            for (let i = 0, z = 0; z <= this.resolutionZ; z++) {
                for (let x = 0; x <= this.resolutionX; x++) {
                    // X
                    vertices[i] = x / this.resolutionX - 0.5;
                    // Apply heightmap to y coordinate
                    vertices[i + 1] = this.heightMapFunction(x / this.resolutionX, z / this.resolutionZ);
                    // Z
                    vertices[i + 2] = z / this.resolutionZ - 0.5;
                    i += 3;
                }
            }
            return vertices;
        }
        createIndices() {
            let vert = 0;
            let tris = 0;
            let indices = new Uint16Array(this.resolutionX * this.resolutionZ * 6);
            for (let z = 0; z < this.resolutionZ; z++) {
                for (let x = 0; x < this.resolutionX; x++) {
                    // First triangle of each grid-cell
                    indices[tris + 0] = vert + 0;
                    indices[tris + 1] = vert + this.resolutionX + 1;
                    indices[tris + 2] = vert + 1;
                    // Second triangle of each grid-cell
                    indices[tris + 3] = vert + 1;
                    indices[tris + 4] = vert + this.resolutionX + 1;
                    indices[tris + 5] = vert + this.resolutionX + 2;
                    vert++;
                    tris += 6;
                }
                vert++;
            }
            return indices;
        }
        createTextureUVs() {
            let textureUVs = new Float32Array(this.indices.length * 2);
            for (let i = 0, z = 0; z <= this.resolutionZ; z++) {
                for (let x = 0; x <= this.resolutionX; x++) {
                    textureUVs[i] = x / this.resolutionX;
                    textureUVs[i + 1] = z / this.resolutionZ;
                    i += 2;
                }
            }
            return textureUVs;
        }
        createFaceNormals() {
            return this.calculateFaceNormals();
        }
    }
    MeshHeightMap.iSubclass = FudgeCore.Mesh.registerSubclass(MeshHeightMap);
    FudgeCore.MeshHeightMap = MeshHeightMap;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a simple pyramid with edges at the base of length 1 and a height of 1. The sides consisting of one, the base of two trigons
     * ```plaintext
     *               4
     *              /\`.
     *            3/__\_\ 2
     *           0/____\/1
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class MeshPyramid extends FudgeCore.Mesh {
        constructor() {
            super();
            this.create();
        }
        createVertices() {
            let vertices = new Float32Array([
                // floor
                /*0*/ -1, 0, 1, /*1*/ 1, 0, 1, /*2*/ 1, 0, -1, /*3*/ -1, 0, -1,
                // tip
                /*4*/ 0, 2, 0,
                // floor again for texturing and normals
                /*5*/ -1, 0, 1, /*6*/ 1, 0, 1, /*7*/ 1, 0, -1, /*8*/ -1, 0, -1
            ]);
            // scale down to a length of 1 for bottom edges and height
            vertices = vertices.map(_value => _value / 2);
            return vertices;
        }
        createIndices() {
            let indices = new Uint16Array([
                // front
                4, 0, 1,
                // right
                4, 1, 2,
                // back
                4, 2, 3,
                // left
                4, 3, 0,
                // bottom
                5 + 0, 5 + 2, 5 + 1, 5 + 0, 5 + 3, 5 + 2
            ]);
            return indices;
        }
        createTextureUVs() {
            let textureUVs = new Float32Array([
                // front
                /*0*/ 0, 1, /*1*/ 0.5, 1, /*2*/ 1, 1, /*3*/ 0.5, 1,
                // back
                /*4*/ 0.5, 0,
                /*5*/ 0, 0, /*6*/ 1, 0, /*7*/ 1, 1, /*8*/ 0, 1
            ]);
            return textureUVs;
        }
        createFaceNormals() {
            return new Float32Array(this.calculateFaceNormals());
        }
    }
    MeshPyramid.iSubclass = FudgeCore.Mesh.registerSubclass(MeshPyramid);
    FudgeCore.MeshPyramid = MeshPyramid;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a simple quad with edges of length 1, the face consisting of two trigons
     * ```plaintext
     *        0 __ 3
     *         |__|
     *        1    2
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class MeshQuad extends FudgeCore.Mesh {
        constructor() {
            super();
            this.create();
        }
        createVertices() {
            let vertices = new Float32Array([
                /*0*/ -1, 1, 0, /*1*/ -1, -1, 0, /*2*/ 1, -1, 0, /*3*/ 1, 1, 0
            ]);
            vertices = vertices.map(_value => _value / 2);
            return vertices;
        }
        createIndices() {
            let indices = new Uint16Array([
                1, 2, 0, 2, 3, 0
            ]);
            return indices;
        }
        createTextureUVs() {
            let textureUVs = new Float32Array([
                // front
                /*0*/ 0, 0, /*1*/ 0, 1, /*2*/ 1, 1, /*3*/ 1, 0
            ]);
            return textureUVs;
        }
        createFaceNormals() {
            return new Float32Array([
                /*0*/ 0, 0, 1, /*1*/ 0, 0, 0, /*2*/ 0, 0, 0, /*3*/ 0, 0, 0
            ]);
        }
    }
    MeshQuad.iSubclass = FudgeCore.Mesh.registerSubclass(MeshQuad);
    FudgeCore.MeshQuad = MeshQuad;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a UV Sphere with a given number of sectors and stacks (clamped at 128*128)
     * Implementation based on http://www.songho.ca/opengl/gl_sphere.html
     * @authors Simon Storl-Schulke, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2020
     */
    class MeshSphere extends FudgeCore.Mesh {
        // Dirty Workaround to have access to the normals from createVertices()
        // private normals: Array<number> = [];
        // private textureUVs: Array<number> = [];
        // public textureUVs: Float32Array;
        constructor(_sectors = 12, _stacks = 8) {
            super();
            //Clamp resolution to prevent performance issues
            this.sectors = Math.min(_sectors, 128);
            this.stacks = Math.min(_stacks, 128);
            if (_sectors < 3 || _stacks < 2) {
                FudgeCore.Debug.warn("UV Sphere must have at least 3 sectors and 2 stacks to form a 3-dimensional shape.");
                this.sectors = Math.max(3, _sectors);
                this.stacks = Math.max(2, _stacks);
            }
            this.create();
        }
        create() {
            let vertices = [];
            let normals = [];
            let textureUVs = [];
            let x;
            let z;
            let xz;
            let y;
            let sectorStep = 2 * Math.PI / this.sectors;
            let stackStep = Math.PI / this.stacks;
            let stackAngle;
            let sectorAngle;
            /* add (sectorCount+1) vertices per stack.
            the first and last vertices have same position and normal,
            but different tex coords */
            for (let i = 0; i <= this.stacks; ++i) {
                stackAngle = Math.PI / 2 - i * stackStep;
                xz = Math.cos(stackAngle);
                y = Math.sin(stackAngle);
                // add (sectorCount+1) vertices per stack
                // the first and last vertices have same position and normal, but different tex coords
                for (let j = 0; j <= this.sectors; ++j) {
                    sectorAngle = j * sectorStep;
                    //vertex position
                    x = xz * Math.cos(sectorAngle);
                    z = xz * Math.sin(sectorAngle);
                    vertices.push(x, y, z);
                    //normals
                    normals.push(x, y, z);
                    //UV Coords
                    textureUVs.push(j / this.sectors * -1);
                    textureUVs.push(i / this.stacks);
                }
            }
            // scale down
            vertices = vertices.map(_value => _value / 2);
            this.textureUVs = new Float32Array(textureUVs);
            this.normals = new Float32Array(normals);
            this.vertices = new Float32Array(vertices);
            this.normalsFace = this.createFaceNormals();
            this.indices = this.createIndices();
            this.createRenderBuffers();
        }
        createIndices() {
            let inds = [];
            let k1;
            let k2;
            for (let i = 0; i < this.stacks; ++i) {
                k1 = i * (this.sectors + 1); // beginning of current stack
                k2 = k1 + this.sectors + 1; // beginning of next stack
                for (let j = 0; j < this.sectors; ++j, ++k1, ++k2) {
                    // 2 triangles per sector excluding first and last stacks
                    // k1 => k2 => k1+1
                    if (i != 0) {
                        inds.push(k1);
                        inds.push(k1 + 1);
                        inds.push(k2);
                    }
                    if (i != (this.stacks - 1)) {
                        inds.push(k1 + 1);
                        inds.push(k2 + 1);
                        inds.push(k2);
                    }
                }
            }
            let indices = new Uint16Array(inds);
            return indices;
        }
        createVertices() {
            return this.vertices;
        }
        createTextureUVs() {
            return this.textureUVs;
        }
        //TODO: we also need REAL face normals
        createFaceNormals() {
            return this.normals;
        }
    }
    MeshSphere.iSubclass = FudgeCore.Mesh.registerSubclass(MeshSphere);
    FudgeCore.MeshSphere = MeshSphere;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate two quads placed back to back, the one facing in negative Z-direction is textured reversed
     * ```plaintext
     *        0 __ 3
     *         |__|
     *        1    2
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2020
     */
    class MeshSprite extends FudgeCore.Mesh {
        constructor() {
            super();
            this.create();
        }
        createVertices() {
            let vertices = new Float32Array([
                /*0*/ -1, 1, 0, /*1*/ -1, -1, 0, /*2*/ 1, -1, 0, /*3*/ 1, 1, 0
            ]);
            vertices = vertices.map(_value => _value / 2);
            return vertices;
        }
        createIndices() {
            let indices = new Uint16Array([
                1, 2, 0, 2, 3, 0,
                0, 3, 1, 3, 2, 1 //back
            ]);
            return indices;
        }
        createTextureUVs() {
            let textureUVs = new Float32Array([
                // front
                /*0*/ 0, 0, /*1*/ 0, 1, /*2*/ 1, 1, /*3*/ 1, 0
            ]);
            return textureUVs;
        }
        createFaceNormals() {
            return new Float32Array([
                /*0: normal of front face*/
                0, 0, 1,
                /*1: normal of back face*/
                0, 0, -1,
                /*2*/
                0, 0, 0,
                /*3*/
                0, 0, 0
            ]);
        }
    }
    MeshSprite.iSubclass = FudgeCore.Mesh.registerSubclass(MeshSprite);
    FudgeCore.MeshSprite = MeshSprite;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Represents a node in the scenetree.
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Graph
     */
    class Node extends FudgeCore.EventTarget∆í {
        /**
         * Creates a new node with a name and initializes all attributes
         * @param _name The name by which the node can be called.
         */
        constructor(_name) {
            super();
            this.mtxWorld = FudgeCore.Matrix4x4.IDENTITY();
            this.timestampUpdate = 0;
            this.parent = null; // The parent of this node.
            this.children = []; // array of child nodes appended to this node.
            this.components = {};
            // private tags: string[] = []; // Names of tags that are attached to this node. (TODO: As of yet no functionality)
            // private layers: string[] = []; // Names of the layers this node is on. (TODO: As of yet no functionality)
            this.listeners = {};
            this.captures = {};
            this.active = true;
            /**
             * Simply calls [[addChild]]. This reference is here solely because appendChild is the equivalent method in DOM.
             * See and preferably use [[addChild]]
             */
            // tslint:disable-next-line: member-ordering
            this.appendChild = this.addChild;
            this.name = _name;
        }
        activate(_on) {
            this.active = _on;
            // TODO: check if COMPONENT_ACTIVATE/DEACTIVATE is the correct event to dispatch. Shouldn't it be something like NODE_ACTIVATE/DEACTIVATE?
            this.dispatchEvent(new Event(_on ? "componentActivate" /* COMPONENT_ACTIVATE */ : "componentDeactivate" /* COMPONENT_DEACTIVATE */));
        }
        get isActive() {
            return this.active;
        }
        /**
         * Shortcut to retrieve this nodes [[ComponentTransform]]
         */
        get cmpTransform() {
            return this.getComponents(FudgeCore.ComponentTransform)[0];
        }
        /**
         * Shortcut to retrieve the local [[Matrix4x4]] attached to this nodes [[ComponentTransform]]
         * Fails if no [[ComponentTransform]] is attached
         */
        get mtxLocal() {
            return this.cmpTransform.local;
        }
        // #region Scenetree
        /**
         * Returns a reference to this nodes parent node
         */
        getParent() {
            return this.parent;
        }
        /**
         * Traces back the ancestors of this node and returns the first
         */
        getAncestor() {
            let ancestor = this;
            while (ancestor.getParent())
                ancestor = ancestor.getParent();
            return ancestor;
        }
        /**
         * Returns the number of children attached to this
         */
        get nChildren() {
            return this.children.length;
        }
        /**
         * Returns child at the given index in the list of children
         */
        getChild(_index) {
            return this.children[_index];
        }
        /**
         * Returns a clone of the list of children
         */
        getChildren() {
            return this.children.slice(0);
        }
        /**
         * Returns an array of references to childnodes with the supplied name.
         */
        getChildrenByName(_name) {
            let found = [];
            found = this.children.filter((_node) => _node.name == _name);
            return found;
        }
        /**
         * Adds the given reference to a node to the list of children, if not already in
         * @throws Error when trying to add an ancestor of this
         */
        addChild(_child) {
            if (this.children.includes(_child))
                // _node is already a child of this
                return;
            let inAudioGraph = false;
            let graphListened = FudgeCore.AudioManager.default.getGraphListeningTo();
            let ancestor = this;
            while (ancestor) {
                ancestor.timestampUpdate = 0;
                inAudioGraph = inAudioGraph || (ancestor == graphListened);
                if (ancestor == _child)
                    throw (new Error("Cyclic reference prohibited in node hierarchy, ancestors must not be added as children"));
                else
                    ancestor = ancestor.parent;
            }
            let previousParent = _child.parent;
            if (previousParent)
                previousParent.removeChild(_child);
            this.children.push(_child);
            _child.parent = this;
            _child.dispatchEvent(new Event("childAppend" /* CHILD_APPEND */, { bubbles: true }));
            if (inAudioGraph)
                _child.broadcastEvent(new Event("childAppendToAudioGraph" /* CHILD_APPEND */));
        }
        /**
         * Removes the reference to the give node from the list of children
         * @param _child The node to be removed.
         */
        removeChild(_child) {
            let found = this.findChild(_child);
            if (found < 0)
                return;
            _child.dispatchEvent(new Event("childRemove" /* CHILD_REMOVE */, { bubbles: true }));
            if (this.isDescendantOf(FudgeCore.AudioManager.default.getGraphListeningTo()))
                _child.broadcastEvent(new Event("childRemoveFromAudioGraph" /* CHILD_REMOVE */));
            this.children.splice(found, 1);
            _child.parent = null;
        }
        /**
         * Returns the position of the node in the list of children or -1 if not found
         * @param _search The node to be found.
         */
        findChild(_search) {
            return this.children.indexOf(_search);
        }
        /**
         * Replaces a child node with another, preserving the position in the list of children
         * @param _replace The node to be replaced
         * @param _with The node to replace with
         */
        replaceChild(_replace, _with) {
            let found = this.findChild(_replace);
            if (found < 0)
                return false;
            let previousParent = _with.getParent();
            if (previousParent)
                previousParent.removeChild(_with);
            _replace.parent = null;
            this.children[found] = _with;
            _with.parent = this;
            _with.dispatchEvent(new Event("childAppend" /* CHILD_APPEND */, { bubbles: true }));
            if (this.isDescendantOf(FudgeCore.AudioManager.default.getGraphListeningTo()))
                _with.broadcastEvent(new Event("childAppendToAudioGraph" /* CHILD_APPEND */));
            return true;
        }
        /**
         * Generator yielding the node and all decendants in the graph below for iteration
         */
        get graph() {
            return this.getGraphGenerator();
        }
        isUpdated(_timestampUpdate) {
            return (this.timestampUpdate == _timestampUpdate);
        }
        isDescendantOf(_ancestor) {
            let node = this;
            while (node && node != _ancestor)
                node = node.parent;
            return (node != null);
        }
        /**
         * Applies a Mutator from [[Animation]] to all its components and transfers it to its children.
         * @param _mutator The mutator generated from an [[Animation]]
         */
        applyAnimation(_mutator) {
            if (_mutator.components) {
                for (let componentName in _mutator.components) {
                    if (this.components[componentName]) {
                        let mutatorOfComponent = _mutator.components;
                        for (let i in mutatorOfComponent[componentName]) {
                            if (this.components[componentName][+i]) {
                                let componentToMutate = this.components[componentName][+i];
                                let mutatorArray = mutatorOfComponent[componentName];
                                let mutatorWithComponentName = mutatorArray[+i];
                                for (let cname in mutatorWithComponentName) { // trick used to get the only entry in the list
                                    let mutatorToGive = mutatorWithComponentName[cname];
                                    componentToMutate.mutate(mutatorToGive);
                                }
                            }
                        }
                    }
                }
            }
            if (_mutator.children) {
                for (let i = 0; i < _mutator.children.length; i++) {
                    let name = _mutator.children[i]["∆í.Node"].name;
                    let childNodes = this.getChildrenByName(name);
                    for (let childNode of childNodes) {
                        childNode.applyAnimation(_mutator.children[i]["∆í.Node"]);
                    }
                }
            }
        }
        // #endregion
        // #region Components
        /**
         * Returns a list of all components attached to this node, independent of type.
         */
        getAllComponents() {
            let all = [];
            for (let type in this.components) {
                all = all.concat(this.components[type]);
            }
            return all;
        }
        /**
         * Returns a clone of the list of components of the given class attached to this node.
         * @param _class The class of the components to be found.
         */
        getComponents(_class) {
            return (this.components[_class.name] || []).slice(0);
        }
        /**
         * Returns the first compontent found of the given class attached this node or null, if list is empty or doesn't exist
         * @param _class The class of the components to be found.
         */
        getComponent(_class) {
            let list = this.components[_class.name];
            if (list)
                return list[0];
            return null;
        }
        /**
         * Adds the supplied component into the nodes component map.
         * @param _component The component to be pushed into the array.
         */
        addComponent(_component) {
            if (_component.getContainer() == this)
                return;
            let cmpList = this.components[_component.type];
            if (cmpList === undefined)
                this.components[_component.type] = [_component];
            else if (cmpList.length && _component.isSingleton)
                throw new Error("Component is marked singleton and can't be attached, no more than one allowed");
            else
                cmpList.push(_component);
            _component.setContainer(this);
            _component.dispatchEvent(new Event("componentAdd" /* COMPONENT_ADD */));
        }
        /**
         * Removes the given component from the node, if it was attached, and sets its parent to null.
         * @param _component The component to be removed
         * @throws Exception when component is not found
         */
        removeComponent(_component) {
            try {
                let componentsOfType = this.components[_component.type];
                let foundAt = componentsOfType.indexOf(_component);
                if (foundAt < 0)
                    return;
                _component.dispatchEvent(new Event("componentRemove" /* COMPONENT_REMOVE */));
                componentsOfType.splice(foundAt, 1);
                _component.setContainer(null);
            }
            catch (_error) {
                throw new Error(`Unable to remove component '${_component}'in node named '${this.name}'`);
            }
        }
        // #endregion
        // #region Serialization
        serialize() {
            let serialization = {
                name: this.name
            };
            let components = {};
            for (let type in this.components) {
                components[type] = [];
                for (let component of this.components[type]) {
                    // components[type].push(component.serialize());
                    components[type].push(FudgeCore.Serializer.serialize(component));
                }
            }
            serialization["components"] = components;
            let children = [];
            for (let child of this.children) {
                children.push(FudgeCore.Serializer.serialize(child));
            }
            serialization["children"] = children;
            this.dispatchEvent(new Event("nodeSerialized" /* NODE_SERIALIZED */));
            return serialization;
        }
        deserialize(_serialization) {
            this.name = _serialization.name;
            // this.parent = is set when the nodes are added
            // deserialize components first so scripts can react to children being appended
            for (let type in _serialization.components) {
                for (let serializedComponent of _serialization.components[type]) {
                    let deserializedComponent = FudgeCore.Serializer.deserialize(serializedComponent);
                    this.addComponent(deserializedComponent);
                }
            }
            for (let serializedChild of _serialization.children) {
                let deserializedChild = FudgeCore.Serializer.deserialize(serializedChild);
                this.appendChild(deserializedChild);
            }
            this.dispatchEvent(new Event("nodeDeserialized" /* NODE_DESERIALIZED */));
            return this;
        }
        // #endregion
        // #region Events
        /**
         * Adds an event listener to the node. The given handler will be called when a matching event is passed to the node.
         * Deviating from the standard EventTarget, here the _handler must be a function and _capture is the only option.
         * @param _type The type of the event, should be an enumerated value of NODE_EVENT, can be any string
         * @param _handler The function to call when the event reaches this node
         * @param _capture When true, the listener listens in the capture phase, when the event travels deeper into the hierarchy of nodes.
         */
        addEventListener(_type, _handler, _capture = false) {
            let listListeners = _capture ? this.captures : this.listeners;
            if (!listListeners[_type])
                listListeners[_type] = [];
            listListeners[_type].push(_handler);
        }
        /**
         * Removes an event listener from the node. The signatur must match the one used with addEventListener
         * @param _type The type of the event, should be an enumerated value of NODE_EVENT, can be any string
         * @param _handler The function to call when the event reaches this node
         * @param _capture When true, the listener listens in the capture phase, when the event travels deeper into the hierarchy of nodes.
         */
        removeEventListener(_type, _handler, _capture = false) {
            let listenersForType = _capture ? this.captures[_type] : this.listeners[_type];
            if (listenersForType)
                for (let i = listenersForType.length - 1; i >= 0; i--)
                    if (listenersForType[i] == _handler)
                        listenersForType.splice(i, 1);
        }
        /**
         * Dispatches a synthetic event to target. This implementation always returns true (standard: return true only if either event's cancelable attribute value is false or its preventDefault() method was not invoked)
         * The event travels into the hierarchy to this node dispatching the event, invoking matching handlers of the nodes ancestors listening to the capture phase,
         * than the matching handler of the target node in the target phase, and back out of the hierarchy in the bubbling phase, invoking appropriate handlers of the anvestors
         * @param _event The event to dispatch
         */
        dispatchEvent(_event) {
            let ancestors = [];
            let upcoming = this;
            // overwrite event target
            Object.defineProperty(_event, "target", { writable: true, value: this });
            // TODO: consider using Reflect instead of Object throughout. See also Render and Mutable...
            while (upcoming.parent)
                ancestors.push(upcoming = upcoming.parent);
            // capture phase
            Object.defineProperty(_event, "eventPhase", { writable: true, value: Event.CAPTURING_PHASE });
            for (let i = ancestors.length - 1; i >= 0; i--) {
                let ancestor = ancestors[i];
                Object.defineProperty(_event, "currentTarget", { writable: true, value: ancestor });
                let captures = ancestor.captures[_event.type] || [];
                for (let handler of captures)
                    handler(_event);
            }
            if (!_event.bubbles)
                return true;
            // target phase
            Object.defineProperty(_event, "eventPhase", { writable: true, value: Event.AT_TARGET });
            Object.defineProperty(_event, "currentTarget", { writable: true, value: this });
            let listeners = this.listeners[_event.type] || [];
            for (let handler of listeners)
                handler(_event);
            // bubble phase
            Object.defineProperty(_event, "eventPhase", { writable: true, value: Event.BUBBLING_PHASE });
            for (let i = 0; i < ancestors.length; i++) {
                let ancestor = ancestors[i];
                Object.defineProperty(_event, "currentTarget", { writable: true, value: ancestor });
                let listeners = ancestor.listeners[_event.type] || [];
                for (let handler of listeners)
                    handler(_event);
            }
            return true; //TODO: return a meaningful value, see documentation of dispatch event
        }
        /**
         * Broadcasts a synthetic event to this node and from there to all nodes deeper in the hierarchy,
         * invoking matching handlers of the nodes listening to the capture phase. Watch performance when there are many nodes involved
         * @param _event The event to broadcast
         */
        broadcastEvent(_event) {
            // overwrite event target and phase
            Object.defineProperty(_event, "eventPhase", { writable: true, value: Event.CAPTURING_PHASE });
            Object.defineProperty(_event, "target", { writable: true, value: this });
            this.broadcastEventRecursive(_event);
        }
        broadcastEventRecursive(_event) {
            // capture phase only
            Object.defineProperty(_event, "currentTarget", { writable: true, value: this });
            let captures = this.captures[_event.type] || [];
            for (let handler of captures)
                handler(_event);
            // appears to be slower, astonishingly...
            // captures.forEach(function (handler: Function): void {
            //     handler(_event);
            // });
            // same for children
            for (let child of this.children) {
                child.broadcastEventRecursive(_event);
            }
        }
        // #endregion
        *getGraphGenerator() {
            yield this;
            for (let child of this.children)
                yield* child.graph;
        }
    }
    FudgeCore.Node = Node;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A node managed by [[ResourceManager]] that functions as a template for [[NodeResourceInstance]]s
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Resource
     */
    class NodeResource extends FudgeCore.Node {
        constructor() {
            super(...arguments);
            this.idResource = undefined;
        }
    }
    FudgeCore.NodeResource = NodeResource;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * An instance of a [[NodeResource]].
     * This node keeps a reference to its resource an can thus optimize serialization
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Resource
     */
    class NodeResourceInstance extends FudgeCore.Node {
        constructor(_nodeResource) {
            super("NodeResourceInstance");
            /** id of the resource that instance was created from */
            // TODO: examine, if this should be a direct reference to the NodeResource, instead of the id
            this.idSource = undefined;
            if (_nodeResource)
                this.set(_nodeResource);
        }
        /**
         * Recreate this node from the [[NodeResource]] referenced
         */
        reset() {
            let resource = FudgeCore.ResourceManager.get(this.idSource);
            this.set(resource);
        }
        //TODO: optimize using the referenced NodeResource, serialize/deserialize only the differences
        serialize() {
            let serialization = super.serialize();
            serialization.idSource = this.idSource;
            return serialization;
        }
        deserialize(_serialization) {
            super.deserialize(_serialization);
            this.idSource = _serialization.idSource;
            return this;
        }
        /**
         * Set this node to be a recreation of the [[NodeResource]] given
         * @param _nodeResource
         */
        set(_nodeResource) {
            // TODO: examine, if the serialization should be stored in the NodeResource for optimization
            let serialization = FudgeCore.Serializer.serialize(_nodeResource);
            //Serializer.deserialize(serialization);
            for (let path in serialization) {
                this.deserialize(serialization[path]);
                break;
            }
            this.idSource = _nodeResource.idResource;
            this.dispatchEvent(new Event("nodeResourceInstantiated" /* NODERESOURCE_INSTANTIATED */));
        }
    }
    FudgeCore.NodeResourceInstance = NodeResourceInstance;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * @class Factory class to create closures.
     */
    class ClosureFactory {
        /**
         * Creates a closure for the given function type and the parameters.
         * @param _function the function type of the closure you want to create.
         * @param _parameters the parameters, which should be functions themselves, given to the created closure.
         * @returns
         */
        static getClosure(_function, _parameters /*, _inputFactors?: { [key: string]: number }, _randomNumbers?: number[]*/) {
            let closure = this.closures[_function];
            if (_function in this.closures)
                return closure(_parameters);
            else {
                FudgeCore.Debug.error(`"${_function}" is not an operation`);
                return null;
            }
        }
        // private static createClosures(): Map<CLOSURE_TYPE, Function> {
        //   return new Map<CLOSURE_TYPE, Function>([
        //     [CLOSURE_TYPE.ADDITION, this.createClosureAddition],
        //     [CLOSURE_TYPE.MULTIPLICATION, this.createClosureMultiplication],
        //     [CLOSURE_TYPE.DIVISION, this.createClosureDivision],
        //     [CLOSURE_TYPE.MODULO, this.createClosureModulo],
        //     [CLOSURE_TYPE.LINEAR, this.createClosureLinear],
        //     [CLOSURE_TYPE.POLYNOMIAL3, this.createClosurePolynomial3],
        //     [CLOSURE_TYPE.RANDOM, this.createClosureRandom],
        //   ]);
        // }
        /**
         * Calculates the sum of the given parameters.
         *  i.e. parameter[0] + ... + parameter[n]
         */
        static createClosureAddition(_parameters) {
            return function () {
                FudgeCore.Debug.group("ClosureAddition");
                let result = 0;
                for (const param of _parameters) {
                    result += param();
                }
                FudgeCore.Debug.groupEnd();
                return result;
            };
        }
        /**
     * Calculates the sum of the given parameters.
     *  i.e. parameter[0] + ... + parameter[n]
     */
        static createClosureSubtraction(_parameters) {
            return function () {
                FudgeCore.Debug.group("ClosureSubtraction");
                let result = _parameters[0]() - _parameters[1]();
                FudgeCore.Debug.groupEnd();
                return result;
            };
        }
        /**
          * Calculates the product of the given parameters.
          *   i.e. parameter[0] * ... * parameter[n]
          */
        static createClosureMultiplication(_parameters) {
            return function () {
                FudgeCore.Debug.log("ClosureMultiplication");
                let result = 1;
                for (const param of _parameters) {
                    result *= param();
                }
                FudgeCore.Debug.groupEnd();
                return result;
            };
        }
        /**
         * Calculates the division of the given parameters.
         *  i.e. parameter[0] / parameter[1]
         */
        static createClosureDivision(_parameters) {
            return function () {
                FudgeCore.Debug.group("ClosureDivision");
                let result = _parameters[0]() / _parameters[1]();
                FudgeCore.Debug.groupEnd();
                return result;
            };
        }
        /**
         * Calculates the modulo of the given parameters.
         *  i.e. parameter[0] % parameter[1]
         */
        static createClosureModulo(_parameters) {
            return function () {
                FudgeCore.Debug.group("ClosureModulo");
                let result = _parameters[0]() % _parameters[1]();
                FudgeCore.Debug.groupEnd();
                return result;
            };
        }
        /**
         * Interpolates a linear function between two given points.
         *  parameter[0] will be the input value for the function.
         *  parameter[1] - parameter[4] describe the points between which will be interpoleted
         */
        static createClosureLinear(_parameters) {
            let xStart = _parameters[1]();
            let xEnd = _parameters[2]();
            let yStart = _parameters[3]();
            let yEnd = _parameters[4]();
            return function () {
                FudgeCore.Debug.group("ClosureLinear");
                let x = _parameters[0]();
                let y = yStart + (x - xStart) * (yEnd - yStart) / (xEnd - xStart);
                FudgeCore.Debug.log(xEnd);
                FudgeCore.Debug.groupEnd();
                return y;
            };
        }
        /**
         * Creates a polynomial of third degree.
         *  parameter[0] will be the input value for the function.
         *  parameter[1] - parameter[4] representing a,b,c,d
         */
        static createClosurePolynomial3(_parameters) {
            let a = _parameters[1]();
            let b = _parameters[2]();
            let c = _parameters[3]();
            let d = _parameters[4]();
            return function () {
                FudgeCore.Debug.group("ClosurePolynomial3");
                let x = _parameters[0]();
                let y = a * Math.pow(x, 3) + b * Math.pow(x, 2) + c * x + d;
                FudgeCore.Debug.groupEnd();
                return y;
            };
        }
        /**
         * Creates a closure which will return the square root of the given parameter
         *  parameter[0] will be the input value for the function.
         */
        static createClosureSquareRoot(_parameters) {
            return function () {
                FudgeCore.Debug.group("ClosureSquareRoot");
                let x = _parameters[0]();
                let y = Math.sqrt(x);
                FudgeCore.Debug.groupEnd();
                return y;
            };
        }
        /**
         * Creates a closure which will return a number chosen from the given array of numbers.
         *  parameter[0] representing the index of the number which will be chosen.
         *  parameter[1] representing the array of random numbers to choose from.
         */
        static createClosureRandom(_parameters) {
            return function () {
                FudgeCore.Debug.group("ClosureRandom");
                let result = _parameters[1]()[_parameters[0]()];
                FudgeCore.Debug.groupEnd();
                return result;
            };
        }
        /**
         * Creates a closure which will return the input value
         */
        static createClosureIdentity(_parameters) {
            return function () {
                FudgeCore.Debug.group("ClosureIdentity");
                let result = _parameters[0]();
                FudgeCore.Debug.groupEnd();
                return result;
            };
        }
    }
    ClosureFactory.closures = {
        "addition": ClosureFactory.createClosureAddition,
        "multiplication": ClosureFactory.createClosureMultiplication,
        "division": ClosureFactory.createClosureDivision,
        "modulo": ClosureFactory.createClosureModulo,
        "linear": ClosureFactory.createClosureLinear,
        "polynomial": ClosureFactory.createClosurePolynomial3,
        "squareRoot": ClosureFactory.createClosureSquareRoot,
        "random": ClosureFactory.createClosureRandom,
        "identity": ClosureFactory.createClosureIdentity,
        "subtraction": ClosureFactory.createClosureSubtraction
    };
    FudgeCore.ClosureFactory = ClosureFactory;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ParticleEffectImporter {
        constructor(_storedValues, _randomNumbers) {
            this.storedValues = _storedValues;
            this.randomNumbers = _randomNumbers;
        }
        importFile(_filename) {
            //TODO: import file
            let file = new XMLHttpRequest();
            file.open("GET", _filename, false);
            file.send();
            let data = JSON.parse(file.responseText);
            return this.parseFile(data);
        }
        /**
         * Parse the data from json file and return a particle effect definition
         * @param _data the data to parse
         * @returns a definition of the particle effect containing the closure for translation, rotation etc.
         */
        parseFile(_data) {
            // console.log(_data);
            // pre parse storage and initialize stored values
            this.preParseStorage(_data["storage"]);
            this.parseDataRecursively(_data);
            return _data;
        }
        /**
         * Create entries in stored values for each defined storage closure. Predefined values (time, index...) and previously defined ones (in json) can not be overwritten.
         * @param _data The paticle data to parse
         */
        preParseStorage(_data) {
            for (const storagePartition in _data) {
                let storage = _data[storagePartition];
                for (const storageValue in storage) {
                    if (storageValue in this.storedValues) {
                        throw `"${storageValue}" is already defined`;
                    }
                    else
                        this.storedValues[storageValue] = 0;
                }
            }
        }
        /**
         * Parse the given effect data recursivley. The hierachy of the json file will be kept. Constants, variables("time") and functions definitions will be replaced with functions.
         * @param _data The effect data to parse recursivley
         */
        parseDataRecursively(_data) {
            for (const key in _data) {
                let value = _data[key];
                if (typeof value === "string" || typeof value === "number" || "function" in value)
                    _data[key] = this.parseClosure(value);
                else {
                    this.parseDataRecursively(value);
                }
            }
        }
        /**
         * Parse the given closure data recursivley. Returns a function depending on the closure data.
         * @param _data The closure data to parse recursively
         */
        parseClosure(_data) {
            switch (typeof _data) {
                case "object":
                    let parameters = [];
                    for (let param of _data.parameters) {
                        parameters.push(this.parseClosure(param));
                    }
                    // random closure needs to have the random numbers array as a parameter
                    if (_data.function == "random") {
                        parameters.push(() => {
                            return this.randomNumbers;
                        });
                    }
                    let closure = FudgeCore.ClosureFactory.getClosure(_data.function, parameters);
                    return closure;
                case "string":
                    if (_data in this.storedValues) {
                        return () => {
                            FudgeCore.Debug.log("Variable", `"${_data}"`, this.storedValues[_data]);
                            return this.storedValues[_data];
                        };
                    }
                    else {
                        throw `"${_data}" is not defined`;
                    }
                case "number":
                    return function () {
                        FudgeCore.Debug.log("Constant", _data);
                        return _data;
                    };
            }
        }
    }
    FudgeCore.ParticleEffectImporter = ParticleEffectImporter;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class Ray {
        constructor(_direction = FudgeCore.Vector3.Z(-1), _origin = FudgeCore.Vector3.ZERO(), _length = 1) {
            this.origin = _origin;
            this.direction = _direction;
            this.length = _length;
        }
    }
    FudgeCore.Ray = Ray;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class RayHit {
        constructor(_node = null, _face = 0, _zBuffer = 0) {
            this.node = _node;
            this.face = _face;
            this.zBuffer = _zBuffer;
        }
    }
    FudgeCore.RayHit = RayHit;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * The main interface to the render engine, here WebGL, which is used mainly in the superclass [[RenderOperator]]
     */
    class RenderManager extends FudgeCore.RenderOperator {
        /**
         * Clear the offscreen renderbuffer with the given [[Color]]
         */
        static clear(_color = null) {
            RenderManager.crc3.clearColor(_color.r, _color.g, _color.b, _color.a);
            RenderManager.crc3.clear(WebGL2RenderingContext.COLOR_BUFFER_BIT | WebGL2RenderingContext.DEPTH_BUFFER_BIT);
        }
        /**
         * Reset the offscreen framebuffer to the original RenderingContext
         */
        static resetFrameBuffer(_color = null) {
            RenderManager.crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, null);
        }
        //#region RayCast & Picking
        /**
         * Draws the graph for RayCasting starting with the given [[Node]] using the camera given [[ComponentCamera]].
         */
        static drawGraphForRayCast(_node, _cmpCamera) {
            RenderManager.pickBuffers = [];
            //TODO: examine, why switching blendFunction is necessary 
            FudgeCore.RenderOperator.crc3.blendFunc(1, 0);
            RenderManager.drawGraph(_node, _cmpCamera, RenderManager.drawNodeForRayCast);
            FudgeCore.RenderOperator.crc3.blendFunc(WebGL2RenderingContext.DST_ALPHA, WebGL2RenderingContext.ONE_MINUS_DST_ALPHA);
            RenderManager.resetFrameBuffer();
            return RenderManager.pickBuffers;
        }
        /**
         * Browses through the buffers (previously created with [[drawGraphForRayCast]]) of the size given
         * and returns an unsorted list of the values at the given position, representing node-ids and depth information as [[RayHit]]s
         */
        static pickNodeAt(_pos, _pickBuffers, _rect) {
            let hits = [];
            for (let pickBuffer of _pickBuffers) {
                RenderManager.crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, pickBuffer.frameBuffer);
                // TODO: instead of reading all data and afterwards pick the pixel, read only the pixel!
                let data = new Uint8Array(_rect.width * _rect.height * 4);
                RenderManager.crc3.readPixels(0, 0, _rect.width, _rect.height, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.UNSIGNED_BYTE, data);
                let pixel = _pos.x + _rect.width * _pos.y;
                // let zBuffer: number = data[4 * pixel + 1] + data[4 * pixel + 2] / 256;
                let zBuffer = data[4 * pixel + 0];
                let hit = new FudgeCore.RayHit(pickBuffer.node, 0, zBuffer);
                hits.push(hit);
            }
            return hits;
        }
        //#endregion
        //#region Drawing
        /**
         * The main rendering function to be called from [[Viewport]].
         * Draws the graph starting with the given [[Node]] using the camera given [[ComponentCamera]].
         */
        static drawGraph(_node, _cmpCamera, _drawNode = RenderManager.drawNode) {
            let matrix = FudgeCore.Matrix4x4.IDENTITY();
            if (_node.getParent())
                matrix = _node.getParent().mtxWorld;
            RenderManager.setupTransformAndLights(_node, matrix);
            RenderManager.drawGraphRecursive(_node, _cmpCamera, _drawNode);
        }
        /**
         * Recursivly iterates over the graph and renders each node and all successors with the given render function
         */
        static drawGraphRecursive(_node, _cmpCamera, _drawNode = RenderManager.drawNode) {
            // TODO: see if third parameter _world?: Matrix4x4 would be usefull
            if (!_node.isActive)
                return;
            let finalTransform;
            let cmpMesh = _node.getComponent(FudgeCore.ComponentMesh);
            if (cmpMesh) // TODO: careful when using particlesystem, pivot must not change node position
                finalTransform = FudgeCore.Matrix4x4.MULTIPLICATION(_node.mtxWorld, cmpMesh.pivot);
            else
                finalTransform = _node.mtxWorld; // caution, RenderManager is a reference...
            // multiply camera matrix
            // TODO: this needs to be done extra for every single particle
            let projection = FudgeCore.Matrix4x4.MULTIPLICATION(_cmpCamera.ViewProjectionMatrix, finalTransform);
            // TODO: create drawNode method for particle system using _node.mtxWorld instead of finalTransform
            let cmpParticleSystem = _node.getComponent(FudgeCore.ComponentParticleSystem);
            if (cmpParticleSystem)
                FudgeCore.RenderParticles.drawParticles(_node, _node.mtxWorld, _cmpCamera);
            else
                _drawNode(_node, finalTransform, projection);
            for (let name in _node.getChildren()) {
                let childNode = _node.getChildren()[name];
                RenderManager.drawGraphRecursive(childNode, _cmpCamera, _drawNode); //, world);
            }
            // TODO: this should also be done per particle
            FudgeCore.Recycler.store(projection);
            if (finalTransform != _node.mtxWorld)
                FudgeCore.Recycler.store(finalTransform);
        }
        /**
         * The standard render function for drawing a single node
         */
        static drawNode(_node, _finalTransform, _projection, _lights) {
            try {
                let cmpMaterial = _node.getComponent(FudgeCore.ComponentMaterial);
                let mesh = _node.getComponent(FudgeCore.ComponentMesh).mesh;
                // RenderManager.setLightsInShader(shader, _lights);
                RenderManager.draw(mesh, cmpMaterial, _finalTransform, _projection); //, _lights);
            }
            catch (_error) {
                // Debug.error(_error);
            }
        }
        //#endregion
        //#region Picking
        /**
         * The render function for drawing buffers for picking. Renders each node on a dedicated buffer with id and depth values instead of colors
         */
        static drawNodeForRayCast(_node, _finalTransform, _projection, _lights) {
            // TODO: look into SSBOs!
            let target = RenderManager.getRayCastTexture();
            const framebuffer = RenderManager.crc3.createFramebuffer();
            // render to our targetTexture by binding the framebuffer
            RenderManager.crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, framebuffer);
            // attach the texture as the first color attachment
            const attachmentPoint = WebGL2RenderingContext.COLOR_ATTACHMENT0;
            RenderManager.crc3.framebufferTexture2D(WebGL2RenderingContext.FRAMEBUFFER, attachmentPoint, WebGL2RenderingContext.TEXTURE_2D, target, 0);
            try {
                let mesh = _node.getComponent(FudgeCore.ComponentMesh).mesh;
                FudgeCore.ShaderRayCast.useProgram();
                let pickBuffer = { node: _node, texture: target, frameBuffer: framebuffer };
                RenderManager.pickBuffers.push(pickBuffer);
                mesh.useRenderBuffers(FudgeCore.ShaderRayCast, _finalTransform, _projection, RenderManager.pickBuffers.length);
                FudgeCore.RenderOperator.crc3.drawElements(WebGL2RenderingContext.TRIANGLES, mesh.renderBuffers.nIndices, WebGL2RenderingContext.UNSIGNED_SHORT, 0);
            }
            catch (_error) {
                //
            }
            // make texture available to onscreen-display
        }
        /**
         * Creates a texture buffer to be uses as pick-buffer
         */
        static getRayCastTexture() {
            // create to render to
            const targetTextureWidth = RenderManager.getViewportRectangle().width;
            const targetTextureHeight = RenderManager.getViewportRectangle().height;
            const targetTexture = RenderManager.crc3.createTexture();
            RenderManager.crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, targetTexture);
            {
                const internalFormat = WebGL2RenderingContext.RGBA8;
                const format = WebGL2RenderingContext.RGBA;
                const type = WebGL2RenderingContext.UNSIGNED_BYTE;
                RenderManager.crc3.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, internalFormat, targetTextureWidth, targetTextureHeight, 0, format, type, null);
                // set the filtering so we don't need mips
                RenderManager.crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.LINEAR);
                RenderManager.crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_S, WebGL2RenderingContext.CLAMP_TO_EDGE);
                RenderManager.crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_T, WebGL2RenderingContext.CLAMP_TO_EDGE);
            }
            return targetTexture;
        }
        //#endregion
        //#region Transformation & Lights
        /**
         * Recursively iterates over the graph starting with the node given, recalculates all world transforms,
         * collects all lights and feeds all shaders used in the graph with these lights
         */
        static setupTransformAndLights(_node, _world = FudgeCore.Matrix4x4.IDENTITY(), _lights = new Map(), _shadersUsed = null) {
            let firstLevel = (_shadersUsed == null);
            if (firstLevel)
                _shadersUsed = [];
            let world = _world;
            let cmpTransform = _node.cmpTransform;
            if (cmpTransform)
                world = FudgeCore.Matrix4x4.MULTIPLICATION(_world, cmpTransform.local);
            _node.mtxWorld = world;
            _node.timestampUpdate = RenderManager.timestampUpdate;
            let cmpLights = _node.getComponents(FudgeCore.ComponentLight);
            for (let cmpLight of cmpLights) {
                let type = cmpLight.light.getType();
                let lightsOfType = _lights.get(type);
                if (!lightsOfType) {
                    lightsOfType = [];
                    _lights.set(type, lightsOfType);
                }
                lightsOfType.push(cmpLight);
            }
            let cmpMaterial = _node.getComponent(FudgeCore.ComponentMaterial);
            if (cmpMaterial) {
                let shader = cmpMaterial.material.getShader();
                if (_shadersUsed.indexOf(shader) < 0)
                    _shadersUsed.push(shader);
            }
            for (let child of _node.getChildren()) {
                RenderManager.setupTransformAndLights(child, world, _lights, _shadersUsed);
            }
            if (firstLevel)
                for (let shader of _shadersUsed)
                    RenderManager.setLightsInShader(shader, _lights);
        }
        /**
         * Set light data in shaders
         */
        static setLightsInShader(_shader, _lights) {
            _shader.useProgram();
            let uni = _shader.uniforms;
            // Ambient
            let ambient = uni["u_ambient.color"];
            if (ambient) {
                let cmpLights = _lights.get(FudgeCore.LightAmbient);
                if (cmpLights) {
                    // TODO: add up ambient lights to a single color
                    let result = new FudgeCore.Color(0, 0, 0, 1);
                    for (let cmpLight of cmpLights)
                        result.add(cmpLight.light.color);
                    FudgeCore.RenderOperator.crc3.uniform4fv(ambient, result.getArray());
                }
            }
            // Directional
            let nDirectional = uni["u_nLightsDirectional"];
            if (nDirectional) {
                let cmpLights = _lights.get(FudgeCore.LightDirectional);
                if (cmpLights) {
                    let n = cmpLights.length;
                    FudgeCore.RenderOperator.crc3.uniform1ui(nDirectional, n);
                    for (let i = 0; i < n; i++) {
                        let cmpLight = cmpLights[i];
                        FudgeCore.RenderOperator.crc3.uniform4fv(uni[`u_directional[${i}].color`], cmpLight.light.color.getArray());
                        let direction = FudgeCore.Vector3.Z();
                        direction.transform(cmpLight.pivot, false);
                        direction.transform(cmpLight.getContainer().mtxWorld);
                        FudgeCore.RenderOperator.crc3.uniform3fv(uni[`u_directional[${i}].direction`], direction.get());
                    }
                }
            }
        }
    }
    RenderManager.rectClip = new FudgeCore.Rectangle(-1, 1, 2, -2);
    FudgeCore.RenderManager = RenderManager;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class RenderParticles extends FudgeCore.RenderManager {
        static drawParticles(_node, _systemTransform, _cmpCamera) {
            let cmpParticleSystem = _node.getComponent(FudgeCore.ComponentParticleSystem);
            let cmpMaterial = _node.getComponent(FudgeCore.ComponentMaterial);
            let cmpMesh = _node.getComponent(FudgeCore.ComponentMesh);
            let mesh = cmpMesh.mesh;
            let shader = cmpMaterial.material.getShader();
            let coat = cmpMaterial.material.getCoat();
            shader.useProgram();
            let storedValues = cmpParticleSystem.storedValues;
            let effectData = cmpParticleSystem.effectData;
            let storageData = effectData["storage"];
            let transformData = effectData["transformations"];
            let transformDataLocal = transformData["local"];
            let transformDataWorld = transformData["world"];
            let componentsData = effectData["components"];
            // get relevant components
            let components = [];
            for (const componentClass in componentsData) {
                components.push(_node.getComponent(globalThis["FudgeCore"][componentClass]));
            }
            let componentsLength = components.length;
            // save their state
            let componentMutators = [];
            for (let i = 0; i < componentsLength; i++) {
                componentMutators.push(components[i].getMutator());
            }
            let particleStorage;
            // evaluate update storage
            if (storageData) {
                cmpParticleSystem.evaluateClosureStorage(storageData["update"]);
                particleStorage = storageData["particle"];
            }
            let cameraViewProjectionMatrix = _cmpCamera.ViewProjectionMatrix;
            // let meshPivotScaling: Vector3 = cmpMesh.pivot.scaling;
            for (let i = 0, length = storedValues["size"]; i < length; i++) {
                storedValues["index"] = i;
                // evaluate particle storage
                cmpParticleSystem.evaluateClosureStorage(particleStorage);
                // apply transformations
                let finalTransform = FudgeCore.Matrix4x4.IDENTITY();
                // for (const key in transformDataLocal) {
                //   // TODO: change this somehow... get mutators out of vectors and change them + get correct vector
                //   let transformMatrix: Matrix4x4 = Matrix4x4.IDENTITY();
                //   let mutator: Mutator = {};
                //   mutator[key] = this.getMutatorFor(transformDataLocal[key]);
                //   transformMatrix.mutate(mutator);
                //   finalTransform.multiply(transformMatrix);
                //   Recycler.store(transformMatrix);
                // }
                finalTransform.mutate(this.getMutatorFor(transformDataLocal));
                for (const key in transformDataLocal) {
                    // TODO: change this somehow... get mutators out of vectors and change them + get correct vector
                    let transformVector = key == "scale" ? _systemTransform.scaling : FudgeCore.Vector3.ZERO();
                    transformVector.mutate(this.getMutatorFor(transformDataLocal[key]));
                    finalTransform[key](transformVector);
                    FudgeCore.Recycler.store(transformVector);
                }
                let worldTransform = FudgeCore.Matrix4x4.IDENTITY();
                for (const key in transformDataWorld) {
                    let transformVector = FudgeCore.Vector3.ZERO();
                    transformVector.mutate(this.getMutatorFor(transformDataWorld[key]));
                    worldTransform[key](transformVector);
                    FudgeCore.Recycler.store(transformVector);
                }
                // apply system transformation
                // finalTransform.scale(meshPivotScaling); // this is slower than matrix multiplication
                finalTransform.multiply(cmpMesh.pivot);
                finalTransform.multiply(_systemTransform, true);
                finalTransform.multiply(worldTransform, true);
                // TODO: optimize
                // transformation.showTo(Matrix4x4.MULTIPLICATION(_cmpCamera.getContainer().mtxWorld, _cmpCamera.pivot).translation);
                // evaluate component data
                for (let i = 0; i < componentsLength; i++) {
                    components[i].mutate(this.getMutatorFor(componentsData[components[i].type]));
                }
                // render
                let projection = FudgeCore.Matrix4x4.MULTIPLICATION(cameraViewProjectionMatrix, finalTransform);
                mesh.useRenderBuffers(shader, finalTransform, projection);
                coat.useRenderData(shader, cmpMaterial);
                FudgeCore.RenderOperator.crc3.drawElements(WebGL2RenderingContext.TRIANGLES, mesh.renderBuffers.nIndices, WebGL2RenderingContext.UNSIGNED_SHORT, 0);
                FudgeCore.Recycler.store(projection);
                FudgeCore.Recycler.store(worldTransform);
                FudgeCore.Recycler.store(finalTransform);
            }
            // restore component state
            for (let i = 0; i < componentsLength; i++) {
                components[i].mutate(componentMutators[i]);
            }
        }
        // TODO: don't create new Mutators all the time
        static getMutatorFor(_effectData) {
            let mutator = {};
            for (const attribute in _effectData) {
                let value = _effectData[attribute];
                if (typeof value === "function") {
                    mutator[attribute] = value();
                }
                else {
                    mutator[attribute] = this.getMutatorFor(value);
                }
            }
            return mutator;
        }
        static evaluateMutator(_effectData, _mutator) {
            for (const attribute in _effectData) {
                let value = _effectData[attribute];
                if (typeof value === "function") {
                    _mutator[attribute] = value();
                }
                else {
                    this.evaluateMutator(value, _mutator[attribute]);
                }
            }
        }
    }
    FudgeCore.RenderParticles = RenderParticles;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="../Coat/Coat.ts"/>
var FudgeCore;
// / <reference path="../Coat/Coat.ts"/>
(function (FudgeCore) {
    /**
     * Static superclass for the representation of WebGl shaderprograms.
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    var Shader_1;
    // TODO: define attribute/uniforms as layout and use those consistently in shaders
    let Shader = Shader_1 = class Shader {
        /** The type of coat that can be used with this shader to create a material */
        static getCoat() { return null; }
        static getVertexShaderSource() { return null; }
        static getFragmentShaderSource() { return null; }
        static deleteProgram() { }
        static useProgram() { }
        static createProgram() { }
        static registerSubclass(_subclass) { return Shader_1.subclasses.push(_subclass) - 1; }
    };
    /** refers back to this class from any subclass e.g. in order to find compatible other resources*/
    Shader.baseClass = Shader_1;
    /** list of all the subclasses derived from this class, if they registered properly*/
    Shader.subclasses = [];
    Shader = Shader_1 = __decorate([
        FudgeCore.RenderInjectorShader.decorate
    ], Shader);
    FudgeCore.Shader = Shader;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    var ShaderFlat_1;
    /**
     * Single color shading
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    let ShaderFlat = ShaderFlat_1 = class ShaderFlat extends FudgeCore.Shader {
        static getCoat() {
            return FudgeCore.CoatColored;
        }
        static getVertexShaderSource() {
            return `#version 300 es

                    struct LightAmbient {
                        vec4 color;
                    };
                    struct LightDirectional {
                        vec4 color;
                        vec3 direction;
                    };

                    const uint MAX_LIGHTS_DIRECTIONAL = 10u;

                    in vec3 a_position;
                    in vec3 a_normal;
                    uniform mat4 u_world;
                    uniform mat4 u_projection;

                    uniform LightAmbient u_ambient;
                    uniform uint u_nLightsDirectional;
                    uniform LightDirectional u_directional[MAX_LIGHTS_DIRECTIONAL];
                    flat out vec4 v_color;
                    
                    void main() {   
                        gl_Position = u_projection * vec4(a_position, 1.0);
                        vec3 normal = normalize(mat3(u_world) * a_normal);

                        v_color = u_ambient.color;
                        for (uint i = 0u; i < u_nLightsDirectional; i++) {
                            float illumination = -dot(normal, u_directional[i].direction);
                            if (illumination > 0.0f)
                                v_color += illumination * u_directional[i].color; // vec4(1,1,1,1); // 
                        }
                        v_color.a = 1.0;
                    }`;
        }
        static getFragmentShaderSource() {
            return `#version 300 es
                    precision mediump float;

                    uniform vec4 u_color;
                    flat in vec4 v_color;
                    out vec4 frag;
                    
                    void main() {
                        frag = u_color * v_color;
                    }`;
        }
    };
    ShaderFlat.iSubclass = FudgeCore.Shader.registerSubclass(ShaderFlat_1);
    ShaderFlat = ShaderFlat_1 = __decorate([
        FudgeCore.RenderInjectorShader.decorate
    ], ShaderFlat);
    FudgeCore.ShaderFlat = ShaderFlat;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Matcap (Material Capture) shading. The texture provided by the coat is used as a matcap material.
     * Implementation based on https://www.clicktorelease.com/blog/creating-spherical-environment-mapping-shader/
     * @authors Simon Storl-Schulke, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ShaderMatCap extends FudgeCore.Shader {
        static getCoat() {
            return FudgeCore.CoatMatCap;
        }
        static getVertexShaderSource() {
            return `#version 300 es

                    in vec3 a_position;
                    in vec3 a_normal;

                    uniform mat4 u_projection;

                    out vec2 texcoords_smooth;
                    flat out vec2 texcoords_flat;

                    void main() {
                        texcoords_smooth = normalize(mat3(u_projection) * a_normal).xy * 0.5 - 0.5;
                        texcoords_flat = texcoords_smooth;
                        gl_Position = u_projection * vec4(a_position, 1.0);
                    }`;
        }
        static getFragmentShaderSource() {
            return `#version 300 es
                    precision mediump float;
                    
                    uniform vec4 u_tint_color;
                    uniform int shade_smooth;
                    uniform sampler2D u_texture;
                    
                    in vec2 texcoords_smooth;
                    flat in vec2 texcoords_flat;

                    out vec4 frag;

                    void main() {

                        if (shade_smooth > 0) {
                          frag = u_tint_color * texture(u_texture, texcoords_smooth) * 2.0;
                        } else {
                          frag = u_tint_color * texture(u_texture, texcoords_flat) * 2.0;
                        }
                    }`;
        }
    }
    ShaderMatCap.iSubclass = FudgeCore.Shader.registerSubclass(ShaderMatCap);
    FudgeCore.ShaderMatCap = ShaderMatCap;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Renders for Raycasting
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ShaderRayCast extends FudgeCore.Shader {
        static getVertexShaderSource() {
            return `#version 300 es

                    in vec3 a_position;
                    uniform mat4 u_projection;
                    
                    void main() {   
                        gl_Position = u_projection * vec4(a_position, 1.0);
                    }`;
        }
        static getFragmentShaderSource() {
            return `#version 300 es
                    precision mediump float;
                    precision highp int;
                    
                    uniform int u_id;
                    out vec4 frag;
                    
                    void main() {
                       float id = float(u_id)/ 256.0;
                       float upperbyte = trunc(gl_FragCoord.z * 256.0) / 256.0;
                       float lowerbyte = fract(gl_FragCoord.z * 256.0);
                       frag = vec4(gl_FragCoord.z, upperbyte, lowerbyte, 1.0);
                    }`;
        }
    }
    FudgeCore.ShaderRayCast = ShaderRayCast;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Textured shading
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ShaderTexture extends FudgeCore.Shader {
        static getCoat() {
            return FudgeCore.CoatTextured;
        }
        static getVertexShaderSource() {
            return `#version 300 es

                in vec3 a_position;
                in vec2 a_textureUVs;
                uniform mat4 u_projection;
                uniform mat3 u_pivot;
                out vec2 v_textureUVs;

                void main() {  
                    gl_Position = u_projection * vec4(a_position, 1.0);
                    // v_textureUVs = a_textureUVs;
                    v_textureUVs = vec2(u_pivot * vec3(a_textureUVs, 1.0)).xy;
                }`;
        }
        static getFragmentShaderSource() {
            return `#version 300 es
                precision mediump float;
                
                in vec2 v_textureUVs;
                uniform vec4 u_color;
                uniform sampler2D u_texture;
                // uniform vec4 u_colorBackground; // maybe a material background color can shine through... but where and with which intensity?
                out vec4 frag;
                
                void main() {
                    vec4 colorTexture = texture(u_texture, v_textureUVs);
                    frag = u_color * colorTexture;
                    //frag = vec4(colorTexture.r * 1.0, colorTexture.g * 0.4, colorTexture.b * 0.1, colorTexture.a * 1.5);//u_color;
                    //frag = colorTexture;
                    if (frag.a < 0.01)
                      discard;
            }`;
        }
    }
    ShaderTexture.iSubclass = FudgeCore.Shader.registerSubclass(ShaderTexture);
    FudgeCore.ShaderTexture = ShaderTexture;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Single color shading
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ShaderUniColor extends FudgeCore.Shader {
        static getCoat() {
            return FudgeCore.CoatColored;
        }
        static getVertexShaderSource() {
            return `#version 300 es

                    in vec3 a_position;
                    uniform mat4 u_projection;
                    
                    void main() {   
                        gl_Position = u_projection * vec4(a_position, 1.0);
                    }`;
        }
        static getFragmentShaderSource() {
            return `#version 300 es
                    precision mediump float;
                    
                    uniform vec4 u_color;
                    out vec4 frag;
                    
                    void main() {
                       frag = u_color;
                    }`;
        }
    }
    ShaderUniColor.iSubclass = FudgeCore.Shader.registerSubclass(ShaderUniColor);
    FudgeCore.ShaderUniColor = ShaderUniColor;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Baseclass for different kinds of textures.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Texture extends FudgeCore.Mutable {
        reduceMutator() { }
    }
    FudgeCore.Texture = Texture;
    /**
     * Texture created from an existing image
     */
    class TextureImage extends Texture {
        constructor() {
            super(...arguments);
            this.image = null;
        }
    }
    FudgeCore.TextureImage = TextureImage;
    /**
     * Texture created from a canvas
     */
    class TextureCanvas extends Texture {
    }
    FudgeCore.TextureCanvas = TextureCanvas;
    /**
     * Texture created from a FUDGE-Sketch
     */
    class TextureSketch extends TextureCanvas {
    }
    FudgeCore.TextureSketch = TextureSketch;
    /**
     * Texture created from an HTML-page
     */
    class TextureHTML extends TextureCanvas {
    }
    FudgeCore.TextureHTML = TextureHTML;
})(FudgeCore || (FudgeCore = {}));
// /<reference path="../Event/Event.ts"/>
// /<reference path="../Time/Time.ts"/>
var FudgeCore;
// /<reference path="../Event/Event.ts"/>
// /<reference path="../Time/Time.ts"/>
(function (FudgeCore) {
    /**
     * Determines the mode a loop runs in
     */
    let LOOP_MODE;
    (function (LOOP_MODE) {
        /** Loop cycles controlled by window.requestAnimationFrame */
        LOOP_MODE["FRAME_REQUEST"] = "frameRequest";
        /** Loop cycles with the given framerate in [[Time]].game */
        LOOP_MODE["TIME_GAME"] = "timeGame";
        /** Loop cycles with the given framerate in realtime, independent of [[Time]].game */
        LOOP_MODE["TIME_REAL"] = "timeReal";
    })(LOOP_MODE = FudgeCore.LOOP_MODE || (FudgeCore.LOOP_MODE = {}));
    /**
     * Core loop of a Fudge application. Initializes automatically and must be started explicitly.
     * It then fires [[EVENT]].LOOP\_FRAME to all added listeners at each frame
     *
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Loop extends FudgeCore.EventTargetStatic {
        /**
         * Starts the loop with the given mode and fps
         * @param _mode
         * @param _fps Is only applicable in TIME-modes
         * @param _syncWithAnimationFrame Experimental and only applicable in TIME-modes. Should defer the loop-cycle until the next possible animation frame.
         */
        static start(_mode = LOOP_MODE.FRAME_REQUEST, _fps = 60, _syncWithAnimationFrame = false) {
            Loop.stop();
            Loop.timeStartGame = FudgeCore.Time.game.get();
            Loop.timeStartReal = performance.now();
            Loop.timeLastFrameGame = Loop.timeStartGame;
            Loop.timeLastFrameReal = Loop.timeStartReal;
            Loop.fpsDesired = (_mode == LOOP_MODE.FRAME_REQUEST) ? 60 : _fps;
            Loop.framesToAverage = Loop.fpsDesired;
            Loop.timeLastFrameGameAvg = Loop.timeLastFrameRealAvg = 1000 / Loop.fpsDesired;
            Loop.mode = _mode;
            Loop.syncWithAnimationFrame = _syncWithAnimationFrame;
            let log = `Loop starting in mode ${Loop.mode}`;
            if (Loop.mode != LOOP_MODE.FRAME_REQUEST)
                log += ` with attempted ${_fps} fps`;
            FudgeCore.Debug.fudge(log);
            switch (_mode) {
                case LOOP_MODE.FRAME_REQUEST:
                    Loop.loopFrame();
                    break;
                case LOOP_MODE.TIME_REAL:
                    Loop.idIntervall = window.setInterval(Loop.loopTime, 1000 / Loop.fpsDesired);
                    Loop.loopTime();
                    break;
                case LOOP_MODE.TIME_GAME:
                    Loop.idIntervall = FudgeCore.Time.game.setTimer(1000 / Loop.fpsDesired, 0, Loop.loopTime);
                    Loop.loopTime();
                    break;
                default:
                    break;
            }
            Loop.running = true;
        }
        /**
         * Stops the loop
         */
        static stop() {
            if (!Loop.running)
                return;
            switch (Loop.mode) {
                case LOOP_MODE.FRAME_REQUEST:
                    window.cancelAnimationFrame(Loop.idRequest);
                    break;
                case LOOP_MODE.TIME_REAL:
                    window.clearInterval(Loop.idIntervall);
                    window.cancelAnimationFrame(Loop.idRequest);
                    break;
                case LOOP_MODE.TIME_GAME:
                    FudgeCore.Time.game.deleteTimer(Loop.idIntervall);
                    window.cancelAnimationFrame(Loop.idRequest);
                    break;
                default:
                    break;
            }
            Loop.running = false;
            FudgeCore.Debug.fudge("Loop stopped!");
        }
        static getFpsGameAverage() {
            return 1000 / Loop.timeLastFrameGameAvg;
        }
        static getFpsRealAverage() {
            return 1000 / Loop.timeLastFrameRealAvg;
        }
        static loop() {
            let time;
            time = performance.now();
            Loop.timeFrameReal = time - Loop.timeLastFrameReal;
            Loop.timeLastFrameReal = time;
            time = FudgeCore.Time.game.get();
            Loop.timeFrameGame = time - Loop.timeLastFrameGame;
            Loop.timeLastFrameGame = time;
            Loop.timeLastFrameGameAvg = ((Loop.framesToAverage - 1) * Loop.timeLastFrameGameAvg + Loop.timeFrameGame) / Loop.framesToAverage;
            Loop.timeLastFrameRealAvg = ((Loop.framesToAverage - 1) * Loop.timeLastFrameRealAvg + Loop.timeFrameReal) / Loop.framesToAverage;
            // TODO: consider LoopEvent which conveys information such as timeElapsed etc...
            let event = new Event("loopFrame" /* LOOP_FRAME */);
            Loop.targetStatic.dispatchEvent(event);
        }
        static loopFrame() {
            Loop.loop();
            Loop.idRequest = window.requestAnimationFrame(Loop.loopFrame);
        }
        static loopTime() {
            if (Loop.syncWithAnimationFrame)
                Loop.idRequest = window.requestAnimationFrame(Loop.loop);
            else
                Loop.loop();
        }
    }
    /** The gametime the loop was started, overwritten at each start */
    Loop.timeStartGame = 0;
    /** The realtime the loop was started, overwritten at each start */
    Loop.timeStartReal = 0;
    /** The gametime elapsed since the last loop cycle */
    Loop.timeFrameGame = 0;
    /** The realtime elapsed since the last loop cycle */
    Loop.timeFrameReal = 0;
    Loop.timeLastFrameGame = 0;
    Loop.timeLastFrameReal = 0;
    Loop.timeLastFrameGameAvg = 0;
    Loop.timeLastFrameRealAvg = 0;
    Loop.running = false;
    Loop.mode = LOOP_MODE.FRAME_REQUEST;
    Loop.idIntervall = 0;
    Loop.idRequest = 0;
    Loop.fpsDesired = 30;
    Loop.framesToAverage = 30;
    Loop.syncWithAnimationFrame = false;
    FudgeCore.Loop = Loop;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Instances of this class generate a timestamp that correlates with the time elapsed since the start of the program but allows for resetting and scaling.
     * Supports [[Timer]]s similar to window.setInterval but with respect to the scaled time.
     * All time values are given in milliseconds
     *
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Time extends FudgeCore.EventTarget∆í {
        constructor() {
            super();
            this.timers = {};
            this.idTimerNext = 0;
            this.start = performance.now();
            this.scale = 1.0;
            this.offset = 0.0;
            this.lastCallToElapsed = 0.0;
        }
        /**
         * Returns the game-time-object which starts automatically and serves as base for various internal operations.
         */
        // public static get game(): Time {
        //   return Time.gameTime;
        // }
        static getUnits(_milliseconds) {
            let units = {};
            units.asSeconds = _milliseconds / 1000;
            units.asMinutes = units.asSeconds / 60;
            units.asHours = units.asMinutes / 60;
            units.hours = Math.floor(units.asHours);
            units.minutes = Math.floor(units.asMinutes) % 60;
            units.seconds = Math.floor(units.asSeconds) % 60;
            units.fraction = _milliseconds % 1000;
            units.thousands = _milliseconds % 10;
            units.hundreds = _milliseconds % 100 - units.thousands;
            units.tenths = units.fraction - units.hundreds - units.thousands;
            return units;
        }
        //#region Get/Set time and scaling
        /**
         * Retrieves the current scaled timestamp of this instance in milliseconds
         */
        get() {
            return this.offset + this.scale * (performance.now() - this.start);
        }
        /**
         * Returns the remaining time to the given point of time
         */
        getRemainder(_to) {
            return _to - this.get();
        }
        /**
         * (Re-) Sets the timestamp of this instance
         * @param _time The timestamp to represent the current time (default 0.0)
         */
        set(_time = 0) {
            this.offset = _time;
            this.start = performance.now();
            this.getElapsedSincePreviousCall();
        }
        /**
         * Sets the scaling of this time, allowing for slowmotion (<1) or fastforward (>1)
         * @param _scale The desired scaling (default 1.0)
         */
        setScale(_scale = 1.0) {
            this.set(this.get());
            this.scale = _scale;
            //TODO: catch scale=0
            this.rescaleAllTimers();
            this.getElapsedSincePreviousCall();
            this.dispatchEvent(new Event("timeScaled" /* TIME_SCALED */));
        }
        /**
         * Retrieves the current scaling of this time
         */
        getScale() {
            return this.scale;
        }
        /**
         * Retrieves the offset of this time
         */
        getOffset() {
            return this.offset;
        }
        /**
         * Retrieves the scaled time in milliseconds passed since the last call to this method
         * Automatically reset at every call to set(...) and setScale(...)
         */
        getElapsedSincePreviousCall() {
            let current = this.get();
            let elapsed = current - this.lastCallToElapsed;
            this.lastCallToElapsed = current;
            return elapsed;
        }
        //#endregion
        //#region Timers
        /**
         * Returns a Promise<void> to be resolved after the time given. To be used with async/await
         */
        delay(_lapse) {
            return new Promise(_resolve => this.setTimer(_lapse, 1, () => _resolve()));
        }
        // TODO: examine if web-workers would enhance performance here!
        /**
         * Stops and deletes all [[Timer]]s attached. Should be called before this Time-object leaves scope
         */
        clearAllTimers() {
            for (let id in this.timers) {
                this.deleteTimer(Number(id));
            }
        }
        /**
         * Deletes [[Timer]] found using the internal id of the connected interval-object
         * @param _id
         */
        deleteTimerByItsInternalId(_id) {
            for (let id in this.timers) {
                let timer = this.timers[id];
                if (timer.id == _id) {
                    timer.clear();
                    delete this.timers[id];
                    // TODO: check if an early out is OK here... should be!
                }
            }
        }
        /**
         * Installs a timer at this time object
         * @param _lapse The object-time to elapse between the calls to _callback
         * @param _count The number of calls desired, 0 = Infinite
         * @param _handler The function to call each the given lapse has elapsed
         * @param _arguments Additional parameters to pass to callback function
         */
        setTimer(_lapse, _count, _handler, ..._arguments) {
            let timer = new FudgeCore.Timer(this, _lapse, _count, _handler, _arguments);
            this.timers[++this.idTimerNext] = timer;
            return this.idTimerNext;
        }
        /**
         * Deletes the timer with the id given by this time object
         */
        deleteTimer(_id) {
            let timer = this.timers[_id];
            if (!timer)
                return;
            timer.clear();
            delete this.timers[_id];
        }
        /**
         * Returns a reference to the timer with the given id or null if not found.
         */
        getTimer(_id) {
            return this.timers[_id];
        }
        /**
         * Returns a copy of the list of timers currently installed on this time object
         */
        getTimers() {
            let result = {};
            return Object.assign(result, this.timers);
        }
        /**
         * Returns true if there are [[Timers]] installed to this
         */
        hasTimers() {
            return (Object.keys(this.timers).length > 0);
        }
        /**
         * Recreates [[Timer]]s when scaling changes
         */
        rescaleAllTimers() {
            for (let id in this.timers) {
                let timer = this.timers[id];
                timer.clear();
                if (!this.scale)
                    // Time has stopped, no need to replace cleared timers
                    continue;
                this.timers[id] = timer.installCopy();
            }
        }
    }
    /** Standard game time starting automatically with the application */
    Time.game = new Time();
    FudgeCore.Time = Time;
    //#endregion
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A [[Timer]]-instance internally uses window.setInterval to call a given handler with a given frequency a given number of times,
     * passing an [[TimerEvent∆í]]-instance with additional information and given arguments.
     * The frequency scales with the [[Time]]-instance the [[Timer]]-instance is attached to.
     *
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Timer {
        /**
         * Creates a [[Timer]] instance.
         * @param _time The [[Time]] instance, the timer attaches to
         * @param _elapse The time in milliseconds to elapse, to the next call of _handler, measured in _time
         * @param _count The desired number of calls to _handler, Timer deinstalls automatically after last call. Passing 0 invokes infinite calls
         * @param _handler The [[TimerHandler]] instance to call
         * @param _arguments Additional arguments to pass to _handler
         */
        constructor(_time, _elapse, _count, _handler, ..._arguments) {
            this.time = _time;
            this.elapse = _elapse;
            this.event = new FudgeCore.EventTimer(this, _arguments);
            this.handler = _handler;
            this.count = _count;
            let scale = Math.abs(_time.getScale());
            if (!scale) {
                // Time is stopped, timer won't be active
                this.active = false;
                return;
            }
            this.timeoutReal = this.elapse / scale;
            let callback = () => {
                if (!this.active)
                    return;
                this.event.lastCall = (this.count == 1);
                _handler(this.event);
                this.event.firstCall = false;
                if (this.count > 0)
                    if (--this.count == 0)
                        _time.deleteTimerByItsInternalId(this.idWindow);
            };
            this.idWindow = window.setInterval(callback, this.timeoutReal, _arguments);
            this.active = true;
        }
        /**
         * Returns the window-id of the timer, which was returned by setInterval
         */
        get id() {
            return this.idWindow;
        }
        /**
         * Returns the time-intervall for calls to the handler
         */
        get lapse() {
            return this.elapse;
        }
        /**
         * Attaches a copy of this at its current state to the same [[Time]]-instance. Used internally when rescaling [[Time]]
         */
        installCopy() {
            return new Timer(this.time, this.elapse, this.count, this.handler, this.event.arguments);
        }
        /**
         * Clears the timer, removing it from the interval-timers handled by window
         */
        clear() {
            // if (this.type == TIMER_TYPE.TIMEOUT) {
            //     if (this.active)
            //         // save remaining time to timeout as new timeout for restart
            //         this.timeout = this.timeout * (1 - (performance.now() - this.startTimeReal) / this.timeoutReal);
            //     window.clearTimeout(this.id);
            // }
            // else
            // TODO: reusing timer starts interval anew. Should be remaining interval as timeout, then starting interval anew 
            window.clearInterval(this.idWindow);
            this.active = false;
        }
    }
    FudgeCore.Timer = Timer;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Handles file transfer from a Fudge-Browserapp to the local filesystem without a local server.
     * Saves to the download-path given by the browser, loads from the player's choice.
     */
    class FileIoBrowserLocal extends FudgeCore.EventTargetStatic {
        // TODO: refactor to async function to be handled using promise, instead of using event target
        static load() {
            FileIoBrowserLocal.selector = document.createElement("input");
            FileIoBrowserLocal.selector.type = "file";
            FileIoBrowserLocal.selector.multiple = true;
            FileIoBrowserLocal.selector.hidden = true;
            FileIoBrowserLocal.selector.addEventListener("change", FileIoBrowserLocal.handleFileSelect);
            document.body.appendChild(FileIoBrowserLocal.selector);
            FileIoBrowserLocal.selector.click();
        }
        // TODO: refactor to async function to be handled using promise, instead of using event target
        static save(_toSave) {
            for (let filename in _toSave) {
                let content = _toSave[filename];
                let blob = new Blob([content], { type: "text/plain" });
                let url = window.URL.createObjectURL(blob);
                //*/ using anchor element for download
                let downloader;
                downloader = document.createElement("a");
                downloader.setAttribute("href", url);
                downloader.setAttribute("download", filename);
                document.body.appendChild(downloader);
                downloader.click();
                document.body.removeChild(downloader);
                window.URL.revokeObjectURL(url);
            }
            let event = new CustomEvent("fileSaved" /* FILE_SAVED */, { detail: { mapFilenameToContent: _toSave } });
            FileIoBrowserLocal.targetStatic.dispatchEvent(event);
        }
        static async handleFileSelect(_event) {
            FudgeCore.Debug.fudge("-------------------------------- handleFileSelect");
            document.body.removeChild(FileIoBrowserLocal.selector);
            let fileList = _event.target.files;
            FudgeCore.Debug.fudge(fileList, fileList.length);
            if (fileList.length == 0)
                return;
            let loaded = {};
            await FileIoBrowserLocal.loadFiles(fileList, loaded);
            let event = new CustomEvent("fileLoaded" /* FILE_LOADED */, { detail: { mapFilenameToContent: loaded } });
            FileIoBrowserLocal.targetStatic.dispatchEvent(event);
        }
        static async loadFiles(_fileList, _loaded) {
            for (let file of _fileList) {
                const content = await new Response(file).text();
                _loaded[file.name] = content;
            }
        }
    }
    FudgeCore.FileIoBrowserLocal = FileIoBrowserLocal;
})(FudgeCore || (FudgeCore = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRnVkZ2VDb3JlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vU291cmNlL0RlYnVnL0RlYnVnVGFyZ2V0LnRzIiwiLi4vU291cmNlL0RlYnVnL0RlYnVnSW50ZXJmYWNlcy50cyIsIi4uL1NvdXJjZS9EZWJ1Zy9EZWJ1Z0NvbnNvbGUudHMiLCIuLi9Tb3VyY2UvRGVidWcvRGVidWcudHMiLCIuLi9Tb3VyY2UvRXZlbnQvRXZlbnQudHMiLCIuLi9Tb3VyY2UvVHJhbnNmZXIvTXV0YWJsZS50cyIsIi4uL1NvdXJjZS9UcmFuc2Zlci9TZXJpYWxpemVyLnRzIiwiLi4vU291cmNlL1JlbmRlci9SZW5kZXJJbmplY3Rvci50cyIsIi4uL1NvdXJjZS9SZW5kZXIvUmVuZGVySW5qZWN0b3JTaGFkZXIudHMiLCIuLi9Tb3VyY2UvUmVuZGVyL1JlbmRlckluamVjdG9yQ29hdC50cyIsIi4uL1NvdXJjZS9SZW5kZXIvUmVuZGVySW5qZWN0b3JNZXNoLnRzIiwiLi4vU291cmNlL0VuZ2luZS9SZWN5Y2xlci50cyIsIi4uL1NvdXJjZS9NYXRoL1ZlY3RvcjIudHMiLCIuLi9Tb3VyY2UvTWF0aC9SZWN0YW5nbGUudHMiLCIuLi9Tb3VyY2UvUmVuZGVyL1JlbmRlck9wZXJhdG9yLnRzIiwiLi4vU291cmNlL1JlZmVyZW5jZXMudHMiLCIuLi9Tb3VyY2UvQW5pbWF0aW9uL0FuaW1hdGlvbi50cyIsIi4uL1NvdXJjZS9BbmltYXRpb24vQW5pbWF0aW9uRnVuY3Rpb24udHMiLCIuLi9Tb3VyY2UvQW5pbWF0aW9uL0FuaW1hdGlvbktleS50cyIsIi4uL1NvdXJjZS9BbmltYXRpb24vQW5pbWF0aW9uU2VxdWVuY2UudHMiLCIuLi9Tb3VyY2UvQXVkaW8vQXVkaW8udHMiLCIuLi9Tb3VyY2UvQXVkaW8vQXVkaW9NYW5hZ2VyLnRzIiwiLi4vU291cmNlL0F1ZGlvL0F1ZGlvT3NjaWxsYXRvci50cyIsIi4uL1NvdXJjZS9Db2F0L0NvYXQudHMiLCIuLi9Tb3VyY2UvQ29hdC9Db2F0VGV4dHVyZWQudHMiLCIuLi9Tb3VyY2UvQ29tcG9uZW50L0NvbXBvbmVudC50cyIsIi4uL1NvdXJjZS9Db21wb25lbnQvQ29tcG9uZW50QW5pbWF0b3IudHMiLCIuLi9Tb3VyY2UvQ29tcG9uZW50L0NvbXBvbmVudEF1ZGlvLnRzIiwiLi4vU291cmNlL0NvbXBvbmVudC9Db21wb25lbnRBdWRpb0xpc3RlbmVyLnRzIiwiLi4vU291cmNlL0NvbXBvbmVudC9Db21wb25lbnRDYW1lcmEudHMiLCIuLi9Tb3VyY2UvQ29tcG9uZW50L0NvbXBvbmVudExpZ2h0LnRzIiwiLi4vU291cmNlL0NvbXBvbmVudC9Db21wb25lbnRNYXRlcmlhbC50cyIsIi4uL1NvdXJjZS9Db21wb25lbnQvQ29tcG9uZW50TWVzaC50cyIsIi4uL1NvdXJjZS9Db21wb25lbnQvQ29tcG9uZW50UGFydGljbGVTeXN0ZW0udHMiLCIuLi9Tb3VyY2UvQ29tcG9uZW50L0NvbXBvbmVudFNjcmlwdC50cyIsIi4uL1NvdXJjZS9Db21wb25lbnQvQ29tcG9uZW50VHJhbnNmb3JtLnRzIiwiLi4vU291cmNlL0NvbnRyb2wvQ29udHJvbC50cyIsIi4uL1NvdXJjZS9Db250cm9sL0F4aXMudHMiLCIuLi9Tb3VyY2UvQ29udHJvbC9LZXlib2FyZC50cyIsIi4uL1NvdXJjZS9EZWJ1Zy9EZWJ1Z0FsZXJ0LnRzIiwiLi4vU291cmNlL0RlYnVnL0RlYnVnRGlhbG9nLnRzIiwiLi4vU291cmNlL0RlYnVnL0RlYnVnVGV4dEFyZWEudHMiLCIuLi9Tb3VyY2UvRW5naW5lL0NvbG9yLnRzIiwiLi4vU291cmNlL0VuZ2luZS9NYXRlcmlhbC50cyIsIi4uL1NvdXJjZS9FbmdpbmUvUmVzb3VyY2VNYW5hZ2VyLnRzIiwiLi4vU291cmNlL0VuZ2luZS9WaWV3cG9ydC50cyIsIi4uL1NvdXJjZS9FdmVudC9FdmVudEF1ZGlvLnRzIiwiLi4vU291cmNlL0V2ZW50L0V2ZW50RHJhZ0Ryb3AudHMiLCIuLi9Tb3VyY2UvRXZlbnQvRXZlbnRLZXlib2FyZC50cyIsIi4uL1NvdXJjZS9FdmVudC9FdmVudFBvaW50ZXIudHMiLCIuLi9Tb3VyY2UvRXZlbnQvRXZlbnRUaW1lci50cyIsIi4uL1NvdXJjZS9FdmVudC9FdmVudFdoZWVsLnRzIiwiLi4vU291cmNlL0xpZ2h0L0xpZ2h0LnRzIiwiLi4vU291cmNlL01hdGgvRnJhbWluZy50cyIsIi4uL1NvdXJjZS9NYXRoL01hdHJpeDN4My50cyIsIi4uL1NvdXJjZS9NYXRoL01hdHJpeDR4NC50cyIsIi4uL1NvdXJjZS9NYXRoL1JhbmRvbS50cyIsIi4uL1NvdXJjZS9NYXRoL1ZlY3RvcjMudHMiLCIuLi9Tb3VyY2UvTWVzaC9NZXNoLnRzIiwiLi4vU291cmNlL01lc2gvTWVzaEN1YmUudHMiLCIuLi9Tb3VyY2UvTWVzaC9NZXNoSGVpZ2h0TWFwLnRzIiwiLi4vU291cmNlL01lc2gvTWVzaFB5cmFtaWQudHMiLCIuLi9Tb3VyY2UvTWVzaC9NZXNoUXVhZC50cyIsIi4uL1NvdXJjZS9NZXNoL01lc2hTcGhlcmUudHMiLCIuLi9Tb3VyY2UvTWVzaC9NZXNoU3ByaXRlLnRzIiwiLi4vU291cmNlL05vZGUvTm9kZS50cyIsIi4uL1NvdXJjZS9Ob2RlL05vZGVSZXNvdXJjZS50cyIsIi4uL1NvdXJjZS9Ob2RlL05vZGVSZXNvdXJjZUluc3RhbmNlLnRzIiwiLi4vU291cmNlL1BhcnRpY2xlU3lzdGVtL0Nsb3N1cmVGYWN0b3J5LnRzIiwiLi4vU291cmNlL1BhcnRpY2xlU3lzdGVtL1BhcnRpY2xlRWZmZWN0SW1wb3J0ZXIudHMiLCIuLi9Tb3VyY2UvUmF5L1JheS50cyIsIi4uL1NvdXJjZS9SYXkvUmF5SGl0LnRzIiwiLi4vU291cmNlL1JlbmRlci9SZW5kZXJNYW5hZ2VyLnRzIiwiLi4vU291cmNlL1JlbmRlci9SZW5kZXJQYXJ0aWNsZXMudHMiLCIuLi9Tb3VyY2UvU2hhZGVyL1NoYWRlci50cyIsIi4uL1NvdXJjZS9TaGFkZXIvU2hhZGVyRmxhdC50cyIsIi4uL1NvdXJjZS9TaGFkZXIvU2hhZGVyTWF0Q2FwLnRzIiwiLi4vU291cmNlL1NoYWRlci9TaGFkZXJSYXlDYXN0LnRzIiwiLi4vU291cmNlL1NoYWRlci9TaGFkZXJUZXh0dXJlLnRzIiwiLi4vU291cmNlL1NoYWRlci9TaGFkZXJVbmlDb2xvci50cyIsIi4uL1NvdXJjZS9UZXh0dXJlL1RleHR1cmUudHMiLCIuLi9Tb3VyY2UvVGltZS9Mb29wLnRzIiwiLi4vU291cmNlL1RpbWUvVGltZS50cyIsIi4uL1NvdXJjZS9UaW1lL1RpbWVyLnRzIiwiLi4vU291cmNlL1RyYW5zZmVyL0ZpbGVJb0Jyb3dzZXJMb2NhbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUEsSUFBVSxTQUFTLENBZ0JsQjtBQWhCRCxXQUFVLFNBQVM7SUFDakI7O09BRUc7SUFDSCxNQUFzQixXQUFXO1FBRXhCLE1BQU0sQ0FBQyxjQUFjLENBQUMsUUFBZ0IsRUFBRSxHQUFHLEtBQWU7WUFDL0QsSUFBSSxHQUFHLEdBQVcsUUFBUSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsMkJBQTJCO1lBQ2xFLEtBQUssSUFBSSxHQUFHLElBQUksS0FBSztnQkFDbkIsSUFBSSxHQUFHLFlBQVksTUFBTTtvQkFDdkIsR0FBRyxJQUFJLElBQUksR0FBRyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsK0JBQStCOztvQkFFNUUsR0FBRyxJQUFJLElBQUksR0FBRyxHQUFHLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQywrQkFBK0I7WUFDakUsT0FBTyxHQUFHLENBQUM7UUFDYixDQUFDO0tBQ0Y7SUFYcUIscUJBQVcsY0FXaEMsQ0FBQTtBQUNILENBQUMsRUFoQlMsU0FBUyxLQUFULFNBQVMsUUFnQmxCO0FDaEJELG9DQUFvQztBQUNwQyxJQUFVLFNBQVMsQ0E4QmxCO0FBL0JELG9DQUFvQztBQUNwQyxXQUFVLFNBQVM7SUFDakI7O09BRUc7SUFDSCxJQUFZLFlBY1g7SUFkRCxXQUFZLFlBQVk7UUFDdEIsK0NBQVcsQ0FBQTtRQUNYLCtDQUFX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Q0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQ3JDLElBQUksR0FBRyxHQUFXLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUNyQyxJQUFJLEdBQUcsR0FBVyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDckMsSUFBSSxHQUFHLEdBQVcsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQ3JDLElBQUksR0FBRyxHQUFXLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUNyQyxJQUFJLEdBQUcsR0FBVyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDckMsSUFBSSxHQUFHLEdBQVcsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQ3JDLElBQUksR0FBRyxHQUFXLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUNyQyxJQUFJLEdBQUcsR0FBVyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDckMsSUFBSSxNQUFNLEdBQWMsSUFBSSxTQUFTLENBQUM7WUFDdEMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUM7Z0JBQ2QsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2dCQUNqQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7Z0JBQ2pDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztnQkFDakMsR0FB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QUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUNiO2dCQUNFLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2dCQUM3QyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztnQkFDN0MsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7Z0JBQzdDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2dCQUM3QyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztnQkFDN0MsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7Z0JBQzdDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2dCQUM3QyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztnQkFDN0MsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7Z0JBQzdDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2dCQUM3QyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztnQkFDN0MsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7Z0JBQzdDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2dCQUM3QyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztnQkFDN0MsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7Z0JBQzdDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2FBQzlDLENBQUMsQ0FBQztZQUNMLE9BQU8sTUFBTSxDQUFDO1FBQ2hCLENBQUM7UUFFRDs7O1dBR0c7UUFDSSxNQUFNLENBQUMsU0FBUyxDQUFDLE9BQWtCO1lBQ3hDLElBQUksQ0FBQyxHQUFpQixPQUFPLENBQUMsSUFBSSxDQUFDO1lBQ25DLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksSUFBSSxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDN0IsSUFBSSxJQUFJLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM3QixJQUFJLElBQUksR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzdCLElBQUksSUFBSSxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDN0IsSUFBSSxJQUFJLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM3QixJQUFJLElBQUksR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzdCLElBQUksSUFBSSxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDN0IsSUFBSSxJQUFJLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM3QixJQUFJLElBQUksR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzdCLElBQUksSUFBSSxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDN0IsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzlCLElBQUksS0FBSyxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDOUIsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzlCLElBQUksS0FBSyxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDOUIsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzlCLElBQUksS0FBSyxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDOUIsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzlCLElBQUksS0FBSyxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDOUIsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBRTlCLElBQUksRUFBRSxHQUFXLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLENBQUM7Z0JBQ3JELENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQztZQUV6QyxJQUFJLEVBQUUsR0FBVyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDO2dCQUNyRCxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUM7WUFDekMsSUFBSSxFQUFFLEdBQVcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQztnQkFDdEQsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO1lBQzFDLElBQUksRUFBRSxHQUFXLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUM7Z0JBQ3RELENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsQ0FBQztZQUUxQyxJQUFJLENBQUMsR0FBVyxHQUFHLEdBQUcsQ0FBQyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxDQUFDLENBQUM7WUFFbEUseUNBQXlDO1lBQ3pDLE1BQU0sTUFBTSxHQUFjLFVBQUEsUUFBUSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUNsRCxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQztnQkFDZCxDQUFDLEdBQUcsRUFBRTtnQkFDTixDQUFDLEdBQUcsRUFBRTtnQkFDTixDQUFDLEdBQUcsRUFBRTtnQkFDTixDQUFDLEdBQUcsRUFBRTtnQkFDTixDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUNyRixDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUNyRixDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUN2RixDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUN2RixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUMzRixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUMzRixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUMzRixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUMzRixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUMzRixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUMzRixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUMzRixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENB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LEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQzFHLGtCQUFrQixDQUFDLFlBQVksQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDekQsQ0FBQztRQUVNLE1BQU0sQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLFNBQW1CLEVBQUUsT0FBNkI7WUFDNUUsS0FBSyxJQUFJLElBQUksSUFBSSxTQUFTLEVBQUU7Z0JBQ3hCLE1BQU0sT0FBTyxHQUFXLE1BQU0sSUFBSSxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7Z0JBQ3hELE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsT0FBTyxDQUFDO2FBQ2hDO1FBQ0wsQ0FBQztLQUNKO0lBdkRZLDRCQUFrQixxQkF1RDlCLENBQUE7QUFDTCxDQUFDLEVBaEVTLFNBQVMsS0FBVCxTQUFTLFFBZ0VsQiIsInNvdXJjZXNDb250ZW50IjpbIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEJhc2UgY2xhc3MgZm9yIHRoZSBkaWZmZXJlbnQgRGVidWdUYXJnZXRzLCBtYWlubHkgZm9yIHRlY2huaWNhbCBwdXJwb3NlIG9mIGluaGVyaXRhbmNlXHJcbiAgICovXHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIERlYnVnVGFyZ2V0IHtcclxuICAgIHB1YmxpYyBkZWxlZ2F0ZXM6IE1hcERlYnVnRmlsdGVyVG9EZWxlZ2F0ZTtcclxuICAgIHB1YmxpYyBzdGF0aWMgbWVyZ2VBcmd1bWVudHMoX21lc3NhZ2U6IE9iamVjdCwgLi4uX2FyZ3M6IE9iamVjdFtdKTogc3RyaW5nIHtcclxuICAgICAgbGV0IG91dDogc3RyaW5nID0gX21lc3NhZ2UudG9TdHJpbmcoKTsgLy9KU09OLnN0cmluZ2lmeShfbWVzc2FnZSk7XHJcbiAgICAgIGZvciAobGV0IGFyZyBvZiBfYXJncylcclxuICAgICAgICBpZiAoYXJnIGluc3RhbmNlb2YgTnVtYmVyKVxyXG4gICAgICAgICAgb3V0ICs9IFwiLCBcIiArIGFyZy50b1ByZWNpc2lvbigyKS50b1N0cmluZygpOyAvL0pTT04uc3RyaW5naWZ5KGFyZywgbnVsbCwgMik7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgb3V0ICs9IFwiLCBcIiArIGFyZy50b1N0cmluZygpOyAvL0pTT04uc3RyaW5naWZ5KGFyZywgbnVsbCwgMik7XHJcbiAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwiLy8gPHJlZmVyZW5jZSBwYXRoPVwiRGVidWdBbGVydC50c1wiLz5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogVGhlIGZpbHRlcnMgY29ycmVzcG9uZGluZyB0byBkZWJ1ZyBhY3Rpdml0aWVzLCBtb3JlIHRvIGNvbWVcclxuICAgKi9cclxuICBleHBvcnQgZW51bSBERUJVR19GSUxURVIge1xyXG4gICAgTk9ORSA9IDB4MDAsXHJcbiAgICBJTkZPID0gMHgwMSxcclxuICAgIExPRyA9IDB4MDIsXHJcbiAgICBXQVJOID0gMHgwNCxcclxuICAgIEVSUk9SID0gMHgwOCxcclxuICAgIEZVREdFID0gMHgxMCxcclxuICAgIENMRUFSID0gMHgxMDAsXHJcbiAgICBHUk9VUCA9IDB4MTAxLFxyXG4gICAgR1JPVVBDT0xMQVBTRUQgPSAweDEwMixcclxuICAgIEdST1VQRU5EID0gMHgxMDQsXHJcbiAgICBNRVNTQUdFUyA9IElORk8gfCBMT0cgfCBXQVJOIHwgRVJST1IgfCBGVURHRSxcclxuICAgIEZPUk1BVCA9IENMRUFSIHwgR1JPVVAgfCBHUk9VUENPTExBUFNFRCB8IEdST1VQRU5ELFxyXG4gICAgQUxMID0gTUVTU0FHRVMgfCBGT1JNQVRcclxuICB9XHJcblxyXG4gIGV4cG9ydCBjb25zdCBERUJVR19TWU1CT0w6IHsgW2ZpbHRlcjogbnVtYmVyXTogc3RyaW5nOyB9ID0ge1xyXG4gICAgW0RFQlVHX0ZJTFRFUi5JTkZPXTogXCLinJNcIixcclxuICAgIFtERUJVR19GSUxURVIuTE9HXTogXCLinI5cIixcclxuICAgIFtERUJVR19GSUxURVIuV0FSTl06IFwi4pqgXCIsXHJcbiAgICBbREVCVUdfRklMVEVSLkVSUk9SXTogXCLinYxcIixcclxuICAgIFtERUJVR19GSUxURVIuRlVER0VdOiBcIvCfjrJcIlxyXG4gIH07XHJcblxyXG4gIGV4cG9ydCB0eXBlIE1hcERlYnVnVGFyZ2V0VG9EZWxlZ2F0ZSA9IE1hcDxEZWJ1Z1RhcmdldCwgRnVuY3Rpb24+O1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgTWFwRGVidWdGaWx0ZXJUb0RlbGVnYXRlIHsgW2ZpbHRlcjogbnVtYmVyXTogRnVuY3Rpb247IH1cclxufSIsIi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiRGVidWdUYXJnZXQudHNcIi8+XHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFJvdXRpbmcgdG8gdGhlIHN0YW5kYXJkLWNvbnNvbGVcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgRGVidWdDb25zb2xlIGV4dGVuZHMgRGVidWdUYXJnZXQge1xyXG4gICAgcHVibGljIHN0YXRpYyBkZWxlZ2F0ZXM6IE1hcERlYnVnRmlsdGVyVG9EZWxlZ2F0ZSA9IHtcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5JTkZPXTogY29uc29sZS5pbmZvLFxyXG4gICAgICBbREVCVUdfRklMVEVSLkxPR106IGNvbnNvbGUubG9nLFxyXG4gICAgICBbREVCVUdfRklMVEVSLldBUk5dOiBjb25zb2xlLndhcm4sXHJcbiAgICAgIFtERUJVR19GSUxURVIuRVJST1JdOiBjb25zb2xlLmVycm9yLFxyXG4gICAgICBbREVCVUdfRklMVEVSLkZVREdFXTogRGVidWdDb25zb2xlLmZ1ZGdlLFxyXG4gICAgICBbREVCVUdfRklMVEVSLkNMRUFSXTogY29uc29sZS5jbGVhcixcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5HUk9VUF06IGNvbnNvbGUuZ3JvdXAsXHJcbiAgICAgIFtERUJVR19GSUxURVIuR1JPVVBDT0xMQVBTRURdOiBjb25zb2xlLmdyb3VwQ29sbGFwc2VkLFxyXG4gICAgICBbREVCVUdfRklMVEVSLkdST1VQRU5EXTogY29uc29sZS5ncm91cEVuZFxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERpc3BsYXlzIGNyaXRpY2FsIGluZm9ybWF0aW9uIGFib3V0IGZhaWx1cmVzLCB3aGljaCBpcyBlbXBoYXNpemVkIGUuZy4gYnkgY29sb3JcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBmdWRnZShfbWVzc2FnZTogT2JqZWN0LCAuLi5fYXJnczogT2JqZWN0W10pOiB2b2lkIHtcclxuICAgICAgY29uc29sZS5kZWJ1ZyhcIvCfjrJcIiwgX21lc3NhZ2UsIC4uLl9hcmdzKTtcclxuICAgICAgLy8gbGV0IHRyYWNlOiBzdHJpbmdbXSA9IG5ldyBFcnJvcihcIlRlc3RcIikuc3RhY2suc3BsaXQoXCJcXG5cIik7XHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKHRyYWNlWzRdKTtcclxuICAgICAgLy8gY29uc29sZS50cmFjZShcIlRlc3RcIik7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwiLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCJEZWJ1Z1RhcmdldC50c1wiLz5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkRlYnVnSW50ZXJmYWNlcy50c1wiLz5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkRlYnVnQ29uc29sZS50c1wiLz5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogVGhlIERlYnVnLUNsYXNzIG9mZmVycyBmdW5jdGlvbnMga25vd24gZnJvbSB0aGUgY29uc29sZS1vYmplY3QgYW5kIGFkZGl0aW9ucywgXHJcbiAgICogcm91dGluZyB0aGUgaW5mb3JtYXRpb24gdG8gdmFyaW91cyBbW0RlYnVnVGFyZ2V0c11dIHRoYXQgY2FuIGJlIGVhc2lseSBkZWZpbmVkIGJ5IHRoZSBkZXZlbG9wZXJzIGFuZCByZWdpc3RlcmQgYnkgdXNlcnNcclxuICAgKiBPdmVycmlkZSBmdW5jdGlvbnMgaW4gc3ViY2xhc3NlcyBvZiBbW0RlYnVnVGFyZ2V0XV0gYW5kIHJlZ2lzdGVyIHRoZW0gYXMgdGhlaXIgZGVsZWdhdGVzXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIERlYnVnIHtcclxuICAgIC8qKlxyXG4gICAgICogRm9yIGVhY2ggc2V0IGZpbHRlciwgdGhpcyBhc3NvY2lhdGl2ZSBhcnJheSBrZWVwcyByZWZlcmVuY2VzIHRvIHRoZSByZWdpc3RlcmVkIGRlbGVnYXRlIGZ1bmN0aW9ucyBvZiB0aGUgY2hvc2VuIFtbRGVidWdUYXJnZXRzXV1cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZGVsZWdhdGVzOiB7IFtmaWx0ZXI6IG51bWJlcl06IE1hcERlYnVnVGFyZ2V0VG9EZWxlZ2F0ZSB9ID0gRGVidWcuc2V0dXBDb25zb2xlKCk7XHJcblxyXG4gICAgLy8gVE9ETzogY3JlYXRlIGZpbHRlciBERUJVR19GSUxURVIuRlVER0Ugc29sZWx5IGZvciBtZXNzYWdlcyBmcm9tIEZVREdFXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZS0gLyBBY3RpdmF0ZSBhIGZpbHRlciBmb3IgdGhlIGdpdmVuIERlYnVnVGFyZ2V0LiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzZXRGaWx0ZXIoX3RhcmdldDogRGVidWdUYXJnZXQsIF9maWx0ZXI6IERFQlVHX0ZJTFRFUik6IHZvaWQge1xyXG4gICAgICBmb3IgKGxldCBmaWx0ZXIgaW4gRGVidWcuZGVsZWdhdGVzKVxyXG4gICAgICAgIERlYnVnLmRlbGVnYXRlc1tmaWx0ZXJdLmRlbGV0ZShfdGFyZ2V0KTtcclxuXHJcbiAgICAgIGZvciAobGV0IGZpbHRlciBpbiBERUJVR19GSUxURVIpIHtcclxuICAgICAgICBsZXQgcGFyc2VkOiBudW1iZXIgPSBwYXJzZUludChmaWx0ZXIpO1xyXG4gICAgICAgIGlmIChpc05hTihwYXJzZWQpKVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgaWYgKFtERUJVR19GSUxURVIuTUVTU0FHRVMsIERFQlVHX0ZJTFRFUi5GT1JNQVQsIERFQlVHX0ZJTFRFUi5BTExdLmluZGV4T2YocGFyc2VkKSAhPSAtMSlcclxuICAgICAgICAgIC8vIGRvbnQgZGVsZWdhdGUgY29tYm9zLi4uIFxyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgaWYgKF9maWx0ZXIgJiBwYXJzZWQpXHJcbiAgICAgICAgICBEZWJ1Zy5kZWxlZ2F0ZXNbcGFyc2VkXS5zZXQoX3RhcmdldCwgX3RhcmdldC5kZWxlZ2F0ZXNbcGFyc2VkXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluZm8oLi4uKSBkaXNwbGF5cyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHdpdGggbG93IHByaW9yaXR5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgaW5mbyhfbWVzc2FnZTogT2JqZWN0LCAuLi5fYXJnczogT2JqZWN0W10pOiB2b2lkIHtcclxuICAgICAgRGVidWcuZGVsZWdhdGUoREVCVUdfRklMVEVSLklORk8sIF9tZXNzYWdlLCBfYXJncyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERpc3BsYXlzIGluZm9ybWF0aW9uIHdpdGggbWVkaXVtIHByaW9yaXR5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgbG9nKF9tZXNzYWdlOiBPYmplY3QsIC4uLl9hcmdzOiBPYmplY3RbXSk6IHZvaWQge1xyXG4gICAgICBEZWJ1Zy5kZWxlZ2F0ZShERUJVR19GSUxURVIuTE9HLCBfbWVzc2FnZSwgX2FyZ3MpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwbGF5cyBpbmZvcm1hdGlvbiBhYm91dCBub24tY29uZm9ybWl0aWVzIGluIHVzYWdlLCB3aGljaCBpcyBlbXBoYXNpemVkIGUuZy4gYnkgY29sb3JcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyB3YXJuKF9tZXNzYWdlOiBPYmplY3QsIC4uLl9hcmdzOiBPYmplY3RbXSk6IHZvaWQge1xyXG4gICAgICBEZWJ1Zy5kZWxlZ2F0ZShERUJVR19GSUxURVIuV0FSTiwgX21lc3NhZ2UsIF9hcmdzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGlzcGxheXMgY3JpdGljYWwgaW5mb3JtYXRpb24gYWJvdXQgZmFpbHVyZXMsIHdoaWNoIGlzIGVtcGhhc2l6ZWQgZS5nLiBieSBjb2xvclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGVycm9yKF9tZXNzYWdlOiBPYmplY3QsIC4uLl9hcmdzOiBPYmplY3RbXSk6IHZvaWQge1xyXG4gICAgICBEZWJ1Zy5kZWxlZ2F0ZShERUJVR19GSUxURVIuRVJST1IsIF9tZXNzYWdlLCBfYXJncyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERpc3BsYXlzIG1lc3NhZ2VzIGZyb20gRlVER0VcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBmdWRnZShfbWVzc2FnZTogT2JqZWN0LCAuLi5fYXJnczogT2JqZWN0W10pOiB2b2lkIHtcclxuICAgICAgRGVidWcuZGVsZWdhdGUoREVCVUdfRklMVEVSLkZVREdFLCBfbWVzc2FnZSwgX2FyZ3MpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgdGhlIG91dHB1dCBhbmQgcmVtb3ZlcyBwcmV2aW91cyBtZXNzYWdlcyBpZiBwb3NzaWJsZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGNsZWFyKCk6IHZvaWQge1xyXG4gICAgICBEZWJ1Zy5kZWxlZ2F0ZShERUJVR19GSUxURVIuQ0xFQVIsIG51bGwsIG51bGwpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVucyBhIG5ldyBncm91cCBmb3IgbWVzc2FnZXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBncm91cChfbmFtZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgIERlYnVnLmRlbGVnYXRlKERFQlVHX0ZJTFRFUi5HUk9VUCwgX25hbWUsIG51bGwpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVucyBhIG5ldyBncm91cCBmb3IgbWVzc2FnZXMgdGhhdCBpcyBjb2xsYXBzZWQgYXQgZmlyc3RcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBncm91cENvbGxhcHNlZChfbmFtZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgIERlYnVnLmRlbGVnYXRlKERFQlVHX0ZJTFRFUi5HUk9VUENPTExBUFNFRCwgX25hbWUsIG51bGwpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDbG9zZXMgdGhlIHlvdW5nZXN0IGdyb3VwXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ3JvdXBFbmQoKTogdm9pZCB7XHJcbiAgICAgIERlYnVnLmRlbGVnYXRlKERFQlVHX0ZJTFRFUi5HUk9VUEVORCwgbnVsbCwgbnVsbCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIExvb2t1cCBhbGwgZGVsZWdhdGVzIHJlZ2lzdGVyZWQgdG8gdGhlIGZpbHRlciBhbmQgY2FsbCB0aGVtIHVzaW5nIHRoZSBnaXZlbiBhcmd1bWVudHNcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZGVsZWdhdGUoX2ZpbHRlcjogREVCVUdfRklMVEVSLCBfbWVzc2FnZTogT2JqZWN0LCBfYXJnczogT2JqZWN0W10pOiB2b2lkIHtcclxuICAgICAgbGV0IGRlbGVnYXRlczogTWFwRGVidWdUYXJnZXRUb0RlbGVnYXRlID0gRGVidWcuZGVsZWdhdGVzW19maWx0ZXJdO1xyXG4gICAgICBmb3IgKGxldCBkZWxlZ2F0ZSBvZiBkZWxlZ2F0ZXMudmFsdWVzKCkpXHJcbiAgICAgICAgaWYgKGRlbGVnYXRlKVxyXG4gICAgICAgICAgaWYgKF9hcmdzICYmIF9hcmdzLmxlbmd0aCA+IDApXHJcbiAgICAgICAgICAgIGRlbGVnYXRlKF9tZXNzYWdlLCAuLi5fYXJncyk7XHJcbiAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIGRlbGVnYXRlKF9tZXNzYWdlKTtcclxuXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIHNldHVwIHJvdXRpbmcgdG8gc3RhbmRhcmQgY29uc29sZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBzZXR1cENvbnNvbGUoKToge30ge1xyXG4gICAgICBsZXQgcmVzdWx0OiB7IFtmaWx0ZXI6IG51bWJlcl06IE1hcERlYnVnVGFyZ2V0VG9EZWxlZ2F0ZSB9ID0ge307XHJcbiAgICAgIGxldCBmaWx0ZXJzOiBERUJVR19GSUxURVJbXSA9IFtcclxuICAgICAgICBERUJVR19GSUxURVIuSU5GTywgREVCVUdfRklMVEVSLkxPRywgREVCVUdfRklMVEVSLldBUk4sIERFQlVHX0ZJTFRFUi5FUlJPUiwgREVCVUdfRklMVEVSLkZVREdFLFxyXG4gICAgICAgIERFQlVHX0ZJTFRFUi5DTEVBUiwgREVCVUdfRklMVEVSLkdST1VQLCBERUJVR19GSUxURVIuR1JPVVBDT0xMQVBTRUQsIERFQlVHX0ZJTFRFUi5HUk9VUEVORFxyXG4gICAgICBdO1xyXG5cclxuICAgICAgZm9yIChsZXQgZmlsdGVyIG9mIGZpbHRlcnMpXHJcbiAgICAgICAgcmVzdWx0W2ZpbHRlcl0gPSBuZXcgTWFwKFtbRGVidWdDb25zb2xlLCBEZWJ1Z0NvbnNvbGUuZGVsZWdhdGVzW2ZpbHRlcl1dXSk7XHJcblxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gICAgZXhwb3J0IGludGVyZmFjZSBNYXBFdmVudFR5cGVUb0xpc3RlbmVyIHtcclxuICAgICAgICBbZXZlbnRUeXBlOiBzdHJpbmddOiBFdmVudExpc3RlbmVyW107XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUeXBlcyBvZiBldmVudHMgc3BlY2lmaWMgdG8gRnVkZ2UsIGluIGFkZGl0aW9uIHRvIHRoZSBzdGFuZGFyZCBET00vQnJvd3Nlci1UeXBlcyBhbmQgY3VzdG9tIHN0cmluZ3NcclxuICAgICAqL1xyXG4gICAgZXhwb3J0IGNvbnN0IGVudW0gRVZFTlQge1xyXG4gICAgICAgIC8qKiBkaXNwYXRjaGVkIHRvIHRhcmdldHMgcmVnaXN0ZXJlZCBhdCBbW0xvb3BdXSwgd2hlbiByZXF1ZXN0ZWQgYW5pbWF0aW9uIGZyYW1lIHN0YXJ0cyAqL1xyXG4gICAgICAgIExPT1BfRlJBTUUgPSBcImxvb3BGcmFtZVwiLFxyXG4gICAgICAgIC8qKiBkaXNwYXRjaGVkIHRvIGEgW1tDb21wb25lbnRdXSB3aGVuIGl0cyBiZWluZyBhZGRlZCB0byBhIFtbTm9kZV1dICovXHJcbiAgICAgICAgQ09NUE9ORU5UX0FERCA9IFwiY29tcG9uZW50QWRkXCIsXHJcbiAgICAgICAgLyoqIGRpc3BhdGNoZWQgdG8gYSBbW0NvbXBvbmVudF1dIHdoZW4gaXRzIGJlaW5nIHJlbW92ZWQgZnJvbSBhIFtbTm9kZV1dICovXHJcbiAgICAgICAgQ09NUE9ORU5UX1JFTU9WRSA9IFwiY29tcG9uZW50UmVtb3ZlXCIsXHJcbiAgICAgICAgLyoqIGRpc3BhdGNoZWQgdG8gYSBbW0NvbXBvbmVudF1dIHdoZW4gaXRzIGJlaW5nIGFjdGl2YXRlZCAqL1xyXG4gICAgICAgIENPTVBPTkVOVF9BQ1RJVkFURSA9IFwiY29tcG9uZW50QWN0aXZhdGVcIixcclxuICAgICAgICAvKiogZGlzcGF0Y2hlZCB0byBhIFtbQ29tcG9uZW50XV0gd2hlbiBpdHMgYmVpbmcgZGVhY3RpdmF0ZWQgKi9cclxuICAgICAgICBDT01QT05FTlRfREVBQ1RJVkFURSA9IFwiY29tcG9uZW50RGVhY3RpdmF0ZVwiLFxyXG4gICAgICAgIC8qKiBkaXNwYXRjaGVkIHRvIGEgY2hpbGQgW1tOb2RlXV0gYW5kIGl0cyBhbmNlc3RvcnMgYWZ0ZXIgaXQgd2FzIGFwcGVuZGVkIHRvIGEgcGFyZW50ICovXHJcbiAgICAgICAgQ0hJTERfQVBQRU5EID0gXCJjaGlsZEFwcGVuZFwiLFxyXG4gICAgICAgIC8qKiBkaXNwYXRjaGVkIHRvIGEgY2hpbGQgW1tOb2RlXV0gYW5kIGl0cyBhbmNlc3RvcnMganVzdCBiZWZvcmUgaXRzIGJlaW5nIHJlbW92ZWQgZnJvbSBpdHMgcGFyZW50ICovXHJcbiAgICAgICAgQ0hJTERfUkVNT1ZFID0gXCJjaGlsZFJlbW92ZVwiLFxyXG4gICAgICAgIC8qKiBkaXNwYXRjaGVkIHRvIGEgW1tNdXRhYmxlXV0gd2hlbiBpdHMgYmVpbmcgbXV0YXRlZCAqL1xyXG4gICAgICAgIE1VVEFURSA9IFwibXV0YXRlXCIsXHJcbiAgICAgICAgLyoqIGRpc3BhdGNoZWQgdG8gW1tWaWV3cG9ydF1dIHdoZW4gaXQgZ2V0cyB0aGUgZm9jdXMgdG8gcmVjZWl2ZSBrZXlib2FyZCBpbnB1dCAqL1xyXG4gICAgICAgIEZPQ1VTX0lOID0gXCJmb2N1c2luXCIsXHJcbiAgICAgICAgLyoqIGRpc3BhdGNoZWQgdG8gW1tWaWV3cG9ydF1dIHdoZW4gaXQgbG9zZXMgdGhlIGZvY3VzIHRvIHJlY2VpdmUga2V5Ym9hcmQgaW5wdXQgKi9cclxuICAgICAgICBGT0NVU19PVVQgPSBcImZvY3Vzb3V0XCIsXHJcbiAgICAgICAgLyoqIGRpc3BhdGNoZWQgdG8gW1tOb2RlXV0gd2hlbiBpdCdzIGRvbmUgc2VyaWFsaXppbmcgKi9cclxuICAgICAgICBOT0RFX1NFUklBTElaRUQgPSBcIm5vZGVTZXJpYWxpemVkXCIsXHJcbiAgICAgICAgLyoqIGRpc3BhdGNoZWQgdG8gW1tOb2RlXV0gd2hlbiBpdCdzIGRvbmUgZGVzZXJpYWxpemluZywgc28gYWxsIGNvbXBvbmVudHMsIGNoaWxkcmVuIGFuZCBhdHRyaWJ1dGVzIGFyZSBhdmFpbGFibGUgKi9cclxuICAgICAgICBOT0RFX0RFU0VSSUFMSVpFRCA9IFwibm9kZURlc2VyaWFsaXplZFwiLFxyXG4gICAgICAgIC8qKiBkaXNwYXRjaGVkIHRvIFtbTm9kZVJlc291cmNlSW5zdGFuY2VdXSB3aGVuIGl0J3MgY29udGVudCBpcyBzZXQgYWNjb3JkaW5nIHRvIGEgc2VyaWFsaXphdGlvbiBvZiBhIFtbTm9kZVJlc291cmNlXV0gICovXHJcbiAgICAgICAgTk9ERVJFU09VUkNFX0lOU1RBTlRJQVRFRCA9IFwibm9kZVJlc291cmNlSW5zdGFudGlhdGVkXCIsXHJcbiAgICAgICAgLyoqIGRpc3BhdGNoZWQgdG8gW1tUaW1lXV0gd2hlbiBpdCdzIHNjYWxpbmcgY2hhbmdlZCAgKi9cclxuICAgICAgICBUSU1FX1NDQUxFRCA9IFwidGltZVNjYWxlZFwiLFxyXG4gICAgICAgIC8qKiBkaXNwYXRjaGVkIHRvIFtbRmlsZUlvXV0gd2hlbiBhIGxpc3Qgb2YgZmlsZXMgaGFzIGJlZW4gbG9hZGVkICAqL1xyXG4gICAgICAgIEZJTEVfTE9BREVEID0gXCJmaWxlTG9hZGVkXCIsXHJcbiAgICAgICAgLyoqIGRpc3BhdGNoZWQgdG8gW1tGaWxlSW9dXSB3aGVuIGEgbGlzdCBvZiBmaWxlcyBoYXMgYmVlbiBzYXZlZCAqL1xyXG4gICAgICAgIEZJTEVfU0FWRUQgPSBcImZpbGVTYXZlZFwiXHJcbiAgICB9XHJcblxyXG5cclxuICAgIGV4cG9ydCB0eXBlIEV2ZW50xpIgPSBFdmVudFBvaW50ZXIgfCBFdmVudERyYWdEcm9wIHwgRXZlbnRXaGVlbCB8IEV2ZW50S2V5Ym9hcmQgfCBFdmVudDtcclxuXHJcbiAgICBleHBvcnQgdHlwZSBFdmVudExpc3RlbmVyxpIgPVxyXG4gICAgICAgICgoX2V2ZW50OiBFdmVudFBvaW50ZXIpID0+IHZvaWQpIHxcclxuICAgICAgICAoKF9ldmVudDogRXZlbnREcmFnRHJvcCkgPT4gdm9pZCkgfFxyXG4gICAgICAgICgoX2V2ZW50OiBFdmVudFdoZWVsKSA9PiB2b2lkKSB8XHJcbiAgICAgICAgKChfZXZlbnQ6IEV2ZW50S2V5Ym9hcmQpID0+IHZvaWQpIHxcclxuICAgICAgICAoKF9ldmVudDogRXZlbnTGkikgPT4gdm9pZCkgfFxyXG4gICAgICAgIEV2ZW50TGlzdGVuZXJPYmplY3Q7XHJcblxyXG4gICAgZXhwb3J0IGNsYXNzIEV2ZW50VGFyZ2V0xpIgZXh0ZW5kcyBFdmVudFRhcmdldCB7XHJcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihfdHlwZTogc3RyaW5nLCBfaGFuZGxlcjogRXZlbnRMaXN0ZW5lcsaSLCBfb3B0aW9ucz86IGJvb2xlYW4gfCBBZGRFdmVudExpc3RlbmVyT3B0aW9ucyk6IHZvaWQge1xyXG4gICAgICAgICAgICBzdXBlci5hZGRFdmVudExpc3RlbmVyKF90eXBlLCA8RXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdD5faGFuZGxlciwgX29wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKF90eXBlOiBzdHJpbmcsIF9oYW5kbGVyOiBFdmVudExpc3RlbmVyxpIsIF9vcHRpb25zPzogYm9vbGVhbiB8IEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zKTogdm9pZCB7XHJcbiAgICAgICAgICAgIHN1cGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoX3R5cGUsIDxFdmVudExpc3RlbmVyT3JFdmVudExpc3RlbmVyT2JqZWN0Pl9oYW5kbGVyLCBfb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkaXNwYXRjaEV2ZW50KF9ldmVudDogRXZlbnTGkik6IGJvb2xlYW4ge1xyXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuZGlzcGF0Y2hFdmVudChfZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJhc2UgY2xhc3MgZm9yIEV2ZW50VGFyZ2V0IHNpbmdsZXRvbnMsIHdoaWNoIGFyZSBmaXhlZCBlbnRpdGllcyBpbiB0aGUgc3RydWN0dXJlIG9mIEZ1ZGdlLCBzdWNoIGFzIHRoZSBjb3JlIGxvb3AgXHJcbiAgICAgKi9cclxuICAgIGV4cG9ydCBjbGFzcyBFdmVudFRhcmdldFN0YXRpYyBleHRlbmRzIEV2ZW50VGFyZ2V0xpIge1xyXG4gICAgICAgIHByb3RlY3RlZCBzdGF0aWMgdGFyZ2V0U3RhdGljOiBFdmVudFRhcmdldFN0YXRpYyA9IG5ldyBFdmVudFRhcmdldFN0YXRpYygpO1xyXG5cclxuICAgICAgICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGFkZEV2ZW50TGlzdGVuZXIoX3R5cGU6IHN0cmluZywgX2hhbmRsZXI6IEV2ZW50TGlzdGVuZXIpOiB2b2lkIHtcclxuICAgICAgICAgICAgRXZlbnRUYXJnZXRTdGF0aWMudGFyZ2V0U3RhdGljLmFkZEV2ZW50TGlzdGVuZXIoX3R5cGUsIF9oYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyByZW1vdmVFdmVudExpc3RlbmVyKF90eXBlOiBzdHJpbmcsIF9oYW5kbGVyOiBFdmVudExpc3RlbmVyKTogdm9pZCB7XHJcbiAgICAgICAgICAgIEV2ZW50VGFyZ2V0U3RhdGljLnRhcmdldFN0YXRpYy5yZW1vdmVFdmVudExpc3RlbmVyKF90eXBlLCBfaGFuZGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgZGlzcGF0Y2hFdmVudChfZXZlbnQ6IEV2ZW50KTogYm9vbGVhbiB7XHJcbiAgICAgICAgICAgIEV2ZW50VGFyZ2V0U3RhdGljLnRhcmdldFN0YXRpYy5kaXNwYXRjaEV2ZW50KF9ldmVudCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vRXZlbnQvRXZlbnQudHNcIi8+XHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEludGVyZmFjZSBkZXNjcmliaW5nIHRoZSBkYXRhdHlwZXMgb2YgdGhlIGF0dHJpYnV0ZXMgYSBtdXRhdG9yIGFzIHN0cmluZ3MgXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBNdXRhdG9yQXR0cmlidXRlVHlwZXMge1xyXG4gICAgW2F0dHJpYnV0ZTogc3RyaW5nXTogc3RyaW5nIHwgT2JqZWN0O1xyXG4gIH1cclxuICAvKipcclxuICAgKiBJbnRlcmZhY2UgZGVzY3JpYmluZyBhIG11dGF0b3IsIHdoaWNoIGlzIGFuIGFzc29jaWF0aXZlIGFycmF5IHdpdGggbmFtZXMgb2YgYXR0cmlidXRlcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyB2YWx1ZXNcclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIE11dGF0b3Ige1xyXG4gICAgW2F0dHJpYnV0ZTogc3RyaW5nXTogT2JqZWN0O1xyXG4gIH1cclxuXHJcbiAgLypcclxuICAgKiBJbnRlcmZhY2VzIGRlZGljYXRlZCBmb3IgZWFjaCBwdXJwb3NlLiBFeHRyYSBhdHRyaWJ1dGUgbmVjZXNzYXJ5IGZvciBjb21waWxldGltZSB0eXBlIGNoZWNraW5nLCBub3QgZXhpc3RlbnQgYXQgcnVudGltZVxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgTXV0YXRvckZvckFuaW1hdGlvbiBleHRlbmRzIE11dGF0b3IgeyByZWFkb25seSBmb3JBbmltYXRpb246IG51bGw7IH1cclxuICBleHBvcnQgaW50ZXJmYWNlIE11dGF0b3JGb3JVc2VySW50ZXJmYWNlIGV4dGVuZHMgTXV0YXRvciB7IHJlYWRvbmx5IGZvclVzZXJJbnRlcmZhY2U6IG51bGw7IH1cclxuICAvLyBleHBvcnQgaW50ZXJmYWNlIE11dGF0b3JGb3JDb21wb25lbnQgZXh0ZW5kcyBNdXRhdG9yIHsgcmVhZG9ubHkgZm9yVXNlckNvbXBvbmVudDogbnVsbDsgfVxyXG5cclxuICAvKipcclxuICAgKiBDb2xsZWN0IGFwcGxpY2FibGUgYXR0cmlidXRlcyBvZiB0aGUgaW5zdGFuY2UgYW5kIGNvcGllcyBvZiB0aGVpciB2YWx1ZXMgaW4gYSBNdXRhdG9yLW9iamVjdFxyXG4gICAqL1xyXG4gIGV4cG9ydCBmdW5jdGlvbiBnZXRNdXRhdG9yT2ZBcmJpdHJhcnkoX29iamVjdDogT2JqZWN0KTogTXV0YXRvciB7XHJcbiAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHt9O1xyXG4gICAgbGV0IGF0dHJpYnV0ZXM6IChzdHJpbmcgfCBudW1iZXIgfCBzeW1ib2wpW10gPSBSZWZsZWN0Lm93bktleXMoUmVmbGVjdC5nZXRQcm90b3R5cGVPZihfb2JqZWN0KSk7XHJcbiAgICBmb3IgKGxldCBhdHRyaWJ1dGUgb2YgYXR0cmlidXRlcykge1xyXG4gICAgICBsZXQgdmFsdWU6IE9iamVjdCA9IFJlZmxlY3QuZ2V0KF9vYmplY3QsIGF0dHJpYnV0ZSk7XHJcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKVxyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAvLyBpZiAodmFsdWUgaW5zdGFuY2VvZiBPYmplY3QgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIE11dGFibGUpKVxyXG4gICAgICAvLyAgIGNvbnRpbnVlO1xyXG4gICAgICBtdXRhdG9yW2F0dHJpYnV0ZS50b1N0cmluZygpXSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEJhc2UgY2xhc3MgZm9yIGFsbCB0eXBlcyBiZWluZyBtdXRhYmxlIHVzaW5nIFtbTXV0YXRvcl1dLW9iamVjdHMsIHRodXMgcHJvdmlkaW5nIGFuZCB1c2luZyBpbnRlcmZhY2VzIGNyZWF0ZWQgYXQgcnVudGltZS4gIFxyXG4gICAqIE11dGFibGVzIHByb3ZpZGUgYSBbW011dGF0b3JdXSB0aGF0IGlzIGJ1aWxkIGJ5IGNvbGxlY3RpbmcgYWxsIG9iamVjdC1wcm9wZXJ0aWVzIHRoYXQgYXJlIGVpdGhlciBvZiBhIHByaW1pdGl2ZSB0eXBlIG9yIGFnYWluIE11dGFibGUuXHJcbiAgICogU3ViY2xhc3NlcyBjYW4gZWl0aGVyIHJlZHVjZSB0aGUgc3RhbmRhcmQgW1tNdXRhdG9yXV0gYnVpbHQgYnkgdGhpcyBiYXNlIGNsYXNzIGJ5IGRlbGV0aW5nIHByb3BlcnRpZXMgb3IgaW1wbGVtZW50IGFuIGluZGl2aWR1YWwgZ2V0TXV0YXRvci1tZXRob2QuXHJcbiAgICogVGhlIHByb3ZpZGVkIHByb3BlcnRpZXMgb2YgdGhlIFtbTXV0YXRvcl1dIG11c3QgbWF0Y2ggcHVibGljIHByb3BlcnRpZXMgb3IgZ2V0dGVycy9zZXR0ZXJzIG9mIHRoZSBvYmplY3QuXHJcbiAgICogT3RoZXJ3aXNlLCB0aGV5IHdpbGwgYmUgaWdub3JlZCBpZiBub3QgaGFuZGxlZCBieSBhbiBvdmVycmlkZSBvZiB0aGUgbXV0YXRlLW1ldGhvZCBpbiB0aGUgc3ViY2xhc3MgYW5kIHRocm93IGVycm9ycyBpbiBhbiBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCB1c2VyLWludGVyZmFjZSBmb3IgdGhlIG9iamVjdC5cclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgTXV0YWJsZSBleHRlbmRzIEV2ZW50VGFyZ2V0xpIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHR5cGUgb2YgdGhpcyBtdXRhYmxlIHN1YmNsYXNzIGFzIHRoZSBuYW1lIG9mIHRoZSBydW50aW1lIGNsYXNzXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdHlwZSBvZiB0aGUgbXV0YWJsZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHR5cGUoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29sbGVjdCBhcHBsaWNhYmxlIGF0dHJpYnV0ZXMgb2YgdGhlIGluc3RhbmNlIGFuZCBjb3BpZXMgb2YgdGhlaXIgdmFsdWVzIGluIGEgTXV0YXRvci1vYmplY3RcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0ge307XHJcblxyXG4gICAgICAvLyBjb2xsZWN0IHByaW1pdGl2ZSBhbmQgbXV0YWJsZSBhdHRyaWJ1dGVzXHJcbiAgICAgIGZvciAobGV0IGF0dHJpYnV0ZSBpbiB0aGlzKSB7XHJcbiAgICAgICAgbGV0IHZhbHVlOiBPYmplY3QgPSB0aGlzW2F0dHJpYnV0ZV07XHJcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pXHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBPYmplY3QgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIE11dGFibGUpICYmICEodmFsdWUuaGFzT3duUHJvcGVydHkoXCJpZFJlc291cmNlXCIpKSlcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIG11dGF0b3JbYXR0cmlidXRlXSA9IHRoaXNbYXR0cmlidXRlXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gbXV0YXRvciBjYW4gYmUgcmVkdWNlZCBidXQgbm90IGV4dGVuZGVkIVxyXG4gICAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnMobXV0YXRvcik7XHJcbiAgICAgIC8vIGRlbGV0ZSB1bndhbnRlZCBhdHRyaWJ1dGVzXHJcbiAgICAgIHRoaXMucmVkdWNlTXV0YXRvcihtdXRhdG9yKTtcclxuXHJcbiAgICAgIC8vIHJlcGxhY2UgcmVmZXJlbmNlcyB0byBtdXRhYmxlIG9iamVjdHMgd2l0aCByZWZlcmVuY2VzIHRvIGNvcGllc1xyXG4gICAgICBmb3IgKGxldCBhdHRyaWJ1dGUgaW4gbXV0YXRvcikge1xyXG4gICAgICAgIGxldCB2YWx1ZTogT2JqZWN0ID0gbXV0YXRvclthdHRyaWJ1dGVdO1xyXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE11dGFibGUpXHJcbiAgICAgICAgICBtdXRhdG9yW2F0dHJpYnV0ZV0gPSB2YWx1ZS5nZXRNdXRhdG9yKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29sbGVjdCB0aGUgYXR0cmlidXRlcyBvZiB0aGUgaW5zdGFuY2UgYW5kIHRoZWlyIHZhbHVlcyBhcHBsaWNhYmxlIGZvciBhbmltYXRpb24uXHJcbiAgICAgKiBCYXNpYyBmdW5jdGlvbmFsaXR5IGlzIGlkZW50aWNhbCB0byBbW2dldE11dGF0b3JdXSwgcmV0dXJuZWQgbXV0YXRvciBzaG91bGQgdGhlbiBiZSByZWR1Y2VkIGJ5IHRoZSBzdWJjbGFzc2VkIGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yRm9yQW5pbWF0aW9uKCk6IE11dGF0b3JGb3JBbmltYXRpb24ge1xyXG4gICAgICByZXR1cm4gPE11dGF0b3JGb3JBbmltYXRpb24+dGhpcy5nZXRNdXRhdG9yKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbGxlY3QgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIGluc3RhbmNlIGFuZCB0aGVpciB2YWx1ZXMgYXBwbGljYWJsZSBmb3IgdGhlIHVzZXIgaW50ZXJmYWNlLlxyXG4gICAgICogQmFzaWMgZnVuY3Rpb25hbGl0eSBpcyBpZGVudGljYWwgdG8gW1tnZXRNdXRhdG9yXV0sIHJldHVybmVkIG11dGF0b3Igc2hvdWxkIHRoZW4gYmUgcmVkdWNlZCBieSB0aGUgc3ViY2xhc3NlZCBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvckZvclVzZXJJbnRlcmZhY2UoKTogTXV0YXRvckZvclVzZXJJbnRlcmZhY2Uge1xyXG4gICAgICByZXR1cm4gPE11dGF0b3JGb3JVc2VySW50ZXJmYWNlPnRoaXMuZ2V0TXV0YXRvcigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb2xsZWN0IHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBpbnN0YW5jZSBhbmQgdGhlaXIgdmFsdWVzIGFwcGxpY2FibGUgZm9yIGluZGl2aXVhbGl6YXRpb24gYnkgdGhlIGNvbXBvbmVudC5cclxuICAgICAqIEJhc2ljIGZ1bmN0aW9uYWxpdHkgaXMgaWRlbnRpY2FsIHRvIFtbZ2V0TXV0YXRvcl1dLCByZXR1cm5lZCBtdXRhdG9yIHNob3VsZCB0aGVuIGJlIHJlZHVjZWQgYnkgdGhlIHN1YmNsYXNzZWQgaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgLy8gcHVibGljIGdldE11dGF0b3JGb3JDb21wb25lbnQoKTogTXV0YXRvckZvckNvbXBvbmVudCB7XHJcbiAgICAvLyAgICAgcmV0dXJuIDxNdXRhdG9yRm9yQ29tcG9uZW50PnRoaXMuZ2V0TXV0YXRvcigpO1xyXG4gICAgLy8gfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIGFzc29jaWF0aXZlIGFycmF5IHdpdGggdGhlIHNhbWUgYXR0cmlidXRlcyBhcyB0aGUgZ2l2ZW4gbXV0YXRvciwgYnV0IHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgdHlwZXMgYXMgc3RyaW5nLXZhbHVlc1xyXG4gICAgICogRG9lcyBub3QgcmVjdXJzZSBpbnRvIG9iamVjdHMhXHJcbiAgICAgKiBAcGFyYW0gX211dGF0b3IgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yQXR0cmlidXRlVHlwZXMoX211dGF0b3I6IE11dGF0b3IpOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMge1xyXG4gICAgICBsZXQgdHlwZXM6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyA9IHt9O1xyXG4gICAgICBmb3IgKGxldCBhdHRyaWJ1dGUgaW4gX211dGF0b3IpIHtcclxuICAgICAgICBsZXQgdHlwZTogc3RyaW5nID0gbnVsbDtcclxuICAgICAgICBsZXQgdmFsdWU6IG51bWJlciB8IGJvb2xlYW4gfCBzdHJpbmcgfCBvYmplY3QgPSBfbXV0YXRvclthdHRyaWJ1dGVdO1xyXG4gICAgICAgIGlmIChfbXV0YXRvclthdHRyaWJ1dGVdICE9IHVuZGVmaW5lZClcclxuICAgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PSBcIm9iamVjdFwiKVxyXG4gICAgICAgICAgICB0eXBlID0gKDxHZW5lcmFsPnRoaXMpW2F0dHJpYnV0ZV0uY29uc3RydWN0b3IubmFtZTtcclxuICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiAodmFsdWUpID09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICAgICAgdHlwZSA9IHZhbHVlW1wibmFtZVwiXTtcclxuICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdHlwZSA9IF9tdXRhdG9yW2F0dHJpYnV0ZV0uY29uc3RydWN0b3IubmFtZTtcclxuICAgICAgICB0eXBlc1thdHRyaWJ1dGVdID0gdHlwZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdHlwZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gbXV0YXRvciBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0gX211dGF0b3IgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB1cGRhdGVNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIGZvciAobGV0IGF0dHJpYnV0ZSBpbiBfbXV0YXRvcikge1xyXG4gICAgICAgIGxldCB2YWx1ZTogT2JqZWN0ID0gX211dGF0b3JbYXR0cmlidXRlXTtcclxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNdXRhYmxlKVxyXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5nZXRNdXRhdG9yKCk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgX211dGF0b3JbYXR0cmlidXRlXSA9ICg8R2VuZXJhbD50aGlzKVthdHRyaWJ1dGVdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIGF0dHJpYnV0ZSB2YWx1ZXMgb2YgdGhlIGluc3RhbmNlIGFjY29yZGluZyB0byB0aGUgc3RhdGUgb2YgdGhlIG11dGF0b3IuIE11c3QgYmUgcHJvdGVjdGVkLi4uIVxyXG4gICAgICogQHBhcmFtIF9tdXRhdG9yXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgLy8gVE9ETzogZG9uJ3QgYXNzaWduIHVua25vd24gcHJvcGVydGllc1xyXG4gICAgICBmb3IgKGxldCBhdHRyaWJ1dGUgaW4gX211dGF0b3IpIHtcclxuICAgICAgICBsZXQgdmFsdWU6IE11dGF0b3IgPSA8TXV0YXRvcj5fbXV0YXRvclthdHRyaWJ1dGVdO1xyXG4gICAgICAgIGxldCBtdXRhbnQ6IE9iamVjdCA9ICg8R2VuZXJhbD50aGlzKVthdHRyaWJ1dGVdO1xyXG4gICAgICAgIGlmIChtdXRhbnQgaW5zdGFuY2VvZiBNdXRhYmxlKVxyXG4gICAgICAgICAgbXV0YW50Lm11dGF0ZSh2YWx1ZSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgKDxHZW5lcmFsPnRoaXMpW2F0dHJpYnV0ZV0gPSB2YWx1ZTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULk1VVEFURSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWR1Y2VzIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBnZW5lcmFsIG11dGF0b3IgYWNjb3JkaW5nIHRvIGRlc2lyZWQgb3B0aW9ucyBmb3IgbXV0YXRpb24uIFRvIGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzZXNcclxuICAgICAqIEBwYXJhbSBfbXV0YXRvciBcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkO1xyXG4gIH1cclxufVxyXG4iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tYW55XHJcbiAgICBleHBvcnQgdHlwZSBHZW5lcmFsID0gYW55O1xyXG5cclxuICAgIGV4cG9ydCBpbnRlcmZhY2UgU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgICAgW3R5cGU6IHN0cmluZ106IEdlbmVyYWw7XHJcbiAgICB9XHJcbiAgICBleHBvcnQgaW50ZXJmYWNlIFNlcmlhbGl6YWJsZSB7XHJcbiAgICAgICAgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb247XHJcbiAgICAgICAgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBTZXJpYWxpemFibGU7XHJcbiAgICB9XHJcblxyXG4gICAgaW50ZXJmYWNlIE5hbWVzcGFjZVJlZ2lzdGVyIHtcclxuICAgICAgICBbbmFtZTogc3RyaW5nXTogT2JqZWN0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlcyB0aGUgZXh0ZXJuYWwgc2VyaWFsaXphdGlvbiBhbmQgZGVzZXJpYWxpemF0aW9uIG9mIFtbU2VyaWFsaXphYmxlXV0gb2JqZWN0cy4gVGhlIGludGVybmFsIHByb2Nlc3MgaXMgaGFuZGxlZCBieSB0aGUgb2JqZWN0cyB0aGVtc2VsdmVzLiAgXHJcbiAgICAgKiBBIFtbU2VyaWFsaXphdGlvbl1dIG9iamVjdCBjYW4gYmUgY3JlYXRlZCBmcm9tIGEgW1tTZXJpYWxpemFibGVdXSBvYmplY3QgYW5kIGEgSlNPTi1TdHJpbmcgbWF5IGJlIGNyZWF0ZWQgZnJvbSB0aGF0LiAgXHJcbiAgICAgKiBWaWNlIHZlcnNhLCBhIEpTT04tU3RyaW5nIGNhbiBiZSBwYXJzZWQgdG8gYSBbW1NlcmlhbGl6YXRpb25dXSB3aGljaCBjYW4gYmUgZGVzZXJpYWxpemVkIHRvIGEgW1tTZXJpYWxpemFibGVdXSBvYmplY3QuXHJcbiAgICAgKiBgYGBwbGFpbnRleHRcclxuICAgICAqICBbU2VyaWFsaXphYmxlXSDihpIgKHNlcmlhbGl6ZSkg4oaSIFtTZXJpYWxpemF0aW9uXSDihpIgKHN0cmluZ2lmeSkgIFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKGk1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1N0cmluZ11cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDihpNcclxuICAgICAqICBbU2VyaWFsaXphYmxlXSDihpAgKGRlc2VyaWFsaXplKSDihpAgW1NlcmlhbGl6YXRpb25dIOKGkCAocGFyc2UpXHJcbiAgICAgKiBgYGAgICAgICBcclxuICAgICAqIFdoaWxlIHRoZSBpbnRlcm5hbCBzZXJpYWxpemUvZGVzZXJpYWxpemUgbWV0aG9kcyBvZiB0aGUgb2JqZWN0cyBjYXJlIG9mIHRoZSBzZWxlY3Rpb24gb2YgaW5mb3JtYXRpb24gbmVlZGVkIHRvIHJlY3JlYXRlIHRoZSBvYmplY3QgYW5kIGl0cyBzdHJ1Y3R1cmUsICBcclxuICAgICAqIHRoZSBbW1NlcmlhbGl6ZXJdXSBrZWVwcyB0cmFjayBvZiB0aGUgbmFtZXNwYWNlcyBhbmQgY2xhc3NlcyBpbiBvcmRlciB0byByZWNyZWF0ZSBbW1NlcmlhbGl6YWJsZV1dIG9iamVjdHMuIFRoZSBnZW5lcmFsIHN0cnVjdHVyZSBvZiBhIFtbU2VyaWFsaXphdGlvbl1dIGlzIGFzIGZvbGxvd3MgIFxyXG4gICAgICogYGBgcGxhaW50ZXh0XHJcbiAgICAgKiB7XHJcbiAgICAgKiAgICAgIG5hbWVzcGFjZU5hbWUuY2xhc3NOYW1lOiB7XHJcbiAgICAgKiAgICAgICAgICBwcm9wZXJ0eU5hbWU6IHByb3BlcnR5VmFsdWUsXHJcbiAgICAgKiAgICAgICAgICAuLi4sXHJcbiAgICAgKiAgICAgICAgICBwcm9wZXJ0eU5hbWVPZlJlZmVyZW5jZTogU2VyaWFsaXphdGlvbk9mVGhlUmVmZXJlbmNlZE9iamVjdCxcclxuICAgICAqICAgICAgICAgIC4uLixcclxuICAgICAqICAgICAgICAgIGNvbnN0cnVjdG9yTmFtZU9mU3VwZXJjbGFzczogU2VyaWFsaXphdGlvbk9mU3VwZXJDbGFzc1xyXG4gICAgICogICAgICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqIFNpbmNlIHRoZSBpbnN0YW5jZSBvZiB0aGUgc3VwZXJjbGFzcyBpcyBjcmVhdGVkIGF1dG9tYXRpY2FsbHkgd2hlbiBhbiBvYmplY3QgaXMgY3JlYXRlZCwgXHJcbiAgICAgKiB0aGUgU2VyaWFsaXphdGlvbk9mU3VwZXJDbGFzcyBvbWl0cyB0aGUgdGhlIG5hbWVzcGFjZU5hbWUuY2xhc3NOYW1lIGtleSBhbmQgY29uc2lzdHMgb25seSBvZiBpdHMgdmFsdWUuIFxyXG4gICAgICogVGhlIGNvbnN0cnVjdG9yTmFtZU9mU3VwZXJjbGFzcyBpcyBnaXZlbiBpbnN0ZWFkIGFzIGEgcHJvcGVydHkgbmFtZSBpbiB0aGUgc2VyaWFsaXphdGlvbiBvZiB0aGUgc3ViY2xhc3MuXHJcbiAgICAgKi9cclxuICAgIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTZXJpYWxpemVyIHtcclxuICAgICAgICAvKiogSW4gb3JkZXIgZm9yIHRoZSBTZXJpYWxpemVyIHRvIGNyZWF0ZSBjbGFzcyBpbnN0YW5jZXMsIGl0IG5lZWRzIGFjY2VzcyB0byB0aGUgYXBwcm9wcmlhdGUgbmFtZXNwYWNlcyAqL1xyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIG5hbWVzcGFjZXM6IE5hbWVzcGFjZVJlZ2lzdGVyID0geyBcIsaSXCI6IEZ1ZGdlQ29yZSB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWdpc3RlcnMgYSBuYW1lc3BhY2UgdG8gdGhlIFtbU2VyaWFsaXplcl1dLCB0byBlbmFibGUgYXV0b21hdGljIGluc3RhbnRpYXRpb24gb2YgY2xhc3NlcyBkZWZpbmVkIHdpdGhpblxyXG4gICAgICAgICAqIEBwYXJhbSBfbmFtZXNwYWNlIFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgcmVnaXN0ZXJOYW1lc3BhY2UoX25hbWVzcGFjZTogT2JqZWN0KTogdm9pZCB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IG5hbWUgaW4gU2VyaWFsaXplci5uYW1lc3BhY2VzKVxyXG4gICAgICAgICAgICAgICAgaWYgKFNlcmlhbGl6ZXIubmFtZXNwYWNlc1tuYW1lXSA9PSBfbmFtZXNwYWNlKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGxldCBuYW1lOiBzdHJpbmcgPSBTZXJpYWxpemVyLmZpbmROYW1lc3BhY2VJbihfbmFtZXNwYWNlLCB3aW5kb3cpO1xyXG4gICAgICAgICAgICBpZiAoIW5hbWUpXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwYXJlbnROYW1lIGluIFNlcmlhbGl6ZXIubmFtZXNwYWNlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBTZXJpYWxpemVyLmZpbmROYW1lc3BhY2VJbihfbmFtZXNwYWNlLCBTZXJpYWxpemVyLm5hbWVzcGFjZXNbcGFyZW50TmFtZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBwYXJlbnROYW1lICsgXCIuXCIgKyBuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIW5hbWUpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOYW1lc3BhY2Ugbm90IGZvdW5kLiBNYXliZSBwYXJlbnQgbmFtZXNwYWNlIGhhc24ndCBiZWVuIHJlZ2lzdGVyZWQgYmVmb3JlP1wiKTtcclxuXHJcbiAgICAgICAgICAgIFNlcmlhbGl6ZXIubmFtZXNwYWNlc1tuYW1lXSA9IF9uYW1lc3BhY2U7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIGphdmFzY3JpcHQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgc2VyaWFsaXphYmxlIEZVREdFLW9iamVjdCBnaXZlbixcclxuICAgICAgICAgKiBpbmNsdWRpbmcgYXR0YWNoZWQgY29tcG9uZW50cywgY2hpbGRyZW4sIHN1cGVyY2xhc3Mtb2JqZWN0cyBhbGwgaW5mb3JtYXRpb24gbmVlZGVkIGZvciByZWNvbnN0cnVjdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSBfb2JqZWN0IEFuIG9iamVjdCB0byBzZXJpYWxpemUsIGltcGxlbWVudGluZyB0aGUgW1tTZXJpYWxpemFibGVdXSBpbnRlcmZhY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBwdWJsaWMgc3RhdGljIHNlcmlhbGl6ZShfb2JqZWN0OiBTZXJpYWxpemFibGUpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7fTtcclxuICAgICAgICAgICAgLy8gVE9ETzogc2F2ZSB0aGUgbmFtZXNwYWNlIHdpdGggdGhlIGNvbnN0cnVjdG9ycyBuYW1lXHJcbiAgICAgICAgICAgIC8vIHNlcmlhbGl6YXRpb25bX29iamVjdC5jb25zdHJ1Y3Rvci5uYW1lXSA9IF9vYmplY3Quc2VyaWFsaXplKCk7XHJcbiAgICAgICAgICAgIGxldCBwYXRoOiBzdHJpbmcgPSB0aGlzLmdldEZ1bGxQYXRoKF9vYmplY3QpO1xyXG4gICAgICAgICAgICBpZiAoIXBhdGgpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5hbWVzcGFjZSBvZiBzZXJpYWxpemFibGUgb2JqZWN0IG9mIHR5cGUgJHtfb2JqZWN0LmNvbnN0cnVjdG9yLm5hbWV9IG5vdCBmb3VuZC4gTWF5YmUgdGhlIG5hbWVzcGFjZSBoYXNuJ3QgYmVlbiByZWdpc3RlcmVkIG9yIHRoZSBjbGFzcyBub3QgZXhwb3J0ZWQ/YCk7XHJcbiAgICAgICAgICAgIHNlcmlhbGl6YXRpb25bcGF0aF0gPSBfb2JqZWN0LnNlcmlhbGl6ZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgICAgICAgICAgLy8gcmV0dXJuIF9vYmplY3Quc2VyaWFsaXplKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgRlVER0Utb2JqZWN0IHJlY29uc3RydWN0ZWQgZnJvbSB0aGUgaW5mb3JtYXRpb24gaW4gdGhlIFtbU2VyaWFsaXphdGlvbl1dIGdpdmVuLFxyXG4gICAgICAgICAqIGluY2x1ZGluZyBhdHRhY2hlZCBjb21wb25lbnRzLCBjaGlsZHJlbiwgc3VwZXJjbGFzcy1vYmplY3RzXHJcbiAgICAgICAgICogQHBhcmFtIF9zZXJpYWxpemF0aW9uIFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBTZXJpYWxpemFibGUge1xyXG4gICAgICAgICAgICBsZXQgcmVjb25zdHJ1Y3Q6IFNlcmlhbGl6YWJsZTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIC8vIGxvb3AgY29uc3RydWN0ZWQgc29sZWx5IHRvIGFjY2VzcyB0eXBlLXByb3BlcnR5LiBPbmx5IG9uZSBleHBlY3RlZCFcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHBhdGggaW4gX3NlcmlhbGl6YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyByZWNvbnN0cnVjdCA9IG5ldyAoPEdlbmVyYWw+RnVkZ2UpW3R5cGVOYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICByZWNvbnN0cnVjdCA9IFNlcmlhbGl6ZXIucmVjb25zdHJ1Y3QocGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVjb25zdHJ1Y3QgPSByZWNvbnN0cnVjdC5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltwYXRoXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlY29uc3RydWN0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRlc2VyaWFsaXphdGlvbiBmYWlsZWQ6IFwiICsgX2Vycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vVE9ETzogaW1wbGVtZW50IHByZXR0aWZpZXIgdG8gbWFrZSBKU09OLVN0cmluZ2lmaWNhdGlvbiBvZiBzZXJpYWxpemF0aW9ucyBtb3JlIHJlYWRhYmxlLCBlLmcuIHBsYWNpbmcgeCwgeSBhbmQgeiBpbiBvbmUgbGluZVxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgcHJldHRpZnkoX2pzb246IHN0cmluZyk6IHN0cmluZyB7IHJldHVybiBfanNvbjsgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgZm9ybWF0dGVkLCBodW1hbiByZWFkYWJsZSBKU09OLVN0cmluZywgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBbW1NlcmlhbGl6YWlvbl1dIHRoYXQgbWF5IGhhdmUgYmVlbiBjcmVhdGVkIGJ5IFtbU2VyaWFsaXplcl1dLnNlcmlhbGl6ZVxyXG4gICAgICAgICAqIEBwYXJhbSBfc2VyaWFsaXphdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgc3RyaW5naWZ5KF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogc3RyaW5nIHtcclxuICAgICAgICAgICAgLy8gYWRqdXN0bWVudHMgdG8gc2VyaWFsaXphdGlvbiBjYW4gYmUgbWFkZSBoZXJlIGJlZm9yZSBzdHJpbmdpZmljYXRpb24sIGlmIGRlc2lyZWRcclxuICAgICAgICAgICAgbGV0IGpzb246IHN0cmluZyA9IEpTT04uc3RyaW5naWZ5KF9zZXJpYWxpemF0aW9uLCBudWxsLCAyKTtcclxuICAgICAgICAgICAgbGV0IHByZXR0eTogc3RyaW5nID0gU2VyaWFsaXplci5wcmV0dGlmeShqc29uKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByZXR0eTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBbW1NlcmlhbGl6YXRpb25dXSBjcmVhdGVkIGZyb20gdGhlIGdpdmVuIEpTT04tU3RyaW5nLiBSZXN1bHQgbWF5IGJlIHBhc3NlZCB0byBbW1NlcmlhbGl6ZXJdXS5kZXNlcmlhbGl6ZVxyXG4gICAgICAgICAqIEBwYXJhbSBfanNvbiBcclxuICAgICAgICAgKi9cclxuICAgICAgICBwdWJsaWMgc3RhdGljIHBhcnNlKF9qc29uOiBzdHJpbmcpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoX2pzb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBvZiB0aGUgY2xhc3MgZGVmaW5lZCB3aXRoIHRoZSBmdWxsIHBhdGggaW5jbHVkaW5nIHRoZSBuYW1lc3BhY2VOYW1lKHMpIGFuZCB0aGUgY2xhc3NOYW1lIHNlcGVyYXRlZCBieSBkb3RzKC4pIFxyXG4gICAgICAgICAqIEBwYXJhbSBfcGF0aCBcclxuICAgICAgICAgKi9cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyByZWNvbnN0cnVjdChfcGF0aDogc3RyaW5nKTogU2VyaWFsaXphYmxlIHtcclxuICAgICAgICAgICAgbGV0IHR5cGVOYW1lOiBzdHJpbmcgPSBfcGF0aC5zdWJzdHIoX3BhdGgubGFzdEluZGV4T2YoXCIuXCIpICsgMSk7XHJcbiAgICAgICAgICAgIGxldCBuYW1lc3BhY2U6IE9iamVjdCA9IFNlcmlhbGl6ZXIuZ2V0TmFtZXNwYWNlKF9wYXRoKTtcclxuICAgICAgICAgICAgaWYgKCFuYW1lc3BhY2UpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5hbWVzcGFjZSBvZiBzZXJpYWxpemFibGUgb2JqZWN0IG9mIHR5cGUgJHt0eXBlTmFtZX0gbm90IGZvdW5kLiBNYXliZSB0aGUgbmFtZXNwYWNlIGhhc24ndCBiZWVuIHJlZ2lzdGVyZWQ/YCk7XHJcbiAgICAgICAgICAgIGxldCByZWNvbnN0cnVjdGlvbjogU2VyaWFsaXphYmxlID0gbmV3ICg8R2VuZXJhbD5uYW1lc3BhY2UpW3R5cGVOYW1lXTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlY29uc3RydWN0aW9uO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgZnVsbCBwYXRoIHRvIHRoZSBjbGFzcyBvZiB0aGUgb2JqZWN0LCBpZiBmb3VuZCBpbiB0aGUgcmVnaXN0ZXJlZCBuYW1lc3BhY2VzXHJcbiAgICAgICAgICogQHBhcmFtIF9vYmplY3QgXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgZ2V0RnVsbFBhdGgoX29iamVjdDogU2VyaWFsaXphYmxlKTogc3RyaW5nIHtcclxuICAgICAgICAgICAgbGV0IHR5cGVOYW1lOiBzdHJpbmcgPSBfb2JqZWN0LmNvbnN0cnVjdG9yLm5hbWU7XHJcbiAgICAgICAgICAgIC8vIERlYnVnLmxvZyhcIlNlYXJjaGluZyBuYW1lc3BhY2Ugb2Y6IFwiICsgdHlwZU5hbWUpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lc3BhY2VOYW1lIGluIFNlcmlhbGl6ZXIubmFtZXNwYWNlcykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kOiBHZW5lcmFsID0gKDxHZW5lcmFsPlNlcmlhbGl6ZXIubmFtZXNwYWNlcylbbmFtZXNwYWNlTmFtZV1bdHlwZU5hbWVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kICYmIF9vYmplY3QgaW5zdGFuY2VvZiBmb3VuZClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZXNwYWNlTmFtZSArIFwiLlwiICsgdHlwZU5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBuYW1lc3BhY2Utb2JqZWN0IGRlZmluZWQgd2l0aGluIHRoZSBmdWxsIHBhdGgsIGlmIHJlZ2lzdGVyZWRcclxuICAgICAgICAgKiBAcGFyYW0gX3BhdGhcclxuICAgICAgICAgKi9cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBnZXROYW1lc3BhY2UoX3BhdGg6IHN0cmluZyk6IE9iamVjdCB7XHJcbiAgICAgICAgICAgIGxldCBuYW1lc3BhY2VOYW1lOiBzdHJpbmcgPSBfcGF0aC5zdWJzdHIoMCwgX3BhdGgubGFzdEluZGV4T2YoXCIuXCIpKTtcclxuICAgICAgICAgICAgcmV0dXJuIFNlcmlhbGl6ZXIubmFtZXNwYWNlc1tuYW1lc3BhY2VOYW1lXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZpbmRzIHRoZSBuYW1lc3BhY2Utb2JqZWN0IGluIHByb3BlcnRpZXMgb2YgdGhlIHBhcmVudC1vYmplY3QgKGUuZy4gd2luZG93KSwgaWYgcHJlc2VudFxyXG4gICAgICAgICAqIEBwYXJhbSBfbmFtZXNwYWNlIFxyXG4gICAgICAgICAqIEBwYXJhbSBfcGFyZW50IFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIGZpbmROYW1lc3BhY2VJbihfbmFtZXNwYWNlOiBPYmplY3QsIF9wYXJlbnQ6IE9iamVjdCk6IHN0cmluZyB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHByb3AgaW4gX3BhcmVudClcclxuICAgICAgICAgICAgICAgIGlmICgoPEdlbmVyYWw+X3BhcmVudClbcHJvcF0gPT0gX25hbWVzcGFjZSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcDtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGNsYXNzIFJlbmRlckluamVjdG9yIHtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGluamVjdChfY29uc3RydWN0b3I6IEZ1bmN0aW9uLCBfaW5qZWN0b3I6IHR5cGVvZiBSZW5kZXJJbmplY3Rvcik6IHZvaWQge1xyXG4gICAgICBsZXQgaW5qZWN0aW9uOiBGdW5jdGlvbiA9IFJlZmxlY3QuZ2V0KF9pbmplY3RvciwgXCJpbmplY3RcIiArIF9jb25zdHJ1Y3Rvci5uYW1lKTtcclxuICAgICAgaWYgKCFpbmplY3Rpb24pIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiTm8gaW5qZWN0aW9uIGRlY29yYXRvciBkZWZpbmVkIGZvciBcIiArIF9jb25zdHJ1Y3Rvci5uYW1lKTtcclxuICAgICAgfVxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2NvbnN0cnVjdG9yLnByb3RvdHlwZSwgXCJ1c2VSZW5kZXJEYXRhXCIsIHtcclxuICAgICAgICB2YWx1ZTogaW5qZWN0aW9uXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBjbGFzcyBSZW5kZXJJbmplY3RvclNoYWRlciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIGRlY29yYXRlKF9jb25zdHJ1Y3RvcjogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9jb25zdHJ1Y3RvciwgXCJ1c2VQcm9ncmFtXCIsIHtcclxuICAgICAgICB2YWx1ZTogUmVuZGVySW5qZWN0b3JTaGFkZXIudXNlUHJvZ3JhbVxyXG4gICAgICB9KTtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9jb25zdHJ1Y3RvciwgXCJkZWxldGVQcm9ncmFtXCIsIHtcclxuICAgICAgICB2YWx1ZTogUmVuZGVySW5qZWN0b3JTaGFkZXIuZGVsZXRlUHJvZ3JhbVxyXG4gICAgICB9KTtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9jb25zdHJ1Y3RvciwgXCJjcmVhdGVQcm9ncmFtXCIsIHtcclxuICAgICAgICB2YWx1ZTogUmVuZGVySW5qZWN0b3JTaGFkZXIuY3JlYXRlUHJvZ3JhbVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIHVzZVByb2dyYW0odGhpczogdHlwZW9mIFNoYWRlcik6IHZvaWQge1xyXG4gICAgICBpZiAoIXRoaXMucHJvZ3JhbSlcclxuICAgICAgICB0aGlzLmNyZWF0ZVByb2dyYW0oKTtcclxuICAgICAgbGV0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJPcGVyYXRvci5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcbiAgICAgIGNyYzMudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xyXG4gICAgICBjcmMzLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuYXR0cmlidXRlc1tcImFfcG9zaXRpb25cIl0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZGVsZXRlUHJvZ3JhbSh0aGlzOiB0eXBlb2YgU2hhZGVyKTogdm9pZCB7XHJcbiAgICAgIGxldCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyT3BlcmF0b3IuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG4gICAgICBpZiAodGhpcy5wcm9ncmFtKSB7XHJcbiAgICAgICAgY3JjMy5kZWxldGVQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuYXR0cmlidXRlcztcclxuICAgICAgICBkZWxldGUgdGhpcy51bmlmb3JtcztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgY3JlYXRlUHJvZ3JhbSh0aGlzOiB0eXBlb2YgU2hhZGVyKTogdm9pZCB7XHJcbiAgICAgIERlYnVnLmZ1ZGdlKFwiQ3JlYXRlIHNoYWRlciBwcm9ncmFtXCIsIHRoaXMubmFtZSk7XHJcbiAgICAgIGxldCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyT3BlcmF0b3IuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG4gICAgICBsZXQgcHJvZ3JhbTogV2ViR0xQcm9ncmFtID0gY3JjMy5jcmVhdGVQcm9ncmFtKCk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY3JjMy5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgUmVuZGVyT3BlcmF0b3IuYXNzZXJ0PFdlYkdMU2hhZGVyPihjb21waWxlU2hhZGVyKHRoaXMuZ2V0VmVydGV4U2hhZGVyU291cmNlKCksIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVkVSVEVYX1NIQURFUikpKTtcclxuICAgICAgICBjcmMzLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBSZW5kZXJPcGVyYXRvci5hc3NlcnQ8V2ViR0xTaGFkZXI+KGNvbXBpbGVTaGFkZXIodGhpcy5nZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZSQUdNRU5UX1NIQURFUikpKTtcclxuICAgICAgICBjcmMzLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xyXG4gICAgICAgIGxldCBlcnJvcjogc3RyaW5nID0gUmVuZGVyT3BlcmF0b3IuYXNzZXJ0PHN0cmluZz4oY3JjMy5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSk7XHJcbiAgICAgICAgaWYgKGVycm9yICE9PSBcIlwiKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBsaW5raW5nIFNoYWRlcjogXCIgKyBlcnJvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xyXG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IGRldGVjdEF0dHJpYnV0ZXMoKTtcclxuICAgICAgICB0aGlzLnVuaWZvcm1zID0gZGV0ZWN0VW5pZm9ybXMoKTtcclxuXHJcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xyXG4gICAgICAgIERlYnVnLmVycm9yKF9lcnJvcik7XHJcbiAgICAgICAgZGVidWdnZXI7XHJcbiAgICAgIH1cclxuXHJcblxyXG4gICAgICBmdW5jdGlvbiBjb21waWxlU2hhZGVyKF9zaGFkZXJDb2RlOiBzdHJpbmcsIF9zaGFkZXJUeXBlOiBHTGVudW0pOiBXZWJHTFNoYWRlciB8IG51bGwge1xyXG4gICAgICAgIGxldCB3ZWJHTFNoYWRlcjogV2ViR0xTaGFkZXIgPSBjcmMzLmNyZWF0ZVNoYWRlcihfc2hhZGVyVHlwZSk7XHJcbiAgICAgICAgY3JjMy5zaGFkZXJTb3VyY2Uod2ViR0xTaGFkZXIsIF9zaGFkZXJDb2RlKTtcclxuICAgICAgICBjcmMzLmNvbXBpbGVTaGFkZXIod2ViR0xTaGFkZXIpO1xyXG4gICAgICAgIGxldCBlcnJvcjogc3RyaW5nID0gUmVuZGVyT3BlcmF0b3IuYXNzZXJ0PHN0cmluZz4oY3JjMy5nZXRTaGFkZXJJbmZvTG9nKHdlYkdMU2hhZGVyKSk7XHJcbiAgICAgICAgaWYgKGVycm9yICE9PSBcIlwiKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBjb21waWxpbmcgc2hhZGVyOiBcIiArIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGFueSBjb21waWxhdGlvbiBlcnJvcnMuXHJcbiAgICAgICAgaWYgKCFjcmMzLmdldFNoYWRlclBhcmFtZXRlcih3ZWJHTFNoYWRlciwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5DT01QSUxFX1NUQVRVUykpIHtcclxuICAgICAgICAgIGFsZXJ0KGNyYzMuZ2V0U2hhZGVySW5mb0xvZyh3ZWJHTFNoYWRlcikpO1xyXG4gICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB3ZWJHTFNoYWRlcjtcclxuICAgICAgfVxyXG4gICAgICBmdW5jdGlvbiBkZXRlY3RBdHRyaWJ1dGVzKCk6IHsgW25hbWU6IHN0cmluZ106IG51bWJlciB9IHtcclxuICAgICAgICBsZXQgZGV0ZWN0ZWRBdHRyaWJ1dGVzOiB7IFtuYW1lOiBzdHJpbmddOiBudW1iZXIgfSA9IHt9O1xyXG4gICAgICAgIGxldCBhdHRyaWJ1dGVDb3VudDogbnVtYmVyID0gY3JjMy5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQUNUSVZFX0FUVFJJQlVURVMpO1xyXG4gICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBhdHRyaWJ1dGVDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICBsZXQgYXR0cmlidXRlSW5mbzogV2ViR0xBY3RpdmVJbmZvID0gUmVuZGVyT3BlcmF0b3IuYXNzZXJ0PFdlYkdMQWN0aXZlSW5mbz4oY3JjMy5nZXRBY3RpdmVBdHRyaWIocHJvZ3JhbSwgaSkpO1xyXG4gICAgICAgICAgaWYgKCFhdHRyaWJ1dGVJbmZvKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZGV0ZWN0ZWRBdHRyaWJ1dGVzW2F0dHJpYnV0ZUluZm8ubmFtZV0gPSBjcmMzLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIGF0dHJpYnV0ZUluZm8ubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZXRlY3RlZEF0dHJpYnV0ZXM7XHJcbiAgICAgIH1cclxuICAgICAgZnVuY3Rpb24gZGV0ZWN0VW5pZm9ybXMoKTogeyBbbmFtZTogc3RyaW5nXTogV2ViR0xVbmlmb3JtTG9jYXRpb24gfSB7XHJcbiAgICAgICAgbGV0IGRldGVjdGVkVW5pZm9ybXM6IHsgW25hbWU6IHN0cmluZ106IFdlYkdMVW5pZm9ybUxvY2F0aW9uIH0gPSB7fTtcclxuICAgICAgICBsZXQgdW5pZm9ybUNvdW50OiBudW1iZXIgPSBjcmMzLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BQ1RJVkVfVU5JRk9STVMpO1xyXG4gICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB1bmlmb3JtQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgbGV0IGluZm86IFdlYkdMQWN0aXZlSW5mbyA9IFJlbmRlck9wZXJhdG9yLmFzc2VydDxXZWJHTEFjdGl2ZUluZm8+KGNyYzMuZ2V0QWN0aXZlVW5pZm9ybShwcm9ncmFtLCBpKSk7XHJcbiAgICAgICAgICBpZiAoIWluZm8pIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBkZXRlY3RlZFVuaWZvcm1zW2luZm8ubmFtZV0gPSBSZW5kZXJPcGVyYXRvci5hc3NlcnQ8V2ViR0xVbmlmb3JtTG9jYXRpb24+KGNyYzMuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIGluZm8ubmFtZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGV0ZWN0ZWRVbmlmb3JtcztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBjbGFzcyBSZW5kZXJJbmplY3RvckNvYXQgZXh0ZW5kcyBSZW5kZXJJbmplY3RvciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIGRlY29yYXRlKF9jb25zdHJ1Y3RvcjogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgUmVuZGVySW5qZWN0b3IuaW5qZWN0KF9jb25zdHJ1Y3RvciwgUmVuZGVySW5qZWN0b3JDb2F0KTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGluamVjdENvYXRDb2xvcmVkKHRoaXM6IENvYXQsIF9zaGFkZXI6IHR5cGVvZiBTaGFkZXIsIF9jbXBNYXRlcmlhbDogQ29tcG9uZW50TWF0ZXJpYWwpOiB2b2lkIHtcclxuICAgICAgbGV0IGNvbG9yVW5pZm9ybUxvY2F0aW9uOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiA9IF9zaGFkZXIudW5pZm9ybXNbXCJ1X2NvbG9yXCJdO1xyXG4gICAgICBsZXQgY29sb3I6IENvbG9yID0gQ29sb3IuTVVMVElQTFkoKDxDb2F0Q29sb3JlZD50aGlzKS5jb2xvciwgX2NtcE1hdGVyaWFsLmNsclByaW1hcnkpO1xyXG4gICAgICBSZW5kZXJPcGVyYXRvci5nZXRSZW5kZXJpbmdDb250ZXh0KCkudW5pZm9ybTRmdihjb2xvclVuaWZvcm1Mb2NhdGlvbiwgY29sb3IuZ2V0QXJyYXkoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBpbmplY3RDb2F0VGV4dHVyZWQodGhpczogQ29hdCwgX3NoYWRlcjogdHlwZW9mIFNoYWRlciwgX2NtcE1hdGVyaWFsOiBDb21wb25lbnRNYXRlcmlhbCk6IHZvaWQge1xyXG4gICAgICBsZXQgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlck9wZXJhdG9yLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcclxuICAgICAgaWYgKHRoaXMucmVuZGVyRGF0YSkge1xyXG4gICAgICAgIC8vIGJ1ZmZlcnMgZXhpc3RcclxuICAgICAgICBsZXQgY29sb3JVbmlmb3JtTG9jYXRpb246IFdlYkdMVW5pZm9ybUxvY2F0aW9uID0gX3NoYWRlci51bmlmb3Jtc1tcInVfY29sb3JcIl07XHJcbiAgICAgICAgbGV0IGNvbG9yOiBDb2xvciA9IENvbG9yLk1VTFRJUExZKCg8Q29hdFRleHR1cmVkPnRoaXMpLmNvbG9yLCBfY21wTWF0ZXJpYWwuY2xyUHJpbWFyeSk7XHJcbiAgICAgICAgUmVuZGVyT3BlcmF0b3IuZ2V0UmVuZGVyaW5nQ29udGV4dCgpLnVuaWZvcm00ZnYoY29sb3JVbmlmb3JtTG9jYXRpb24sIGNvbG9yLmdldEFycmF5KCkpO1xyXG5cclxuICAgICAgICBjcmMzLmFjdGl2ZVRleHR1cmUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFMCk7XHJcbiAgICAgICAgY3JjMy5iaW5kVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIHRoaXMucmVuZGVyRGF0YVtcInRleHR1cmUwXCJdKTtcclxuICAgICAgICBjcmMzLnVuaWZvcm0xaShfc2hhZGVyLnVuaWZvcm1zW1widV90ZXh0dXJlXCJdLCAwKTtcclxuICAgICAgICBjcmMzLnVuaWZvcm1NYXRyaXgzZnYoX3NoYWRlci51bmlmb3Jtc1tcInVfcGl2b3RcIl0sIGZhbHNlLCAoPENvYXRUZXh0dXJlZD50aGlzKS5waXZvdC5nZXQoKSk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJEYXRhID0ge307XHJcbiAgICAgICAgLy8gVE9ETzogY2hlY2sgaWYgYWxsIFdlYkdMLUNyZWF0aW9ucyBhcmUgYXNzZXJ0ZWRcclxuICAgICAgICBjb25zdCB0ZXh0dXJlOiBXZWJHTFRleHR1cmUgPSBSZW5kZXJNYW5hZ2VyLmFzc2VydDxXZWJHTFRleHR1cmU+KGNyYzMuY3JlYXRlVGV4dHVyZSgpKTtcclxuICAgICAgICBjcmMzLmJpbmRUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjcmMzLnRleEltYWdlMkQoY3JjMy5URVhUVVJFXzJELCAwLCBjcmMzLlJHQkEsIGNyYzMuUkdCQSwgY3JjMy5VTlNJR05FRF9CWVRFLCAoPENvYXRUZXh0dXJlZD50aGlzKS50ZXh0dXJlLmltYWdlKTtcclxuICAgICAgICAgIGNyYzMudGV4SW1hZ2UyRChcclxuICAgICAgICAgICAgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCAwLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlJHQkEsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuUkdCQSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTlNJR05FRF9CWVRFLFxyXG4gICAgICAgICAgICAoPENvYXRUZXh0dXJlZD50aGlzKS50ZXh0dXJlLmltYWdlXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xyXG4gICAgICAgICAgRGVidWcuZXJyb3IoX2Vycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3JjMy50ZXhQYXJhbWV0ZXJpKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFX01BR19GSUxURVIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTkVBUkVTVCk7XHJcbiAgICAgICAgY3JjMy50ZXhQYXJhbWV0ZXJpKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFX01JTl9GSUxURVIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTkVBUkVTVCk7XHJcbiAgICAgICAgY3JjMy5nZW5lcmF0ZU1pcG1hcChjcmMzLlRFWFRVUkVfMkQpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyRGF0YVtcInRleHR1cmUwXCJdID0gdGV4dHVyZTtcclxuXHJcbiAgICAgICAgY3JjMy5iaW5kVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIG51bGwpO1xyXG5cclxuICAgICAgICB0aGlzLnVzZVJlbmRlckRhdGEoX3NoYWRlciwgX2NtcE1hdGVyaWFsKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgaW5qZWN0Q29hdE1hdENhcCh0aGlzOiBDb2F0LCBfc2hhZGVyOiB0eXBlb2YgU2hhZGVyLCBfY21wTWF0ZXJpYWw6IENvbXBvbmVudE1hdGVyaWFsKTogdm9pZCB7XHJcbiAgICAgIGxldCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyT3BlcmF0b3IuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG5cclxuICAgICAgbGV0IGNvbG9yVW5pZm9ybUxvY2F0aW9uOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiA9IF9zaGFkZXIudW5pZm9ybXNbXCJ1X3RpbnRfY29sb3JcIl07XHJcbiAgICAgIGxldCB7IHIsIGcsIGIsIGEgfSA9ICg8Q29hdE1hdENhcD50aGlzKS5jb2xvcjtcclxuICAgICAgbGV0IHRpbnRDb2xvckFycmF5OiBGbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KFtyLCBnLCBiLCBhXSk7XHJcbiAgICAgIGNyYzMudW5pZm9ybTRmdihjb2xvclVuaWZvcm1Mb2NhdGlvbiwgdGludENvbG9yQXJyYXkpO1xyXG5cclxuICAgICAgbGV0IGZsb2F0VW5pZm9ybUxvY2F0aW9uOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiA9IF9zaGFkZXIudW5pZm9ybXNbXCJzaGFkZV9zbW9vdGhcIl07XHJcbiAgICAgIGxldCBzaGFkZVNtb290aDogbnVtYmVyID0gKDxDb2F0TWF0Q2FwPnRoaXMpLnNoYWRlU21vb3RoO1xyXG4gICAgICBjcmMzLnVuaWZvcm0xaShmbG9hdFVuaWZvcm1Mb2NhdGlvbiwgc2hhZGVTbW9vdGgpO1xyXG5cclxuICAgICAgaWYgKHRoaXMucmVuZGVyRGF0YSkge1xyXG4gICAgICAgIC8vIGJ1ZmZlcnMgZXhpc3RcclxuICAgICAgICBjcmMzLmFjdGl2ZVRleHR1cmUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFMCk7XHJcbiAgICAgICAgY3JjMy5iaW5kVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIHRoaXMucmVuZGVyRGF0YVtcInRleHR1cmUwXCJdKTtcclxuICAgICAgICBjcmMzLnVuaWZvcm0xaShfc2hhZGVyLnVuaWZvcm1zW1widV90ZXh0dXJlXCJdLCAwKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICB0aGlzLnJlbmRlckRhdGEgPSB7fTtcclxuICAgICAgICAvLyBUT0RPOiBjaGVjayBpZiBhbGwgV2ViR0wtQ3JlYXRpb25zIGFyZSBhc3NlcnRlZFxyXG4gICAgICAgIGNvbnN0IHRleHR1cmU6IFdlYkdMVGV4dHVyZSA9IFJlbmRlck1hbmFnZXIuYXNzZXJ0PFdlYkdMVGV4dHVyZT4oY3JjMy5jcmVhdGVUZXh0dXJlKCkpO1xyXG4gICAgICAgIGNyYzMuYmluZFRleHR1cmUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNyYzMudGV4SW1hZ2UyRChjcmMzLlRFWFRVUkVfMkQsIDAsIGNyYzMuUkdCQSwgY3JjMy5SR0JBLCBjcmMzLlVOU0lHTkVEX0JZVEUsICg8Q29hdE1hdENhcD50aGlzKS50ZXh0dXJlLmltYWdlKTtcclxuICAgICAgICAgIGNyYzMudGV4SW1hZ2UyRChcclxuICAgICAgICAgICAgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCAwLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlJHQkEsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuUkdCQSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTlNJR05FRF9CWVRFLFxyXG4gICAgICAgICAgICAoPENvYXRNYXRDYXA+dGhpcykudGV4dHVyZS5pbWFnZVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcclxuICAgICAgICAgIERlYnVnLmVycm9yKF9lcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNyYzMudGV4UGFyYW1ldGVyaShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV9NQUdfRklMVEVSLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk5FQVJFU1QpO1xyXG4gICAgICAgIGNyYzMudGV4UGFyYW1ldGVyaShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV9NSU5fRklMVEVSLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk5FQVJFU1QpO1xyXG4gICAgICAgIGNyYzMuZ2VuZXJhdGVNaXBtYXAoY3JjMy5URVhUVVJFXzJEKTtcclxuICAgICAgICB0aGlzLnJlbmRlckRhdGFbXCJ0ZXh0dXJlMFwiXSA9IHRleHR1cmU7XHJcblxyXG4gICAgICAgIGNyYzMuYmluZFRleHR1cmUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBudWxsKTtcclxuICAgICAgICB0aGlzLnVzZVJlbmRlckRhdGEoX3NoYWRlciwgX2NtcE1hdGVyaWFsKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgUmVuZGVyQnVmZmVycyB7XHJcbiAgICB2ZXJ0aWNlczogV2ViR0xCdWZmZXI7XHJcbiAgICBpbmRpY2VzOiBXZWJHTEJ1ZmZlcjtcclxuICAgIG5JbmRpY2VzOiBudW1iZXI7XHJcbiAgICB0ZXh0dXJlVVZzOiBXZWJHTEJ1ZmZlcjtcclxuICAgIG5vcm1hbHNGYWNlOiBXZWJHTEJ1ZmZlcjtcclxuICB9XHJcblxyXG4gIGV4cG9ydCBjbGFzcyBSZW5kZXJJbmplY3Rvck1lc2gge1xyXG4gICAgcHVibGljIHN0YXRpYyBkZWNvcmF0ZShfY29uc3RydWN0b3I6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfY29uc3RydWN0b3IucHJvdG90eXBlLCBcInVzZVJlbmRlckJ1ZmZlcnNcIiwge1xyXG4gICAgICAgIHZhbHVlOiBSZW5kZXJJbmplY3Rvck1lc2gudXNlUmVuZGVyQnVmZmVyc1xyXG4gICAgICB9KTtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIFwiY3JlYXRlUmVuZGVyQnVmZmVyc1wiLCB7XHJcbiAgICAgICAgdmFsdWU6IFJlbmRlckluamVjdG9yTWVzaC5jcmVhdGVSZW5kZXJCdWZmZXJzXHJcbiAgICAgIH0pO1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2NvbnN0cnVjdG9yLnByb3RvdHlwZSwgXCJkZWxldGVSZW5kZXJCdWZmZXJzXCIsIHtcclxuICAgICAgICB2YWx1ZTogUmVuZGVySW5qZWN0b3JNZXNoLmRlbGV0ZVJlbmRlckJ1ZmZlcnNcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBjcmVhdGVSZW5kZXJCdWZmZXJzKHRoaXM6IE1lc2gpOiB2b2lkIHtcclxuICAgICAgLy8gY29uc29sZS5sb2coXCJjcmVhdGVSZW5kZXJCdWZmZXJzXCIsIHRoaXMpO1xyXG4gICAgICAvLyByZXR1cm47XHJcblxyXG4gICAgICBsZXQgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlck9wZXJhdG9yLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcclxuICAgICAgbGV0IHZlcnRpY2VzOiBXZWJHTEJ1ZmZlciA9IFJlbmRlck9wZXJhdG9yLmFzc2VydDxXZWJHTEJ1ZmZlcj4oY3JjMy5jcmVhdGVCdWZmZXIoKSk7XHJcbiAgICAgIGNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgdmVydGljZXMpO1xyXG4gICAgICBjcmMzLmJ1ZmZlckRhdGEoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BUlJBWV9CVUZGRVIsIHRoaXMudmVydGljZXMsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuU1RBVElDX0RSQVcpO1xyXG5cclxuICAgICAgbGV0IGluZGljZXM6IFdlYkdMQnVmZmVyID0gUmVuZGVyT3BlcmF0b3IuYXNzZXJ0PFdlYkdMQnVmZmVyPihjcmMzLmNyZWF0ZUJ1ZmZlcigpKTtcclxuICAgICAgY3JjMy5iaW5kQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGluZGljZXMpO1xyXG4gICAgICBjcmMzLmJ1ZmZlckRhdGEoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5pbmRpY2VzLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlNUQVRJQ19EUkFXKTtcclxuXHJcbiAgICAgIGxldCB0ZXh0dXJlVVZzOiBXZWJHTEJ1ZmZlciA9IGNyYzMuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICAgIGNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgdGV4dHVyZVVWcyk7XHJcbiAgICAgIGNyYzMuYnVmZmVyRGF0YShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgdGhpcy50ZXh0dXJlVVZzLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlNUQVRJQ19EUkFXKTtcclxuXHJcbiAgICAgIGxldCBub3JtYWxzRmFjZTogV2ViR0xCdWZmZXIgPSBSZW5kZXJPcGVyYXRvci5hc3NlcnQ8V2ViR0xCdWZmZXI+KGNyYzMuY3JlYXRlQnVmZmVyKCkpO1xyXG4gICAgICBjcmMzLmJpbmRCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BUlJBWV9CVUZGRVIsIG5vcm1hbHNGYWNlKTtcclxuICAgICAgY3JjMy5idWZmZXJEYXRhKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQVJSQVlfQlVGRkVSLCB0aGlzLm5vcm1hbHNGYWNlLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlNUQVRJQ19EUkFXKTtcclxuXHJcbiAgICAgIGxldCByZW5kZXJCdWZmZXJzOiBSZW5kZXJCdWZmZXJzID0ge1xyXG4gICAgICAgIHZlcnRpY2VzOiB2ZXJ0aWNlcyxcclxuICAgICAgICBpbmRpY2VzOiBpbmRpY2VzLFxyXG4gICAgICAgIG5JbmRpY2VzOiB0aGlzLmdldEluZGV4Q291bnQoKSxcclxuICAgICAgICB0ZXh0dXJlVVZzOiB0ZXh0dXJlVVZzLFxyXG4gICAgICAgIG5vcm1hbHNGYWNlOiBub3JtYWxzRmFjZVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgdGhpcy5yZW5kZXJCdWZmZXJzID0gcmVuZGVyQnVmZmVycztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHVzZVJlbmRlckJ1ZmZlcnModGhpczogTWVzaCwgX3NoYWRlcjogdHlwZW9mIFNoYWRlciwgX3dvcmxkOiBNYXRyaXg0eDQsIF9wcm9qZWN0aW9uOiBNYXRyaXg0eDQsIF9pZD86IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAvLyBjb25zb2xlLmxvZyhcInVzZVJlbmRlckJ1ZmZlcnNcIiwgdGhpcyk7XHJcbiAgICAgIC8vIHJldHVybjtcclxuICAgICAgbGV0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJPcGVyYXRvci5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcblxyXG4gICAgICBsZXQgYVBvc2l0aW9uOiBudW1iZXIgPSBfc2hhZGVyLmF0dHJpYnV0ZXNbXCJhX3Bvc2l0aW9uXCJdO1xyXG4gICAgICBjcmMzLmJpbmRCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BUlJBWV9CVUZGRVIsIHRoaXMucmVuZGVyQnVmZmVycy52ZXJ0aWNlcyk7XHJcbiAgICAgIGNyYzMuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYVBvc2l0aW9uKTtcclxuICAgICAgUmVuZGVyT3BlcmF0b3Iuc2V0QXR0cmlidXRlU3RydWN0dXJlKGFQb3NpdGlvbiwgTWVzaC5nZXRCdWZmZXJTcGVjaWZpY2F0aW9uKCkpO1xyXG5cclxuICAgICAgY3JjMy5iaW5kQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMucmVuZGVyQnVmZmVycy5pbmRpY2VzKTtcclxuXHJcbiAgICAgIGxldCB1UHJvamVjdGlvbjogV2ViR0xVbmlmb3JtTG9jYXRpb24gPSBfc2hhZGVyLnVuaWZvcm1zW1widV9wcm9qZWN0aW9uXCJdO1xyXG4gICAgICBjcmMzLnVuaWZvcm1NYXRyaXg0ZnYodVByb2plY3Rpb24sIGZhbHNlLCBfcHJvamVjdGlvbi5nZXQoKSk7XHJcblxyXG4gICAgICAvLyBmZWVkIGluIGZhY2Ugbm9ybWFscyBpZiBzaGFkZXIgYWNjZXB0cyB1X3dvcmxkLiBcclxuICAgICAgbGV0IHVXb3JsZDogV2ViR0xVbmlmb3JtTG9jYXRpb24gPSBfc2hhZGVyLnVuaWZvcm1zW1widV93b3JsZFwiXTtcclxuICAgICAgaWYgKHVXb3JsZCkge1xyXG4gICAgICAgIGNyYzMudW5pZm9ybU1hdHJpeDRmdih1V29ybGQsIGZhbHNlLCBfd29ybGQuZ2V0KCkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgYU5vcm1hbDogbnVtYmVyID0gX3NoYWRlci5hdHRyaWJ1dGVzW1wiYV9ub3JtYWxcIl07XHJcbiAgICAgIGlmIChhTm9ybWFsKSB7XHJcbiAgICAgICAgY3JjMy5iaW5kQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQVJSQVlfQlVGRkVSLCB0aGlzLnJlbmRlckJ1ZmZlcnMubm9ybWFsc0ZhY2UpO1xyXG4gICAgICAgIGNyYzMuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYU5vcm1hbCk7XHJcbiAgICAgICAgUmVuZGVyT3BlcmF0b3Iuc2V0QXR0cmlidXRlU3RydWN0dXJlKGFOb3JtYWwsIE1lc2guZ2V0QnVmZmVyU3BlY2lmaWNhdGlvbigpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gZmVlZCBpbiB0ZXh0dXJlIGNvb3JkaW5hdGVzIGlmIHNoYWRlciBhY2NlcHRzIGFfdGV4dHVyZVVWc1xyXG4gICAgICBsZXQgYVRleHR1cmVVVnM6IG51bWJlciA9IF9zaGFkZXIuYXR0cmlidXRlc1tcImFfdGV4dHVyZVVWc1wiXTtcclxuICAgICAgaWYgKGFUZXh0dXJlVVZzKSB7XHJcbiAgICAgICAgY3JjMy5iaW5kQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQVJSQVlfQlVGRkVSLCB0aGlzLnJlbmRlckJ1ZmZlcnMudGV4dHVyZVVWcyk7XHJcbiAgICAgICAgY3JjMy5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhVGV4dHVyZVVWcyk7IC8vIGVuYWJsZSB0aGUgYnVmZmVyXHJcbiAgICAgICAgY3JjMy52ZXJ0ZXhBdHRyaWJQb2ludGVyKGFUZXh0dXJlVVZzLCAyLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZMT0FULCBmYWxzZSwgMCwgMCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGZlZWQgaW4gYW4gaWQgb2YgdGhlIG5vZGUgaWYgc2hhZGVyIGFjY2VwdHMgdV9pZC4gVXNlZCBmb3IgcGlja2luZ1xyXG4gICAgICBsZXQgdUlkOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiA9IF9zaGFkZXIudW5pZm9ybXNbXCJ1X2lkXCJdO1xyXG4gICAgICBpZiAodUlkKVxyXG4gICAgICAgIFJlbmRlck9wZXJhdG9yLmdldFJlbmRlcmluZ0NvbnRleHQoKS51bmlmb3JtMWkodUlkLCBfaWQpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgZGVsZXRlUmVuZGVyQnVmZmVycyhfcmVuZGVyQnVmZmVyczogUmVuZGVyQnVmZmVycyk6IHZvaWQge1xyXG4gICAgICAvLyBjb25zb2xlLmxvZyhcImRlbGV0ZVJlbmRlckJ1ZmZlcnNcIiwgdGhpcyk7XHJcbiAgICAgIC8vIHJldHVybjtcclxuICAgICAgbGV0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJPcGVyYXRvci5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcbiAgICAgIGlmIChfcmVuZGVyQnVmZmVycykge1xyXG4gICAgICAgIGNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgbnVsbCk7XHJcbiAgICAgICAgY3JjMy5kZWxldGVCdWZmZXIoX3JlbmRlckJ1ZmZlcnMudmVydGljZXMpO1xyXG4gICAgICAgIGNyYzMuZGVsZXRlQnVmZmVyKF9yZW5kZXJCdWZmZXJzLnRleHR1cmVVVnMpO1xyXG4gICAgICAgIGNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBudWxsKTtcclxuICAgICAgICBjcmMzLmRlbGV0ZUJ1ZmZlcihfcmVuZGVyQnVmZmVycy5pbmRpY2VzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEtlZXBzIGEgZGVwb3Qgb2Ygb2JqZWN0cyB0aGF0IGhhdmUgYmVlbiBtYXJrZWQgZm9yIHJldXNlLCBzb3J0ZWQgYnkgdHlwZS4gIFxyXG4gICAqIFVzaW5nIFtbUmVjeWNsZXJdXSByZWR1Y2VzIGxvYWQgb24gdGhlIGNhcmJhZ2UgY29sbGVjdG9yIGFuZCB0aHVzIHN1cHBvcnRzIHNtb290aCBwZXJmb3JtYW5jZVxyXG4gICAqL1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBSZWN5Y2xlciB7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBkZXBvdDogeyBbdHlwZTogc3RyaW5nXTogT2JqZWN0W10gfSA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmV0Y2hlcyBhbiBvYmplY3Qgb2YgdGhlIHJlcXVlc3RlZCB0eXBlIGZyb20gdGhlIGRlcG90LCBvciByZXR1cm5zIGEgbmV3IG9uZSwgaWYgdGhlIGRlcG90IHdhcyBlbXB0eSBcclxuICAgICAqIEBwYXJhbSBfVCBUaGUgY2xhc3MgaWRlbnRpZmllciBvZiB0aGUgZGVzaXJlZCBvYmplY3RcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXQ8VD4oX1Q6IG5ldyAoKSA9PiBUKTogVCB7XHJcbiAgICAgIGxldCBrZXk6IHN0cmluZyA9IF9ULm5hbWU7XHJcbiAgICAgIGxldCBpbnN0YW5jZXM6IE9iamVjdFtdID0gUmVjeWNsZXIuZGVwb3Rba2V5XTtcclxuICAgICAgaWYgKGluc3RhbmNlcyAmJiBpbnN0YW5jZXMubGVuZ3RoID4gMClcclxuICAgICAgICByZXR1cm4gPFQ+aW5zdGFuY2VzLnBvcCgpO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIG5ldyBfVCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byBhbiBvYmplY3Qgb2YgdGhlIHJlcXVlc3RlZCB0eXBlIGluIHRoZSBkZXBvdCwgYnV0IGRvZXMgbm90IHJlbW92ZSBpdCB0aGVyZS4gXHJcbiAgICAgKiBJZiBubyBvYmplY3Qgb2YgdGhlIHJlcXVlc3RlZCB0eXBlIHdhcyBpbiB0aGUgZGVwb3QsIG9uZSBpcyBjcmVhdGVkLCBzdG9yZWQgYW5kIGJvcnJvd2VkLlxyXG4gICAgICogRm9yIHNob3J0IHRlcm0gdXNhZ2Ugb2Ygb2JqZWN0cyBpbiBhIGxvY2FsIHNjb3BlLCB3aGVuIHRoZXJlIHdpbGwgYmUgbm8gb3RoZXIgY2FsbCB0byBSZWN5Y2xlci5nZXQgb3IgLmJvcnJvdyFcclxuICAgICAqIEBwYXJhbSBfVCBUaGUgY2xhc3MgaWRlbnRpZmllciBvZiB0aGUgZGVzaXJlZCBvYmplY3RcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBib3Jyb3c8VD4oX1Q6IG5ldyAoKSA9PiBUKTogVCB7XHJcbiAgICAgIGxldCB0OiBUO1xyXG4gICAgICBsZXQga2V5OiBzdHJpbmcgPSBfVC5uYW1lO1xyXG4gICAgICBsZXQgaW5zdGFuY2VzOiBPYmplY3RbXSA9IFJlY3ljbGVyLmRlcG90W2tleV07XHJcbiAgICAgIGlmICghaW5zdGFuY2VzIHx8IGluc3RhbmNlcy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgIHQgPSBuZXcgX1QoKTtcclxuICAgICAgICBSZWN5Y2xlci5zdG9yZSh0KTtcclxuICAgICAgICByZXR1cm4gdDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gPFQ+aW5zdGFuY2VzWzBdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RvcmVzIHRoZSBvYmplY3QgaW4gdGhlIGRlcG90IGZvciBsYXRlciByZWN5Y2xpbmcuIFVzZXJzIGFyZSByZXNwb25zaWJsZSBmb3IgdGhyb3dpbmcgaW4gb2JqZWN0cyB0aGF0IGFyZSBhYm91dCB0byBsb29zZSBzY29wZSBhbmQgYXJlIG5vdCByZWZlcmVuY2VkIGJ5IGFueSBvdGhlclxyXG4gICAgICogQHBhcmFtIF9pbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHN0b3JlKF9pbnN0YW5jZTogT2JqZWN0KTogdm9pZCB7XHJcbiAgICAgIGxldCBrZXk6IHN0cmluZyA9IF9pbnN0YW5jZS5jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gICAgICAvL0RlYnVnLmxvZyhrZXkpO1xyXG4gICAgICBsZXQgaW5zdGFuY2VzOiBPYmplY3RbXSA9IFJlY3ljbGVyLmRlcG90W2tleV0gfHwgW107XHJcbiAgICAgIGluc3RhbmNlcy5wdXNoKF9pbnN0YW5jZSk7XHJcbiAgICAgIFJlY3ljbGVyLmRlcG90W2tleV0gPSBpbnN0YW5jZXM7XHJcbiAgICAgIC8vIERlYnVnLmxvZyhgT2JqZWN0TWFuYWdlci5kZXBvdFske2tleX1dOiAke09iamVjdE1hbmFnZXIuZGVwb3Rba2V5XS5sZW5ndGh9YCk7XHJcbiAgICAgIC8vRGVidWcubG9nKHRoaXMuZGVwb3QpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRW1wdHlzIHRoZSBkZXBvdCBvZiBhIGdpdmVuIHR5cGUsIGxlYXZpbmcgdGhlIG9iamVjdHMgZm9yIHRoZSBnYXJiYWdlIGNvbGxlY3Rvci4gTWF5IHJlc3VsdCBpbiBhIHNob3J0IHN0YWxsIHdoZW4gbWFueSBvYmplY3RzIHdlcmUgaW5cclxuICAgICAqIEBwYXJhbSBfVFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGR1bXA8VD4oX1Q6IG5ldyAoKSA9PiBUKTogdm9pZCB7XHJcbiAgICAgIGxldCBrZXk6IHN0cmluZyA9IF9ULm5hbWU7XHJcbiAgICAgIFJlY3ljbGVyLmRlcG90W2tleV0gPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEVtcHR5cyBhbGwgZGVwb3RzLCBsZWF2aW5nIGFsbCBvYmplY3RzIHRvIHRoZSBnYXJiYWdlIGNvbGxlY3Rvci4gTWF5IHJlc3VsdCBpbiBhIHNob3J0IHN0YWxsIHdoZW4gbWFueSBvYmplY3RzIHdlcmUgaW5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBkdW1wQWxsKCk6IHZvaWQge1xyXG4gICAgICBSZWN5Y2xlci5kZXBvdCA9IHt9O1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFN0b3JlcyBhbmQgbWFuaXB1bGF0ZXMgYSB0d29kaW1lbnNpb25hbCB2ZWN0b3IgY29tcHJpc2VkIG9mIHRoZSBjb21wb25lbnRzIHggYW5kIHlcclxuICAgKiBgYGBwbGFpbnRleHRcclxuICAgKiAgICAgICAgICAgICt5XHJcbiAgICogICAgICAgICAgICAgfF9fICt4XHJcbiAgICogYGBgXHJcbiAgICogQGF1dGhvcnMgTHVrYXMgU2NoZXVlcmxlLCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBWZWN0b3IyIGV4dGVuZHMgTXV0YWJsZSB7XHJcbiAgICBwcml2YXRlIGRhdGE6IEZsb2F0MzJBcnJheTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3g6IG51bWJlciA9IDAsIF95OiBudW1iZXIgPSAwKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoW194LCBfeV0pO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCB4KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmRhdGFbMF07XHJcbiAgICB9XHJcbiAgICBnZXQgeSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5kYXRhWzFdO1xyXG4gICAgfVxyXG5cclxuICAgIHNldCB4KF94OiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5kYXRhWzBdID0gX3g7XHJcbiAgICB9XHJcbiAgICBzZXQgeShfeTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuZGF0YVsxXSA9IF95O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgZ2V0IG1hZ25pdHVkZSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gTWF0aC5oeXBvdCguLi50aGlzLmRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc3F1YXJlIG9mIHRoZSBtYWduaXR1ZGUgb2YgdGhlIHZlY3RvciB3aXRob3V0IGNhbGN1bGF0aW5nIGEgc3F1YXJlIHJvb3QuIEZhc3RlciBmb3Igc2ltcGxlIHByb3hpbWl0eSBldmFsdWF0aW9uLlxyXG4gICAgICovXHJcbiAgICBnZXQgbWFnbml0dWRlU3F1YXJlZCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gVmVjdG9yMi5ET1QodGhpcywgdGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQSBzaG9ydGhhbmQgZm9yIHdyaXRpbmcgYG5ldyBWZWN0b3IyKDAsIDApYC5cclxuICAgICAqIEByZXR1cm5zIEEgbmV3IHZlY3RvciB3aXRoIHRoZSB2YWx1ZXMgKDAsIDApXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgWkVSTygpOiBWZWN0b3IyIHtcclxuICAgICAgbGV0IHZlY3RvcjogVmVjdG9yMiA9IG5ldyBWZWN0b3IyKCk7XHJcbiAgICAgIHJldHVybiB2ZWN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQSBzaG9ydGhhbmQgZm9yIHdyaXRpbmcgYG5ldyBWZWN0b3IyKF9zY2FsZSwgX3NjYWxlKWAuXHJcbiAgICAgKiBAcGFyYW0gX3NjYWxlIHRoZSBzY2FsZSBvZiB0aGUgdmVjdG9yLiBEZWZhdWx0OiAxXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgT05FKF9zY2FsZTogbnVtYmVyID0gMSk6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgdmVjdG9yOiBWZWN0b3IyID0gbmV3IFZlY3RvcjIoX3NjYWxlLCBfc2NhbGUpO1xyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEEgc2hvcnRoYW5kIGZvciB3cml0aW5nIGBuZXcgVmVjdG9yMigwLCB5KWAuXHJcbiAgICAgKiBAcGFyYW0gX3NjYWxlIFRoZSBudW1iZXIgdG8gd3JpdGUgaW4gdGhlIHkgY29vcmRpbmF0ZS4gRGVmYXVsdDogMVxyXG4gICAgICogQHJldHVybnMgQSBuZXcgdmVjdG9yIHdpdGggdGhlIHZhbHVlcyAoMCwgX3NjYWxlKVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFkoX3NjYWxlOiBudW1iZXIgPSAxKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCB2ZWN0b3I6IFZlY3RvcjIgPSBuZXcgVmVjdG9yMigwLCBfc2NhbGUpO1xyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEEgc2hvcnRoYW5kIGZvciB3cml0aW5nIGBuZXcgVmVjdG9yMih4LCAwKWAuXHJcbiAgICAgKiBAcGFyYW0gX3NjYWxlIFRoZSBudW1iZXIgdG8gd3JpdGUgaW4gdGhlIHggY29vcmRpbmF0ZS4gRGVmYXVsdDogMVxyXG4gICAgICogQHJldHVybnMgQSBuZXcgdmVjdG9yIHdpdGggdGhlIHZhbHVlcyAoX3NjYWxlLCAwKVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFgoX3NjYWxlOiBudW1iZXIgPSAxKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCB2ZWN0b3I6IFZlY3RvcjIgPSBuZXcgVmVjdG9yMihfc2NhbGUsIDApO1xyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgVFJBTlNGT1JNQVRJT04oX3ZlY3RvcjogVmVjdG9yMiwgX21hdHJpeDogTWF0cml4M3gzLCBfaW5jbHVkZVRyYW5zbGF0aW9uOiBib29sZWFuID0gdHJ1ZSk6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IyID0gbmV3IFZlY3RvcjIoKTtcclxuICAgICAgbGV0IG06IEZsb2F0MzJBcnJheSA9IF9tYXRyaXguZ2V0KCk7XHJcbiAgICAgIGxldCBbeCwgeV0gPSBfdmVjdG9yLmdldCgpO1xyXG4gICAgICByZXN1bHQueCA9IG1bMF0gKiB4ICsgbVszXSAqIHk7XHJcbiAgICAgIHJlc3VsdC55ID0gbVsxXSAqIHggKyBtWzRdICogeTtcclxuXHJcbiAgICAgIGlmIChfaW5jbHVkZVRyYW5zbGF0aW9uKSB7XHJcbiAgICAgICAgcmVzdWx0LmFkZChfbWF0cml4LnRyYW5zbGF0aW9uKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE5vcm1hbGl6ZXMgYSBnaXZlbiB2ZWN0b3IgdG8gdGhlIGdpdmVuIGxlbmd0aCB3aXRob3V0IGVkaXRpbmcgdGhlIG9yaWdpbmFsIHZlY3Rvci5cclxuICAgICAqIEBwYXJhbSBfdmVjdG9yIHRoZSB2ZWN0b3IgdG8gbm9ybWFsaXplXHJcbiAgICAgKiBAcGFyYW0gX2xlbmd0aCB0aGUgbGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBkZWZhdWx0cyB0byAxXHJcbiAgICAgKiBAcmV0dXJucyBhIG5ldyB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBub3JtYWxpc2VkIHZlY3RvciBzY2FsZWQgYnkgdGhlIGdpdmVuIGxlbmd0aFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIE5PUk1BTElaQVRJT04oX3ZlY3RvcjogVmVjdG9yMiwgX2xlbmd0aDogbnVtYmVyID0gMSk6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgdmVjdG9yOiBWZWN0b3IyID0gVmVjdG9yMi5aRVJPKCk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgbGV0IFt4LCB5XSA9IF92ZWN0b3IuZGF0YTtcclxuICAgICAgICBsZXQgZmFjdG9yOiBudW1iZXIgPSBfbGVuZ3RoIC8gTWF0aC5oeXBvdCh4LCB5KTtcclxuICAgICAgICB2ZWN0b3IuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoW192ZWN0b3IueCAqIGZhY3RvciwgX3ZlY3Rvci55ICogZmFjdG9yXSk7XHJcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xyXG4gICAgICAgIERlYnVnLmZ1ZGdlKF9lcnJvcik7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNjYWxlcyBhIGdpdmVuIHZlY3RvciBieSBhIGdpdmVuIHNjYWxlIHdpdGhvdXQgY2hhbmdpbmcgdGhlIG9yaWdpbmFsIHZlY3RvclxyXG4gICAgICogQHBhcmFtIF92ZWN0b3IgVGhlIHZlY3RvciB0byBzY2FsZS5cclxuICAgICAqIEBwYXJhbSBfc2NhbGUgVGhlIHNjYWxlIHRvIHNjYWxlIHdpdGguXHJcbiAgICAgKiBAcmV0dXJucyBBIG5ldyB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBzY2FsZWQgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgU0NBTEUoX3ZlY3RvcjogVmVjdG9yMiwgX3NjYWxlOiBudW1iZXIpOiBWZWN0b3IyIHtcclxuICAgICAgbGV0IHZlY3RvcjogVmVjdG9yMiA9IG5ldyBWZWN0b3IyKF92ZWN0b3IueCAqIF9zY2FsZSwgX3ZlY3Rvci55ICogX3NjYWxlKTtcclxuICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN1bXMgdXAgbXVsdGlwbGUgdmVjdG9ycy5cclxuICAgICAqIEBwYXJhbSBfdmVjdG9ycyBBIHNlcmllcyBvZiB2ZWN0b3JzIHRvIHN1bSB1cFxyXG4gICAgICogQHJldHVybnMgQSBuZXcgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgc3VtIG9mIHRoZSBnaXZlbiB2ZWN0b3JzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgU1VNKC4uLl92ZWN0b3JzOiBWZWN0b3IyW10pOiBWZWN0b3IyIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMiA9IG5ldyBWZWN0b3IyKCk7XHJcbiAgICAgIGZvciAobGV0IHZlY3RvciBvZiBfdmVjdG9ycylcclxuICAgICAgICByZXN1bHQuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoW3Jlc3VsdC54ICsgdmVjdG9yLngsIHJlc3VsdC55ICsgdmVjdG9yLnldKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN1YnRyYWN0cyB0d28gdmVjdG9ycy5cclxuICAgICAqIEBwYXJhbSBfYSBUaGUgdmVjdG9yIHRvIHN1YnRyYWN0IGZyb20uXHJcbiAgICAgKiBAcGFyYW0gX2IgVGhlIHZlY3RvciB0byBzdWJ0cmFjdC5cclxuICAgICAqIEByZXR1cm5zIEEgbmV3IHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGRpZmZlcmVuY2Ugb2YgdGhlIGdpdmVuIHZlY3RvcnNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBESUZGRVJFTkNFKF9hOiBWZWN0b3IyLCBfYjogVmVjdG9yMik6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgdmVjdG9yOiBWZWN0b3IyID0gbmV3IFZlY3RvcjI7XHJcbiAgICAgIHZlY3Rvci5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShbX2EueCAtIF9iLngsIF9hLnkgLSBfYi55XSk7XHJcbiAgICAgIHJldHVybiB2ZWN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyB0aGUgZG90cHJvZHVjdCBvZiAyIHZlY3RvcnMuXHJcbiAgICAgKiBAcGFyYW0gX2EgVGhlIHZlY3RvciB0byBtdWx0aXBseS5cclxuICAgICAqIEBwYXJhbSBfYiBUaGUgdmVjdG9yIHRvIG11bHRpcGx5IGJ5LlxyXG4gICAgICogQHJldHVybnMgQSBuZXcgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgZG90cHJvZHVjdCBvZiB0aGUgZ2l2ZW4gdmVjdG9yc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIERPVChfYTogVmVjdG9yMiwgX2I6IFZlY3RvcjIpOiBudW1iZXIge1xyXG4gICAgICBsZXQgc2NhbGFyUHJvZHVjdDogbnVtYmVyID0gX2EueCAqIF9iLnggKyBfYS55ICogX2IueTtcclxuICAgICAgcmV0dXJuIHNjYWxhclByb2R1Y3Q7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byBWZWN0b3JzLiBEdWUgdG8gdGhlbSBiZWluZyBvbmx5IDIgRGltZW5zaW9uYWwsIHRoZSByZXN1bHQgaXMgYSBzaW5nbGUgbnVtYmVyLFxyXG4gICAgICogd2hpY2ggaW1wbGljaXRseSBpcyBvbiB0aGUgWiBheGlzLiBJdCBpcyBhbHNvIHRoZSBzaWduZWQgbWFnbml0dWRlIG9mIHRoZSByZXN1bHQuXHJcbiAgICAgKiBAcGFyYW0gX2EgVmVjdG9yIHRvIGNvbXB1dGUgdGhlIGNyb3NzIHByb2R1Y3Qgb25cclxuICAgICAqIEBwYXJhbSBfYiBWZWN0b3IgdG8gY29tcHV0ZSB0aGUgY3Jvc3MgcHJvZHVjdCB3aXRoXHJcbiAgICAgKiBAcmV0dXJucyBBIG51bWJlciByZXByZXNlbnRpbmcgcmVzdWx0IG9mIHRoZSBjcm9zcyBwcm9kdWN0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIENST1NTUFJPRFVDVChfYTogVmVjdG9yMiwgX2I6IFZlY3RvcjIpOiBudW1iZXIge1xyXG4gICAgICBsZXQgY3Jvc3NQcm9kdWN0OiBudW1iZXIgPSBfYS54ICogX2IueSAtIF9hLnkgKiBfYi54O1xyXG4gICAgICByZXR1cm4gY3Jvc3NQcm9kdWN0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgb3J0aG9nb25hbCB2ZWN0b3IgdG8gdGhlIGdpdmVuIHZlY3Rvci4gUm90YXRlcyBjb3VudGVyY2xvY2t3aXNlIGJ5IGRlZmF1bHQuXHJcbiAgICAgKiBgYGBwbGFpbnRleHRcclxuICAgICAqIOKGkSA9PiDihpAgPT4g4oaTID0+IOKGkiA9PiDihpFcclxuICAgICAqIGBgYFxyXG4gICAgICogQHBhcmFtIF92ZWN0b3IgVmVjdG9yIHRvIGdldCB0aGUgb3J0aG9nb25hbCBlcXVpdmFsZW50IG9mXHJcbiAgICAgKiBAcGFyYW0gX2Nsb2Nrd2lzZSBTaG91bGQgdGhlIHJvdGF0aW9uIGJlIGNsb2Nrd2lzZSBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IGNvdW50ZXJjbG9ja3dpc2U/IGRlZmF1bHQ6IGZhbHNlXHJcbiAgICAgKiBAcmV0dXJucyBBIFZlY3RvciB0aGF0IGlzIG9ydGhvZ29uYWwgdG8gYW5kIGhhcyB0aGUgc2FtZSBtYWduaXR1ZGUgYXMgdGhlIGdpdmVuIFZlY3Rvci4gIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIE9SVEhPR09OQUwoX3ZlY3RvcjogVmVjdG9yMiwgX2Nsb2Nrd2lzZTogYm9vbGVhbiA9IGZhbHNlKTogVmVjdG9yMiB7XHJcbiAgICAgIGlmIChfY2xvY2t3aXNlKSByZXR1cm4gbmV3IFZlY3RvcjIoX3ZlY3Rvci55LCAtX3ZlY3Rvci54KTtcclxuICAgICAgZWxzZSByZXR1cm4gbmV3IFZlY3RvcjIoLV92ZWN0b3IueSwgX3ZlY3Rvci54KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY29vcmRpbmF0ZXMgb2YgdGhpcyBhbmQgdGhlIGdpdmVuIHZlY3RvciBhcmUgdG8gYmUgY29uc2lkZXJlZCBpZGVudGljYWwgd2l0aGluIHRoZSBnaXZlbiB0b2xlcmFuY2VcclxuICAgICAqIFRPRE86IGV4YW1pbmUsIGlmIHRvbGVyYW5jZSBhcyBjcml0ZXJpdW0gZm9yIHRoZSBkaWZmZXJlbmNlIGlzIGFwcHJvcHJpYXRlIHdpdGggdmVyeSBsYXJnZSBjb29yZGluYXRlIHZhbHVlcyBvciBpZiBfdG9sZXJhbmNlIHNob3VsZCBiZSBtdWx0aXBsaWVkIGJ5IGNvb3JkaW5hdGUgdmFsdWVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGVxdWFscyhfY29tcGFyZTogVmVjdG9yMiwgX3RvbGVyYW5jZTogbnVtYmVyID0gTnVtYmVyLkVQU0lMT04pOiBib29sZWFuIHtcclxuICAgICAgaWYgKE1hdGguYWJzKHRoaXMueCAtIF9jb21wYXJlLngpID4gX3RvbGVyYW5jZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAoTWF0aC5hYnModGhpcy55IC0gX2NvbXBhcmUueSkgPiBfdG9sZXJhbmNlKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgZ2l2ZW4gdmVjdG9yIHRvIHRoZSBleGVjdXRpbmcgdmVjdG9yLCBjaGFuZ2luZyB0aGUgZXhlY3V0b3IuXHJcbiAgICAgKiBAcGFyYW0gX2FkZGVuZCBUaGUgdmVjdG9yIHRvIGFkZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFkZChfYWRkZW5kOiBWZWN0b3IyKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuZGF0YSA9IG5ldyBWZWN0b3IyKF9hZGRlbmQueCArIHRoaXMueCwgX2FkZGVuZC55ICsgdGhpcy55KS5kYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3VidHJhY3RzIHRoZSBnaXZlbiB2ZWN0b3IgZnJvbSB0aGUgZXhlY3V0aW5nIHZlY3RvciwgY2hhbmdpbmcgdGhlIGV4ZWN1dG9yLlxyXG4gICAgICogQHBhcmFtIF9zdWJ0cmFoZW5kIFRoZSB2ZWN0b3IgdG8gc3VidHJhY3QuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdWJ0cmFjdChfc3VidHJhaGVuZDogVmVjdG9yMik6IHZvaWQge1xyXG4gICAgICB0aGlzLmRhdGEgPSBuZXcgVmVjdG9yMih0aGlzLnggLSBfc3VidHJhaGVuZC54LCB0aGlzLnkgLSBfc3VidHJhaGVuZC55KS5kYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2NhbGVzIHRoZSBWZWN0b3IgYnkgdGhlIF9zY2FsZS5cclxuICAgICAqIEBwYXJhbSBfc2NhbGUgVGhlIHNjYWxlIHRvIG11bHRpcGx5IHRoZSB2ZWN0b3Igd2l0aC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNjYWxlKF9zY2FsZTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuZGF0YSA9IG5ldyBWZWN0b3IyKF9zY2FsZSAqIHRoaXMueCwgX3NjYWxlICogdGhpcy55KS5kYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTm9ybWFsaXplcyB0aGUgdmVjdG9yLlxyXG4gICAgICogQHBhcmFtIF9sZW5ndGggQSBtb2RpZmljYXRvciB0byBnZXQgYSBkaWZmZXJlbnQgbGVuZ3RoIG9mIG5vcm1hbGl6ZWQgdmVjdG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbm9ybWFsaXplKF9sZW5ndGg6IG51bWJlciA9IDEpOiB2b2lkIHtcclxuICAgICAgdGhpcy5kYXRhID0gVmVjdG9yMi5OT1JNQUxJWkFUSU9OKHRoaXMsIF9sZW5ndGgpLmRhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBWZWN0b3IgdG8gdGhlIGdpdmVuIHBhcmFtZXRlcnMuIE9tbWl0dGVkIHBhcmFtZXRlcnMgZGVmYXVsdCB0byAwLlxyXG4gICAgICogQHBhcmFtIF94IG5ldyB4IHRvIHNldFxyXG4gICAgICogQHBhcmFtIF95IG5ldyB5IHRvIHNldFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0KF94OiBudW1iZXIgPSAwLCBfeTogbnVtYmVyID0gMCk6IHZvaWQge1xyXG4gICAgICB0aGlzLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KFtfeCwgX3ldKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHRoZSBkYXRhIG9mIHRoZSB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCgpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgQSBkZWVwIGNvcHkgb2YgdGhlIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBjb3B5KCk6IFZlY3RvcjIge1xyXG4gICAgICByZXR1cm4gbmV3IFZlY3RvcjIodGhpcy54LCB0aGlzLnkpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB0cmFuc2Zvcm0oX21hdHJpeDogTWF0cml4M3gzLCBfaW5jbHVkZVRyYW5zbGF0aW9uOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xyXG4gICAgICB0aGlzLmRhdGEgPSBWZWN0b3IyLlRSQU5TRk9STUFUSU9OKHRoaXMsIF9tYXRyaXgsIF9pbmNsdWRlVHJhbnNsYXRpb24pLmRhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgei1jb21wb25lbnQgdG8gdGhlIHZlY3RvciBhbmQgcmV0dXJucyBhIG5ldyBWZWN0b3IzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b1ZlY3RvcjMoKTogVmVjdG9yMyB7XHJcbiAgICAgIHJldHVybiBuZXcgVmVjdG9yMyh0aGlzLngsIHRoaXMueSwgMCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgIGxldCByZXN1bHQ6IHN0cmluZyA9IGAoJHt0aGlzLngudG9QcmVjaXNpb24oNSl9LCAke3RoaXMueS50b1ByZWNpc2lvbig1KX0pYDtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSB7XHJcbiAgICAgICAgeDogdGhpcy5kYXRhWzBdLCB5OiB0aGlzLmRhdGFbMV1cclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQgey8qKiAqLyB9XHJcbiAgfVxyXG59IiwiLy8vPHJlZmVyZW5jZSBwYXRoPVwiLi4vRW5naW5lL1JlY3ljbGVyLnRzXCIvPlxyXG4vLy88cmVmZXJlbmNlIHBhdGg9XCJWZWN0b3IyLnRzXCIvPlxyXG5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogRGVmaW5lcyB0aGUgb3JpZ2luIG9mIGEgcmVjdGFuZ2xlXHJcbiAgICovXHJcbiAgZXhwb3J0IGVudW0gT1JJR0lOMkQge1xyXG4gICAgVE9QTEVGVCA9IDB4MDAsXHJcbiAgICBUT1BDRU5URVIgPSAweDAxLFxyXG4gICAgVE9QUklHSFQgPSAweDAyLFxyXG4gICAgQ0VOVEVSTEVGVCA9IDB4MTAsXHJcbiAgICBDRU5URVIgPSAweDExLFxyXG4gICAgQ0VOVEVSUklHSFQgPSAweDEyLFxyXG4gICAgQk9UVE9NTEVGVCA9IDB4MjAsXHJcbiAgICBCT1RUT01DRU5URVIgPSAweDIxLFxyXG4gICAgQk9UVE9NUklHSFQgPSAweDIyXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZWZpbmVzIGEgcmVjdGFuZ2xlIHdpdGggcG9zaXRpb24gYW5kIHNpemUgYW5kIGFkZCBjb21mb3J0YWJsZSBtZXRob2RzIHRvIGl0XHJcbiAgICogQGF1dGhvciBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBSZWN0YW5nbGUgZXh0ZW5kcyBNdXRhYmxlIHtcclxuICAgIHB1YmxpYyBwb3NpdGlvbjogVmVjdG9yMiA9IFJlY3ljbGVyLmdldChWZWN0b3IyKTtcclxuICAgIHB1YmxpYyBzaXplOiBWZWN0b3IyID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjIpO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKF94OiBudW1iZXIgPSAwLCBfeTogbnVtYmVyID0gMCwgX3dpZHRoOiBudW1iZXIgPSAxLCBfaGVpZ2h0OiBudW1iZXIgPSAxLCBfb3JpZ2luOiBPUklHSU4yRCA9IE9SSUdJTjJELlRPUExFRlQpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5zZXRQb3NpdGlvbkFuZFNpemUoX3gsIF95LCBfd2lkdGgsIF9oZWlnaHQsIF9vcmlnaW4pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG5ldyByZWN0YW5nbGUgY3JlYXRlZCB3aXRoIHRoZSBnaXZlbiBwYXJhbWV0ZXJzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgR0VUKF94OiBudW1iZXIgPSAwLCBfeTogbnVtYmVyID0gMCwgX3dpZHRoOiBudW1iZXIgPSAxLCBfaGVpZ2h0OiBudW1iZXIgPSAxLCBfb3JpZ2luOiBPUklHSU4yRCA9IE9SSUdJTjJELlRPUExFRlQpOiBSZWN0YW5nbGUge1xyXG4gICAgICBsZXQgcmVjdDogUmVjdGFuZ2xlID0gUmVjeWNsZXIuZ2V0KFJlY3RhbmdsZSk7XHJcbiAgICAgIHJlY3Quc2V0UG9zaXRpb25BbmRTaXplKF94LCBfeSwgX3dpZHRoLCBfaGVpZ2h0KTtcclxuICAgICAgcmV0dXJuIHJlY3Q7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBwb3NpdGlvbiBhbmQgc2l6ZSBvZiB0aGUgcmVjdGFuZ2xlIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gcGFyYW1ldGVyc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0UG9zaXRpb25BbmRTaXplKF94OiBudW1iZXIgPSAwLCBfeTogbnVtYmVyID0gMCwgX3dpZHRoOiBudW1iZXIgPSAxLCBfaGVpZ2h0OiBudW1iZXIgPSAxLCBfb3JpZ2luOiBPUklHSU4yRCA9IE9SSUdJTjJELlRPUExFRlQpOiB2b2lkIHtcclxuICAgICAgdGhpcy5zaXplLnNldChfd2lkdGgsIF9oZWlnaHQpO1xyXG4gICAgICBzd2l0Y2ggKF9vcmlnaW4gJiAweDAzKSB7XHJcbiAgICAgICAgY2FzZSAweDAwOiB0aGlzLnBvc2l0aW9uLnggPSBfeDsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAweDAxOiB0aGlzLnBvc2l0aW9uLnggPSBfeCAtIF93aWR0aCAvIDI7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMHgwMjogdGhpcy5wb3NpdGlvbi54ID0gX3ggLSBfd2lkdGg7IGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIHN3aXRjaCAoX29yaWdpbiAmIDB4MzApIHtcclxuICAgICAgICBjYXNlIDB4MDA6IHRoaXMucG9zaXRpb24ueSA9IF95OyBicmVhaztcclxuICAgICAgICBjYXNlIDB4MTA6IHRoaXMucG9zaXRpb24ueSA9IF95IC0gX2hlaWdodCAvIDI7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMHgyMDogdGhpcy5wb3NpdGlvbi55ID0gX3kgLSBfaGVpZ2h0OyBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBwb2ludFRvUmVjdChfcG9pbnQ6IFZlY3RvcjIsIF90YXJnZXQ6IFJlY3RhbmdsZSk6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IyID0gX3BvaW50LmNvcHk7XHJcbiAgICAgIHJlc3VsdC5zdWJ0cmFjdCh0aGlzLnBvc2l0aW9uKTtcclxuICAgICAgcmVzdWx0LnggKj0gX3RhcmdldC53aWR0aCAvIHRoaXMud2lkdGg7XHJcbiAgICAgIHJlc3VsdC55ICo9IF90YXJnZXQuaGVpZ2h0IC8gdGhpcy5oZWlnaHQ7XHJcbiAgICAgIHJlc3VsdC5hZGQoX3RhcmdldC5wb3NpdGlvbik7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHgoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24ueDtcclxuICAgIH1cclxuICAgIGdldCB5KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLnk7XHJcbiAgICB9XHJcbiAgICBnZXQgd2lkdGgoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc2l6ZS54O1xyXG4gICAgfVxyXG4gICAgZ2V0IGhlaWdodCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5zaXplLnk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIGxlZnRtb3N0IGV4cGFuc2lvbiwgcmVzcGVjdGluZyBhbHNvIG5lZ2F0aXZlIHZhbHVlcyBvZiB3aWR0aFxyXG4gICAgICovXHJcbiAgICBnZXQgbGVmdCgpOiBudW1iZXIge1xyXG4gICAgICBpZiAodGhpcy5zaXplLnggPiAwKVxyXG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLng7XHJcbiAgICAgIHJldHVybiAodGhpcy5wb3NpdGlvbi54ICsgdGhpcy5zaXplLngpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIHRvcG1vc3QgZXhwYW5zaW9uLCByZXNwZWN0aW5nIGFsc28gbmVnYXRpdmUgdmFsdWVzIG9mIGhlaWdodFxyXG4gICAgICovXHJcbiAgICBnZXQgdG9wKCk6IG51bWJlciB7XHJcbiAgICAgIGlmICh0aGlzLnNpemUueSA+IDApXHJcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24ueTtcclxuICAgICAgcmV0dXJuICh0aGlzLnBvc2l0aW9uLnkgKyB0aGlzLnNpemUueSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgcmlnaHRtb3N0IGV4cGFuc2lvbiwgcmVzcGVjdGluZyBhbHNvIG5lZ2F0aXZlIHZhbHVlcyBvZiB3aWR0aFxyXG4gICAgICovXHJcbiAgICBnZXQgcmlnaHQoKTogbnVtYmVyIHtcclxuICAgICAgaWYgKHRoaXMuc2l6ZS54ID4gMClcclxuICAgICAgICByZXR1cm4gKHRoaXMucG9zaXRpb24ueCArIHRoaXMuc2l6ZS54KTtcclxuICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24ueDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBsb3dlc3QgZXhwYW5zaW9uLCByZXNwZWN0aW5nIGFsc28gbmVnYXRpdmUgdmFsdWVzIG9mIGhlaWdodFxyXG4gICAgICovXHJcbiAgICBnZXQgYm90dG9tKCk6IG51bWJlciB7XHJcbiAgICAgIGlmICh0aGlzLnNpemUueSA+IDApXHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnBvc2l0aW9uLnkgKyB0aGlzLnNpemUueSk7XHJcbiAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLnk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IHgoX3g6IG51bWJlcikge1xyXG4gICAgICB0aGlzLnBvc2l0aW9uLnggPSBfeDtcclxuICAgIH1cclxuICAgIHNldCB5KF95OiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5wb3NpdGlvbi55ID0gX3k7XHJcbiAgICB9XHJcbiAgICBzZXQgd2lkdGgoX3dpZHRoOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5wb3NpdGlvbi54ID0gX3dpZHRoO1xyXG4gICAgfVxyXG4gICAgc2V0IGhlaWdodChfaGVpZ2h0OiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5wb3NpdGlvbi55ID0gX2hlaWdodDtcclxuICAgIH1cclxuICAgIHNldCBsZWZ0KF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuc2l6ZS54ID0gdGhpcy5yaWdodCAtIF92YWx1ZTtcclxuICAgICAgdGhpcy5wb3NpdGlvbi54ID0gX3ZhbHVlO1xyXG4gICAgfVxyXG4gICAgc2V0IHRvcChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLnNpemUueSA9IHRoaXMuYm90dG9tIC0gX3ZhbHVlO1xyXG4gICAgICB0aGlzLnBvc2l0aW9uLnkgPSBfdmFsdWU7XHJcbiAgICB9XHJcbiAgICBzZXQgcmlnaHQoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5zaXplLnggPSB0aGlzLnBvc2l0aW9uLnggKyBfdmFsdWU7XHJcbiAgICB9XHJcbiAgICBzZXQgYm90dG9tKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuc2l6ZS55ID0gdGhpcy5wb3NpdGlvbi55ICsgX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgY29weSgpOiBSZWN0YW5nbGUge1xyXG4gICAgICByZXR1cm4gUmVjdGFuZ2xlLkdFVCh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBwb2ludCBpcyBpbnNpZGUgb2YgdGhpcyByZWN0YW5nbGUgb3Igb24gdGhlIGJvcmRlclxyXG4gICAgICogQHBhcmFtIF9wb2ludFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaXNJbnNpZGUoX3BvaW50OiBWZWN0b3IyKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiAoX3BvaW50LnggPj0gdGhpcy5sZWZ0ICYmIF9wb2ludC54IDw9IHRoaXMucmlnaHQgJiYgX3BvaW50LnkgPj0gdGhpcy50b3AgJiYgX3BvaW50LnkgPD0gdGhpcy5ib3R0b20pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBjb2xsaWRlcyhfcmVjdDogUmVjdGFuZ2xlKTogYm9vbGVhbiB7XHJcbiAgICAgIGlmICh0aGlzLmxlZnQgPiBfcmVjdC5yaWdodCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAodGhpcy5yaWdodCA8IF9yZWN0LmxlZnQpIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKHRoaXMudG9wID4gX3JlY3QuYm90dG9tKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmICh0aGlzLmJvdHRvbSA8IF9yZWN0LnRvcCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuICAgICAgbGV0IHJlc3VsdDogc3RyaW5nID0gYMaSLlJlY3RhbmdsZShwb3NpdGlvbjoke3RoaXMucG9zaXRpb24udG9TdHJpbmcoKX0sIHNpemU6JHt0aGlzLnNpemUudG9TdHJpbmcoKX1gO1xyXG4gICAgICByZXN1bHQgKz0gYCwgbGVmdDoke3RoaXMubGVmdC50b1ByZWNpc2lvbig1KX0sIHRvcDoke3RoaXMudG9wLnRvUHJlY2lzaW9uKDUpfSwgcmlnaHQ6JHt0aGlzLnJpZ2h0LnRvUHJlY2lzaW9uKDUpfSwgYm90dG9tOiR7dGhpcy5ib3R0b20udG9QcmVjaXNpb24oNSl9YDtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQgey8qICovIH1cclxuICB9XHJcbn0iLCIvLy88cmVmZXJlbmNlIHBhdGg9XCJSZW5kZXJJbmplY3Rvci50c1wiLz5cclxuLy8vPHJlZmVyZW5jZSBwYXRoPVwiUmVuZGVySW5qZWN0b3JTaGFkZXIudHNcIi8+XHJcbi8vLzxyZWZlcmVuY2UgcGF0aD1cIlJlbmRlckluamVjdG9yQ29hdC50c1wiLz5cclxuLy8vPHJlZmVyZW5jZSBwYXRoPVwiUmVuZGVySW5qZWN0b3JNZXNoLnRzXCIvPlxyXG4vLy88cmVmZXJlbmNlIHBhdGg9XCIuLi9NYXRoL1JlY3RhbmdsZS50c1wiLz5cclxuXHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBkZWNsYXJlIGxldCBmdWRnZUNvbmZpZzogR2VuZXJhbDtcclxuXHJcbiAgZXhwb3J0IGVudW0gQkxFTkQge1xyXG4gICAgT1BBUVVFLCBUUkFOU1BBUkVOVCwgUEFSVElDTEVcclxuICB9XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgQnVmZmVyU3BlY2lmaWNhdGlvbiB7XHJcbiAgICBzaXplOiBudW1iZXI7ICAgLy8gVGhlIHNpemUgb2YgdGhlIGRhdGFzYW1wbGUuXHJcbiAgICBkYXRhVHlwZTogbnVtYmVyOyAvLyBUaGUgZGF0YXR5cGUgb2YgdGhlIHNhbXBsZSAoZS5nLiBnbC5GTE9BVCwgZ2wuQllURSwgZXRjLilcclxuICAgIG5vcm1hbGl6ZTogYm9vbGVhbjsgLy8gRmxhZyB0byBub3JtYWxpemUgdGhlIGRhdGEuXHJcbiAgICBzdHJpZGU6IG51bWJlcjsgLy8gTnVtYmVyIG9mIGluZGljZXMgdGhhdCB3aWxsIGJlIHNraXBwZWQgZWFjaCBpdGVyYXRpb24uXHJcbiAgICBvZmZzZXQ6IG51bWJlcjsgLy8gSW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gYmVnaW4gd2l0aC5cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEJhc2UgY2xhc3MgZm9yIFJlbmRlck1hbmFnZXIsIGhhbmRsaW5nIHRoZSBjb25uZWN0aW9uIHRvIHRoZSByZW5kZXJpbmcgc3lzdGVtLCBpbiB0aGlzIGNhc2UgV2ViR0wuXHJcbiAgICogTWV0aG9kcyBhbmQgYXR0cmlidXRlcyBvZiB0aGlzIGNsYXNzIHNob3VsZCBub3QgYmUgY2FsbGVkIGRpcmVjdGx5LCBvbmx5IHRocm91Z2ggW1tSZW5kZXJNYW5hZ2VyXV1cclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgUmVuZGVyT3BlcmF0b3Ige1xyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyT3BlcmF0b3IuaW5pdGlhbGl6ZSgpO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVjdFZpZXdwb3J0OiBSZWN0YW5nbGUgPSBSZW5kZXJPcGVyYXRvci5nZXRDYW52YXNSZWN0KCk7XHJcblxyXG5cclxuICAgIC8qKiBcclxuICAgICAqIFdyYXBwZXIgZnVuY3Rpb24gdG8gdXRpbGl6ZSB0aGUgYnVmZmVyU3BlY2lmaWNhdGlvbiBpbnRlcmZhY2Ugd2hlbiBwYXNzaW5nIGRhdGEgdG8gdGhlIHNoYWRlciB2aWEgYSBidWZmZXIuXHJcbiAgICAgKiBAcGFyYW0gX2F0dHJpYnV0ZUxvY2F0aW9uICBUaGUgbG9jYXRpb24gb2YgdGhlIGF0dHJpYnV0ZSBvbiB0aGUgc2hhZGVyLCB0byB3aGljaCB0aGV5IGRhdGEgd2lsbCBiZSBwYXNzZWQuXHJcbiAgICAgKiBAcGFyYW0gX2J1ZmZlclNwZWNpZmljYXRpb24gIEludGVyZmFjZSBwYXNzaW5nIGRhdGFwdWxsc3BlY2lmaWNhdGlvbnMgdG8gdGhlIGJ1ZmZlci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzZXRBdHRyaWJ1dGVTdHJ1Y3R1cmUoX2F0dHJpYnV0ZUxvY2F0aW9uOiBudW1iZXIsIF9idWZmZXJTcGVjaWZpY2F0aW9uOiBCdWZmZXJTcGVjaWZpY2F0aW9uKTogdm9pZCB7XHJcbiAgICAgIFJlbmRlck9wZXJhdG9yLmNyYzMudmVydGV4QXR0cmliUG9pbnRlcihfYXR0cmlidXRlTG9jYXRpb24sIF9idWZmZXJTcGVjaWZpY2F0aW9uLnNpemUsIF9idWZmZXJTcGVjaWZpY2F0aW9uLmRhdGFUeXBlLCBfYnVmZmVyU3BlY2lmaWNhdGlvbi5ub3JtYWxpemUsIF9idWZmZXJTcGVjaWZpY2F0aW9uLnN0cmlkZSwgX2J1ZmZlclNwZWNpZmljYXRpb24ub2Zmc2V0KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogQ2hlY2tzIHRoZSBmaXJzdCBwYXJhbWV0ZXIgYW5kIHRocm93cyBhbiBleGNlcHRpb24gd2l0aCB0aGUgV2ViR0wtZXJyb3Jjb2RlIGlmIHRoZSB2YWx1ZSBpcyBudWxsXHJcbiAgICAqIEBwYXJhbSBfdmFsdWUgIHZhbHVlIHRvIGNoZWNrIGFnYWluc3QgbnVsbFxyXG4gICAgKiBAcGFyYW0gX21lc3NhZ2UgIG9wdGlvbmFsLCBhZGRpdGlvbmFsIG1lc3NhZ2UgZm9yIHRoZSBleGNlcHRpb25cclxuICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGFzc2VydDxUPihfdmFsdWU6IFQgfCBudWxsLCBfbWVzc2FnZTogc3RyaW5nID0gXCJcIik6IFQge1xyXG4gICAgICBpZiAoX3ZhbHVlID09PSBudWxsKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQXNzZXJ0aW9uIGZhaWxlZC4gJHtfbWVzc2FnZX0sIFdlYkdMLUVycm9yOiAke1JlbmRlck9wZXJhdG9yLmNyYzMgPyBSZW5kZXJPcGVyYXRvci5jcmMzLmdldEVycm9yKCkgOiBcIlwifWApO1xyXG4gICAgICByZXR1cm4gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZXMgb2Zmc2NyZWVuLWNhbnZhcywgcmVuZGVyaW5nY29udGV4dCBhbmQgaGFyZHdhcmUgdmlld3BvcnQuIENhbGwgb25jZSBiZWZvcmUgY3JlYXRpbmcgYW55IHJlc291cmNlcyBsaWtlIG1lc2hlcyBvciBzaGFkZXJzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgaW5pdGlhbGl6ZShfYW50aWFsaWFzPzogYm9vbGVhbiwgX2FscGhhPzogYm9vbGVhbik6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQge1xyXG4gICAgICBmdWRnZUNvbmZpZyA9IGZ1ZGdlQ29uZmlnIHx8IHt9O1xyXG4gICAgICBsZXQgY29udGV4dEF0dHJpYnV0ZXM6IFdlYkdMQ29udGV4dEF0dHJpYnV0ZXMgPSB7XHJcbiAgICAgICAgYWxwaGE6IChfYWxwaGEgIT0gdW5kZWZpbmVkKSA/IF9hbHBoYSA6IGZ1ZGdlQ29uZmlnLmFscGhhIHx8IGZhbHNlLFxyXG4gICAgICAgIGFudGlhbGlhczogKF9hbnRpYWxpYXMgIT0gdW5kZWZpbmVkKSA/IF9hbnRpYWxpYXMgOiBmdWRnZUNvbmZpZy5hbnRpYWxpYXMgfHwgZmFsc2UsXHJcbiAgICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiBmYWxzZVxyXG4gICAgICB9O1xyXG4gICAgICBEZWJ1Zy5mdWRnZShcIkluaXRpYWxpemUgUmVuZGVyTWFuYWdlclwiLCBjb250ZXh0QXR0cmlidXRlcyk7XHJcbiAgICAgIGxldCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcclxuICAgICAgbGV0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ7XHJcbiAgICAgIGNyYzMgPSBSZW5kZXJPcGVyYXRvci5hc3NlcnQ8V2ViR0wyUmVuZGVyaW5nQ29udGV4dD4oXHJcbiAgICAgICAgY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbDJcIiwgY29udGV4dEF0dHJpYnV0ZXMpLFxyXG4gICAgICAgIFwiV2ViR0wtY29udGV4dCBjb3VsZG4ndCBiZSBjcmVhdGVkXCJcclxuICAgICAgKTtcclxuICAgICAgUmVuZGVyT3BlcmF0b3IuY3JjMyA9IGNyYzM7XHJcbiAgICAgIC8vIEVuYWJsZSBiYWNrZmFjZS0gYW5kIHpCdWZmZXItY3VsbGluZy5cclxuICAgICAgY3JjMy5lbmFibGUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5DVUxMX0ZBQ0UpO1xyXG4gICAgICBjcmMzLmVuYWJsZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkRFUFRIX1RFU1QpO1xyXG4gICAgICBjcmMzLmVuYWJsZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkJMRU5EKTtcclxuICAgICAgY3JjMy5ibGVuZEVxdWF0aW9uKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRlVOQ19BREQpO1xyXG4gICAgICBSZW5kZXJPcGVyYXRvci5zZXRCbGVuZE1vZGUoQkxFTkQuVFJBTlNQQVJFTlQpO1xyXG4gICAgICAvLyBSZW5kZXJPcGVyYXRvci5jcmMzLnBpeGVsU3RvcmVpKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdHJ1ZSk7XHJcbiAgICAgIFJlbmRlck9wZXJhdG9yLnJlY3RWaWV3cG9ydCA9IFJlbmRlck9wZXJhdG9yLmdldENhbnZhc1JlY3QoKTtcclxuICAgICAgcmV0dXJuIGNyYzM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYSByZWZlcmVuY2UgdG8gdGhlIG9mZnNjcmVlbi1jYW52YXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXRDYW52YXMoKTogSFRNTENhbnZhc0VsZW1lbnQge1xyXG4gICAgICByZXR1cm4gPEhUTUxDYW52YXNFbGVtZW50PlJlbmRlck9wZXJhdG9yLmNyYzMuY2FudmFzOyAvLyBUT0RPOiBlbmFibGUgT2Zmc2NyZWVuQ2FudmFzXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYSByZWZlcmVuY2UgdG8gdGhlIHJlbmRlcmluZyBjb250ZXh0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0UmVuZGVyaW5nQ29udGV4dCgpOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0IHtcclxuICAgICAgcmV0dXJuIFJlbmRlck9wZXJhdG9yLmNyYzM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYSByZWN0YW5nbGUgZGVzY3JpYmluZyB0aGUgc2l6ZSBvZiB0aGUgb2Zmc2NyZWVuLWNhbnZhcy4geCx5IGFyZSAwIGF0IGFsbCB0aW1lcy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXRDYW52YXNSZWN0KCk6IFJlY3RhbmdsZSB7XHJcbiAgICAgIGxldCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50ID0gPEhUTUxDYW52YXNFbGVtZW50PlJlbmRlck9wZXJhdG9yLmNyYzMuY2FudmFzO1xyXG4gICAgICByZXR1cm4gUmVjdGFuZ2xlLkdFVCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBzaXplIG9mIHRoZSBvZmZzY3JlZW4tY2FudmFzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHNldENhbnZhc1NpemUoX3dpZHRoOiBudW1iZXIsIF9oZWlnaHQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICBSZW5kZXJPcGVyYXRvci5jcmMzLmNhbnZhcy53aWR0aCA9IF93aWR0aDtcclxuICAgICAgUmVuZGVyT3BlcmF0b3IuY3JjMy5jYW52YXMuaGVpZ2h0ID0gX2hlaWdodDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgYXJlYSBvbiB0aGUgb2Zmc2NyZWVuLWNhbnZhcyB0byByZW5kZXIgdGhlIGNhbWVyYSBpbWFnZSB0by5cclxuICAgICAqIEBwYXJhbSBfcmVjdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHNldFZpZXdwb3J0UmVjdGFuZ2xlKF9yZWN0OiBSZWN0YW5nbGUpOiB2b2lkIHtcclxuICAgICAgT2JqZWN0LmFzc2lnbihSZW5kZXJPcGVyYXRvci5yZWN0Vmlld3BvcnQsIF9yZWN0KTtcclxuICAgICAgUmVuZGVyT3BlcmF0b3IuY3JjMy52aWV3cG9ydChfcmVjdC54LCBfcmVjdC55LCBfcmVjdC53aWR0aCwgX3JlY3QuaGVpZ2h0KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlIHRoZSBhcmVhIG9uIHRoZSBvZmZzY3JlZW4tY2FudmFzIHRoZSBjYW1lcmEgaW1hZ2UgZ2V0cyByZW5kZXJlZCB0by5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXRWaWV3cG9ydFJlY3RhbmdsZSgpOiBSZWN0YW5nbGUge1xyXG4gICAgICByZXR1cm4gUmVuZGVyT3BlcmF0b3IucmVjdFZpZXdwb3J0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgc2V0RGVwdGhUZXN0KF90ZXN0OiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgIGlmIChfdGVzdClcclxuICAgICAgICBSZW5kZXJPcGVyYXRvci5jcmMzLmVuYWJsZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkRFUFRIX1RFU1QpO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgUmVuZGVyT3BlcmF0b3IuY3JjMy5kaXNhYmxlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuREVQVEhfVEVTVCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBzZXRCbGVuZE1vZGUoX21vZGU6IEJMRU5EKTogdm9pZCB7XHJcbiAgICAgIHN3aXRjaCAoX21vZGUpIHtcclxuICAgICAgICBjYXNlIEJMRU5ELk9QQVFVRTpcclxuICAgICAgICAgIFJlbmRlck9wZXJhdG9yLmNyYzMuYmxlbmRGdW5jKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuT05FLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlpFUk8pO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBCTEVORC5UUkFOU1BBUkVOVDpcclxuICAgICAgICAgIFJlbmRlck9wZXJhdG9yLmNyYzMuYmxlbmRGdW5jKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuU1JDX0FMUEhBLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk9ORV9NSU5VU19TUkNfQUxQSEEpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBCTEVORC5QQVJUSUNMRTpcclxuICAgICAgICAgIFJlbmRlck9wZXJhdG9yLmNyYzMuYmxlbmRGdW5jKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuU1JDX0FMUEhBLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkRTVF9BTFBIQSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXcgYSBtZXNoIGJ1ZmZlciB1c2luZyB0aGUgZ2l2ZW4gaW5mb3MgYW5kIHRoZSBjb21wbGV0ZSBwcm9qZWN0aW9uIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGRyYXcoX21lc2g6IE1lc2gsIGNtcE1hdGVyaWFsOiBDb21wb25lbnRNYXRlcmlhbCwgX2ZpbmFsOiBNYXRyaXg0eDQsIF9wcm9qZWN0aW9uOiBNYXRyaXg0eDQpOiB2b2lkIHtcclxuICAgICAgbGV0IHNoYWRlcjogdHlwZW9mIFNoYWRlciA9IGNtcE1hdGVyaWFsLm1hdGVyaWFsLmdldFNoYWRlcigpO1xyXG4gICAgICBsZXQgY29hdDogQ29hdCA9IGNtcE1hdGVyaWFsLm1hdGVyaWFsLmdldENvYXQoKTtcclxuICAgICAgc2hhZGVyLnVzZVByb2dyYW0oKTtcclxuICAgICAgX21lc2gudXNlUmVuZGVyQnVmZmVycyhzaGFkZXIsIF9maW5hbCwgX3Byb2plY3Rpb24pO1xyXG4gICAgICBjb2F0LnVzZVJlbmRlckRhdGEoc2hhZGVyLCBjbXBNYXRlcmlhbCk7XHJcbiAgICAgIFJlbmRlck9wZXJhdG9yLmNyYzMuZHJhd0VsZW1lbnRzKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVFJJQU5HTEVTLCBfbWVzaC5yZW5kZXJCdWZmZXJzLm5JbmRpY2VzLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOU0lHTkVEX1NIT1JULCAwKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCIvLy8gPHJlZmVyZW5jZSBwYXRoPVwiRGVidWcvRGVidWdUYXJnZXQudHNcIi8+XHJcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJEZWJ1Zy9EZWJ1Zy50c1wiLz5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkV2ZW50L0V2ZW50LnRzXCIvPlxyXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiVHJhbnNmZXIvTXV0YWJsZS50c1wiLz4gIFxyXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiVHJhbnNmZXIvU2VyaWFsaXplci50c1wiLz4gXHJcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJSZW5kZXIvUmVuZGVyT3BlcmF0b3IudHNcIi8+XHJcbiIsIi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vVHJhbnNmZXIvTXV0YWJsZS50c1wiLz5cclxuXHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEhvbGRzIGluZm9ybWF0aW9uIGFib3V0IHRoZSBBbmltYXRpb25TdHJ1Y3R1cmUgdGhhdCB0aGUgQW5pbWF0aW9uIHVzZXMgdG8gbWFwIHRoZSBTZXF1ZW5jZXMgdG8gdGhlIEF0dHJpYnV0ZXMuXHJcbiAgICogQnVpbHQgb3V0IG9mIGEgW1tOb2RlXV0ncyBzZXJpYWxzYXRpb24sIGl0IHN3YXBzIHRoZSB2YWx1ZXMgd2l0aCBbW0FuaW1hdGlvblNlcXVlbmNlXV1zLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgQW5pbWF0aW9uU3RydWN0dXJlIHtcclxuICAgIFthdHRyaWJ1dGU6IHN0cmluZ106IFNlcmlhbGl6YXRpb24gfCBBbmltYXRpb25TZXF1ZW5jZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICogQW4gYXNzb2NpYXRpdmUgYXJyYXkgbWFwcGluZyBuYW1lcyBvZiBsYWJsZXMgdG8gdGltZXN0YW1wcy5cclxuICAqIExhYmVscyBuZWVkIHRvIGJlIHVuaXF1ZSBwZXIgQW5pbWF0aW9uLlxyXG4gICogQGF1dGhvciBMdWthcyBTY2hldWVybGUsIEhGVSwgMjAxOVxyXG4gICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBBbmltYXRpb25MYWJlbCB7XHJcbiAgICBbbmFtZTogc3RyaW5nXTogbnVtYmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgKiBIb2xkcyBpbmZvcm1hdGlvbiBhYm91dCBBbmltYXRpb24gRXZlbnQgVHJpZ2dlcnNcclxuICAqIEBhdXRob3IgTHVrYXMgU2NoZXVlcmxlLCBIRlUsIDIwMTlcclxuICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgQW5pbWF0aW9uRXZlbnRUcmlnZ2VyIHtcclxuICAgIFtuYW1lOiBzdHJpbmddOiBudW1iZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbnRlcm5hbGx5IHVzZWQgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIHRoZSB2YXJpb3VzIGdlbmVyYXRlZCBzdHJ1Y3R1cmVzIGFuZCBldmVudHMuXHJcbiAgICogQGF1dGhvciBMdWthcyBTY2hldWVybGUsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGVudW0gQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFIHtcclxuICAgIC8qKkRlZmF1bHQ6IGZvcndhcmQsIGNvbnRpbm91cyAqL1xyXG4gICAgTk9STUFMLFxyXG4gICAgLyoqYmFja3dhcmQsIGNvbnRpbm91cyAqL1xyXG4gICAgUkVWRVJTRSxcclxuICAgIC8qKmZvcndhcmQsIHJhc3RlcmVkICovXHJcbiAgICBSQVNURVJFRCxcclxuICAgIC8qKmJhY2t3YXJkLCByYXN0ZXJlZCAqL1xyXG4gICAgUkFTVEVSRURSRVZFUlNFXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBbmltYXRpb24gQ2xhc3MgdG8gaG9sZCBhbGwgcmVxdWlyZWQgT2JqZWN0cyB0aGF0IGFyZSBwYXJ0IG9mIGFuIEFuaW1hdGlvbi5cclxuICAgKiBBbHNvIGhvbGRzIGZ1bmN0aW9ucyB0byBwbGF5IHNhaWQgQW5pbWF0aW9uLlxyXG4gICAqIENhbiBiZSBhZGRlZCB0byBhIE5vZGUgYW5kIHBsYXllZCB0aHJvdWdoIFtbQ29tcG9uZW50QW5pbWF0b3JdXS5cclxuICAgKiBAYXV0aG9yIEx1a2FzIFNjaGV1ZXJsZSwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEFuaW1hdGlvbiBleHRlbmRzIE11dGFibGUgaW1wbGVtZW50cyBTZXJpYWxpemFibGVSZXNvdXJjZSB7XHJcbiAgICBpZFJlc291cmNlOiBzdHJpbmc7XHJcbiAgICBuYW1lOiBzdHJpbmc7XHJcbiAgICB0b3RhbFRpbWU6IG51bWJlciA9IDA7XHJcbiAgICBsYWJlbHM6IEFuaW1hdGlvbkxhYmVsID0ge307XHJcbiAgICBzdGVwc1BlclNlY29uZDogbnVtYmVyID0gMTA7XHJcbiAgICBhbmltYXRpb25TdHJ1Y3R1cmU6IEFuaW1hdGlvblN0cnVjdHVyZTtcclxuICAgIGV2ZW50czogQW5pbWF0aW9uRXZlbnRUcmlnZ2VyID0ge307XHJcbiAgICBwcml2YXRlIGZyYW1lc1BlclNlY29uZDogbnVtYmVyID0gNjA7XHJcblxyXG4gICAgLy8gcHJvY2Vzc2VkIGV2ZW50bGlzdCBhbmQgYW5pbWF0aW9uIHN0cnVjdXRyZXMgZm9yIHBsYXliYWNrLlxyXG4gICAgcHJpdmF0ZSBldmVudHNQcm9jZXNzZWQ6IE1hcDxBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUsIEFuaW1hdGlvbkV2ZW50VHJpZ2dlcj4gPSBuZXcgTWFwPEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRSwgQW5pbWF0aW9uRXZlbnRUcmlnZ2VyPigpO1xyXG4gICAgcHJpdmF0ZSBhbmltYXRpb25TdHJ1Y3R1cmVzUHJvY2Vzc2VkOiBNYXA8QU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLCBBbmltYXRpb25TdHJ1Y3R1cmU+ID0gbmV3IE1hcDxBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUsIEFuaW1hdGlvblN0cnVjdHVyZT4oKTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nLCBfYW5pbVN0cnVjdHVyZTogQW5pbWF0aW9uU3RydWN0dXJlID0ge30sIF9mcHM6IG51bWJlciA9IDYwKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMubmFtZSA9IF9uYW1lO1xyXG4gICAgICB0aGlzLmFuaW1hdGlvblN0cnVjdHVyZSA9IF9hbmltU3RydWN0dXJlO1xyXG4gICAgICB0aGlzLmFuaW1hdGlvblN0cnVjdHVyZXNQcm9jZXNzZWQuc2V0KEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5OT1JNQUwsIF9hbmltU3RydWN0dXJlKTtcclxuICAgICAgdGhpcy5mcmFtZXNQZXJTZWNvbmQgPSBfZnBzO1xyXG4gICAgICB0aGlzLmNhbGN1bGF0ZVRvdGFsVGltZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIGEgbmV3IFwiTXV0YXRvclwiIHdpdGggdGhlIGluZm9ybWF0aW9uIHRvIGFwcGx5IHRvIHRoZSBbW05vZGVdXSB0aGUgW1tDb21wb25lbnRBbmltYXRvcl1dIGlzIGF0dGFjaGVkIHRvIHdpdGggW1tOb2RlLmFwcGx5QW5pbWF0aW9uKCldXS5cclxuICAgICAqIEBwYXJhbSBfdGltZSBUaGUgdGltZSBhdCB3aGljaCB0aGUgYW5pbWF0aW9uIGN1cnJlbnRseSBpcyBhdFxyXG4gICAgICogQHBhcmFtIF9kaXJlY3Rpb24gVGhlIGRpcmVjdGlvbiBpbiB3aGljaCB0aGUgYW5pbWF0aW9uIGlzIHN1cHBvc2VkIHRvIGJlIHBsYXlpbmcgYmFjay4gPjAgPT0gZm9yd2FyZCwgMCA9PSBzdG9wLCA8MCA9PSBiYWNrd2FyZHNcclxuICAgICAqIEBwYXJhbSBfcGxheWJhY2sgVGhlIHBsYXliYWNrbW9kZSB0aGUgYW5pbWF0aW9uIGlzIHN1cHBvc2VkIHRvIGJlIGNhbGN1bGF0ZWQgd2l0aC5cclxuICAgICAqIEByZXR1cm5zIGEgXCJNdXRhdG9yXCIgdG8gYXBwbHkuXHJcbiAgICAgKi9cclxuICAgIGdldE11dGF0ZWQoX3RpbWU6IG51bWJlciwgX2RpcmVjdGlvbjogbnVtYmVyLCBfcGxheWJhY2s6IEFOSU1BVElPTl9QTEFZQkFDSyk6IE11dGF0b3IgeyAgICAgLy9UT0RPOiBmaW5kIGEgYmV0dGVyIG5hbWUgZm9yIHRoaXNcclxuICAgICAgbGV0IG06IE11dGF0b3IgPSB7fTtcclxuICAgICAgaWYgKF9wbGF5YmFjayA9PSBBTklNQVRJT05fUExBWUJBQ0suVElNRUJBU0VEX0NPTlRJTk9VUykge1xyXG4gICAgICAgIGlmIChfZGlyZWN0aW9uID49IDApIHtcclxuICAgICAgICAgIG0gPSB0aGlzLnRyYXZlcnNlU3RydWN0dXJlRm9yTXV0YXRvcih0aGlzLmdldFByb2Nlc3NlZEFuaW1hdGlvblN0cnVjdHVyZShBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuTk9STUFMKSwgX3RpbWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBtID0gdGhpcy50cmF2ZXJzZVN0cnVjdHVyZUZvck11dGF0b3IodGhpcy5nZXRQcm9jZXNzZWRBbmltYXRpb25TdHJ1Y3R1cmUoQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlJFVkVSU0UpLCBfdGltZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChfZGlyZWN0aW9uID49IDApIHtcclxuICAgICAgICAgIG0gPSB0aGlzLnRyYXZlcnNlU3RydWN0dXJlRm9yTXV0YXRvcih0aGlzLmdldFByb2Nlc3NlZEFuaW1hdGlvblN0cnVjdHVyZShBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuUkFTVEVSRUQpLCBfdGltZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG0gPSB0aGlzLnRyYXZlcnNlU3RydWN0dXJlRm9yTXV0YXRvcih0aGlzLmdldFByb2Nlc3NlZEFuaW1hdGlvblN0cnVjdHVyZShBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuUkFTVEVSRURSRVZFUlNFKSwgX3RpbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiB0aGUgbmFtZXMgb2YgdGhlIGV2ZW50cyB0aGUgW1tDb21wb25lbnRBbmltYXRvcl1dIG5lZWRzIHRvIGZpcmUgYmV0d2VlbiBfbWluIGFuZCBfbWF4LiBcclxuICAgICAqIEBwYXJhbSBfbWluIFRoZSBtaW5pbXVtIHRpbWUgKGluY2x1c2l2ZSkgdG8gY2hlY2sgYmV0d2VlblxyXG4gICAgICogQHBhcmFtIF9tYXggVGhlIG1heGltdW0gdGltZSAoZXhjbHVzaXZlKSB0byBjaGVjayBiZXR3ZWVuXHJcbiAgICAgKiBAcGFyYW0gX3BsYXliYWNrIFRoZSBwbGF5YmFjayBtb2RlIHRvIGNoZWNrIGluLiBIYXMgYW4gZWZmZWN0IG9uIHdoZW4gdGhlIEV2ZW50cyBhcmUgZmlyZWQuIFxyXG4gICAgICogQHBhcmFtIF9kaXJlY3Rpb24gVGhlIGRpcmVjdGlvbiB0aGUgYW5pbWF0aW9uIGlzIHN1cHBvc2VkIHRvIHJ1biBpbi4gPjAgPT0gZm9yd2FyZCwgMCA9PSBzdG9wLCA8MCA9PSBiYWNrd2FyZHNcclxuICAgICAqIEByZXR1cm5zIGEgbGlzdCBvZiBzdHJpbmdzIHdpdGggdGhlIG5hbWVzIG9mIHRoZSBjdXN0b20gZXZlbnRzIHRvIGZpcmUuXHJcbiAgICAgKi9cclxuICAgIGdldEV2ZW50c1RvRmlyZShfbWluOiBudW1iZXIsIF9tYXg6IG51bWJlciwgX3BsYXliYWNrOiBBTklNQVRJT05fUExBWUJBQ0ssIF9kaXJlY3Rpb246IG51bWJlcik6IHN0cmluZ1tdIHtcclxuICAgICAgbGV0IGV2ZW50TGlzdDogc3RyaW5nW10gPSBbXTtcclxuICAgICAgbGV0IG1pblNlY3Rpb246IG51bWJlciA9IE1hdGguZmxvb3IoX21pbiAvIHRoaXMudG90YWxUaW1lKTtcclxuICAgICAgbGV0IG1heFNlY3Rpb246IG51bWJlciA9IE1hdGguZmxvb3IoX21heCAvIHRoaXMudG90YWxUaW1lKTtcclxuICAgICAgX21pbiA9IF9taW4gJSB0aGlzLnRvdGFsVGltZTtcclxuICAgICAgX21heCA9IF9tYXggJSB0aGlzLnRvdGFsVGltZTtcclxuXHJcbiAgICAgIHdoaWxlIChtaW5TZWN0aW9uIDw9IG1heFNlY3Rpb24pIHtcclxuICAgICAgICBsZXQgZXZlbnRUcmlnZ2VyczogQW5pbWF0aW9uRXZlbnRUcmlnZ2VyID0gdGhpcy5nZXRDb3JyZWN0RXZlbnRMaXN0KF9kaXJlY3Rpb24sIF9wbGF5YmFjayk7XHJcbiAgICAgICAgaWYgKG1pblNlY3Rpb24gPT0gbWF4U2VjdGlvbikge1xyXG4gICAgICAgICAgZXZlbnRMaXN0ID0gZXZlbnRMaXN0LmNvbmNhdCh0aGlzLmNoZWNrRXZlbnRzQmV0d2VlbihldmVudFRyaWdnZXJzLCBfbWluLCBfbWF4KSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGV2ZW50TGlzdCA9IGV2ZW50TGlzdC5jb25jYXQodGhpcy5jaGVja0V2ZW50c0JldHdlZW4oZXZlbnRUcmlnZ2VycywgX21pbiwgdGhpcy50b3RhbFRpbWUpKTtcclxuICAgICAgICAgIF9taW4gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtaW5TZWN0aW9uKys7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBldmVudExpc3Q7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIEV2ZW50IHRvIHRoZSBMaXN0IG9mIGV2ZW50cy5cclxuICAgICAqIEBwYXJhbSBfbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgKG5lZWRzIHRvIGJlIHVuaXF1ZSBwZXIgQW5pbWF0aW9uKS5cclxuICAgICAqIEBwYXJhbSBfdGltZSBUaGUgdGltZXN0YW1wIG9mIHRoZSBldmVudCAoaW4gbWlsbGlzZWNvbmRzKS5cclxuICAgICAqL1xyXG4gICAgc2V0RXZlbnQoX25hbWU6IHN0cmluZywgX3RpbWU6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICB0aGlzLmV2ZW50c1tfbmFtZV0gPSBfdGltZTtcclxuICAgICAgdGhpcy5ldmVudHNQcm9jZXNzZWQuY2xlYXIoKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBldmVudCB3aXRoIHRoZSBnaXZlbiBuYW1lIGZyb20gdGhlIGxpc3Qgb2YgZXZlbnRzLlxyXG4gICAgICogQHBhcmFtIF9uYW1lIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHJlbW92ZS5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlRXZlbnQoX25hbWU6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICBkZWxldGUgdGhpcy5ldmVudHNbX25hbWVdO1xyXG4gICAgICB0aGlzLmV2ZW50c1Byb2Nlc3NlZC5jbGVhcigpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBnZXRMYWJlbHMoKTogRW51bWVyYXRvciB7XHJcbiAgICAgIC8vVE9ETzogdGhpcyBhY3R1YWxseSBuZWVkcyB0ZXN0aW5nXHJcbiAgICAgIGxldCBlbjogRW51bWVyYXRvciA9IG5ldyBFbnVtZXJhdG9yKHRoaXMubGFiZWxzKTtcclxuICAgICAgcmV0dXJuIGVuO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBmcHMoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZnJhbWVzUGVyU2Vjb25kO1xyXG4gICAgfVxyXG5cclxuICAgIHNldCBmcHMoX2ZwczogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuZnJhbWVzUGVyU2Vjb25kID0gX2ZwcztcclxuICAgICAgdGhpcy5ldmVudHNQcm9jZXNzZWQuY2xlYXIoKTtcclxuICAgICAgdGhpcy5hbmltYXRpb25TdHJ1Y3R1cmVzUHJvY2Vzc2VkLmNsZWFyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAoUmUtKUNhbGN1bGF0ZSB0aGUgdG90YWwgdGltZSBvZiB0aGUgQW5pbWF0aW9uLiBDYWxjdWxhdGlvbi1oZWF2eSwgdXNlIG9ubHkgaWYgYWN0dWFsbHkgbmVlZGVkLlxyXG4gICAgICovXHJcbiAgICBjYWxjdWxhdGVUb3RhbFRpbWUoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMudG90YWxUaW1lID0gMDtcclxuICAgICAgdGhpcy50cmF2ZXJzZVN0cnVjdHVyZUZvclRpbWUodGhpcy5hbmltYXRpb25TdHJ1Y3R1cmUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiB0cmFuc2ZlclxyXG4gICAgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgczogU2VyaWFsaXphdGlvbiA9IHtcclxuICAgICAgICBpZFJlc291cmNlOiB0aGlzLmlkUmVzb3VyY2UsXHJcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgIGxhYmVsczoge30sXHJcbiAgICAgICAgZXZlbnRzOiB7fSxcclxuICAgICAgICBmcHM6IHRoaXMuZnJhbWVzUGVyU2Vjb25kLFxyXG4gICAgICAgIHNwczogdGhpcy5zdGVwc1BlclNlY29uZFxyXG4gICAgICB9O1xyXG4gICAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMubGFiZWxzKSB7XHJcbiAgICAgICAgcy5sYWJlbHNbbmFtZV0gPSB0aGlzLmxhYmVsc1tuYW1lXTtcclxuICAgICAgfVxyXG4gICAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMuZXZlbnRzKSB7XHJcbiAgICAgICAgcy5ldmVudHNbbmFtZV0gPSB0aGlzLmV2ZW50c1tuYW1lXTtcclxuICAgICAgfVxyXG4gICAgICBzLmFuaW1hdGlvblN0cnVjdHVyZSA9IHRoaXMudHJhdmVyc2VTdHJ1Y3R1cmVGb3JTZXJpYWxpc2F0aW9uKHRoaXMuYW5pbWF0aW9uU3RydWN0dXJlKTtcclxuICAgICAgcmV0dXJuIHM7XHJcbiAgICB9XHJcbiAgICBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFNlcmlhbGl6YWJsZSB7XHJcbiAgICAgIHRoaXMuaWRSZXNvdXJjZSA9IF9zZXJpYWxpemF0aW9uLmlkUmVzb3VyY2U7XHJcbiAgICAgIHRoaXMubmFtZSA9IF9zZXJpYWxpemF0aW9uLm5hbWU7XHJcbiAgICAgIHRoaXMuZnJhbWVzUGVyU2Vjb25kID0gX3NlcmlhbGl6YXRpb24uZnBzO1xyXG4gICAgICB0aGlzLnN0ZXBzUGVyU2Vjb25kID0gX3NlcmlhbGl6YXRpb24uc3BzO1xyXG4gICAgICB0aGlzLmxhYmVscyA9IHt9O1xyXG4gICAgICBmb3IgKGxldCBuYW1lIGluIF9zZXJpYWxpemF0aW9uLmxhYmVscykge1xyXG4gICAgICAgIHRoaXMubGFiZWxzW25hbWVdID0gX3NlcmlhbGl6YXRpb24ubGFiZWxzW25hbWVdO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuZXZlbnRzID0ge307XHJcbiAgICAgIGZvciAobGV0IG5hbWUgaW4gX3NlcmlhbGl6YXRpb24uZXZlbnRzKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudHNbbmFtZV0gPSBfc2VyaWFsaXphdGlvbi5ldmVudHNbbmFtZV07XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5ldmVudHNQcm9jZXNzZWQgPSBuZXcgTWFwPEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRSwgQW5pbWF0aW9uRXZlbnRUcmlnZ2VyPigpO1xyXG5cclxuICAgICAgdGhpcy5hbmltYXRpb25TdHJ1Y3R1cmUgPSB0aGlzLnRyYXZlcnNlU3RydWN0dXJlRm9yRGVzZXJpYWxpc2F0aW9uKF9zZXJpYWxpemF0aW9uLmFuaW1hdGlvblN0cnVjdHVyZSk7XHJcblxyXG4gICAgICB0aGlzLmFuaW1hdGlvblN0cnVjdHVyZXNQcm9jZXNzZWQgPSBuZXcgTWFwPEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRSwgQW5pbWF0aW9uU3RydWN0dXJlPigpO1xyXG5cclxuICAgICAgdGhpcy5jYWxjdWxhdGVUb3RhbFRpbWUoKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplKCk7XHJcbiAgICB9XHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICBkZWxldGUgX211dGF0b3IudG90YWxUaW1lO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmF2ZXJzZXMgYW4gQW5pbWF0aW9uU3RydWN0dXJlIGFuZCByZXR1cm5zIHRoZSBTZXJpYWxpemF0aW9uIG9mIHNhaWQgU3RydWN0dXJlLlxyXG4gICAgICogQHBhcmFtIF9zdHJ1Y3R1cmUgVGhlIEFuaW1hdGlvbiBTdHJ1Y3R1cmUgYXQgdGhlIGN1cnJlbnQgbGV2ZWwgdG8gdHJhbnNmb3JtIGludG8gdGhlIFNlcmlhbGl6YXRpb24uXHJcbiAgICAgKiBAcmV0dXJucyB0aGUgZmlsbGVkIFNlcmlhbGl6YXRpb24uXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdHJhdmVyc2VTdHJ1Y3R1cmVGb3JTZXJpYWxpc2F0aW9uKF9zdHJ1Y3R1cmU6IEFuaW1hdGlvblN0cnVjdHVyZSk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgbmV3U2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHt9O1xyXG4gICAgICBmb3IgKGxldCBuIGluIF9zdHJ1Y3R1cmUpIHtcclxuICAgICAgICBpZiAoX3N0cnVjdHVyZVtuXSBpbnN0YW5jZW9mIEFuaW1hdGlvblNlcXVlbmNlKSB7XHJcbiAgICAgICAgICBuZXdTZXJpYWxpemF0aW9uW25dID0gX3N0cnVjdHVyZVtuXS5zZXJpYWxpemUoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbmV3U2VyaWFsaXphdGlvbltuXSA9IHRoaXMudHJhdmVyc2VTdHJ1Y3R1cmVGb3JTZXJpYWxpc2F0aW9uKDxBbmltYXRpb25TdHJ1Y3R1cmU+X3N0cnVjdHVyZVtuXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBuZXdTZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmF2ZXJzZXMgYSBTZXJpYWxpemF0aW9uIHRvIGNyZWF0ZSBhIG5ldyBBbmltYXRpb25TdHJ1Y3R1cmUuXHJcbiAgICAgKiBAcGFyYW0gX3NlcmlhbGl6YXRpb24gVGhlIHNlcmlhbGl6YXRpb24gdG8gdHJhbnNmZXIgaW50byBhbiBBbmltYXRpb25TdHJ1Y3R1cmVcclxuICAgICAqIEByZXR1cm5zIHRoZSBuZXdseSBjcmVhdGVkIEFuaW1hdGlvblN0cnVjdHVyZS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSB0cmF2ZXJzZVN0cnVjdHVyZUZvckRlc2VyaWFsaXNhdGlvbihfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IEFuaW1hdGlvblN0cnVjdHVyZSB7XHJcbiAgICAgIGxldCBuZXdTdHJ1Y3R1cmU6IEFuaW1hdGlvblN0cnVjdHVyZSA9IHt9O1xyXG4gICAgICBmb3IgKGxldCBuIGluIF9zZXJpYWxpemF0aW9uKSB7XHJcbiAgICAgICAgaWYgKF9zZXJpYWxpemF0aW9uW25dLmFuaW1hdGlvblNlcXVlbmNlKSB7XHJcbiAgICAgICAgICBsZXQgYW5pbVNlcTogQW5pbWF0aW9uU2VxdWVuY2UgPSBuZXcgQW5pbWF0aW9uU2VxdWVuY2UoKTtcclxuICAgICAgICAgIG5ld1N0cnVjdHVyZVtuXSA9IGFuaW1TZXEuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bbl0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuZXdTdHJ1Y3R1cmVbbl0gPSB0aGlzLnRyYXZlcnNlU3RydWN0dXJlRm9yRGVzZXJpYWxpc2F0aW9uKF9zZXJpYWxpemF0aW9uW25dKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG5ld1N0cnVjdHVyZTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmluZHMgdGhlIGxpc3Qgb2YgZXZlbnRzIHRvIGJlIHVzZWQgd2l0aCB0aGVzZSBzZXR0aW5ncy5cclxuICAgICAqIEBwYXJhbSBfZGlyZWN0aW9uIFRoZSBkaXJlY3Rpb24gdGhlIGFuaW1hdGlvbiBpcyBwbGF5aW5nIGluLlxyXG4gICAgICogQHBhcmFtIF9wbGF5YmFjayBUaGUgcGxheWJhY2ttb2RlIHRoZSBhbmltYXRpb24gaXMgcGxheWluZyBpbi5cclxuICAgICAqIEByZXR1cm5zIFRoZSBjb3JyZWN0IEFuaW1hdGlvbkV2ZW50VHJpZ2dlciBPYmplY3QgdG8gdXNlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZ2V0Q29ycmVjdEV2ZW50TGlzdChfZGlyZWN0aW9uOiBudW1iZXIsIF9wbGF5YmFjazogQU5JTUFUSU9OX1BMQVlCQUNLKTogQW5pbWF0aW9uRXZlbnRUcmlnZ2VyIHtcclxuICAgICAgaWYgKF9wbGF5YmFjayAhPSBBTklNQVRJT05fUExBWUJBQ0suRlJBTUVCQVNFRCkge1xyXG4gICAgICAgIGlmIChfZGlyZWN0aW9uID49IDApIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLmdldFByb2Nlc3NlZEV2ZW50VHJpZ2dlcihBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuTk9STUFMKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJvY2Vzc2VkRXZlbnRUcmlnZ2VyKEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5SRVZFUlNFKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKF9kaXJlY3Rpb24gPj0gMCkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJvY2Vzc2VkRXZlbnRUcmlnZ2VyKEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5SQVNURVJFRCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLmdldFByb2Nlc3NlZEV2ZW50VHJpZ2dlcihBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuUkFTVEVSRURSRVZFUlNFKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYXZlcnNlcyBhbiBBbmltYXRpb25TdHJ1Y3R1cmUgdG8gdHVybiBpdCBpbnRvIHRoZSBcIk11dGF0b3JcIiB0byByZXR1cm4gdG8gdGhlIENvbXBvbmVudC5cclxuICAgICAqIEBwYXJhbSBfc3RydWN0dXJlIFRoZSBzdHJjdXR1cmUgdG8gdHJhdmVyc2VcclxuICAgICAqIEBwYXJhbSBfdGltZSB0aGUgcG9pbnQgaW4gdGltZSB0byB3cml0ZSB0aGUgYW5pbWF0aW9uIG51bWJlcnMgaW50by5cclxuICAgICAqIEByZXR1cm5zIFRoZSBcIk11dGF0b3JcIiBmaWxsZWQgd2l0aCB0aGUgY29ycmVjdCB2YWx1ZXMgYXQgdGhlIGdpdmVuIHRpbWUuIFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHRyYXZlcnNlU3RydWN0dXJlRm9yTXV0YXRvcihfc3RydWN0dXJlOiBBbmltYXRpb25TdHJ1Y3R1cmUsIF90aW1lOiBudW1iZXIpOiBNdXRhdG9yIHtcclxuICAgICAgbGV0IG5ld011dGF0b3I6IE11dGF0b3IgPSB7fTtcclxuICAgICAgZm9yIChsZXQgbiBpbiBfc3RydWN0dXJlKSB7XHJcbiAgICAgICAgaWYgKF9zdHJ1Y3R1cmVbbl0gaW5zdGFuY2VvZiBBbmltYXRpb25TZXF1ZW5jZSkge1xyXG4gICAgICAgICAgbmV3TXV0YXRvcltuXSA9ICg8QW5pbWF0aW9uU2VxdWVuY2U+X3N0cnVjdHVyZVtuXSkuZXZhbHVhdGUoX3RpbWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuZXdNdXRhdG9yW25dID0gdGhpcy50cmF2ZXJzZVN0cnVjdHVyZUZvck11dGF0b3IoPEFuaW1hdGlvblN0cnVjdHVyZT5fc3RydWN0dXJlW25dLCBfdGltZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBuZXdNdXRhdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhdmVyc2VzIHRoZSBjdXJyZW50IEFuaW1hdGlvblN0cmN1dHVyZSB0byBmaW5kIHRoZSB0b3RhbFRpbWUgb2YgdGhpcyBhbmltYXRpb24uXHJcbiAgICAgKiBAcGFyYW0gX3N0cnVjdHVyZSBUaGUgc3RydWN0dXJlIHRvIHRyYXZlcnNlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdHJhdmVyc2VTdHJ1Y3R1cmVGb3JUaW1lKF9zdHJ1Y3R1cmU6IEFuaW1hdGlvblN0cnVjdHVyZSk6IHZvaWQge1xyXG4gICAgICBmb3IgKGxldCBuIGluIF9zdHJ1Y3R1cmUpIHtcclxuICAgICAgICBpZiAoX3N0cnVjdHVyZVtuXSBpbnN0YW5jZW9mIEFuaW1hdGlvblNlcXVlbmNlKSB7XHJcbiAgICAgICAgICBsZXQgc2VxdWVuY2U6IEFuaW1hdGlvblNlcXVlbmNlID0gPEFuaW1hdGlvblNlcXVlbmNlPl9zdHJ1Y3R1cmVbbl07XHJcbiAgICAgICAgICBpZiAoc2VxdWVuY2UubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBsZXQgc2VxdWVuY2VUaW1lOiBudW1iZXIgPSBzZXF1ZW5jZS5nZXRLZXkoc2VxdWVuY2UubGVuZ3RoIC0gMSkuVGltZTtcclxuICAgICAgICAgICAgdGhpcy50b3RhbFRpbWUgPSBzZXF1ZW5jZVRpbWUgPiB0aGlzLnRvdGFsVGltZSA/IHNlcXVlbmNlVGltZSA6IHRoaXMudG90YWxUaW1lO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLnRyYXZlcnNlU3RydWN0dXJlRm9yVGltZSg8QW5pbWF0aW9uU3RydWN0dXJlPl9zdHJ1Y3R1cmVbbl0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRW5zdXJlcyB0aGUgZXhpc3RhbmNlIG9mIHRoZSByZXF1ZXN0ZWQgW1tBbmltYXRpb25TdHJjdXR1cmVdXSBhbmQgcmV0dXJucyBpdC5cclxuICAgICAqIEBwYXJhbSBfdHlwZSB0aGUgdHlwZSBvZiB0aGUgc3RydWN0dXJlIHRvIGdldFxyXG4gICAgICogQHJldHVybnMgdGhlIHJlcXVlc3RlZCBbW0FuaW1hdGlvblN0cnVjdHVyZV1dXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZ2V0UHJvY2Vzc2VkQW5pbWF0aW9uU3RydWN0dXJlKF90eXBlOiBBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUpOiBBbmltYXRpb25TdHJ1Y3R1cmUge1xyXG4gICAgICBpZiAoIXRoaXMuYW5pbWF0aW9uU3RydWN0dXJlc1Byb2Nlc3NlZC5oYXMoX3R5cGUpKSB7XHJcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVUb3RhbFRpbWUoKTtcclxuICAgICAgICBsZXQgYWU6IEFuaW1hdGlvblN0cnVjdHVyZSA9IHt9O1xyXG4gICAgICAgIHN3aXRjaCAoX3R5cGUpIHtcclxuICAgICAgICAgIGNhc2UgQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLk5PUk1BTDpcclxuICAgICAgICAgICAgYWUgPSB0aGlzLmFuaW1hdGlvblN0cnVjdHVyZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5SRVZFUlNFOlxyXG4gICAgICAgICAgICBhZSA9IHRoaXMudHJhdmVyc2VTdHJ1Y3R1cmVGb3JOZXdTdHJ1Y3R1cmUodGhpcy5hbmltYXRpb25TdHJ1Y3R1cmUsIHRoaXMuY2FsY3VsYXRlUmV2ZXJzZVNlcXVlbmNlLmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlJBU1RFUkVEOlxyXG4gICAgICAgICAgICBhZSA9IHRoaXMudHJhdmVyc2VTdHJ1Y3R1cmVGb3JOZXdTdHJ1Y3R1cmUodGhpcy5hbmltYXRpb25TdHJ1Y3R1cmUsIHRoaXMuY2FsY3VsYXRlUmFzdGVyZWRTZXF1ZW5jZS5iaW5kKHRoaXMpKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5SQVNURVJFRFJFVkVSU0U6XHJcbiAgICAgICAgICAgIGFlID0gdGhpcy50cmF2ZXJzZVN0cnVjdHVyZUZvck5ld1N0cnVjdHVyZSh0aGlzLmdldFByb2Nlc3NlZEFuaW1hdGlvblN0cnVjdHVyZShBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuUkVWRVJTRSksIHRoaXMuY2FsY3VsYXRlUmFzdGVyZWRTZXF1ZW5jZS5iaW5kKHRoaXMpKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3RydWN0dXJlc1Byb2Nlc3NlZC5zZXQoX3R5cGUsIGFlKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy5hbmltYXRpb25TdHJ1Y3R1cmVzUHJvY2Vzc2VkLmdldChfdHlwZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbnN1cmVzIHRoZSBleGlzdGFuY2Ugb2YgdGhlIHJlcXVlc3RlZCBbW0FuaW1hdGlvbkV2ZW50VHJpZ2dlcl1dIGFuZCByZXR1cm5zIGl0LlxyXG4gICAgICogQHBhcmFtIF90eXBlIFRoZSB0eXBlIG9mIEFuaW1hdGlvbkV2ZW50VHJpZ2dlciB0byBnZXRcclxuICAgICAqIEByZXR1cm5zIHRoZSByZXF1ZXN0ZWQgW1tBbmltYXRpb25FdmVudFRyaWdnZXJdXVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGdldFByb2Nlc3NlZEV2ZW50VHJpZ2dlcihfdHlwZTogQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFKTogQW5pbWF0aW9uRXZlbnRUcmlnZ2VyIHtcclxuICAgICAgaWYgKCF0aGlzLmV2ZW50c1Byb2Nlc3NlZC5oYXMoX3R5cGUpKSB7XHJcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVUb3RhbFRpbWUoKTtcclxuICAgICAgICBsZXQgZXY6IEFuaW1hdGlvbkV2ZW50VHJpZ2dlciA9IHt9O1xyXG4gICAgICAgIHN3aXRjaCAoX3R5cGUpIHtcclxuICAgICAgICAgIGNhc2UgQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLk5PUk1BTDpcclxuICAgICAgICAgICAgZXYgPSB0aGlzLmV2ZW50cztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5SRVZFUlNFOlxyXG4gICAgICAgICAgICBldiA9IHRoaXMuY2FsY3VsYXRlUmV2ZXJzZUV2ZW50VHJpZ2dlcnModGhpcy5ldmVudHMpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlJBU1RFUkVEOlxyXG4gICAgICAgICAgICBldiA9IHRoaXMuY2FsY3VsYXRlUmFzdGVyZWRFdmVudFRyaWdnZXJzKHRoaXMuZXZlbnRzKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5SQVNURVJFRFJFVkVSU0U6XHJcbiAgICAgICAgICAgIGV2ID0gdGhpcy5jYWxjdWxhdGVSYXN0ZXJlZEV2ZW50VHJpZ2dlcnModGhpcy5nZXRQcm9jZXNzZWRFdmVudFRyaWdnZXIoQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlJFVkVSU0UpKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZXZlbnRzUHJvY2Vzc2VkLnNldChfdHlwZSwgZXYpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLmV2ZW50c1Byb2Nlc3NlZC5nZXQoX3R5cGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhdmVyc2VzIGFuIGV4aXN0aW5nIHN0cnVjdHVyZSB0byBhcHBseSBhIHJlY2FsY3VsYXRpb24gZnVuY3Rpb24gdG8gdGhlIEFuaW1hdGlvblN0cnVjdHVyZSB0byBzdG9yZSBpbiBhIG5ldyBTdHJ1Y3R1cmUuXHJcbiAgICAgKiBAcGFyYW0gX29sZFN0cnVjdHVyZSBUaGUgb2xkIHN0cnVjdHVyZSB0byB0cmF2ZXJzZVxyXG4gICAgICogQHBhcmFtIF9mdW5jdGlvblRvVXNlIFRoZSBmdW5jdGlvbiB0byB1c2UgdG8gcmVjYWxjdWxhdGVkIHRoZSBzdHJ1Y3R1cmUuXHJcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBBbmltYXRpb24gU3RydWN0dXJlIHdpdGggdGhlIHJlY2FsdWxhdGVkIEFuaW1hdGlvbiBTZXF1ZW5jZXMuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdHJhdmVyc2VTdHJ1Y3R1cmVGb3JOZXdTdHJ1Y3R1cmUoX29sZFN0cnVjdHVyZTogQW5pbWF0aW9uU3RydWN0dXJlLCBfZnVuY3Rpb25Ub1VzZTogRnVuY3Rpb24pOiBBbmltYXRpb25TdHJ1Y3R1cmUge1xyXG4gICAgICBsZXQgbmV3U3RydWN0dXJlOiBBbmltYXRpb25TdHJ1Y3R1cmUgPSB7fTtcclxuICAgICAgZm9yIChsZXQgbiBpbiBfb2xkU3RydWN0dXJlKSB7XHJcbiAgICAgICAgaWYgKF9vbGRTdHJ1Y3R1cmVbbl0gaW5zdGFuY2VvZiBBbmltYXRpb25TZXF1ZW5jZSkge1xyXG4gICAgICAgICAgbmV3U3RydWN0dXJlW25dID0gX2Z1bmN0aW9uVG9Vc2UoX29sZFN0cnVjdHVyZVtuXSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG5ld1N0cnVjdHVyZVtuXSA9IHRoaXMudHJhdmVyc2VTdHJ1Y3R1cmVGb3JOZXdTdHJ1Y3R1cmUoPEFuaW1hdGlvblN0cnVjdHVyZT5fb2xkU3RydWN0dXJlW25dLCBfZnVuY3Rpb25Ub1VzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBuZXdTdHJ1Y3R1cmU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgcmV2ZXJzZWQgQW5pbWF0aW9uIFNlcXVlbmNlIG91dCBvZiBhIGdpdmVuIFNlcXVlbmNlLlxyXG4gICAgICogQHBhcmFtIF9zZXF1ZW5jZSBUaGUgc2VxdWVuY2UgdG8gY2FsY3VsYXRlIHRoZSBuZXcgc2VxdWVuY2Ugb3V0IG9mXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgcmV2ZXJzZWQgU2VxdWVuY2VcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjYWxjdWxhdGVSZXZlcnNlU2VxdWVuY2UoX3NlcXVlbmNlOiBBbmltYXRpb25TZXF1ZW5jZSk6IEFuaW1hdGlvblNlcXVlbmNlIHtcclxuICAgICAgbGV0IHNlcTogQW5pbWF0aW9uU2VxdWVuY2UgPSBuZXcgQW5pbWF0aW9uU2VxdWVuY2UoKTtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IF9zZXF1ZW5jZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCBvbGRLZXk6IEFuaW1hdGlvbktleSA9IF9zZXF1ZW5jZS5nZXRLZXkoaSk7XHJcbiAgICAgICAgbGV0IGtleTogQW5pbWF0aW9uS2V5ID0gbmV3IEFuaW1hdGlvbktleSh0aGlzLnRvdGFsVGltZSAtIG9sZEtleS5UaW1lLCBvbGRLZXkuVmFsdWUsIG9sZEtleS5TbG9wZU91dCwgb2xkS2V5LlNsb3BlSW4sIG9sZEtleS5Db25zdGFudCk7XHJcbiAgICAgICAgc2VxLmFkZEtleShrZXkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBzZXE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgcmFzdGVyZWQgW1tBbmltYXRpb25TZXF1ZW5jZV1dIG91dCBvZiBhIGdpdmVuIHNlcXVlbmNlLlxyXG4gICAgICogQHBhcmFtIF9zZXF1ZW5jZSBUaGUgc2VxdWVuY2UgdG8gY2FsY3VsYXRlIHRoZSBuZXcgc2VxdWVuY2Ugb3V0IG9mXHJcbiAgICAgKiBAcmV0dXJucyB0aGUgcmFzdGVyZWQgc2VxdWVuY2UuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY2FsY3VsYXRlUmFzdGVyZWRTZXF1ZW5jZShfc2VxdWVuY2U6IEFuaW1hdGlvblNlcXVlbmNlKTogQW5pbWF0aW9uU2VxdWVuY2Uge1xyXG4gICAgICBsZXQgc2VxOiBBbmltYXRpb25TZXF1ZW5jZSA9IG5ldyBBbmltYXRpb25TZXF1ZW5jZSgpO1xyXG4gICAgICBsZXQgZnJhbWVUaW1lOiBudW1iZXIgPSAxMDAwIC8gdGhpcy5mcmFtZXNQZXJTZWNvbmQ7XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLnRvdGFsVGltZTsgaSArPSBmcmFtZVRpbWUpIHtcclxuICAgICAgICBsZXQga2V5OiBBbmltYXRpb25LZXkgPSBuZXcgQW5pbWF0aW9uS2V5KGksIF9zZXF1ZW5jZS5ldmFsdWF0ZShpKSwgMCwgMCwgdHJ1ZSk7XHJcbiAgICAgICAgc2VxLmFkZEtleShrZXkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBzZXE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHJldmVyc2VkIFtbQW5pbWF0aW9uRXZlbnRUcmlnZ2VyXV0gb2JqZWN0IGJhc2VkIG9uIHRoZSBnaXZlbiBvbmUuICBcclxuICAgICAqIEBwYXJhbSBfZXZlbnRzIHRoZSBldmVudCBvYmplY3QgdG8gY2FsY3VsYXRlIHRoZSBuZXcgb25lIG91dCBvZlxyXG4gICAgICogQHJldHVybnMgdGhlIHJldmVyc2VkIGV2ZW50IG9iamVjdFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNhbGN1bGF0ZVJldmVyc2VFdmVudFRyaWdnZXJzKF9ldmVudHM6IEFuaW1hdGlvbkV2ZW50VHJpZ2dlcik6IEFuaW1hdGlvbkV2ZW50VHJpZ2dlciB7XHJcbiAgICAgIGxldCBhZTogQW5pbWF0aW9uRXZlbnRUcmlnZ2VyID0ge307XHJcbiAgICAgIGZvciAobGV0IG5hbWUgaW4gX2V2ZW50cykge1xyXG4gICAgICAgIGFlW25hbWVdID0gdGhpcy50b3RhbFRpbWUgLSBfZXZlbnRzW25hbWVdO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBhZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgcmFzdGVyZWQgW1tBbmltYXRpb25FdmVudFRyaWdnZXJdXSBvYmplY3QgYmFzZWQgb24gdGhlIGdpdmVuIG9uZS4gIFxyXG4gICAgICogQHBhcmFtIF9ldmVudHMgdGhlIGV2ZW50IG9iamVjdCB0byBjYWxjdWxhdGUgdGhlIG5ldyBvbmUgb3V0IG9mXHJcbiAgICAgKiBAcmV0dXJucyB0aGUgcmFzdGVyZWQgZXZlbnQgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY2FsY3VsYXRlUmFzdGVyZWRFdmVudFRyaWdnZXJzKF9ldmVudHM6IEFuaW1hdGlvbkV2ZW50VHJpZ2dlcik6IEFuaW1hdGlvbkV2ZW50VHJpZ2dlciB7XHJcbiAgICAgIGxldCBhZTogQW5pbWF0aW9uRXZlbnRUcmlnZ2VyID0ge307XHJcbiAgICAgIGxldCBmcmFtZVRpbWU6IG51bWJlciA9IDEwMDAgLyB0aGlzLmZyYW1lc1BlclNlY29uZDtcclxuICAgICAgZm9yIChsZXQgbmFtZSBpbiBfZXZlbnRzKSB7XHJcbiAgICAgICAgYWVbbmFtZV0gPSBfZXZlbnRzW25hbWVdIC0gKF9ldmVudHNbbmFtZV0gJSBmcmFtZVRpbWUpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBhZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3Mgd2hpY2ggZXZlbnRzIGxheSBiZXR3ZWVuIHR3byBnaXZlbiB0aW1lcyBhbmQgcmV0dXJucyB0aGUgbmFtZXMgb2YgdGhlIG9uZXMgdGhhdCBkby5cclxuICAgICAqIEBwYXJhbSBfZXZlbnRUcmlnZ2VycyBUaGUgZXZlbnQgb2JqZWN0IHRvIGNoZWNrIHRoZSBldmVudHMgaW5zaWRlIG9mXHJcbiAgICAgKiBAcGFyYW0gX21pbiB0aGUgbWluaW11bSBvZiB0aGUgcmFuZ2UgdG8gY2hlY2sgYmV0d2VlbiAoaW5jbHVzaXZlKVxyXG4gICAgICogQHBhcmFtIF9tYXggdGhlIG1heGltdW0gb2YgdGhlIHJhbmdlIHRvIGNoZWNrIGJldHdlZW4gKGV4Y2x1c2l2ZSlcclxuICAgICAqIEByZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBuYW1lcyBvZiB0aGUgZXZlbnRzIGluIHRoZSBnaXZlbiByYW5nZS4gXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY2hlY2tFdmVudHNCZXR3ZWVuKF9ldmVudFRyaWdnZXJzOiBBbmltYXRpb25FdmVudFRyaWdnZXIsIF9taW46IG51bWJlciwgX21heDogbnVtYmVyKTogc3RyaW5nW10ge1xyXG4gICAgICBsZXQgZXZlbnRzVG9UcmlnZ2VyOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgICBmb3IgKGxldCBuYW1lIGluIF9ldmVudFRyaWdnZXJzKSB7XHJcbiAgICAgICAgaWYgKF9taW4gPD0gX2V2ZW50VHJpZ2dlcnNbbmFtZV0gJiYgX2V2ZW50VHJpZ2dlcnNbbmFtZV0gPCBfbWF4KSB7XHJcbiAgICAgICAgICBldmVudHNUb1RyaWdnZXIucHVzaChuYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGV2ZW50c1RvVHJpZ2dlcjtcclxuICAgIH1cclxuICB9XHJcbn0iLCIvLyAvIDxyZWZlcmVuY2UgcGF0aD1cIi4uL1RyYW5zZmVyL1NlcmlhbGl6ZXIudHNcIi8+XHJcbi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vVHJhbnNmZXIvTXV0YWJsZS50c1wiLz5cclxuXHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZXMgdGhlIHZhbHVlcyBiZXR3ZWVuIFtbQW5pbWF0aW9uS2V5XV1zLlxyXG4gICAqIFJlcHJlc2VudGVkIGludGVybmFsbHkgYnkgYSBjdWJpYyBmdW5jdGlvbiAoYGYoeCkgPSBheMKzICsgYnjCsiArIGN4ICsgZGApLiBcclxuICAgKiBPbmx5IG5lZWRzIHRvIGJlIHJlY2FsY3VsYXRlZCB3aGVuIHRoZSBrZXlzIGNoYW5nZSwgc28gYXQgcnVudGltZSBpdCBzaG91bGQgb25seSBiZSBjYWxjdWxhdGVkIG9uY2UuXHJcbiAgICogQGF1dGhvciBMdWthcyBTY2hldWVybGUsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBBbmltYXRpb25GdW5jdGlvbiB7XHJcbiAgICBwcml2YXRlIGE6IG51bWJlciA9IDA7XHJcbiAgICBwcml2YXRlIGI6IG51bWJlciA9IDA7XHJcbiAgICBwcml2YXRlIGM6IG51bWJlciA9IDA7XHJcbiAgICBwcml2YXRlIGQ6IG51bWJlciA9IDA7XHJcbiAgICBwcml2YXRlIGtleUluOiBBbmltYXRpb25LZXk7XHJcbiAgICBwcml2YXRlIGtleU91dDogQW5pbWF0aW9uS2V5O1xyXG5cclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihfa2V5SW46IEFuaW1hdGlvbktleSwgX2tleU91dDogQW5pbWF0aW9uS2V5ID0gbnVsbCkge1xyXG4gICAgICB0aGlzLmtleUluID0gX2tleUluO1xyXG4gICAgICB0aGlzLmtleU91dCA9IF9rZXlPdXQ7XHJcbiAgICAgIHRoaXMuY2FsY3VsYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gYXQgdGhlIGdpdmVuIHRpbWUuXHJcbiAgICAgKiBAcGFyYW0gX3RpbWUgdGhlIHBvaW50IGluIHRpbWUgYXQgd2hpY2ggdG8gZXZhbHVhdGUgdGhlIGZ1bmN0aW9uIGluIG1pbGxpc2Vjb25kcy4gV2lsbCBiZSBjb3JyZWN0ZWQgZm9yIG9mZnNldCBpbnRlcm5hbGx5LlxyXG4gICAgICogQHJldHVybnMgdGhlIHZhbHVlIGF0IHRoZSBnaXZlbiB0aW1lXHJcbiAgICAgKi9cclxuICAgIGV2YWx1YXRlKF90aW1lOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICBfdGltZSAtPSB0aGlzLmtleUluLlRpbWU7XHJcbiAgICAgIGxldCB0aW1lMjogbnVtYmVyID0gX3RpbWUgKiBfdGltZTtcclxuICAgICAgbGV0IHRpbWUzOiBudW1iZXIgPSB0aW1lMiAqIF90aW1lO1xyXG4gICAgICByZXR1cm4gdGhpcy5hICogdGltZTMgKyB0aGlzLmIgKiB0aW1lMiArIHRoaXMuYyAqIF90aW1lICsgdGhpcy5kO1xyXG4gICAgfVxyXG5cclxuICAgIHNldCBzZXRLZXlJbihfa2V5SW46IEFuaW1hdGlvbktleSkge1xyXG4gICAgICB0aGlzLmtleUluID0gX2tleUluO1xyXG4gICAgICB0aGlzLmNhbGN1bGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldCBzZXRLZXlPdXQoX2tleU91dDogQW5pbWF0aW9uS2V5KSB7XHJcbiAgICAgIHRoaXMua2V5T3V0ID0gX2tleU91dDtcclxuICAgICAgdGhpcy5jYWxjdWxhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIChSZS0pQ2FsY3VsYXRlcyB0aGUgcGFyYW1ldGVycyBvZiB0aGUgY3ViaWMgZnVuY3Rpb24uXHJcbiAgICAgKiBTZWUgaHR0cHM6Ly9tYXRoLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy8zMTczNDY5L2NhbGN1bGF0ZS1jdWJpYy1lcXVhdGlvbi1mcm9tLXR3by1wb2ludHMtYW5kLXR3by1zbG9wZXMtdmFyaWFibHlcclxuICAgICAqIGFuZCBodHRwczovL2ppcmthZGVsbG9yby5naXRodWIuaW8vRlVER0UvRG9jdW1lbnRhdGlvbi9Mb2dzLzE5MDQxMF9Ob3RpemVuX0xTXHJcbiAgICAgKi9cclxuICAgIGNhbGN1bGF0ZSgpOiB2b2lkIHtcclxuICAgICAgaWYgKCF0aGlzLmtleUluKSB7XHJcbiAgICAgICAgdGhpcy5kID0gdGhpcy5jID0gdGhpcy5iID0gdGhpcy5hID0gMDtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCF0aGlzLmtleU91dCB8fCB0aGlzLmtleUluLkNvbnN0YW50KSB7XHJcbiAgICAgICAgdGhpcy5kID0gdGhpcy5rZXlJbi5WYWx1ZTtcclxuICAgICAgICB0aGlzLmMgPSB0aGlzLmIgPSB0aGlzLmEgPSAwO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IHgxOiBudW1iZXIgPSB0aGlzLmtleU91dC5UaW1lIC0gdGhpcy5rZXlJbi5UaW1lO1xyXG5cclxuICAgICAgdGhpcy5kID0gdGhpcy5rZXlJbi5WYWx1ZTtcclxuICAgICAgdGhpcy5jID0gdGhpcy5rZXlJbi5TbG9wZU91dDtcclxuXHJcbiAgICAgIHRoaXMuYSA9ICgteDEgKiAodGhpcy5rZXlJbi5TbG9wZU91dCArIHRoaXMua2V5T3V0LlNsb3BlSW4pIC0gMiAqIHRoaXMua2V5SW4uVmFsdWUgKyAyICogdGhpcy5rZXlPdXQuVmFsdWUpIC8gLU1hdGgucG93KHgxLCAzKTtcclxuICAgICAgdGhpcy5iID0gKHRoaXMua2V5T3V0LlNsb3BlSW4gLSB0aGlzLmtleUluLlNsb3BlT3V0IC0gMyAqIHRoaXMuYSAqIE1hdGgucG93KHgxLCAyKSkgLyAoMiAqIHgxKTtcclxuICAgIH1cclxuICB9XHJcblxyXG59IiwiLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9UcmFuc2Zlci9TZXJpYWxpemVyLnRzXCIvPlxyXG4vLyAvIDxyZWZlcmVuY2UgcGF0aD1cIi4uL1RyYW5zZmVyL011dGFibGUudHNcIi8+XHJcblxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBIb2xkcyBpbmZvcm1hdGlvbiBhYm91dCBzZXQgcG9pbnRzIGluIHRpbWUsIHRoZWlyIGFjY29tcGFueWluZyB2YWx1ZXMgYXMgd2VsbCBhcyB0aGVpciBzbG9wZXMuIFxyXG4gICAqIEFsc28gaG9sZHMgYSByZWZlcmVuY2UgdG8gdGhlIFtbQW5pbWF0aW9uRnVuY3Rpb25dXXMgdGhhdCBjb21lIGluIGFuZCBvdXQgb2YgdGhlIHNpZGVzLiBUaGUgW1tBbmltYXRpb25GdW5jdGlvbl1dcyBhcmUgaGFuZGxlZCBieSB0aGUgW1tBbmltYXRpb25TZXF1ZW5jZV1dcy5cclxuICAgKiBTYXZlZCBpbnNpZGUgYW4gW1tBbmltYXRpb25TZXF1ZW5jZV1dLlxyXG4gICAqIEBhdXRob3IgTHVrYXMgU2NoZXVlcmxlLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQW5pbWF0aW9uS2V5IGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZSB7XHJcbiAgICAvLyBUT0RPOiBjaGVjayBpZiBmdW5jdGlvbkluIGNhbiBiZSByZW1vdmVkXHJcbiAgICAvKipEb24ndCBtb2RpZnkgdGhpcyB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmcuKi9cclxuICAgIGZ1bmN0aW9uSW46IEFuaW1hdGlvbkZ1bmN0aW9uO1xyXG4gICAgLyoqRG9uJ3QgbW9kaWZ5IHRoaXMgdW5sZXNzIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nLiovXHJcbiAgICBmdW5jdGlvbk91dDogQW5pbWF0aW9uRnVuY3Rpb247XHJcbiAgICBcclxuICAgIGJyb2tlbjogYm9vbGVhbjtcclxuXHJcbiAgICBwcml2YXRlIHRpbWU6IG51bWJlcjtcclxuICAgIHByaXZhdGUgdmFsdWU6IG51bWJlcjtcclxuICAgIHByaXZhdGUgY29uc3RhbnQ6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICBwcml2YXRlIHNsb3BlSW46IG51bWJlciA9IDA7XHJcbiAgICBwcml2YXRlIHNsb3BlT3V0OiBudW1iZXIgPSAwO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKF90aW1lOiBudW1iZXIgPSAwLCBfdmFsdWU6IG51bWJlciA9IDAsIF9zbG9wZUluOiBudW1iZXIgPSAwLCBfc2xvcGVPdXQ6IG51bWJlciA9IDAsIF9jb25zdGFudDogYm9vbGVhbiA9IGZhbHNlKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMudGltZSA9IF90aW1lO1xyXG4gICAgICB0aGlzLnZhbHVlID0gX3ZhbHVlO1xyXG4gICAgICB0aGlzLnNsb3BlSW4gPSBfc2xvcGVJbjtcclxuICAgICAgdGhpcy5zbG9wZU91dCA9IF9zbG9wZU91dDtcclxuICAgICAgdGhpcy5jb25zdGFudCA9IF9jb25zdGFudDtcclxuXHJcbiAgICAgIHRoaXMuYnJva2VuID0gdGhpcy5zbG9wZUluICE9IC10aGlzLnNsb3BlT3V0O1xyXG4gICAgICB0aGlzLmZ1bmN0aW9uT3V0ID0gbmV3IEFuaW1hdGlvbkZ1bmN0aW9uKHRoaXMsIG51bGwpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBUaW1lKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLnRpbWU7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IFRpbWUoX3RpbWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLnRpbWUgPSBfdGltZTtcclxuICAgICAgdGhpcy5mdW5jdGlvbkluLmNhbGN1bGF0ZSgpO1xyXG4gICAgICB0aGlzLmZ1bmN0aW9uT3V0LmNhbGN1bGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBWYWx1ZSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy52YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgVmFsdWUoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy52YWx1ZSA9IF92YWx1ZTtcclxuICAgICAgdGhpcy5mdW5jdGlvbkluLmNhbGN1bGF0ZSgpO1xyXG4gICAgICB0aGlzLmZ1bmN0aW9uT3V0LmNhbGN1bGF0ZSgpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBnZXQgQ29uc3RhbnQoKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0YW50O1xyXG4gICAgfVxyXG5cclxuICAgIHNldCBDb25zdGFudChfY29uc3RhbnQ6IGJvb2xlYW4pIHtcclxuICAgICAgdGhpcy5jb25zdGFudCA9IF9jb25zdGFudDtcclxuICAgICAgdGhpcy5mdW5jdGlvbkluLmNhbGN1bGF0ZSgpO1xyXG4gICAgICB0aGlzLmZ1bmN0aW9uT3V0LmNhbGN1bGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBTbG9wZUluKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNsb3BlSW47XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHNldCBTbG9wZUluKF9zbG9wZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuc2xvcGVJbiA9IF9zbG9wZTtcclxuICAgICAgdGhpcy5mdW5jdGlvbkluLmNhbGN1bGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBTbG9wZU91dCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5zbG9wZU91dDtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgU2xvcGVPdXQoX3Nsb3BlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5zbG9wZU91dCA9IF9zbG9wZTtcclxuICAgICAgdGhpcy5mdW5jdGlvbk91dC5jYWxjdWxhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0YXRpYyBjb21wYXJhdGlvbiBmdW5jdGlvbiB0byB1c2UgaW4gYW4gYXJyYXkgc29ydCBmdW5jdGlvbiB0byBzb3J0IHRoZSBrZXlzIGJ5IHRoZWlyIHRpbWUuXHJcbiAgICAgKiBAcGFyYW0gX2EgdGhlIGFuaW1hdGlvbiBrZXkgdG8gY2hlY2tcclxuICAgICAqIEBwYXJhbSBfYiB0aGUgYW5pbWF0aW9uIGtleSB0byBjaGVjayBhZ2FpbnN0XHJcbiAgICAgKiBAcmV0dXJucyA+MCBpZiBhPmIsIDAgaWYgYT1iLCA8MCBpZiBhPGJcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNvbXBhcmUoX2E6IEFuaW1hdGlvbktleSwgX2I6IEFuaW1hdGlvbktleSk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiBfYS50aW1lIC0gX2IudGltZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gdHJhbnNmZXJcclxuICAgIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHM6IFNlcmlhbGl6YXRpb24gPSB7fTtcclxuICAgICAgcy50aW1lID0gdGhpcy50aW1lO1xyXG4gICAgICBzLnZhbHVlID0gdGhpcy52YWx1ZTtcclxuICAgICAgcy5zbG9wZUluID0gdGhpcy5zbG9wZUluO1xyXG4gICAgICBzLnNsb3BlT3V0ID0gdGhpcy5zbG9wZU91dDtcclxuICAgICAgcy5jb25zdGFudCA9IHRoaXMuY29uc3RhbnQ7XHJcbiAgICAgIHJldHVybiBzO1xyXG4gICAgfVxyXG5cclxuICAgIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogU2VyaWFsaXphYmxlIHtcclxuICAgICAgdGhpcy50aW1lID0gX3NlcmlhbGl6YXRpb24udGltZTtcclxuICAgICAgdGhpcy52YWx1ZSA9IF9zZXJpYWxpemF0aW9uLnZhbHVlO1xyXG4gICAgICB0aGlzLnNsb3BlSW4gPSBfc2VyaWFsaXphdGlvbi5zbG9wZUluO1xyXG4gICAgICB0aGlzLnNsb3BlT3V0ID0gX3NlcmlhbGl6YXRpb24uc2xvcGVPdXQ7XHJcbiAgICAgIHRoaXMuY29uc3RhbnQgPSBfc2VyaWFsaXphdGlvbi5jb25zdGFudDtcclxuXHJcbiAgICAgIHRoaXMuYnJva2VuID0gdGhpcy5zbG9wZUluICE9IC10aGlzLnNsb3BlT3V0O1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgLy9cclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICB9XHJcblxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQSBzZXF1ZW5jZSBvZiBbW0FuaW1hdGlvbktleV1dcyB0aGF0IGlzIG1hcHBlZCB0byBhbiBhdHRyaWJ1dGUgb2YgYSBbW05vZGVdXSBvciBpdHMgW1tDb21wb25lbnRdXXMgaW5zaWRlIHRoZSBbW0FuaW1hdGlvbl1dLlxyXG4gICAqIFByb3ZpZGVzIGZ1bmN0aW9ucyB0byBtb2RpZnkgc2FpZCBrZXlzXHJcbiAgICogQGF1dGhvciBMdWthcyBTY2hldWVybGUsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBBbmltYXRpb25TZXF1ZW5jZSBleHRlbmRzIE11dGFibGUgaW1wbGVtZW50cyBTZXJpYWxpemFibGUge1xyXG4gICAgcHJpdmF0ZSBrZXlzOiBBbmltYXRpb25LZXlbXSA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXZhbHVhdGVzIHRoZSBzZXF1ZW5jZSBhdCB0aGUgZ2l2ZW4gcG9pbnQgaW4gdGltZS5cclxuICAgICAqIEBwYXJhbSBfdGltZSB0aGUgcG9pbnQgaW4gdGltZSBhdCB3aGljaCB0byBldmFsdWF0ZSB0aGUgc2VxdWVuY2UgaW4gbWlsbGlzZWNvbmRzLlxyXG4gICAgICogQHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBzZXF1ZW5jZSBhdCB0aGUgZ2l2ZW4gdGltZS4gMCBpZiB0aGVyZSBhcmUgbm8ga2V5cy5cclxuICAgICAqL1xyXG4gICAgZXZhbHVhdGUoX3RpbWU6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgIGlmICh0aGlzLmtleXMubGVuZ3RoID09IDApXHJcbiAgICAgICAgcmV0dXJuIDA7IC8vVE9ETzogc2hvdWxkbid0IHJldHVybiAwIGJ1dCBzb21ldGhpbmcgaW5kaWNhdGluZyBubyBjaGFuZ2UsIGxpa2UgbnVsbC4gcHJvYmFibHkgbmVlZHMgdG8gYmUgY2hhbmdlZCBpbiBOb2RlIGFzIHdlbGwgdG8gaWdub3JlIG5vbi1udW1lcmljIHZhbHVlcyBpbiB0aGUgYXBwbHlBbmltYXRpb24gZnVuY3Rpb25cclxuICAgICAgaWYgKHRoaXMua2V5cy5sZW5ndGggPT0gMSB8fCB0aGlzLmtleXNbMF0uVGltZSA+PSBfdGltZSlcclxuICAgICAgICByZXR1cm4gdGhpcy5rZXlzWzBdLlZhbHVlO1xyXG5cclxuXHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLmtleXMubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgaWYgKHRoaXMua2V5c1tpXS5UaW1lIDw9IF90aW1lICYmIHRoaXMua2V5c1tpICsgMV0uVGltZSA+IF90aW1lKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5rZXlzW2ldLmZ1bmN0aW9uT3V0LmV2YWx1YXRlKF90aW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMua2V5c1t0aGlzLmtleXMubGVuZ3RoIC0gMV0uVmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbmV3IGtleSB0byB0aGUgc2VxdWVuY2UuXHJcbiAgICAgKiBAcGFyYW0gX2tleSB0aGUga2V5IHRvIGFkZFxyXG4gICAgICovXHJcbiAgICBhZGRLZXkoX2tleTogQW5pbWF0aW9uS2V5KTogdm9pZCB7XHJcbiAgICAgIHRoaXMua2V5cy5wdXNoKF9rZXkpO1xyXG4gICAgICB0aGlzLmtleXMuc29ydChBbmltYXRpb25LZXkuY29tcGFyZSk7XHJcbiAgICAgIHRoaXMucmVnZW5lcmF0ZUZ1bmN0aW9ucygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhIGdpdmVuIGtleSBmcm9tIHRoZSBzZXF1ZW5jZS5cclxuICAgICAqIEBwYXJhbSBfa2V5IHRoZSBrZXkgdG8gcmVtb3ZlXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZUtleShfa2V5OiBBbmltYXRpb25LZXkpOiB2b2lkIHtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMua2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmICh0aGlzLmtleXNbaV0gPT0gX2tleSkge1xyXG4gICAgICAgICAgdGhpcy5rZXlzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgIHRoaXMucmVnZW5lcmF0ZUZ1bmN0aW9ucygpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgQW5pbWF0aW9uIEtleSBhdCB0aGUgZ2l2ZW4gaW5kZXggZnJvbSB0aGUga2V5cy5cclxuICAgICAqIEBwYXJhbSBfaW5kZXggdGhlIHplcm8tYmFzZWQgaW5kZXggYXQgd2hpY2ggdG8gcmVtb3ZlIHRoZSBrZXlcclxuICAgICAqIEByZXR1cm5zIHRoZSByZW1vdmVkIEFuaW1hdGlvbktleSBpZiBzdWNjZXNzZnVsLCBudWxsIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlS2V5QXRJbmRleChfaW5kZXg6IG51bWJlcik6IEFuaW1hdGlvbktleSB7XHJcbiAgICAgIGlmIChfaW5kZXggPCAwIHx8IF9pbmRleCA+PSB0aGlzLmtleXMubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgbGV0IGFrOiBBbmltYXRpb25LZXkgPSB0aGlzLmtleXNbX2luZGV4XTtcclxuICAgICAgdGhpcy5rZXlzLnNwbGljZShfaW5kZXgsIDEpO1xyXG4gICAgICB0aGlzLnJlZ2VuZXJhdGVGdW5jdGlvbnMoKTtcclxuICAgICAgcmV0dXJuIGFrO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhIGtleSBmcm9tIHRoZSBzZXF1ZW5jZSBhdCB0aGUgZGVzaXJlZCBpbmRleC5cclxuICAgICAqIEBwYXJhbSBfaW5kZXggdGhlIHplcm8tYmFzZWQgaW5kZXggYXQgd2hpY2ggdG8gZ2V0IHRoZSBrZXlcclxuICAgICAqIEByZXR1cm5zIHRoZSBBbmltYXRpb25LZXkgYXQgdGhlIGluZGV4IGlmIGl0IGV4aXN0cywgbnVsbCBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIGdldEtleShfaW5kZXg6IG51bWJlcik6IEFuaW1hdGlvbktleSB7XHJcbiAgICAgIGlmIChfaW5kZXggPCAwIHx8IF9pbmRleCA+PSB0aGlzLmtleXMubGVuZ3RoKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICByZXR1cm4gdGhpcy5rZXlzW19pbmRleF07XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGxlbmd0aCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5rZXlzLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gdHJhbnNmZXJcclxuICAgIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHM6IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAga2V5czogW10sXHJcbiAgICAgICAgYW5pbWF0aW9uU2VxdWVuY2U6IHRydWVcclxuICAgICAgfTtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMua2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHMua2V5c1tpXSA9IHRoaXMua2V5c1tpXS5zZXJpYWxpemUoKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcztcclxuICAgIH1cclxuICAgIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogU2VyaWFsaXphYmxlIHtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IF9zZXJpYWxpemF0aW9uLmtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAvLyB0aGlzLmtleXMucHVzaCg8QW5pbWF0aW9uS2V5PlNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24ua2V5c1tpXSkpO1xyXG4gICAgICAgIGxldCBrOiBBbmltYXRpb25LZXkgPSBuZXcgQW5pbWF0aW9uS2V5KCk7XHJcbiAgICAgICAgay5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5rZXlzW2ldKTtcclxuICAgICAgICB0aGlzLmtleXNbaV0gPSBrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnJlZ2VuZXJhdGVGdW5jdGlvbnMoKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICAvL1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVdGlsaXR5IGZ1bmN0aW9uIHRoYXQgKHJlLSlnZW5lcmF0ZXMgYWxsIGZ1bmN0aW9ucyBpbiB0aGUgc2VxdWVuY2UuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcmVnZW5lcmF0ZUZ1bmN0aW9ucygpOiB2b2lkIHtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMua2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCBmOiBBbmltYXRpb25GdW5jdGlvbiA9IG5ldyBBbmltYXRpb25GdW5jdGlvbih0aGlzLmtleXNbaV0pO1xyXG4gICAgICAgIHRoaXMua2V5c1tpXS5mdW5jdGlvbk91dCA9IGY7XHJcbiAgICAgICAgaWYgKGkgPT0gdGhpcy5rZXlzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgIC8vVE9ETzogY2hlY2sgaWYgdGhpcyBpcyBldmVuIHVzZWZ1bC4gTWF5YmUgdXBkYXRlIHRoZSBydW5jb25kaXRpb24gdG8gbGVuZ3RoIC0gMSBpbnN0ZWFkLiBNaWdodCBiZSByZWR1bmRhbnQgaWYgZnVuY3Rpb25JbiBpcyByZW1vdmVkLCBzZWUgVE9ETyBpbiBBbmltYXRpb25LZXkuXHJcbiAgICAgICAgICBmLnNldEtleU91dCA9IHRoaXMua2V5c1swXTtcclxuICAgICAgICAgIHRoaXMua2V5c1swXS5mdW5jdGlvbkluID0gZjtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmLnNldEtleU91dCA9IHRoaXMua2V5c1tpICsgMV07XHJcbiAgICAgICAgdGhpcy5rZXlzW2kgKyAxXS5mdW5jdGlvbkluID0gZjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEV4dGVuc2lvbiBvZiBBdWRpb0J1ZmZlciB3aXRoIGEgbG9hZCBtZXRob2QgdGhhdCBjcmVhdGVzIGEgYnVmZmVyIGluIHRoZSBbW0F1ZGlvTWFuYWdlcl1dLmRlZmF1bHQgdG8gYmUgdXNlZCB3aXRoIFtbQ29tcG9uZW50QXVkaW9dXVxyXG4gICAqIEBhdXRob3JzIFRob21hcyBEb3JuZXIsIEhGVSwgMjAxOSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIwXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEF1ZGlvIGV4dGVuZHMgQXVkaW9CdWZmZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBBc3luY2hyb25vdXNseSBsb2FkcyB0aGUgYXVkaW8gKG1wMykgZnJvbSB0aGUgZ2l2ZW4gdXJsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgbG9hZChfdXJsOiBzdHJpbmcpOiBQcm9taXNlPEF1ZGlvPiB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlOiBSZXNwb25zZSA9IGF3YWl0IHdpbmRvdy5mZXRjaChfdXJsKTtcclxuICAgICAgY29uc3QgYXJyYXlCdWZmZXI6IEFycmF5QnVmZmVyID0gYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcclxuICAgICAgcmV0dXJuIDxBdWRpbz4oYXdhaXQgQXVkaW9NYW5hZ2VyLmRlZmF1bHQuZGVjb2RlQXVkaW9EYXRhKGFycmF5QnVmZmVyKSk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogRXh0ZW5kcyB0aGUgc3RhbmRhcmQgQXVkaW9Db250ZXh0IGZvciBpbnRlZ3JhdGlvbiB3aXRoIEZVREdFLWdyYXBocy5cclxuICAgKiBDcmVhdGVzIGEgZGVmYXVsdCBvYmplY3QgYXQgc3RhcnR1cCB0byBiZSBhZGRyZXNzZWQgYXMgQXVkaW9NYW5hZ2VyIGRlZmF1bHQuXHJcbiAgICogT3RoZXIgb2JqZWN0cyBvZiB0aGlzIGNsYXNzIG1heSBiZSBjcmVhdGUgZm9yIHNwZWNpYWwgcHVycG9zZXMuXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEF1ZGlvTWFuYWdlciBleHRlbmRzIEF1ZGlvQ29udGV4dCB7XHJcbiAgICAvKiogVGhlIGRlZmF1bHQgY29udGV4dCB0aGF0IG1heSBiZSB1c2VkIHRocm91Z2hvdXQgdGhlIHByb2plY3Qgd2l0aG91dCB0aGUgbmVlZCB0byBjcmVhdGUgb3RoZXJzICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGRlZmF1bHQ6IEF1ZGlvTWFuYWdlciA9IG5ldyBBdWRpb01hbmFnZXIoeyBsYXRlbmN5SGludDogXCJpbnRlcmFjdGl2ZVwiLCBzYW1wbGVSYXRlOiA0NDEwMCB9KTtcclxuICAgIC8qKiBUaGUgbWFzdGVyIHZvbHVtZSBhbGwgQXVkaW9Ob2RlcyBpbiB0aGUgY29udGV4dCBzaG91bGQgYXR0YWNoIHRvICovXHJcbiAgICBwdWJsaWMgcmVhZG9ubHkgZ2FpbjogR2Fpbk5vZGU7XHJcbiAgICBwcml2YXRlIGdyYXBoOiBOb2RlID0gbnVsbDtcclxuICAgIHByaXZhdGUgY21wTGlzdGVuZXI6IENvbXBvbmVudEF1ZGlvTGlzdGVuZXIgPSBudWxsO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHRPcHRpb25zPzogQXVkaW9Db250ZXh0T3B0aW9ucykge1xyXG4gICAgICBzdXBlcihjb250ZXh0T3B0aW9ucyk7XHJcbiAgICAgIHRoaXMuZ2FpbiA9IHRoaXMuY3JlYXRlR2FpbigpO1xyXG4gICAgICB0aGlzLmdhaW4uY29ubmVjdCh0aGlzLmRlc3RpbmF0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgbWFzdGVyIHZvbHVtZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0IHZvbHVtZShfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLmdhaW4uZ2Fpbi52YWx1ZSA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgbWFzdGVyIHZvbHVtZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHZvbHVtZSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5nYWluLmdhaW4udmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlcm1pbmVzIEZVREdFLWdyYXBoIHRvIGxpc3RlbiB0by4gRWFjaCBbW0NvbXBvbmVudEF1ZGlvXV0gaW4gdGhlIGdyYXBoIHdpbGwgY29ubmVjdCB0byB0aGlzIGNvbnRleHRzIG1hc3RlciBnYWluLCBhbGwgb3RoZXJzIGRpc2Nvbm5lY3QuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBsaXN0ZW5UbyA9IChfZ3JhcGg6IE5vZGUgfCBudWxsKTogdm9pZCA9PiB7XHJcbiAgICAgIGlmICh0aGlzLmdyYXBoKVxyXG4gICAgICAgIHRoaXMuZ3JhcGguYnJvYWRjYXN0RXZlbnQobmV3IEV2ZW50KEVWRU5UX0FVRElPLkNISUxEX1JFTU9WRSkpO1xyXG4gICAgICBpZiAoIV9ncmFwaClcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIHRoaXMuZ3JhcGggPSBfZ3JhcGg7XHJcbiAgICAgIHRoaXMuZ3JhcGguYnJvYWRjYXN0RXZlbnQobmV3IEV2ZW50KEVWRU5UX0FVRElPLkNISUxEX0FQUEVORCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmUgdGhlIEZVREdFLWdyYXBoIGN1cnJlbnRseSBsaXN0ZW5pbmcgdG9cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEdyYXBoTGlzdGVuaW5nVG8gPSAoKTogTm9kZSA9PiB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdyYXBoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBbW0NvbXBvbmVudEF1ZGlvTGlzdGVuZXJdXSB0aGF0IHNlcnZlcyB0aGUgc3BhdGlhbCBsb2NhdGlvbiBhbmQgb3JpZW50YXRpb24gZm9yIHRoaXMgY29udGV4dHMgbGlzdGVuZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGxpc3RlbiA9IChfY21wTGlzdGVuZXI6IENvbXBvbmVudEF1ZGlvTGlzdGVuZXIgfCBudWxsKTogdm9pZCA9PiB7XHJcbiAgICAgIHRoaXMuY21wTGlzdGVuZXIgPSBfY21wTGlzdGVuZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBzcGF0aWFsIHNldHRpbmdzIG9mIHRoZSBBdWRpb05vZGVzIGVmZmVjdGVkIGluIHRoZSBjdXJyZW50IEZVREdFLWdyYXBoXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB1cGRhdGUgPSAoKTogdm9pZCA9PiB7XHJcbiAgICAgIHRoaXMuZ3JhcGguYnJvYWRjYXN0RXZlbnQobmV3IEV2ZW50KEVWRU5UX0FVRElPLlVQREFURSkpO1xyXG4gICAgICBpZiAodGhpcy5jbXBMaXN0ZW5lcilcclxuICAgICAgICB0aGlzLmNtcExpc3RlbmVyLnVwZGF0ZSh0aGlzLmxpc3RlbmVyKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCIvLyBuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAgIFxyXG4vLyAgICAgLyoqXHJcbi8vICAgICAgKiBFbnVtZXJhdG9yIGZvciBhbGwgcG9zc2libGUgT3NjaWxsYXRvciBUeXBlc1xyXG4vLyAgICAgICovXHJcbi8vICAgICB0eXBlIE9TQ0lMTEFUT1JfVFlQRSA9IFwic2luZVwiIHwgXCJzcXVhcmVcIiB8IFwic2F3dG9vdGhcIiB8IFwidHJpYW5nbGVcIiB8IFwiY3VzdG9tXCI7XHJcblxyXG4vLyAgICAgLyoqXHJcbi8vICAgICAgKiBJbnRlcmZhY2UgdG8gY3JlYXRlIEN1c3RvbSBPc2NpbGxhdG9yIFR5cGVzLlxyXG4vLyAgICAgICogU3RhcnQtL0VuZHBvaW50IG9mIGEgY3VzdHVtIGN1cnZlIGUuZy4gc2luZSBjdXJ2ZS5cclxuLy8gICAgICAqIEJvdGggcGFyYW1ldGVycyBuZWVkIHRvIGJlIGluYmV0d2VlbiAtMSBhbmQgMS5cclxuLy8gICAgICAqIEBwYXJhbSBzdGFydHBvaW50IHN0YXJ0cG9pbnQgb2YgYSBjdXJ2ZSBcclxuLy8gICAgICAqIEBwYXJhbSBlbmRwb2ludCBFbmRwb2ludCBvZiBhIGN1cnZlIFxyXG4vLyAgICAgICovXHJcbi8vICAgICBpbnRlcmZhY2UgT3NjaWxsYXRvcldhdmUge1xyXG4vLyAgICAgICAgIHN0YXJ0cG9pbnQ6IG51bWJlcjtcclxuLy8gICAgICAgICBlbmRwb2ludDogbnVtYmVyO1xyXG4vLyAgICAgfVxyXG4vLyAgICAgLyoqXHJcbi8vICAgICAgKiBBZGQgYW4gW1tBdWRpb0ZpbHRlcl1dIHRvIGFuIFtbQXVkaW9dXVxyXG4vLyAgICAgICogQGF1dGhvcnMgVGhvbWFzIERvcm5lciwgSEZVLCAyMDE5XHJcbi8vICAgICAgKi9cclxuLy8gICAgIGV4cG9ydCBjbGFzcyBBdWRpb09zY2lsbGF0b3Ige1xyXG5cclxuLy8gICAgICAgICBwdWJsaWMgYXVkaW9Pc2NpbGxhdG9yOiBPc2NpbGxhdG9yTm9kZTsgXHJcblxyXG4vLyAgICAgICAgIHByaXZhdGUgZnJlcXVlbmN5OiBudW1iZXI7XHJcbi8vICAgICAgICAgcHJpdmF0ZSBvc2NpbGxhdG9yVHlwZTogT1NDSUxMQVRPUl9UWVBFO1xyXG4vLyAgICAgICAgIHByaXZhdGUgb3NjaWxsYXRvcldhdmU6IFBlcmlvZGljV2F2ZTtcclxuXHJcbi8vICAgICAgICAgcHJpdmF0ZSBsb2NhbEdhaW46IEdhaW5Ob2RlO1xyXG4vLyAgICAgICAgIHByaXZhdGUgbG9jYWxHYWluVmFsdWU6IG51bWJlcjtcclxuXHJcbi8vICAgICAgICAgY29uc3RydWN0b3IoX2F1ZGlvU2V0dGluZ3M6IEF1ZGlvU2V0dGluZ3MsIF9vc2NpbGxhdG9yVHlwZT86IE9TQ0lMTEFUT1JfVFlQRSkge1xyXG4vLyAgICAgICAgICAgICB0aGlzLmF1ZGlvT3NjaWxsYXRvciA9IF9hdWRpb1NldHRpbmdzLmdldEF1ZGlvQ29udGV4dCgpLmNyZWF0ZU9zY2lsbGF0b3IoKTtcclxuLy8gICAgICAgICAgICAgdGhpcy5sb2NhbEdhaW4gPSBfYXVkaW9TZXR0aW5ncy5nZXRBdWRpb0NvbnRleHQoKS5jcmVhdGVHYWluKCk7XHJcbi8vICAgICAgICAgICAgIHRoaXMub3NjaWxsYXRvclR5cGUgPSBfb3NjaWxsYXRvclR5cGU7XHJcbi8vICAgICAgICAgICAgIGlmICh0aGlzLm9zY2lsbGF0b3JUeXBlICE9IFwiY3VzdG9tXCIpIHtcclxuLy8gICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9Pc2NpbGxhdG9yLnR5cGUgPSB0aGlzLm9zY2lsbGF0b3JUeXBlO1xyXG4vLyAgICAgICAgICAgICB9XHJcbi8vICAgICAgICAgICAgIGVsc2Uge1xyXG4vLyAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9zY2lsbGF0b3JXYXZlKSB7XHJcbi8vICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdWRpb09zY2lsbGF0b3Iuc2V0UGVyaW9kaWNXYXZlKHRoaXMub3NjaWxsYXRvcldhdmUpO1xyXG4vLyAgICAgICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbi8vICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJDcmVhdGUgYSBDdXN0b20gUGVyaW9kaWMgV2F2ZSBmaXJzdCB0byB1c2UgQ3VzdG9tIFR5cGVcIik7XHJcbi8vICAgICAgICAgICAgICAgICB9XHJcbi8vICAgICAgICAgICAgIH1cclxuLy8gICAgICAgICB9XHJcblxyXG4vLyAgICAgICAgIHB1YmxpYyBzZXRPc2NpbGxhdG9yVHlwZShfb3NjaWxsYXRvclR5cGU6IE9TQ0lMTEFUT1JfVFlQRSk6IHZvaWQge1xyXG4vLyAgICAgICAgICAgICBpZiAodGhpcy5vc2NpbGxhdG9yVHlwZSAhPSBcImN1c3RvbVwiKSB7XHJcbi8vICAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvT3NjaWxsYXRvci50eXBlID0gdGhpcy5vc2NpbGxhdG9yVHlwZTtcclxuLy8gICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgICAgICBlbHNlIHtcclxuLy8gICAgICAgICAgICAgICAgIGlmICghdGhpcy5vc2NpbGxhdG9yV2F2ZSkge1xyXG4vLyAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9Pc2NpbGxhdG9yLnNldFBlcmlvZGljV2F2ZSh0aGlzLm9zY2lsbGF0b3JXYXZlKTtcclxuLy8gICAgICAgICAgICAgICAgIH1cclxuLy8gICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgIH1cclxuXHJcbi8vICAgICAgICAgcHVibGljIGdldE9zY2lsbGF0b3JUeXBlKCk6IE9TQ0lMTEFUT1JfVFlQRSB7XHJcbi8vICAgICAgICAgICAgIHJldHVybiB0aGlzLm9zY2lsbGF0b3JUeXBlO1xyXG4vLyAgICAgICAgIH1cclxuXHJcbi8vICAgICAgICAgcHVibGljIGNyZWF0ZVBlcmlvZGljV2F2ZShfYXVkaW9TZXR0aW5nczogQXVkaW9TZXR0aW5ncywgX3JlYWw6IE9zY2lsbGF0b3JXYXZlLCBfaW1hZzogT3NjaWxsYXRvcldhdmUpOiB2b2lkIHtcclxuLy8gICAgICAgICAgICAgbGV0IHdhdmVSZWFsOiBGbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xyXG4vLyAgICAgICAgICAgICB3YXZlUmVhbFswXSA9IF9yZWFsLnN0YXJ0cG9pbnQ7XHJcbi8vICAgICAgICAgICAgIHdhdmVSZWFsWzFdID0gX3JlYWwuZW5kcG9pbnQ7XHJcblxyXG4vLyAgICAgICAgICAgICBsZXQgd2F2ZUltYWc6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XHJcbi8vICAgICAgICAgICAgIHdhdmVJbWFnWzBdID0gX2ltYWcuc3RhcnRwb2ludDtcclxuLy8gICAgICAgICAgICAgd2F2ZUltYWdbMV0gPSBfaW1hZy5lbmRwb2ludDtcclxuXHJcbi8vICAgICAgICAgICAgIHRoaXMub3NjaWxsYXRvcldhdmUgPSBfYXVkaW9TZXR0aW5ncy5nZXRBdWRpb0NvbnRleHQoKS5jcmVhdGVQZXJpb2RpY1dhdmUod2F2ZVJlYWwsIHdhdmVJbWFnKTtcclxuLy8gICAgICAgICB9XHJcblxyXG4vLyAgICAgICAgIHB1YmxpYyBzZXRMb2NhbEdhaW4oX2xvY2FsR2FpbjogR2Fpbk5vZGUpOiB2b2lkIHtcclxuLy8gICAgICAgICAgICAgdGhpcy5sb2NhbEdhaW4gPSBfbG9jYWxHYWluO1xyXG4vLyAgICAgICAgIH1cclxuXHJcbi8vICAgICAgICAgcHVibGljIGdldExvY2FsR2FpbigpOiBHYWluTm9kZSB7XHJcbi8vICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsR2FpbjtcclxuLy8gICAgICAgICB9XHJcblxyXG4vLyAgICAgICAgIHB1YmxpYyBzZXRMb2NhbEdhaW5WYWx1ZShfbG9jYWxHYWluVmFsdWU6IG51bWJlcik6IHZvaWQge1xyXG4vLyAgICAgICAgICAgICB0aGlzLmxvY2FsR2FpblZhbHVlID0gX2xvY2FsR2FpblZhbHVlO1xyXG4vLyAgICAgICAgICAgICB0aGlzLmxvY2FsR2Fpbi5nYWluLnZhbHVlID0gdGhpcy5sb2NhbEdhaW5WYWx1ZTtcclxuLy8gICAgICAgICB9XHJcblxyXG4vLyAgICAgICAgIHB1YmxpYyBnZXRMb2NhbEdhaW5WYWx1ZSgpOiBudW1iZXIge1xyXG4vLyAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbEdhaW5WYWx1ZTtcclxuLy8gICAgICAgICB9XHJcblxyXG4vLyAgICAgICAgIHB1YmxpYyBzZXRGcmVxdWVuY3koX2F1ZGlvU2V0dGluZ3M6IEF1ZGlvU2V0dGluZ3MsIF9mcmVxdWVuY3k6IG51bWJlcik6IHZvaWQge1xyXG4vLyAgICAgICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IF9mcmVxdWVuY3k7XHJcbi8vICAgICAgICAgICAgIHRoaXMuYXVkaW9Pc2NpbGxhdG9yLmZyZXF1ZW5jeS5zZXRWYWx1ZUF0VGltZSh0aGlzLmZyZXF1ZW5jeSwgX2F1ZGlvU2V0dGluZ3MuZ2V0QXVkaW9Db250ZXh0KCkuY3VycmVudFRpbWUpO1xyXG4vLyAgICAgICAgIH1cclxuXHJcbi8vICAgICAgICAgcHVibGljIGdldEZyZXF1ZW5jeSgpOiBudW1iZXIge1xyXG4vLyAgICAgICAgICAgICByZXR1cm4gdGhpcy5mcmVxdWVuY3k7XHJcbi8vICAgICAgICAgfVxyXG5cclxuLy8gICAgICAgICBwdWJsaWMgY3JlYXRlU25hcmUoX2F1ZGlvU2V0dGluZ3M6IEF1ZGlvU2V0dGluZ3MpOiB2b2lkIHtcclxuLy8gICAgICAgICAgICAgdGhpcy5zZXRPc2NpbGxhdG9yVHlwZShcInRyaWFuZ2xlXCIpO1xyXG4vLyAgICAgICAgICAgICB0aGlzLnNldEZyZXF1ZW5jeShfYXVkaW9TZXR0aW5ncywgMTAwKTtcclxuLy8gICAgICAgICAgICAgdGhpcy5zZXRMb2NhbEdhaW5WYWx1ZSgwKTtcclxuLy8gICAgICAgICAgICAgdGhpcy5sb2NhbEdhaW4uZ2Fpbi5zZXRWYWx1ZUF0VGltZSgwLCBfYXVkaW9TZXR0aW5ncy5nZXRBdWRpb0NvbnRleHQoKS5jdXJyZW50VGltZSk7XHJcbi8vICAgICAgICAgICAgIHRoaXMubG9jYWxHYWluLmdhaW4uZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZSgwLjAxLCBfYXVkaW9TZXR0aW5ncy5nZXRBdWRpb0NvbnRleHQoKS5jdXJyZW50VGltZSArIC4xKTtcclxuXHJcbi8vICAgICAgICAgICAgIHRoaXMuYXVkaW9Pc2NpbGxhdG9yLmNvbm5lY3QodGhpcy5sb2NhbEdhaW4pO1xyXG4vLyAgICAgICAgIH1cclxuLy8gICAgIH1cclxuLy8gfSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBIb2xkcyBkYXRhIHRvIGZlZWQgaW50byBhIFtbU2hhZGVyXV0gdG8gZGVzY3JpYmUgdGhlIHN1cmZhY2Ugb2YgW1tNZXNoXV0uICBcclxuICAgICAqIFtbTWF0ZXJpYWxdXXMgcmVmZXJlbmNlIFtbQ29hdF1dIGFuZCBbW1NoYWRlcl1dLiAgIFxyXG4gICAgICogVGhlIG1ldGhvZCB1c2VSZW5kZXJEYXRhIHdpbGwgYmUgaW5qZWN0ZWQgYnkgW1tSZW5kZXJJbmplY3Rvcl1dIGF0IHJ1bnRpbWUsIGV4dGVuZGluZyB0aGUgZnVuY3Rpb25hbGl0eSBvZiB0aGlzIGNsYXNzIHRvIGRlYWwgd2l0aCB0aGUgcmVuZGVyZXIuXHJcbiAgICAgKi9cclxuICAgIGV4cG9ydCBjbGFzcyBDb2F0IGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZSB7XHJcbiAgICAgICAgcHVibGljIG5hbWU6IHN0cmluZyA9IFwiQ29hdFwiO1xyXG4gICAgICAgIHByb3RlY3RlZCByZW5kZXJEYXRhOiB7W2tleTogc3RyaW5nXTogdW5rbm93bn07XHJcblxyXG4gICAgICAgIHB1YmxpYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgICAgICAgc3VwZXIubXV0YXRlKF9tdXRhdG9yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB1c2VSZW5kZXJEYXRhKF9zaGFkZXI6IHR5cGVvZiBTaGFkZXIsIF9jbXBNYXRlcmlhbDogQ29tcG9uZW50TWF0ZXJpYWwpOiB2b2lkIHsvKiBpbmplY3RlZCBieSBSZW5kZXJJbmplY3RvciovIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgICAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICAgICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHRoaXMuZ2V0TXV0YXRvcigpOyBcclxuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB1YmxpYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFNlcmlhbGl6YWJsZSB7XHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRlKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcigpOiB2b2lkIHsgLyoqLyB9XHJcbiAgICAgICAgLy8jZW5kcmVnaW9uXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc2ltcGxlc3QgW1tDb2F0XV0gcHJvdmlkaW5nIGp1c3QgYSBjb2xvclxyXG4gICAgICovXHJcbiAgICBAUmVuZGVySW5qZWN0b3JDb2F0LmRlY29yYXRlXHJcbiAgICBleHBvcnQgY2xhc3MgQ29hdENvbG9yZWQgZXh0ZW5kcyBDb2F0IHtcclxuICAgICAgICBwdWJsaWMgY29sb3I6IENvbG9yO1xyXG5cclxuICAgICAgICBjb25zdHJ1Y3RvcihfY29sb3I/OiBDb2xvcikge1xyXG4gICAgICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbG9yID0gX2NvbG9yIHx8IG5ldyBDb2xvcigwLjUsIDAuNSwgMC41LCAxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIFtbQ29hdF1dIHRvIGJlIHVzZWQgYnkgdGhlIE1hdENhcCBTaGFkZXIgcHJvdmlkaW5nIGEgdGV4dHVyZSwgYSB0aW50IGNvbG9yICgwLjUgZ3JleSBpcyBuZXV0cmFsKS4gU2V0IHNoYWRlU21vb3RoIHRvIDEgZm9yIHNtb290aCBzaGFkaW5nLlxyXG4gICAgICovXHJcbiAgICBAUmVuZGVySW5qZWN0b3JDb2F0LmRlY29yYXRlXHJcbiAgICBleHBvcnQgY2xhc3MgQ29hdE1hdENhcCBleHRlbmRzIENvYXQge1xyXG4gICAgICAgIHB1YmxpYyB0ZXh0dXJlOiBUZXh0dXJlSW1hZ2UgPSBudWxsO1xyXG4gICAgICAgIHB1YmxpYyBjb2xvcjogQ29sb3IgPSBuZXcgQ29sb3IoMC41LCAwLjUsIDAuNSwgMSk7XHJcbiAgICAgICAgcHVibGljIHNoYWRlU21vb3RoOiBudW1iZXI7XHJcblxyXG4gICAgICAgIGNvbnN0cnVjdG9yKF90ZXh0dXJlPzogVGV4dHVyZUltYWdlLCBfY29sb3I/OiBDb2xvciwgX3NoYWRlU21vb3RoPzogbnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZSA9IF90ZXh0dXJlIHx8IG5ldyBUZXh0dXJlSW1hZ2UoKTtcclxuICAgICAgICAgICAgdGhpcy5jb2xvciA9IF9jb2xvciB8fCBuZXcgQ29sb3IoMC41LCAwLjUsIDAuNSwgMSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2hhZGVTbW9vdGggPSBfc2hhZGVTbW9vdGggfHwgMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBBIFtbQ29hdF1dIHByb3ZpZGluZyBhIHRleHR1cmUgYW5kIGFkZGl0aW9uYWwgZGF0YSBmb3IgdGV4dHVyaW5nXHJcbiAgICovXHJcbiAgQFJlbmRlckluamVjdG9yQ29hdC5kZWNvcmF0ZVxyXG4gIGV4cG9ydCBjbGFzcyBDb2F0VGV4dHVyZWQgZXh0ZW5kcyBDb2F0IHtcclxuICAgIC8vIFRPRE86IHNlZSBpZiBjb2xvciBzaG91bGQgYmUgZ2VuZXJhbGl6ZWRcclxuICAgIHB1YmxpYyBjb2xvcjogQ29sb3IgPSBuZXcgQ29sb3IoMSwgMSwgMSwgMSk7XHJcbiAgICBwdWJsaWMgdGV4dHVyZTogVGV4dHVyZUltYWdlID0gbnVsbDtcclxuICAgIHB1YmxpYyBwaXZvdDogTWF0cml4M3gzID0gTWF0cml4M3gzLklERU5USVRZKCk7XHJcbiAgICAvLyBqdXN0IGlkZWFzIHNvIGZhclxyXG4gICAgcHVibGljIHRpbGluZ1g6IG51bWJlcjtcclxuICAgIHB1YmxpYyB0aWxpbmdZOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgcmVwZXRpdGlvbjogYm9vbGVhbjtcclxuXHJcbiAgICAvLyBjb25zdHJ1Y3RvcihfdGV4dHVyZTogVGV4dHVyZUltYWdlLCBfY29sb3I/OiBDb2xvcikge1xyXG4gICAgLy8gICBzdXBlcigpO1xyXG4gICAgLy8gICB0aGlzLnRleHR1cmUgPSBfdGV4dHVyZTtcclxuICAgIC8vICAgdGhpcy5jb2xvciA9IF9jb2xvciB8fCBuZXcgQ29sb3IoMSwgMSwgMSwgMSk7XHJcbiAgICAvLyB9XHJcblxyXG4gICAgLy8gcHVibGljIGdldE11dGF0b3JGb3JDb21wb25lbnQoKTogTXV0YXRvckZvckNvbXBvbmVudCB7XHJcbiAgICAvLyAgIGxldCBtdXRhdG9yUGl2b3Q6IE11dGF0b3JGb3JDb21wb25lbnQgPSA8TXV0YXRvckZvckNvbXBvbmVudD48dW5rbm93bj50aGlzLnBpdm90LmdldE11dGF0b3IoKTtcclxuICAgIC8vICAgcmV0dXJuIG11dGF0b3JQaXZvdDtcclxuICAgIC8vIH1cclxuXHJcbiAgICAvLyBwdWJsaWMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yRm9yQ29tcG9uZW50KTogdm9pZCB7XHJcbiAgICAvLyAgIHRoaXMucGl2b3QubXV0YXRlKF9tdXRhdG9yKTtcclxuICAgIC8vIH1cclxuICB9XHJcbn0iLCIvLyAvIDxyZWZlcmVuY2UgcGF0aD1cIi4uL1RyYW5zZmVyL1NlcmlhbGl6ZXIudHNcIi8+XHJcbi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vVHJhbnNmZXIvTXV0YWJsZS50c1wiLz5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqIFxyXG4gICAqIFN1cGVyY2xhc3MgZm9yIGFsbCBbW0NvbXBvbmVudF1dcyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBbW05vZGVdXXMuXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjAgfCBKYXNjaGEgS2FyYWfDtmwsIEhGVSwgMjAxOSAgXHJcbiAgICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL0ppcmthRGVsbE9yby9GVURHRS93aWtpL0NvbXBvbmVudFxyXG4gICAqL1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBDb21wb25lbnQgZXh0ZW5kcyBNdXRhYmxlIGltcGxlbWVudHMgU2VyaWFsaXphYmxlIHtcclxuICAgIC8qKiBzdWJjbGFzc2VzIGdldCBhIGlTdWJjbGFzcyBudW1iZXIgZm9yIGlkZW50aWZpY2F0aW9uICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyO1xyXG4gICAgLyoqIHJlZmVycyBiYWNrIHRvIHRoaXMgY2xhc3MgZnJvbSBhbnkgc3ViY2xhc3MgZS5nLiBpbiBvcmRlciB0byBmaW5kIGNvbXBhdGlibGUgb3RoZXIgcmVzb3VyY2VzKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgYmFzZUNsYXNzOiB0eXBlb2YgQ29tcG9uZW50ID0gQ29tcG9uZW50O1xyXG4gICAgLyoqIGxpc3Qgb2YgYWxsIHRoZSBzdWJjbGFzc2VzIGRlcml2ZWQgZnJvbSB0aGlzIGNsYXNzLCBpZiB0aGV5IHJlZ2lzdGVyZWQgcHJvcGVybHkqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBzdWJjbGFzc2VzOiB0eXBlb2YgQ29tcG9uZW50W10gPSBbXTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgc2luZ2xldG9uOiBib29sZWFuID0gdHJ1ZTtcclxuICAgIHByaXZhdGUgY29udGFpbmVyOiBOb2RlIHwgbnVsbCA9IG51bGw7XHJcbiAgICBwcml2YXRlIGFjdGl2ZTogYm9vbGVhbiA9IHRydWU7XHJcblxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyByZWdpc3RlclN1YmNsYXNzKF9zdWJjbGFzczogdHlwZW9mIENvbXBvbmVudCk6IG51bWJlciB7IHJldHVybiBDb21wb25lbnQuc3ViY2xhc3Nlcy5wdXNoKF9zdWJjbGFzcykgLSAxOyB9XHJcblxyXG4gICAgcHVibGljIGFjdGl2YXRlKF9vbjogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICB0aGlzLmFjdGl2ZSA9IF9vbjtcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChfb24gPyBFVkVOVC5DT01QT05FTlRfQUNUSVZBVEUgOiBFVkVOVC5DT01QT05FTlRfREVBQ1RJVkFURSkpO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGdldCBpc0FjdGl2ZSgpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSXMgdHJ1ZSwgd2hlbiBvbmx5IG9uZSBpbnN0YW5jZSBvZiB0aGUgY29tcG9uZW50IGNsYXNzIGNhbiBiZSBhdHRhY2hlZCB0byBhIG5vZGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBpc1NpbmdsZXRvbigpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc2luZ2xldG9uO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIG5vZGUsIHRoaXMgY29tcG9uZW50IGlzIGN1cnJlbnRseSBhdHRhY2hlZCB0b1xyXG4gICAgICogQHJldHVybnMgVGhlIGNvbnRhaW5lciBub2RlIG9yIG51bGwsIGlmIHRoZSBjb21wb25lbnQgaXMgbm90IGF0dGFjaGVkIHRvXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRDb250YWluZXIoKTogTm9kZSB8IG51bGwge1xyXG4gICAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyaWVzIHRvIGFkZCB0aGUgY29tcG9uZW50IHRvIHRoZSBnaXZlbiBub2RlLCByZW1vdmluZyBpdCBmcm9tIHRoZSBwcmV2aW91cyBjb250YWluZXIgaWYgYXBwbGljYWJsZVxyXG4gICAgICogQHBhcmFtIF9jb250YWluZXIgVGhlIG5vZGUgdG8gYXR0YWNoIHRoaXMgY29tcG9uZW50IHRvXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRDb250YWluZXIoX2NvbnRhaW5lcjogTm9kZSB8IG51bGwpOiB2b2lkIHtcclxuICAgICAgaWYgKHRoaXMuY29udGFpbmVyID09IF9jb250YWluZXIpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBsZXQgcHJldmlvdXNDb250YWluZXI6IE5vZGUgPSB0aGlzLmNvbnRhaW5lcjtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBpZiAocHJldmlvdXNDb250YWluZXIpXHJcbiAgICAgICAgICBwcmV2aW91c0NvbnRhaW5lci5yZW1vdmVDb21wb25lbnQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBfY29udGFpbmVyO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5lcilcclxuICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENvbXBvbmVudCh0aGlzKTtcclxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBwcmV2aW91c0NvbnRhaW5lcjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHtcclxuICAgICAgICBhY3RpdmU6IHRoaXMuYWN0aXZlXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogU2VyaWFsaXphYmxlIHtcclxuICAgICAgdGhpcy5hY3RpdmUgPSBfc2VyaWFsaXphdGlvbi5hY3RpdmU7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5zaW5nbGV0b247XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5jb250YWluZXI7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICB9XHJcbn0iLCIvLyAvIDxyZWZlcmVuY2UgcGF0aD1cIi4uL1RpbWUvTG9vcC50c1wiLz5cclxuLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9BbmltYXRpb24vQW5pbWF0aW9uLnRzXCIvPlxyXG5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogSG9sZHMgZGlmZmVyZW50IHBsYXltb2RlcyB0aGUgYW5pbWF0aW9uIHVzZXMgdG8gcGxheSBiYWNrIGl0cyBhbmltYXRpb24uXHJcbiAgICogQGF1dGhvciBMdWthcyBTY2hldWVybGUsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBlbnVtIEFOSU1BVElPTl9QTEFZTU9ERSB7XHJcbiAgICAvKipQbGF5cyBhbmltYXRpb24gaW4gYSBsb29wOiBpdCByZXN0YXJ0cyBvbmNlIGl0IGhpdCB0aGUgZW5kLiovXHJcbiAgICBMT09QLFxyXG4gICAgLyoqUGxheXMgYW5pbWF0aW9uIG9uY2UgYW5kIHN0b3BzIGF0IHRoZSBsYXN0IGtleS9mcmFtZSovXHJcbiAgICBQTEFZT05DRSxcclxuICAgIC8qKlBsYXlzIGFuaW1hdGlvbiBvbmNlIGFuZCBzdG9wcyBvbiB0aGUgZmlyc3Qga2V5L2ZyYW1lICovXHJcbiAgICBQTEFZT05DRVNUT1BBRlRFUixcclxuICAgIC8qKlBsYXlzIGFuaW1hdGlvbiBsaWtlIExPT1AsIGJ1dCBiYWNrd2FyZHMuKi9cclxuICAgIFJFVkVSU0VMT09QLFxyXG4gICAgLyoqQ2F1c2VzIHRoZSBhbmltYXRpb24gbm90IHRvIHBsYXkgYXQgYWxsLiBVc2VmdWwgZm9yIGp1bXBpbmcgdG8gdmFyaW91cyBwb3NpdGlvbnMgaW4gdGhlIGFuaW1hdGlvbiB3aXRob3V0IHByb2NlZWRpbmcgaW4gdGhlIGFuaW1hdGlvbi4qL1xyXG4gICAgU1RPUFxyXG4gICAgLy9UT0RPOiBhZGQgYW4gSU5IRVJJVCBhbmQgYSBQSU5HUE9ORyBtb2RlXHJcbiAgfVxyXG5cclxuICBleHBvcnQgZW51bSBBTklNQVRJT05fUExBWUJBQ0sge1xyXG4gICAgLy9UT0RPOiBhZGQgYW4gaW4tZGVwdGggZGVzY3JpcHRpb24gb2Ygd2hhdCBoYXBwZW5zIHRvIHRoZSBhbmltYXRpb24gKGFuZCBldmVudHMpIGRlcGVuZGluZyBvbiB0aGUgUGxheWJhY2suIFVzZSBHcmFwaHMgdG8gZXhwbGFpbi5cclxuICAgIC8qKkNhbGN1bGF0ZXMgdGhlIHN0YXRlIG9mIHRoZSBhbmltYXRpb24gYXQgdGhlIGV4YWN0IHBvc2l0aW9uIG9mIHRpbWUuIElnbm9yZXMgRlBTIHZhbHVlIG9mIGFuaW1hdGlvbi4qL1xyXG4gICAgVElNRUJBU0VEX0NPTlRJTk9VUyxcclxuICAgIC8qKkxpbWl0cyB0aGUgY2FsY3VsYXRpb24gb2YgdGhlIHN0YXRlIG9mIHRoZSBhbmltYXRpb24gdG8gdGhlIEZQUyB2YWx1ZSBvZiB0aGUgYW5pbWF0aW9uLiBTa2lwcyBmcmFtZXMgaWYgbmVlZGVkLiovXHJcbiAgICBUSU1FQkFTRURfUkFTVEVSRURfVE9fRlBTLFxyXG4gICAgLyoqVXNlcyB0aGUgRlBTIHZhbHVlIG9mIHRoZSBhbmltYXRpb24gdG8gYWR2YW5jZSBvbmNlIHBlciBmcmFtZSwgbm8gbWF0dGVyIHRoZSBzcGVlZCBvZiB0aGUgZnJhbWVzLiBEb2Vzbid0IHNraXAgYW55IGZyYW1lcy4qL1xyXG4gICAgRlJBTUVCQVNFRFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSG9sZHMgYSByZWZlcmVuY2UgdG8gYW4gW1tBbmltYXRpb25dXSBhbmQgY29udHJvbHMgaXQuIENvbnRyb2xzIHBsYXliYWNrIGFuZCBwbGF5bW9kZSBhcyB3ZWxsIGFzIHNwZWVkLlxyXG4gICAqIEBhdXRob3JzIEx1a2FzIFNjaGV1ZXJsZSwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIENvbXBvbmVudEFuaW1hdG9yIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRBbmltYXRvcik7XHJcbiAgICAvL1RPRE86IGFkZCBmdW5jdGlvbmFsaXR5IHRvIGJsZW5kIGZyb20gb25lIGFuaW1hdGlvbiB0byBhbm90aGVyLlxyXG4gICAgYW5pbWF0aW9uOiBBbmltYXRpb247XHJcbiAgICBwbGF5bW9kZTogQU5JTUFUSU9OX1BMQVlNT0RFO1xyXG4gICAgcGxheWJhY2s6IEFOSU1BVElPTl9QTEFZQkFDSztcclxuICAgIHNwZWVkU2NhbGVzV2l0aEdsb2JhbFNwZWVkOiBib29sZWFuID0gdHJ1ZTtcclxuXHJcbiAgICBwcml2YXRlIGxvY2FsVGltZTogVGltZTtcclxuICAgIHByaXZhdGUgc3BlZWRTY2FsZTogbnVtYmVyID0gMTtcclxuICAgIHByaXZhdGUgbGFzdFRpbWU6IG51bWJlciA9IDA7XHJcblxyXG4gICAgY29uc3RydWN0b3IoX2FuaW1hdGlvbjogQW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbihcIlwiKSwgX3BsYXltb2RlOiBBTklNQVRJT05fUExBWU1PREUgPSBBTklNQVRJT05fUExBWU1PREUuTE9PUCwgX3BsYXliYWNrOiBBTklNQVRJT05fUExBWUJBQ0sgPSBBTklNQVRJT05fUExBWUJBQ0suVElNRUJBU0VEX0NPTlRJTk9VUykge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLmFuaW1hdGlvbiA9IF9hbmltYXRpb247XHJcbiAgICAgIHRoaXMucGxheW1vZGUgPSBfcGxheW1vZGU7XHJcbiAgICAgIHRoaXMucGxheWJhY2sgPSBfcGxheWJhY2s7XHJcblxyXG4gICAgICB0aGlzLmxvY2FsVGltZSA9IG5ldyBUaW1lKCk7XHJcblxyXG4gICAgICAvL1RPRE86IHVwZGF0ZSBhbmltYXRpb24gdG90YWwgdGltZSB3aGVuIGxvYWRpbmcgYSBkaWZmZXJlbnQgYW5pbWF0aW9uP1xyXG4gICAgICB0aGlzLmFuaW1hdGlvbi5jYWxjdWxhdGVUb3RhbFRpbWUoKTtcclxuXHJcbiAgICAgIExvb3AuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5MT09QX0ZSQU1FLCB0aGlzLnVwZGF0ZUFuaW1hdGlvbkxvb3AuYmluZCh0aGlzKSk7XHJcbiAgICAgIFRpbWUuZ2FtZS5hZGRFdmVudExpc3RlbmVyKEVWRU5ULlRJTUVfU0NBTEVELCB0aGlzLnVwZGF0ZVNjYWxlLmJpbmQodGhpcykpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldCBzcGVlZChfczogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuc3BlZWRTY2FsZSA9IF9zO1xyXG4gICAgICB0aGlzLnVwZGF0ZVNjYWxlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBKdW1wcyB0byBhIGNlcnRhaW4gdGltZSBpbiB0aGUgYW5pbWF0aW9uIHRvIHBsYXkgZnJvbSB0aGVyZS5cclxuICAgICAqIEBwYXJhbSBfdGltZSBUaGUgdGltZSB0byBqdW1wIHRvXHJcbiAgICAgKi9cclxuICAgIGp1bXBUbyhfdGltZTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIHRoaXMubG9jYWxUaW1lLnNldChfdGltZSk7XHJcbiAgICAgIHRoaXMubGFzdFRpbWUgPSBfdGltZTtcclxuICAgICAgX3RpbWUgPSBfdGltZSAlIHRoaXMuYW5pbWF0aW9uLnRvdGFsVGltZTtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSB0aGlzLmFuaW1hdGlvbi5nZXRNdXRhdGVkKF90aW1lLCB0aGlzLmNhbGN1bGF0ZURpcmVjdGlvbihfdGltZSksIHRoaXMucGxheWJhY2spO1xyXG4gICAgICB0aGlzLmdldENvbnRhaW5lcigpLmFwcGx5QW5pbWF0aW9uKG11dGF0b3IpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCB0aW1lIG9mIHRoZSBhbmltYXRpb24sIG1vZHVsYXRlZCBmb3IgYW5pbWF0aW9uIGxlbmd0aC5cclxuICAgICAqL1xyXG4gICAgZ2V0Q3VycmVudFRpbWUoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMubG9jYWxUaW1lLmdldCgpICUgdGhpcy5hbmltYXRpb24udG90YWxUaW1lO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRm9yY2VzIGFuIHVwZGF0ZSBvZiB0aGUgYW5pbWF0aW9uIGZyb20gb3V0c2lkZS4gVXNlZCBpbiB0aGUgVmlld0FuaW1hdGlvbi4gU2hvdWxkbid0IGJlIHVzZWQgZHVyaW5nIHRoZSBnYW1lLlxyXG4gICAgICogQHBhcmFtIF90aW1lIHRoZSAodW5zY2FsZWQpIHRpbWUgdG8gdXBkYXRlIHRoZSBhbmltYXRpb24gd2l0aC5cclxuICAgICAqIEByZXR1cm5zIGEgVHVwZWwgY29udGFpbmluZyB0aGUgTXV0YXRvciBmb3IgQW5pbWF0aW9uIGFuZCB0aGUgcGxheW1vZGUgY29ycmVjdGVkIHRpbWUuIFxyXG4gICAgICovXHJcbiAgICB1cGRhdGVBbmltYXRpb24oX3RpbWU6IG51bWJlcik6IFtNdXRhdG9yLCBudW1iZXJdIHtcclxuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlQW5pbWF0aW9uTG9vcChudWxsLCBfdGltZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIHRyYW5zZmVyXHJcbiAgICBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzOiBTZXJpYWxpemF0aW9uID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIHNbXCJhbmltYXRpb25cIl0gPSB0aGlzLmFuaW1hdGlvbi5zZXJpYWxpemUoKTtcclxuICAgICAgc1tcInBsYXltb2RlXCJdID0gdGhpcy5wbGF5bW9kZTtcclxuICAgICAgc1tcInBsYXliYWNrXCJdID0gdGhpcy5wbGF5YmFjaztcclxuICAgICAgc1tcInNwZWVkU2NhbGVcIl0gPSB0aGlzLnNwZWVkU2NhbGU7XHJcbiAgICAgIHNbXCJzcGVlZFNjYWxlc1dpdGhHbG9iYWxTcGVlZFwiXSA9IHRoaXMuc3BlZWRTY2FsZXNXaXRoR2xvYmFsU3BlZWQ7XHJcblxyXG4gICAgICBzW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcblxyXG4gICAgICByZXR1cm4gcztcclxuICAgIH1cclxuXHJcbiAgICBkZXNlcmlhbGl6ZShfczogU2VyaWFsaXphdGlvbik6IFNlcmlhbGl6YWJsZSB7XHJcbiAgICAgIHRoaXMuYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbihcIlwiKTtcclxuICAgICAgdGhpcy5hbmltYXRpb24uZGVzZXJpYWxpemUoX3MuYW5pbWF0aW9uKTtcclxuICAgICAgdGhpcy5wbGF5YmFjayA9IF9zLnBsYXliYWNrO1xyXG4gICAgICB0aGlzLnBsYXltb2RlID0gX3MucGxheW1vZGU7XHJcbiAgICAgIHRoaXMuc3BlZWRTY2FsZSA9IF9zLnNwZWVkU2NhbGU7XHJcbiAgICAgIHRoaXMuc3BlZWRTY2FsZXNXaXRoR2xvYmFsU3BlZWQgPSBfcy5zcGVlZFNjYWxlc1dpdGhHbG9iYWxTcGVlZDtcclxuXHJcbiAgICAgIHN1cGVyLmRlc2VyaWFsaXplKF9zW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gdXBkYXRlQW5pbWF0aW9uXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIEFuaW1hdGlvbi5cclxuICAgICAqIEdldHMgY2FsbGVkIGV2ZXJ5IHRpbWUgdGhlIExvb3AgZmlyZXMgdGhlIExPT1BfRlJBTUUgRXZlbnQuXHJcbiAgICAgKiBVc2VzIHRoZSBidWlsdC1pbiB0aW1lIHVubGVzcyBhIGRpZmZlcmVudCB0aW1lIGlzIHNwZWNpZmllZC5cclxuICAgICAqIE1heSBhbHNvIGJlIGNhbGxlZCBmcm9tIHVwZGF0ZUFuaW1hdGlvbigpLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHVwZGF0ZUFuaW1hdGlvbkxvb3AoX2U6IEV2ZW50LCBfdGltZTogbnVtYmVyKTogW011dGF0b3IsIG51bWJlcl0ge1xyXG4gICAgICBpZiAodGhpcy5hbmltYXRpb24udG90YWxUaW1lID09IDApXHJcbiAgICAgICAgcmV0dXJuIFtudWxsLCAwXTtcclxuICAgICAgbGV0IHRpbWU6IG51bWJlciA9IF90aW1lIHx8IHRoaXMubG9jYWxUaW1lLmdldCgpO1xyXG4gICAgICBpZiAodGhpcy5wbGF5YmFjayA9PSBBTklNQVRJT05fUExBWUJBQ0suRlJBTUVCQVNFRCkge1xyXG4gICAgICAgIHRpbWUgPSB0aGlzLmxhc3RUaW1lICsgKDEwMDAgLyB0aGlzLmFuaW1hdGlvbi5mcHMpO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCBkaXJlY3Rpb246IG51bWJlciA9IHRoaXMuY2FsY3VsYXRlRGlyZWN0aW9uKHRpbWUpO1xyXG4gICAgICB0aW1lID0gdGhpcy5hcHBseVBsYXltb2Rlcyh0aW1lKTtcclxuICAgICAgdGhpcy5leGVjdXRlRXZlbnRzKHRoaXMuYW5pbWF0aW9uLmdldEV2ZW50c1RvRmlyZSh0aGlzLmxhc3RUaW1lLCB0aW1lLCB0aGlzLnBsYXliYWNrLCBkaXJlY3Rpb24pKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLmxhc3RUaW1lICE9IHRpbWUpIHtcclxuICAgICAgICB0aGlzLmxhc3RUaW1lID0gdGltZTtcclxuICAgICAgICB0aW1lID0gdGltZSAlIHRoaXMuYW5pbWF0aW9uLnRvdGFsVGltZTtcclxuICAgICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHRoaXMuYW5pbWF0aW9uLmdldE11dGF0ZWQodGltZSwgZGlyZWN0aW9uLCB0aGlzLnBsYXliYWNrKTtcclxuICAgICAgICBpZiAodGhpcy5nZXRDb250YWluZXIoKSkge1xyXG4gICAgICAgICAgdGhpcy5nZXRDb250YWluZXIoKS5hcHBseUFuaW1hdGlvbihtdXRhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFttdXRhdG9yLCB0aW1lXTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gW251bGwsIHRpbWVdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZXMgYWxsIGN1c3RvbSBldmVudHMgdGhlIEFuaW1hdGlvbiBzaG91bGQgaGF2ZSBmaXJlZCBiZXR3ZWVuIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGUgY3VycmVudCBmcmFtZS5cclxuICAgICAqIEBwYXJhbSBldmVudHMgYSBsaXN0IG9mIG5hbWVzIG9mIGN1c3RvbSBldmVudHMgdG8gZmlyZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGV4ZWN1dGVFdmVudHMoZXZlbnRzOiBzdHJpbmdbXSk6IHZvaWQge1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChldmVudHNbaV0pKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgYWN0dWFsIHRpbWUgdG8gdXNlLCB1c2luZyB0aGUgY3VycmVudCBwbGF5bW9kZXMuXHJcbiAgICAgKiBAcGFyYW0gX3RpbWUgdGhlIHRpbWUgdG8gYXBwbHkgdGhlIHBsYXltb2RlcyB0b1xyXG4gICAgICogQHJldHVybnMgdGhlIHJlY2FsY3VsYXRlZCB0aW1lXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYXBwbHlQbGF5bW9kZXMoX3RpbWU6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgIHN3aXRjaCAodGhpcy5wbGF5bW9kZSkge1xyXG4gICAgICAgIGNhc2UgQU5JTUFUSU9OX1BMQVlNT0RFLlNUT1A6XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbFRpbWUuZ2V0T2Zmc2V0KCk7XHJcbiAgICAgICAgY2FzZSBBTklNQVRJT05fUExBWU1PREUuUExBWU9OQ0U6XHJcbiAgICAgICAgICBpZiAoX3RpbWUgPj0gdGhpcy5hbmltYXRpb24udG90YWxUaW1lKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRpb24udG90YWxUaW1lIC0gMC4wMTsgICAgIC8vVE9ETzogdGhpcyBtaWdodCBjYXVzZSBzb21lIGlzc3Vlc1xyXG4gICAgICAgICAgZWxzZSByZXR1cm4gX3RpbWU7XHJcbiAgICAgICAgY2FzZSBBTklNQVRJT05fUExBWU1PREUuUExBWU9OQ0VTVE9QQUZURVI6XHJcbiAgICAgICAgICBpZiAoX3RpbWUgPj0gdGhpcy5hbmltYXRpb24udG90YWxUaW1lKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRpb24udG90YWxUaW1lICsgMC4wMTsgICAgIC8vVE9ETzogdGhpcyBtaWdodCBjYXVzZSBzb21lIGlzc3Vlc1xyXG4gICAgICAgICAgZWxzZSByZXR1cm4gX3RpbWU7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHJldHVybiBfdGltZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyBhbmQgcmV0dXJucyB0aGUgZGlyZWN0aW9uIHRoZSBhbmltYXRpb24gc2hvdWxkIGN1cnJlbnRseSBiZSBwbGF5aW5nIGluLlxyXG4gICAgICogQHBhcmFtIF90aW1lIHRoZSB0aW1lIGF0IHdoaWNoIHRvIGNhbGN1bGF0ZSB0aGUgZGlyZWN0aW9uXHJcbiAgICAgKiBAcmV0dXJucyAxIGlmIGZvcndhcmQsIDAgaWYgc3RvcCwgLTEgaWYgYmFja3dhcmRzXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY2FsY3VsYXRlRGlyZWN0aW9uKF90aW1lOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICBzd2l0Y2ggKHRoaXMucGxheW1vZGUpIHtcclxuICAgICAgICBjYXNlIEFOSU1BVElPTl9QTEFZTU9ERS5TVE9QOlxyXG4gICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgLy8gY2FzZSBBTklNQVRJT05fUExBWU1PREUuUElOR1BPTkc6XHJcbiAgICAgICAgLy8gICBpZiAoTWF0aC5mbG9vcihfdGltZSAvIHRoaXMuYW5pbWF0aW9uLnRvdGFsVGltZSkgJSAyID09IDApXHJcbiAgICAgICAgLy8gICAgIHJldHVybiAxO1xyXG4gICAgICAgIC8vICAgZWxzZVxyXG4gICAgICAgIC8vICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgY2FzZSBBTklNQVRJT05fUExBWU1PREUuUkVWRVJTRUxPT1A6XHJcbiAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgY2FzZSBBTklNQVRJT05fUExBWU1PREUuUExBWU9OQ0U6XHJcbiAgICAgICAgY2FzZSBBTklNQVRJT05fUExBWU1PREUuUExBWU9OQ0VTVE9QQUZURVI6XHJcbiAgICAgICAgICBpZiAoX3RpbWUgPj0gdGhpcy5hbmltYXRpb24udG90YWxUaW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgc2NhbGUgb2YgdGhlIGFuaW1hdGlvbiBpZiB0aGUgdXNlciBjaGFuZ2VzIGl0IG9yIGlmIHRoZSBnbG9iYWwgZ2FtZSB0aW1lciBjaGFuZ2VkIGl0cyBzY2FsZS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSB1cGRhdGVTY2FsZSgpOiB2b2lkIHtcclxuICAgICAgbGV0IG5ld1NjYWxlOiBudW1iZXIgPSB0aGlzLnNwZWVkU2NhbGU7XHJcbiAgICAgIGlmICh0aGlzLnNwZWVkU2NhbGVzV2l0aEdsb2JhbFNwZWVkKVxyXG4gICAgICAgIG5ld1NjYWxlICo9IFRpbWUuZ2FtZS5nZXRTY2FsZSgpO1xyXG4gICAgICB0aGlzLmxvY2FsVGltZS5zZXRTY2FsZShuZXdTY2FsZSk7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgZW51bSBBVURJT19QQU5ORVIge1xyXG4gICAgQ09ORV9JTk5FUl9BTkdMRSA9IFwiY29uZUlubmVyQW5nbGVcIixcclxuICAgIENPTkVfT1VURVJfQU5HTEUgPSBcImNvbmVPdXRlckFuZ2xlXCIsXHJcbiAgICBDT05FX09VVEVSX0dBSU4gPSBcImNvbmVPdXRlckdhaW5cIixcclxuICAgIERJU1RBTkNFX01PREVMID0gXCJkaXN0YW5jZU1vZGVsXCIsXHJcbiAgICBNQVhfRElTVEFOQ0UgPSBcIm1heERpc3RhbmNlXCIsXHJcbiAgICBQQU5OSU5HX01PREVMID0gXCJwYW5uaW5nTW9kZWxcIixcclxuICAgIFJFRl9ESVNUQU5DRSA9IFwicmVmRGlzdGFuY2VcIixcclxuICAgIFJPTExPRkZfRkFDVE9SID0gXCJyb2xsb2ZmRmFjdG9yXCJcclxuICB9XHJcblxyXG4gIGV4cG9ydCBlbnVtIEFVRElPX05PREVfVFlQRSB7XHJcbiAgICBTT1VSQ0UsIFBBTk5FUiwgR0FJTlxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQnVpbGRzIGEgbWluaW1hbCBhdWRpbyBncmFwaCAoYnkgZGVmYXVsdCBpbiBbW0F1ZGlvTWFuYWdlcl1dLmRlZmF1bHQpIGFuZCBzeW5jaHJvbml6ZXMgaXQgd2l0aCB0aGUgY29udGFpbmluZyBbW05vZGVdXVxyXG4gICAqIGBgYHBsYWludGV4dFxyXG4gICAqIOKUjCBBdWRpb01hbmFnZXIoLmRlZmF1bHQpIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxyXG4gICAqIOKUgiDilIwgQ29tcG9uZW50QXVkaW8g4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQICAgICAgICAgIOKUglxyXG4gICAqIOKUgiDilIIgICAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSQICAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSQICAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSQIOKUgiDilIzilIDilIDilIDilIDilIDilIDilJAg4pSCICBcclxuICAgKiDilIIg4pSCICAgIOKUgnNvdXJjZeKUgiDihpIg4pSCcGFubmVy4pSCIOKGkiDilIIgZ2FpbiDilIIg4oaSIOKUgiBnYWluIOKUgiDilIJcclxuICAgKiDilIIg4pSCICAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUmCDilIIg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSYIOKUgiAgXHJcbiAgICog4pSCIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgICAgICAgICDilIJcclxuICAgKiDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcclxuICAgKiBgYGBcclxuICAgKiBAYXV0aG9ycyBUaG9tYXMgRG9ybmVyLCBIRlUsIDIwMTkgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb21wb25lbnRBdWRpbyBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gQ29tcG9uZW50LnJlZ2lzdGVyU3ViY2xhc3MoQ29tcG9uZW50QXVkaW8pO1xyXG4gICAgLyoqIHBsYWNlcyBhbmQgZGlyZWN0cyB0aGUgcGFubmVyIHJlbGF0aXZlIHRvIHRoZSB3b3JsZCB0cmFuc2Zvcm0gb2YgdGhlIFtbTm9kZV1dICAqL1xyXG4gICAgcHVibGljIHBpdm90OiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKTtcclxuICAgIFxyXG4gICAgcHJvdGVjdGVkIHNpbmdsZXRvbjogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgXHJcbiAgICBwcml2YXRlIGdhaW46IEdhaW5Ob2RlO1xyXG4gICAgcHJpdmF0ZSBwYW5uZXI6IFBhbm5lck5vZGU7XHJcbiAgICBwcml2YXRlIHNvdXJjZTogQXVkaW9CdWZmZXJTb3VyY2VOb2RlO1xyXG4gICAgcHJpdmF0ZSBhdWRpb01hbmFnZXI6IEF1ZGlvTWFuYWdlcjtcclxuICAgIHByaXZhdGUgcGxheWluZzogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgcHJpdmF0ZSBsaXN0ZW5lZDogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKF9hdWRpbzogQXVkaW8gPSBudWxsLCBfbG9vcDogYm9vbGVhbiA9IGZhbHNlLCBfc3RhcnQ6IGJvb2xlYW4gPSBmYWxzZSwgX2F1ZGlvTWFuYWdlcjogQXVkaW9NYW5hZ2VyID0gQXVkaW9NYW5hZ2VyLmRlZmF1bHQpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5pbnN0YWxsKF9hdWRpb01hbmFnZXIpO1xyXG4gICAgICB0aGlzLmNyZWF0ZVNvdXJjZShfYXVkaW8sIF9sb29wKTtcclxuXHJcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5DT01QT05FTlRfQURELCB0aGlzLmhhbmRsZUF0dGFjaCk7XHJcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5DT01QT05FTlRfUkVNT1ZFLCB0aGlzLmhhbmRsZUF0dGFjaCk7XHJcblxyXG4gICAgICBpZiAoX3N0YXJ0KVxyXG4gICAgICAgIHRoaXMucGxheShfc3RhcnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXQgYXVkaW8oX2F1ZGlvOiBBdWRpbykge1xyXG4gICAgICB0aGlzLnNvdXJjZS5idWZmZXIgPSBfYXVkaW87XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBhdWRpbygpOiBBdWRpbyB7XHJcbiAgICAgIHJldHVybiA8QXVkaW8+dGhpcy5zb3VyY2UuYnVmZmVyO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXQgdm9sdW1lKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuZ2Fpbi5nYWluLnZhbHVlID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgdm9sdW1lKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdhaW4uZ2Fpbi52YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgcHJvcGVydHkgb2YgdGhlIHBhbm5lciB0byB0aGUgZ2l2ZW4gdmFsdWUuIFVzZSB0byBtYW5pcHVsYXRlIHJhbmdlIGFuZCByb2xsb2ZmIGV0Yy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFBhbm5lcihfcHJvcGVydHk6IEFVRElPX1BBTk5FUiwgX3ZhbHVlOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLnBhbm5lciwgeyBbX3Byb3BlcnR5XTogX3ZhbHVlIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE86IG1heSBiZSB1c2VkIGZvciBzZXJpYWxpemF0aW9uIG9mIEF1ZGlvTm9kZXNcclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yT2ZOb2RlKF90eXBlOiBBVURJT19OT0RFX1RZUEUpOiBNdXRhdG9yIHtcclxuICAgICAgbGV0IG5vZGU6IEF1ZGlvTm9kZSA9IHRoaXMuZ2V0QXVkaW9Ob2RlKF90eXBlKTtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSBnZXRNdXRhdG9yT2ZBcmJpdHJhcnkobm9kZSk7XHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc3BlY2lmaWVkIEF1ZGlvTm9kZSBvZiB0aGUgc3RhbmRhcmQgZ3JhcGggZm9yIGZ1cnRoZXIgbWFuaXB1bGF0aW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRBdWRpb05vZGUoX3R5cGU6IEFVRElPX05PREVfVFlQRSk6IEF1ZGlvTm9kZSB7XHJcbiAgICAgIHN3aXRjaCAoX3R5cGUpIHtcclxuICAgICAgICBjYXNlIEFVRElPX05PREVfVFlQRS5TT1VSQ0U6IHJldHVybiB0aGlzLnNvdXJjZTtcclxuICAgICAgICBjYXNlIEFVRElPX05PREVfVFlQRS5QQU5ORVI6IHJldHVybiB0aGlzLnBhbm5lcjtcclxuICAgICAgICBjYXNlIEFVRElPX05PREVfVFlQRS5HQUlOOiByZXR1cm4gdGhpcy5nYWluO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydCBvciBzdG9wIHBsYXlpbmcgdGhlIGF1ZGlvXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwbGF5KF9vbjogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICBpZiAoX29uKSB7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVTb3VyY2UodGhpcy5hdWRpbywgdGhpcy5zb3VyY2UubG9vcCk7XHJcbiAgICAgICAgdGhpcy5zb3VyY2Uuc3RhcnQoMCwgMCk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZVxyXG4gICAgICAgIHRoaXMuc291cmNlLnN0b3AoKTtcclxuICAgICAgdGhpcy5wbGF5aW5nID0gX29uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgaXNQbGF5aW5nKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy5wbGF5aW5nO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGdldCBpc0F0dGFjaGVkKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy5nZXRDb250YWluZXIoKSAhPSBudWxsO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGdldCBpc0xpc3RlbmVkKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy5saXN0ZW5lZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW5zZXJ0cyBBdWRpb05vZGVzIGJldHdlZW4gdGhlIHBhbm5lciBhbmQgdGhlIGxvY2FsIGdhaW4gb2YgdGhpcyBbW0NvbXBvbmVudEF1ZGlvXV1cclxuICAgICAqIF9pbnB1dCBhbmQgX291dHB1dCBtYXkgYmUgdGhlIHNhbWUgQXVkaW9Ob2RlLCBpZiB0aGVyZSBpcyBvbmx5IG9uZSB0byBpbnNlcnQsXHJcbiAgICAgKiBvciBtYXkgaGF2ZSBtdWx0aXBsZSBBdWRpb05vZGUgYmV0d2VlbiB0aGVtIHRvIGNyZWF0ZSBhbiBlZmZlY3QtZ3JhcGguXFxcclxuICAgICAqIE5vdGUgdGhhdCBbW0NvbXBvbmVudEF1ZGlvXV0gZG9lcyBub3Qga2VlcCB0cmFjayBvZiBpbnNlcnRlZCBBdWRpb05vZGVzIVxyXG4gICAgICogYGBgcGxhaW50ZXh0XHJcbiAgICAgKiDilIwgQXVkaW9NYW5hZ2VyKC5kZWZhdWx0KSDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcclxuICAgICAqIOKUgiDilIwgQ29tcG9uZW50QXVkaW8g4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQICAgICAgICAgIOKUglxyXG4gICAgICog4pSCIOKUgiAgICDilIzilIDilIDilIDilIDilIDilIDilJAgICDilIzilIDilIDilIDilIDilIDilIDilJAgICDilIzilIDilIDilIDilIDilIDilIDilJAgICAgICAgICAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQICAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSQIOKUgiDilIzilIDilIDilIDilIDilIDilIDilJAg4pSCICBcclxuICAgICAqIOKUgiDilIIgICAg4pSCc291cmNl4pSCIOKGkiDilIJwYW5uZXLilIIg4oaSIOKUgl9pbnB1dOKUgiDihpIgLi4uICDihpIg4pSCX291dHB1dOKUgiDihpIg4pSCIGdhaW4g4pSCIOKGkiDilIIgZ2FpbiDilIIg4pSCXHJcbiAgICAgKiDilIIg4pSCICAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgICAgICAgICDilJTilIDilIDilIDilIDilIDilIDilIDilJggICDilJTilIDilIDilIDilIDilIDilIDilJgg4pSCIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUmCDilIIgIFxyXG4gICAgICog4pSCIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgICAgICAgICDilIJcclxuICAgICAqIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpbnNlcnRBdWRpb05vZGVzKF9pbnB1dDogQXVkaW9Ob2RlLCBfb3V0cHV0OiBBdWRpb05vZGUpOiB2b2lkIHtcclxuICAgICAgdGhpcy5wYW5uZXIuZGlzY29ubmVjdCgwKTtcclxuICAgICAgaWYgKCFfaW5wdXQgJiYgIV9vdXRwdXQpIHtcclxuICAgICAgICB0aGlzLnBhbm5lci5jb25uZWN0KHRoaXMuZ2Fpbik7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMucGFubmVyLmNvbm5lY3QoX2lucHV0KTtcclxuICAgICAgX291dHB1dC5jb25uZWN0KHRoaXMuZ2Fpbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBY3RpdmF0ZSBvdmVycmlkZS4gQ29ubmVjdHMgb3IgZGlzY29ubmVjdHMgQXVkaW9Ob2Rlc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWN0aXZhdGUoX29uOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgIHN1cGVyLmFjdGl2YXRlKF9vbik7XHJcbiAgICAgIHRoaXMudXBkYXRlQ29ubmVjdGlvbigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29ubmVjdHMgdGhpcyBjb21wb25lbnRzIGdhaW4tbm9kZSB0byB0aGUgZ2FpbiBub2RlIG9mIHRoZSBBdWRpb01hbmFnZXIgdGhpcyBjb21wb25lbnQgcnVucyBvbi5cclxuICAgICAqIE9ubHkgY2FsbCB0aGlzIG1ldGhvZCBpZiB0aGUgY29tcG9uZW50IGlzIG5vdCBhdHRhY2hlZCB0byBhIFtbTm9kZV1dIGJ1dCBuZWVkcyB0byBiZSBoZWFyZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGNvbm5lY3QoX29uOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgIGlmIChfb24pXHJcbiAgICAgICAgdGhpcy5nYWluLmNvbm5lY3QodGhpcy5hdWRpb01hbmFnZXIuZ2Fpbik7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICB0aGlzLmdhaW4uZGlzY29ubmVjdCh0aGlzLmF1ZGlvTWFuYWdlci5nYWluKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGluc3RhbGwoX2F1ZGlvTWFuYWdlcjogQXVkaW9NYW5hZ2VyID0gQXVkaW9NYW5hZ2VyLmRlZmF1bHQpOiB2b2lkIHtcclxuICAgICAgbGV0IGFjdGl2ZTogYm9vbGVhbiA9IHRoaXMuaXNBY3RpdmU7XHJcbiAgICAgIHRoaXMuYWN0aXZhdGUoZmFsc2UpO1xyXG4gICAgICB0aGlzLmF1ZGlvTWFuYWdlciA9IF9hdWRpb01hbmFnZXI7XHJcbiAgICAgIHRoaXMucGFubmVyID0gX2F1ZGlvTWFuYWdlci5jcmVhdGVQYW5uZXIoKTtcclxuICAgICAgdGhpcy5nYWluID0gX2F1ZGlvTWFuYWdlci5jcmVhdGVHYWluKCk7XHJcbiAgICAgIHRoaXMucGFubmVyLmNvbm5lY3QodGhpcy5nYWluKTtcclxuICAgICAgdGhpcy5nYWluLmNvbm5lY3QoX2F1ZGlvTWFuYWdlci5nYWluKTtcclxuICAgICAgdGhpcy5hY3RpdmF0ZShhY3RpdmUpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgY3JlYXRlU291cmNlKF9hdWRpbzogQXVkaW8sIF9sb29wOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgIGlmICh0aGlzLnNvdXJjZSkge1xyXG4gICAgICAgIHRoaXMuc291cmNlLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICB0aGlzLnNvdXJjZS5idWZmZXIgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuc291cmNlID0gdGhpcy5hdWRpb01hbmFnZXIuY3JlYXRlQnVmZmVyU291cmNlKCk7XHJcbiAgICAgIHRoaXMuc291cmNlLmNvbm5lY3QodGhpcy5wYW5uZXIpO1xyXG5cclxuICAgICAgaWYgKF9hdWRpbylcclxuICAgICAgICB0aGlzLmF1ZGlvID0gX2F1ZGlvO1xyXG4gICAgICB0aGlzLnNvdXJjZS5sb29wID0gX2xvb3A7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSB1cGRhdGVDb25uZWN0aW9uKCk6IHZvaWQge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuY29ubmVjdCh0aGlzLmlzQWN0aXZlICYmIHRoaXMuaXNBdHRhY2hlZCAmJiB0aGlzLmxpc3RlbmVkKTtcclxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XHJcbiAgICAgICAgLy8gbm9wXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBBdXRvbWF0aWNhbGx5IGNvbm5lY3RzL2Rpc2Nvbm5lY3RzIEF1ZGlvTm9kZXMgd2hlbiBhZGRpbmcvcmVtb3ZpbmcgdGhpcyBjb21wb25lbnQgdG8vZnJvbSBhIG5vZGUuIFxyXG4gICAgICogVGhlcmVmb3JlIHVudXNlZCBBdWRpb05vZGVzIG1heSBiZSBnYXJiYWdlIGNvbGxlY3RlZCB3aGVuIGFuIHVudXNlZCBjb21wb25lbnQgaXMgY29sbGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgaGFuZGxlQXR0YWNoID0gKF9ldmVudDogRXZlbnQpOiB2b2lkID0+IHtcclxuICAgICAgLy8gRGVidWcubG9nKF9ldmVudCk7XHJcbiAgICAgIGlmIChfZXZlbnQudHlwZSA9PSBFVkVOVC5DT01QT05FTlRfQUREKSB7XHJcbiAgICAgICAgdGhpcy5nZXRDb250YWluZXIoKS5hZGRFdmVudExpc3RlbmVyKEVWRU5UX0FVRElPLkNISUxEX0FQUEVORCwgdGhpcy5oYW5kbGVHcmFwaCwgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5nZXRDb250YWluZXIoKS5hZGRFdmVudExpc3RlbmVyKEVWRU5UX0FVRElPLkNISUxEX1JFTU9WRSwgdGhpcy5oYW5kbGVHcmFwaCwgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5nZXRDb250YWluZXIoKS5hZGRFdmVudExpc3RlbmVyKEVWRU5UX0FVRElPLlVQREFURSwgdGhpcy51cGRhdGUsIHRydWUpO1xyXG4gICAgICAgIHRoaXMubGlzdGVuZWQgPSB0aGlzLmdldENvbnRhaW5lcigpLmlzRGVzY2VuZGFudE9mKEF1ZGlvTWFuYWdlci5kZWZhdWx0LmdldEdyYXBoTGlzdGVuaW5nVG8oKSk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgdGhpcy5nZXRDb250YWluZXIoKS5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5UX0FVRElPLkNISUxEX0FQUEVORCwgdGhpcy5oYW5kbGVHcmFwaCwgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5nZXRDb250YWluZXIoKS5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5UX0FVRElPLkNISUxEX1JFTU9WRSwgdGhpcy5oYW5kbGVHcmFwaCwgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5nZXRDb250YWluZXIoKS5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5UX0FVRElPLlVQREFURSwgdGhpcy51cGRhdGUsIHRydWUpO1xyXG4gICAgICAgIHRoaXMubGlzdGVuZWQgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnVwZGF0ZUNvbm5lY3Rpb24oKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBBdXRvbWF0aWNhbGx5IGNvbm5lY3RzL2Rpc2Nvbm5lY3RzIEF1ZGlvTm9kZXMgd2hlbiBhcHBlbmRpbmcvcmVtb3ZpbmcgdGhlIEZVREdFLWdyYXBoIHRoZSBjb21wb25lbnQgaXMgaW4uIFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGhhbmRsZUdyYXBoID0gKF9ldmVudDogRXZlbnQpOiB2b2lkID0+IHtcclxuICAgICAgLy8gRGVidWcubG9nKF9ldmVudCk7XHJcbiAgICAgIHRoaXMubGlzdGVuZWQgPSAoX2V2ZW50LnR5cGUgPT0gRVZFTlRfQVVESU8uQ0hJTERfQVBQRU5EKTtcclxuICAgICAgdGhpcy51cGRhdGVDb25uZWN0aW9uKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogVXBkYXRlcyB0aGUgcGFubmVyIG5vZGUsIGl0cyBwb3NpdGlvbiBhbmQgZGlyZWN0aW9uLCB1c2luZyB0aGUgd29ybGRtYXRyaXggb2YgdGhlIGNvbnRhaW5lciBhbmQgdGhlIHBpdm90IG9mIHRoaXMgY29tcG9uZW50LiBcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSB1cGRhdGUgPSAoX2V2ZW50OiBFdmVudCk6IHZvaWQgPT4ge1xyXG4gICAgICBsZXQgbXR4UmVzdWx0OiBNYXRyaXg0eDQgPSB0aGlzLnBpdm90O1xyXG4gICAgICBpZiAodGhpcy5nZXRDb250YWluZXIoKSlcclxuICAgICAgICBtdHhSZXN1bHQgPSBNYXRyaXg0eDQuTVVMVElQTElDQVRJT04odGhpcy5nZXRDb250YWluZXIoKS5tdHhXb3JsZCwgdGhpcy5waXZvdCk7XHJcblxyXG4gICAgICAvLyBEZWJ1Zy5sb2cobXR4UmVzdWx0LnRvU3RyaW5nKCkpO1xyXG4gICAgICBsZXQgcG9zaXRpb246IFZlY3RvcjMgPSBtdHhSZXN1bHQudHJhbnNsYXRpb247XHJcbiAgICAgIGxldCBmb3J3YXJkOiBWZWN0b3IzID0gVmVjdG9yMy5UUkFOU0ZPUk1BVElPTihWZWN0b3IzLlooMSksIG10eFJlc3VsdCwgZmFsc2UpO1xyXG5cclxuICAgICAgdGhpcy5wYW5uZXIucG9zaXRpb25YLnZhbHVlID0gcG9zaXRpb24ueDtcclxuICAgICAgdGhpcy5wYW5uZXIucG9zaXRpb25ZLnZhbHVlID0gcG9zaXRpb24ueTtcclxuICAgICAgdGhpcy5wYW5uZXIucG9zaXRpb25aLnZhbHVlID0gcG9zaXRpb24uejtcclxuXHJcbiAgICAgIHRoaXMucGFubmVyLm9yaWVudGF0aW9uWC52YWx1ZSA9IGZvcndhcmQueDtcclxuICAgICAgdGhpcy5wYW5uZXIub3JpZW50YXRpb25ZLnZhbHVlID0gZm9yd2FyZC55O1xyXG4gICAgICB0aGlzLnBhbm5lci5vcmllbnRhdGlvbloudmFsdWUgPSBmb3J3YXJkLno7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogU2VydmVzIHRvIHNldCB0aGUgc3BhdGlhbCBsb2NhdGlvbiBhbmQgb3JpZW50YXRpb24gb2YgQXVkaW9MaXN0ZW5lcnMgcmVsYXRpdmUgdG8gdGhlXHJcbiAgICogd29ybGQgdHJhbnNmb3JtIG9mIHRoZSBbW05vZGVdXSBpdCBpcyBhdHRhY2hlZCB0by5cclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb21wb25lbnRBdWRpb0xpc3RlbmVyIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRBdWRpb0xpc3RlbmVyKTtcclxuICAgIHB1YmxpYyBwaXZvdDogTWF0cml4NHg0ID0gTWF0cml4NHg0LklERU5USVRZKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBwb3NpdGlvbiBhbmQgb3JpZW50YXRpb24gb2YgdGhlIGdpdmVuIEF1ZGlvTGlzdGVuZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIHVwZGF0ZShfbGlzdGVuZXI6IEF1ZGlvTGlzdGVuZXIpOiB2b2lkIHtcclxuICAgICAgbGV0IG10eFJlc3VsdDogTWF0cml4NHg0ID0gdGhpcy5waXZvdDtcclxuICAgICAgaWYgKHRoaXMuZ2V0Q29udGFpbmVyKCkpXHJcbiAgICAgICAgbXR4UmVzdWx0ID0gTWF0cml4NHg0Lk1VTFRJUExJQ0FUSU9OKHRoaXMuZ2V0Q29udGFpbmVyKCkubXR4V29ybGQsIHRoaXMucGl2b3QpO1xyXG5cclxuICAgICAgLy8gRGVidWcubG9nKG10eFJlc3VsdC50b1N0cmluZygpKTtcclxuICAgICAgbGV0IHBvc2l0aW9uOiBWZWN0b3IzID0gbXR4UmVzdWx0LnRyYW5zbGF0aW9uO1xyXG4gICAgICBsZXQgZm9yd2FyZDogVmVjdG9yMyA9IFZlY3RvcjMuVFJBTlNGT1JNQVRJT04oVmVjdG9yMy5aKDEpLCBtdHhSZXN1bHQsIGZhbHNlKTtcclxuICAgICAgbGV0IHVwOiBWZWN0b3IzID0gVmVjdG9yMy5UUkFOU0ZPUk1BVElPTihWZWN0b3IzLlkoKSwgbXR4UmVzdWx0LCBmYWxzZSk7XHJcblxyXG4gICAgICBfbGlzdGVuZXIucG9zaXRpb25YLnZhbHVlID0gcG9zaXRpb24ueDtcclxuICAgICAgX2xpc3RlbmVyLnBvc2l0aW9uWS52YWx1ZSA9IHBvc2l0aW9uLnk7XHJcbiAgICAgIF9saXN0ZW5lci5wb3NpdGlvbloudmFsdWUgPSBwb3NpdGlvbi56O1xyXG5cclxuICAgICAgX2xpc3RlbmVyLmZvcndhcmRYLnZhbHVlID0gZm9yd2FyZC54O1xyXG4gICAgICBfbGlzdGVuZXIuZm9yd2FyZFkudmFsdWUgPSBmb3J3YXJkLnk7XHJcbiAgICAgIF9saXN0ZW5lci5mb3J3YXJkWi52YWx1ZSA9IGZvcndhcmQuejtcclxuXHJcbiAgICAgIF9saXN0ZW5lci51cFgudmFsdWUgPSB1cC54O1xyXG4gICAgICBfbGlzdGVuZXIudXBZLnZhbHVlID0gdXAueTtcclxuICAgICAgX2xpc3RlbmVyLnVwWi52YWx1ZSA9IHVwLno7XHJcblxyXG4gICAgICAvLyBEZWJ1Zy5sb2cobXR4UmVzdWx0LnRyYW5zbGF0aW9uLnRvU3RyaW5nKCksIGZvcndhcmQudG9TdHJpbmcoKSwgdXAudG9TdHJpbmcoKSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsIi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiQ29tcG9uZW50LnRzXCIvPlxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgZW51bSBGSUVMRF9PRl9WSUVXIHtcclxuICAgIEhPUklaT05UQUwsIFZFUlRJQ0FMLCBESUFHT05BTFxyXG4gIH1cclxuICAvKipcclxuICAgKiBEZWZpbmVzIGlkZW50aWZpZXJzIGZvciB0aGUgdmFyaW91cyBwcm9qZWN0aW9ucyBhIGNhbWVyYSBjYW4gcHJvdmlkZS4gIFxyXG4gICAqIFRPRE86IGNoYW5nZSBiYWNrIHRvIG51bWJlciBlbnVtIGlmIHN0cmluZ3Mgbm90IG5lZWRlZFxyXG4gICAqL1xyXG4gIGV4cG9ydCBlbnVtIFBST0pFQ1RJT04ge1xyXG4gICAgQ0VOVFJBTCA9IFwiY2VudHJhbFwiLFxyXG4gICAgT1JUSE9HUkFQSElDID0gXCJvcnRob2dyYXBoaWNcIixcclxuICAgIERJTUVUUklDID0gXCJkaW1ldHJpY1wiLFxyXG4gICAgU1RFUkVPID0gXCJzdGVyZW9cIlxyXG4gIH1cclxuICAvKipcclxuICAgKiBUaGUgY2FtZXJhIGNvbXBvbmVudCBob2xkcyB0aGUgcHJvamVjdGlvbi1tYXRyaXggYW5kIG90aGVyIGRhdGEgbmVlZGVkIHRvIHJlbmRlciBhIHNjZW5lIGZyb20gdGhlIHBlcnNwZWN0aXZlIG9mIHRoZSBub2RlIGl0IGlzIGF0dGFjaGVkIHRvLlxyXG4gICAqIEBhdXRob3JzIEphc2NoYSBLYXJhZ8O2bCwgSEZVLCAyMDE5IHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29tcG9uZW50Q2FtZXJhIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRDYW1lcmEpO1xyXG4gICAgcHVibGljIHBpdm90OiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKTtcclxuICAgIHB1YmxpYyBiYWNrZ3JvdW5kQ29sb3I6IENvbG9yID0gbmV3IENvbG9yKDAsIDAsIDAsIDEpOyAvLyBUaGUgY29sb3Igb2YgdGhlIGJhY2tncm91bmQgdGhlIGNhbWVyYSB3aWxsIHJlbmRlci5cclxuICAgIC8vcHJpdmF0ZSBvcnRob2dyYXBoaWM6IGJvb2xlYW4gPSBmYWxzZTsgLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBpbWFnZSB3aWxsIGJlIHJlbmRlcmVkIHdpdGggcGVyc3BlY3RpdmUgb3Igb3J0aG9ncmFwaGljIHByb2plY3Rpb24uXHJcbiAgICBwcml2YXRlIHByb2plY3Rpb246IFBST0pFQ1RJT04gPSBQUk9KRUNUSU9OLkNFTlRSQUw7XHJcbiAgICBwcml2YXRlIHRyYW5zZm9ybTogTWF0cml4NHg0ID0gbmV3IE1hdHJpeDR4NDsgLy8gVGhlIG1hdHJpeCB0byBtdWx0aXBseSBlYWNoIHNjZW5lIG9iamVjdHMgdHJhbnNmb3JtYXRpb24gYnksIHRvIGRldGVybWluZSB3aGVyZSBpdCB3aWxsIGJlIGRyYXduLlxyXG4gICAgcHJpdmF0ZSBmaWVsZE9mVmlldzogbnVtYmVyID0gNDU7IC8vIFRoZSBjYW1lcmEncyBzZW5zb3JhbmdsZS5cclxuICAgIHByaXZhdGUgYXNwZWN0UmF0aW86IG51bWJlciA9IDEuMDtcclxuICAgIHByaXZhdGUgZGlyZWN0aW9uOiBGSUVMRF9PRl9WSUVXID0gRklFTERfT0ZfVklFVy5ESUFHT05BTDtcclxuICAgIHByaXZhdGUgYmFja2dyb3VuZEVuYWJsZWQ6IGJvb2xlYW4gPSB0cnVlOyAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHRoZSBiYWNrZ3JvdW5kIG9mIHRoaXMgY2FtZXJhIHdpbGwgYmUgcmVuZGVyZWQuXHJcbiAgICAvLyBUT0RPOiBleGFtaW5lLCBpZiBiYWNrZ3JvdW5kIHNob3VsZCBiZSBhbiBhdHRyaWJ1dGUgb2YgQ2FtZXJhIG9yIFZpZXdwb3J0XHJcblxyXG4gICAgcHVibGljIGdldFByb2plY3Rpb24oKTogUFJPSkVDVElPTiB7XHJcbiAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEJhY2tncm91bmRFbmFibGVkKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy5iYWNrZ3JvdW5kRW5hYmxlZDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0QXNwZWN0KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmFzcGVjdFJhdGlvO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRGaWVsZE9mVmlldygpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5maWVsZE9mVmlldztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0RGlyZWN0aW9uKCk6IEZJRUxEX09GX1ZJRVcge1xyXG4gICAgICByZXR1cm4gdGhpcy5kaXJlY3Rpb247XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBtdWx0aXBsaWthdGlvbiBvZiB0aGUgd29ybGR0cmFuc2Zvcm1hdGlvbiBvZiB0aGUgY2FtZXJhIGNvbnRhaW5lciB3aXRoIHRoZSBwcm9qZWN0aW9uIG1hdHJpeFxyXG4gICAgICogQHJldHVybnMgdGhlIHdvcmxkLXByb2plY3Rpb24tbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgVmlld1Byb2plY3Rpb25NYXRyaXgoKTogTWF0cml4NHg0IHtcclxuICAgICAgLy9UT0RPOiBvcHRpbWl6ZSwgbm8gbmVlZCB0byByZWNhbGN1bGF0ZSBpZiBuZWl0aGVyIG10eFdvcmxkIG5vciBwaXZvdCBoYXZlIGNoYW5nZWRcclxuICAgICAgbGV0IG10eENhbWVyYTogTWF0cml4NHg0ID0gdGhpcy5waXZvdDtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBtdHhDYW1lcmEgPSBNYXRyaXg0eDQuTVVMVElQTElDQVRJT04odGhpcy5nZXRDb250YWluZXIoKS5tdHhXb3JsZCwgdGhpcy5waXZvdCk7XHJcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xyXG4gICAgICAgIC8vIG5vIGNvbnRhaW5lciBub2RlIG9yIG5vIHdvcmxkIHRyYW5zZm9ybWF0aW9uIGZvdW5kIC0+IGNvbnRpbnVlIHdpdGggcGl2b3Qgb25seVxyXG4gICAgICB9XHJcbiAgICAgIGxldCBtdHhXb3JsZFByb2plY3Rpb246IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JTlZFUlNJT04obXR4Q2FtZXJhKTtcclxuICAgICAgbXR4V29ybGRQcm9qZWN0aW9uID0gTWF0cml4NHg0Lk1VTFRJUExJQ0FUSU9OKHRoaXMudHJhbnNmb3JtLCBtdHhXb3JsZFByb2plY3Rpb24pO1xyXG4gICAgICByZXR1cm4gbXR4V29ybGRQcm9qZWN0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBjYW1lcmEgdG8gcGVyc3BlY3RpdmUgcHJvamVjdGlvbi4gVGhlIHdvcmxkIG9yaWdpbiBpcyBpbiB0aGUgY2VudGVyIG9mIHRoZSBjYW52YXNlbGVtZW50LlxyXG4gICAgICogQHBhcmFtIF9hc3BlY3QgVGhlIGFzcGVjdCByYXRpbyBiZXR3ZWVuIHdpZHRoIGFuZCBoZWlnaHQgb2YgcHJvamVjdGlvbnNwYWNlLihEZWZhdWx0ID0gY2FudmFzLmNsaWVudFdpZHRoIC8gY2FudmFzLkNsaWVudEhlaWdodClcclxuICAgICAqIEBwYXJhbSBfZmllbGRPZlZpZXcgVGhlIGZpZWxkIG9mIHZpZXcgaW4gRGVncmVlcy4gKERlZmF1bHQgPSA0NSlcclxuICAgICAqIEBwYXJhbSBfZGlyZWN0aW9uIFRoZSBwbGFuZSBvbiB3aGljaCB0aGUgZmllbGRPZlZpZXctQW5nbGUgaXMgZ2l2ZW4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwcm9qZWN0Q2VudHJhbChfYXNwZWN0OiBudW1iZXIgPSB0aGlzLmFzcGVjdFJhdGlvLCBfZmllbGRPZlZpZXc6IG51bWJlciA9IHRoaXMuZmllbGRPZlZpZXcsIF9kaXJlY3Rpb246IEZJRUxEX09GX1ZJRVcgPSB0aGlzLmRpcmVjdGlvbik6IHZvaWQge1xyXG4gICAgICB0aGlzLmFzcGVjdFJhdGlvID0gX2FzcGVjdDtcclxuICAgICAgdGhpcy5maWVsZE9mVmlldyA9IF9maWVsZE9mVmlldztcclxuICAgICAgdGhpcy5kaXJlY3Rpb24gPSBfZGlyZWN0aW9uO1xyXG4gICAgICB0aGlzLnByb2plY3Rpb24gPSBQUk9KRUNUSU9OLkNFTlRSQUw7XHJcbiAgICAgIHRoaXMudHJhbnNmb3JtID0gTWF0cml4NHg0LlBST0pFQ1RJT05fQ0VOVFJBTChfYXNwZWN0LCB0aGlzLmZpZWxkT2ZWaWV3LCAxLCAyMDAwLCB0aGlzLmRpcmVjdGlvbik7IC8vIFRPRE86IHJlbW92ZSBtYWdpYyBudW1iZXJzXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgY2FtZXJhIHRvIG9ydGhvZ3JhcGhpYyBwcm9qZWN0aW9uLiBUaGUgb3JpZ2luIGlzIGluIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhcy5cclxuICAgICAqIEBwYXJhbSBfbGVmdCBUaGUgcG9zaXRpb252YWx1ZSBvZiB0aGUgcHJvamVjdGlvbnNwYWNlJ3MgbGVmdCBib3JkZXIuIChEZWZhdWx0ID0gMClcclxuICAgICAqIEBwYXJhbSBfcmlnaHQgVGhlIHBvc2l0aW9udmFsdWUgb2YgdGhlIHByb2plY3Rpb25zcGFjZSdzIHJpZ2h0IGJvcmRlci4gKERlZmF1bHQgPSBjYW52YXMuY2xpZW50V2lkdGgpXHJcbiAgICAgKiBAcGFyYW0gX2JvdHRvbSBUaGUgcG9zaXRpb252YWx1ZSBvZiB0aGUgcHJvamVjdGlvbnNwYWNlJ3MgYm90dG9tIGJvcmRlci4oRGVmYXVsdCA9IGNhbnZhcy5jbGllbnRIZWlnaHQpXHJcbiAgICAgKiBAcGFyYW0gX3RvcCBUaGUgcG9zaXRpb252YWx1ZSBvZiB0aGUgcHJvamVjdGlvbnNwYWNlJ3MgdG9wIGJvcmRlci4oRGVmYXVsdCA9IDApXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwcm9qZWN0T3J0aG9ncmFwaGljKF9sZWZ0OiBudW1iZXIgPSAwLCBfcmlnaHQ6IG51bWJlciA9IFJlbmRlck1hbmFnZXIuZ2V0Q2FudmFzKCkuY2xpZW50V2lkdGgsIF9ib3R0b206IG51bWJlciA9IFJlbmRlck1hbmFnZXIuZ2V0Q2FudmFzKCkuY2xpZW50SGVpZ2h0LCBfdG9wOiBudW1iZXIgPSAwKTogdm9pZCB7XHJcbiAgICAgIHRoaXMucHJvamVjdGlvbiA9IFBST0pFQ1RJT04uT1JUSE9HUkFQSElDO1xyXG4gICAgICB0aGlzLnRyYW5zZm9ybSA9IE1hdHJpeDR4NC5QUk9KRUNUSU9OX09SVEhPR1JBUEhJQyhfbGVmdCwgX3JpZ2h0LCBfYm90dG9tLCBfdG9wLCA0MDAsIC00MDApOyAvLyBUT0RPOiBleGFtaW5lIG1hZ2ljIG51bWJlcnMhXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIGNhbGN1bGF0ZWQgbm9ybWVkIGRpbWVuc2lvbiBvZiB0aGUgcHJvamVjdGlvbiBzdXJmYWNlLCB0aGF0IGlzIGluIHRoZSBoeXBvdGhldGljYWwgZGlzdGFuY2Ugb2YgMSB0byB0aGUgY2FtZXJhXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRQcm9qZWN0aW9uUmVjdGFuZ2xlKCk6IFJlY3RhbmdsZSB7XHJcbiAgICAgIGxldCB0YW5Gb3Y6IG51bWJlciA9IE1hdGgudGFuKE1hdGguUEkgKiB0aGlzLmZpZWxkT2ZWaWV3IC8gMzYwKTsgLy8gSGFsZiBvZiB0aGUgYW5nbGUsIHRvIGNhbGN1bGF0ZSBkaW1lbnNpb24gZnJvbSB0aGUgY2VudGVyIC0+IHJpZ2h0IGFuZ2xlXHJcbiAgICAgIGxldCB0YW5Ib3Jpem9udGFsOiBudW1iZXIgPSAwO1xyXG4gICAgICBsZXQgdGFuVmVydGljYWw6IG51bWJlciA9IDA7XHJcblxyXG4gICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT0gRklFTERfT0ZfVklFVy5ESUFHT05BTCkge1xyXG4gICAgICAgIGxldCBhc3BlY3Q6IG51bWJlciA9IE1hdGguc3FydCh0aGlzLmFzcGVjdFJhdGlvKTtcclxuICAgICAgICB0YW5Ib3Jpem9udGFsID0gdGFuRm92ICogYXNwZWN0O1xyXG4gICAgICAgIHRhblZlcnRpY2FsID0gdGFuRm92IC8gYXNwZWN0O1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKHRoaXMuZGlyZWN0aW9uID09IEZJRUxEX09GX1ZJRVcuVkVSVElDQUwpIHtcclxuICAgICAgICB0YW5WZXJ0aWNhbCA9IHRhbkZvdjtcclxuICAgICAgICB0YW5Ib3Jpem9udGFsID0gdGFuVmVydGljYWwgKiB0aGlzLmFzcGVjdFJhdGlvO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Ugey8vRk9WX0RJUkVDVElPTi5IT1JJWk9OVEFMXHJcbiAgICAgICAgdGFuSG9yaXpvbnRhbCA9IHRhbkZvdjtcclxuICAgICAgICB0YW5WZXJ0aWNhbCA9IHRhbkhvcml6b250YWwgLyB0aGlzLmFzcGVjdFJhdGlvO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gUmVjdGFuZ2xlLkdFVCgwLCAwLCB0YW5Ib3Jpem9udGFsICogMiwgdGFuVmVydGljYWwgKiAyKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcHJvamVjdChfcG9pbnRJbldvcmxkU3BhY2U6IFZlY3RvcjMpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMztcclxuICAgICAgcmVzdWx0ID0gVmVjdG9yMy5UUkFOU0ZPUk1BVElPTihfcG9pbnRJbldvcmxkU3BhY2UsIHRoaXMuVmlld1Byb2plY3Rpb25NYXRyaXgpO1xyXG4gICAgICBsZXQgbTogRmxvYXQzMkFycmF5ID0gdGhpcy5WaWV3UHJvamVjdGlvbk1hdHJpeC5nZXQoKTtcclxuICAgICAgbGV0IHc6IG51bWJlciA9IG1bM10gKiBfcG9pbnRJbldvcmxkU3BhY2UueCArIG1bN10gKiBfcG9pbnRJbldvcmxkU3BhY2UueSArIG1bMTFdICogX3BvaW50SW5Xb3JsZFNwYWNlLnogKyBtWzE1XTtcclxuICAgICAgcmVzdWx0LnNjYWxlKDEgLyB3KTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge1xyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5iYWNrZ3JvdW5kQ29sb3IsXHJcbiAgICAgICAgYmFja2dyb3VuZEVuYWJsZWQ6IHRoaXMuYmFja2dyb3VuZEVuYWJsZWQsXHJcbiAgICAgICAgcHJvamVjdGlvbjogdGhpcy5wcm9qZWN0aW9uLFxyXG4gICAgICAgIGZpZWxkT2ZWaWV3OiB0aGlzLmZpZWxkT2ZWaWV3LFxyXG4gICAgICAgIGRpcmVjdGlvbjogdGhpcy5kaXJlY3Rpb24sXHJcbiAgICAgICAgYXNwZWN0OiB0aGlzLmFzcGVjdFJhdGlvLFxyXG4gICAgICAgIHBpdm90OiB0aGlzLnBpdm90LnNlcmlhbGl6ZSgpLFxyXG4gICAgICAgIFtzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXTogc3VwZXIuc2VyaWFsaXplKClcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogU2VyaWFsaXphYmxlIHtcclxuICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBfc2VyaWFsaXphdGlvbi5iYWNrZ3JvdW5kQ29sb3I7XHJcbiAgICAgIHRoaXMuYmFja2dyb3VuZEVuYWJsZWQgPSBfc2VyaWFsaXphdGlvbi5iYWNrZ3JvdW5kRW5hYmxlZDtcclxuICAgICAgdGhpcy5wcm9qZWN0aW9uID0gX3NlcmlhbGl6YXRpb24ucHJvamVjdGlvbjtcclxuICAgICAgdGhpcy5maWVsZE9mVmlldyA9IF9zZXJpYWxpemF0aW9uLmZpZWxkT2ZWaWV3O1xyXG4gICAgICB0aGlzLmFzcGVjdFJhdGlvID0gX3NlcmlhbGl6YXRpb24uYXNwZWN0O1xyXG4gICAgICB0aGlzLmRpcmVjdGlvbiA9IF9zZXJpYWxpemF0aW9uLmRpcmVjdGlvbjtcclxuICAgICAgdGhpcy5waXZvdC5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5waXZvdCk7XHJcbiAgICAgIHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdKTtcclxuICAgICAgc3dpdGNoICh0aGlzLnByb2plY3Rpb24pIHtcclxuICAgICAgICBjYXNlIFBST0pFQ1RJT04uT1JUSE9HUkFQSElDOlxyXG4gICAgICAgICAgdGhpcy5wcm9qZWN0T3J0aG9ncmFwaGljKCk7IC8vIFRPRE86IHNlcmlhbGl6ZSBhbmQgZGVzZXJpYWxpemUgcGFyYW1ldGVyc1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBQUk9KRUNUSU9OLkNFTlRSQUw6XHJcbiAgICAgICAgICB0aGlzLnByb2plY3RDZW50cmFsKCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvckF0dHJpYnV0ZVR5cGVzKF9tdXRhdG9yOiBNdXRhdG9yKTogTXV0YXRvckF0dHJpYnV0ZVR5cGVzIHtcclxuICAgICAgbGV0IHR5cGVzOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMgPSBzdXBlci5nZXRNdXRhdG9yQXR0cmlidXRlVHlwZXMoX211dGF0b3IpO1xyXG4gICAgICBpZiAodHlwZXMuZGlyZWN0aW9uKVxyXG4gICAgICAgIHR5cGVzLmRpcmVjdGlvbiA9IEZJRUxEX09GX1ZJRVc7XHJcbiAgICAgIGlmICh0eXBlcy5wcm9qZWN0aW9uKVxyXG4gICAgICAgIHR5cGVzLnByb2plY3Rpb24gPSBQUk9KRUNUSU9OO1xyXG4gICAgICByZXR1cm4gdHlwZXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICBzdXBlci5tdXRhdGUoX211dGF0b3IpO1xyXG5cclxuICAgICAgc3dpdGNoICh0aGlzLnByb2plY3Rpb24pIHtcclxuICAgICAgICBjYXNlIFBST0pFQ1RJT04uQ0VOVFJBTDpcclxuICAgICAgICAgIHRoaXMucHJvamVjdENlbnRyYWwodGhpcy5hc3BlY3RSYXRpbywgdGhpcy5maWVsZE9mVmlldywgdGhpcy5kaXJlY3Rpb24pO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICBkZWxldGUgX211dGF0b3IudHJhbnNmb3JtO1xyXG4gICAgICBzdXBlci5yZWR1Y2VNdXRhdG9yKF9tdXRhdG9yKTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gIH1cclxufSIsIi8vIC88cmVmZXJlbmNlIHBhdGg9XCIuLi9MaWdodC9MaWdodC50c1wiLz5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgICAvKipcclxuICAgICAqIEF0dGFjaGVzIGEgW1tMaWdodF1dIHRvIHRoZSBub2RlXHJcbiAgICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIGlkZW50aWZpZXJzIGZvciB0aGUgdmFyaW91cyB0eXBlcyBvZiBsaWdodCB0aGlzIGNvbXBvbmVudCBjYW4gcHJvdmlkZS4gIFxyXG4gICAgICovXHJcbiAgICAvLyBleHBvcnQgZW51bSBMSUdIVF9UWVBFIHtcclxuICAgIC8vICAgICBBTUJJRU5UID0gXCJhbWJpZW50XCIsXHJcbiAgICAvLyAgICAgRElSRUNUSU9OQUwgPSBcImRpcmVjdGlvbmFsXCIsXHJcbiAgICAvLyAgICAgUE9JTlQgPSBcInBvaW50XCIsXHJcbiAgICAvLyAgICAgU1BPVCA9IFwic3BvdFwiXHJcbiAgICAvLyB9XHJcblxyXG4gICAgZXhwb3J0IGNsYXNzIENvbXBvbmVudExpZ2h0IGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IENvbXBvbmVudC5yZWdpc3RlclN1YmNsYXNzKENvbXBvbmVudExpZ2h0KTtcclxuICAgICAgICAvLyBwcml2YXRlIHN0YXRpYyBjb25zdHJ1Y3RvcnM6IHsgW3R5cGU6IHN0cmluZ106IEdlbmVyYWwgfSA9IHsgW0xJR0hUX1RZUEUuQU1CSUVOVF06IExpZ2h0QW1iaWVudCwgW0xJR0hUX1RZUEUuRElSRUNUSU9OQUxdOiBMaWdodERpcmVjdGlvbmFsLCBbTElHSFRfVFlQRS5QT0lOVF06IExpZ2h0UG9pbnQsIFtMSUdIVF9UWVBFLlNQT1RdOiBMaWdodFNwb3QgfTtcclxuICAgICAgICBwdWJsaWMgcGl2b3Q6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpO1xyXG4gICAgICAgIHB1YmxpYyBsaWdodDogTGlnaHQgPSBudWxsO1xyXG5cclxuICAgICAgICBjb25zdHJ1Y3RvcihfbGlnaHQ6IExpZ2h0ID0gbmV3IExpZ2h0QW1iaWVudCgpKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2luZ2xldG9uID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMubGlnaHQgPSBfbGlnaHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc2V0VHlwZTxUIGV4dGVuZHMgTGlnaHQ+KF9jbGFzczogbmV3ICgpID0+IFQpOiB2b2lkIHtcclxuICAgICAgICAgICAgbGV0IG10ck9sZDogTXV0YXRvciA9IHt9O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5saWdodClcclxuICAgICAgICAgICAgICAgIG10ck9sZCA9IHRoaXMubGlnaHQuZ2V0TXV0YXRvcigpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5saWdodCA9IG5ldyBfY2xhc3MoKTtcclxuICAgICAgICAgICAgdGhpcy5saWdodC5tdXRhdGUobXRyT2xkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgYSBbW01hdGVyaWFsXV0gdG8gdGhlIG5vZGVcclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb21wb25lbnRNYXRlcmlhbCBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gQ29tcG9uZW50LnJlZ2lzdGVyU3ViY2xhc3MoQ29tcG9uZW50TWF0ZXJpYWwpO1xyXG4gICAgcHVibGljIG1hdGVyaWFsOiBNYXRlcmlhbDtcclxuICAgIHB1YmxpYyBjbHJQcmltYXJ5OiBDb2xvciA9IENvbG9yLkNTUyhcIndoaXRlXCIpO1xyXG4gICAgcHVibGljIGNsclNlY29uZGFyeTogQ29sb3IgPSBDb2xvci5DU1MoXCJ3aGl0ZVwiKTtcclxuICAgIC8vIHB1YmxpYyBtdXRhdG9yQ29hdDogTXV0YXRvckZvckNvbXBvbmVudDtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX21hdGVyaWFsOiBNYXRlcmlhbCA9IG51bGwpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5tYXRlcmlhbCA9IF9tYXRlcmlhbDtcclxuICAgICAgLy8gdGhpcy5tdXRhdG9yQ29hdCA9IF9tYXRlcmlhbC5nZXRDb2F0KCkuZ2V0TXV0YXRvckZvckNvbXBvbmVudCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb247XHJcbiAgICAgIC8qIGF0IHRoaXMgcG9pbnQgb2YgdGltZSwgc2VyaWFsaXphdGlvbiBhcyByZXNvdXJjZSBhbmQgYXMgaW5saW5lIG9iamVjdCBpcyBwb3NzaWJsZS4gVE9ETzogY2hlY2sgaWYgaW5saW5lIGJlY29tZXMgb2Jzb2xldGUgKi9cclxuICAgICAgbGV0IGlkTWF0ZXJpYWw6IHN0cmluZyA9IHRoaXMubWF0ZXJpYWwuaWRSZXNvdXJjZTtcclxuICAgICAgaWYgKGlkTWF0ZXJpYWwpXHJcbiAgICAgICAgc2VyaWFsaXphdGlvbiA9IHsgaWRNYXRlcmlhbDogaWRNYXRlcmlhbCB9O1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgc2VyaWFsaXphdGlvbiA9IHsgbWF0ZXJpYWw6IFNlcmlhbGl6ZXIuc2VyaWFsaXplKHRoaXMubWF0ZXJpYWwpIH07XHJcblxyXG4gICAgICBzZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogU2VyaWFsaXphYmxlIHtcclxuICAgICAgbGV0IG1hdGVyaWFsOiBNYXRlcmlhbDtcclxuICAgICAgaWYgKF9zZXJpYWxpemF0aW9uLmlkTWF0ZXJpYWwpXHJcbiAgICAgICAgbWF0ZXJpYWwgPSA8TWF0ZXJpYWw+UmVzb3VyY2VNYW5hZ2VyLmdldChfc2VyaWFsaXphdGlvbi5pZE1hdGVyaWFsKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIG1hdGVyaWFsID0gPE1hdGVyaWFsPlNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24ubWF0ZXJpYWwpO1xyXG4gICAgICB0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWw7XHJcbiAgICAgIHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcHVibGljIGdldE11dGF0b3JGb3JVc2VySW50ZXJmYWNlKCk6IE11dGF0b3JGb3JVc2VySW50ZXJmYWNlIHtcclxuICAgIC8vICAgbGV0IG11dGF0b3JDb2F0OiBNdXRhdG9yRm9yQ29tcG9uZW50ID0gdGhpcy5tYXRlcmlhbC5nZXRDb2F0KCkuZ2V0TXV0YXRvckZvckNvbXBvbmVudCgpO1xyXG4gICAgLy8gICByZXR1cm4gPE11dGF0b3JGb3JVc2VySW50ZXJmYWNlPjx1bmtub3duPm11dGF0b3JDb2F0O1xyXG4gICAgLy8gfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgYSBbW01lc2hdXSB0byB0aGUgbm9kZVxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIENvbXBvbmVudE1lc2ggZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IENvbXBvbmVudC5yZWdpc3RlclN1YmNsYXNzKENvbXBvbmVudE1lc2gpO1xyXG4gICAgcHVibGljIHBpdm90OiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKTtcclxuICAgIHB1YmxpYyBtZXNoOiBNZXNoID0gbnVsbDtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX21lc2g6IE1lc2ggPSBudWxsKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMubWVzaCA9IF9tZXNoO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb247XHJcbiAgICAgIC8qIGF0IHRoaXMgcG9pbnQgb2YgdGltZSwgc2VyaWFsaXphdGlvbiBhcyByZXNvdXJjZSBhbmQgYXMgaW5saW5lIG9iamVjdCBpcyBwb3NzaWJsZS4gVE9ETzogY2hlY2sgaWYgaW5saW5lIGJlY29tZXMgb2Jzb2xldGUgKi9cclxuICAgICAgbGV0IGlkTWVzaDogc3RyaW5nID0gdGhpcy5tZXNoLmlkUmVzb3VyY2U7XHJcbiAgICAgIGlmIChpZE1lc2gpXHJcbiAgICAgICAgc2VyaWFsaXphdGlvbiA9IHsgaWRNZXNoOiBpZE1lc2ggfTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHNlcmlhbGl6YXRpb24gPSB7IG1lc2g6IFNlcmlhbGl6ZXIuc2VyaWFsaXplKHRoaXMubWVzaCkgfTtcclxuXHJcbiAgICAgIHNlcmlhbGl6YXRpb24ucGl2b3QgPSB0aGlzLnBpdm90LnNlcmlhbGl6ZSgpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFNlcmlhbGl6YWJsZSB7XHJcbiAgICAgIGxldCBtZXNoOiBNZXNoO1xyXG4gICAgICBpZiAoX3NlcmlhbGl6YXRpb24uaWRNZXNoKVxyXG4gICAgICAgIG1lc2ggPSA8TWVzaD5SZXNvdXJjZU1hbmFnZXIuZ2V0KF9zZXJpYWxpemF0aW9uLmlkTWVzaCk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBtZXNoID0gPE1lc2g+U2VyaWFsaXplci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5tZXNoKTtcclxuICAgICAgdGhpcy5tZXNoID0gbWVzaDtcclxuXHJcbiAgICAgIHRoaXMucGl2b3QuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24ucGl2b3QpO1xyXG4gICAgICBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yRm9yVXNlckludGVyZmFjZSgpOiBNdXRhdG9yRm9yVXNlckludGVyZmFjZSB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yRm9yVXNlckludGVyZmFjZSA9IDxNdXRhdG9yRm9yVXNlckludGVyZmFjZT50aGlzLmdldE11dGF0b3IoKTtcclxuICAgICAgaWYgKCF0aGlzLm1lc2gpXHJcbiAgICAgICAgbXV0YXRvci5tZXNoID0gTWVzaDtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICB9XHJcbn1cclxuIiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgU3RvcmVkVmFsdWVzIHtcclxuICAgIFtrZXk6IHN0cmluZ106IG51bWJlcjtcclxuICB9XHJcblxyXG4gIGV4cG9ydCBjbGFzcyBDb21wb25lbnRQYXJ0aWNsZVN5c3RlbSBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gQ29tcG9uZW50LnJlZ2lzdGVyU3ViY2xhc3MoQ29tcG9uZW50UGFydGljbGVTeXN0ZW0pO1xyXG4gICAgcHVibGljIHN0b3JlZFZhbHVlczogU3RvcmVkVmFsdWVzID0ge307IC8vIFRPRE86IG1ha2UgcHJpdmF0ZVxyXG4gICAgcHVibGljIGVmZmVjdERhdGE6IFBhcnRpY2xlRWZmZWN0RGF0YTtcclxuICAgIHByaXZhdGUgcmFuZG9tTnVtYmVyczogbnVtYmVyW10gPSBbXTtcclxuICAgIC8vIGNvbG9yXHJcblxyXG4gICAgY29uc3RydWN0b3IoX2ZpbGVuYW1lOiBzdHJpbmcgPSBudWxsLCBfbnVtYmVyT2ZQYXJ0aWNsZXM6IG51bWJlciA9IG51bGwpIHtcclxuICAgICAgc3VwZXIoKTtcclxuXHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCAyMDAwIC8qIFRPRE86IGRvbid0IGhhcmRjb2RlIHRoaXMgbnVtYmVyLCBudW1iZXIgc2hvdWxkIGJlIGJpZ2dlciB0aGFuIG51bWJlciBvZiBwYXJ0aWNsZXMgKi87IGkrKykge1xyXG4gICAgICAgIHRoaXMucmFuZG9tTnVtYmVycy5wdXNoKE1hdGgucmFuZG9tKCkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnN0b3JlZFZhbHVlcyA9IHtcclxuICAgICAgICBcInRpbWVcIjogMCxcclxuICAgICAgICBcImluZGV4XCI6IDAsXHJcbiAgICAgICAgXCJzaXplXCI6IF9udW1iZXJPZlBhcnRpY2xlc1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgbGV0IGVmZmVjdEltcG9ydGVyOiBQYXJ0aWNsZUVmZmVjdEltcG9ydGVyID0gbmV3IFBhcnRpY2xlRWZmZWN0SW1wb3J0ZXIodGhpcy5zdG9yZWRWYWx1ZXMsIHRoaXMucmFuZG9tTnVtYmVycyk7XHJcbiAgICAgIHRoaXMuZWZmZWN0RGF0YSA9IGVmZmVjdEltcG9ydGVyLmltcG9ydEZpbGUoX2ZpbGVuYW1lKTtcclxuXHJcbiAgICAgIC8vIGV2YWx1YXRlIHN5c3RlbSBzdG9yYWdlXHJcbiAgICAgIGlmICg8UGFydGljbGVFZmZlY3REYXRhPnRoaXMuZWZmZWN0RGF0YVtcInN0b3JhZ2VcIl0pXHJcbiAgICAgICAgdGhpcy5ldmFsdWF0ZUNsb3N1cmVTdG9yYWdlKDxQYXJ0aWNsZUVmZmVjdERhdGE+KDxQYXJ0aWNsZUVmZmVjdERhdGE+dGhpcy5lZmZlY3REYXRhW1wic3RvcmFnZVwiXSlbXCJzeXN0ZW1cIl0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB1cGRhdGVQYXJ0aWNsZUVmZmVjdChfdGltZTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuc3RvcmVkVmFsdWVzW1widGltZVwiXSA9IF90aW1lO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBldmFsdWF0ZUNsb3N1cmVTdG9yYWdlKF9zdG9yYWdlRGF0YTogUGFydGljbGVFZmZlY3REYXRhKTogdm9pZCB7XHJcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIF9zdG9yYWdlRGF0YSkge1xyXG4gICAgICAgIHRoaXMuc3RvcmVkVmFsdWVzW2tleV0gPSAoPEZ1bmN0aW9uPl9zdG9yYWdlRGF0YVtrZXldKSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQmFzZSBjbGFzcyBmb3Igc2NyaXB0cyB0aGUgdXNlciB3cml0ZXNcclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9KaXJrYURlbGxPcm8vRlVER0Uvd2lraS9Db21wb25lbnRcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29tcG9uZW50U2NyaXB0IGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIC8vIHJlZ2lzdGVyaW5nIHRoaXMgZG9lc24ndCBtYWtlIHNlbnNlLCBvbmx5IGl0cyBzdWJjbGFzc2VzLiBPciB0aGlzIGNvbXBvbmVudCBtdXN0IHJlZmVyIHRvIHNjcmlwdHMgdG8gYmUgYXR0YWNoZWQgdG8gdGhpcyBjb21wb25lbnRcclxuICAgIC8vIFRPRE86IHJldGhpbmsgJiByZWZhY3RvclxyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IENvbXBvbmVudC5yZWdpc3RlclN1YmNsYXNzKENvbXBvbmVudFNjcmlwdCk7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5zaW5nbGV0b24gPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICByZXR1cm4gdGhpcy5nZXRNdXRhdG9yKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogU2VyaWFsaXphYmxlIHtcclxuICAgICAgdGhpcy5tdXRhdGUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBBdHRhY2hlcyBhIHRyYW5zZm9ybS1bW01hdHJpeDR4NF1dIHRvIHRoZSBub2RlLCBtb3ZpbmcsIHNjYWxpbmcgYW5kIHJvdGF0aW5nIGl0IGluIHNwYWNlIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQuXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29tcG9uZW50VHJhbnNmb3JtIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRUcmFuc2Zvcm0pO1xyXG4gICAgcHVibGljIGxvY2FsOiBNYXRyaXg0eDQ7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9tYXRyaXg6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMubG9jYWwgPSBfbWF0cml4O1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgbG9jYWw6IHRoaXMubG9jYWwuc2VyaWFsaXplKCksXHJcbiAgICAgICAgW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdOiBzdXBlci5zZXJpYWxpemUoKVxyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFNlcmlhbGl6YWJsZSB7XHJcbiAgICAgIHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdKTtcclxuICAgICAgdGhpcy5sb2NhbC5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5sb2NhbCk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHB1YmxpYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgIC8vICAgICB0aGlzLmxvY2FsLm11dGF0ZShfbXV0YXRvcik7XHJcbiAgICAvLyB9XHJcbiAgICAvLyBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHsgXHJcbiAgICAvLyAgICAgcmV0dXJuIHRoaXMubG9jYWwuZ2V0TXV0YXRvcigpO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIC8vIHB1YmxpYyBnZXRNdXRhdG9yQXR0cmlidXRlVHlwZXMoX211dGF0b3I6IE11dGF0b3IpOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMge1xyXG4gICAgLy8gICAgIGxldCB0eXBlczogTXV0YXRvckF0dHJpYnV0ZVR5cGVzID0gdGhpcy5sb2NhbC5nZXRNdXRhdG9yQXR0cmlidXRlVHlwZXMoX211dGF0b3IpO1xyXG4gICAgLy8gICAgIHJldHVybiB0eXBlcztcclxuICAgIC8vIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICBkZWxldGUgX211dGF0b3Iud29ybGQ7XHJcbiAgICAgIHN1cGVyLnJlZHVjZU11dGF0b3IoX211dGF0b3IpO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59XHJcbiIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBjb25zdCBlbnVtIEVWRU5UX0NPTlRST0wge1xyXG4gICAgSU5QVVQgPSBcImlucHV0XCIsXHJcbiAgICBPVVRQVVQgPSBcIm91dHB1dFwiXHJcbiAgfVxyXG5cclxuICBleHBvcnQgY29uc3QgZW51bSBDT05UUk9MX1RZUEUge1xyXG4gICAgLyoqIFRoZSBvdXRwdXQgc2ltcGx5IGZvbGxvd3MgdGhlIHNjYWxlZCBhbmQgZGVsYXllZCBpbnB1dCAqL1xyXG4gICAgUFJPUE9SVElPTkFMLFxyXG4gICAgLyoqIFRoZSBvdXRwdXQgdmFsdWUgY2hhbmdlcyBvdmVyIHRpbWUgd2l0aCBhIHJhdGUgZ2l2ZW4gYnkgdGhlIHNjYWxlZCBhbmQgZGVsYXllZCBpbnB1dCAqL1xyXG4gICAgSU5URUdSQUwsXHJcbiAgICAvKiogVGhlIG91dHB1dCB2YWx1ZSByZWFjdHMgdG8gY2hhbmdlcyBvZiB0aGUgc2NhbGVkIGlucHV0IGFuZCBkcm9wcyB0byAwIHdpdGggZ2l2ZW4gZGVsYXksIGlmIGlucHV0IHJlbWFpbnMgY29uc3RhbnQgKi9cclxuICAgIERJRkZFUkVOVElBTFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUHJvY2Vzc2VzIGlucHV0IHNpZ25hbHMgb2YgdHlwZSBudW1iZXIgYW5kIGdlbmVyYXRlcyBhbiBvdXRwdXQgc2lnbmFsIG9mIHRoZSBzYW1lIHR5cGUgdXNpbmcgXHJcbiAgICogcHJvcG9ydGlvbmFsLCBpbnRlZ3JhbCBvciBkaWZmZXJlbnRpYWwgbWFwcGluZywgYW4gYW1wbGlmaWNhdGlvbiBmYWN0b3IgYW5kIGEgbGluZWFyIGRhbXBlbmluZy9kZWxheVxyXG4gICAqIGBgYHBsYWludGV4dFxyXG4gICAqICAgICAgICAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxyXG4gICAqICAgICAgICAgIOKUgiAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUkCAgICAgIHBhc3MgdGhyb3VnaCAoUHJvcG9ydGlvbmFsKSAgICAgIOKUglxyXG4gICAqICBJbnB1dCDihpIg4pSCIOKGkiDilIJhbXBsaWZ54pSCIOKGkiDilIJkZWxheeKUgiDihpIg4pqfIHN1bSB1cCBvdmVyIHRpbWUgKEludGVncmFsKSDimp4g4oaSIOKUgiDihpIgT3V0cHV0XHJcbiAgICogICAgICAgICAg4pSCICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSYICAgICAgcGFzcyBjaGFuZ2UgIChEaWZmZXJlbnRpYWwpICAgICAg4pSCXHJcbiAgICogICAgICAgICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYIFxyXG4gICAqIGBgYFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb250cm9sIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xyXG4gICAgcHVibGljIHJlYWRvbmx5IHR5cGU6IENPTlRST0xfVFlQRTtcclxuICAgIHB1YmxpYyBhY3RpdmU6IGJvb2xlYW47XHJcbiAgICBwdWJsaWMgbmFtZTogc3RyaW5nO1xyXG5cclxuICAgIHByb3RlY3RlZCByYXRlRGlzcGF0Y2hPdXRwdXQ6IG51bWJlciA9IDA7XHJcbiAgICBwcm90ZWN0ZWQgdmFsdWVQcmV2aW91czogbnVtYmVyID0gMDtcclxuICAgIHByb3RlY3RlZCBvdXRwdXRCYXNlOiBudW1iZXIgPSAwO1xyXG4gICAgcHJvdGVjdGVkIG91dHB1dFRhcmdldDogbnVtYmVyID0gMDtcclxuICAgIHByb3RlY3RlZCBvdXRwdXRQcmV2aW91czogbnVtYmVyID0gMDtcclxuICAgIHByb3RlY3RlZCBvdXRwdXRUYXJnZXRQcmV2aW91czogbnVtYmVyID0gMDtcclxuICAgIHByb3RlY3RlZCBmYWN0b3I6IG51bWJlciA9IDA7XHJcblxyXG4gICAgcHJvdGVjdGVkIHRpbWU6IFRpbWUgPSBUaW1lLmdhbWU7XHJcbiAgICBwcm90ZWN0ZWQgdGltZVZhbHVlRGVsYXk6IG51bWJlciA9IDA7XHJcbiAgICBwcm90ZWN0ZWQgdGltZU91dHB1dFRhcmdldFNldDogbnVtYmVyID0gMDtcclxuICAgIHByb3RlY3RlZCBpZFRpbWVyOiBudW1iZXIgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgY29uc3RydWN0b3IoX25hbWU6IHN0cmluZywgX2ZhY3RvcjogbnVtYmVyID0gMSwgX3R5cGU6IENPTlRST0xfVFlQRSA9IENPTlRST0xfVFlQRS5QUk9QT1JUSU9OQUwsIF9hY3RpdmU6IGJvb2xlYW4gPSB0cnVlKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuZmFjdG9yID0gX2ZhY3RvcjtcclxuICAgICAgdGhpcy50eXBlID0gX3R5cGU7XHJcbiAgICAgIHRoaXMuYWN0aXZlID0gX2FjdGl2ZTtcclxuICAgICAgdGhpcy5uYW1lID0gX25hbWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHRpbWUtb2JqZWN0IHRvIGJlIHVzZWQgd2hlbiBjYWxjdWxhdGluZyB0aGUgb3V0cHV0IGluIFtbQ09OVFJPTF9UWVBFLklOVEVHUkFMXV1cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFRpbWViYXNlKF90aW1lOiBUaW1lKTogdm9pZCB7XHJcbiAgICAgIHRoaXMudGltZSA9IF90aW1lO1xyXG4gICAgICB0aGlzLmNhbGN1bGF0ZU91dHB1dCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmVlZCBhbiBpbnB1dCB2YWx1ZSBpbnRvIHRoaXMgY29udHJvbCBhbmQgZmlyZSB0aGUgZXZlbnRzIFtbRVZFTlRfQ09OVFJPTC5JTlBVVF1dIGFuZCBbW0VWRU5UX0NPTlRST0wuT1VUUFVUXV1cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldElucHV0KF9pbnB1dDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIHRoaXMub3V0cHV0QmFzZSA9IHRoaXMuY2FsY3VsYXRlT3V0cHV0KCk7XHJcbiAgICAgIHRoaXMudmFsdWVQcmV2aW91cyA9IHRoaXMuZ2V0VmFsdWVEZWxheWVkKCk7XHJcbiAgICAgIHRoaXMub3V0cHV0VGFyZ2V0ID0gdGhpcy5mYWN0b3IgKiBfaW5wdXQ7XHJcbiAgICAgIHRoaXMudGltZU91dHB1dFRhcmdldFNldCA9IHRoaXMudGltZS5nZXQoKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLnR5cGUgPT0gQ09OVFJPTF9UWVBFLkRJRkZFUkVOVElBTCkge1xyXG4gICAgICAgIHRoaXMudmFsdWVQcmV2aW91cyA9IHRoaXMub3V0cHV0VGFyZ2V0IC0gdGhpcy5vdXRwdXRUYXJnZXRQcmV2aW91cztcclxuICAgICAgICB0aGlzLm91dHB1dFRhcmdldFByZXZpb3VzID0gdGhpcy5vdXRwdXRUYXJnZXQ7XHJcbiAgICAgICAgdGhpcy5vdXRwdXRUYXJnZXQgPSAwO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5UX0NPTlRST0wuSU5QVVQpKTtcclxuICAgICAgaWYgKHRoaXMudHlwZSA9PSBDT05UUk9MX1RZUEUuRElGRkVSRU5USUFMKVxyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hPdXRwdXQodGhpcy52YWx1ZVByZXZpb3VzKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hPdXRwdXQobnVsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHRpbWUgdG8gdGFrZSBmb3IgdGhlIGludGVybmFsIGxpbmVhciBkYW1wZW5pbmcgdW50aWwgdGhlIGZpbmFsIG91cHV0IHZhbHVlIGlzIHJlYWNoZWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldERlbGF5KF90aW1lOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy50aW1lVmFsdWVEZWxheSA9IE1hdGgubWF4KDAsIF90aW1lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgbnVtYmVyIG9mIG91dHB1dC1ldmVudHMgdG8gZGlzcGF0Y2ggcGVyIHNlY29uZC4gXHJcbiAgICAgKiBBdCB0aGUgZGVmYXVsdCBvZiAwLCB0aGUgY29udHJvbCBvdXRwdXQgbXVzdCBiZSBwb2xsZWQgYW5kIHdpbGwgb25seSBhY3RpdmVseSBkaXNwYXRjaGVkIG9uY2UgZWFjaCB0aW1lIGlucHV0IG9jY3VycyBhbmQgdGhlIG91dHB1dCBjaGFuZ2VzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0UmF0ZURpc3BhdGNoT3V0cHV0KF9yYXRlRGlzcGF0Y2hPdXRwdXQ6IG51bWJlciA9IDApOiB2b2lkIHtcclxuICAgICAgdGhpcy5yYXRlRGlzcGF0Y2hPdXRwdXQgPSBfcmF0ZURpc3BhdGNoT3V0cHV0O1xyXG4gICAgICB0aGlzLnRpbWUuZGVsZXRlVGltZXIodGhpcy5pZFRpbWVyKTtcclxuICAgICAgdGhpcy5pZFRpbWVyID0gdW5kZWZpbmVkO1xyXG4gICAgICBpZiAodGhpcy5yYXRlRGlzcGF0Y2hPdXRwdXQpXHJcbiAgICAgICAgdGhpcy5pZFRpbWVyID0gdGhpcy50aW1lLnNldFRpbWVyKDEwMDAgLyB0aGlzLnJhdGVEaXNwYXRjaE91dHB1dCwgMCwgdGhpcy5kaXNwYXRjaE91dHB1dCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGZhY3RvciB0byBtdWx0aXBseSB0aGUgaW5wdXQgdmFsdWUgZ2l2ZW4gd2l0aCBbW3NldElucHV0XV0gd2l0aFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0RmFjdG9yKF9mYWN0b3I6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICB0aGlzLmZhY3RvciA9IF9mYWN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHZhbHVlIGZyb20gdGhlIG91dHB1dCBvZiB0aGlzIGNvbnRyb2xcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldE91dHB1dCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5jYWxjdWxhdGVPdXRwdXQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIG91dHB1dCBvZiB0aGlzIGNvbnRyb2xcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGNhbGN1bGF0ZU91dHB1dCgpOiBudW1iZXIge1xyXG4gICAgICBsZXQgb3V0cHV0OiBudW1iZXIgPSAwO1xyXG4gICAgICBsZXQgdmFsdWU6IG51bWJlciA9IHRoaXMuZ2V0VmFsdWVEZWxheWVkKCk7XHJcblxyXG4gICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xyXG4gICAgICAgIGNhc2UgQ09OVFJPTF9UWVBFLklOVEVHUkFMOlxyXG4gICAgICAgICAgbGV0IHRpbWVDdXJyZW50OiBudW1iZXIgPSB0aGlzLnRpbWUuZ2V0KCk7XHJcbiAgICAgICAgICBsZXQgdGltZUVsYXBzZWRTaW5jZUlucHV0OiBudW1iZXIgPSB0aW1lQ3VycmVudCAtIHRoaXMudGltZU91dHB1dFRhcmdldFNldDtcclxuICAgICAgICAgIG91dHB1dCA9IHRoaXMub3V0cHV0QmFzZTtcclxuXHJcbiAgICAgICAgICBpZiAodGhpcy50aW1lVmFsdWVEZWxheSA+IDApIHtcclxuICAgICAgICAgICAgaWYgKHRpbWVFbGFwc2VkU2luY2VJbnB1dCA8IHRoaXMudGltZVZhbHVlRGVsYXkpIHtcclxuICAgICAgICAgICAgICBvdXRwdXQgKz0gMC41ICogKHRoaXMudmFsdWVQcmV2aW91cyArIHZhbHVlKSAqIHRpbWVFbGFwc2VkU2luY2VJbnB1dDtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICBvdXRwdXQgKz0gMC41ICogKHRoaXMudmFsdWVQcmV2aW91cyArIHZhbHVlKSAqIHRoaXMudGltZVZhbHVlRGVsYXk7XHJcbiAgICAgICAgICAgICAgdGltZUVsYXBzZWRTaW5jZUlucHV0IC09IHRoaXMudGltZVZhbHVlRGVsYXk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIG91dHB1dCArPSB2YWx1ZSAqIHRpbWVFbGFwc2VkU2luY2VJbnB1dDtcclxuICAgICAgICAgIC8vIHZhbHVlICs9IDAuNSAqICh0aGlzLmlucHV0UHJldmlvdXMgLSBpbnB1dCkgKiB0aGlzLnRpbWVJbnB1dERlbGF5ICsgaW5wdXQgKiB0aW1lRWxhcHNlZFNpbmNlSW5wdXQ7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIENPTlRST0xfVFlQRS5ESUZGRVJFTlRJQUw6XHJcbiAgICAgICAgY2FzZSBDT05UUk9MX1RZUEUuUFJPUE9SVElPTkFMOlxyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBvdXRwdXQgPSB2YWx1ZTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBnZXRWYWx1ZURlbGF5ZWQoKTogbnVtYmVyIHtcclxuICAgICAgaWYgKHRoaXMudGltZVZhbHVlRGVsYXkgPiAwKSB7XHJcbiAgICAgICAgbGV0IHRpbWVFbGFwc2VkU2luY2VJbnB1dDogbnVtYmVyID0gdGhpcy50aW1lLmdldCgpIC0gdGhpcy50aW1lT3V0cHV0VGFyZ2V0U2V0O1xyXG4gICAgICAgIGlmICh0aW1lRWxhcHNlZFNpbmNlSW5wdXQgPCB0aGlzLnRpbWVWYWx1ZURlbGF5KVxyXG4gICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVQcmV2aW91cyArICh0aGlzLm91dHB1dFRhcmdldCAtIHRoaXMudmFsdWVQcmV2aW91cykgKiB0aW1lRWxhcHNlZFNpbmNlSW5wdXQgLyB0aGlzLnRpbWVWYWx1ZURlbGF5O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLm91dHB1dFRhcmdldDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGRpc3BhdGNoT3V0cHV0ID0gKF9ldmVudE9yVmFsdWU6IEV2ZW50VGltZXIgfCBudW1iZXIpOiB2b2lkID0+IHtcclxuICAgICAgbGV0IHRpbWVyOiBUaW1lciA9IHRoaXMudGltZS5nZXRUaW1lcih0aGlzLmlkVGltZXIpO1xyXG4gICAgICBsZXQgb3V0cHV0OiBudW1iZXI7XHJcbiAgICAgIGlmICh0eXBlb2YgKF9ldmVudE9yVmFsdWUpID09IFwibnVtYmVyXCIpXHJcbiAgICAgICAgb3V0cHV0ID0gX2V2ZW50T3JWYWx1ZTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIG91dHB1dCA9IHRoaXMuY2FsY3VsYXRlT3V0cHV0KCk7XHJcbiAgICAgIGxldCBvdXRwdXRDaGFuZ2VkOiBib29sZWFuID0gKG91dHB1dCAhPSB0aGlzLm91dHB1dFByZXZpb3VzKTtcclxuXHJcbiAgICAgIGlmICh0aW1lcilcclxuICAgICAgICB0aW1lci5hY3RpdmUgPSBvdXRwdXRDaGFuZ2VkO1xyXG5cclxuICAgICAgaWYgKCFvdXRwdXRDaGFuZ2VkKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIHRoaXMub3V0cHV0UHJldmlvdXMgPSBvdXRwdXQ7XHJcblxyXG4gICAgICBsZXQgZXZlbnQ6IEN1c3RvbUV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KEVWRU5UX0NPTlRST0wuT1VUUFVULCB7XHJcbiAgICAgICAgZGV0YWlsOiB7XHJcbiAgICAgICAgICBvdXRwdXQ6IG91dHB1dFxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIi8vLzxyZWZlcmVuY2UgcGF0aD1cIkNvbnRyb2wudHNcIi8+XHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEhhbmRsZXMgbXVsdGlwbGUgY29udHJvbHMgYXMgaW5wdXRzIGFuZCBjcmVhdGVzIGFuIG91dHB1dCBmcm9tIHRoYXQuXHJcbiAgICogQXMgYSBzdWJjbGFzcyBvZiBbW0NvbnRyb2xdXSwgYXhpcyBjYWxjdWxhdGVzIHRoZSBvdXB1dCBzdW1taW5nIHVwIHRoZSBpbnB1dHMgYW5kIHByb2Nlc3NpbmcgdGhlIHJlc3VsdCB1c2luZyBpdHMgb3duIHNldHRpbmdzLiAgXHJcbiAgICogRGlzcGF0Y2hlcyBbW0VWRU5UX0NPTlRST0wuT1VUUFVUXV0gYW5kIFtbRVZFTlRfQ09OVFJPTC5JTlBVVF1dIHdoZW4gb25lIG9mIHRoZSBjb250cm9scyBkaXNwYXRjaGVzIHRoZW0uXHJcbiAgICogYGBgcGxhaW50ZXh0XHJcbiAgICogICAgICAgICAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxyXG4gICAqICAgICAgICAgICDilIIg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXHJcbiAgICogICBJbnB1dCDihpIg4pSCIOKUgmNvbnRyb2zilIJcXCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXHJcbiAgICogICAgICAgICAgIOKUgiDilJTilIDilIDilIDilIDilIDilIDilIDilJggXFwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXHJcbiAgICogICAgICAgICAgIOKUgiDilIzilIDilIDilIDilIDilIDilIDilIDilJAgIFxc4pSM4pSA4pSA4pSA4pSQICAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQICAg4pSCXHJcbiAgICogICBJbnB1dCDihpIg4pSCIOKUgmNvbnRyb2zilIItLS3ilIJzdW3ilIIg4oaSIOKUgmludGVybmFsIGNvbnRyb2wg4pSCIOKGkiDilIIg4oaSIE91dHB1dFxyXG4gICAqICAgICAgICAgICDilIIg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYICAv4pSU4pSA4pSA4pSA4pSYICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYICAg4pSCXHJcbiAgICogICAgICAgICAgIOKUgiDilIzilIDilIDilIDilIDilIDilIDilIDilJAgLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcclxuICAgKiAgIElucHV0IOKGkiDilIIg4pSCY29udHJvbOKUgi8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxyXG4gICAqICAgICAgICAgICDilIIg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXHJcbiAgICogICAgICAgICAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgXHJcbiAgICogYGBgXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEF4aXMgZXh0ZW5kcyBDb250cm9sIHtcclxuICAgIHByaXZhdGUgY29udHJvbHM6IE1hcDxzdHJpbmcsIENvbnRyb2w+ID0gbmV3IE1hcCgpO1xyXG4gICAgcHJpdmF0ZSBzdW1QcmV2aW91czogbnVtYmVyID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCB0aGUgY29udHJvbCBnaXZlbiB0byB0aGUgbGlzdCBvZiBjb250cm9scyBmZWVkaW5nIGludG8gdGhpcyBheGlzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhZGRDb250cm9sKF9jb250cm9sOiBDb250cm9sKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuY29udHJvbHMuc2V0KF9jb250cm9sLm5hbWUsIF9jb250cm9sKTtcclxuICAgICAgX2NvbnRyb2wuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVF9DT05UUk9MLklOUFVULCB0aGlzLmhuZElucHV0RXZlbnQpO1xyXG4gICAgICBfY29udHJvbC5hZGRFdmVudExpc3RlbmVyKEVWRU5UX0NPTlRST0wuT1VUUFVULCB0aGlzLmhuZE91dHB1dEV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gbmFtZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Q29udHJvbChfbmFtZTogc3RyaW5nKTogQ29udHJvbCB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xzLmdldChfbmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBjb250cm9sIHdpdGggdGhlIGdpdmVuIG5hbWVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlbW92ZUNvbnRyb2woX25hbWU6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICBsZXQgY29udHJvbDogQ29udHJvbCA9IHRoaXMuZ2V0Q29udHJvbChfbmFtZSk7XHJcbiAgICAgIGlmIChjb250cm9sKSB7XHJcbiAgICAgICAgY29udHJvbC5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5UX0NPTlRST0wuSU5QVVQsIHRoaXMuaG5kSW5wdXRFdmVudCk7XHJcbiAgICAgICAgY29udHJvbC5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5UX0NPTlRST0wuT1VUUFVULCB0aGlzLmhuZE91dHB1dEV2ZW50KTtcclxuICAgICAgICB0aGlzLmNvbnRyb2xzLmRlbGV0ZShfbmFtZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoaXMgYXhpcyBhZnRlciBzdW1taW5nIHVwIGFsbCBpbnB1dHMgYW5kIHByb2Nlc3NpbmcgdGhlIHN1bSBhY2NvcmRpbmcgdG8gdGhlIGF4aXMnIHNldHRpbmdzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRPdXRwdXQoKTogbnVtYmVyIHtcclxuICAgICAgbGV0IHN1bUlucHV0OiBudW1iZXIgPSAwO1xyXG4gICAgICBmb3IgKGxldCBjb250cm9sIG9mIHRoaXMuY29udHJvbHMpIHtcclxuXHJcbiAgICAgICAgaWYgKGNvbnRyb2xbMV0uYWN0aXZlKVxyXG4gICAgICAgICAgc3VtSW5wdXQgKz0gY29udHJvbFsxXS5nZXRPdXRwdXQoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHN1bUlucHV0ICE9IHRoaXMuc3VtUHJldmlvdXMpXHJcbiAgICAgICAgc3VwZXIuc2V0SW5wdXQoc3VtSW5wdXQpO1xyXG5cclxuICAgICAgdGhpcy5zdW1QcmV2aW91cyA9IHN1bUlucHV0O1xyXG5cclxuICAgICAgcmV0dXJuIHN1cGVyLmdldE91dHB1dCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaG5kT3V0cHV0RXZlbnQ6IEV2ZW50TGlzdGVuZXIgPSAoX2V2ZW50OiBFdmVudCk6IHZvaWQgPT4ge1xyXG4gICAgICBsZXQgY29udHJvbDogQ29udHJvbCA9ICg8Q29udHJvbD5fZXZlbnQudGFyZ2V0KTtcclxuICAgICAgbGV0IGV2ZW50OiBDdXN0b21FdmVudCA9IG5ldyBDdXN0b21FdmVudChFVkVOVF9DT05UUk9MLk9VVFBVVCwge2RldGFpbDoge1xyXG4gICAgICAgIGNvbnRyb2w6IGNvbnRyb2wsIFxyXG4gICAgICAgIGlucHV0OiAoPEN1c3RvbUV2ZW50Pl9ldmVudCkuZGV0YWlsLm91dHB1dCxcclxuICAgICAgICBvdXRwdXQ6IHRoaXMuZ2V0T3V0cHV0KClcclxuICAgICAgfX0pO1xyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaG5kSW5wdXRFdmVudDogRXZlbnRMaXN0ZW5lciA9IChfZXZlbnQ6IEV2ZW50KTogdm9pZCA9PiB7XHJcbiAgICAgIGxldCBldmVudDogRXZlbnQgPSBuZXcgRXZlbnQoRVZFTlRfQ09OVFJPTC5JTlBVVCwgX2V2ZW50KTtcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBpbnRlcmZhY2UgS2V5UHJlc3NlZCB7XHJcbiAgICBbY29kZTogc3RyaW5nXTogYm9vbGVhbjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbGxlY3RzIHRoZSBrZXlzIHByZXNzZWQgb24gdGhlIGtleWJvYXJkIGFuZCBzdG9yZXMgdGhlaXIgc3RhdHVzLiBcclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgS2V5Ym9hcmQge1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMga2V5c1ByZXNzZWQ6IEtleVByZXNzZWQgPSBLZXlib2FyZC5pbml0aWFsaXplKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgb25lIG9mIHRoZSBnaXZlbiBrZXlzIGlzIGlzIGN1cnJlbnRseSBiZWluZyBwcmVzc2VkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGlzUHJlc3NlZE9uZShfa2V5czogS0VZQk9BUkRfQ09ERVtdKTogYm9vbGVhbiB7XHJcbiAgICAgIGZvciAobGV0IGNvZGUgb2YgX2tleXMpIHtcclxuICAgICAgICBpZiAoS2V5Ym9hcmQua2V5c1ByZXNzZWRbY29kZV0pXHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgYWxsIG9mIHRoZSBnaXZlbiBrZXlzIGFyZSBjdXJyZW50bHkgYmVpbmcgcHJlc3NlZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGlzUHJlc3NlZENvbWJvKF9rZXlzOiBLRVlCT0FSRF9DT0RFW10pOiBib29sZWFuIHtcclxuICAgICAgZm9yIChsZXQgY29kZSBvZiBfa2V5cykge1xyXG4gICAgICAgIGlmICghS2V5Ym9hcmQua2V5c1ByZXNzZWRbY29kZV0pXHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBnaXZlbiBhcyBfYWN0aXZlIGlmIG9uZSBvciwgd2hlbiBfY29tYm8gaXMgdHJ1ZSwgYWxsIG9mIHRoZSBnaXZlbiBrZXlzIGFyZSBwcmVzc2VkLlxyXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgZ2l2ZW4gYXMgX2luYWN0aXZlIGlmIG5vdC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBtYXBUb1ZhbHVlPFQ+KF9hY3RpdmU6IFQsIF9pbmFjdGl2ZTogVCwgX2tleXM6IEtFWUJPQVJEX0NPREVbXSwgX2NvbWJvOiBib29sZWFuID0gZmFsc2UpOiBUIHtcclxuICAgICAgaWYgKCFfY29tYm8gJiYgS2V5Ym9hcmQuaXNQcmVzc2VkT25lKF9rZXlzKSlcclxuICAgICAgICByZXR1cm4gX2FjdGl2ZTtcclxuICAgICAgaWYgKEtleWJvYXJkLmlzUHJlc3NlZENvbWJvKF9rZXlzKSlcclxuICAgICAgICByZXR1cm4gX2FjdGl2ZTtcclxuICAgICAgcmV0dXJuIF9pbmFjdGl2ZTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBpbml0aWFsaXplKCk6IEtleVByZXNzZWQge1xyXG4gICAgICBsZXQgc3RvcmU6IEtleVByZXNzZWQgPSB7fTtcclxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgS2V5Ym9hcmQuaG5kS2V5SW50ZXJhY3Rpb24pO1xyXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgS2V5Ym9hcmQuaG5kS2V5SW50ZXJhY3Rpb24pO1xyXG4gICAgICByZXR1cm4gc3RvcmU7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgaG5kS2V5SW50ZXJhY3Rpb24oX2V2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XHJcbiAgICAgIEtleWJvYXJkLmtleXNQcmVzc2VkW19ldmVudC5jb2RlXSA9IChfZXZlbnQudHlwZSA9PSBcImtleWRvd25cIik7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwiLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCJEZWJ1Z1RhcmdldC50c1wiLz5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogUm91dGluZyB0byB0aGUgYWxlcnQgYm94XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIERlYnVnQWxlcnQgZXh0ZW5kcyBEZWJ1Z1RhcmdldCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIGRlbGVnYXRlczogTWFwRGVidWdGaWx0ZXJUb0RlbGVnYXRlID0ge1xyXG4gICAgICBbREVCVUdfRklMVEVSLklORk9dOiBEZWJ1Z0FsZXJ0LmNyZWF0ZURlbGVnYXRlKERFQlVHX1NZTUJPTFtERUJVR19GSUxURVIuSU5GT10pLFxyXG4gICAgICBbREVCVUdfRklMVEVSLkxPR106IERlYnVnQWxlcnQuY3JlYXRlRGVsZWdhdGUoREVCVUdfU1lNQk9MW0RFQlVHX0ZJTFRFUi5MT0ddKSxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5XQVJOXTogRGVidWdBbGVydC5jcmVhdGVEZWxlZ2F0ZShERUJVR19TWU1CT0xbREVCVUdfRklMVEVSLldBUk5dKSxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5FUlJPUl06IERlYnVnQWxlcnQuY3JlYXRlRGVsZWdhdGUoREVCVUdfU1lNQk9MW0RFQlVHX0ZJTFRFUi5FUlJPUl0pLFxyXG4gICAgICBbREVCVUdfRklMVEVSLkZVREdFXTogRGVidWdBbGVydC5jcmVhdGVEZWxlZ2F0ZShERUJVR19TWU1CT0xbREVCVUdfRklMVEVSLkZVREdFXSlcclxuICAgIH07XHJcbiAgICBwdWJsaWMgc3RhdGljIGNyZWF0ZURlbGVnYXRlKF9oZWFkbGluZTogc3RyaW5nKTogRnVuY3Rpb24ge1xyXG4gICAgICBsZXQgZGVsZWdhdGU6IEZ1bmN0aW9uID0gZnVuY3Rpb24gKF9tZXNzYWdlOiBPYmplY3QsIC4uLl9hcmdzOiBPYmplY3RbXSk6IHZvaWQge1xyXG4gICAgICAgIGxldCBhcmdzOiBzdHJpbmdbXSA9IF9hcmdzLm1hcChfYXJnID0+IF9hcmcudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgbGV0IG91dDogc3RyaW5nID0gX2hlYWRsaW5lICsgXCIgXCIgKyBEZWJ1Z1RhcmdldC5tZXJnZUFyZ3VtZW50cyhfbWVzc2FnZSwgYXJncyk7XHJcbiAgICAgICAgYWxlcnQob3V0KTtcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIGRlbGVnYXRlO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiRGVidWdUYXJnZXQudHNcIi8+XHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBSb3V0aW5nIHRvIGEgSFRNTERpYWxvZ0VsZW1lbnRcclxuICAgICAqL1xyXG4gICAgZXhwb3J0IGNsYXNzIERlYnVnRGlhbG9nIGV4dGVuZHMgRGVidWdUYXJnZXQge1xyXG4gICAgICAgIC8vIFRPRE86IGNoZWNrb3V0IEhUTUxEaWFsb2dFbGVtZW50OyAhISFcclxuICAgIH1cclxufSIsIi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiRGVidWdUYXJnZXQudHNcIi8+XHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFJvdXRlIHRvIGFuIEhUTUxUZXh0QXJlYSwgbWF5IGJlIG9ic29sZXRlIHdoZW4gdXNpbmcgSFRNTERpYWxvZ0VsZW1lbnRcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgRGVidWdUZXh0QXJlYSBleHRlbmRzIERlYnVnVGFyZ2V0IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgdGV4dEFyZWE6IEhUTUxUZXh0QXJlYUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIik7XHJcbiAgICBwdWJsaWMgc3RhdGljIGF1dG9TY3JvbGw6IGJvb2xlYW4gPSB0cnVlO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZGVsZWdhdGVzOiBNYXBEZWJ1Z0ZpbHRlclRvRGVsZWdhdGUgPSB7XHJcbiAgICAgIFtERUJVR19GSUxURVIuSU5GT106IERlYnVnVGV4dEFyZWEuY3JlYXRlRGVsZWdhdGUoREVCVUdfU1lNQk9MW0RFQlVHX0ZJTFRFUi5JTkZPXSksXHJcbiAgICAgIFtERUJVR19GSUxURVIuTE9HXTogRGVidWdUZXh0QXJlYS5jcmVhdGVEZWxlZ2F0ZShERUJVR19TWU1CT0xbREVCVUdfRklMVEVSLkxPR10pLFxyXG4gICAgICBbREVCVUdfRklMVEVSLldBUk5dOiBEZWJ1Z1RleHRBcmVhLmNyZWF0ZURlbGVnYXRlKERFQlVHX1NZTUJPTFtERUJVR19GSUxURVIuV0FSTl0pLFxyXG4gICAgICBbREVCVUdfRklMVEVSLkVSUk9SXTogRGVidWdUZXh0QXJlYS5jcmVhdGVEZWxlZ2F0ZShERUJVR19TWU1CT0xbREVCVUdfRklMVEVSLkVSUk9SXSksXHJcbiAgICAgIFtERUJVR19GSUxURVIuRlVER0VdOiBEZWJ1Z1RleHRBcmVhLmNyZWF0ZURlbGVnYXRlKERFQlVHX1NZTUJPTFtERUJVR19GSUxURVIuRlVER0VdKSxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5DTEVBUl06IERlYnVnVGV4dEFyZWEuY2xlYXIsXHJcbiAgICAgIFtERUJVR19GSUxURVIuR1JPVVBdOiBEZWJ1Z1RleHRBcmVhLmdyb3VwLFxyXG4gICAgICBbREVCVUdfRklMVEVSLkdST1VQQ09MTEFQU0VEXTogRGVidWdUZXh0QXJlYS5ncm91cCxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5HUk9VUEVORF06IERlYnVnVGV4dEFyZWEuZ3JvdXBFbmRcclxuICAgIH07XHJcbiAgICBwcml2YXRlIHN0YXRpYyBncm91cHM6IHN0cmluZ1tdID0gW107XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBjbGVhcigpOiB2b2lkIHtcclxuICAgICAgRGVidWdUZXh0QXJlYS50ZXh0QXJlYS50ZXh0Q29udGVudCA9IFwiXCI7XHJcbiAgICAgIERlYnVnVGV4dEFyZWEuZ3JvdXBzID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBncm91cChfbmFtZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgIERlYnVnVGV4dEFyZWEucHJpbnQoXCLilrwgXCIgKyBfbmFtZSk7XHJcbiAgICAgIERlYnVnVGV4dEFyZWEuZ3JvdXBzLnB1c2goX25hbWUpO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHN0YXRpYyBncm91cEVuZCgpOiB2b2lkIHtcclxuICAgICAgRGVidWdUZXh0QXJlYS5ncm91cHMucG9wKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBjcmVhdGVEZWxlZ2F0ZShfaGVhZGxpbmU6IHN0cmluZyk6IEZ1bmN0aW9uIHtcclxuICAgICAgbGV0IGRlbGVnYXRlOiBGdW5jdGlvbiA9IGZ1bmN0aW9uIChfbWVzc2FnZTogT2JqZWN0LCAuLi5fYXJnczogT2JqZWN0W10pOiB2b2lkIHtcclxuICAgICAgICBEZWJ1Z1RleHRBcmVhLnByaW50KF9oZWFkbGluZSArIFwiIFwiICsgRGVidWdUYXJnZXQubWVyZ2VBcmd1bWVudHMoX21lc3NhZ2UsIF9hcmdzKSk7XHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBkZWxlZ2F0ZTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBnZXRJbmRlbnRhdGlvbihfbGV2ZWw6IG51bWJlcik6IHN0cmluZyB7XHJcbiAgICAgIGxldCByZXN1bHQ6IHN0cmluZyA9IFwiXCI7XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBfbGV2ZWw7IGkrKylcclxuICAgICAgICByZXN1bHQgKz0gXCJ8IFwiO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIHByaW50KF90ZXh0OiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgRGVidWdUZXh0QXJlYS50ZXh0QXJlYS50ZXh0Q29udGVudCArPSBEZWJ1Z1RleHRBcmVhLmdldEluZGVudGF0aW9uKERlYnVnVGV4dEFyZWEuZ3JvdXBzLmxlbmd0aCkgKyBfdGV4dCArIFwiXFxuXCI7XHJcbiAgICAgIGlmIChEZWJ1Z1RleHRBcmVhLmF1dG9TY3JvbGwpXHJcbiAgICAgICAgRGVidWdUZXh0QXJlYS50ZXh0QXJlYS5zY3JvbGxUb3AgPSBEZWJ1Z1RleHRBcmVhLnRleHRBcmVhLnNjcm9sbEhlaWdodDtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBEZWZpbmVzIGEgY29sb3IgYXMgdmFsdWVzIGluIHRoZSByYW5nZSBvZiAwIHRvIDEgZm9yIHRoZSBmb3VyIGNoYW5uZWxzIHJlZCwgZ3JlZW4sIGJsdWUgYW5kIGFscGhhIChmb3Igb3BhY2l0eSlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29sb3IgZXh0ZW5kcyBNdXRhYmxlIHsgLy9pbXBsZW1lbnRzIFNlcmlhbGl6YWJsZSB7XHJcbiAgICAvLyBjcmMyIG9ubHkgdXNlZCBmb3IgY29udmVydGluZyBjb2xvcnMgZnJvbSBzdHJpbmdzIHByZWRlZmluZWQgYnkgQ1NTXHJcbiAgICBwcml2YXRlIHN0YXRpYyBjcmMyOiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLmdldENvbnRleHQoXCIyZFwiKTtcclxuXHJcbiAgICBwdWJsaWMgcjogbnVtYmVyO1xyXG4gICAgcHVibGljIGc6IG51bWJlcjtcclxuICAgIHB1YmxpYyBiOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgYTogbnVtYmVyO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKF9yOiBudW1iZXIgPSAxLCBfZzogbnVtYmVyID0gMSwgX2I6IG51bWJlciA9IDEsIF9hOiBudW1iZXIgPSAxKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuc2V0Tm9ybVJHQkEoX3IsIF9nLCBfYiwgX2EpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0SGV4RnJvbUNTU0tleXdvcmQoX2tleXdvcmQ6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgIENvbG9yLmNyYzIuZmlsbFN0eWxlID0gX2tleXdvcmQ7XHJcbiAgICAgIHJldHVybiBDb2xvci5jcmMyLmZpbGxTdHlsZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIENTUyhfa2V5d29yZDogc3RyaW5nLCBfYWxwaGE6IG51bWJlciA9IDEpOiBDb2xvciB7XHJcbiAgICAgIGxldCBoZXg6IHN0cmluZyA9IENvbG9yLmdldEhleEZyb21DU1NLZXl3b3JkKF9rZXl3b3JkKTtcclxuICAgICAgbGV0IGNvbG9yOiBDb2xvciA9IG5ldyBDb2xvcihcclxuICAgICAgICBwYXJzZUludChoZXguc3Vic3RyKDEsIDIpLCAxNikgLyAyNTUsXHJcbiAgICAgICAgcGFyc2VJbnQoaGV4LnN1YnN0cigzLCAyKSwgMTYpIC8gMjU1LFxyXG4gICAgICAgIHBhcnNlSW50KGhleC5zdWJzdHIoNSwgMiksIDE2KSAvIDI1NSxcclxuICAgICAgICBfYWxwaGEpO1xyXG4gICAgICByZXR1cm4gY29sb3I7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgTVVMVElQTFkoX2NvbG9yMTogQ29sb3IsIF9jb2xvcjI6IENvbG9yKTogQ29sb3Ige1xyXG4gICAgICByZXR1cm4gbmV3IENvbG9yKF9jb2xvcjEuciAqIF9jb2xvcjIuciwgX2NvbG9yMS5nICogX2NvbG9yMi5nLCBfY29sb3IxLmIgKiBfY29sb3IyLmIsIF9jb2xvcjEuYSAqIF9jb2xvcjIuYSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldE5vcm1SR0JBKF9yOiBudW1iZXIsIF9nOiBudW1iZXIsIF9iOiBudW1iZXIsIF9hOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy5yID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgX3IpKTtcclxuICAgICAgdGhpcy5nID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgX2cpKTtcclxuICAgICAgdGhpcy5iID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgX2IpKTtcclxuICAgICAgdGhpcy5hID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgX2EpKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0Qnl0ZXNSR0JBKF9yOiBudW1iZXIsIF9nOiBudW1iZXIsIF9iOiBudW1iZXIsIF9hOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy5zZXROb3JtUkdCQShfciAvIDI1NSwgX2cgLyAyNTUsIF9iIC8gMjU1LCBfYSAvIDI1NSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEFycmF5KCk6IEZsb2F0MzJBcnJheSB7XHJcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KFt0aGlzLnIsIHRoaXMuZywgdGhpcy5iLCB0aGlzLmFdKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0QXJyYXlOb3JtUkdCQShfY29sb3I6IEZsb2F0MzJBcnJheSk6IHZvaWQge1xyXG4gICAgICB0aGlzLnNldE5vcm1SR0JBKF9jb2xvclswXSwgX2NvbG9yWzFdLCBfY29sb3JbMl0sIF9jb2xvclszXSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldEFycmF5Qnl0ZXNSR0JBKF9jb2xvcjogVWludDhDbGFtcGVkQXJyYXkpOiB2b2lkIHtcclxuICAgICAgdGhpcy5zZXRCeXRlc1JHQkEoX2NvbG9yWzBdLCBfY29sb3JbMV0sIF9jb2xvclsyXSwgX2NvbG9yWzNdKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0QXJyYXlCeXRlc1JHQkEoKTogVWludDhDbGFtcGVkQXJyYXkge1xyXG4gICAgICByZXR1cm4gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KFt0aGlzLnIgKiAyNTUsIHRoaXMuZyAqIDI1NSwgdGhpcy5iICogMjU1LCB0aGlzLmEgKiAyNTVdKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYWRkKF9jb2xvcjogQ29sb3IpOiB2b2lkIHtcclxuICAgICAgdGhpcy5yICs9IF9jb2xvci5yO1xyXG4gICAgICB0aGlzLmcgKz0gX2NvbG9yLmc7XHJcbiAgICAgIHRoaXMuYiArPSBfY29sb3IuYjtcclxuICAgICAgdGhpcy5hICs9IF9jb2xvci5hO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRDU1MoKTogc3RyaW5nIHtcclxuICAgICAgbGV0IGJ5dGVzOiBVaW50OENsYW1wZWRBcnJheSA9IHRoaXMuZ2V0QXJyYXlCeXRlc1JHQkEoKTtcclxuICAgICAgcmV0dXJuIGBSR0JBKCR7Ynl0ZXNbMF19LCAke2J5dGVzWzFdfSwgJHtieXRlc1syXX0sICR7Ynl0ZXNbM119KWA7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEhleCgpOiBzdHJpbmcge1xyXG4gICAgICBsZXQgYnl0ZXM6IFVpbnQ4Q2xhbXBlZEFycmF5ID0gdGhpcy5nZXRBcnJheUJ5dGVzUkdCQSgpO1xyXG4gICAgICBsZXQgaGV4OiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgICBmb3IgKGxldCBieXRlIG9mIGJ5dGVzKVxyXG4gICAgICAgIGhleCArPSBieXRlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIik7XHJcbiAgICAgIHJldHVybiBoZXg7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldEhleChfaGV4OiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgbGV0IGJ5dGVzOiBVaW50OENsYW1wZWRBcnJheSA9IHRoaXMuZ2V0QXJyYXlCeXRlc1JHQkEoKTtcclxuICAgICAgbGV0IGNoYW5uZWw6IG51bWJlciA9IDA7XHJcbiAgICAgIGZvciAobGV0IGJ5dGUgaW4gYnl0ZXMpXHJcbiAgICAgICAgYnl0ZXNbYnl0ZV0gPSBwYXJzZUludChfaGV4LnN1YnN0cihjaGFubmVsKysgKiAyLCAyKSwgMTYpO1xyXG4gICAgICB0aGlzLnNldEFycmF5Qnl0ZXNSR0JBKGJ5dGVzKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQgey8qKiAqLyB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQmFzZWNsYXNzIGZvciBtYXRlcmlhbHMuIENvbWJpbmVzIGEgW1tTaGFkZXJdXSB3aXRoIGEgY29tcGF0aWJsZSBbW0NvYXRdXVxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE1hdGVyaWFsIGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZVJlc291cmNlIHtcclxuICAgIC8qKiBUaGUgbmFtZSB0byBjYWxsIHRoZSBNYXRlcmlhbCBieS4gKi9cclxuICAgIHB1YmxpYyBuYW1lOiBzdHJpbmc7XHJcbiAgICBwdWJsaWMgaWRSZXNvdXJjZTogc3RyaW5nID0gdW5kZWZpbmVkO1xyXG4gICAgcHJpdmF0ZSBzaGFkZXJUeXBlOiB0eXBlb2YgU2hhZGVyOyAvLyBUaGUgc2hhZGVyIHByb2dyYW0gdXNlZCBieSB0aGlzIEJhc2VNYXRlcmlhbFxyXG4gICAgcHJpdmF0ZSBjb2F0OiBDb2F0O1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nLCBfc2hhZGVyPzogdHlwZW9mIFNoYWRlciwgX2NvYXQ/OiBDb2F0KSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMubmFtZSA9IF9uYW1lO1xyXG4gICAgICB0aGlzLnNoYWRlclR5cGUgPSBfc2hhZGVyO1xyXG4gICAgICBpZiAoX3NoYWRlcikge1xyXG4gICAgICAgIGlmIChfY29hdClcclxuICAgICAgICAgIHRoaXMuc2V0Q29hdChfY29hdCk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgdGhpcy5zZXRDb2F0KHRoaXMuY3JlYXRlQ29hdE1hdGNoaW5nU2hhZGVyKCkpO1xyXG4gICAgICB9XHJcbiAgICAgIFJlc291cmNlTWFuYWdlci5yZWdpc3Rlcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgW1tDb2F0XV0gaW5zdGFuY2UgdGhhdCBpcyB2YWxpZCBmb3IgdGhlIFtbU2hhZGVyXV0gcmVmZXJlbmNlZCBieSB0aGlzIG1hdGVyaWFsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjcmVhdGVDb2F0TWF0Y2hpbmdTaGFkZXIoKTogQ29hdCB7XHJcbiAgICAgIGxldCBjb2F0OiBDb2F0ID0gbmV3ICh0aGlzLnNoYWRlclR5cGUuZ2V0Q29hdCgpKSgpO1xyXG4gICAgICByZXR1cm4gY29hdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1ha2VzIHRoaXMgbWF0ZXJpYWwgcmVmZXJlbmNlIHRoZSBnaXZlbiBbW0NvYXRdXSBpZiBpdCBpcyBjb21wYXRpYmxlIHdpdGggdGhlIHJlZmVyZW5jZWQgW1tTaGFkZXJdXVxyXG4gICAgICogQHBhcmFtIF9jb2F0IFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0Q29hdChfY29hdDogQ29hdCk6IHZvaWQge1xyXG4gICAgICBpZiAoX2NvYXQuY29uc3RydWN0b3IgIT0gdGhpcy5zaGFkZXJUeXBlLmdldENvYXQoKSlcclxuICAgICAgICB0aHJvdyAobmV3IEVycm9yKFwiU2hhZGVyIGFuZCBjb2F0IGRvbid0IG1hdGNoXCIpKTtcclxuICAgICAgdGhpcy5jb2F0ID0gX2NvYXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50bHkgcmVmZXJlbmNlZCBbW0NvYXRdXSBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Q29hdCgpOiBDb2F0IHtcclxuICAgICAgcmV0dXJuIHRoaXMuY29hdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZXMgdGhlIG1hdGVyaWFscyByZWZlcmVuY2UgdG8gdGhlIGdpdmVuIFtbU2hhZGVyXV0sIGNyZWF0ZXMgYW5kIHJlZmVyZW5jZXMgYSBuZXcgW1tDb2F0XV0gaW5zdGFuY2UgIFxyXG4gICAgICogYW5kIG11dGF0ZXMgdGhlIG5ldyBjb2F0IHRvIHByZXNlcnZlIG1hdGNoaW5nIHByb3BlcnRpZXMuXHJcbiAgICAgKiBAcGFyYW0gX3NoYWRlclR5cGUgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRTaGFkZXIoX3NoYWRlclR5cGU6IHR5cGVvZiBTaGFkZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy5zaGFkZXJUeXBlID0gX3NoYWRlclR5cGU7XHJcbiAgICAgIGxldCBjb2F0OiBDb2F0ID0gdGhpcy5jcmVhdGVDb2F0TWF0Y2hpbmdTaGFkZXIoKTtcclxuICAgICAgY29hdC5tdXRhdGUodGhpcy5jb2F0LmdldE11dGF0b3IoKSk7XHJcbiAgICAgIHRoaXMuc2V0Q29hdChjb2F0KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIFtbU2hhZGVyXV0gcmVmZXJlbmNlZCBieSB0aGlzIG1hdGVyaWFsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRTaGFkZXIoKTogdHlwZW9mIFNoYWRlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNoYWRlclR5cGU7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgLy8gVE9ETzogdGhpcyB0eXBlIG9mIHNlcmlhbGl6YXRpb24gd2FzIGltcGxlbWVudGVkIGZvciBpbXBsaWNpdCBNYXRlcmlhbCBjcmVhdGUuIENoZWNrIGlmIG9ic29sZXRlIHdoZW4gb25seSBvbmUgbWF0ZXJpYWwgY2xhc3MgZXhpc3RzIGFuZC9vciBtYXRlcmlhbHMgYXJlIHN0b3JlZCBzZXBhcmF0ZWx5XHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHtcclxuICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgaWRSZXNvdXJjZTogdGhpcy5pZFJlc291cmNlLFxyXG4gICAgICAgIHNoYWRlcjogdGhpcy5zaGFkZXJUeXBlLm5hbWUsXHJcbiAgICAgICAgY29hdDogU2VyaWFsaXplci5zZXJpYWxpemUodGhpcy5jb2F0KVxyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFNlcmlhbGl6YWJsZSB7XHJcbiAgICAgIHRoaXMubmFtZSA9IF9zZXJpYWxpemF0aW9uLm5hbWU7XHJcbiAgICAgIHRoaXMuaWRSZXNvdXJjZSA9IF9zZXJpYWxpemF0aW9uLmlkUmVzb3VyY2U7XHJcbiAgICAgIC8vIFRPRE86IHByb3ZpZGUgZm9yIHNoYWRlcnMgaW4gdGhlIHVzZXJzIG5hbWVzcGFjZS4gU2VlIFNlcmlhbGl6ZXIgZnVsbHBhdGggZXRjLlxyXG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLWFueVxyXG4gICAgICB0aGlzLnNoYWRlclR5cGUgPSAoPGFueT5GdWRnZUNvcmUpW19zZXJpYWxpemF0aW9uLnNoYWRlcl07XHJcbiAgICAgIGxldCBjb2F0OiBDb2F0ID0gPENvYXQ+U2VyaWFsaXplci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5jb2F0KTtcclxuICAgICAgdGhpcy5zZXRDb2F0KGNvYXQpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgLy9cclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gICAgZXhwb3J0IGludGVyZmFjZSBTZXJpYWxpemFibGVSZXNvdXJjZSBleHRlbmRzIFNlcmlhbGl6YWJsZSB7XHJcbiAgICAgICAgaWRSZXNvdXJjZTogc3RyaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIGV4cG9ydCBpbnRlcmZhY2UgUmVzb3VyY2VzIHtcclxuICAgICAgICBbaWRSZXNvdXJjZTogc3RyaW5nXTogU2VyaWFsaXphYmxlUmVzb3VyY2U7XHJcbiAgICB9XHJcblxyXG4gICAgZXhwb3J0IGludGVyZmFjZSBTZXJpYWxpemF0aW9uT2ZSZXNvdXJjZXMge1xyXG4gICAgICAgIFtpZFJlc291cmNlOiBzdHJpbmddOiBTZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RhdGljIGNsYXNzIGhhbmRsaW5nIHRoZSByZXNvdXJjZXMgdXNlZCB3aXRoIHRoZSBjdXJyZW50IEZVREdFLWluc3RhbmNlLiAgXHJcbiAgICAgKiBLZWVwcyBhIGxpc3Qgb2YgdGhlIHJlc291cmNlcyBhbmQgZ2VuZXJhdGVzIGlkcyB0byByZXRyaWV2ZSB0aGVtLiAgXHJcbiAgICAgKiBSZXNvdXJjZXMgYXJlIG9iamVjdHMgcmVmZXJlbmNlZCBtdWx0aXBsZSB0aW1lcyBidXQgc3VwcG9zZWQgdG8gYmUgc3RvcmVkIG9ubHkgb25jZVxyXG4gICAgICovXHJcbiAgICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgUmVzb3VyY2VNYW5hZ2VyIHtcclxuICAgICAgICBwdWJsaWMgc3RhdGljIHJlc291cmNlczogUmVzb3VyY2VzID0ge307XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uT2ZSZXNvdXJjZXMgPSBudWxsO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZW5lcmF0ZXMgYW4gaWQgZm9yIHRoZSByZXNvdXJjZXMgYW5kIHJlZ2lzdGVycyBpdCB3aXRoIHRoZSBsaXN0IG9mIHJlc291cmNlcyBcclxuICAgICAgICAgKiBAcGFyYW0gX3Jlc291cmNlIFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgcmVnaXN0ZXIoX3Jlc291cmNlOiBTZXJpYWxpemFibGVSZXNvdXJjZSk6IHZvaWQge1xyXG4gICAgICAgICAgICBpZiAoIV9yZXNvdXJjZS5pZFJlc291cmNlKVxyXG4gICAgICAgICAgICAgICAgX3Jlc291cmNlLmlkUmVzb3VyY2UgPSBSZXNvdXJjZU1hbmFnZXIuZ2VuZXJhdGVJZChfcmVzb3VyY2UpO1xyXG4gICAgICAgICAgICBSZXNvdXJjZU1hbmFnZXIucmVzb3VyY2VzW19yZXNvdXJjZS5pZFJlc291cmNlXSA9IF9yZXNvdXJjZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdlbmVyYXRlIGEgdXNlciByZWFkYWJsZSBhbmQgdW5pcXVlIGlkIHVzaW5nIHRoZSB0eXBlIG9mIHRoZSByZXNvdXJjZSwgdGhlIGRhdGUgYW5kIHJhbmRvbSBudW1iZXJzXHJcbiAgICAgICAgICogQHBhcmFtIF9yZXNvdXJjZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgZ2VuZXJhdGVJZChfcmVzb3VyY2U6IFNlcmlhbGl6YWJsZVJlc291cmNlKTogc3RyaW5nIHtcclxuICAgICAgICAgICAgLy8gVE9ETzogYnVpbGQgaWQgYW5kIGludGVncmF0ZSBpbmZvIGZyb20gcmVzb3VyY2UsIG5vdCBqdXN0IGRhdGVcclxuICAgICAgICAgICAgbGV0IGlkUmVzb3VyY2U6IHN0cmluZztcclxuICAgICAgICAgICAgZG9cclxuICAgICAgICAgICAgICAgIGlkUmVzb3VyY2UgPSBfcmVzb3VyY2UuY29uc3RydWN0b3IubmFtZSArIFwifFwiICsgbmV3IERhdGUoKS50b0lTT1N0cmluZygpICsgXCJ8XCIgKyBNYXRoLnJhbmRvbSgpLnRvUHJlY2lzaW9uKDUpLnN1YnN0cigyLCA1KTtcclxuICAgICAgICAgICAgd2hpbGUgKFJlc291cmNlTWFuYWdlci5yZXNvdXJjZXNbaWRSZXNvdXJjZV0pO1xyXG4gICAgICAgICAgICByZXR1cm4gaWRSZXNvdXJjZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRlc3RzLCBpZiBhbiBvYmplY3QgaXMgYSBbW1NlcmlhbGl6YWJsZVJlc291cmNlXV1cclxuICAgICAgICAgKiBAcGFyYW0gX29iamVjdCBUaGUgb2JqZWN0IHRvIGV4YW1pbmVcclxuICAgICAgICAgKi9cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGlzUmVzb3VyY2UoX29iamVjdDogU2VyaWFsaXphYmxlKTogYm9vbGVhbiB7XHJcbiAgICAgICAgICAgIHJldHVybiAoUmVmbGVjdC5oYXMoX29iamVjdCwgXCJpZFJlc291cmNlXCIpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHJpZXZlcyB0aGUgcmVzb3VyY2Ugc3RvcmVkIHdpdGggdGhlIGdpdmVuIGlkXHJcbiAgICAgICAgICogQHBhcmFtIF9pZFJlc291cmNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBnZXQoX2lkUmVzb3VyY2U6IHN0cmluZyk6IFNlcmlhbGl6YWJsZVJlc291cmNlIHtcclxuICAgICAgICAgICAgbGV0IHJlc291cmNlOiBTZXJpYWxpemFibGVSZXNvdXJjZSA9IFJlc291cmNlTWFuYWdlci5yZXNvdXJjZXNbX2lkUmVzb3VyY2VdO1xyXG4gICAgICAgICAgICBpZiAoIXJlc291cmNlKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IFJlc291cmNlTWFuYWdlci5zZXJpYWxpemF0aW9uW19pZFJlc291cmNlXTtcclxuICAgICAgICAgICAgICAgIGlmICghc2VyaWFsaXphdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIERlYnVnLmVycm9yKFwiUmVzb3VyY2Ugbm90IGZvdW5kXCIsIF9pZFJlc291cmNlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc291cmNlID0gUmVzb3VyY2VNYW5hZ2VyLmRlc2VyaWFsaXplUmVzb3VyY2Uoc2VyaWFsaXphdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc291cmNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhbmQgcmVnaXN0ZXJzIGEgcmVzb3VyY2UgZnJvbSBhIFtbTm9kZV1dLCBjb3B5aW5nIHRoZSBjb21wbGV0ZSBncmFwaCBzdGFydGluZyB3aXRoIGl0XHJcbiAgICAgICAgICogQHBhcmFtIF9ub2RlIEEgbm9kZSB0byBjcmVhdGUgdGhlIHJlc291cmNlIGZyb21cclxuICAgICAgICAgKiBAcGFyYW0gX3JlcGxhY2VXaXRoSW5zdGFuY2UgaWYgdHJ1ZSAoZGVmYXVsdCksIHRoZSBub2RlIHVzZWQgYXMgb3JpZ2luIGlzIHJlcGxhY2VkIGJ5IGEgW1tOb2RlUmVzb3VyY2VJbnN0YW5jZV1dIG9mIHRoZSBbW05vZGVSZXNvdXJjZV1dIGNyZWF0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBwdWJsaWMgc3RhdGljIHJlZ2lzdGVyTm9kZUFzUmVzb3VyY2UoX25vZGU6IE5vZGUsIF9yZXBsYWNlV2l0aEluc3RhbmNlOiBib29sZWFuID0gdHJ1ZSk6IE5vZGVSZXNvdXJjZSB7XHJcbiAgICAgICAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gX25vZGUuc2VyaWFsaXplKCk7XHJcbiAgICAgICAgICAgIGxldCBub2RlUmVzb3VyY2U6IE5vZGVSZXNvdXJjZSA9IG5ldyBOb2RlUmVzb3VyY2UoXCJOb2RlUmVzb3VyY2VcIik7XHJcbiAgICAgICAgICAgIG5vZGVSZXNvdXJjZS5kZXNlcmlhbGl6ZShzZXJpYWxpemF0aW9uKTtcclxuICAgICAgICAgICAgUmVzb3VyY2VNYW5hZ2VyLnJlZ2lzdGVyKG5vZGVSZXNvdXJjZSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoX3JlcGxhY2VXaXRoSW5zdGFuY2UgJiYgX25vZGUuZ2V0UGFyZW50KCkpIHtcclxuICAgICAgICAgICAgICAgIGxldCBpbnN0YW5jZTogTm9kZVJlc291cmNlSW5zdGFuY2UgPSBuZXcgTm9kZVJlc291cmNlSW5zdGFuY2Uobm9kZVJlc291cmNlKTtcclxuICAgICAgICAgICAgICAgIF9ub2RlLmdldFBhcmVudCgpLnJlcGxhY2VDaGlsZChfbm9kZSwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbm9kZVJlc291cmNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2VyaWFsaXplIGFsbCByZXNvdXJjZXNcclxuICAgICAgICAgKi9cclxuICAgICAgICBwdWJsaWMgc3RhdGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uT2ZSZXNvdXJjZXMge1xyXG4gICAgICAgICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbk9mUmVzb3VyY2VzID0ge307XHJcbiAgICAgICAgICAgIGZvciAobGV0IGlkUmVzb3VyY2UgaW4gUmVzb3VyY2VNYW5hZ2VyLnJlc291cmNlcykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlc291cmNlOiBTZXJpYWxpemFibGVSZXNvdXJjZSA9IFJlc291cmNlTWFuYWdlci5yZXNvdXJjZXNbaWRSZXNvdXJjZV07XHJcbiAgICAgICAgICAgICAgICBpZiAoaWRSZXNvdXJjZSAhPSByZXNvdXJjZS5pZFJlc291cmNlKVxyXG4gICAgICAgICAgICAgICAgICAgIERlYnVnLmVycm9yKFwiUmVzb3VyY2UtaWQgbWlzbWF0Y2hcIiwgcmVzb3VyY2UpO1xyXG4gICAgICAgICAgICAgICAgc2VyaWFsaXphdGlvbltpZFJlc291cmNlXSA9IFNlcmlhbGl6ZXIuc2VyaWFsaXplKHJlc291cmNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZSByZXNvdXJjZXMgZnJvbSBhIHNlcmlhbGl6YXRpb24sIGRlbGV0aW5nIGFsbCByZXNvdXJjZXMgcHJldmlvdXNseSByZWdpc3RlcmVkXHJcbiAgICAgICAgICogQHBhcmFtIF9zZXJpYWxpemF0aW9uIFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb25PZlJlc291cmNlcyk6IFJlc291cmNlcyB7XHJcbiAgICAgICAgICAgIFJlc291cmNlTWFuYWdlci5zZXJpYWxpemF0aW9uID0gX3NlcmlhbGl6YXRpb247XHJcbiAgICAgICAgICAgIFJlc291cmNlTWFuYWdlci5yZXNvdXJjZXMgPSB7fTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaWRSZXNvdXJjZSBpbiBfc2VyaWFsaXphdGlvbikge1xyXG4gICAgICAgICAgICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSBfc2VyaWFsaXphdGlvbltpZFJlc291cmNlXTtcclxuICAgICAgICAgICAgICAgIGxldCByZXNvdXJjZTogU2VyaWFsaXphYmxlUmVzb3VyY2UgPSBSZXNvdXJjZU1hbmFnZXIuZGVzZXJpYWxpemVSZXNvdXJjZShzZXJpYWxpemF0aW9uKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXNvdXJjZSlcclxuICAgICAgICAgICAgICAgICAgICBSZXNvdXJjZU1hbmFnZXIucmVzb3VyY2VzW2lkUmVzb3VyY2VdID0gcmVzb3VyY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFJlc291cmNlTWFuYWdlci5yZXNvdXJjZXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBkZXNlcmlhbGl6ZVJlc291cmNlKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogU2VyaWFsaXphYmxlUmVzb3VyY2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gPFNlcmlhbGl6YWJsZVJlc291cmNlPlNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIENvbnRyb2xzIHRoZSByZW5kZXJpbmcgb2YgYSBncmFwaCwgdXNpbmcgdGhlIGdpdmVuIFtbQ29tcG9uZW50Q2FtZXJhXV0sXHJcbiAgICogYW5kIHRoZSBwcm9wYWdhdGlvbiBvZiB0aGUgcmVuZGVyZWQgaW1hZ2UgZnJvbSB0aGUgb2Zmc2NyZWVuIHJlbmRlcmJ1ZmZlciB0byB0aGUgdGFyZ2V0IGNhbnZhc1xyXG4gICAqIHRocm91Z2ggYSBzZXJpZXMgb2YgW1tGcmFtaW5nXV0gb2JqZWN0cy4gVGhlIHN0YWdlcyBpbnZvbHZlZCBhcmUgaW4gb3JkZXIgb2YgcmVuZGVyaW5nXHJcbiAgICogW1tSZW5kZXJNYW5hZ2VyXV0udmlld3BvcnQgLT4gW1tWaWV3cG9ydF1dLnNvdXJjZSAtPiBbW1ZpZXdwb3J0XV0uZGVzdGluYXRpb24gLT4gRE9NLUNhbnZhcyAtPiBDbGllbnQoQ1NTKVxyXG4gICAqIEBhdXRob3JzIEphc2NoYSBLYXJhZ8O2bCwgSEZVLCAyMDE5IHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgVmlld3BvcnQgZXh0ZW5kcyBFdmVudFRhcmdldMaSIHtcclxuICAgIHByaXZhdGUgc3RhdGljIGZvY3VzOiBWaWV3cG9ydDtcclxuXHJcbiAgICBwdWJsaWMgbmFtZTogc3RyaW5nID0gXCJWaWV3cG9ydFwiOyAvLyBUaGUgbmFtZSB0byBjYWxsIHRoaXMgdmlld3BvcnQgYnkuXHJcbiAgICBwdWJsaWMgY2FtZXJhOiBDb21wb25lbnRDYW1lcmEgPSBudWxsOyAvLyBUaGUgY2FtZXJhIHJlcHJlc2VudGluZyB0aGUgdmlldyBwYXJhbWV0ZXJzIHRvIHJlbmRlciB0aGUgZ3JhcGguXHJcblxyXG4gICAgcHVibGljIHJlY3RTb3VyY2U6IFJlY3RhbmdsZTtcclxuICAgIHB1YmxpYyByZWN0RGVzdGluYXRpb246IFJlY3RhbmdsZTtcclxuXHJcbiAgICAvLyBUT0RPOiB2ZXJpZnkgaWYgY2xpZW50IHRvIGNhbnZhcyBzaG91bGQgYmUgaW4gVmlld3BvcnQgb3Igc29tZXdoZXJlIGVsc2UgKFdpbmRvdywgQ29udGFpbmVyPylcclxuICAgIC8vIE11bHRpcGxlIHZpZXdwb3J0cyB1c2luZyB0aGUgc2FtZSBjYW52YXMgc2hvdWxkbid0IGRpZmZlciBoZXJlLi4uXHJcbiAgICAvLyBkaWZmZXJlbnQgZnJhbWluZyBtZXRob2RzIGNhbiBiZSB1c2VkLCB0aGlzIGlzIHRoZSBkZWZhdWx0XHJcbiAgICBwdWJsaWMgZnJhbWVDbGllbnRUb0NhbnZhczogRnJhbWluZ1NjYWxlZCA9IG5ldyBGcmFtaW5nU2NhbGVkKCk7XHJcbiAgICBwdWJsaWMgZnJhbWVDYW52YXNUb0Rlc3RpbmF0aW9uOiBGcmFtaW5nQ29tcGxleCA9IG5ldyBGcmFtaW5nQ29tcGxleCgpO1xyXG4gICAgcHVibGljIGZyYW1lRGVzdGluYXRpb25Ub1NvdXJjZTogRnJhbWluZ1NjYWxlZCA9IG5ldyBGcmFtaW5nU2NhbGVkKCk7XHJcbiAgICBwdWJsaWMgZnJhbWVTb3VyY2VUb1JlbmRlcjogRnJhbWluZ1NjYWxlZCA9IG5ldyBGcmFtaW5nU2NhbGVkKCk7XHJcblxyXG4gICAgcHVibGljIGFkanVzdGluZ0ZyYW1lczogYm9vbGVhbiA9IHRydWU7XHJcbiAgICBwdWJsaWMgYWRqdXN0aW5nQ2FtZXJhOiBib29sZWFuID0gdHJ1ZTtcclxuXHJcblxyXG4gICAgcHJpdmF0ZSBncmFwaDogTm9kZSA9IG51bGw7IC8vIFRoZSBmaXJzdCBub2RlIGluIHRoZSBncmFwaCB0aGF0IHdpbGwgYmUgcmVuZGVyZWQuXHJcbiAgICBwcml2YXRlIGNyYzI6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCA9IG51bGw7XHJcbiAgICBwcml2YXRlIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQgPSBudWxsO1xyXG4gICAgcHJpdmF0ZSBwaWNrQnVmZmVyczogUGlja0J1ZmZlcltdID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25uZWN0cyB0aGUgdmlld3BvcnQgdG8gdGhlIGdpdmVuIGNhbnZhcyB0byByZW5kZXIgdGhlIGdpdmVuIGdyYXBoIHRvIHVzaW5nIHRoZSBnaXZlbiBjYW1lcmEtY29tcG9uZW50LCBhbmQgbmFtZXMgdGhlIHZpZXdwb3J0IGFzIGdpdmVuLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaW5pdGlhbGl6ZShfbmFtZTogc3RyaW5nLCBfZ3JhcGg6IE5vZGUsIF9jYW1lcmE6IENvbXBvbmVudENhbWVyYSwgX2NhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpOiB2b2lkIHtcclxuICAgICAgdGhpcy5uYW1lID0gX25hbWU7XHJcbiAgICAgIHRoaXMuY2FtZXJhID0gX2NhbWVyYTtcclxuICAgICAgdGhpcy5jYW52YXMgPSBfY2FudmFzO1xyXG4gICAgICB0aGlzLmNyYzIgPSBfY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuXHJcbiAgICAgIHRoaXMucmVjdFNvdXJjZSA9IFJlbmRlck1hbmFnZXIuZ2V0Q2FudmFzUmVjdCgpO1xyXG4gICAgICB0aGlzLnJlY3REZXN0aW5hdGlvbiA9IHRoaXMuZ2V0Q2xpZW50UmVjdGFuZ2xlKCk7XHJcblxyXG4gICAgICB0aGlzLnNldEdyYXBoKF9ncmFwaCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlIHRoZSAyRC1jb250ZXh0IGF0dGFjaGVkIHRvIHRoZSBkZXN0aW5hdGlvbiBjYW52YXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldENvbnRleHQoKTogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY3JjMjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmUgdGhlIHNpemUgb2YgdGhlIGRlc3RpbmF0aW9uIGNhbnZhcyBhcyBhIHJlY3RhbmdsZSwgeCBhbmQgeSBhcmUgYWx3YXlzIDAgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRDYW52YXNSZWN0YW5nbGUoKTogUmVjdGFuZ2xlIHtcclxuICAgICAgcmV0dXJuIFJlY3RhbmdsZS5HRVQoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlIHRoZSBjbGllbnQgcmVjdGFuZ2xlIHRoZSBjYW52YXMgaXMgZGlzcGxheWVkIGFuZCBmaXQgaW4sIHggYW5kIHkgYXJlIGFsd2F5cyAwIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Q2xpZW50UmVjdGFuZ2xlKCk6IFJlY3RhbmdsZSB7XHJcbiAgICAgIC8vIEZVREdFIGRvZXNuJ3QgY2FyZSBhYm91dCB3aGVyZSB0aGUgY2xpZW50IHJlY3QgaXMsIG9ubHkgYWJvdXQgdGhlIHNpemUgbWF0dGVycy5cclxuICAgICAgLy8gcmV0dXJuIFJlY3RhbmdsZS5HRVQodGhpcy5jYW52YXMub2Zmc2V0TGVmdCwgdGhpcy5jYW52YXMub2Zmc2V0VG9wLCB0aGlzLmNhbnZhcy5jbGllbnRXaWR0aCwgdGhpcy5jYW52YXMuY2xpZW50SGVpZ2h0KTtcclxuICAgICAgcmV0dXJuIFJlY3RhbmdsZS5HRVQoMCwgMCwgdGhpcy5jYW52YXMuY2xpZW50V2lkdGgsIHRoaXMuY2FudmFzLmNsaWVudEhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGdyYXBoIHRvIGJlIGRyYXduIGluIHRoZSB2aWV3cG9ydC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldEdyYXBoKF9ncmFwaDogTm9kZSk6IHZvaWQge1xyXG4gICAgICBpZiAodGhpcy5ncmFwaCkge1xyXG4gICAgICAgIHRoaXMuZ3JhcGgucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVC5DT01QT05FTlRfQURELCB0aGlzLmhuZENvbXBvbmVudEV2ZW50KTtcclxuICAgICAgICB0aGlzLmdyYXBoLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlQuQ09NUE9ORU5UX1JFTU9WRSwgdGhpcy5obmRDb21wb25lbnRFdmVudCk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5ncmFwaCA9IF9ncmFwaDtcclxuICAgICAgaWYgKHRoaXMuZ3JhcGgpIHtcclxuICAgICAgICB0aGlzLmdyYXBoLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuQ09NUE9ORU5UX0FERCwgdGhpcy5obmRDb21wb25lbnRFdmVudCk7XHJcbiAgICAgICAgdGhpcy5ncmFwaC5hZGRFdmVudExpc3RlbmVyKEVWRU5ULkNPTVBPTkVOVF9SRU1PVkUsIHRoaXMuaG5kQ29tcG9uZW50RXZlbnQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIExvZ3MgdGhpcyB2aWV3cG9ydHMgc2NlbmVncmFwaCB0byB0aGUgY29uc29sZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNob3dTY2VuZUdyYXBoKCk6IHZvaWQge1xyXG4gICAgICAvLyBUT0RPOiBtb3ZlIHRvIGRlYnVnLWNsYXNzXHJcbiAgICAgIGxldCBvdXRwdXQ6IHN0cmluZyA9IFwiU2NlbmVHcmFwaCBmb3IgdGhpcyB2aWV3cG9ydDpcIjtcclxuICAgICAgb3V0cHV0ICs9IFwiXFxuIFxcblwiO1xyXG4gICAgICBvdXRwdXQgKz0gdGhpcy5ncmFwaC5uYW1lO1xyXG4gICAgICBEZWJ1Zy5sb2cob3V0cHV0ICsgXCIgICA9PiBST09UTk9ERVwiICsgdGhpcy5jcmVhdGVTY2VuZUdyYXBoKHRoaXMuZ3JhcGgpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAjcmVnaW9uIERyYXdpbmdcclxuICAgIC8qKlxyXG4gICAgICogRHJhdyB0aGlzIHZpZXdwb3J0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBkcmF3KCk6IHZvaWQge1xyXG4gICAgICBSZW5kZXJNYW5hZ2VyLnJlc2V0RnJhbWVCdWZmZXIoKTtcclxuICAgICAgaWYgKCF0aGlzLmNhbWVyYS5pc0FjdGl2ZSlcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIGlmICh0aGlzLmFkanVzdGluZ0ZyYW1lcylcclxuICAgICAgICB0aGlzLmFkanVzdEZyYW1lcygpO1xyXG4gICAgICBpZiAodGhpcy5hZGp1c3RpbmdDYW1lcmEpXHJcbiAgICAgICAgdGhpcy5hZGp1c3RDYW1lcmEoKTtcclxuXHJcbiAgICAgIFJlbmRlck1hbmFnZXIuY2xlYXIodGhpcy5jYW1lcmEuYmFja2dyb3VuZENvbG9yKTtcclxuICAgICAgUmVuZGVyTWFuYWdlci5kcmF3R3JhcGgodGhpcy5ncmFwaCwgdGhpcy5jYW1lcmEpO1xyXG5cclxuICAgICAgdGhpcy5jcmMyLmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICB0aGlzLmNyYzIuZHJhd0ltYWdlKFxyXG4gICAgICAgIFJlbmRlck1hbmFnZXIuZ2V0Q2FudmFzKCksXHJcbiAgICAgICAgdGhpcy5yZWN0U291cmNlLngsIHRoaXMucmVjdFNvdXJjZS55LCB0aGlzLnJlY3RTb3VyY2Uud2lkdGgsIHRoaXMucmVjdFNvdXJjZS5oZWlnaHQsXHJcbiAgICAgICAgdGhpcy5yZWN0RGVzdGluYXRpb24ueCwgdGhpcy5yZWN0RGVzdGluYXRpb24ueSwgdGhpcy5yZWN0RGVzdGluYXRpb24ud2lkdGgsIHRoaXMucmVjdERlc3RpbmF0aW9uLmhlaWdodFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBEcmF3IHRoaXMgdmlld3BvcnQgZm9yIFJheUNhc3RcclxuICAgICovXHJcbiAgICBwdWJsaWMgY3JlYXRlUGlja0J1ZmZlcnMoKTogdm9pZCB7XHJcbiAgICAgIGlmICh0aGlzLmFkanVzdGluZ0ZyYW1lcylcclxuICAgICAgICB0aGlzLmFkanVzdEZyYW1lcygpO1xyXG4gICAgICBpZiAodGhpcy5hZGp1c3RpbmdDYW1lcmEpXHJcbiAgICAgICAgdGhpcy5hZGp1c3RDYW1lcmEoKTtcclxuICAgICAgdGhpcy5waWNrQnVmZmVycyA9IFJlbmRlck1hbmFnZXIuZHJhd0dyYXBoRm9yUmF5Q2FzdCh0aGlzLmdyYXBoLCB0aGlzLmNhbWVyYSk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyBwaWNrTm9kZUF0KF9wb3M6IFZlY3RvcjIpOiBSYXlIaXRbXSB7XHJcbiAgICAgIC8vIHRoaXMuY3JlYXRlUGlja0J1ZmZlcnMoKTtcclxuICAgICAgbGV0IGhpdHM6IFJheUhpdFtdID0gUmVuZGVyTWFuYWdlci5waWNrTm9kZUF0KF9wb3MsIHRoaXMucGlja0J1ZmZlcnMsIHRoaXMucmVjdFNvdXJjZSk7XHJcbiAgICAgIGhpdHMuc29ydCgoYTogUmF5SGl0LCBiOiBSYXlIaXQpID0+IChiLnpCdWZmZXIgPiAwKSA/IChhLnpCdWZmZXIgPiAwKSA/IGEuekJ1ZmZlciAtIGIuekJ1ZmZlciA6IDEgOiAtMSk7XHJcbiAgICAgIHJldHVybiBoaXRzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRqdXN0IGFsbCBmcmFtZXMgaW52b2x2ZWQgaW4gdGhlIHJlbmRlcmluZyBwcm9jZXNzIGZyb20gdGhlIGRpc3BsYXkgYXJlYSBpbiB0aGUgY2xpZW50IHVwIHRvIHRoZSByZW5kZXJlciBjYW52YXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFkanVzdEZyYW1lcygpOiB2b2lkIHtcclxuICAgICAgLy8gZ2V0IHRoZSByZWN0YW5nbGUgb2YgdGhlIGNhbnZhcyBhcmVhIGFzIGRpc3BsYXllZCAoY29uc2lkZXIgY3NzKVxyXG4gICAgICBsZXQgcmVjdENsaWVudDogUmVjdGFuZ2xlID0gdGhpcy5nZXRDbGllbnRSZWN0YW5nbGUoKTtcclxuICAgICAgLy8gYWRqdXN0IHRoZSBjYW52YXMgc2l6ZSBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIGZyYW1pbmcgYXBwbGllZCB0byBjbGllbnRcclxuICAgICAgbGV0IHJlY3RDYW52YXM6IFJlY3RhbmdsZSA9IHRoaXMuZnJhbWVDbGllbnRUb0NhbnZhcy5nZXRSZWN0KHJlY3RDbGllbnQpO1xyXG4gICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHJlY3RDYW52YXMud2lkdGg7XHJcbiAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHJlY3RDYW52YXMuaGVpZ2h0O1xyXG4gICAgICAvLyBhZGp1c3QgdGhlIGRlc3RpbmF0aW9uIGFyZWEgb24gdGhlIHRhcmdldC1jYW52YXMgdG8gcmVuZGVyIHRvIGJ5IGFwcGx5aW5nIHRoZSBmcmFtaW5nIHRvIGNhbnZhc1xyXG4gICAgICB0aGlzLnJlY3REZXN0aW5hdGlvbiA9IHRoaXMuZnJhbWVDYW52YXNUb0Rlc3RpbmF0aW9uLmdldFJlY3QocmVjdENhbnZhcyk7XHJcbiAgICAgIC8vIGFkanVzdCB0aGUgYXJlYSBvbiB0aGUgc291cmNlLWNhbnZhcyB0byByZW5kZXIgZnJvbSBieSBhcHBseWluZyB0aGUgZnJhbWluZyB0byBkZXN0aW5hdGlvbiBhcmVhXHJcbiAgICAgIHRoaXMucmVjdFNvdXJjZSA9IHRoaXMuZnJhbWVEZXN0aW5hdGlvblRvU291cmNlLmdldFJlY3QodGhpcy5yZWN0RGVzdGluYXRpb24pO1xyXG4gICAgICAvLyBoYXZpbmcgYW4gb2Zmc2V0IHNvdXJjZSBkb2VzIG1ha2Ugc2Vuc2Ugb25seSB3aGVuIG11bHRpcGxlIHZpZXdwb3J0cyBkaXNwbGF5IHBhcnRzIG9mIHRoZSBzYW1lIHJlbmRlcmluZy4gRm9yIG5vdzogc2hpZnQgaXQgdG8gMCwwXHJcbiAgICAgIHRoaXMucmVjdFNvdXJjZS54ID0gdGhpcy5yZWN0U291cmNlLnkgPSAwO1xyXG4gICAgICAvLyBzdGlsbCwgYSBwYXJ0aWFsIGltYWdlIG9mIHRoZSByZW5kZXJpbmcgbWF5IGJlIHJldHJpZXZlZCBieSBtb3ZpbmcgYW5kIHJlc2l6aW5nIHRoZSByZW5kZXIgdmlld3BvcnRcclxuICAgICAgbGV0IHJlY3RSZW5kZXI6IFJlY3RhbmdsZSA9IHRoaXMuZnJhbWVTb3VyY2VUb1JlbmRlci5nZXRSZWN0KHRoaXMucmVjdFNvdXJjZSk7XHJcbiAgICAgIFJlbmRlck1hbmFnZXIuc2V0Vmlld3BvcnRSZWN0YW5nbGUocmVjdFJlbmRlcik7XHJcbiAgICAgIC8vIG5vIG1vcmUgdHJhbnNmb3JtYXRpb24gYWZ0ZXIgdGhpcyBmb3Igbm93LCBvZmZzY3JlZW4gY2FudmFzIGFuZCByZW5kZXItdmlld3BvcnQgaGF2ZSB0aGUgc2FtZSBzaXplXHJcbiAgICAgIFJlbmRlck1hbmFnZXIuc2V0Q2FudmFzU2l6ZShyZWN0UmVuZGVyLndpZHRoLCByZWN0UmVuZGVyLmhlaWdodCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkanVzdCB0aGUgY2FtZXJhIHBhcmFtZXRlcnMgdG8gZml0IHRoZSByZW5kZXJpbmcgaW50byB0aGUgcmVuZGVyIHZpZXBvcnRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFkanVzdENhbWVyYSgpOiB2b2lkIHtcclxuICAgICAgbGV0IHJlY3Q6IFJlY3RhbmdsZSA9IFJlbmRlck1hbmFnZXIuZ2V0Vmlld3BvcnRSZWN0YW5nbGUoKTtcclxuICAgICAgdGhpcy5jYW1lcmEucHJvamVjdENlbnRyYWwocmVjdC53aWR0aCAvIHJlY3QuaGVpZ2h0LCB0aGlzLmNhbWVyYS5nZXRGaWVsZE9mVmlldygpKTtcclxuICAgIH1cclxuICAgIC8vICNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gUG9pbnRzXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBwb2ludCBvbiB0aGUgc291cmNlLXJlY3RhbmdsZSBtYXRjaGluZyB0aGUgZ2l2ZW4gcG9pbnQgb24gdGhlIGNsaWVudCByZWN0YW5nbGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHBvaW50Q2xpZW50VG9Tb3VyY2UoX2NsaWVudDogVmVjdG9yMik6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IyID0gdGhpcy5mcmFtZUNsaWVudFRvQ2FudmFzLmdldFBvaW50KF9jbGllbnQsIHRoaXMuZ2V0Q2xpZW50UmVjdGFuZ2xlKCkpO1xyXG4gICAgICByZXN1bHQgPSB0aGlzLmZyYW1lQ2FudmFzVG9EZXN0aW5hdGlvbi5nZXRQb2ludChyZXN1bHQsIHRoaXMuZ2V0Q2FudmFzUmVjdGFuZ2xlKCkpO1xyXG4gICAgICByZXN1bHQgPSB0aGlzLmZyYW1lRGVzdGluYXRpb25Ub1NvdXJjZS5nZXRQb2ludChyZXN1bHQsIHRoaXMucmVjdFNvdXJjZSk7XHJcbiAgICAgIC8vVE9ETzogd2hlbiBTb3VyY2UsIFJlbmRlciBhbmQgUmVuZGVyVmlld3BvcnQgZGV2aWF0ZSwgY29udGludWUgdHJhbnNmb3JtYXRpb24gXHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBwb2ludCBvbiB0aGUgcmVuZGVyLXJlY3RhbmdsZSBtYXRjaGluZyB0aGUgZ2l2ZW4gcG9pbnQgb24gdGhlIHNvdXJjZSByZWN0YW5nbGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHBvaW50U291cmNlVG9SZW5kZXIoX3NvdXJjZTogVmVjdG9yMik6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcHJvamVjdGlvblJlY3RhbmdsZTogUmVjdGFuZ2xlID0gdGhpcy5jYW1lcmEuZ2V0UHJvamVjdGlvblJlY3RhbmdsZSgpO1xyXG4gICAgICBsZXQgcG9pbnQ6IFZlY3RvcjIgPSB0aGlzLmZyYW1lU291cmNlVG9SZW5kZXIuZ2V0UG9pbnQoX3NvdXJjZSwgcHJvamVjdGlvblJlY3RhbmdsZSk7XHJcbiAgICAgIHJldHVybiBwb2ludDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBwb2ludCBvbiB0aGUgcmVuZGVyLXJlY3RhbmdsZSBtYXRjaGluZyB0aGUgZ2l2ZW4gcG9pbnQgb24gdGhlIGNsaWVudCByZWN0YW5nbGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHBvaW50Q2xpZW50VG9SZW5kZXIoX2NsaWVudDogVmVjdG9yMik6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcG9pbnQ6IFZlY3RvcjIgPSB0aGlzLnBvaW50Q2xpZW50VG9Tb3VyY2UoX2NsaWVudCk7XHJcbiAgICAgIHBvaW50ID0gdGhpcy5wb2ludFNvdXJjZVRvUmVuZGVyKHBvaW50KTtcclxuICAgICAgLy9UT0RPOiB3aGVuIFJlbmRlciBhbmQgUmVuZGVyVmlld3BvcnQgZGV2aWF0ZSwgY29udGludWUgdHJhbnNmb3JtYXRpb24gXHJcbiAgICAgIHJldHVybiBwb2ludDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBwb2ludCBpbiBub3JtZWQgdmlldy1yZWN0YW5nbGUgbWF0Y2hpbmcgdGhlIGdpdmVuIHBvaW50IG9uIHRoZSBjbGllbnQgcmVjdGFuZ2xlXHJcbiAgICAgKiBUaGUgdmlldy1yZWN0YW5nbGUgbWF0Y2hlcyB0aGUgY2xpZW50IHNpemUgaW4gdGhlIGh5cG90aGV0aWNhbCBkaXN0YW5jZSBvZiAxIHRvIHRoZSBjYW1lcmEsIGl0cyBvcmlnaW4gaW4gdGhlIGNlbnRlciBhbmQgeS1heGlzIHBvaW50aW5nIHVwXHJcbiAgICAgKiBUT0RPOiBleGFtaW5lLCBpZiB0aGlzIHNob3VsZCBiZSBhIGNhbWVyYS1tZXRob2QuIEN1cnJlbnQgaW1wbGVtZW50YXRpb24gaXMgZm9yIGNlbnRyYWwtcHJvamVjdGlvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcG9pbnRDbGllbnRUb1Byb2plY3Rpb24oX2NsaWVudDogVmVjdG9yMik6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcG9zUmVuZGVyOiBWZWN0b3IyID0gdGhpcy5wb2ludENsaWVudFRvUmVuZGVyKF9jbGllbnQpO1xyXG4gICAgICBsZXQgcmVjdFJlbmRlcjogUmVjdGFuZ2xlID0gdGhpcy5mcmFtZVNvdXJjZVRvUmVuZGVyLmdldFJlY3QodGhpcy5yZWN0U291cmNlKTtcclxuICAgICAgbGV0IHJlY3RQcm9qZWN0aW9uOiBSZWN0YW5nbGUgPSB0aGlzLmNhbWVyYS5nZXRQcm9qZWN0aW9uUmVjdGFuZ2xlKCk7XHJcblxyXG4gICAgICBsZXQgcG9zUHJvamVjdGlvbjogVmVjdG9yMiA9IG5ldyBWZWN0b3IyKFxyXG4gICAgICAgIHJlY3RQcm9qZWN0aW9uLndpZHRoICogcG9zUmVuZGVyLnggLyByZWN0UmVuZGVyLndpZHRoLFxyXG4gICAgICAgIHJlY3RQcm9qZWN0aW9uLmhlaWdodCAqIHBvc1JlbmRlci55IC8gcmVjdFJlbmRlci5oZWlnaHRcclxuICAgICAgKTtcclxuXHJcbiAgICAgIHBvc1Byb2plY3Rpb24uc3VidHJhY3QobmV3IFZlY3RvcjIocmVjdFByb2plY3Rpb24ud2lkdGggLyAyLCByZWN0UHJvamVjdGlvbi5oZWlnaHQgLyAyKSk7XHJcbiAgICAgIHBvc1Byb2plY3Rpb24ueSAqPSAtMTtcclxuXHJcbiAgICAgIHJldHVybiBwb3NQcm9qZWN0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHBvaW50IGluIHRoZSBjbGllbnQgcmVjdGFuZ2xlIG1hdGNoaW5nIHRoZSBnaXZlbiBwb2ludCBpbiBub3JtZWQgY2xpcHNwYWNlIHJlY3RhbmdsZSwgXHJcbiAgICAgKiB3aGljaCBzdHJldGNoZXMgZnJvbSAtMSB0byAxIGluIGJvdGggZGltZW5zaW9ucywgeSBwb2ludGluZyB1cFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcG9pbnRDbGlwVG9DbGllbnQoX25vcm1lZDogVmVjdG9yMik6IFZlY3RvcjIge1xyXG4gICAgICAvLyBsZXQgcmVjdENsaWVudDogUmVjdGFuZ2xlID0gdGhpcy5nZXRDbGllbnRSZWN0YW5nbGUoKTtcclxuICAgICAgLy8gbGV0IHJlc3VsdDogVmVjdG9yMiA9IFZlY3RvcjIuT05FKDAuNSk7XHJcbiAgICAgIC8vIHJlc3VsdC54ICo9IChfbm9ybWVkLnggKyAxKSAqIHJlY3RDbGllbnQud2lkdGg7XHJcbiAgICAgIC8vIHJlc3VsdC55ICo9ICgxIC0gX25vcm1lZC55KSAqIHJlY3RDbGllbnQuaGVpZ2h0O1xyXG4gICAgICAvLyByZXN1bHQuYWRkKHJlY3RDbGllbnQucG9zaXRpb24pO1xyXG4gICAgICAvL1RPRE86IGNoZWNrIGlmIHJlY3REZXN0aW5hdGlvbiBjYW4gYmUgc2FmZWx5IChhbmQgbW9yZSBwZXJmb21hbnQpIGJlIHVzZWQgaW5zdGVhZCBnZXRDbGllbnRSZWN0YW5nbGVcclxuICAgICAgbGV0IHBvaW50Q2xpZW50OiBWZWN0b3IyID0gUmVuZGVyTWFuYWdlci5yZWN0Q2xpcC5wb2ludFRvUmVjdChfbm9ybWVkLCB0aGlzLnJlY3REZXN0aW5hdGlvbik7XHJcbiAgICAgIHJldHVybiBwb2ludENsaWVudDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHBvaW50IGluIHRoZSBjbGllbnQgcmVjdGFuZ2xlIG1hdGNoaW5nIHRoZSBnaXZlbiBwb2ludCBpbiBub3JtZWQgY2xpcHNwYWNlIHJlY3RhbmdsZSwgXHJcbiAgICAgKiB3aGljaCBzdHJldGNoZXMgZnJvbSAtMSB0byAxIGluIGJvdGggZGltZW5zaW9ucywgeSBwb2ludGluZyB1cFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcG9pbnRDbGlwVG9DYW52YXMoX25vcm1lZDogVmVjdG9yMik6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcG9pbnRDYW52YXM6IFZlY3RvcjIgPSBSZW5kZXJNYW5hZ2VyLnJlY3RDbGlwLnBvaW50VG9SZWN0KF9ub3JtZWQsIHRoaXMuZ2V0Q2FudmFzUmVjdGFuZ2xlKCkpO1xyXG4gICAgICByZXR1cm4gcG9pbnRDYW52YXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHBvaW50Q2xpZW50VG9TY3JlZW4oX2NsaWVudDogVmVjdG9yMik6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgc2NyZWVuOiBWZWN0b3IyID0gbmV3IFZlY3RvcjIodGhpcy5jYW52YXMub2Zmc2V0TGVmdCArIF9jbGllbnQueCwgdGhpcy5jYW52YXMub2Zmc2V0VG9wICsgX2NsaWVudC55KTtcclxuICAgICAgcmV0dXJuIHNjcmVlbjtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vICNyZWdpb24gRXZlbnRzIChwYXNzaW5nIGZyb20gY2FudmFzIHRvIHZpZXdwb3J0IGFuZCBmcm9tIHRoZXJlIGludG8gZ3JhcGgpXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHZpZXdwb3J0IGN1cnJlbnRseSBoYXMgZm9jdXMgYW5kIHRodXMgcmVjZWl2ZXMga2V5Ym9hcmQgZXZlbnRzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgaGFzRm9jdXMoKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiAoVmlld3BvcnQuZm9jdXMgPT0gdGhpcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN3aXRjaCB0aGUgdmlld3BvcnRzIGZvY3VzIG9uIG9yIG9mZi4gT25seSBvbmUgdmlld3BvcnQgaW4gb25lIEZVREdFIGluc3RhbmNlIGNhbiBoYXZlIHRoZSBmb2N1cywgdGh1cyByZWNlaXZpbmcga2V5Ym9hcmQgZXZlbnRzLiBcclxuICAgICAqIFNvIGEgdmlld3BvcnQgY3VycmVudGx5IGhhdmluZyB0aGUgZm9jdXMgd2lsbCBsb3NlIGl0LCB3aGVuIGFub3RoZXIgb25lIHJlY2VpdmVzIGl0LiBUaGUgdmlld3BvcnRzIGZpcmUgW1tFdmVudF1dcyBhY2NvcmRpbmdseS5cclxuICAgICAqICBcclxuICAgICAqIEBwYXJhbSBfb24gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRGb2N1cyhfb246IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgaWYgKF9vbikge1xyXG4gICAgICAgIGlmIChWaWV3cG9ydC5mb2N1cyA9PSB0aGlzKVxyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGlmIChWaWV3cG9ydC5mb2N1cylcclxuICAgICAgICAgIFZpZXdwb3J0LmZvY3VzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULkZPQ1VTX09VVCkpO1xyXG4gICAgICAgIFZpZXdwb3J0LmZvY3VzID0gdGhpcztcclxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULkZPQ1VTX0lOKSk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKFZpZXdwb3J0LmZvY3VzICE9IHRoaXMpXHJcbiAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuRk9DVVNfT1VUKSk7XHJcbiAgICAgICAgVmlld3BvcnQuZm9jdXMgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlLSAvIEFjdGl2YXRlcyB0aGUgZ2l2ZW4gcG9pbnRlciBldmVudCB0byBiZSBwcm9wYWdhdGVkIGludG8gdGhlIHZpZXdwb3J0IGFzIEZVREdFLUV2ZW50IFxyXG4gICAgICogQHBhcmFtIF90eXBlIFxyXG4gICAgICogQHBhcmFtIF9vbiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFjdGl2YXRlUG9pbnRlckV2ZW50KF90eXBlOiBFVkVOVF9QT0lOVEVSLCBfb246IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgdGhpcy5hY3RpdmF0ZUV2ZW50KHRoaXMuY2FudmFzLCBfdHlwZSwgdGhpcy5obmRQb2ludGVyRXZlbnQsIF9vbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlLSAvIEFjdGl2YXRlcyB0aGUgZ2l2ZW4ga2V5Ym9hcmQgZXZlbnQgdG8gYmUgcHJvcGFnYXRlZCBpbnRvIHRoZSB2aWV3cG9ydCBhcyBGVURHRS1FdmVudFxyXG4gICAgICogQHBhcmFtIF90eXBlIFxyXG4gICAgICogQHBhcmFtIF9vbiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFjdGl2YXRlS2V5Ym9hcmRFdmVudChfdHlwZTogRVZFTlRfS0VZQk9BUkQsIF9vbjogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICB0aGlzLmFjdGl2YXRlRXZlbnQodGhpcy5jYW52YXMub3duZXJEb2N1bWVudCwgX3R5cGUsIHRoaXMuaG5kS2V5Ym9hcmRFdmVudCwgX29uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGUtIC8gQWN0aXZhdGVzIHRoZSBnaXZlbiBkcmFnLWRyb3AgZXZlbnQgdG8gYmUgcHJvcGFnYXRlZCBpbnRvIHRoZSB2aWV3cG9ydCBhcyBGVURHRS1FdmVudFxyXG4gICAgICogQHBhcmFtIF90eXBlIFxyXG4gICAgICogQHBhcmFtIF9vbiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFjdGl2YXRlRHJhZ0Ryb3BFdmVudChfdHlwZTogRVZFTlRfRFJBR0RST1AsIF9vbjogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICBpZiAoX3R5cGUgPT0gRVZFTlRfRFJBR0RST1AuU1RBUlQpXHJcbiAgICAgICAgdGhpcy5jYW52YXMuZHJhZ2dhYmxlID0gX29uO1xyXG4gICAgICB0aGlzLmFjdGl2YXRlRXZlbnQodGhpcy5jYW52YXMsIF90eXBlLCB0aGlzLmhuZERyYWdEcm9wRXZlbnQsIF9vbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlLSAvIEFjdGl2YXRlcyB0aGUgd2hlZWwgZXZlbnQgdG8gYmUgcHJvcGFnYXRlZCBpbnRvIHRoZSB2aWV3cG9ydCBhcyBGVURHRS1FdmVudFxyXG4gICAgICogQHBhcmFtIF90eXBlIFxyXG4gICAgICogQHBhcmFtIF9vbiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFjdGl2YXRlV2hlZWxFdmVudChfdHlwZTogRVZFTlRfV0hFRUwsIF9vbjogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICB0aGlzLmFjdGl2YXRlRXZlbnQodGhpcy5jYW52YXMsIF90eXBlLCB0aGlzLmhuZFdoZWVsRXZlbnQsIF9vbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZSBkcmFnLWRyb3AgZXZlbnRzIGFuZCBkaXNwYXRjaCB0byB2aWV3cG9ydCBhcyBGVURHRS1FdmVudFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGhuZERyYWdEcm9wRXZlbnQ6IEV2ZW50TGlzdGVuZXIgPSAoX2V2ZW50OiBFdmVudCkgPT4ge1xyXG4gICAgICBsZXQgX2RyYWdldmVudDogRXZlbnREcmFnRHJvcCA9IDxFdmVudERyYWdEcm9wPl9ldmVudDtcclxuICAgICAgc3dpdGNoIChfZHJhZ2V2ZW50LnR5cGUpIHtcclxuICAgICAgICBjYXNlIFwiZHJhZ292ZXJcIjpcclxuICAgICAgICBjYXNlIFwiZHJvcFwiOlxyXG4gICAgICAgICAgX2RyYWdldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgX2RyYWdldmVudC5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9IFwibm9uZVwiO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcImRyYWdzdGFydFwiOlxyXG4gICAgICAgICAgLy8ganVzdCBkdW1teSBkYXRhLCAgdmFsaWQgZGF0YSBzaG91bGQgYmUgc2V0IGluIGhhbmRsZXIgcmVnaXN0ZXJlZCBieSB0aGUgdXNlclxyXG4gICAgICAgICAgX2RyYWdldmVudC5kYXRhVHJhbnNmZXIuc2V0RGF0YShcInRleHRcIiwgXCJIYWxsb1wiKTtcclxuICAgICAgICAgIC8vIFRPRE86IGNoZWNrIGlmIHRoZXJlIGlzIGEgYmV0dGVyIHNvbHV0aW9uIHRvIGhpZGUgdGhlIGdob3N0IGltYWdlIG9mIHRoZSBkcmFnZ2FibGUgb2JqZWN0XHJcbiAgICAgICAgICBfZHJhZ2V2ZW50LmRhdGFUcmFuc2Zlci5zZXREcmFnSW1hZ2UobmV3IEltYWdlKCksIDAsIDApO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgbGV0IGV2ZW50OiBFdmVudERyYWdEcm9wID0gbmV3IEV2ZW50RHJhZ0Ryb3AoXCLGklwiICsgX2V2ZW50LnR5cGUsIF9kcmFnZXZlbnQpO1xyXG4gICAgICB0aGlzLmFkZENhbnZhc1Bvc2l0aW9uKGV2ZW50KTtcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIG1hcHBlZCB0byBjYW52YXMtY29vcmRpbmF0ZXMgYXMgY2FudmFzWCwgY2FudmFzWSB0byB0aGUgZXZlbnRcclxuICAgICAqIEBwYXJhbSBldmVudFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGFkZENhbnZhc1Bvc2l0aW9uKGV2ZW50OiBFdmVudFBvaW50ZXIgfCBFdmVudERyYWdEcm9wKTogdm9pZCB7XHJcbiAgICAgIGV2ZW50LmNhbnZhc1ggPSB0aGlzLmNhbnZhcy53aWR0aCAqIGV2ZW50LnBvaW50ZXJYIC8gZXZlbnQuY2xpZW50UmVjdC53aWR0aDtcclxuICAgICAgZXZlbnQuY2FudmFzWSA9IHRoaXMuY2FudmFzLmhlaWdodCAqIGV2ZW50LnBvaW50ZXJZIC8gZXZlbnQuY2xpZW50UmVjdC5oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZSBwb2ludGVyIGV2ZW50cyBhbmQgZGlzcGF0Y2ggdG8gdmlld3BvcnQgYXMgRlVER0UtRXZlbnRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBobmRQb2ludGVyRXZlbnQ6IEV2ZW50TGlzdGVuZXIgPSAoX2V2ZW50OiBFdmVudCkgPT4ge1xyXG4gICAgICBsZXQgZXZlbnQ6IEV2ZW50UG9pbnRlciA9IG5ldyBFdmVudFBvaW50ZXIoXCLGklwiICsgX2V2ZW50LnR5cGUsIDxFdmVudFBvaW50ZXI+X2V2ZW50KTtcclxuICAgICAgdGhpcy5hZGRDYW52YXNQb3NpdGlvbihldmVudCk7XHJcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZSBrZXlib2FyZCBldmVudHMgYW5kIGRpc3BhdGNoIHRvIHZpZXdwb3J0IGFzIEZVREdFLUV2ZW50LCBpZiB0aGUgdmlld3BvcnQgaGFzIHRoZSBmb2N1c1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGhuZEtleWJvYXJkRXZlbnQ6IEV2ZW50TGlzdGVuZXIgPSAoX2V2ZW50OiBFdmVudCkgPT4ge1xyXG4gICAgICBpZiAoIXRoaXMuaGFzRm9jdXMpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBsZXQgZXZlbnQ6IEV2ZW50S2V5Ym9hcmQgPSBuZXcgRXZlbnRLZXlib2FyZChcIsaSXCIgKyBfZXZlbnQudHlwZSwgPEV2ZW50S2V5Ym9hcmQ+X2V2ZW50KTtcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlIHdoZWVsIGV2ZW50IGFuZCBkaXNwYXRjaCB0byB2aWV3cG9ydCBhcyBGVURHRS1FdmVudFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGhuZFdoZWVsRXZlbnQ6IEV2ZW50TGlzdGVuZXIgPSAoX2V2ZW50OiBFdmVudCkgPT4ge1xyXG4gICAgICBsZXQgZXZlbnQ6IEV2ZW50V2hlZWwgPSBuZXcgRXZlbnRXaGVlbChcIsaSXCIgKyBfZXZlbnQudHlwZSwgPEV2ZW50V2hlZWw+X2V2ZW50KTtcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFjdGl2YXRlRXZlbnQoX3RhcmdldDogRXZlbnRUYXJnZXQsIF90eXBlOiBzdHJpbmcsIF9oYW5kbGVyOiBFdmVudExpc3RlbmVyLCBfb246IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgX3R5cGUgPSBfdHlwZS5zbGljZSgxKTsgLy8gY2hpcCB0aGUgxpJsb3JlbnRpblxyXG4gICAgICBpZiAoX29uKVxyXG4gICAgICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihfdHlwZSwgX2hhbmRsZXIpO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKF90eXBlLCBfaGFuZGxlcik7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBobmRDb21wb25lbnRFdmVudChfZXZlbnQ6IEV2ZW50KTogdm9pZCB7XHJcbiAgICAgIERlYnVnLmZ1ZGdlKF9ldmVudCk7XHJcbiAgICB9XHJcbiAgICAvLyAjZW5kcmVnaW9uXHJcblxyXG4gIFxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIG91dHB1dHN0cmluZyBhcyB2aXN1YWwgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2aWV3cG9ydHMgc2NlbmVncmFwaC4gQ2FsbGVkIGZvciB0aGUgcGFzc2VkIG5vZGUgYW5kIHJlY3Vyc2l2ZSBmb3IgYWxsIGl0cyBjaGlsZHJlbi5cclxuICAgICAqIEBwYXJhbSBfZnVkZ2VOb2RlIFRoZSBub2RlIHRvIGNyZWF0ZSBhIHNjZW5lZ3JhcGhlbnRyeSBmb3IuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY3JlYXRlU2NlbmVHcmFwaChfZnVkZ2VOb2RlOiBOb2RlKTogc3RyaW5nIHtcclxuICAgICAgLy8gVE9ETzogbW92ZSB0byBkZWJ1Zy1jbGFzc1xyXG4gICAgICBsZXQgb3V0cHV0OiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgICBmb3IgKGxldCBuYW1lIGluIF9mdWRnZU5vZGUuZ2V0Q2hpbGRyZW4oKSkge1xyXG4gICAgICAgIGxldCBjaGlsZDogTm9kZSA9IF9mdWRnZU5vZGUuZ2V0Q2hpbGRyZW4oKVtuYW1lXTtcclxuICAgICAgICBvdXRwdXQgKz0gXCJcXG5cIjtcclxuICAgICAgICBsZXQgY3VycmVudDogTm9kZSA9IGNoaWxkO1xyXG4gICAgICAgIGlmIChjdXJyZW50LmdldFBhcmVudCgpICYmIGN1cnJlbnQuZ2V0UGFyZW50KCkuZ2V0UGFyZW50KCkpXHJcbiAgICAgICAgICBvdXRwdXQgKz0gXCJ8XCI7XHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQuZ2V0UGFyZW50KCkgJiYgY3VycmVudC5nZXRQYXJlbnQoKS5nZXRQYXJlbnQoKSkge1xyXG4gICAgICAgICAgb3V0cHV0ICs9IFwiICAgXCI7XHJcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5nZXRQYXJlbnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgb3V0cHV0ICs9IFwiJy0tXCI7XHJcblxyXG4gICAgICAgIG91dHB1dCArPSBjaGlsZC5uYW1lO1xyXG4gICAgICAgIG91dHB1dCArPSB0aGlzLmNyZWF0ZVNjZW5lR3JhcGgoY2hpbGQpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gICAgZXhwb3J0IGNvbnN0IGVudW0gRVZFTlRfQVVESU8ge1xyXG4gICAgICAvKiogYnJvYWRjYXN0IHRvIGEgW1tOb2RlXV0gYW5kIGFsbCBpdHMgZGVzY2VuZGFudHMgaW4gdGhlIGdyYXBoIGFmdGVyIGl0IHdhcyBhcHBlbmRlZCB0byBhIHBhcmVudCAqL1xyXG4gICAgICBDSElMRF9BUFBFTkQgPSBcImNoaWxkQXBwZW5kVG9BdWRpb0dyYXBoXCIsXHJcbiAgICAgIC8qKiBicm9hZGNhc3QgdG8gYSBbW05vZGVdXSBhbmQgYWxsIGl0cyBkZXNjZW5kYW50cyBpbiB0aGUgZ3JhcGgganVzdCBiZWZvcmUgaXRzIGJlaW5nIHJlbW92ZWQgZnJvbSBpdHMgcGFyZW50ICovXHJcbiAgICAgIENISUxEX1JFTU9WRSA9IFwiY2hpbGRSZW1vdmVGcm9tQXVkaW9HcmFwaFwiLFxyXG4gICAgICAvKiogYnJvYWRjYXN0IHRvIGEgW1tOb2RlXV0gYW5kIGFsbCBpdHMgZGVzY2VuZGFudHMgaW4gdGhlIGdyYXBoIHRvIHVwZGF0ZSB0aGUgcGFubmVycyBpbiBBdWRpb0NvbXBvbmVudHMgKi9cclxuICAgICAgVVBEQVRFID0gXCJ1cGRhdGVBdWRpb0dyYXBoXCJcclxuICAgIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gICAgZXhwb3J0IGNvbnN0IGVudW0gRVZFTlRfRFJBR0RST1Age1xyXG4gICAgICAgIERSQUcgPSBcIsaSZHJhZ1wiLFxyXG4gICAgICAgIERST1AgPSBcIsaSZHJvcFwiLFxyXG4gICAgICAgIFNUQVJUID0gXCLGkmRyYWdzdGFydFwiLFxyXG4gICAgICAgIEVORCA9IFwixpJkcmFnZW5kXCIsXHJcbiAgICAgICAgT1ZFUiA9IFwixpJkcmFnb3ZlclwiXHJcbiAgICB9XHJcblxyXG4gICAgZXhwb3J0IGNsYXNzIEV2ZW50RHJhZ0Ryb3AgZXh0ZW5kcyBEcmFnRXZlbnQge1xyXG4gICAgICAgIHB1YmxpYyBwb2ludGVyWDogbnVtYmVyO1xyXG4gICAgICAgIHB1YmxpYyBwb2ludGVyWTogbnVtYmVyO1xyXG4gICAgICAgIHB1YmxpYyBjYW52YXNYOiBudW1iZXI7XHJcbiAgICAgICAgcHVibGljIGNhbnZhc1k6IG51bWJlcjtcclxuICAgICAgICBwdWJsaWMgY2xpZW50UmVjdDogQ2xpZW50UmVjdDtcclxuXHJcbiAgICAgICAgY29uc3RydWN0b3IodHlwZTogc3RyaW5nLCBfZXZlbnQ6IEV2ZW50RHJhZ0Ryb3ApIHtcclxuICAgICAgICAgICAgc3VwZXIodHlwZSwgX2V2ZW50KTtcclxuICAgICAgICAgICAgbGV0IHRhcmdldDogSFRNTEVsZW1lbnQgPSA8SFRNTEVsZW1lbnQ+X2V2ZW50LnRhcmdldDtcclxuICAgICAgICAgICAgdGhpcy5jbGllbnRSZWN0ID0gdGFyZ2V0LmdldENsaWVudFJlY3RzKClbMF07XHJcbiAgICAgICAgICAgIHRoaXMucG9pbnRlclggPSBfZXZlbnQuY2xpZW50WCAtIHRoaXMuY2xpZW50UmVjdC5sZWZ0O1xyXG4gICAgICAgICAgICB0aGlzLnBvaW50ZXJZID0gX2V2ZW50LmNsaWVudFkgLSB0aGlzLmNsaWVudFJlY3QudG9wO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gICAgZXhwb3J0IGNsYXNzIEV2ZW50S2V5Ym9hcmQgZXh0ZW5kcyBLZXlib2FyZEV2ZW50IHtcclxuICAgICAgICBjb25zdHJ1Y3Rvcih0eXBlOiBzdHJpbmcsIF9ldmVudDogRXZlbnRLZXlib2FyZCkge1xyXG4gICAgICAgICAgICBzdXBlcih0eXBlLCBfZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcHBpbmdzIG9mIHN0YW5kYXJkIERPTS9Ccm93c2VyLUV2ZW50cyBhcyBwYXNzZWQgZnJvbSBhIGNhbnZhcyB0byB0aGUgdmlld3BvcnRcclxuICAgICAqL1xyXG4gICAgZXhwb3J0IGNvbnN0IGVudW0gRVZFTlRfS0VZQk9BUkQge1xyXG4gICAgICAgIFVQID0gXCLGkmtleXVwXCIsXHJcbiAgICAgICAgRE9XTiA9IFwixpJrZXlkb3duXCJcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjb2RlcyBzZW50IGZyb20gYSBzdGFuZGFyZCBlbmdsaXNoIGtleWJvYXJkIGxheW91dFxyXG4gICAgICovXHJcbiAgICBleHBvcnQgZW51bSBLRVlCT0FSRF9DT0RFIHtcclxuICAgICAgICBBID0gXCJLZXlBXCIsXHJcbiAgICAgICAgQiA9IFwiS2V5QlwiLFxyXG4gICAgICAgIEMgPSBcIktleUNcIixcclxuICAgICAgICBEID0gXCJLZXlEXCIsXHJcbiAgICAgICAgRSA9IFwiS2V5RVwiLFxyXG4gICAgICAgIEYgPSBcIktleUZcIixcclxuICAgICAgICBHID0gXCJLZXlHXCIsXHJcbiAgICAgICAgSCA9IFwiS2V5SFwiLFxyXG4gICAgICAgIEkgPSBcIktleUlcIixcclxuICAgICAgICBKID0gXCJLZXlKXCIsXHJcbiAgICAgICAgSyA9IFwiS2V5S1wiLFxyXG4gICAgICAgIEwgPSBcIktleUxcIixcclxuICAgICAgICBNID0gXCJLZXlNXCIsXHJcbiAgICAgICAgTiA9IFwiS2V5TlwiLFxyXG4gICAgICAgIE8gPSBcIktleU9cIixcclxuICAgICAgICBQID0gXCJLZXlQXCIsXHJcbiAgICAgICAgUSA9IFwiS2V5UVwiLFxyXG4gICAgICAgIFIgPSBcIktleVJcIixcclxuICAgICAgICBTID0gXCJLZXlTXCIsXHJcbiAgICAgICAgVCA9IFwiS2V5VFwiLFxyXG4gICAgICAgIFUgPSBcIktleVVcIixcclxuICAgICAgICBWID0gXCJLZXlWXCIsXHJcbiAgICAgICAgVyA9IFwiS2V5V1wiLFxyXG4gICAgICAgIFggPSBcIktleVhcIixcclxuICAgICAgICBZID0gXCJLZXlZXCIsXHJcbiAgICAgICAgWiA9IFwiS2V5WlwiLFxyXG4gICAgICAgIEVTQyA9IFwiRXNjYXBlXCIsXHJcbiAgICAgICAgWkVSTyA9IFwiRGlnaXQwXCIsXHJcbiAgICAgICAgT05FID0gXCJEaWdpdDFcIixcclxuICAgICAgICBUV08gPSBcIkRpZ2l0MlwiLFxyXG4gICAgICAgIFRIUkVFID0gXCJEaWdpdDNcIixcclxuICAgICAgICBGT1VSID0gXCJEaWdpdDRcIixcclxuICAgICAgICBGSVZFID0gXCJEaWdpdDVcIixcclxuICAgICAgICBTSVggPSBcIkRpZ2l0NlwiLFxyXG4gICAgICAgIFNFVkVOID0gXCJEaWdpdDdcIixcclxuICAgICAgICBFSUdIVCA9IFwiRGlnaXQ4XCIsXHJcbiAgICAgICAgTklORSA9IFwiRGlnaXQ5XCIsXHJcbiAgICAgICAgTUlOVVMgPSBcIk1pbnVzXCIsXHJcbiAgICAgICAgRVFVQUwgPSBcIkVxdWFsXCIsXHJcbiAgICAgICAgQkFDS1NQQUNFID0gXCJCYWNrc3BhY2VcIixcclxuICAgICAgICBUQUJVTEFUT1IgPSBcIlRhYlwiLFxyXG4gICAgICAgIEJSQUNLRVRfTEVGVCA9IFwiQnJhY2tldExlZnRcIixcclxuICAgICAgICBCUkFDS0VUX1JJR0hUID0gXCJCcmFja2V0UmlnaHRcIixcclxuICAgICAgICBFTlRFUiA9IFwiRW50ZXJcIixcclxuICAgICAgICBDVFJMX0xFRlQgPSBcIkNvbnRyb2xMZWZ0XCIsXHJcbiAgICAgICAgU0VNSUNPTE9OID0gXCJTZW1pY29sb25cIixcclxuICAgICAgICBRVU9URSA9IFwiUXVvdGVcIixcclxuICAgICAgICBCQUNLX1FVT1RFID0gXCJCYWNrcXVvdGVcIixcclxuICAgICAgICBTSElGVF9MRUZUID0gXCJTaGlmdExlZnRcIixcclxuICAgICAgICBCQUNLU0xBU0ggPSBcIkJhY2tzbGFzaFwiLFxyXG4gICAgICAgIENPTU1BID0gXCJDb21tYVwiLFxyXG4gICAgICAgIFBFUklPRCA9IFwiUGVyaW9kXCIsXHJcbiAgICAgICAgU0xBU0ggPSBcIlNsYXNoXCIsXHJcbiAgICAgICAgU0hJRlRfUklHSFQgPSBcIlNoaWZ0UmlnaHRcIixcclxuICAgICAgICBOVU1QQURfTVVMVElQTFkgPSBcIk51bXBhZE11bHRpcGx5XCIsXHJcbiAgICAgICAgQUxUX0xFRlQgPSBcIkFsdExlZnRcIixcclxuICAgICAgICBTUEFDRSA9IFwiU3BhY2VcIixcclxuICAgICAgICBDQVBTX0xPQ0sgPSBcIkNhcHNMb2NrXCIsXHJcbiAgICAgICAgRjEgPSBcIkYxXCIsXHJcbiAgICAgICAgRjIgPSBcIkYyXCIsXHJcbiAgICAgICAgRjMgPSBcIkYzXCIsXHJcbiAgICAgICAgRjQgPSBcIkY0XCIsXHJcbiAgICAgICAgRjUgPSBcIkY1XCIsXHJcbiAgICAgICAgRjYgPSBcIkY2XCIsXHJcbiAgICAgICAgRjcgPSBcIkY3XCIsXHJcbiAgICAgICAgRjggPSBcIkY4XCIsXHJcbiAgICAgICAgRjkgPSBcIkY5XCIsXHJcbiAgICAgICAgRjEwID0gXCJGMTBcIixcclxuICAgICAgICBQQVVTRSA9IFwiUGF1c2VcIixcclxuICAgICAgICBTQ1JPTExfTE9DSyA9IFwiU2Nyb2xsTG9ja1wiLFxyXG4gICAgICAgIE5VTVBBRDcgPSBcIk51bXBhZDdcIixcclxuICAgICAgICBOVU1QQUQ4ID0gXCJOdW1wYWQ4XCIsXHJcbiAgICAgICAgTlVNUEFEOSA9IFwiTnVtcGFkOVwiLFxyXG4gICAgICAgIE5VTVBBRF9TVUJUUkFDVCA9IFwiTnVtcGFkU3VidHJhY3RcIixcclxuICAgICAgICBOVU1QQUQ0ID0gXCJOdW1wYWQ0XCIsXHJcbiAgICAgICAgTlVNUEFENSA9IFwiTnVtcGFkNVwiLFxyXG4gICAgICAgIE5VTVBBRDYgPSBcIk51bXBhZDZcIixcclxuICAgICAgICBOVU1QQURfQUREID0gXCJOdW1wYWRBZGRcIixcclxuICAgICAgICBOVU1QQUQxID0gXCJOdW1wYWQxXCIsXHJcbiAgICAgICAgTlVNUEFEMiA9IFwiTnVtcGFkMlwiLFxyXG4gICAgICAgIE5VTVBBRDMgPSBcIk51bXBhZDNcIixcclxuICAgICAgICBOVU1QQUQwID0gXCJOdW1wYWQwXCIsXHJcbiAgICAgICAgTlVNUEFEX0RFQ0lNQUwgPSBcIk51bXBhZERlY2ltYWxcIixcclxuICAgICAgICBQUklOVF9TQ1JFRU4gPSBcIlByaW50U2NyZWVuXCIsXHJcbiAgICAgICAgSU5UTF9CQUNLX1NMQVNIID0gXCJJbnRsQmFja1NsYXNoXCIsXHJcbiAgICAgICAgRjExID0gXCJGMTFcIixcclxuICAgICAgICBGMTIgPSBcIkYxMlwiLFxyXG4gICAgICAgIE5VTVBBRF9FUVVBTCA9IFwiTnVtcGFkRXF1YWxcIixcclxuICAgICAgICBGMTMgPSBcIkYxM1wiLFxyXG4gICAgICAgIEYxNCA9IFwiRjE0XCIsXHJcbiAgICAgICAgRjE1ID0gXCJGMTVcIixcclxuICAgICAgICBGMTYgPSBcIkYxNlwiLFxyXG4gICAgICAgIEYxNyA9IFwiRjE3XCIsXHJcbiAgICAgICAgRjE4ID0gXCJGMThcIixcclxuICAgICAgICBGMTkgPSBcIkYxOVwiLFxyXG4gICAgICAgIEYyMCA9IFwiRjIwXCIsXHJcbiAgICAgICAgRjIxID0gXCJGMjFcIixcclxuICAgICAgICBGMjIgPSBcIkYyMlwiLFxyXG4gICAgICAgIEYyMyA9IFwiRjIzXCIsXHJcbiAgICAgICAgRjI0ID0gXCJGMjRcIixcclxuICAgICAgICBLQU5BX01PREUgPSBcIkthbmFNb2RlXCIsXHJcbiAgICAgICAgTEFORzIgPSBcIkxhbmcyXCIsXHJcbiAgICAgICAgTEFORzEgPSBcIkxhbmcxXCIsXHJcbiAgICAgICAgSU5UTF9STyA9IFwiSW50bFJvXCIsXHJcbiAgICAgICAgQ09OVkVSVCA9IFwiQ29udmVydFwiLFxyXG4gICAgICAgIE5PTl9DT05WRVJUID0gXCJOb25Db252ZXJ0XCIsXHJcbiAgICAgICAgSU5UTF9ZRU4gPSBcIkludGxZZW5cIixcclxuICAgICAgICBOVU1QQURfQ09NTUEgPSBcIk51bXBhZENvbW1hXCIsXHJcbiAgICAgICAgVU5ETyA9IFwiVW5kb1wiLFxyXG4gICAgICAgIFBBU1RFID0gXCJQYXN0ZVwiLFxyXG4gICAgICAgIE1FRElBX1RSQUNLX1BSRVZJT1VTID0gXCJNZWRpYVRyYWNrUHJldmlvdXNcIixcclxuICAgICAgICBDVVQgPSBcIkN1dFwiLFxyXG4gICAgICAgIENPUFkgPSBcIkNvcHlcIixcclxuICAgICAgICBNRURJQV9UUkFDS19ORVhUID0gXCJNZWRpYVRyYWNrTmV4dFwiLFxyXG4gICAgICAgIE5VTVBBRF9FTlRFUiA9IFwiTnVtcGFkRW50ZXJcIixcclxuICAgICAgICBDVFJMX1JJR0hUID0gXCJDb250cm9sUmlnaHRcIixcclxuICAgICAgICBBVURJT19WT0xVTUVfTVVURSA9IFwiQXVkaW9Wb2x1bWVNdXRlXCIsXHJcbiAgICAgICAgTEFVTkNIX0FQUDIgPSBcIkxhdW5jaEFwcDJcIixcclxuICAgICAgICBNRURJQV9QTEFZX1BBVVNFID0gXCJNZWRpYVBsYXlQYXVzZVwiLFxyXG4gICAgICAgIE1FRElBX1NUT1AgPSBcIk1lZGlhU3RvcFwiLFxyXG4gICAgICAgIEVKRUNUID0gXCJFamVjdFwiLFxyXG4gICAgICAgIEFVRElPX1ZPTFVNRV9ET1dOID0gXCJBdWRpb1ZvbHVtZURvd25cIixcclxuICAgICAgICBWT0xVTUVfRE9XTiA9IFwiVm9sdW1lRG93blwiLFxyXG4gICAgICAgIEFVRElPX1ZPTFVNRV9VUCA9IFwiQXVkaW9Wb2x1bWVVcFwiLFxyXG4gICAgICAgIFZPTFVNRV9VUCA9IFwiVm9sdW1lVXBcIixcclxuICAgICAgICBCUk9XU0VSX0hPTUUgPSBcIkJyb3dzZXJIb21lXCIsXHJcbiAgICAgICAgTlVNUEFEX0RJVklERSA9IFwiTnVtcGFkRGl2aWRlXCIsXHJcbiAgICAgICAgQUxUX1JJR0hUID0gXCJBbHRSaWdodFwiLFxyXG4gICAgICAgIEhFTFAgPSBcIkhlbHBcIixcclxuICAgICAgICBOVU1fTE9DSyA9IFwiTnVtTG9ja1wiLFxyXG4gICAgICAgIEhPTUUgPSBcIkhvbWVcIixcclxuICAgICAgICBBUlJPV19VUCA9IFwiQXJyb3dVcFwiLFxyXG4gICAgICAgIEFSUk9XX1JJR0hUID0gXCJBcnJvd1JpZ2h0XCIsXHJcbiAgICAgICAgQVJST1dfRE9XTiA9IFwiQXJyb3dEb3duXCIsXHJcbiAgICAgICAgQVJST1dfTEVGVCA9IFwiQXJyb3dMZWZ0XCIsXHJcbiAgICAgICAgRU5EID0gXCJFbmRcIixcclxuICAgICAgICBQQUdFX1VQID0gXCJQYWdlVXBcIixcclxuICAgICAgICBQQUdFX0RPV04gPSBcIlBhZ2VEb3duXCIsXHJcbiAgICAgICAgSU5TRVJUID0gXCJJbnNlcnRcIixcclxuICAgICAgICBERUxFVEUgPSBcIkRlbGV0ZVwiLFxyXG4gICAgICAgIE1FVEFfTEVGVCA9IFwiTWV0YV9MZWZ0XCIsXHJcbiAgICAgICAgT1NfTEVGVCA9IFwiT1NMZWZ0XCIsXHJcbiAgICAgICAgTUVUQV9SSUdIVCA9IFwiTWV0YVJpZ2h0XCIsXHJcbiAgICAgICAgT1NfUklHSFQgPSBcIk9TUmlnaHRcIixcclxuICAgICAgICBDT05URVhUX01FTlUgPSBcIkNvbnRleHRNZW51XCIsXHJcbiAgICAgICAgUE9XRVIgPSBcIlBvd2VyXCIsXHJcbiAgICAgICAgQlJPV1NFUl9TRUFSQ0ggPSBcIkJyb3dzZXJTZWFyY2hcIixcclxuICAgICAgICBCUk9XU0VSX0ZBVk9SSVRFUyA9IFwiQnJvd3NlckZhdm9yaXRlc1wiLFxyXG4gICAgICAgIEJST1dTRVJfUkVGUkVTSCA9IFwiQnJvd3NlclJlZnJlc2hcIixcclxuICAgICAgICBCUk9XU0VSX1NUT1AgPSBcIkJyb3dzZXJTdG9wXCIsXHJcbiAgICAgICAgQlJPV1NFUl9GT1JXQVJEID0gXCJCcm93c2VyRm9yd2FyZFwiLFxyXG4gICAgICAgIEJST1dTRVJfQkFDSyA9IFwiQnJvd3NlckJhY2tcIixcclxuICAgICAgICBMQVVOQ0hfQVBQMSA9IFwiTGF1bmNoQXBwMVwiLFxyXG4gICAgICAgIExBVU5DSF9NQUlMID0gXCJMYXVuY2hNYWlsXCIsXHJcbiAgICAgICAgTEFVTkNIX01FRElBX1BMQVlFUiA9IFwiTGF1bmNoTWVkaWFQbGF5ZXJcIixcclxuXHJcbiAgICAgICAgLy9tYWMgYnJpbmdzIHRoaXMgYnV0dHRvblxyXG4gICAgICAgIEZOID0gXCJGblwiLCAvL25vIGV2ZW50IGZpcmVkIGFjdHVhbGx5XHJcblxyXG4gICAgICAgIC8vTGludXggYnJpbmdzIHRoZXNlXHJcbiAgICAgICAgQUdBSU4gPSBcIkFnYWluXCIsXHJcbiAgICAgICAgUFJPUFMgPSBcIlByb3BzXCIsXHJcbiAgICAgICAgU0VMRUNUID0gXCJTZWxlY3RcIixcclxuICAgICAgICBPUEVOID0gXCJPcGVuXCIsXHJcbiAgICAgICAgRklORCA9IFwiRmluZFwiLFxyXG4gICAgICAgIFdBS0VfVVAgPSBcIldha2VVcFwiLFxyXG4gICAgICAgIE5VTVBBRF9QQVJFTlRfTEVGVCA9IFwiTnVtcGFkUGFyZW50TGVmdFwiLFxyXG4gICAgICAgIE5VTVBBRF9QQVJFTlRfUklHSFQgPSBcIk51bXBhZFBhcmVudFJpZ2h0XCIsXHJcblxyXG4gICAgICAgIC8vYW5kcm9pZFxyXG4gICAgICAgIFNMRUVQID0gXCJTbGVlcFwiXHJcbiAgICB9XHJcbiAgICAvKiBcclxuICAgIEZpcmVmb3ggY2FuJ3QgbWFrZSB1c2Ugb2YgdGhvc2UgYnV0dG9ucyBhbmQgQ29tYmluYXRpb25zOlxyXG4gICAgU0lOR0VMRV9CVVRUT05TOlxyXG4gICAgIERydWNrLFxyXG4gICAgQ09NQklOQVRJT05TOlxyXG4gICAgIFNoaWZ0ICsgRjEwLCBTaGlmdCArIE51bXBhZDUsXHJcbiAgICAgQ1RSTCArIHEsIENUUkwgKyBGNCxcclxuICAgICBBTFQgKyBGMSwgQUxUICsgRjIsIEFMVCArIEYzLCBBTFQgKyBGNywgQUxUICsgRjgsIEFMVCArIEYxMFxyXG4gICAgT3BlcmEgd29uJ3QgZG8gZ29vZCB3aXRoIHRoZXNlIEJ1dHRvbnMgYW5kIGNvbWJpbmF0aW9uczpcclxuICAgIFNJTkdMRV9CVVRUT05TOlxyXG4gICAgIEZsb2F0MzJBcnJheSwgRjExLCBBTFQsXHJcbiAgICBDT01CSU5BVElPTlM6XHJcbiAgICAgQ1RSTCArIHEsIENUUkwgKyB0LCBDVFJMICsgaCwgQ1RSTCArIGcsIENUUkwgKyBuLCBDVFJMICsgZiBcclxuICAgICBBTFQgKyBGMSwgQUxUICsgRjIsIEFMVCArIEY0LCBBTFQgKyBGNSwgQUxUICsgRjYsIEFMVCArIEY3LCBBTFQgKyBGOCwgQUxUICsgRjEwXHJcbiAgICAgKi9cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gICAgZXhwb3J0IGNvbnN0IGVudW0gRVZFTlRfUE9JTlRFUiB7XHJcbiAgICAgICAgVVAgPSBcIsaScG9pbnRlcnVwXCIsXHJcbiAgICAgICAgRE9XTiA9IFwixpJwb2ludGVyZG93blwiLFxyXG4gICAgICAgIE1PVkUgPSBcIsaScG9pbnRlcm1vdmVcIixcclxuICAgICAgICBPVkVSID0gXCLGknBvaW50ZXJvdmVyXCIsXHJcbiAgICAgICAgRU5URVIgPSBcIsaScG9pbnRlcmVudGVyXCIsXHJcbiAgICAgICAgQ0FOQ0VMID0gXCLGknBvaW50ZXJjYW5jZWxcIixcclxuICAgICAgICBPVVQgPSBcIsaScG9pbnRlcm91dFwiLFxyXG4gICAgICAgIExFQVZFID0gXCLGknBvaW50ZXJsZWF2ZVwiLFxyXG4gICAgICAgIEdPVENBUFRVUkUgPSBcIsaSZ290cG9pbnRlcmNhcHR1cmVcIixcclxuICAgICAgICBMT1NUQ0FQVFVSRSA9IFwixpJsb3N0cG9pbnRlcmNhcHR1cmVcIlxyXG4gICAgfVxyXG5cclxuICAgIGV4cG9ydCBjbGFzcyBFdmVudFBvaW50ZXIgZXh0ZW5kcyBQb2ludGVyRXZlbnQge1xyXG4gICAgICAgIHB1YmxpYyBwb2ludGVyWDogbnVtYmVyO1xyXG4gICAgICAgIHB1YmxpYyBwb2ludGVyWTogbnVtYmVyO1xyXG4gICAgICAgIHB1YmxpYyBjYW52YXNYOiBudW1iZXI7XHJcbiAgICAgICAgcHVibGljIGNhbnZhc1k6IG51bWJlcjtcclxuICAgICAgICBwdWJsaWMgY2xpZW50UmVjdDogQ2xpZW50UmVjdDtcclxuXHJcbiAgICAgICAgY29uc3RydWN0b3IodHlwZTogc3RyaW5nLCBfZXZlbnQ6IEV2ZW50UG9pbnRlcikge1xyXG4gICAgICAgICAgICBzdXBlcih0eXBlLCBfZXZlbnQpO1xyXG4gICAgICAgICAgICBsZXQgdGFyZ2V0OiBIVE1MRWxlbWVudCA9IDxIVE1MRWxlbWVudD5fZXZlbnQudGFyZ2V0O1xyXG4gICAgICAgICAgICB0aGlzLmNsaWVudFJlY3QgPSB0YXJnZXQuZ2V0Q2xpZW50UmVjdHMoKVswXTtcclxuICAgICAgICAgICAgdGhpcy5wb2ludGVyWCA9IF9ldmVudC5jbGllbnRYIC0gdGhpcy5jbGllbnRSZWN0LmxlZnQ7XHJcbiAgICAgICAgICAgIHRoaXMucG9pbnRlclkgPSBfZXZlbnQuY2xpZW50WSAtIHRoaXMuY2xpZW50UmVjdC50b3A7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgICBleHBvcnQgY29uc3QgZW51bSBFVkVOVF9USU1FUiB7XHJcbiAgICAgICAgQ0FMTCA9IFwixpJsYXBzZVwiXHJcbiAgICB9XHJcblxyXG4gICAgZXhwb3J0IGNsYXNzIEV2ZW50VGltZXIge1xyXG4gICAgICAgIHB1YmxpYyB0eXBlOiBFVkVOVF9USU1FUiA9IEVWRU5UX1RJTUVSLkNBTEw7XHJcbiAgICAgICAgcHVibGljIHRhcmdldDogVGltZXI7XHJcbiAgICAgICAgcHVibGljIGFyZ3VtZW50czogT2JqZWN0W107XHJcbiAgICAgICAgcHVibGljIGZpcnN0Q2FsbDogYm9vbGVhbiA9IHRydWU7XHJcbiAgICAgICAgcHVibGljIGxhc3RDYWxsOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGNvbnN0cnVjdG9yKF90aW1lcjogVGltZXIsIC4uLl9hcmd1bWVudHM6IE9iamVjdFtdKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gX3RpbWVyO1xyXG4gICAgICAgICAgICB0aGlzLmFyZ3VtZW50cyA9IF9hcmd1bWVudHM7XHJcbiAgICAgICAgICAgIHRoaXMuZmlyc3RDYWxsID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAgIGV4cG9ydCBjb25zdCBlbnVtIEVWRU5UX1dIRUVMIHtcclxuICAgICAgICBXSEVFTCA9IFwixpJ3aGVlbFwiXHJcbiAgICB9XHJcbiAgICBcclxuICAgIGV4cG9ydCBjbGFzcyBFdmVudFdoZWVsIGV4dGVuZHMgV2hlZWxFdmVudCB7XHJcbiAgICAgICAgY29uc3RydWN0b3IodHlwZTogc3RyaW5nLCBfZXZlbnQ6IEV2ZW50V2hlZWwpIHtcclxuICAgICAgICAgICAgc3VwZXIodHlwZSwgX2V2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAgIGV4cG9ydCB0eXBlIFR5cGVPZkxpZ2h0ID0gbmV3ICgpID0+IExpZ2h0O1xyXG4gICAgLyoqXHJcbiAgICAgKiBCYXNlY2xhc3MgZm9yIGRpZmZlcmVudCBraW5kcyBvZiBsaWdodHMuIFxyXG4gICAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgICAqL1xyXG4gICAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIExpZ2h0IGV4dGVuZHMgTXV0YWJsZSB7XHJcbiAgICAgICAgcHVibGljIGNvbG9yOiBDb2xvcjtcclxuICAgICAgICBjb25zdHJ1Y3RvcihfY29sb3I6IENvbG9yID0gbmV3IENvbG9yKDEsIDEsIDEsIDEpKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29sb3IgPSBfY29sb3I7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgZ2V0VHlwZSgpOiBUeXBlT2ZMaWdodCB7XHJcbiAgICAgICAgICAgIHJldHVybiA8VHlwZU9mTGlnaHQ+dGhpcy5jb25zdHJ1Y3RvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoKTogdm9pZCB7LyoqLyB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbWJpZW50IGxpZ2h0LCBjb21pbmcgZnJvbSBhbGwgZGlyZWN0aW9ucywgaWxsdW1pbmF0aW5nIGV2ZXJ5dGhpbmcgd2l0aCBpdHMgY29sb3IgaW5kZXBlbmRlbnQgb2YgcG9zaXRpb24gYW5kIG9yaWVudGF0aW9uIChsaWtlIGEgZm9nZ3kgZGF5IG9yIGluIHRoZSBzaGFkZXMpICBcclxuICAgICAqIGBgYHBsYWludGV4dFxyXG4gICAgICogfiB+IH4gIFxyXG4gICAgICogIH4gfiB+ICBcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBleHBvcnQgY2xhc3MgTGlnaHRBbWJpZW50IGV4dGVuZHMgTGlnaHQge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKF9jb2xvcjogQ29sb3IgPSBuZXcgQ29sb3IoMSwgMSwgMSwgMSkpIHtcclxuICAgICAgICAgICAgc3VwZXIoX2NvbG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERpcmVjdGlvbmFsIGxpZ2h0LCBpbGx1bWluYXRpbmcgZXZlcnl0aGluZyBmcm9tIGEgc3BlY2lmaWVkIGRpcmVjdGlvbiB3aXRoIGl0cyBjb2xvciAobGlrZSBzdGFuZGluZyBpbiBicmlnaHQgc3VubGlnaHQpICBcclxuICAgICAqIGBgYHBsYWludGV4dFxyXG4gICAgICogLS0tPiAgXHJcbiAgICAgKiAtLS0+ICBcclxuICAgICAqIC0tLT4gIFxyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIGV4cG9ydCBjbGFzcyBMaWdodERpcmVjdGlvbmFsIGV4dGVuZHMgTGlnaHQge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKF9jb2xvcjogQ29sb3IgPSBuZXcgQ29sb3IoMSwgMSwgMSwgMSkpIHtcclxuICAgICAgICAgICAgc3VwZXIoX2NvbG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE9tbmlkaXJlY3Rpb25hbCBsaWdodCBlbWl0dGluZyBmcm9tIGl0cyBwb3NpdGlvbiwgaWxsdW1pbmF0aW5nIG9iamVjdHMgZGVwZW5kaW5nIG9uIHRoZWlyIHBvc2l0aW9uIGFuZCBkaXN0YW5jZSB3aXRoIGl0cyBjb2xvciAobGlrZSBhIGNvbG9yZWQgbGlnaHQgYnVsYikgIFxyXG4gICAgICogYGBgcGxhaW50ZXh0XHJcbiAgICAgKiAgICAgICAgIC5cXHwvLlxyXG4gICAgICogICAgICAgIC0tIG8gLS1cclxuICAgICAqICAgICAgICAgwrQvfFxcYFxyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIGV4cG9ydCBjbGFzcyBMaWdodFBvaW50IGV4dGVuZHMgTGlnaHQge1xyXG4gICAgICAgIHB1YmxpYyByYW5nZTogbnVtYmVyID0gMTA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNwb3QgbGlnaHQgZW1pdHRpbmcgd2l0aGluIGEgc3BlY2lmaWVkIGFuZ2xlIGZyb20gaXRzIHBvc2l0aW9uLCBpbGx1bWluYXRpbmcgb2JqZWN0cyBkZXBlbmRpbmcgb24gdGhlaXIgcG9zaXRpb24gYW5kIGRpc3RhbmNlIHdpdGggaXRzIGNvbG9yICBcclxuICAgICAqIGBgYHBsYWludGV4dFxyXG4gICAgICogICAgICAgICAgbyAgXHJcbiAgICAgKiAgICAgICAgIC98XFwgIFxyXG4gICAgICogICAgICAgIC8gfCBcXCBcclxuICAgICAqIGBgYCAgIFxyXG4gICAgICovXHJcbiAgICBleHBvcnQgY2xhc3MgTGlnaHRTcG90IGV4dGVuZHMgTGlnaHQge1xyXG4gICAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGludGVyZmFjZSBCb3JkZXIge1xyXG4gICAgbGVmdDogbnVtYmVyO1xyXG4gICAgdG9wOiBudW1iZXI7XHJcbiAgICByaWdodDogbnVtYmVyO1xyXG4gICAgYm90dG9tOiBudW1iZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGcmFtaW5nIGRlc2NyaWJlcyBob3cgdG8gbWFwIGEgcmVjdGFuZ2xlIGludG8gYSBnaXZlbiBmcmFtZVxyXG4gICAqIGFuZCBob3cgcG9pbnRzIGluIHRoZSBmcmFtZSBjb3JyZXNwb25kIHRvIHBvaW50cyBpbiB0aGUgcmVzdWx0aW5nIHJlY3RhbmdsZSBhbmQgdmljZSB2ZXJzYVxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5ICBcclxuICAgKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vSmlya2FEZWxsT3JvL0ZVREdFL3dpa2kvRnJhbWluZ1xyXG4gICAqL1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBGcmFtaW5nIGV4dGVuZHMgTXV0YWJsZSB7XHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgYSBwb2ludCBpbiB0aGUgZ2l2ZW4gZnJhbWUgYWNjb3JkaW5nIHRvIHRoaXMgZnJhbWluZ1xyXG4gICAgICogQHBhcmFtIF9wb2ludEluRnJhbWUgVGhlIHBvaW50IGluIHRoZSBmcmFtZSBnaXZlblxyXG4gICAgICogQHBhcmFtIF9yZWN0RnJhbWUgVGhlIGZyYW1lIHRoZSBwb2ludCBpcyByZWxhdGl2ZSB0b1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0UG9pbnQoX3BvaW50SW5GcmFtZTogVmVjdG9yMiwgX3JlY3RGcmFtZTogUmVjdGFuZ2xlKTogVmVjdG9yMjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgYSBwb2ludCBpbiBhIGdpdmVuIHJlY3RhbmdsZSBiYWNrIHRvIGEgY2FsY3VsYXRlZCBmcmFtZSBvZiBvcmlnaW5cclxuICAgICAqIEBwYXJhbSBfcG9pbnQgVGhlIHBvaW50IGluIHRoZSByZWN0YW5nbGVcclxuICAgICAqIEBwYXJhbSBfcmVjdCBUaGUgcmVjdGFuZ2xlIHRoZSBwb2ludCBpcyByZWxhdGl2ZSB0b1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0UG9pbnRJbnZlcnNlKF9wb2ludDogVmVjdG9yMiwgX3JlY3Q6IFJlY3RhbmdsZSk6IFZlY3RvcjI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUYWtlcyBhIHJlY3RhbmdsZSBhcyB0aGUgZnJhbWUgYW5kIGNyZWF0ZXMgYSBuZXcgcmVjdGFuZ2xlIGFjY29yZGluZyB0byB0aGUgZnJhbWluZ1xyXG4gICAgICogQHBhcmFtIF9yZWN0RnJhbWVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IGdldFJlY3QoX3JlY3RGcmFtZTogUmVjdGFuZ2xlKTogUmVjdGFuZ2xlO1xyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHsvKiogKi8gfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHJlc3VsdGluZyByZWN0YW5nbGUgaGFzIGEgZml4ZWQgd2lkdGggYW5kIGhlaWdodCBhbmQgZGlzcGxheSBzaG91bGQgc2NhbGUgdG8gZml0IHRoZSBmcmFtZVxyXG4gICAqIFBvaW50cyBhcmUgc2NhbGVkIGluIHRoZSBzYW1lIHJhdGlvXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEZyYW1pbmdGaXhlZCBleHRlbmRzIEZyYW1pbmcge1xyXG4gICAgcHVibGljIHdpZHRoOiBudW1iZXIgPSAzMDA7XHJcbiAgICBwdWJsaWMgaGVpZ2h0OiBudW1iZXIgPSAxNTA7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF93aWR0aDogbnVtYmVyID0gMzAwLCBfaGVpZ2h0OiBudW1iZXIgPSAxNTApIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5zZXRTaXplKF93aWR0aCwgX2hlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldFNpemUoX3dpZHRoOiBudW1iZXIsIF9oZWlnaHQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICB0aGlzLndpZHRoID0gX3dpZHRoO1xyXG4gICAgICB0aGlzLmhlaWdodCA9IF9oZWlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFBvaW50KF9wb2ludEluRnJhbWU6IFZlY3RvcjIsIF9yZWN0RnJhbWU6IFJlY3RhbmdsZSk6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IyID0gbmV3IFZlY3RvcjIoXHJcbiAgICAgICAgdGhpcy53aWR0aCAqIChfcG9pbnRJbkZyYW1lLnggLSBfcmVjdEZyYW1lLngpIC8gX3JlY3RGcmFtZS53aWR0aCxcclxuICAgICAgICB0aGlzLmhlaWdodCAqIChfcG9pbnRJbkZyYW1lLnkgLSBfcmVjdEZyYW1lLnkpIC8gX3JlY3RGcmFtZS5oZWlnaHRcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0UG9pbnRJbnZlcnNlKF9wb2ludDogVmVjdG9yMiwgX3JlY3Q6IFJlY3RhbmdsZSk6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IyID0gbmV3IFZlY3RvcjIoXHJcbiAgICAgICAgX3BvaW50LnggKiBfcmVjdC53aWR0aCAvIHRoaXMud2lkdGggKyBfcmVjdC54LFxyXG4gICAgICAgIF9wb2ludC55ICogX3JlY3QuaGVpZ2h0IC8gdGhpcy5oZWlnaHQgKyBfcmVjdC55XHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFJlY3QoX3JlY3RGcmFtZTogUmVjdGFuZ2xlKTogUmVjdGFuZ2xlIHtcclxuICAgICAgcmV0dXJuIFJlY3RhbmdsZS5HRVQoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKipcclxuICAgKiBXaWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSByZXN1bHRpbmcgcmVjdGFuZ2xlIGFyZSBmcmFjdGlvbnMgb2YgdGhvc2Ugb2YgdGhlIGZyYW1lLCBzY2FsZWQgYnkgbm9ybWVkIHZhbHVlcyBub3JtV2lkdGggYW5kIG5vcm1IZWlnaHQuXHJcbiAgICogRGlzcGxheSBzaG91bGQgc2NhbGUgdG8gZml0IHRoZSBmcmFtZSBhbmQgcG9pbnRzIGFyZSBzY2FsZWQgaW4gdGhlIHNhbWUgcmF0aW9cclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgRnJhbWluZ1NjYWxlZCBleHRlbmRzIEZyYW1pbmcge1xyXG4gICAgcHVibGljIG5vcm1XaWR0aDogbnVtYmVyID0gMS4wO1xyXG4gICAgcHVibGljIG5vcm1IZWlnaHQ6IG51bWJlciA9IDEuMDtcclxuXHJcbiAgICBwdWJsaWMgc2V0U2NhbGUoX25vcm1XaWR0aDogbnVtYmVyLCBfbm9ybUhlaWdodDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIHRoaXMubm9ybVdpZHRoID0gX25vcm1XaWR0aDtcclxuICAgICAgdGhpcy5ub3JtSGVpZ2h0ID0gX25vcm1IZWlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFBvaW50KF9wb2ludEluRnJhbWU6IFZlY3RvcjIsIF9yZWN0RnJhbWU6IFJlY3RhbmdsZSk6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IyID0gbmV3IFZlY3RvcjIoXHJcbiAgICAgICAgdGhpcy5ub3JtV2lkdGggKiAoX3BvaW50SW5GcmFtZS54IC0gX3JlY3RGcmFtZS54KSxcclxuICAgICAgICB0aGlzLm5vcm1IZWlnaHQgKiAoX3BvaW50SW5GcmFtZS55IC0gX3JlY3RGcmFtZS55KVxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRQb2ludEludmVyc2UoX3BvaW50OiBWZWN0b3IyLCBfcmVjdDogUmVjdGFuZ2xlKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjIgPSBuZXcgVmVjdG9yMihcclxuICAgICAgICBfcG9pbnQueCAvIHRoaXMubm9ybVdpZHRoICsgX3JlY3QueCxcclxuICAgICAgICBfcG9pbnQueSAvIHRoaXMubm9ybUhlaWdodCArIF9yZWN0LnlcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0UmVjdChfcmVjdEZyYW1lOiBSZWN0YW5nbGUpOiBSZWN0YW5nbGUge1xyXG4gICAgICByZXR1cm4gUmVjdGFuZ2xlLkdFVCgwLCAwLCB0aGlzLm5vcm1XaWR0aCAqIF9yZWN0RnJhbWUud2lkdGgsIHRoaXMubm9ybUhlaWdodCAqIF9yZWN0RnJhbWUuaGVpZ2h0KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSByZXN1bHRpbmcgcmVjdGFuZ2xlIGZpdHMgaW50byBhIG1hcmdpbiBnaXZlbiBhcyBmcmFjdGlvbnMgb2YgdGhlIHNpemUgb2YgdGhlIGZyYW1lIGdpdmVuIGJ5IG5vcm1BbmNob3JcclxuICAgKiBwbHVzIGFuIGFic29sdXRlIHBhZGRpbmcgZ2l2ZW4gYnkgcGl4ZWxCb3JkZXIuIERpc3BsYXkgc2hvdWxkIGZpdCBpbnRvIHRoaXMuXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEZyYW1pbmdDb21wbGV4IGV4dGVuZHMgRnJhbWluZyB7XHJcbiAgICBwdWJsaWMgbWFyZ2luOiBCb3JkZXIgPSB7IGxlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCB9O1xyXG4gICAgcHVibGljIHBhZGRpbmc6IEJvcmRlciA9IHsgbGVmdDogMCwgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwIH07XHJcblxyXG4gICAgcHVibGljIGdldFBvaW50KF9wb2ludEluRnJhbWU6IFZlY3RvcjIsIF9yZWN0RnJhbWU6IFJlY3RhbmdsZSk6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IyID0gbmV3IFZlY3RvcjIoXHJcbiAgICAgICAgX3BvaW50SW5GcmFtZS54IC0gdGhpcy5wYWRkaW5nLmxlZnQgLSB0aGlzLm1hcmdpbi5sZWZ0ICogX3JlY3RGcmFtZS53aWR0aCxcclxuICAgICAgICBfcG9pbnRJbkZyYW1lLnkgLSB0aGlzLnBhZGRpbmcudG9wIC0gdGhpcy5tYXJnaW4udG9wICogX3JlY3RGcmFtZS5oZWlnaHRcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHB1YmxpYyBnZXRQb2ludEludmVyc2UoX3BvaW50OiBWZWN0b3IyLCBfcmVjdDogUmVjdGFuZ2xlKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjIgPSBuZXcgVmVjdG9yMihcclxuICAgICAgICBfcG9pbnQueCArIHRoaXMucGFkZGluZy5sZWZ0ICsgdGhpcy5tYXJnaW4ubGVmdCAqIF9yZWN0LndpZHRoLFxyXG4gICAgICAgIF9wb2ludC55ICsgdGhpcy5wYWRkaW5nLnRvcCArIHRoaXMubWFyZ2luLnRvcCAqIF9yZWN0LmhlaWdodFxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRSZWN0KF9yZWN0RnJhbWU6IFJlY3RhbmdsZSk6IFJlY3RhbmdsZSB7XHJcbiAgICAgIGlmICghX3JlY3RGcmFtZSlcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgIGxldCBtaW5YOiBudW1iZXIgPSBfcmVjdEZyYW1lLnggKyB0aGlzLm1hcmdpbi5sZWZ0ICogX3JlY3RGcmFtZS53aWR0aCArIHRoaXMucGFkZGluZy5sZWZ0O1xyXG4gICAgICBsZXQgbWluWTogbnVtYmVyID0gX3JlY3RGcmFtZS55ICsgdGhpcy5tYXJnaW4udG9wICogX3JlY3RGcmFtZS5oZWlnaHQgKyB0aGlzLnBhZGRpbmcudG9wO1xyXG4gICAgICBsZXQgbWF4WDogbnVtYmVyID0gX3JlY3RGcmFtZS54ICsgKDEgLSB0aGlzLm1hcmdpbi5yaWdodCkgKiBfcmVjdEZyYW1lLndpZHRoIC0gdGhpcy5wYWRkaW5nLnJpZ2h0O1xyXG4gICAgICBsZXQgbWF4WTogbnVtYmVyID0gX3JlY3RGcmFtZS55ICsgKDEgLSB0aGlzLm1hcmdpbi5ib3R0b20pICogX3JlY3RGcmFtZS5oZWlnaHQgLSB0aGlzLnBhZGRpbmcuYm90dG9tO1xyXG5cclxuICAgICAgcmV0dXJuIFJlY3RhbmdsZS5HRVQobWluWCwgbWluWSwgbWF4WCAtIG1pblgsIG1heFkgLSBtaW5ZKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcclxuICAgICAgcmV0dXJuIHsgbWFyZ2luOiB0aGlzLm1hcmdpbiwgcGFkZGluZzogdGhpcy5wYWRkaW5nIH07XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlcHJlc2VudHMgdGhlIG1hdHJpeCBhcyB0cmFuc2xhdGlvbiwgcm90YXRpb24gYW5kIHNjYWxpbmcgdmVjdG9yLCBiZWluZyBjYWxjdWxhdGVkIGZyb20gdGhlIG1hdHJpeFxyXG4gICAqL1xyXG4gIGludGVyZmFjZSBWZWN0b3JSZXByZXNlbnRhdGlvbiB7XHJcbiAgICB0cmFuc2xhdGlvbjogVmVjdG9yMjtcclxuICAgIHJvdGF0aW9uOiBudW1iZXI7XHJcbiAgICBzY2FsaW5nOiBWZWN0b3IyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2ltcGxlIGNsYXNzIGZvciAzeDMgbWF0cml4IG9wZXJhdGlvbnNcclxuICAgKiBAYXV0aG9ycyBKYXNjaGEgS2FyYWfDtmwsIEhGVSwgMjAxOSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIwXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE1hdHJpeDN4MyBleHRlbmRzIE11dGFibGUgaW1wbGVtZW50cyBTZXJpYWxpemFibGUge1xyXG4gICAgcHJpdmF0ZSBkYXRhOiBGbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDMpOyAvLyBUaGUgZGF0YSBvZiB0aGUgbWF0cml4LlxyXG4gICAgcHJpdmF0ZSBtdXRhdG9yOiBNdXRhdG9yID0gbnVsbDsgLy8gcHJlcGFyZWQgZm9yIG9wdGltaXphdGlvbiwga2VlcCBtdXRhdG9yIHRvIHJlZHVjZSByZWR1bmRhbnQgY2FsY3VsYXRpb24gYW5kIGZvciBjb21wYXJpc29uLiBTZXQgdG8gbnVsbCB3aGVuIGRhdGEgY2hhbmdlcyFcclxuICAgIHByaXZhdGUgdmVjdG9yczogVmVjdG9yUmVwcmVzZW50YXRpb247IC8vIHZlY3RvciByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG1hdHJpeFxyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAgICAgMSwgMCwgMCxcclxuICAgICAgICAwLCAxLCAwLFxyXG4gICAgICAgIDAsIDAsIDFcclxuICAgICAgXSk7XHJcbiAgICAgIHRoaXMucmVzZXRDYWNoZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBcclxuICAgICAqIC0gZ2V0OiBhIGNvcHkgb2YgdGhlIGNhbGN1bGF0ZWQgdHJhbnNsYXRpb24gdmVjdG9yICAgXHJcbiAgICAgKiAtIHNldDogZWZmZWN0IHRoZSBtYXRyaXggaWdub3JpbmcgaXRzIHJvdGF0aW9uIGFuZCBzY2FsaW5nXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgdHJhbnNsYXRpb24oKTogVmVjdG9yMiB7XHJcbiAgICAgIGlmICghdGhpcy52ZWN0b3JzLnRyYW5zbGF0aW9uKVxyXG4gICAgICAgIHRoaXMudmVjdG9ycy50cmFuc2xhdGlvbiA9IG5ldyBWZWN0b3IyKHRoaXMuZGF0YVs2XSwgdGhpcy5kYXRhWzddKTtcclxuICAgICAgcmV0dXJuIHRoaXMudmVjdG9ycy50cmFuc2xhdGlvbi5jb3B5O1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCB0cmFuc2xhdGlvbihfdHJhbnNsYXRpb246IFZlY3RvcjIpIHtcclxuICAgICAgdGhpcy5kYXRhLnNldChfdHJhbnNsYXRpb24uZ2V0KCksIDEyKTtcclxuICAgICAgLy8gbm8gZnVsbCBjYWNoZSByZXNldCByZXF1aXJlZFxyXG4gICAgICB0aGlzLnZlY3RvcnMudHJhbnNsYXRpb24gPSBfdHJhbnNsYXRpb247XHJcbiAgICAgIHRoaXMubXV0YXRvciA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogLSBnZXQ6IGEgY29weSBvZiB0aGUgY2FsY3VsYXRlZCByb3RhdGlvbiB2ZWN0b3IgICBcclxuICAgICAqIC0gc2V0OiBlZmZlY3QgdGhlIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHJvdGF0aW9uKCk6IG51bWJlciB7XHJcbiAgICAgIGlmICghdGhpcy52ZWN0b3JzLnJvdGF0aW9uKVxyXG4gICAgICAgIHRoaXMudmVjdG9ycy5yb3RhdGlvbiA9IHRoaXMuZ2V0RXVsZXJBbmdsZXMoKTtcclxuICAgICAgcmV0dXJuIHRoaXMudmVjdG9ycy5yb3RhdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgcm90YXRpb24oX3JvdGF0aW9uOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5tdXRhdGUoeyBcInJvdGF0aW9uXCI6IF9yb3RhdGlvbiB9KTtcclxuICAgICAgdGhpcy5yZXNldENhY2hlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogLSBnZXQ6IGEgY29weSBvZiB0aGUgY2FsY3VsYXRlZCBzY2FsZSB2ZWN0b3IgICBcclxuICAgICAqIC0gc2V0OiBlZmZlY3QgdGhlIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHNjYWxpbmcoKTogVmVjdG9yMiB7XHJcbiAgICAgIGlmICghdGhpcy52ZWN0b3JzLnNjYWxpbmcpXHJcbiAgICAgICAgdGhpcy52ZWN0b3JzLnNjYWxpbmcgPSBuZXcgVmVjdG9yMihcclxuICAgICAgICAgIE1hdGguaHlwb3QodGhpcy5kYXRhWzBdLCB0aGlzLmRhdGFbMV0pLFxyXG4gICAgICAgICAgTWF0aC5oeXBvdCh0aGlzLmRhdGFbM10sIHRoaXMuZGF0YVs0XSlcclxuICAgICAgICApO1xyXG4gICAgICByZXR1cm4gdGhpcy52ZWN0b3JzLnNjYWxpbmcuY29weTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgc2NhbGluZyhfc2NhbGluZzogVmVjdG9yMikge1xyXG4gICAgICB0aGlzLm11dGF0ZSh7IFwic2NhbGluZ1wiOiBfc2NhbGluZyB9KTtcclxuICAgICAgdGhpcy5yZXNldENhY2hlKCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vVE9ETzogZmlndXJlIG91dCB3aGF0IHRoaXMgaXMgdXNlZCBmb3JcclxuICAgIHB1YmxpYyBzdGF0aWMgUFJPSkVDVElPTihfd2lkdGg6IG51bWJlciwgX2hlaWdodDogbnVtYmVyKTogTWF0cml4M3gzIHtcclxuICAgICAgbGV0IG1hdHJpeDogTWF0cml4M3gzID0gbmV3IE1hdHJpeDN4MztcclxuICAgICAgbWF0cml4LmRhdGEuc2V0KFtcclxuICAgICAgICAyIC8gX3dpZHRoLCAwLCAwLFxyXG4gICAgICAgIDAsIC0yIC8gX2hlaWdodCwgMCxcclxuICAgICAgICAtMSwgMSwgMVxyXG4gICAgICBdKTtcclxuICAgICAgcmV0dXJuIG1hdHJpeDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIElERU5USVRZKCk6IE1hdHJpeDN4MyB7XHJcbiAgICAgIGNvbnN0IHJlc3VsdDogTWF0cml4M3gzID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDN4Myk7XHJcbiAgICAgIHJlc3VsdC5kYXRhLnNldChbXHJcbiAgICAgICAgMSwgMCwgMCxcclxuICAgICAgICAwLCAxLCAwLFxyXG4gICAgICAgIDAsIDAsIDFcclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbWF0cml4IHRoYXQgdHJhbnNsYXRlcyBjb29yZGluYXRlcyBhbG9uZyB0aGUgeC0sIHktIGFuZCB6LWF4aXMgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgVFJBTlNMQVRJT04oX3RyYW5zbGF0ZTogVmVjdG9yMik6IE1hdHJpeDN4MyB7XHJcbiAgICAgIGNvbnN0IG1hdHJpeDogTWF0cml4M3gzID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDN4Myk7XHJcbiAgICAgIG1hdHJpeC5kYXRhLnNldChbXHJcbiAgICAgICAgMSwgMCwgMCxcclxuICAgICAgICAwLCAxLCAwLFxyXG4gICAgICAgIF90cmFuc2xhdGUueCwgX3RyYW5zbGF0ZS55LCAxXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gbWF0cml4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG1hdHJpeCB0aGF0IHJvdGF0ZXMgY29vcmRpbmF0ZXMgb24gdGhlIHotYXhpcyB3aGVuIG11bHRpcGxpZWQgYnkuXHJcbiAgICAgKiBAcGFyYW0gX2FuZ2xlSW5EZWdyZWVzIFRoZSB2YWx1ZSBvZiB0aGUgcm90YXRpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgUk9UQVRJT04oX2FuZ2xlSW5EZWdyZWVzOiBudW1iZXIpOiBNYXRyaXgzeDMge1xyXG4gICAgICAvLyBjb25zdCBtYXRyaXg6IE1hdHJpeDN4MyA9IG5ldyBNYXRyaXgzeDM7XHJcbiAgICAgIGNvbnN0IG1hdHJpeDogTWF0cml4M3gzID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDN4Myk7XHJcbiAgICAgIGxldCBhbmdsZUluUmFkaWFuczogbnVtYmVyID0gX2FuZ2xlSW5EZWdyZWVzICogTWF0aC5QSSAvIDE4MDtcclxuICAgICAgbGV0IHNpbjogbnVtYmVyID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xyXG4gICAgICBsZXQgY29zOiBudW1iZXIgPSBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyk7XHJcbiAgICAgIG1hdHJpeC5kYXRhLnNldChbXHJcbiAgICAgICAgY29zLCBzaW4sIDAsXHJcbiAgICAgICAgLXNpbiwgY29zLCAwLFxyXG4gICAgICAgIDAsIDAsIDFcclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiBtYXRyaXg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbWF0cml4IHRoYXQgc2NhbGVzIGNvb3JkaW5hdGVzIGFsb25nIHRoZSB4LSwgeS0gYW5kIHotYXhpcyBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFNDQUxJTkcoX3NjYWxhcjogVmVjdG9yMik6IE1hdHJpeDN4MyB7XHJcbiAgICAgIC8vIGNvbnN0IG1hdHJpeDogTWF0cml4M3gzID0gbmV3IE1hdHJpeDN4MztcclxuICAgICAgY29uc3QgbWF0cml4OiBNYXRyaXgzeDMgPSBSZWN5Y2xlci5nZXQoTWF0cml4M3gzKTtcclxuICAgICAgbWF0cml4LmRhdGEuc2V0KFtcclxuICAgICAgICBfc2NhbGFyLngsIDAsIDAsXHJcbiAgICAgICAgMCwgX3NjYWxhci55LCAwLFxyXG4gICAgICAgIDAsIDAsIDFcclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiBtYXRyaXg7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBNVUxUSVBMSUNBVElPTihfYTogTWF0cml4M3gzLCBfYjogTWF0cml4M3gzKTogTWF0cml4M3gzIHtcclxuICAgICAgbGV0IGEwMDogbnVtYmVyID0gX2EuZGF0YVswICogMyArIDBdO1xyXG4gICAgICBsZXQgYTAxOiBudW1iZXIgPSBfYS5kYXRhWzAgKiAzICsgMV07XHJcbiAgICAgIGxldCBhMDI6IG51bWJlciA9IF9hLmRhdGFbMCAqIDMgKyAyXTtcclxuICAgICAgbGV0IGExMDogbnVtYmVyID0gX2EuZGF0YVsxICogMyArIDBdO1xyXG4gICAgICBsZXQgYTExOiBudW1iZXIgPSBfYS5kYXRhWzEgKiAzICsgMV07XHJcbiAgICAgIGxldCBhMTI6IG51bWJlciA9IF9hLmRhdGFbMSAqIDMgKyAyXTtcclxuICAgICAgbGV0IGEyMDogbnVtYmVyID0gX2EuZGF0YVsyICogMyArIDBdO1xyXG4gICAgICBsZXQgYTIxOiBudW1iZXIgPSBfYS5kYXRhWzIgKiAzICsgMV07XHJcbiAgICAgIGxldCBhMjI6IG51bWJlciA9IF9hLmRhdGFbMiAqIDMgKyAyXTtcclxuICAgICAgbGV0IGIwMDogbnVtYmVyID0gX2IuZGF0YVswICogMyArIDBdO1xyXG4gICAgICBsZXQgYjAxOiBudW1iZXIgPSBfYi5kYXRhWzAgKiAzICsgMV07XHJcbiAgICAgIGxldCBiMDI6IG51bWJlciA9IF9iLmRhdGFbMCAqIDMgKyAyXTtcclxuICAgICAgbGV0IGIxMDogbnVtYmVyID0gX2IuZGF0YVsxICogMyArIDBdO1xyXG4gICAgICBsZXQgYjExOiBudW1iZXIgPSBfYi5kYXRhWzEgKiAzICsgMV07XHJcbiAgICAgIGxldCBiMTI6IG51bWJlciA9IF9iLmRhdGFbMSAqIDMgKyAyXTtcclxuICAgICAgbGV0IGIyMDogbnVtYmVyID0gX2IuZGF0YVsyICogMyArIDBdO1xyXG4gICAgICBsZXQgYjIxOiBudW1iZXIgPSBfYi5kYXRhWzIgKiAzICsgMV07XHJcbiAgICAgIGxldCBiMjI6IG51bWJlciA9IF9iLmRhdGFbMiAqIDMgKyAyXTtcclxuICAgICAgbGV0IG1hdHJpeDogTWF0cml4M3gzID0gbmV3IE1hdHJpeDN4MztcclxuICAgICAgbWF0cml4LmRhdGEuc2V0KFtcclxuICAgICAgICBiMDAgKiBhMDAgKyBiMDEgKiBhMTAgKyBiMDIgKiBhMjAsXHJcbiAgICAgICAgYjAwICogYTAxICsgYjAxICogYTExICsgYjAyICogYTIxLFxyXG4gICAgICAgIGIwMCAqIGEwMiArIGIwMSAqIGExMiArIGIwMiAqIGEyMixcclxuICAgICAgICBiMTAgKiBhMDAgKyBiMTEgKiBhMTAgKyBiMTIgKiBhMjAsXHJcbiAgICAgICAgYjEwICogYTAxICsgYjExICogYTExICsgYjEyICogYTIxLFxyXG4gICAgICAgIGIxMCAqIGEwMiArIGIxMSAqIGExMiArIGIxMiAqIGEyMixcclxuICAgICAgICBiMjAgKiBhMDAgKyBiMjEgKiBhMTAgKyBiMjIgKiBhMjAsXHJcbiAgICAgICAgYjIwICogYTAxICsgYjIxICogYTExICsgYjIyICogYTIxLFxyXG4gICAgICAgIGIyMCAqIGEwMiArIGIyMSAqIGExMiArIGIyMiAqIGEyMlxyXG4gICAgICBdKTtcclxuICAgICAgcmV0dXJuIG1hdHJpeDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zbGF0aW9uXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIHRyYW5zbGF0aW9uIGJ5IHRoZSBnaXZlbiB2ZWN0b3IgdG8gdGhpcyBtYXRyaXggXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0cmFuc2xhdGUoX2J5OiBWZWN0b3IyKTogdm9pZCB7XHJcbiAgICAgIGNvbnN0IG1hdHJpeDogTWF0cml4M3gzID0gTWF0cml4M3gzLk1VTFRJUExJQ0FUSU9OKHRoaXMsIE1hdHJpeDN4My5UUkFOU0xBVElPTihfYnkpKTtcclxuICAgICAgLy8gVE9ETzogcG9zc2libGUgb3B0aW1pemF0aW9uLCB0cmFuc2xhdGlvbiBtYXkgYWx0ZXIgbXV0YXRvciBpbnN0ZWFkIG9mIGRlbGV0aW5nIGl0LlxyXG4gICAgICB0aGlzLnNldChtYXRyaXgpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShtYXRyaXgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgdHJhbnNsYXRpb24gYWxvbmcgdGhlIHgtQXhpcyBieSB0aGUgZ2l2ZW4gYW1vdW50IHRvIHRoaXMgbWF0cml4IFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdHJhbnNsYXRlWChfeDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuZGF0YVs2XSArPSBfeDtcclxuICAgICAgdGhpcy5tdXRhdG9yID0gbnVsbDtcclxuICAgICAgdGhpcy52ZWN0b3JzLnRyYW5zbGF0aW9uID0gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgdHJhbnNsYXRpb24gYWxvbmcgdGhlIHktQXhpcyBieSB0aGUgZ2l2ZW4gYW1vdW50IHRvIHRoaXMgbWF0cml4IFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdHJhbnNsYXRlWShfeTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuZGF0YVs3XSArPSBfeTtcclxuICAgICAgdGhpcy5tdXRhdG9yID0gbnVsbDtcclxuICAgICAgdGhpcy52ZWN0b3JzLnRyYW5zbGF0aW9uID0gbnVsbDtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBTY2FsaW5nXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIHNjYWxpbmcgYnkgdGhlIGdpdmVuIHZlY3RvciB0byB0aGlzIG1hdHJpeCBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNjYWxlKF9ieTogVmVjdG9yMik6IHZvaWQge1xyXG4gICAgICBjb25zdCBtYXRyaXg6IE1hdHJpeDN4MyA9IE1hdHJpeDN4My5NVUxUSVBMSUNBVElPTih0aGlzLCBNYXRyaXgzeDMuU0NBTElORyhfYnkpKTtcclxuICAgICAgdGhpcy5zZXQobWF0cml4KTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUobWF0cml4KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgc2NhbGluZyBhbG9uZyB0aGUgeC1BeGlzIGJ5IHRoZSBnaXZlbiBhbW91bnQgdG8gdGhpcyBtYXRyaXggXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzY2FsZVgoX2J5OiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgbGV0IHZlY3RvcjogVmVjdG9yMiA9IFJlY3ljbGVyLmJvcnJvdyhWZWN0b3IyKTtcclxuICAgICAgdmVjdG9yLnNldChfYnksIDEpO1xyXG4gICAgICB0aGlzLnNjYWxlKHZlY3Rvcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIHNjYWxpbmcgYWxvbmcgdGhlIHktQXhpcyBieSB0aGUgZ2l2ZW4gYW1vdW50IHRvIHRoaXMgbWF0cml4IFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2NhbGVZKF9ieTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIGxldCB2ZWN0b3I6IFZlY3RvcjIgPSBSZWN5Y2xlci5ib3Jyb3coVmVjdG9yMik7XHJcbiAgICAgIHZlY3Rvci5zZXQoMSwgX2J5KTtcclxuICAgICAgdGhpcy5zY2FsZSh2ZWN0b3IpO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG5cclxuICAgIC8vI3JlZ2lvbiBSb3RhdGlvblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgcm90YXRpb24gYXJvdW5kIHRoZSB6LUF4aXMgdG8gdGhpcyBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgcHVibGljIHJvdGF0ZShfYW5nbGVJbkRlZ3JlZXM6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICBjb25zdCBtYXRyaXg6IE1hdHJpeDN4MyA9IE1hdHJpeDN4My5NVUxUSVBMSUNBVElPTih0aGlzLCBNYXRyaXgzeDMuUk9UQVRJT04oX2FuZ2xlSW5EZWdyZWVzKSk7XHJcbiAgICAgIHRoaXMuc2V0KG1hdHJpeCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG1hdHJpeCk7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmb3JtYXRpb25cclxuICAgIC8qKlxyXG4gICAgICogTXVsdGlwbHkgdGhpcyBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBtdWx0aXBseShfbWF0cml4OiBNYXRyaXgzeDMpOiB2b2lkIHtcclxuICAgICAgdGhpcy5zZXQoTWF0cml4M3gzLk1VTFRJUExJQ0FUSU9OKHRoaXMsIF9tYXRyaXgpKTtcclxuICAgICAgdGhpcy5tdXRhdG9yID0gbnVsbDtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyBhbmQgcmV0dXJucyB0aGUgZXVsZXItYW5nbGVzIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCByb3RhdGlvbiBvZiB0aGlzIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0RXVsZXJBbmdsZXMoKTogbnVtYmVyIHtcclxuICAgICAgbGV0IHNjYWxpbmc6IFZlY3RvcjIgPSB0aGlzLnNjYWxpbmc7XHJcblxyXG4gICAgICBsZXQgczA6IG51bWJlciA9IHRoaXMuZGF0YVswXSAvIHNjYWxpbmcueDtcclxuICAgICAgbGV0IHMxOiBudW1iZXIgPSB0aGlzLmRhdGFbMV0gLyBzY2FsaW5nLng7XHJcbiAgICAgIGxldCBzMzogbnVtYmVyID0gdGhpcy5kYXRhWzNdIC8gc2NhbGluZy55O1xyXG4gICAgICBsZXQgczQ6IG51bWJlciA9IHRoaXMuZGF0YVs0XSAvIHNjYWxpbmcueTtcclxuXHJcbiAgICAgIGxldCB4U2tldzogbnVtYmVyID0gTWF0aC5hdGFuMigtczMsIHM0KTtcclxuICAgICAgbGV0IHlTa2V3OiBudW1iZXIgPSBNYXRoLmF0YW4yKHMwLCBzMSk7XHJcblxyXG4gICAgICBsZXQgc3k6IG51bWJlciA9IE1hdGguaHlwb3QoczAsIHMxKTsgLy8gcHJvYmFibHkgMi4gcGFyYW0gc2hvdWxkIGJlIHRoaXMuZGF0YVs0XSAvIHNjYWxpbmcueVxyXG4gICAgICBsZXQgcm90YXRpb246IG51bWJlcjtcclxuXHJcbiAgICAgIGlmICghKHN5ID4gMWUtNikpXHJcbiAgICAgICAgcm90YXRpb24gPSB5U2tldztcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHJvdGF0aW9uID0geFNrZXc7XHJcblxyXG4gICAgICByb3RhdGlvbiAqPSAxODAgLyBNYXRoLlBJO1xyXG5cclxuICAgICAgcmV0dXJuIHJvdGF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgZWxlbWVudHMgb2YgdGhpcyBtYXRyaXggdG8gdGhlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQoX3RvOiBNYXRyaXgzeDMpOiB2b2lkIHtcclxuICAgICAgLy8gdGhpcy5kYXRhID0gX3RvLmdldCgpO1xyXG4gICAgICB0aGlzLmRhdGEuc2V0KF90by5kYXRhKTtcclxuICAgICAgdGhpcy5yZXNldENhY2hlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiBgxpIuTWF0cml4M3gzKHRyYW5zbGF0aW9uOiAke3RoaXMudHJhbnNsYXRpb24udG9TdHJpbmcoKX0sIHJvdGF0aW9uOiAke3RoaXMucm90YXRpb24udG9TdHJpbmcoKX0sIHNjYWxpbmc6ICR7dGhpcy5zY2FsaW5nLnRvU3RyaW5nKCl9YDtcclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBlbGVtZW50cyBvZiB0aGlzIG1hdHJpeCBhcyBhIEZsb2F0MzJBcnJheVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0KCk6IEZsb2F0MzJBcnJheSB7XHJcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KHRoaXMuZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYSBjb3B5IG9mIHRoaXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBjb3B5KCk6IE1hdHJpeDN4MyB7XHJcbiAgICAgIGxldCBjb3B5OiBNYXRyaXgzeDMgPSBuZXcgTWF0cml4M3gzKCk7XHJcbiAgICAgIGNvcHkuc2V0KHRoaXMpO1xyXG4gICAgICByZXR1cm4gY29weTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICAvLyBUT0RPOiBzYXZlIHRyYW5zbGF0aW9uLCByb3RhdGlvbiBhbmQgc2NhbGUgYXMgdmVjdG9ycyBmb3IgcmVhZGFiaWxpdHkgYW5kIG1hbmlwdWxhdGlvblxyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHRoaXMuZ2V0TXV0YXRvcigpO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFNlcmlhbGl6YWJsZSB7XHJcbiAgICAgIHRoaXMubXV0YXRlKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XHJcbiAgICAgIGlmICh0aGlzLm11dGF0b3IpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMubXV0YXRvcjtcclxuXHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0ge1xyXG4gICAgICAgIHRyYW5zbGF0aW9uOiB0aGlzLnRyYW5zbGF0aW9uLmdldE11dGF0b3IoKSxcclxuICAgICAgICByb3RhdGlvbjogdGhpcy5yb3RhdGlvbixcclxuICAgICAgICBzY2FsaW5nOiB0aGlzLnNjYWxpbmcuZ2V0TXV0YXRvcigpXHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBjYWNoZSBtdXRhdG9yXHJcbiAgICAgIHRoaXMubXV0YXRvciA9IG11dGF0b3I7XHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgbGV0IG9sZFRyYW5zbGF0aW9uOiBWZWN0b3IyID0gdGhpcy50cmFuc2xhdGlvbjtcclxuICAgICAgbGV0IG9sZFJvdGF0aW9uOiBudW1iZXIgPSB0aGlzLnJvdGF0aW9uO1xyXG4gICAgICBsZXQgb2xkU2NhbGluZzogVmVjdG9yMiA9IHRoaXMuc2NhbGluZztcclxuICAgICAgbGV0IG5ld1RyYW5zbGF0aW9uOiBWZWN0b3IyID0gPFZlY3RvcjI+X211dGF0b3JbXCJ0cmFuc2xhdGlvblwiXTtcclxuICAgICAgbGV0IG5ld1JvdGF0aW9uOiBudW1iZXIgPSA8bnVtYmVyPl9tdXRhdG9yW1wicm90YXRpb25cIl07XHJcbiAgICAgIGxldCBuZXdTY2FsaW5nOiBWZWN0b3IyID0gPFZlY3RvcjI+X211dGF0b3JbXCJzY2FsaW5nXCJdO1xyXG4gICAgICBsZXQgdmVjdG9yczogVmVjdG9yUmVwcmVzZW50YXRpb24gPSB7IHRyYW5zbGF0aW9uOiBvbGRUcmFuc2xhdGlvbiwgcm90YXRpb246IG9sZFJvdGF0aW9uLCBzY2FsaW5nOiBvbGRTY2FsaW5nIH07XHJcbiAgICAgIGlmIChuZXdUcmFuc2xhdGlvbikge1xyXG4gICAgICAgIHZlY3RvcnMudHJhbnNsYXRpb24gPSBuZXcgVmVjdG9yMihcclxuICAgICAgICAgIG5ld1RyYW5zbGF0aW9uLnggIT0gdW5kZWZpbmVkID8gbmV3VHJhbnNsYXRpb24ueCA6IG9sZFRyYW5zbGF0aW9uLngsXHJcbiAgICAgICAgICBuZXdUcmFuc2xhdGlvbi55ICE9IHVuZGVmaW5lZCA/IG5ld1RyYW5zbGF0aW9uLnkgOiBvbGRUcmFuc2xhdGlvbi55XHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmVjdG9ycy5yb3RhdGlvbiA9IChuZXdSb3RhdGlvbiA9PSB1bmRlZmluZWQpID8gb2xkUm90YXRpb24gOiBuZXdSb3RhdGlvbjtcclxuXHJcbiAgICAgIGlmIChuZXdTY2FsaW5nKSB7XHJcbiAgICAgICAgdmVjdG9ycy5zY2FsaW5nID0gbmV3IFZlY3RvcjIoXHJcbiAgICAgICAgICBuZXdTY2FsaW5nLnggIT0gdW5kZWZpbmVkID8gbmV3U2NhbGluZy54IDogb2xkU2NhbGluZy54LFxyXG4gICAgICAgICAgbmV3U2NhbGluZy55ICE9IHVuZGVmaW5lZCA/IG5ld1NjYWxpbmcueSA6IG9sZFNjYWxpbmcueVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFRPRE86IHBvc3NpYmxlIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiB3aGVuIG9ubHkgb25lIG9yIHR3byBjb21wb25lbnRzIGNoYW5nZSwgdGhlbiB1c2Ugb2xkIG1hdHJpeCBpbnN0ZWFkIG9mIElERU5USVRZIGFuZCB0cmFuc2Zvcm0gYnkgZGlmZmVyZW5jZXMvcXVvdGllbnRzXHJcbiAgICAgIGxldCBtYXRyaXg6IE1hdHJpeDN4MyA9IE1hdHJpeDN4My5JREVOVElUWSgpO1xyXG4gICAgICBpZiAodmVjdG9ycy50cmFuc2xhdGlvbilcclxuICAgICAgICBtYXRyaXgudHJhbnNsYXRlKHZlY3RvcnMudHJhbnNsYXRpb24pO1xyXG4gICAgICBpZiAodmVjdG9ycy5yb3RhdGlvbikge1xyXG4gICAgICAgIG1hdHJpeC5yb3RhdGUodmVjdG9ycy5yb3RhdGlvbik7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHZlY3RvcnMuc2NhbGluZylcclxuICAgICAgICBtYXRyaXguc2NhbGUodmVjdG9ycy5zY2FsaW5nKTtcclxuICAgICAgdGhpcy5zZXQobWF0cml4KTtcclxuXHJcbiAgICAgIHRoaXMudmVjdG9ycyA9IHZlY3RvcnM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3JBdHRyaWJ1dGVUeXBlcyhfbXV0YXRvcjogTXV0YXRvcik6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyB7XHJcbiAgICAgIGxldCB0eXBlczogTXV0YXRvckF0dHJpYnV0ZVR5cGVzID0ge307XHJcbiAgICAgIGlmIChfbXV0YXRvci50cmFuc2xhdGlvbikgdHlwZXMudHJhbnNsYXRpb24gPSBcIlZlY3RvcjJcIjtcclxuICAgICAgaWYgKF9tdXRhdG9yLnJvdGF0aW9uKSB0eXBlcy5yb3RhdGlvbiA9IFwibnVtYmVyXCI7XHJcbiAgICAgIGlmIChfbXV0YXRvci5zY2FsaW5nKSB0eXBlcy5zY2FsaW5nID0gXCJWZWN0b3IyXCI7XHJcbiAgICAgIHJldHVybiB0eXBlcztcclxuICAgIH1cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7LyoqICovIH1cclxuXHJcbiAgICBwcml2YXRlIHJlc2V0Q2FjaGUoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMudmVjdG9ycyA9IHsgdHJhbnNsYXRpb246IG51bGwsIHJvdGF0aW9uOiBudWxsLCBzY2FsaW5nOiBudWxsIH07XHJcbiAgICAgIHRoaXMubXV0YXRvciA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vI2VuZHJlZ2lvblxyXG5cclxufVxyXG4iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVwcmVzZW50cyB0aGUgbWF0cml4IGFzIHRyYW5zbGF0aW9uLCByb3RhdGlvbiBhbmQgc2NhbGluZyB2ZWN0b3IsIGJlaW5nIGNhbGN1bGF0ZWQgZnJvbSB0aGUgbWF0cml4XHJcbiAgICovXHJcbiAgaW50ZXJmYWNlIFZlY3RvclJlcHJlc2VudGF0aW9uIHtcclxuICAgIHRyYW5zbGF0aW9uOiBWZWN0b3IzO1xyXG4gICAgcm90YXRpb246IFZlY3RvcjM7XHJcbiAgICBzY2FsaW5nOiBWZWN0b3IzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RvcmVzIGEgNHg0IHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBhbmQgcHJvdmlkZXMgb3BlcmF0aW9ucyBmb3IgaXQuXHJcbiAgICogYGBgcGxhaW50ZXh0XHJcbiAgICogWyAwLCAxLCAyLCAzIF0g4oaQIHJvdyB2ZWN0b3IgeFxyXG4gICAqIFsgNCwgNSwgNiwgNyBdIOKGkCByb3cgdmVjdG9yIHlcclxuICAgKiBbIDgsIDksMTAsMTEgXSDihpAgcm93IHZlY3RvciB6XHJcbiAgICogWzEyLDEzLDE0LDE1IF0g4oaQIHRyYW5zbGF0aW9uXHJcbiAgICogICAgICAgICAgICDihpEgIGhvbW9nZW5lb3VzIGNvbHVtblxyXG4gICAqIGBgYFxyXG4gICAqIEBhdXRob3JzIEphc2NoYSBLYXJhZ8O2bCwgSEZVLCAyMDE5IHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuXHJcbiAgZXhwb3J0IGNsYXNzIE1hdHJpeDR4NCBleHRlbmRzIE11dGFibGUgaW1wbGVtZW50cyBTZXJpYWxpemFibGUge1xyXG4gICAgcHJpdmF0ZSBkYXRhOiBGbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDE2KTsgLy8gVGhlIGRhdGEgb2YgdGhlIG1hdHJpeC5cclxuICAgIHByaXZhdGUgbXV0YXRvcjogTXV0YXRvciA9IG51bGw7IC8vIHByZXBhcmVkIGZvciBvcHRpbWl6YXRpb24sIGtlZXAgbXV0YXRvciB0byByZWR1Y2UgcmVkdW5kYW50IGNhbGN1bGF0aW9uIGFuZCBmb3IgY29tcGFyaXNvbi4gU2V0IHRvIG51bGwgd2hlbiBkYXRhIGNoYW5nZXMhXHJcbiAgICBwcml2YXRlIHZlY3RvcnM6IFZlY3RvclJlcHJlc2VudGF0aW9uOyAvLyB2ZWN0b3IgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBtYXRyaXhcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuZGF0YS5zZXQoW1xyXG4gICAgICAgIDEsIDAsIDAsIDAsXHJcbiAgICAgICAgMCwgMSwgMCwgMCxcclxuICAgICAgICAwLCAwLCAxLCAwLFxyXG4gICAgICAgIDAsIDAsIDAsIDFcclxuICAgICAgXSk7XHJcbiAgICAgIHRoaXMucmVzZXRDYWNoZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBcclxuICAgICAqIC0gZ2V0OiBhIGNvcHkgb2YgdGhlIGNhbGN1bGF0ZWQgdHJhbnNsYXRpb24gdmVjdG9yICAgXHJcbiAgICAgKiAtIHNldDogZWZmZWN0IHRoZSBtYXRyaXggaWdub3JpbmcgaXRzIHJvdGF0aW9uIGFuZCBzY2FsaW5nXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgdHJhbnNsYXRpb24oKTogVmVjdG9yMyB7XHJcbiAgICAgIGlmICghdGhpcy52ZWN0b3JzLnRyYW5zbGF0aW9uKSB7XHJcbiAgICAgICAgdGhpcy52ZWN0b3JzLnRyYW5zbGF0aW9uID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xyXG4gICAgICAgIHRoaXMudmVjdG9ycy50cmFuc2xhdGlvbi5zZXQodGhpcy5kYXRhWzEyXSwgdGhpcy5kYXRhWzEzXSwgdGhpcy5kYXRhWzE0XSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMudmVjdG9ycy50cmFuc2xhdGlvbi5jb3B5O1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCB0cmFuc2xhdGlvbihfdHJhbnNsYXRpb246IFZlY3RvcjMpIHtcclxuICAgICAgdGhpcy5kYXRhLnNldChfdHJhbnNsYXRpb24uZ2V0KCksIDEyKTtcclxuICAgICAgLy8gbm8gZnVsbCBjYWNoZSByZXNldCByZXF1aXJlZFxyXG4gICAgICB0aGlzLnZlY3RvcnMudHJhbnNsYXRpb24gPSBfdHJhbnNsYXRpb24uY29weTtcclxuICAgICAgdGhpcy5tdXRhdG9yID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiAtIGdldDogYSBjb3B5IG9mIHRoZSBjYWxjdWxhdGVkIHJvdGF0aW9uIHZlY3RvciAgIFxyXG4gICAgICogLSBzZXQ6IGVmZmVjdCB0aGUgbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgcm90YXRpb24oKTogVmVjdG9yMyB7XHJcbiAgICAgIGlmICghdGhpcy52ZWN0b3JzLnJvdGF0aW9uKVxyXG4gICAgICAgIHRoaXMudmVjdG9ycy5yb3RhdGlvbiA9IHRoaXMuZ2V0RXVsZXJBbmdsZXMoKTtcclxuICAgICAgcmV0dXJuIHRoaXMudmVjdG9ycy5yb3RhdGlvbi5jb3B5O1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCByb3RhdGlvbihfcm90YXRpb246IFZlY3RvcjMpIHtcclxuICAgICAgdGhpcy5tdXRhdGUoeyBcInJvdGF0aW9uXCI6IF9yb3RhdGlvbiB9KTtcclxuICAgICAgdGhpcy5yZXNldENhY2hlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogLSBnZXQ6IGEgY29weSBvZiB0aGUgY2FsY3VsYXRlZCBzY2FsZSB2ZWN0b3IgICBcclxuICAgICAqIC0gc2V0OiBlZmZlY3QgdGhlIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHNjYWxpbmcoKTogVmVjdG9yMyB7XHJcbiAgICAgIGlmICghdGhpcy52ZWN0b3JzLnNjYWxpbmcpIHtcclxuICAgICAgICB0aGlzLnZlY3RvcnMuc2NhbGluZyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgICB0aGlzLnZlY3RvcnMuc2NhbGluZy5zZXQoXHJcbiAgICAgICAgICBNYXRoLmh5cG90KHRoaXMuZGF0YVswXSwgdGhpcy5kYXRhWzFdLCB0aGlzLmRhdGFbMl0pLFxyXG4gICAgICAgICAgTWF0aC5oeXBvdCh0aGlzLmRhdGFbNF0sIHRoaXMuZGF0YVs1XSwgdGhpcy5kYXRhWzZdKSxcclxuICAgICAgICAgIE1hdGguaHlwb3QodGhpcy5kYXRhWzhdLCB0aGlzLmRhdGFbOV0sIHRoaXMuZGF0YVsxMF0pXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy52ZWN0b3JzLnNjYWxpbmcuY29weTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgc2NhbGluZyhfc2NhbGluZzogVmVjdG9yMykge1xyXG4gICAgICB0aGlzLm11dGF0ZSh7IFwic2NhbGluZ1wiOiBfc2NhbGluZyB9KTtcclxuICAgICAgdGhpcy5yZXNldENhY2hlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFNUQVRJQ1NcclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmUgYSBuZXcgaWRlbnRpdHkgbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgSURFTlRJVFkoKTogTWF0cml4NHg0IHtcclxuICAgICAgLy8gY29uc3QgcmVzdWx0OiBNYXRyaXg0eDQgPSBuZXcgTWF0cml4NHg0KCk7XHJcbiAgICAgIGNvbnN0IHJlc3VsdDogTWF0cml4NHg0ID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDR4NCk7XHJcbiAgICAgIHJlc3VsdC5kYXRhLnNldChbXHJcbiAgICAgICAgMSwgMCwgMCwgMCxcclxuICAgICAgICAwLCAxLCAwLCAwLFxyXG4gICAgICAgIDAsIDAsIDEsIDAsXHJcbiAgICAgICAgMCwgMCwgMCwgMVxyXG4gICAgICBdKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIGFuZCByZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHR3byBwYXNzZWQgbWF0cmljZXMuXHJcbiAgICAgKiBAcGFyYW0gX2EgVGhlIG1hdHJpeCB0byBtdWx0aXBseS5cclxuICAgICAqIEBwYXJhbSBfYiBUaGUgbWF0cml4IHRvIG11bHRpcGx5IGJ5LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIE1VTFRJUExJQ0FUSU9OKF9hOiBNYXRyaXg0eDQsIF9iOiBNYXRyaXg0eDQpOiBNYXRyaXg0eDQge1xyXG4gICAgICBsZXQgYTogRmxvYXQzMkFycmF5ID0gX2EuZGF0YTtcclxuICAgICAgbGV0IGI6IEZsb2F0MzJBcnJheSA9IF9iLmRhdGE7XHJcbiAgICAgIC8vIGxldCBtYXRyaXg6IE1hdHJpeDR4NCA9IG5ldyBNYXRyaXg0eDQoKTtcclxuICAgICAgY29uc3QgbWF0cml4OiBNYXRyaXg0eDQgPSBSZWN5Y2xlci5nZXQoTWF0cml4NHg0KTtcclxuICAgICAgbGV0IGEwMDogbnVtYmVyID0gYVswICogNCArIDBdO1xyXG4gICAgICBsZXQgYTAxOiBudW1iZXIgPSBhWzAgKiA0ICsgMV07XHJcbiAgICAgIGxldCBhMDI6IG51bWJlciA9IGFbMCAqIDQgKyAyXTtcclxuICAgICAgbGV0IGEwMzogbnVtYmVyID0gYVswICogNCArIDNdO1xyXG4gICAgICBsZXQgYTEwOiBudW1iZXIgPSBhWzEgKiA0ICsgMF07XHJcbiAgICAgIGxldCBhMTE6IG51bWJlciA9IGFbMSAqIDQgKyAxXTtcclxuICAgICAgbGV0IGExMjogbnVtYmVyID0gYVsxICogNCArIDJdO1xyXG4gICAgICBsZXQgYTEzOiBudW1iZXIgPSBhWzEgKiA0ICsgM107XHJcbiAgICAgIGxldCBhMjA6IG51bWJlciA9IGFbMiAqIDQgKyAwXTtcclxuICAgICAgbGV0IGEyMTogbnVtYmVyID0gYVsyICogNCArIDFdO1xyXG4gICAgICBsZXQgYTIyOiBudW1iZXIgPSBhWzIgKiA0ICsgMl07XHJcbiAgICAgIGxldCBhMjM6IG51bWJlciA9IGFbMiAqIDQgKyAzXTtcclxuICAgICAgbGV0IGEzMDogbnVtYmVyID0gYVszICogNCArIDBdO1xyXG4gICAgICBsZXQgYTMxOiBudW1iZXIgPSBhWzMgKiA0ICsgMV07XHJcbiAgICAgIGxldCBhMzI6IG51bWJlciA9IGFbMyAqIDQgKyAyXTtcclxuICAgICAgbGV0IGEzMzogbnVtYmVyID0gYVszICogNCArIDNdO1xyXG4gICAgICBsZXQgYjAwOiBudW1iZXIgPSBiWzAgKiA0ICsgMF07XHJcbiAgICAgIGxldCBiMDE6IG51bWJlciA9IGJbMCAqIDQgKyAxXTtcclxuICAgICAgbGV0IGIwMjogbnVtYmVyID0gYlswICogNCArIDJdO1xyXG4gICAgICBsZXQgYjAzOiBudW1iZXIgPSBiWzAgKiA0ICsgM107XHJcbiAgICAgIGxldCBiMTA6IG51bWJlciA9IGJbMSAqIDQgKyAwXTtcclxuICAgICAgbGV0IGIxMTogbnVtYmVyID0gYlsxICogNCArIDFdO1xyXG4gICAgICBsZXQgYjEyOiBudW1iZXIgPSBiWzEgKiA0ICsgMl07XHJcbiAgICAgIGxldCBiMTM6IG51bWJlciA9IGJbMSAqIDQgKyAzXTtcclxuICAgICAgbGV0IGIyMDogbnVtYmVyID0gYlsyICogNCArIDBdO1xyXG4gICAgICBsZXQgYjIxOiBudW1iZXIgPSBiWzIgKiA0ICsgMV07XHJcbiAgICAgIGxldCBiMjI6IG51bWJlciA9IGJbMiAqIDQgKyAyXTtcclxuICAgICAgbGV0IGIyMzogbnVtYmVyID0gYlsyICogNCArIDNdO1xyXG4gICAgICBsZXQgYjMwOiBudW1iZXIgPSBiWzMgKiA0ICsgMF07XHJcbiAgICAgIGxldCBiMzE6IG51bWJlciA9IGJbMyAqIDQgKyAxXTtcclxuICAgICAgbGV0IGIzMjogbnVtYmVyID0gYlszICogNCArIDJdO1xyXG4gICAgICBsZXQgYjMzOiBudW1iZXIgPSBiWzMgKiA0ICsgM107XHJcbiAgICAgIG1hdHJpeC5kYXRhLnNldChcclxuICAgICAgICBbXHJcbiAgICAgICAgICBiMDAgKiBhMDAgKyBiMDEgKiBhMTAgKyBiMDIgKiBhMjAgKyBiMDMgKiBhMzAsXHJcbiAgICAgICAgICBiMDAgKiBhMDEgKyBiMDEgKiBhMTEgKyBiMDIgKiBhMjEgKyBiMDMgKiBhMzEsXHJcbiAgICAgICAgICBiMDAgKiBhMDIgKyBiMDEgKiBhMTIgKyBiMDIgKiBhMjIgKyBiMDMgKiBhMzIsXHJcbiAgICAgICAgICBiMDAgKiBhMDMgKyBiMDEgKiBhMTMgKyBiMDIgKiBhMjMgKyBiMDMgKiBhMzMsXHJcbiAgICAgICAgICBiMTAgKiBhMDAgKyBiMTEgKiBhMTAgKyBiMTIgKiBhMjAgKyBiMTMgKiBhMzAsXHJcbiAgICAgICAgICBiMTAgKiBhMDEgKyBiMTEgKiBhMTEgKyBiMTIgKiBhMjEgKyBiMTMgKiBhMzEsXHJcbiAgICAgICAgICBiMTAgKiBhMDIgKyBiMTEgKiBhMTIgKyBiMTIgKiBhMjIgKyBiMTMgKiBhMzIsXHJcbiAgICAgICAgICBiMTAgKiBhMDMgKyBiMTEgKiBhMTMgKyBiMTIgKiBhMjMgKyBiMTMgKiBhMzMsXHJcbiAgICAgICAgICBiMjAgKiBhMDAgKyBiMjEgKiBhMTAgKyBiMjIgKiBhMjAgKyBiMjMgKiBhMzAsXHJcbiAgICAgICAgICBiMjAgKiBhMDEgKyBiMjEgKiBhMTEgKyBiMjIgKiBhMjEgKyBiMjMgKiBhMzEsXHJcbiAgICAgICAgICBiMjAgKiBhMDIgKyBiMjEgKiBhMTIgKyBiMjIgKiBhMjIgKyBiMjMgKiBhMzIsXHJcbiAgICAgICAgICBiMjAgKiBhMDMgKyBiMjEgKiBhMTMgKyBiMjIgKiBhMjMgKyBiMjMgKiBhMzMsXHJcbiAgICAgICAgICBiMzAgKiBhMDAgKyBiMzEgKiBhMTAgKyBiMzIgKiBhMjAgKyBiMzMgKiBhMzAsXHJcbiAgICAgICAgICBiMzAgKiBhMDEgKyBiMzEgKiBhMTEgKyBiMzIgKiBhMjEgKyBiMzMgKiBhMzEsXHJcbiAgICAgICAgICBiMzAgKiBhMDIgKyBiMzEgKiBhMTIgKyBiMzIgKiBhMjIgKyBiMzMgKiBhMzIsXHJcbiAgICAgICAgICBiMzAgKiBhMDMgKyBiMzEgKiBhMTMgKyBiMzIgKiBhMjMgKyBiMzMgKiBhMzNcclxuICAgICAgICBdKTtcclxuICAgICAgcmV0dXJuIG1hdHJpeDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIGFuZCByZXR1cm5zIHRoZSBpbnZlcnNlIG9mIGEgcGFzc2VkIG1hdHJpeC5cclxuICAgICAqIEBwYXJhbSBfbWF0cml4IFRoZSBtYXRyaXggdG8gY29tcHV0ZSB0aGUgaW52ZXJzZSBvZi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBJTlZFUlNJT04oX21hdHJpeDogTWF0cml4NHg0KTogTWF0cml4NHg0IHtcclxuICAgICAgbGV0IG06IEZsb2F0MzJBcnJheSA9IF9tYXRyaXguZGF0YTtcclxuICAgICAgbGV0IG0wMDogbnVtYmVyID0gbVswICogNCArIDBdO1xyXG4gICAgICBsZXQgbTAxOiBudW1iZXIgPSBtWzAgKiA0ICsgMV07XHJcbiAgICAgIGxldCBtMDI6IG51bWJlciA9IG1bMCAqIDQgKyAyXTtcclxuICAgICAgbGV0IG0wMzogbnVtYmVyID0gbVswICogNCArIDNdO1xyXG4gICAgICBsZXQgbTEwOiBudW1iZXIgPSBtWzEgKiA0ICsgMF07XHJcbiAgICAgIGxldCBtMTE6IG51bWJlciA9IG1bMSAqIDQgKyAxXTtcclxuICAgICAgbGV0IG0xMjogbnVtYmVyID0gbVsxICogNCArIDJdO1xyXG4gICAgICBsZXQgbTEzOiBudW1iZXIgPSBtWzEgKiA0ICsgM107XHJcbiAgICAgIGxldCBtMjA6IG51bWJlciA9IG1bMiAqIDQgKyAwXTtcclxuICAgICAgbGV0IG0yMTogbnVtYmVyID0gbVsyICogNCArIDFdO1xyXG4gICAgICBsZXQgbTIyOiBudW1iZXIgPSBtWzIgKiA0ICsgMl07XHJcbiAgICAgIGxldCBtMjM6IG51bWJlciA9IG1bMiAqIDQgKyAzXTtcclxuICAgICAgbGV0IG0zMDogbnVtYmVyID0gbVszICogNCArIDBdO1xyXG4gICAgICBsZXQgbTMxOiBudW1iZXIgPSBtWzMgKiA0ICsgMV07XHJcbiAgICAgIGxldCBtMzI6IG51bWJlciA9IG1bMyAqIDQgKyAyXTtcclxuICAgICAgbGV0IG0zMzogbnVtYmVyID0gbVszICogNCArIDNdO1xyXG4gICAgICBsZXQgdG1wMDogbnVtYmVyID0gbTIyICogbTMzO1xyXG4gICAgICBsZXQgdG1wMTogbnVtYmVyID0gbTMyICogbTIzO1xyXG4gICAgICBsZXQgdG1wMjogbnVtYmVyID0gbTEyICogbTMzO1xyXG4gICAgICBsZXQgdG1wMzogbnVtYmVyID0gbTMyICogbTEzO1xyXG4gICAgICBsZXQgdG1wNDogbnVtYmVyID0gbTEyICogbTIzO1xyXG4gICAgICBsZXQgdG1wNTogbnVtYmVyID0gbTIyICogbTEzO1xyXG4gICAgICBsZXQgdG1wNjogbnVtYmVyID0gbTAyICogbTMzO1xyXG4gICAgICBsZXQgdG1wNzogbnVtYmVyID0gbTMyICogbTAzO1xyXG4gICAgICBsZXQgdG1wODogbnVtYmVyID0gbTAyICogbTIzO1xyXG4gICAgICBsZXQgdG1wOTogbnVtYmVyID0gbTIyICogbTAzO1xyXG4gICAgICBsZXQgdG1wMTA6IG51bWJlciA9IG0wMiAqIG0xMztcclxuICAgICAgbGV0IHRtcDExOiBudW1iZXIgPSBtMTIgKiBtMDM7XHJcbiAgICAgIGxldCB0bXAxMjogbnVtYmVyID0gbTIwICogbTMxO1xyXG4gICAgICBsZXQgdG1wMTM6IG51bWJlciA9IG0zMCAqIG0yMTtcclxuICAgICAgbGV0IHRtcDE0OiBudW1iZXIgPSBtMTAgKiBtMzE7XHJcbiAgICAgIGxldCB0bXAxNTogbnVtYmVyID0gbTMwICogbTExO1xyXG4gICAgICBsZXQgdG1wMTY6IG51bWJlciA9IG0xMCAqIG0yMTtcclxuICAgICAgbGV0IHRtcDE3OiBudW1iZXIgPSBtMjAgKiBtMTE7XHJcbiAgICAgIGxldCB0bXAxODogbnVtYmVyID0gbTAwICogbTMxO1xyXG4gICAgICBsZXQgdG1wMTk6IG51bWJlciA9IG0zMCAqIG0wMTtcclxuICAgICAgbGV0IHRtcDIwOiBudW1iZXIgPSBtMDAgKiBtMjE7XHJcbiAgICAgIGxldCB0bXAyMTogbnVtYmVyID0gbTIwICogbTAxO1xyXG4gICAgICBsZXQgdG1wMjI6IG51bWJlciA9IG0wMCAqIG0xMTtcclxuICAgICAgbGV0IHRtcDIzOiBudW1iZXIgPSBtMTAgKiBtMDE7XHJcblxyXG4gICAgICBsZXQgdDA6IG51bWJlciA9ICh0bXAwICogbTExICsgdG1wMyAqIG0yMSArIHRtcDQgKiBtMzEpIC1cclxuICAgICAgICAodG1wMSAqIG0xMSArIHRtcDIgKiBtMjEgKyB0bXA1ICogbTMxKTtcclxuXHJcbiAgICAgIGxldCB0MTogbnVtYmVyID0gKHRtcDEgKiBtMDEgKyB0bXA2ICogbTIxICsgdG1wOSAqIG0zMSkgLVxyXG4gICAgICAgICh0bXAwICogbTAxICsgdG1wNyAqIG0yMSArIHRtcDggKiBtMzEpO1xyXG4gICAgICBsZXQgdDI6IG51bWJlciA9ICh0bXAyICogbTAxICsgdG1wNyAqIG0xMSArIHRtcDEwICogbTMxKSAtXHJcbiAgICAgICAgKHRtcDMgKiBtMDEgKyB0bXA2ICogbTExICsgdG1wMTEgKiBtMzEpO1xyXG4gICAgICBsZXQgdDM6IG51bWJlciA9ICh0bXA1ICogbTAxICsgdG1wOCAqIG0xMSArIHRtcDExICogbTIxKSAtXHJcbiAgICAgICAgKHRtcDQgKiBtMDEgKyB0bXA5ICogbTExICsgdG1wMTAgKiBtMjEpO1xyXG5cclxuICAgICAgbGV0IGQ6IG51bWJlciA9IDEuMCAvIChtMDAgKiB0MCArIG0xMCAqIHQxICsgbTIwICogdDIgKyBtMzAgKiB0Myk7XHJcblxyXG4gICAgICAvLyBsZXQgbWF0cml4OiBNYXRyaXg0eDQgPSBuZXcgTWF0cml4NHg0O1xyXG4gICAgICBjb25zdCBtYXRyaXg6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLmdldChNYXRyaXg0eDQpO1xyXG4gICAgICBtYXRyaXguZGF0YS5zZXQoW1xyXG4gICAgICAgIGQgKiB0MCwgLy8gWzBdXHJcbiAgICAgICAgZCAqIHQxLCAvLyBbMV1cclxuICAgICAgICBkICogdDIsIC8vIFsyXVxyXG4gICAgICAgIGQgKiB0MywgLy8gWzNdXHJcbiAgICAgICAgZCAqICgodG1wMSAqIG0xMCArIHRtcDIgKiBtMjAgKyB0bXA1ICogbTMwKSAtICh0bXAwICogbTEwICsgdG1wMyAqIG0yMCArIHRtcDQgKiBtMzApKSwgICAgICAgIC8vIFs0XVxyXG4gICAgICAgIGQgKiAoKHRtcDAgKiBtMDAgKyB0bXA3ICogbTIwICsgdG1wOCAqIG0zMCkgLSAodG1wMSAqIG0wMCArIHRtcDYgKiBtMjAgKyB0bXA5ICogbTMwKSksICAgICAgICAvLyBbNV1cclxuICAgICAgICBkICogKCh0bXAzICogbTAwICsgdG1wNiAqIG0xMCArIHRtcDExICogbTMwKSAtICh0bXAyICogbTAwICsgdG1wNyAqIG0xMCArIHRtcDEwICogbTMwKSksICAgICAgLy8gWzZdXHJcbiAgICAgICAgZCAqICgodG1wNCAqIG0wMCArIHRtcDkgKiBtMTAgKyB0bXAxMCAqIG0yMCkgLSAodG1wNSAqIG0wMCArIHRtcDggKiBtMTAgKyB0bXAxMSAqIG0yMCkpLCAgICAgIC8vIFs3XVxyXG4gICAgICAgIGQgKiAoKHRtcDEyICogbTEzICsgdG1wMTUgKiBtMjMgKyB0bXAxNiAqIG0zMykgLSAodG1wMTMgKiBtMTMgKyB0bXAxNCAqIG0yMyArIHRtcDE3ICogbTMzKSksICAvLyBbOF1cclxuICAgICAgICBkICogKCh0bXAxMyAqIG0wMyArIHRtcDE4ICogbTIzICsgdG1wMjEgKiBtMzMpIC0gKHRtcDEyICogbTAzICsgdG1wMTkgKiBtMjMgKyB0bXAyMCAqIG0zMykpLCAgLy8gWzldXHJcbiAgICAgICAgZCAqICgodG1wMTQgKiBtMDMgKyB0bXAxOSAqIG0xMyArIHRtcDIyICogbTMzKSAtICh0bXAxNSAqIG0wMyArIHRtcDE4ICogbTEzICsgdG1wMjMgKiBtMzMpKSwgIC8vIFsxMF1cclxuICAgICAgICBkICogKCh0bXAxNyAqIG0wMyArIHRtcDIwICogbTEzICsgdG1wMjMgKiBtMjMpIC0gKHRtcDE2ICogbTAzICsgdG1wMjEgKiBtMTMgKyB0bXAyMiAqIG0yMykpLCAgLy8gWzExXVxyXG4gICAgICAgIGQgKiAoKHRtcDE0ICogbTIyICsgdG1wMTcgKiBtMzIgKyB0bXAxMyAqIG0xMikgLSAodG1wMTYgKiBtMzIgKyB0bXAxMiAqIG0xMiArIHRtcDE1ICogbTIyKSksICAvLyBbMTJdXHJcbiAgICAgICAgZCAqICgodG1wMjAgKiBtMzIgKyB0bXAxMiAqIG0wMiArIHRtcDE5ICogbTIyKSAtICh0bXAxOCAqIG0yMiArIHRtcDIxICogbTMyICsgdG1wMTMgKiBtMDIpKSwgIC8vIFsxM11cclxuICAgICAgICBkICogKCh0bXAxOCAqIG0xMiArIHRtcDIzICogbTMyICsgdG1wMTUgKiBtMDIpIC0gKHRtcDIyICogbTMyICsgdG1wMTQgKiBtMDIgKyB0bXAxOSAqIG0xMikpLCAgLy8gWzE0XVxyXG4gICAgICAgIGQgKiAoKHRtcDIyICogbTIyICsgdG1wMTYgKiBtMDIgKyB0bXAyMSAqIG0xMikgLSAodG1wMjAgKiBtMTIgKyB0bXAyMyAqIG0yMiArIHRtcDE3ICogbTAyKSkgIC8vIFsxNV1cclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiBtYXRyaXg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBhbmQgcmV0dXJucyBhIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiB0cmFuc2xhdGlvbiwgaXRzIHotYXhpcyBwb2ludGluZyBkaXJlY3RseSBhdCB0aGUgZ2l2ZW4gdGFyZ2V0LFxyXG4gICAgICogYW5kIGEgbWluaW1hbCBhbmdsZSBiZXR3ZWVuIGl0cyB5LWF4aXMgYW5kIHRoZSBnaXZlbiB1cC1WZWN0b3IsIHJlc3BldGl2ZWx5IGNhbGN1bGF0aW5nIHlhdyBhbmQgcGl0Y2guXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgTE9PS19BVChfdHJhbnNsYXRpb246IFZlY3RvcjMsIF90YXJnZXQ6IFZlY3RvcjMsIF91cDogVmVjdG9yMyA9IFZlY3RvcjMuWSgpKTogTWF0cml4NHg0IHtcclxuICAgICAgLy8gY29uc3QgbWF0cml4OiBNYXRyaXg0eDQgPSBuZXcgTWF0cml4NHg0O1xyXG4gICAgICBjb25zdCBtYXRyaXg6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLmdldChNYXRyaXg0eDQpO1xyXG4gICAgICBsZXQgekF4aXM6IFZlY3RvcjMgPSBWZWN0b3IzLkRJRkZFUkVOQ0UoX3RhcmdldCwgX3RyYW5zbGF0aW9uKTtcclxuICAgICAgekF4aXMubm9ybWFsaXplKCk7XHJcbiAgICAgIGxldCB4QXhpczogVmVjdG9yMyA9IFZlY3RvcjMuTk9STUFMSVpBVElPTihWZWN0b3IzLkNST1NTKF91cCwgekF4aXMpKTtcclxuICAgICAgbGV0IHlBeGlzOiBWZWN0b3IzID0gVmVjdG9yMy5OT1JNQUxJWkFUSU9OKFZlY3RvcjMuQ1JPU1MoekF4aXMsIHhBeGlzKSk7XHJcbiAgICAgIG1hdHJpeC5kYXRhLnNldChcclxuICAgICAgICBbXHJcbiAgICAgICAgICB4QXhpcy54LCB4QXhpcy55LCB4QXhpcy56LCAwLFxyXG4gICAgICAgICAgeUF4aXMueCwgeUF4aXMueSwgeUF4aXMueiwgMCxcclxuICAgICAgICAgIHpBeGlzLngsIHpBeGlzLnksIHpBeGlzLnosIDAsXHJcbiAgICAgICAgICBfdHJhbnNsYXRpb24ueCxcclxuICAgICAgICAgIF90cmFuc2xhdGlvbi55LFxyXG4gICAgICAgICAgX3RyYW5zbGF0aW9uLnosXHJcbiAgICAgICAgICAxXHJcbiAgICAgICAgXSk7XHJcbiAgICAgIHJldHVybiBtYXRyaXg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBhbmQgcmV0dXJucyBhIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiB0cmFuc2xhdGlvbiwgaXRzIHktYXhpcyBtYXRjaGluZyB0aGUgZ2l2ZW4gdXAtdmVjdG9yXHJcbiAgICAgKiBhbmQgaXRzIHotYXhpcyBmYWNpbmcgdG93YXJkcyB0aGUgZ2l2ZW4gdGFyZ2V0IGF0IGEgbWluaW1hbCBhbmdsZSwgcmVzcGV0aXZlbHkgY2FsY3VsYXRpbmcgeWF3IG9ubHkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgU0hPV19UTyhfdHJhbnNsYXRpb246IFZlY3RvcjMsIF90YXJnZXQ6IFZlY3RvcjMsIF91cDogVmVjdG9yMyA9IFZlY3RvcjMuWSgpKTogTWF0cml4NHg0IHtcclxuICAgICAgLy8gY29uc3QgbWF0cml4OiBNYXRyaXg0eDQgPSBuZXcgTWF0cml4NHg0O1xyXG4gICAgICBjb25zdCBtYXRyaXg6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLmdldChNYXRyaXg0eDQpO1xyXG4gICAgICBsZXQgekF4aXM6IFZlY3RvcjMgPSBWZWN0b3IzLkRJRkZFUkVOQ0UoX3RhcmdldCwgX3RyYW5zbGF0aW9uKTtcclxuICAgICAgekF4aXMubm9ybWFsaXplKCk7XHJcbiAgICAgIGxldCB4QXhpczogVmVjdG9yMyA9IFZlY3RvcjMuTk9STUFMSVpBVElPTihWZWN0b3IzLkNST1NTKF91cCwgekF4aXMpKTtcclxuICAgICAgLy8gbGV0IHlBeGlzOiBWZWN0b3IzID0gVmVjdG9yMy5OT1JNQUxJWkFUSU9OKFZlY3RvcjMuQ1JPU1MoekF4aXMsIHhBeGlzKSk7XHJcbiAgICAgIHpBeGlzID0gVmVjdG9yMy5OT1JNQUxJWkFUSU9OKFZlY3RvcjMuQ1JPU1MoeEF4aXMsIF91cCkpO1xyXG4gICAgICBtYXRyaXguZGF0YS5zZXQoXHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgeEF4aXMueCwgeEF4aXMueSwgeEF4aXMueiwgMCxcclxuICAgICAgICAgIF91cC54LCBfdXAueSwgX3VwLnosIDAsXHJcbiAgICAgICAgICB6QXhpcy54LCB6QXhpcy55LCB6QXhpcy56LCAwLFxyXG4gICAgICAgICAgX3RyYW5zbGF0aW9uLngsXHJcbiAgICAgICAgICBfdHJhbnNsYXRpb24ueSxcclxuICAgICAgICAgIF90cmFuc2xhdGlvbi56LFxyXG4gICAgICAgICAgMVxyXG4gICAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gbWF0cml4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG1hdHJpeCB0aGF0IHRyYW5zbGF0ZXMgY29vcmRpbmF0ZXMgYWxvbmcgdGhlIHgtLCB5LSBhbmQgei1heGlzIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gdmVjdG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFRSQU5TTEFUSU9OKF90cmFuc2xhdGU6IFZlY3RvcjMpOiBNYXRyaXg0eDQge1xyXG4gICAgICAvLyBsZXQgbWF0cml4OiBNYXRyaXg0eDQgPSBuZXcgTWF0cml4NHg0O1xyXG4gICAgICBjb25zdCBtYXRyaXg6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLmdldChNYXRyaXg0eDQpO1xyXG4gICAgICBtYXRyaXguZGF0YS5zZXQoW1xyXG4gICAgICAgIDEsIDAsIDAsIDAsXHJcbiAgICAgICAgMCwgMSwgMCwgMCxcclxuICAgICAgICAwLCAwLCAxLCAwLFxyXG4gICAgICAgIF90cmFuc2xhdGUueCwgX3RyYW5zbGF0ZS55LCBfdHJhbnNsYXRlLnosIDFcclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiBtYXRyaXg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbWF0cml4IHRoYXQgcm90YXRlcyBjb29yZGluYXRlcyBvbiB0aGUgeC1heGlzIHdoZW4gbXVsdGlwbGllZCBieS5cclxuICAgICAqIEBwYXJhbSBfYW5nbGVJbkRlZ3JlZXMgVGhlIHZhbHVlIG9mIHRoZSByb3RhdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBST1RBVElPTl9YKF9hbmdsZUluRGVncmVlczogbnVtYmVyKTogTWF0cml4NHg0IHtcclxuICAgICAgLy8gY29uc3QgbWF0cml4OiBNYXRyaXg0eDQgPSBuZXcgTWF0cml4NHg0O1xyXG4gICAgICBjb25zdCBtYXRyaXg6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLmdldChNYXRyaXg0eDQpO1xyXG4gICAgICBsZXQgYW5nbGVJblJhZGlhbnM6IG51bWJlciA9IF9hbmdsZUluRGVncmVlcyAqIE1hdGguUEkgLyAxODA7XHJcbiAgICAgIGxldCBzaW46IG51bWJlciA9IE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKTtcclxuICAgICAgbGV0IGNvczogbnVtYmVyID0gTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpO1xyXG4gICAgICBtYXRyaXguZGF0YS5zZXQoW1xyXG4gICAgICAgIDEsIDAsIDAsIDAsXHJcbiAgICAgICAgMCwgY29zLCBzaW4sIDAsXHJcbiAgICAgICAgMCwgLXNpbiwgY29zLCAwLFxyXG4gICAgICAgIDAsIDAsIDAsIDFcclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiBtYXRyaXg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbWF0cml4IHRoYXQgcm90YXRlcyBjb29yZGluYXRlcyBvbiB0aGUgeS1heGlzIHdoZW4gbXVsdGlwbGllZCBieS5cclxuICAgICAqIEBwYXJhbSBfYW5nbGVJbkRlZ3JlZXMgVGhlIHZhbHVlIG9mIHRoZSByb3RhdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBST1RBVElPTl9ZKF9hbmdsZUluRGVncmVlczogbnVtYmVyKTogTWF0cml4NHg0IHtcclxuICAgICAgLy8gY29uc3QgbWF0cml4OiBNYXRyaXg0eDQgPSBuZXcgTWF0cml4NHg0O1xyXG4gICAgICBsZXQgbWF0cml4OiBNYXRyaXg0eDQgPSBSZWN5Y2xlci5nZXQoTWF0cml4NHg0KTtcclxuICAgICAgbGV0IGFuZ2xlSW5SYWRpYW5zOiBudW1iZXIgPSBfYW5nbGVJbkRlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwO1xyXG4gICAgICBsZXQgc2luOiBudW1iZXIgPSBNYXRoLnNpbihhbmdsZUluUmFkaWFucyk7XHJcbiAgICAgIGxldCBjb3M6IG51bWJlciA9IE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKTtcclxuICAgICAgbWF0cml4LmRhdGEuc2V0KFtcclxuICAgICAgICBjb3MsIDAsIC1zaW4sIDAsXHJcbiAgICAgICAgMCwgMSwgMCwgMCxcclxuICAgICAgICBzaW4sIDAsIGNvcywgMCxcclxuICAgICAgICAwLCAwLCAwLCAxXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gbWF0cml4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG1hdHJpeCB0aGF0IHJvdGF0ZXMgY29vcmRpbmF0ZXMgb24gdGhlIHotYXhpcyB3aGVuIG11bHRpcGxpZWQgYnkuXHJcbiAgICAgKiBAcGFyYW0gX2FuZ2xlSW5EZWdyZWVzIFRoZSB2YWx1ZSBvZiB0aGUgcm90YXRpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgUk9UQVRJT05fWihfYW5nbGVJbkRlZ3JlZXM6IG51bWJlcik6IE1hdHJpeDR4NCB7XHJcbiAgICAgIC8vIGNvbnN0IG1hdHJpeDogTWF0cml4NHg0ID0gbmV3IE1hdHJpeDR4NDtcclxuICAgICAgY29uc3QgbWF0cml4OiBNYXRyaXg0eDQgPSBSZWN5Y2xlci5nZXQoTWF0cml4NHg0KTtcclxuICAgICAgbGV0IGFuZ2xlSW5SYWRpYW5zOiBudW1iZXIgPSBfYW5nbGVJbkRlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwO1xyXG4gICAgICBsZXQgc2luOiBudW1iZXIgPSBNYXRoLnNpbihhbmdsZUluUmFkaWFucyk7XHJcbiAgICAgIGxldCBjb3M6IG51bWJlciA9IE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKTtcclxuICAgICAgbWF0cml4LmRhdGEuc2V0KFtcclxuICAgICAgICBjb3MsIHNpbiwgMCwgMCxcclxuICAgICAgICAtc2luLCBjb3MsIDAsIDAsXHJcbiAgICAgICAgMCwgMCwgMSwgMCxcclxuICAgICAgICAwLCAwLCAwLCAxXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gbWF0cml4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG1hdHJpeCB0aGF0IHNjYWxlcyBjb29yZGluYXRlcyBhbG9uZyB0aGUgeC0sIHktIGFuZCB6LWF4aXMgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBTQ0FMSU5HKF9zY2FsYXI6IFZlY3RvcjMpOiBNYXRyaXg0eDQge1xyXG4gICAgICAvLyBjb25zdCBtYXRyaXg6IE1hdHJpeDR4NCA9IG5ldyBNYXRyaXg0eDQ7XHJcbiAgICAgIGNvbnN0IG1hdHJpeDogTWF0cml4NHg0ID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDR4NCk7XHJcbiAgICAgIG1hdHJpeC5kYXRhLnNldChbXHJcbiAgICAgICAgX3NjYWxhci54LCAwLCAwLCAwLFxyXG4gICAgICAgIDAsIF9zY2FsYXIueSwgMCwgMCxcclxuICAgICAgICAwLCAwLCBfc2NhbGFyLnosIDAsXHJcbiAgICAgICAgMCwgMCwgMCwgMVxyXG4gICAgICBdKTtcclxuICAgICAgcmV0dXJuIG1hdHJpeDtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBQUk9KRUNUSU9OU1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBhbmQgcmV0dXJucyBhIG1hdHJpeCB0aGF0IGFwcGxpZXMgcGVyc3BlY3RpdmUgdG8gYW4gb2JqZWN0LCBpZiBpdHMgdHJhbnNmb3JtIGlzIG11bHRpcGxpZWQgYnkgaXQuXHJcbiAgICAgKiBAcGFyYW0gX2FzcGVjdCBUaGUgYXNwZWN0IHJhdGlvIGJldHdlZW4gd2lkdGggYW5kIGhlaWdodCBvZiBwcm9qZWN0aW9uc3BhY2UuKERlZmF1bHQgPSBjYW52YXMuY2xpZW50V2lkdGggLyBjYW52YXMuQ2xpZW50SGVpZ2h0KVxyXG4gICAgICogQHBhcmFtIF9maWVsZE9mVmlld0luRGVncmVlcyBUaGUgZmllbGQgb2YgdmlldyBpbiBEZWdyZWVzLiAoRGVmYXVsdCA9IDQ1KVxyXG4gICAgICogQHBhcmFtIF9uZWFyIFRoZSBuZWFyIGNsaXBzcGFjZSBib3JkZXIgb24gdGhlIHotYXhpcy5cclxuICAgICAqIEBwYXJhbSBfZmFyIFRoZSBmYXIgY2xpcHNwYWNlIGJvcmRlciBvbiB0aGUgei1heGlzLlxyXG4gICAgICogQHBhcmFtIF9kaXJlY3Rpb24gVGhlIHBsYW5lIG9uIHdoaWNoIHRoZSBmaWVsZE9mVmlldy1BbmdsZSBpcyBnaXZlbiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBQUk9KRUNUSU9OX0NFTlRSQUwoX2FzcGVjdDogbnVtYmVyLCBfZmllbGRPZlZpZXdJbkRlZ3JlZXM6IG51bWJlciwgX25lYXI6IG51bWJlciwgX2ZhcjogbnVtYmVyLCBfZGlyZWN0aW9uOiBGSUVMRF9PRl9WSUVXKTogTWF0cml4NHg0IHtcclxuICAgICAgLy9UT0RPOiBjYW1lcmEgbG9va3MgZG93biBuZWdhdGl2ZSB6LWRpcmVjdGlvbiwgc2hvdWxkIGJlIHBvc2l0aXZlXHJcbiAgICAgIGxldCBmaWVsZE9mVmlld0luUmFkaWFuczogbnVtYmVyID0gX2ZpZWxkT2ZWaWV3SW5EZWdyZWVzICogTWF0aC5QSSAvIDE4MDtcclxuICAgICAgbGV0IGY6IG51bWJlciA9IE1hdGgudGFuKDAuNSAqIChNYXRoLlBJIC0gZmllbGRPZlZpZXdJblJhZGlhbnMpKTtcclxuICAgICAgbGV0IHJhbmdlSW52OiBudW1iZXIgPSAxLjAgLyAoX25lYXIgLSBfZmFyKTtcclxuICAgICAgLy8gY29uc3QgbWF0cml4OiBNYXRyaXg0eDQgPSBuZXcgTWF0cml4NHg0O1xyXG4gICAgICBjb25zdCBtYXRyaXg6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLmdldChNYXRyaXg0eDQpO1xyXG4gICAgICBtYXRyaXguZGF0YS5zZXQoW1xyXG4gICAgICAgIGYsIDAsIDAsIDAsXHJcbiAgICAgICAgMCwgZiwgMCwgMCxcclxuICAgICAgICAwLCAwLCAoX25lYXIgKyBfZmFyKSAqIHJhbmdlSW52LCAtMSxcclxuICAgICAgICAwLCAwLCBfbmVhciAqIF9mYXIgKiByYW5nZUludiAqIDIsIDBcclxuICAgICAgXSk7XHJcblxyXG4gICAgICBpZiAoX2RpcmVjdGlvbiA9PSBGSUVMRF9PRl9WSUVXLkRJQUdPTkFMKSB7XHJcbiAgICAgICAgX2FzcGVjdCA9IE1hdGguc3FydChfYXNwZWN0KTtcclxuICAgICAgICBtYXRyaXguZGF0YVswXSA9IGYgLyBfYXNwZWN0O1xyXG4gICAgICAgIG1hdHJpeC5kYXRhWzVdID0gZiAqIF9hc3BlY3Q7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoX2RpcmVjdGlvbiA9PSBGSUVMRF9PRl9WSUVXLlZFUlRJQ0FMKVxyXG4gICAgICAgIG1hdHJpeC5kYXRhWzBdID0gZiAvIF9hc3BlY3Q7XHJcbiAgICAgIGVsc2UgLy9GT1ZfRElSRUNUSU9OLkhPUklaT05UQUxcclxuICAgICAgICBtYXRyaXguZGF0YVs1XSA9IGYgKiBfYXNwZWN0O1xyXG5cclxuICAgICAgLy8gSEFDSzogbWF0cml4IHNob3VsZCBsb29rIGluIHBvc2l0aXZlIHotZGlyZWN0aW9uLCBwcmVmZXJhYmx5IHRoZSBtYXRyaXggc2hvdWxkIGJlIGNhbGN1bGF0ZWQgbGlrZSB0aGF0IHJpZ2h0IGF3YXlcclxuICAgICAgbWF0cml4LnJvdGF0ZVkoMTgwKTtcclxuXHJcbiAgICAgIHJldHVybiBtYXRyaXg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBhbmQgcmV0dXJucyBhIG1hdHJpeCB0aGF0IGFwcGxpZXMgb3J0aG9ncmFwaGljIHByb2plY3Rpb24gdG8gYW4gb2JqZWN0LCBpZiBpdHMgdHJhbnNmb3JtIGlzIG11bHRpcGxpZWQgYnkgaXQuXHJcbiAgICAgKiBAcGFyYW0gX2xlZnQgVGhlIHBvc2l0aW9udmFsdWUgb2YgdGhlIHByb2plY3Rpb25zcGFjZSdzIGxlZnQgYm9yZGVyLlxyXG4gICAgICogQHBhcmFtIF9yaWdodCBUaGUgcG9zaXRpb252YWx1ZSBvZiB0aGUgcHJvamVjdGlvbnNwYWNlJ3MgcmlnaHQgYm9yZGVyLlxyXG4gICAgICogQHBhcmFtIF9ib3R0b20gVGhlIHBvc2l0aW9udmFsdWUgb2YgdGhlIHByb2plY3Rpb25zcGFjZSdzIGJvdHRvbSBib3JkZXIuXHJcbiAgICAgKiBAcGFyYW0gX3RvcCBUaGUgcG9zaXRpb252YWx1ZSBvZiB0aGUgcHJvamVjdGlvbnNwYWNlJ3MgdG9wIGJvcmRlci5cclxuICAgICAqIEBwYXJhbSBfbmVhciBUaGUgcG9zaXRpb252YWx1ZSBvZiB0aGUgcHJvamVjdGlvbnNwYWNlJ3MgbmVhciBib3JkZXIuXHJcbiAgICAgKiBAcGFyYW0gX2ZhciBUaGUgcG9zaXRpb252YWx1ZSBvZiB0aGUgcHJvamVjdGlvbnNwYWNlJ3MgZmFyIGJvcmRlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFBST0pFQ1RJT05fT1JUSE9HUkFQSElDKF9sZWZ0OiBudW1iZXIsIF9yaWdodDogbnVtYmVyLCBfYm90dG9tOiBudW1iZXIsIF90b3A6IG51bWJlciwgX25lYXI6IG51bWJlciA9IC00MDAsIF9mYXI6IG51bWJlciA9IDQwMCk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIC8vIGNvbnN0IG1hdHJpeDogTWF0cml4NHg0ID0gbmV3IE1hdHJpeDR4NDtcclxuICAgICAgY29uc3QgbWF0cml4OiBNYXRyaXg0eDQgPSBSZWN5Y2xlci5nZXQoTWF0cml4NHg0KTtcclxuICAgICAgbWF0cml4LmRhdGEuc2V0KFtcclxuICAgICAgICAyIC8gKF9yaWdodCAtIF9sZWZ0KSwgMCwgMCwgMCxcclxuICAgICAgICAwLCAyIC8gKF90b3AgLSBfYm90dG9tKSwgMCwgMCxcclxuICAgICAgICAwLCAwLCAyIC8gKF9uZWFyIC0gX2ZhciksIDAsXHJcbiAgICAgICAgKF9sZWZ0ICsgX3JpZ2h0KSAvIChfbGVmdCAtIF9yaWdodCksXHJcbiAgICAgICAgKF9ib3R0b20gKyBfdG9wKSAvIChfYm90dG9tIC0gX3RvcCksXHJcbiAgICAgICAgKF9uZWFyICsgX2ZhcikgLyAoX25lYXIgLSBfZmFyKSxcclxuICAgICAgICAxXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gbWF0cml4O1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIFJvdGF0aW9uXHJcbiAgICAvKipcclxuICAgICAqIFJvdGF0ZSB0aGlzIG1hdHJpeCBieSBnaXZlbiB2ZWN0b3IgaW4gdGhlIG9yZGVyIFosIFksIFguIFJpZ2h0IGhhbmQgcm90YXRpb24gaXMgdXNlZCwgdGh1bWIgcG9pbnRzIGluIGF4aXMgZGlyZWN0aW9uLCBmaW5nZXJzIGN1cmxpbmcgaW5kaWNhdGUgcm90YXRpb25cclxuICAgICAqIEBwYXJhbSBfYnkgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByb3RhdGUoX2J5OiBWZWN0b3IzLCBfZnJvbUxlZnQ6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xyXG4gICAgICB0aGlzLnJvdGF0ZVooX2J5LnosIF9mcm9tTGVmdCk7XHJcbiAgICAgIHRoaXMucm90YXRlWShfYnkueSwgX2Zyb21MZWZ0KTtcclxuICAgICAgdGhpcy5yb3RhdGVYKF9ieS54LCBfZnJvbUxlZnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHJvdGF0aW9uIGFyb3VuZCB0aGUgeC1heGlzIHRvIHRoaXMgbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByb3RhdGVYKF9hbmdsZUluRGVncmVlczogbnVtYmVyLCBfZnJvbUxlZnQ6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xyXG4gICAgICBsZXQgcm90YXRpb246IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5ST1RBVElPTl9YKF9hbmdsZUluRGVncmVlcyk7XHJcbiAgICAgIHRoaXMubXVsdGlwbHkocm90YXRpb24sIF9mcm9tTGVmdCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKHJvdGF0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSByb3RhdGlvbiBhcm91bmQgdGhlIHktYXhpcyB0byB0aGlzIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcm90YXRlWShfYW5nbGVJbkRlZ3JlZXM6IG51bWJlciwgX2Zyb21MZWZ0OiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcclxuICAgICAgbGV0IHJvdGF0aW9uOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuUk9UQVRJT05fWShfYW5nbGVJbkRlZ3JlZXMpO1xyXG4gICAgICB0aGlzLm11bHRpcGx5KHJvdGF0aW9uLCBfZnJvbUxlZnQpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShyb3RhdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgcm90YXRpb24gYXJvdW5kIHRoZSB6LWF4aXMgdG8gdGhpcyBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgcHVibGljIHJvdGF0ZVooX2FuZ2xlSW5EZWdyZWVzOiBudW1iZXIsIF9mcm9tTGVmdDogYm9vbGVhbiA9IGZhbHNlKTogdm9pZCB7XHJcbiAgICAgIGxldCByb3RhdGlvbjogTWF0cml4NHg0ID0gTWF0cml4NHg0LlJPVEFUSU9OX1ooX2FuZ2xlSW5EZWdyZWVzKTtcclxuICAgICAgdGhpcy5tdWx0aXBseShyb3RhdGlvbiwgX2Zyb21MZWZ0KTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUocm90YXRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRqdXN0cyB0aGUgcm90YXRpb24gb2YgdGhpcyBtYXRyaXggdG8gcG9pbnQgdGhlIHktYXhpcyBkaXJlY3RseSBhdCB0aGUgZ2l2ZW4gdGFyZ2V0IGFuZCB0aWx0cyBpdCB0byBhY2NvcmQgd2l0aCB0aGUgZ2l2ZW4gdXAgdmVjdG9yLFxyXG4gICAgICogcmVzcGVjdGl2ZWx5IGNhbGN1bGF0aW5nIHlhdyBhbmQgcGl0Y2guIElmIG5vIHVwIHZlY3RvciBpcyBnaXZlbiwgdGhlIHByZXZpb3VzIHVwLXZlY3RvciBpcyB1c2VkLiBcclxuICAgICAqIFdoZW4gX3ByZXNlcnZlU2NhbGluZyBpcyBmYWxzZSwgYSByb3RhdGVkIGlkZW50aXR5IG1hdHJpeCBpcyB0aGUgcmVzdWx0LiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGxvb2tBdChfdGFyZ2V0OiBWZWN0b3IzLCBfdXA/OiBWZWN0b3IzLCBfcHJlc2VydmVTY2FsaW5nOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xyXG4gICAgICBpZiAoIV91cClcclxuICAgICAgICBfdXAgPSB0aGlzLmdldFkoKTtcclxuXHJcbiAgICAgIGNvbnN0IG1hdHJpeDogTWF0cml4NHg0ID0gTWF0cml4NHg0LkxPT0tfQVQodGhpcy50cmFuc2xhdGlvbiwgX3RhcmdldCwgX3VwKTtcclxuICAgICAgaWYgKF9wcmVzZXJ2ZVNjYWxpbmcpXHJcbiAgICAgICAgbWF0cml4LnNjYWxlKHRoaXMuc2NhbGluZyk7XHJcbiAgICAgIHRoaXMuc2V0KG1hdHJpeCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG1hdHJpeCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGp1c3RzIHRoZSByb3RhdGlvbiBvZiB0aGlzIG1hdHJpeCB0byBtYXRjaCBpdHMgeS1heGlzIHdpdGggdGhlIGdpdmVuIHVwLXZlY3RvciBhbmQgZmFjaW5nIGl0cyB6LWF4aXMgdG93YXJkIHRoZSBnaXZlbiB0YXJnZXQgYXQgbWluaW1hbCBhbmdsZSxcclxuICAgICAqIHJlc3BlY3RpdmVseSBjYWxjdWxhdGluZyB5YXcgb25seS4gSWYgbm8gdXAgdmVjdG9yIGlzIGdpdmVuLCB0aGUgcHJldmlvdXMgdXAtdmVjdG9yIGlzIHVzZWQuIFxyXG4gICAgICogV2hlbiBfcHJlc2VydmVTY2FsaW5nIGlzIGZhbHNlLCBhIHJvdGF0ZWQgaWRlbnRpdHkgbWF0cml4IGlzIHRoZSByZXN1bHQuIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2hvd1RvKF90YXJnZXQ6IFZlY3RvcjMsIF91cD86IFZlY3RvcjMsIF9wcmVzZXJ2ZVNjYWxpbmc6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XHJcbiAgICAgIGlmICghX3VwKVxyXG4gICAgICAgIF91cCA9IHRoaXMuZ2V0WSgpO1xyXG5cclxuICAgICAgY29uc3QgbWF0cml4OiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuU0hPV19UTyh0aGlzLnRyYW5zbGF0aW9uLCBfdGFyZ2V0LCBfdXApOyBcclxuICAgICAgaWYgKF9wcmVzZXJ2ZVNjYWxpbmcpXHJcbiAgICAgICAgbWF0cml4LnNjYWxlKHRoaXMuc2NhbGluZyk7XHJcbiAgICAgIHRoaXMuc2V0KG1hdHJpeCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG1hdHJpeCk7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNsYXRpb25cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgdHJhbnNsYXRpb24gYnkgdGhlIGdpdmVuIHZlY3RvciB0byB0aGlzIG1hdHJpeCBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHRyYW5zbGF0ZShfYnk6IFZlY3RvcjMsIF9sb2NhbDogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcclxuICAgICAgaWYgKF9sb2NhbCkge1xyXG4gICAgICAgIGxldCB0cmFuc2xhdGlvbjogTWF0cml4NHg0ID0gTWF0cml4NHg0LlRSQU5TTEFUSU9OKF9ieSk7XHJcbiAgICAgICAgdGhpcy5tdWx0aXBseSh0cmFuc2xhdGlvbik7XHJcbiAgICAgICAgUmVjeWNsZXIuc3RvcmUodHJhbnNsYXRpb24pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuZGF0YVsxMl0gKz0gX2J5Lng7XHJcbiAgICAgICAgdGhpcy5kYXRhWzEzXSArPSBfYnkueTtcclxuICAgICAgICB0aGlzLmRhdGFbMTRdICs9IF9ieS56O1xyXG4gICAgICAgIHRoaXMubXV0YXRvciA9IG51bGw7XHJcbiAgICAgICAgaWYgKHRoaXMudmVjdG9ycy50cmFuc2xhdGlvbilcclxuICAgICAgICAgIFJlY3ljbGVyLnN0b3JlKHRoaXMudmVjdG9ycy50cmFuc2xhdGlvbik7XHJcbiAgICAgICAgdGhpcy52ZWN0b3JzLnRyYW5zbGF0aW9uID0gbnVsbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gY29uc3QgbWF0cml4OiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuTVVMVElQTElDQVRJT04odGhpcywgTWF0cml4NHg0LlRSQU5TTEFUSU9OKF9ieSkpO1xyXG4gICAgICAvLyAvLyBUT0RPOiBwb3NzaWJsZSBvcHRpbWl6YXRpb24sIHRyYW5zbGF0aW9uIG1heSBhbHRlciBtdXRhdG9yIGluc3RlYWQgb2YgZGVsZXRpbmcgaXQuXHJcbiAgICAgIC8vIHRoaXMuc2V0KG1hdHJpeCk7XHJcbiAgICAgIC8vIFJlY3ljbGVyLnN0b3JlKG1hdHJpeCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSB0cmFuc2xhdGlvbiBhbG9uZyB0aGUgeC1heGlzIGJ5IHRoZSBnaXZlbiBhbW91bnQgdG8gdGhpcyBtYXRyaXggXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0cmFuc2xhdGVYKF94OiBudW1iZXIsIF9sb2NhbDogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcclxuICAgICAgbGV0IHRyYW5zbGF0aW9uOiBWZWN0b3IzID0gVmVjdG9yMy5YKF94KTtcclxuICAgICAgdGhpcy50cmFuc2xhdGUodHJhbnNsYXRpb24sIF9sb2NhbCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKHRyYW5zbGF0aW9uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgdHJhbnNsYXRpb24gYWxvbmcgdGhlIHktYXhpcyBieSB0aGUgZ2l2ZW4gYW1vdW50IHRvIHRoaXMgbWF0cml4IFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdHJhbnNsYXRlWShfeTogbnVtYmVyLCBfbG9jYWw6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XHJcbiAgICAgIGxldCB0cmFuc2xhdGlvbjogVmVjdG9yMyA9IFZlY3RvcjMuWShfeSk7XHJcbiAgICAgIHRoaXMudHJhbnNsYXRlKHRyYW5zbGF0aW9uLCBfbG9jYWwpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZSh0cmFuc2xhdGlvbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIHRyYW5zbGF0aW9uIGFsb25nIHRoZSB6LWF4aXMgYnkgdGhlIGdpdmVuIGFtb3VudCB0byB0aGlzIG1hdHJpeCBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHRyYW5zbGF0ZVooX3o6IG51bWJlciwgX2xvY2FsOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xyXG4gICAgICBsZXQgdHJhbnNsYXRpb246IFZlY3RvcjMgPSBWZWN0b3IzLlooX3opO1xyXG4gICAgICB0aGlzLnRyYW5zbGF0ZSh0cmFuc2xhdGlvbiwgX2xvY2FsKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUodHJhbnNsYXRpb24pO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIFNjYWxpbmdcclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgc2NhbGluZyBieSB0aGUgZ2l2ZW4gdmVjdG9yIHRvIHRoaXMgbWF0cml4IFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2NhbGUoX2J5OiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIGNvbnN0IG1hdHJpeDogTWF0cml4NHg0ID0gTWF0cml4NHg0Lk1VTFRJUExJQ0FUSU9OKHRoaXMsIE1hdHJpeDR4NC5TQ0FMSU5HKF9ieSkpO1xyXG4gICAgICB0aGlzLnNldChtYXRyaXgpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShtYXRyaXgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgc2NhbGluZyBhbG9uZyB0aGUgeC1heGlzIGJ5IHRoZSBnaXZlbiBhbW91bnQgdG8gdGhpcyBtYXRyaXggXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzY2FsZVgoX2J5OiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgbGV0IHZlY3RvcjogVmVjdG9yMyA9IFJlY3ljbGVyLmJvcnJvdyhWZWN0b3IzKTtcclxuICAgICAgdmVjdG9yLnNldChfYnksIDEsIDEpO1xyXG4gICAgICB0aGlzLnNjYWxlKHZlY3Rvcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIHNjYWxpbmcgYWxvbmcgdGhlIHktYXhpcyBieSB0aGUgZ2l2ZW4gYW1vdW50IHRvIHRoaXMgbWF0cml4IFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2NhbGVZKF9ieTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIGxldCB2ZWN0b3I6IFZlY3RvcjMgPSBSZWN5Y2xlci5ib3Jyb3coVmVjdG9yMyk7XHJcbiAgICAgIHZlY3Rvci5zZXQoMSwgX2J5LCAxKTtcclxuICAgICAgdGhpcy5zY2FsZSh2ZWN0b3IpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSBzY2FsaW5nIGFsb25nIHRoZSB6LWF4aXMgYnkgdGhlIGdpdmVuIGFtb3VudCB0byB0aGlzIG1hdHJpeCBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNjYWxlWihfYnk6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICBsZXQgdmVjdG9yOiBWZWN0b3IzID0gUmVjeWNsZXIuYm9ycm93KFZlY3RvcjMpO1xyXG4gICAgICB2ZWN0b3Iuc2V0KDEsIDEsIF9ieSk7XHJcbiAgICAgIHRoaXMuc2NhbGUodmVjdG9yKTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2Zvcm1hdGlvblxyXG4gICAgLyoqXHJcbiAgICAgKiBNdWx0aXBseSB0aGlzIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgcHVibGljIG11bHRpcGx5KF9tYXRyaXg6IE1hdHJpeDR4NCwgX2Zyb21MZWZ0OiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcclxuICAgICAgY29uc3QgbWF0cml4OiBNYXRyaXg0eDQgPSBfZnJvbUxlZnQgPyBNYXRyaXg0eDQuTVVMVElQTElDQVRJT04oX21hdHJpeCwgdGhpcykgOiBNYXRyaXg0eDQuTVVMVElQTElDQVRJT04odGhpcywgX21hdHJpeCk7XHJcbiAgICAgIHRoaXMuc2V0KG1hdHJpeCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG1hdHJpeCk7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyBhbmQgcmV0dXJucyB0aGUgZXVsZXItYW5nbGVzIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCByb3RhdGlvbiBvZiB0aGlzIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0RXVsZXJBbmdsZXMoKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCBzY2FsaW5nOiBWZWN0b3IzID0gdGhpcy5zY2FsaW5nO1xyXG5cclxuICAgICAgbGV0IHMwOiBudW1iZXIgPSB0aGlzLmRhdGFbMF0gLyBzY2FsaW5nLng7XHJcbiAgICAgIGxldCBzMTogbnVtYmVyID0gdGhpcy5kYXRhWzFdIC8gc2NhbGluZy54O1xyXG4gICAgICBsZXQgczI6IG51bWJlciA9IHRoaXMuZGF0YVsyXSAvIHNjYWxpbmcueDtcclxuICAgICAgbGV0IHM2OiBudW1iZXIgPSB0aGlzLmRhdGFbNl0gLyBzY2FsaW5nLnk7XHJcbiAgICAgIGxldCBzMTA6IG51bWJlciA9IHRoaXMuZGF0YVsxMF0gLyBzY2FsaW5nLno7XHJcblxyXG4gICAgICBsZXQgc3k6IG51bWJlciA9IE1hdGguaHlwb3QoczAsIHMxKTsgLy8gcHJvYmFibHkgMi4gcGFyYW0gc2hvdWxkIGJlIHRoaXMuZGF0YVs0XSAvIHNjYWxpbmcueVxyXG5cclxuICAgICAgbGV0IHNpbmd1bGFyOiBib29sZWFuID0gc3kgPCAxZS02OyAvLyBJZlxyXG5cclxuICAgICAgbGV0IHgxOiBudW1iZXIsIHkxOiBudW1iZXIsIHoxOiBudW1iZXI7XHJcbiAgICAgIGxldCB4MjogbnVtYmVyLCB5MjogbnVtYmVyLCB6MjogbnVtYmVyO1xyXG5cclxuICAgICAgaWYgKCFzaW5ndWxhcikge1xyXG4gICAgICAgIHgxID0gTWF0aC5hdGFuMihzNiwgczEwKTtcclxuICAgICAgICB5MSA9IE1hdGguYXRhbjIoLXMyLCBzeSk7XHJcbiAgICAgICAgejEgPSBNYXRoLmF0YW4yKHMxLCBzMCk7XHJcblxyXG4gICAgICAgIHgyID0gTWF0aC5hdGFuMigtczYsIC1zMTApO1xyXG4gICAgICAgIHkyID0gTWF0aC5hdGFuMigtczIsIC1zeSk7XHJcbiAgICAgICAgejIgPSBNYXRoLmF0YW4yKC1zMSwgLXMwKTtcclxuXHJcbiAgICAgICAgaWYgKE1hdGguYWJzKHgyKSArIE1hdGguYWJzKHkyKSArIE1hdGguYWJzKHoyKSA8IE1hdGguYWJzKHgxKSArIE1hdGguYWJzKHkxKSArIE1hdGguYWJzKHoxKSkge1xyXG4gICAgICAgICAgeDEgPSB4MjtcclxuICAgICAgICAgIHkxID0geTI7XHJcbiAgICAgICAgICB6MSA9IHoyO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICB4MSA9IE1hdGguYXRhbjIoLXRoaXMuZGF0YVs5XSAvIHNjYWxpbmcueiwgdGhpcy5kYXRhWzVdIC8gc2NhbGluZy55KTtcclxuICAgICAgICB5MSA9IE1hdGguYXRhbjIoLXRoaXMuZGF0YVsyXSAvIHNjYWxpbmcueCwgc3kpO1xyXG4gICAgICAgIHoxID0gMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IHJvdGF0aW9uOiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xyXG4gICAgICByb3RhdGlvbi5zZXQoeDEsIHkxLCB6MSk7XHJcbiAgICAgIHJvdGF0aW9uLnNjYWxlKDE4MCAvIE1hdGguUEkpO1xyXG5cclxuICAgICAgcmV0dXJuIHJvdGF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgZWxlbWVudHMgb2YgdGhpcyBtYXRyaXggdG8gdGhlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQoX3RvOiBNYXRyaXg0eDQpOiB2b2lkIHtcclxuICAgICAgLy8gdGhpcy5kYXRhID0gX3RvLmdldCgpO1xyXG4gICAgICB0aGlzLmRhdGEuc2V0KF90by5kYXRhKTtcclxuICAgICAgdGhpcy5yZXNldENhY2hlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiBgxpIuTWF0cml4NHg0KHRyYW5zbGF0aW9uOiAke3RoaXMudHJhbnNsYXRpb24udG9TdHJpbmcoKX0sIHJvdGF0aW9uOiAke3RoaXMucm90YXRpb24udG9TdHJpbmcoKX0sIHNjYWxpbmc6ICR7dGhpcy5zY2FsaW5nLnRvU3RyaW5nKCl9YDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgZWxlbWVudHMgb2YgdGhpcyBtYXRyaXggYXMgYSBGbG9hdDMyQXJyYXlcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCgpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGNhcmRpbmFsIHgtYXhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0WCgpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgcmVzdWx0LnNldCh0aGlzLmRhdGFbMF0sIHRoaXMuZGF0YVsxXSwgdGhpcy5kYXRhWzJdKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGNhcmRpbmFsIHktYXhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0WSgpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgcmVzdWx0LnNldCh0aGlzLmRhdGFbNF0sIHRoaXMuZGF0YVs1XSwgdGhpcy5kYXRhWzZdKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGNhcmRpbmFsIHotYXhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0WigpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgcmVzdWx0LnNldCh0aGlzLmRhdGFbOF0sIHRoaXMuZGF0YVs5XSwgdGhpcy5kYXRhWzEwXSk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTd2FwcyB0aGUgdHdvIGNhcmRpbmFsIGF4aXMgYW5kIHJldmVyc2VzIHRoZSB0aGlyZCwgZWZmZWN0aXZlbHkgcm90YXRpbmcgdGhlIHRyYW5zZm9ybSAxODAgZGVncmVlcyBhcm91bmQgb25lIGFuZCA5MCBkZWdyZWVzIGFyb3VuZCBhIHNlY29uZCBheGlzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzd2FwWFkoKTogdm9pZCB7XHJcbiAgICAgIGxldCB0ZW1wOiBudW1iZXJbXSA9IFt0aGlzLmRhdGFbMF0sIHRoaXMuZGF0YVsxXSwgdGhpcy5kYXRhWzJdXTsgLy8gc3RvcmUgeC1heGlzXHJcbiAgICAgIHRoaXMuZGF0YS5zZXQoW3RoaXMuZGF0YVs0XSwgdGhpcy5kYXRhWzVdLCB0aGlzLmRhdGFbNl1dLCAwKTsgLy8gb3ZlcndyaXRlIHgtYXhpcyB3aXRoIHktYXhpc1xyXG4gICAgICB0aGlzLmRhdGEuc2V0KHRlbXAsIDQpOyAvLyBvdmVyd3JpdGUgWSB3aXRoIHRlbXBcclxuICAgICAgdGhpcy5kYXRhLnNldChbLXRoaXMuZGF0YVs4XSwgLXRoaXMuZGF0YVs5XSwgLXRoaXMuZGF0YVsxMF1dLCA4KTsgLy8gcmV2ZXJzZSB6LWF4aXNcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3dhcHMgdGhlIHR3byBjYXJkaW5hbCBheGlzIGFuZCByZXZlcnNlcyB0aGUgdGhpcmQsIGVmZmVjdGl2ZWx5IHJvdGF0aW5nIHRoZSB0cmFuc2Zvcm0gMTgwIGRlZ3JlZXMgYXJvdW5kIG9uZSBhbmQgOTAgZGVncmVlcyBhcm91bmQgYSBzZWNvbmQgYXhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3dhcFhaKCk6IHZvaWQge1xyXG4gICAgICBsZXQgdGVtcDogbnVtYmVyW10gPSBbdGhpcy5kYXRhWzBdLCB0aGlzLmRhdGFbMV0sIHRoaXMuZGF0YVsyXV07IC8vIHN0b3JlIHgtYXhpc1xyXG4gICAgICB0aGlzLmRhdGEuc2V0KFt0aGlzLmRhdGFbOF0sIHRoaXMuZGF0YVs5XSwgdGhpcy5kYXRhWzEwXV0sIDApOyAvLyBvdmVyd3JpdGUgeC1heGlzIHdpdGggei1heGlzXHJcbiAgICAgIHRoaXMuZGF0YS5zZXQodGVtcCwgOCk7IC8vIG92ZXJ3cml0ZSBaIHdpdGggdGVtcFxyXG4gICAgICB0aGlzLmRhdGEuc2V0KFstdGhpcy5kYXRhWzRdLCAtdGhpcy5kYXRhWzVdLCAtdGhpcy5kYXRhWzZdXSwgNCk7IC8vIHJldmVyc2UgeS1heGlzXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN3YXBzIHRoZSB0d28gY2FyZGluYWwgYXhpcyBhbmQgcmV2ZXJzZXMgdGhlIHRoaXJkLCBlZmZlY3RpdmVseSByb3RhdGluZyB0aGUgdHJhbnNmb3JtIDE4MCBkZWdyZWVzIGFyb3VuZCBvbmUgYW5kIDkwIGRlZ3JlZXMgYXJvdW5kIGEgc2Vjb25kIGF4aXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN3YXBZWigpOiB2b2lkIHtcclxuICAgICAgbGV0IHRlbXA6IG51bWJlcltdID0gW3RoaXMuZGF0YVs0XSwgdGhpcy5kYXRhWzVdLCB0aGlzLmRhdGFbNl1dOyAvLyBzdG9yZSB5LWF4aXNcclxuICAgICAgdGhpcy5kYXRhLnNldChbdGhpcy5kYXRhWzhdLCB0aGlzLmRhdGFbOV0sIHRoaXMuZGF0YVsxMF1dLCA0KTsgLy8gb3ZlcndyaXRlIHktYXhpcyB3aXRoIHotYXhpc1xyXG4gICAgICB0aGlzLmRhdGEuc2V0KHRlbXAsIDgpOyAvLyBvdmVyd3JpdGUgWiB3aXRoIHRlbXBcclxuICAgICAgdGhpcy5kYXRhLnNldChbLXRoaXMuZGF0YVswXSwgLXRoaXMuZGF0YVsxXSwgLXRoaXMuZGF0YVsyXV0sIDApOyAvLyByZXZlcnNlIHgtYXhpc1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGEgY29weSBvZiB0aGlzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgY29weSgpOiBNYXRyaXg0eDQge1xyXG4gICAgICBsZXQgY29weTogTWF0cml4NHg0ID0gbmV3IE1hdHJpeDR4NCgpO1xyXG4gICAgICBjb3B5LnNldCh0aGlzKTtcclxuICAgICAgcmV0dXJuIGNvcHk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFRyYW5zbGF0aW9uVG8oX3RhcmdldDogTWF0cml4NHg0KTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCBkaWZmZXJlbmNlOiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xyXG4gICAgICBkaWZmZXJlbmNlLnNldChfdGFyZ2V0LmRhdGFbMTJdIC0gdGhpcy5kYXRhWzEyXSwgX3RhcmdldC5kYXRhWzEzXSAtIHRoaXMuZGF0YVsxM10sIF90YXJnZXQuZGF0YVsxNF0gLSB0aGlzLmRhdGFbMTRdKTtcclxuICAgICAgcmV0dXJuIGRpZmZlcmVuY2U7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgLy8gVE9ETzogc2F2ZSB0cmFuc2xhdGlvbiwgcm90YXRpb24gYW5kIHNjYWxlIGFzIHZlY3RvcnMgZm9yIHJlYWRhYmlsaXR5IGFuZCBtYW5pcHVsYXRpb25cclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB0aGlzLmdldE11dGF0b3IoKTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBTZXJpYWxpemFibGUge1xyXG4gICAgICB0aGlzLm11dGF0ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xyXG4gICAgICBpZiAodGhpcy5tdXRhdG9yKVxyXG4gICAgICAgIHJldHVybiB0aGlzLm11dGF0b3I7XHJcblxyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHtcclxuICAgICAgICB0cmFuc2xhdGlvbjogdGhpcy50cmFuc2xhdGlvbi5nZXRNdXRhdG9yKCksXHJcbiAgICAgICAgcm90YXRpb246IHRoaXMucm90YXRpb24uZ2V0TXV0YXRvcigpLFxyXG4gICAgICAgIHNjYWxpbmc6IHRoaXMuc2NhbGluZy5nZXRNdXRhdG9yKClcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIGNhY2hlIG11dGF0b3JcclxuICAgICAgdGhpcy5tdXRhdG9yID0gbXV0YXRvcjtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICBsZXQgb2xkVHJhbnNsYXRpb246IFZlY3RvcjMgPSB0aGlzLnRyYW5zbGF0aW9uO1xyXG4gICAgICBsZXQgb2xkUm90YXRpb246IFZlY3RvcjMgPSB0aGlzLnJvdGF0aW9uO1xyXG4gICAgICBsZXQgb2xkU2NhbGluZzogVmVjdG9yMyA9IHRoaXMuc2NhbGluZztcclxuICAgICAgbGV0IG5ld1RyYW5zbGF0aW9uOiBWZWN0b3IzID0gPFZlY3RvcjM+X211dGF0b3JbXCJ0cmFuc2xhdGlvblwiXTtcclxuICAgICAgbGV0IG5ld1JvdGF0aW9uOiBWZWN0b3IzID0gPFZlY3RvcjM+X211dGF0b3JbXCJyb3RhdGlvblwiXTtcclxuICAgICAgbGV0IG5ld1NjYWxpbmc6IFZlY3RvcjMgPSA8VmVjdG9yMz5fbXV0YXRvcltcInNjYWxpbmdcIl07XHJcbiAgICAgIGxldCB2ZWN0b3JzOiBWZWN0b3JSZXByZXNlbnRhdGlvbiA9IHsgdHJhbnNsYXRpb246IG9sZFRyYW5zbGF0aW9uLCByb3RhdGlvbjogb2xkUm90YXRpb24sIHNjYWxpbmc6IG9sZFNjYWxpbmcgfTtcclxuICAgICAgaWYgKG5ld1RyYW5zbGF0aW9uKSB7XHJcbiAgICAgICAgdmVjdG9ycy50cmFuc2xhdGlvbiA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgICB2ZWN0b3JzLnRyYW5zbGF0aW9uLnNldChcclxuICAgICAgICAgIG5ld1RyYW5zbGF0aW9uLnggIT0gdW5kZWZpbmVkID8gbmV3VHJhbnNsYXRpb24ueCA6IG9sZFRyYW5zbGF0aW9uLngsXHJcbiAgICAgICAgICBuZXdUcmFuc2xhdGlvbi55ICE9IHVuZGVmaW5lZCA/IG5ld1RyYW5zbGF0aW9uLnkgOiBvbGRUcmFuc2xhdGlvbi55LFxyXG4gICAgICAgICAgbmV3VHJhbnNsYXRpb24ueiAhPSB1bmRlZmluZWQgPyBuZXdUcmFuc2xhdGlvbi56IDogb2xkVHJhbnNsYXRpb24uelxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG5ld1JvdGF0aW9uKSB7XHJcbiAgICAgICAgdmVjdG9ycy5yb3RhdGlvbiA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgICB2ZWN0b3JzLnJvdGF0aW9uLnNldChcclxuICAgICAgICAgIG5ld1JvdGF0aW9uLnggIT0gdW5kZWZpbmVkID8gbmV3Um90YXRpb24ueCA6IG9sZFJvdGF0aW9uLngsXHJcbiAgICAgICAgICBuZXdSb3RhdGlvbi55ICE9IHVuZGVmaW5lZCA/IG5ld1JvdGF0aW9uLnkgOiBvbGRSb3RhdGlvbi55LFxyXG4gICAgICAgICAgbmV3Um90YXRpb24ueiAhPSB1bmRlZmluZWQgPyBuZXdSb3RhdGlvbi56IDogb2xkUm90YXRpb24uelxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG5ld1NjYWxpbmcpIHtcclxuICAgICAgICB2ZWN0b3JzLnNjYWxpbmcgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XHJcbiAgICAgICAgdmVjdG9ycy5zY2FsaW5nLnNldChcclxuICAgICAgICAgIG5ld1NjYWxpbmcueCAhPSB1bmRlZmluZWQgPyBuZXdTY2FsaW5nLnggOiBvbGRTY2FsaW5nLngsXHJcbiAgICAgICAgICBuZXdTY2FsaW5nLnkgIT0gdW5kZWZpbmVkID8gbmV3U2NhbGluZy55IDogb2xkU2NhbGluZy55LFxyXG4gICAgICAgICAgbmV3U2NhbGluZy56ICE9IHVuZGVmaW5lZCA/IG5ld1NjYWxpbmcueiA6IG9sZFNjYWxpbmcuelxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFRPRE86IHBvc3NpYmxlIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiB3aGVuIG9ubHkgb25lIG9yIHR3byBjb21wb25lbnRzIGNoYW5nZSwgdGhlbiB1c2Ugb2xkIG1hdHJpeCBpbnN0ZWFkIG9mIElERU5USVRZIGFuZCB0cmFuc2Zvcm0gYnkgZGlmZmVyZW5jZXMvcXVvdGllbnRzXHJcbiAgICAgIGxldCBtYXRyaXg6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpO1xyXG4gICAgICBpZiAodmVjdG9ycy50cmFuc2xhdGlvbilcclxuICAgICAgICBtYXRyaXgudHJhbnNsYXRlKHZlY3RvcnMudHJhbnNsYXRpb24pO1xyXG4gICAgICBpZiAodmVjdG9ycy5yb3RhdGlvbikge1xyXG4gICAgICAgIG1hdHJpeC5yb3RhdGVaKHZlY3RvcnMucm90YXRpb24ueik7XHJcbiAgICAgICAgbWF0cml4LnJvdGF0ZVkodmVjdG9ycy5yb3RhdGlvbi55KTtcclxuICAgICAgICBtYXRyaXgucm90YXRlWCh2ZWN0b3JzLnJvdGF0aW9uLngpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh2ZWN0b3JzLnNjYWxpbmcpXHJcbiAgICAgICAgbWF0cml4LnNjYWxlKHZlY3RvcnMuc2NhbGluZyk7XHJcblxyXG4gICAgICB0aGlzLnNldChtYXRyaXgpO1xyXG4gICAgICB0aGlzLnZlY3RvcnMgPSB2ZWN0b3JzO1xyXG5cclxuICAgICAgUmVjeWNsZXIuc3RvcmUobWF0cml4KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvckF0dHJpYnV0ZVR5cGVzKF9tdXRhdG9yOiBNdXRhdG9yKTogTXV0YXRvckF0dHJpYnV0ZVR5cGVzIHtcclxuICAgICAgbGV0IHR5cGVzOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMgPSB7fTtcclxuICAgICAgaWYgKF9tdXRhdG9yLnRyYW5zbGF0aW9uKSB0eXBlcy50cmFuc2xhdGlvbiA9IFwiVmVjdG9yM1wiO1xyXG4gICAgICBpZiAoX211dGF0b3Iucm90YXRpb24pIHR5cGVzLnJvdGF0aW9uID0gXCJWZWN0b3IzXCI7XHJcbiAgICAgIGlmIChfbXV0YXRvci5zY2FsaW5nKSB0eXBlcy5zY2FsaW5nID0gXCJWZWN0b3IzXCI7XHJcbiAgICAgIHJldHVybiB0eXBlcztcclxuICAgIH1cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7LyoqICovIH1cclxuXHJcbiAgICBwcml2YXRlIHJlc2V0Q2FjaGUoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMudmVjdG9ycyA9IHsgdHJhbnNsYXRpb246IG51bGwsIHJvdGF0aW9uOiBudWxsLCBzY2FsaW5nOiBudWxsIH07XHJcbiAgICAgIHRoaXMubXV0YXRvciA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vI2VuZHJlZ2lvblxyXG59XHJcbiIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIENsYXNzIGZvciBjcmVhdGluZyByYW5kb20gdmFsdWVzLCBzdXBwb3J0aW5nIEphdmFzY3JpcHQncyBNYXRoLnJhbmRvbSBhbmQgYSBkZXRlcm1pbmlzdGlnIHBzZXVkby1yYW5kb20gbnVtYmVyIGdlbmVyYXRvciAoUFJORykgXHJcbiAgICogdGhhdCBjYW4gYmUgZmVkIHdpdGggYSBzZWVkIGFuZCB0aGVuIHJldHVybnMgYSByZXByb2R1Y2FibGUgc2V0IG9mIHJhbmRvbSBudW1iZXJzIChpZiB0aGUgcHJlY2lzaW9uIG9mIEphdmFzY3JpcHQgYWxsb3dzKSBcclxuICAgKiBcclxuICAgKiBAYXV0aG9yIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFJhbmRvbSB7XHJcbiAgICBwdWJsaWMgc3RhdGljIGRlZmF1bHQ6IFJhbmRvbSA9IG5ldyBSYW5kb20oKTtcclxuICAgIHByaXZhdGUgZ2VuZXJhdGU6IEZ1bmN0aW9uID0gTWF0aC5yYW5kb207XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgW1tSYW5kb21dXS4gSWYgZGVzaXJlZCwgY3JlYXRlcyBhIFBSTkcgd2l0aCBpdCBhbmQgZmVlZHMgdGhlIGdpdmVuIHNlZWQuXHJcbiAgICAgKiBAcGFyYW0gX293bkdlbmVyYXRvclxyXG4gICAgICogQHBhcmFtIF9zZWVkIFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihfb3duR2VuZXJhdG9yOiBib29sZWFuID0gZmFsc2UsIF9zZWVkOiBudW1iZXIgPSBNYXRoLnJhbmRvbSgpKSB7XHJcbiAgICAgIGlmIChfb3duR2VuZXJhdG9yKVxyXG4gICAgICAgIHRoaXMuZ2VuZXJhdGUgPSBSYW5kb20uY3JlYXRlR2VuZXJhdG9yKF9zZWVkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBkZXJlcm1pbnN0aWMgUFJORyB3aXRoIHRoZSBnaXZlbiBzZWVkXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgY3JlYXRlR2VuZXJhdG9yKF9zZWVkOiBudW1iZXIpOiBGdW5jdGlvbiB7XHJcbiAgICAgIC8vIFRPRE86IHJlcGxhY2Ugd2l0aCByYW5kb20gbnVtYmVyIGdlbmVyYXRvciB0byBnZW5lcmF0ZSBwcmVkaWN0YWJsZSBzZXF1ZW5jZVxyXG4gICAgICByZXR1cm4gTWF0aC5yYW5kb207XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbm9ybWVkIHJhbmRvbSBudW1iZXIsIHRodXMgaW4gdGhlIHJhbmdlIG9mIFswLCAxW1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Tm9ybSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHJhbmRvbSBudW1iZXIgaW4gdGhlIHJhbmdlIG9mIGdpdmVuIFtfbWluLCBfbWF4W1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0UmFuZ2UoX21pbjogbnVtYmVyLCBfbWF4OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gX21pbiArIHRoaXMuZ2VuZXJhdGUoKSAqIChfbWF4IC0gX21pbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcmFuZG9tIGludGVnZXIgbnVtYmVyIGluIHRoZSByYW5nZSBvZiBnaXZlbiBmbG9vcmVkIFtfbWluLCBfbWF4W1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0UmFuZ2VGbG9vcmVkKF9taW46IG51bWJlciwgX21heDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy5nZXRSYW5nZShfbWluLCBfbWF4KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgb3IgZmFsc2UgcmFuZG9tbHlcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEJvb2xlYW4oKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlKCkgPCAwLjU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIC0xIG9yIDEgcmFuZG9tbHlcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFNpZ24oKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2V0Qm9vbGVhbigpID8gMSA6IC0xO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHJhbmRvbWx5IHNlbGVjdGVkIGluZGV4IGludG8gdGhlIGdpdmVuIGFycmF5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRJbmRleDxUPihfYXJyYXk6IEFycmF5PFQ+KTogbnVtYmVyIHtcclxuICAgICAgaWYgKF9hcnJheS5sZW5ndGggPiAwKVxyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFJhbmdlRmxvb3JlZCgwLCBfYXJyYXkubGVuZ3RoKTtcclxuICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhIHJhbmRvbWx5IHNlbGVjdGVkIGVsZW1lbnQgZnJvbSB0aGUgZ2l2ZW4gYXJyYXkgYW5kIHJldHVybnMgaXRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNwbGljZTxUPihfYXJyYXk6IEFycmF5PFQ+KTogVCB7XHJcbiAgICAgIHJldHVybiBfYXJyYXkuc3BsaWNlKHRoaXMuZ2V0SW5kZXgoX2FycmF5KSwgMSlbMF07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcmFuZG9tbHkgc2VsZWN0ZWQga2V5IGZyb20gdGhlIGdpdmVuIE1hcC1pbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0S2V5PFQsIFU+KF9tYXA6IE1hcDxULCBVPik6IFQge1xyXG4gICAgICBsZXQga2V5czogR2VuZXJhbCA9IEFycmF5LmZyb20oX21hcC5rZXlzKCkpO1xyXG4gICAgICByZXR1cm4ga2V5c1t0aGlzLmdldEluZGV4KGtleXMpXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSByYW5kb21seSBzZWxlY3RlZCBwcm9wZXJ0eSBuYW1lIGZyb20gdGhlIGdpdmVuIG9iamVjdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0UHJvcGVydHlOYW1lKF9vYmplY3Q6IE9iamVjdCk6IHN0cmluZyB7XHJcbiAgICAgIGxldCBrZXlzOiBzdHJpbmdbXSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKF9vYmplY3QpO1xyXG4gICAgICByZXR1cm4ga2V5c1t0aGlzLmdldEluZGV4KGtleXMpXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSByYW5kb21seSBzZWxlY3RlZCBzeW1ib2wgZnJvbSB0aGUgZ2l2ZW4gb2JqZWN0LCBpZiBzeW1ib2xzIGFyZSB1c2VkIGFzIGtleXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFByb3BlcnR5U3ltYm9sKF9vYmplY3Q6IE9iamVjdCk6IHN5bWJvbCB7XHJcbiAgICAgIGxldCBrZXlzOiBzeW1ib2xbXSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoX29iamVjdCk7XHJcbiAgICAgIHJldHVybiBrZXlzW3RoaXMuZ2V0SW5kZXgoa2V5cyldO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhbmRhcmQgW1tSYW5kb21dXS1pbnN0YW5jZSB1c2luZyBNYXRoLnJhbmRvbSgpLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBjb25zdCByYW5kb206IFJhbmRvbSA9IG5ldyBSYW5kb20oKTtcclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFN0b3JlcyBhbmQgbWFuaXB1bGF0ZXMgYSB0aHJlZWRpbWVuc2lvbmFsIHZlY3RvciBjb21wcmlzZWQgb2YgdGhlIGNvbXBvbmVudHMgeCwgeSBhbmQgelxyXG4gICAqIGBgYHBsYWludGV4dFxyXG4gICAqICAgICAgICAgICAgK3lcclxuICAgKiAgICAgICAgICAgICB8X18gK3hcclxuICAgKiAgICAgICAgICAgIC9cclxuICAgKiAgICAgICAgICAreiAgIFxyXG4gICAqIGBgYFxyXG4gICAqIEBhdXRob3JzIEphc2NoYSBLYXJhZ8O2bCwgSEZVLCAyMDE5IHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgVmVjdG9yMyBleHRlbmRzIE11dGFibGUge1xyXG4gICAgcHJpdmF0ZSBkYXRhOiBGbG9hdDMyQXJyYXk7IC8vIFRPRE86IGNoZWNrIHdoeSB0aGlzIHNob3VsZG4ndCBiZSB4LHkseiBhcyBudW1iZXJzLi4uXHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF94OiBudW1iZXIgPSAwLCBfeTogbnVtYmVyID0gMCwgX3o6IG51bWJlciA9IDApIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShbX3gsIF95LCBfel0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE86IGltcGxlbWVudCBlcXVhbHMtZnVuY3Rpb25zXHJcbiAgICBnZXQgeCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5kYXRhWzBdO1xyXG4gICAgfVxyXG4gICAgZ2V0IHkoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZGF0YVsxXTtcclxuICAgIH1cclxuICAgIGdldCB6KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmRhdGFbMl07XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IHgoX3g6IG51bWJlcikge1xyXG4gICAgICB0aGlzLmRhdGFbMF0gPSBfeDtcclxuICAgIH1cclxuICAgIHNldCB5KF95OiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5kYXRhWzFdID0gX3k7XHJcbiAgICB9XHJcbiAgICBzZXQgeihfejogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuZGF0YVsyXSA9IF96O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgZ2V0IG1hZ25pdHVkZSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gTWF0aC5oeXBvdCguLi50aGlzLmRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc3F1YXJlIG9mIHRoZSBtYWduaXR1ZGUgb2YgdGhlIHZlY3RvciB3aXRob3V0IGNhbGN1bGF0aW5nIGEgc3F1YXJlIHJvb3QuIEZhc3RlciBmb3Igc2ltcGxlIHByb3hpbWl0eSBldmFsdWF0aW9uLlxyXG4gICAgICovXHJcbiAgICBnZXQgbWFnbml0dWRlU3F1YXJlZCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gVmVjdG9yMy5ET1QodGhpcywgdGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgdmVjdG9yIHdpdGggdGhlIGdpdmVuIGxlbmd0aCBwb2ludGluZyBpbiB4LWRpcmVjdGlvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFgoX3NjYWxlOiBudW1iZXIgPSAxKTogVmVjdG9yMyB7XHJcbiAgICAgIGNvbnN0IHZlY3RvcjogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgdmVjdG9yLmRhdGEuc2V0KFtfc2NhbGUsIDAsIDBdKTtcclxuICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gbGVuZ3RoIHBvaW50aW5nIGluIHktZGlyZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgWShfc2NhbGU6IG51bWJlciA9IDEpOiBWZWN0b3IzIHtcclxuICAgICAgY29uc3QgdmVjdG9yOiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xyXG4gICAgICB2ZWN0b3IuZGF0YS5zZXQoWzAsIF9zY2FsZSwgMF0pO1xyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBsZW5ndGggcG9pbnRpbmcgaW4gei1kaXJlY3Rpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBaKF9zY2FsZTogbnVtYmVyID0gMSk6IFZlY3RvcjMge1xyXG4gICAgICBjb25zdCB2ZWN0b3I6IFZlY3RvcjMgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XHJcbiAgICAgIHZlY3Rvci5kYXRhLnNldChbMCwgMCwgX3NjYWxlXSk7XHJcbiAgICAgIHJldHVybiB2ZWN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgdmVjdG9yIHdpdGggdGhlIHZhbHVlIDAgb24gZWFjaCBheGlzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgWkVSTygpOiBWZWN0b3IzIHtcclxuICAgICAgY29uc3QgdmVjdG9yOiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xyXG4gICAgICB2ZWN0b3IuZGF0YS5zZXQoWzAsIDAsIDBdKTtcclxuICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSB2ZWN0b3Igb2YgdGhlIGdpdmVuIHNpemUgb24gZWFjaCBvZiB0aGUgdGhyZWUgYXhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIE9ORShfc2NhbGU6IG51bWJlciA9IDEpOiBWZWN0b3IzIHtcclxuICAgICAgY29uc3QgdmVjdG9yOiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xyXG4gICAgICB2ZWN0b3IuZGF0YS5zZXQoW19zY2FsZSwgX3NjYWxlLCBfc2NhbGVdKTtcclxuICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSB2ZWN0b3IgdGhyb3VnaCB0cmFuc2Zvcm1hdGlvbiBvZiB0aGUgZ2l2ZW4gdmVjdG9yIGJ5IHRoZSBnaXZlbiBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBUUkFOU0ZPUk1BVElPTihfdmVjdG9yOiBWZWN0b3IzLCBfbWF0cml4OiBNYXRyaXg0eDQsIF9pbmNsdWRlVHJhbnNsYXRpb246IGJvb2xlYW4gPSB0cnVlKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjMgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XHJcbiAgICAgIGxldCBtOiBGbG9hdDMyQXJyYXkgPSBfbWF0cml4LmdldCgpO1xyXG4gICAgICBsZXQgW3gsIHksIHpdID0gX3ZlY3Rvci5nZXQoKTtcclxuXHJcbiAgICAgIHJlc3VsdC54ID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6O1xyXG4gICAgICByZXN1bHQueSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogejtcclxuICAgICAgcmVzdWx0LnogPSBtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6O1xyXG5cclxuICAgICAgaWYgKF9pbmNsdWRlVHJhbnNsYXRpb24pIHtcclxuICAgICAgICByZXN1bHQuYWRkKF9tYXRyaXgudHJhbnNsYXRpb24pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIHZlY3RvciB3aGljaCBpcyBhIGNvcHkgb2YgdGhlIGdpdmVuIHZlY3RvciBzY2FsZWQgdG8gdGhlIGdpdmVuIGxlbmd0aFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIE5PUk1BTElaQVRJT04oX3ZlY3RvcjogVmVjdG9yMywgX2xlbmd0aDogbnVtYmVyID0gMSk6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgbWFnbml0dWRlOiBudW1iZXIgPSBfdmVjdG9yLm1hZ25pdHVkZTtcclxuICAgICAgbGV0IHZlY3RvcjogVmVjdG9yMztcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBpZiAobWFnbml0dWRlID09IDApXHJcbiAgICAgICAgICB0aHJvdyAobmV3IFJhbmdlRXJyb3IoXCJJbXBvc3NpYmxlIG5vcm1hbGl6YXRpb25cIikpO1xyXG4gICAgICAgIHZlY3RvciA9IFZlY3RvcjMuWkVSTygpO1xyXG4gICAgICAgIGxldCBmYWN0b3I6IG51bWJlciA9IF9sZW5ndGggLyBfdmVjdG9yLm1hZ25pdHVkZTtcclxuICAgICAgICB2ZWN0b3IuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoW192ZWN0b3IueCAqIGZhY3RvciwgX3ZlY3Rvci55ICogZmFjdG9yLCBfdmVjdG9yLnogKiBmYWN0b3JdKTtcclxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XHJcbiAgICAgICAgRGVidWcud2FybihfZXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB2ZWN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSByZXN1bHRpbmcgdmVjdG9yIGF0dGFpbmVkIGJ5IGFkZGl0aW9uIG9mIGFsbCBnaXZlbiB2ZWN0b3JzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFNVTSguLi5fdmVjdG9yczogVmVjdG9yM1tdKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjMgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XHJcbiAgICAgIGZvciAobGV0IHZlY3RvciBvZiBfdmVjdG9ycylcclxuICAgICAgICByZXN1bHQuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoW3Jlc3VsdC54ICsgdmVjdG9yLngsIHJlc3VsdC55ICsgdmVjdG9yLnksIHJlc3VsdC56ICsgdmVjdG9yLnpdKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgc3VidHJhY3Rpb24gb2YgdHdvIHZlY3RvcnMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgRElGRkVSRU5DRShfbWludWVuZDogVmVjdG9yMywgX3N1YnRyYWhlbmQ6IFZlY3RvcjMpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHZlY3RvcjogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgdmVjdG9yLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KFtfbWludWVuZC54IC0gX3N1YnRyYWhlbmQueCwgX21pbnVlbmQueSAtIF9zdWJ0cmFoZW5kLnksIF9taW51ZW5kLnogLSBfc3VidHJhaGVuZC56XSk7XHJcbiAgICAgIHJldHVybiB2ZWN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGdpdmVuIHZlY3RvciBzY2FsZWQgYnkgdGhlIGdpdmVuIHNjYWxpbmcgZmFjdG9yXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgU0NBTEUoX3ZlY3RvcjogVmVjdG9yMywgX3NjYWxpbmc6IG51bWJlcik6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgc2NhbGVkOiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xyXG4gICAgICBzY2FsZWQuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoW192ZWN0b3IueCAqIF9zY2FsaW5nLCBfdmVjdG9yLnkgKiBfc2NhbGluZywgX3ZlY3Rvci56ICogX3NjYWxpbmddKTtcclxuICAgICAgcmV0dXJuIHNjYWxlZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIHRoZSBjcm9zc3Byb2R1Y3Qgb2YgMiB2ZWN0b3JzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIENST1NTKF9hOiBWZWN0b3IzLCBfYjogVmVjdG9yMyk6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgdmVjdG9yOiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xyXG4gICAgICB2ZWN0b3IuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoW1xyXG4gICAgICAgIF9hLnkgKiBfYi56IC0gX2EueiAqIF9iLnksXHJcbiAgICAgICAgX2EueiAqIF9iLnggLSBfYS54ICogX2IueixcclxuICAgICAgICBfYS54ICogX2IueSAtIF9hLnkgKiBfYi54XSk7XHJcbiAgICAgIHJldHVybiB2ZWN0b3I7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIHRoZSBkb3Rwcm9kdWN0IG9mIDIgdmVjdG9ycy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBET1QoX2E6IFZlY3RvcjMsIF9iOiBWZWN0b3IzKTogbnVtYmVyIHtcclxuICAgICAgbGV0IHNjYWxhclByb2R1Y3Q6IG51bWJlciA9IF9hLnggKiBfYi54ICsgX2EueSAqIF9iLnkgKyBfYS56ICogX2IuejtcclxuICAgICAgcmV0dXJuIHNjYWxhclByb2R1Y3Q7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIGFuZCByZXR1cm5zIHRoZSByZWZsZWN0aW9uIG9mIHRoZSBpbmNvbWluZyB2ZWN0b3IgYXQgdGhlIGdpdmVuIG5vcm1hbCB2ZWN0b3IuIFRoZSBsZW5ndGggb2Ygbm9ybWFsIHNob3VsZCBiZSAxLlxyXG4gICAgICogICAgIF9fX19fX19fX19fX19fX19fX1xyXG4gICAgICogICAgICAgICAgIC98XFxcclxuICAgICAqIGluY29taW5nIC8gfCBcXCByZWZsZWN0aW9uXHJcbiAgICAgKiAgICAgICAgIC8gIHwgIFxcICAgXHJcbiAgICAgKiAgICAgICAgICBub3JtYWxcclxuICAgICAqIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFJFRkxFQ1RJT04oX2luY29taW5nOiBWZWN0b3IzLCBfbm9ybWFsOiBWZWN0b3IzKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCBkb3Q6IG51bWJlciA9IC1WZWN0b3IzLkRPVChfaW5jb21pbmcsIF9ub3JtYWwpO1xyXG4gICAgICBsZXQgcmVmbGVjdGlvbjogVmVjdG9yMyA9IFZlY3RvcjMuU1VNKF9pbmNvbWluZywgVmVjdG9yMy5TQ0FMRShfbm9ybWFsLCAyICogZG90KSk7XHJcbiAgICAgIHJldHVybiByZWZsZWN0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGl2aWRlcyB0aGUgZGl2aWRlbmQgYnkgdGhlIGRpdmlzb3IgY29tcG9uZW50IGJ5IGNvbXBvbmVudCBhbmQgcmV0dXJucyB0aGUgcmVzdWx0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgUkFUSU8oX2RpdmlkZW5kOiBWZWN0b3IzLCBfZGl2aXNvcjogVmVjdG9yMyk6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgdmVjdG9yOiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xyXG4gICAgICB2ZWN0b3IuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoW19kaXZpZGVuZC54IC8gX2Rpdmlzb3IueCwgX2RpdmlkZW5kLnkgLyBfZGl2aXNvci55LCBfZGl2aWRlbmQueiAvIF9kaXZpc29yLnpdKTtcclxuICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY29vcmRpbmF0ZXMgb2YgdGhpcyBhbmQgdGhlIGdpdmVuIHZlY3RvciBhcmUgdG8gYmUgY29uc2lkZXJlZCBpZGVudGljYWwgd2l0aGluIHRoZSBnaXZlbiB0b2xlcmFuY2VcclxuICAgICAqIFRPRE86IGV4YW1pbmUsIGlmIHRvbGVyYW5jZSBhcyBjcml0ZXJpdW0gZm9yIHRoZSBkaWZmZXJlbmNlIGlzIGFwcHJvcHJpYXRlIHdpdGggdmVyeSBsYXJnZSBjb29yZGluYXRlIHZhbHVlcyBvciBpZiBfdG9sZXJhbmNlIHNob3VsZCBiZSBtdWx0aXBsaWVkIGJ5IGNvb3JkaW5hdGUgdmFsdWVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGVxdWFscyhfY29tcGFyZTogVmVjdG9yMywgX3RvbGVyYW5jZTogbnVtYmVyID0gTnVtYmVyLkVQU0lMT04pOiBib29sZWFuIHtcclxuICAgICAgaWYgKE1hdGguYWJzKHRoaXMueCAtIF9jb21wYXJlLngpID4gX3RvbGVyYW5jZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAoTWF0aC5hYnModGhpcy55IC0gX2NvbXBhcmUueSkgPiBfdG9sZXJhbmNlKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmIChNYXRoLmFicyh0aGlzLnogLSBfY29tcGFyZS56KSA+IF90b2xlcmFuY2UpIHJldHVybiBmYWxzZTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBvc2l0aW9uIGRlc2NyaWJlZCBieSB0aGlzIGlzIHdpdGhpbiBhIGN1YmUgd2l0aCB0aGUgb3Bwb3NpdGUgY29ybmVycyAxIGFuZCAyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpc0luc2lkZUN1YmUoX2Nvcm5lcjE6IFZlY3RvcjMsIF9jb3JuZXIyOiBWZWN0b3IzKTogYm9vbGVhbiB7XHJcbiAgICAgIGxldCBkaWFnb25hbDogVmVjdG9yMyA9IFZlY3RvcjMuRElGRkVSRU5DRShfY29ybmVyMiwgX2Nvcm5lcjEpO1xyXG4gICAgICBsZXQgcmVsYXRpdmU6IFZlY3RvcjMgPSBWZWN0b3IzLkRJRkZFUkVOQ0UodGhpcywgX2Nvcm5lcjEpO1xyXG4gICAgICBsZXQgcmF0aW86IFZlY3RvcjMgPSBWZWN0b3IzLlJBVElPKHJlbGF0aXZlLCBkaWFnb25hbCk7XHJcbiAgICAgIGlmIChyYXRpby54ID4gMSB8fCByYXRpby54IDwgMClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmIChyYXRpby55ID4gMSB8fCByYXRpby55IDwgMClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmIChyYXRpby56ID4gMSB8fCByYXRpby56IDwgMClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwb3NpdGlvbiBkZXNjcmliZWQgYnkgdGhpcyBpcyB3aXRoaW4gYSBzcGhlcmUgd2l0aCB0aGUgZ2l2ZW4gY2VudGVyIGFuZCByYWRpdXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGlzSW5zaWRlU3BoZXJlKF9jZW50ZXI6IFZlY3RvcjMsIF9yYWRpdXM6IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgICBsZXQgZGlmZmVyZW5jZTogVmVjdG9yMyA9IFZlY3RvcjMuRElGRkVSRU5DRSh0aGlzLCBfY2VudGVyKTtcclxuICAgICAgcmV0dXJuIGRpZmZlcmVuY2UubWFnbml0dWRlU3F1YXJlZCA8IChfcmFkaXVzICogX3JhZGl1cyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHRoZSBnaXZlbiB2ZWN0b3IgdG8gdGhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWRkKF9hZGRlbmQ6IFZlY3RvcjMpOiB2b2lkIHtcclxuICAgICAgdGhpcy5kYXRhLnNldChbX2FkZGVuZC54ICsgdGhpcy54LCBfYWRkZW5kLnkgKyB0aGlzLnksIF9hZGRlbmQueiArIHRoaXMuel0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3VidHJhY3RzIHRoZSBnaXZlbiB2ZWN0b3IgZnJvbSB0aGlzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdWJ0cmFjdChfc3VidHJhaGVuZDogVmVjdG9yMyk6IHZvaWQge1xyXG4gICAgICB0aGlzLmRhdGEuc2V0KFt0aGlzLnggLSBfc3VidHJhaGVuZC54LCB0aGlzLnkgLSBfc3VidHJhaGVuZC55LCB0aGlzLnogLSBfc3VidHJhaGVuZC56XSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTY2FsZXMgdGhpcyB2ZWN0b3IgYnkgdGhlIGdpdmVuIHNjYWxhclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2NhbGUoX3NjYWxhcjogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuZGF0YS5zZXQoW19zY2FsYXIgKiB0aGlzLngsIF9zY2FsYXIgKiB0aGlzLnksIF9zY2FsYXIgKiB0aGlzLnpdKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE5vcm1hbGl6ZXMgdGhpcyB0byB0aGUgZ2l2ZW4gbGVuZ3RoLCAxIGJ5IGRlZmF1bHRcclxuICAgICAqL1xyXG4gICAgcHVibGljIG5vcm1hbGl6ZShfbGVuZ3RoOiBudW1iZXIgPSAxKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuZGF0YSA9IFZlY3RvcjMuTk9STUFMSVpBVElPTih0aGlzLCBfbGVuZ3RoKS5kYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyB0aGUgY29tcG9uZW50cyBvZiB0aGlzIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBudW1iZXJzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQoX3g6IG51bWJlciA9IDAsIF95OiBudW1iZXIgPSAwLCBfejogbnVtYmVyID0gMCk6IHZvaWQge1xyXG4gICAgICB0aGlzLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KFtfeCwgX3ksIF96XSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoaXMgdmVjdG9yIGFzIGEgbmV3IEZsb2F0MzJBcnJheSAoY29weSlcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCgpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBjb3B5KCk6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgY29weTogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgY29weS5kYXRhLnNldCh0aGlzLmRhdGEpO1xyXG4gICAgICByZXR1cm4gY29weTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zZm9ybXMgdGhpcyB2ZWN0b3IgYnkgdGhlIGdpdmVuIG1hdHJpeCwgaW5jbHVkaW5nIG9yIGV4bHVkaW5nIHRoZSB0cmFuc2xhdGlvbi5cclxuICAgICAqIEluY2x1ZGluZyBpcyB0aGUgZGVmYXVsdCwgZXhjbHVkaW5nIHdpbGwgb25seSByb3RhdGUgYW5kIHNjYWxlIHRoaXMgdmVjdG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdHJhbnNmb3JtKF9tYXRyaXg6IE1hdHJpeDR4NCwgX2luY2x1ZGVUcmFuc2xhdGlvbjogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcclxuICAgICAgdGhpcy5kYXRhID0gVmVjdG9yMy5UUkFOU0ZPUk1BVElPTih0aGlzLCBfbWF0cml4LCBfaW5jbHVkZVRyYW5zbGF0aW9uKS5kYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJvcHMgdGhlIHotY29tcG9uZW50IGFuZCByZXR1cm5zIGEgVmVjdG9yMiBjb25zaXN0aW5nIG9mIHRoZSB4LSBhbmQgeS1jb21wb25lbnRzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b1ZlY3RvcjIoKTogVmVjdG9yMiB7XHJcbiAgICAgIHJldHVybiBuZXcgVmVjdG9yMih0aGlzLngsIHRoaXMueSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZsZWN0cyB0aGlzIHZlY3RvciBhdCBhIGdpdmVuIG5vcm1hbC4gU2VlIFtbUkVGTEVDVElPTl1dXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZWZsZWN0KF9ub3JtYWw6IFZlY3RvcjMpOiB2b2lkIHtcclxuICAgICAgY29uc3QgcmVmbGVjdGVkOiBWZWN0b3IzID0gVmVjdG9yMy5SRUZMRUNUSU9OKHRoaXMsIF9ub3JtYWwpO1xyXG4gICAgICB0aGlzLnNldChyZWZsZWN0ZWQueCwgcmVmbGVjdGVkLnksIHJlZmxlY3RlZC56KTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUocmVmbGVjdGVkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNodWZmbGVzIHRoZSBjb21wb25lbnRzIG9mIHRoaXMgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzaHVmZmxlKCk6IHZvaWQge1xyXG4gICAgICBsZXQgYTogbnVtYmVyW10gPSBBcnJheS5mcm9tKHRoaXMuZGF0YSk7XHJcbiAgICAgIHRoaXMuc2V0KFJhbmRvbS5kZWZhdWx0LnNwbGljZShhKSwgUmFuZG9tLmRlZmF1bHQuc3BsaWNlKGEpLCBhWzBdKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBmb3JtYXR0ZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG4gICAgICBsZXQgcmVzdWx0OiBzdHJpbmcgPSBgKCR7dGhpcy54LnRvUHJlY2lzaW9uKDUpfSwgJHt0aGlzLnkudG9QcmVjaXNpb24oNSl9LCAke3RoaXMuei50b1ByZWNpc2lvbig1KX0pYDtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVzZXMgdGhlIHN0YW5kYXJkIGFycmF5Lm1hcCBmdW5jdGlvbmFsaXR5IHRvIHBlcmZvcm0gdGhlIGdpdmVuIGZ1bmN0aW9uIG9uIGFsbCBjb21wb25lbnRzIG9mIHRoaXMgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBtYXAoX2Z1bmN0aW9uOiAodmFsdWU6IG51bWJlciwgaW5kZXg6IG51bWJlciwgYXJyYXk6IEZsb2F0MzJBcnJheSkgPT4gbnVtYmVyKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCBjb3B5OiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xyXG4gICAgICBjb3B5LmRhdGEgPSB0aGlzLmRhdGEubWFwKF9mdW5jdGlvbik7XHJcbiAgICAgIHJldHVybiBjb3B5O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHtcclxuICAgICAgICB4OiB0aGlzLmRhdGFbMF0sIHk6IHRoaXMuZGF0YVsxXSwgejogdGhpcy5kYXRhWzJdXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfVxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHsvKiogKi8gfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIGFsbCBtZXNoZXMuIFxyXG4gICAqIE1lc2hlcyBwcm92aWRlIGluZGV4ZWQgdmVydGljZXMsIHRoZSBvcmRlciBvZiBpbmRpY2VzIHRvIGNyZWF0ZSB0cmlnb25zIGFuZCBub3JtYWxzLCBhbmQgdGV4dHVyZSBjb29yZGluYXRlc1xyXG4gICAqIFxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgQFJlbmRlckluamVjdG9yTWVzaC5kZWNvcmF0ZVxyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBNZXNoIGltcGxlbWVudHMgU2VyaWFsaXphYmxlUmVzb3VyY2Uge1xyXG4gICAgLyoqIHJlZmVycyBiYWNrIHRvIHRoaXMgY2xhc3MgZnJvbSBhbnkgc3ViY2xhc3MgZS5nLiBpbiBvcmRlciB0byBmaW5kIGNvbXBhdGlibGUgb3RoZXIgcmVzb3VyY2VzKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgYmFzZUNsYXNzOiB0eXBlb2YgTWVzaCA9IE1lc2g7XHJcbiAgICAvKiogbGlzdCBvZiBhbGwgdGhlIHN1YmNsYXNzZXMgZGVyaXZlZCBmcm9tIHRoaXMgY2xhc3MsIGlmIHRoZXkgcmVnaXN0ZXJlZCBwcm9wZXJseSovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IHN1YmNsYXNzZXM6IHR5cGVvZiBNZXNoW10gPSBbXTtcclxuXHJcbiAgICAvLyBUT0RPOiBjaGVjayBpZiB0aGVzZSBhcnJheXMgbXVzdCBiZSBjYWNoZWQgbGlrZSB0aGlzIG9yIGlmIGNhbGxpbmcgdGhlIG1ldGhvZHMgaXMgYmV0dGVyLlxyXG4gICAgcHVibGljIHZlcnRpY2VzOiBGbG9hdDMyQXJyYXk7XHJcbiAgICBwdWJsaWMgaW5kaWNlczogVWludDE2QXJyYXk7XHJcbiAgICBwdWJsaWMgdGV4dHVyZVVWczogRmxvYXQzMkFycmF5O1xyXG4gICAgcHVibGljIG5vcm1hbHNGYWNlOiBGbG9hdDMyQXJyYXk7XHJcblxyXG4gICAgcHVibGljIGlkUmVzb3VyY2U6IHN0cmluZyA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyQnVmZmVyczogUmVuZGVyQnVmZmVyczsgLyogZGVmaW5lZCBieSBSZW5kZXJJbmplY3RvciovXHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRCdWZmZXJTcGVjaWZpY2F0aW9uKCk6IEJ1ZmZlclNwZWNpZmljYXRpb24ge1xyXG4gICAgICByZXR1cm4geyBzaXplOiAzLCBkYXRhVHlwZTogV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GTE9BVCwgbm9ybWFsaXplOiBmYWxzZSwgc3RyaWRlOiAwLCBvZmZzZXQ6IDAgfTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHJlZ2lzdGVyU3ViY2xhc3MoX3N1YkNsYXNzOiB0eXBlb2YgTWVzaCk6IG51bWJlciB7IHJldHVybiBNZXNoLnN1YmNsYXNzZXMucHVzaChfc3ViQ2xhc3MpIC0gMTsgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgdXNlUmVuZGVyQnVmZmVycyhfc2hhZGVyOiB0eXBlb2YgU2hhZGVyLCBfd29ybGQ6IE1hdHJpeDR4NCwgX3Byb2plY3Rpb246IE1hdHJpeDR4NCwgX2lkPzogbnVtYmVyKTogdm9pZCB7LyogaW5qZWN0ZWQgYnkgUmVuZGVySW5qZWN0b3IqLyB9XHJcbiAgICBwdWJsaWMgY3JlYXRlUmVuZGVyQnVmZmVycygpOiB2b2lkIHsvKiBpbmplY3RlZCBieSBSZW5kZXJJbmplY3RvciovIH1cclxuICAgIHB1YmxpYyBkZWxldGVSZW5kZXJCdWZmZXJzKF9zaGFkZXI6IHR5cGVvZiBTaGFkZXIpOiB2b2lkIHsvKiBpbmplY3RlZCBieSBSZW5kZXJJbmplY3RvciovIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0VmVydGV4Q291bnQoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMudmVydGljZXMubGVuZ3RoIC8gTWVzaC5nZXRCdWZmZXJTcGVjaWZpY2F0aW9uKCkuc2l6ZTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBnZXRJbmRleENvdW50KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmluZGljZXMubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBjcmVhdGUoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMudmVydGljZXMgPSB0aGlzLmNyZWF0ZVZlcnRpY2VzKCk7XHJcbiAgICAgIHRoaXMuaW5kaWNlcyA9IHRoaXMuY3JlYXRlSW5kaWNlcygpO1xyXG4gICAgICB0aGlzLnRleHR1cmVVVnMgPSB0aGlzLmNyZWF0ZVRleHR1cmVVVnMoKTtcclxuICAgICAgdGhpcy5ub3JtYWxzRmFjZSA9IHRoaXMuY3JlYXRlRmFjZU5vcm1hbHMoKTtcclxuICAgICAgdGhpcy5jcmVhdGVSZW5kZXJCdWZmZXJzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2VyaWFsaXplL0Rlc2VyaWFsaXplIGZvciBhbGwgbWVzaGVzIHRoYXQgY2FsY3VsYXRlIHdpdGhvdXQgcGFyYW1ldGVyc1xyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgaWRSZXNvdXJjZTogdGhpcy5pZFJlc291cmNlXHJcbiAgICAgIH07IC8vIG5vIGRhdGEgbmVlZGVkIC4uLlxyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFNlcmlhbGl6YWJsZSB7XHJcbiAgICAgIHRoaXMuY3JlYXRlKCk7IC8vIFRPRE86IG11c3Qgbm90IGJlIGNyZWF0ZWQsIGlmIGFuIGlkZW50aWNhbCBtZXNoIGFscmVhZHkgZXhpc3RzXHJcbiAgICAgIHRoaXMuaWRSZXNvdXJjZSA9IF9zZXJpYWxpemF0aW9uLmlkUmVzb3VyY2U7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHB1YmxpYyBhYnN0cmFjdCBjcmVhdGUoKTogdm9pZDtcclxuXHJcbiAgICBwcm90ZWN0ZWQgY2FsY3VsYXRlRmFjZU5vcm1hbHMoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgbGV0IG5vcm1hbHM6IG51bWJlcltdID0gW107XHJcbiAgICAgIGxldCB2ZXJ0aWNlczogVmVjdG9yM1tdID0gW107XHJcblxyXG4gICAgICBmb3IgKGxldCB2OiBudW1iZXIgPSAwOyB2IDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IHYgKz0gMylcclxuICAgICAgICB2ZXJ0aWNlcy5wdXNoKG5ldyBWZWN0b3IzKHRoaXMudmVydGljZXNbdl0sIHRoaXMudmVydGljZXNbdiArIDFdLCB0aGlzLnZlcnRpY2VzW3YgKyAyXSkpO1xyXG5cclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMuaW5kaWNlcy5sZW5ndGg7IGkgKz0gMykge1xyXG4gICAgICAgIGxldCB2ZXJ0ZXg6IG51bWJlcltdID0gW3RoaXMuaW5kaWNlc1tpXSwgdGhpcy5pbmRpY2VzW2kgKyAxXSwgdGhpcy5pbmRpY2VzW2kgKyAyXV07XHJcblxyXG4gICAgICAgIGxldCB2MDogVmVjdG9yMyA9IFZlY3RvcjMuRElGRkVSRU5DRSh2ZXJ0aWNlc1t2ZXJ0ZXhbMF1dLCB2ZXJ0aWNlc1t2ZXJ0ZXhbMV1dKTtcclxuICAgICAgICBsZXQgdjE6IFZlY3RvcjMgPSBWZWN0b3IzLkRJRkZFUkVOQ0UodmVydGljZXNbdmVydGV4WzBdXSwgdmVydGljZXNbdmVydGV4WzJdXSk7XHJcbiAgICAgICAgbGV0IG5vcm1hbDogVmVjdG9yMyA9IFZlY3RvcjMuTk9STUFMSVpBVElPTihWZWN0b3IzLkNST1NTKHYwLCB2MSkpO1xyXG4gICAgICAgIGxldCBpbmRleDogbnVtYmVyID0gdmVydGV4WzJdICogMztcclxuICAgICAgICBub3JtYWxzW2luZGV4XSA9IG5vcm1hbC54O1xyXG4gICAgICAgIG5vcm1hbHNbaW5kZXggKyAxXSA9IG5vcm1hbC55O1xyXG4gICAgICAgIG5vcm1hbHNbaW5kZXggKyAyXSA9IG5vcm1hbC56O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KG5vcm1hbHMpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBjcmVhdGVWZXJ0aWNlcygpOiBGbG9hdDMyQXJyYXk7XHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgY3JlYXRlVGV4dHVyZVVWcygpOiBGbG9hdDMyQXJyYXk7XHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgY3JlYXRlSW5kaWNlcygpOiBVaW50MTZBcnJheTtcclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBjcmVhdGVGYWNlTm9ybWFscygpOiBGbG9hdDMyQXJyYXk7XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogR2VuZXJhdGUgYSBzaW1wbGUgY3ViZSB3aXRoIGVkZ2VzIG9mIGxlbmd0aCAxLCBlYWNoIGZhY2UgY29uc2lzdGluZyBvZiB0d28gdHJpZ29uc1xyXG4gICAqIGBgYHBsYWludGV4dFxyXG4gICAqICAgICAgICAgICAgNF9fX183XHJcbiAgICogICAgICAgICAgIDAvX18zL3xcclxuICAgKiAgICAgICAgICAgIHx8NV98fDZcclxuICAgKiAgICAgICAgICAgMXwvXzJ8LyBcclxuICAgKiBgYGBcclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBNZXNoQ3ViZSBleHRlbmRzIE1lc2gge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IE1lc2gucmVnaXN0ZXJTdWJjbGFzcyhNZXNoQ3ViZSk7XHJcbiAgIFxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLmNyZWF0ZSgpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlVmVydGljZXMoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgbGV0IHZlcnRpY2VzOiBGbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KFtcclxuICAgICAgICAgICAgICAgIC8vIEZpcnN0IHdyYXBcclxuICAgICAgICAgICAgICAgIC8vIGZyb250XHJcbiAgICAgICAgICAgICAgICAvKjAqLyAtMSwgMSwgMSwgLyoxKi8gLTEsIC0xLCAxLCAgLyoyKi8gMSwgLTEsIDEsIC8qMyovIDEsIDEsIDEsXHJcbiAgICAgICAgICAgICAgICAvLyBiYWNrXHJcbiAgICAgICAgICAgICAgICAvKjQqLyAtMSwgMSwgLTEsIC8qIDUqLyAtMSwgLTEsIC0xLCAgLyogNiovIDEsIC0xLCAtMSwgLyogNyovIDEsIDEsIC0xLFxyXG4gICAgICAgICAgICAgICAgLy8gU2Vjb25kIHdyYXBcclxuICAgICAgICAgICAgICAgIC8vIGZyb250XHJcbiAgICAgICAgICAgICAgICAvKjAqLyAtMSwgMSwgMSwgLyoxKi8gLTEsIC0xLCAxLCAgLyoyKi8gMSwgLTEsIDEsIC8qMyovIDEsIDEsIDEsXHJcbiAgICAgICAgICAgICAgICAvLyBiYWNrXHJcbiAgICAgICAgICAgICAgICAvKjQqLyAtMSwgMSwgLTEsIC8qIDUqLyAtMSwgLTEsIC0xLCAgLyogNiovIDEsIC0xLCAtMSwgLyogNyovIDEsIDEsIC0xXHJcbiAgICAgIF0pO1xyXG5cclxuICAgICAgLy8gc2NhbGUgZG93biB0byBhIGxlbmd0aCBvZiAxIGZvciBhbGwgZWRnZXNcclxuICAgICAgdmVydGljZXMgPSB2ZXJ0aWNlcy5tYXAoX3ZhbHVlID0+IF92YWx1ZSAvIDIpO1xyXG5cclxuICAgICAgcmV0dXJuIHZlcnRpY2VzO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBjcmVhdGVJbmRpY2VzKCk6IFVpbnQxNkFycmF5IHtcclxuICAgICAgbGV0IGluZGljZXM6IFVpbnQxNkFycmF5ID0gbmV3IFVpbnQxNkFycmF5KFtcclxuICAgICAgICAvLyBGaXJzdCB3cmFwXHJcbiAgICAgICAgLy8gZnJvbnRcclxuICAgICAgICAxLCAyLCAwLCAyLCAzLCAwLFxyXG4gICAgICAgIC8vIHJpZ2h0XHJcbiAgICAgICAgMiwgNiwgMywgNiwgNywgMyxcclxuICAgICAgICAvLyBiYWNrXHJcbiAgICAgICAgNiwgNSwgNywgNSwgNCwgNyxcclxuXHJcbiAgICAgICAgLy8gU2Vjb25kIHdyYXBcclxuICAgICAgICAvLyBsZWZ0XHJcbiAgICAgICAgNSArIDgsIDEgKyA4LCA0ICsgOCwgMSArIDgsIDAgKyA4LCA0ICsgOCxcclxuICAgICAgICAvLyB0b3BcclxuICAgICAgICA0ICsgOCwgMCArIDgsIDMgKyA4LCA3ICsgOCwgNCArIDgsIDMgKyA4LFxyXG4gICAgICAgIC8vIGJvdHRvbVxyXG4gICAgICAgIDUgKyA4LCA2ICsgOCwgMSArIDgsIDYgKyA4LCAyICsgOCwgMSArIDhcclxuXHJcbiAgICAgICAgLyosXHJcbiAgICAgICAgLy8gbGVmdFxyXG4gICAgICAgIDQsIDUsIDEsIDQsIDEsIDAsXHJcbiAgICAgICAgLy8gdG9wXHJcbiAgICAgICAgNCwgMCwgMywgNCwgMywgNyxcclxuICAgICAgICAvLyBib3R0b21cclxuICAgICAgICAxLCA1LCA2LCAxLCA2LCAyXHJcbiAgICAgICAgKi9cclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiBpbmRpY2VzO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBjcmVhdGVUZXh0dXJlVVZzKCk6IEZsb2F0MzJBcnJheSB7XHJcbiAgICAgIGxldCB0ZXh0dXJlVVZzOiBGbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KFtcclxuICAgICAgICAgICAgICAgIC8vIEZpcnN0IHdyYXBcclxuICAgICAgICAgICAgICAgIC8vIGZyb250XHJcbiAgICAgICAgICAgICAgICAvKjAqLyAwLCAwLCAvKjEqLyAwLCAxLCAgLyoyKi8gMSwgMSwgLyozKi8gMSwgMCxcclxuICAgICAgICAgICAgICAgIC8vIGJhY2tcclxuICAgICAgICAgICAgICAgIC8qNCovIDMsIDAsIC8qNSovIDMsIDEsICAvKjYqLyAyLCAxLCAvKjcqLyAyLCAwLFxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNlY29uZCB3cmFwXHJcbiAgICAgICAgICAgICAgICAvLyBmcm9udFxyXG4gICAgICAgICAgICAgICAgLyowKi8gMSwgMCwgLyoxKi8gMSwgMSwgIC8qMiovIDEsIDIsIC8qMyovIDEsIC0xLFxyXG4gICAgICAgICAgICAgICAgLy8gYmFja1xyXG4gICAgICAgICAgICAgICAgLyo0Ki8gMCwgMCwgLyo1Ki8gMCwgMSwgIC8qNiovIDAsIDIsIC8qNyovIDAsIC0xXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gdGV4dHVyZVVWcztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlRmFjZU5vcm1hbHMoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgbGV0IG5vcm1hbHM6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoW1xyXG4gICAgICAgICAgICAgICAgLy8gZm9yIGVhY2ggdHJpYW5nbGUsIHRoZSBsYXN0IHZlcnRleCBvZiB0aGUgdGhyZWUgZGVmaW5pbmcgcmVmZXJzIHRvIHRoZSBub3JtYWx2ZWN0b3Igd2hlbiB1c2luZyBmbGF0IHNoYWRpbmdcclxuICAgICAgICAgICAgICAgIC8vIEZpcnN0IHdyYXBcclxuICAgICAgICAgICAgICAgIC8vIGZyb250XHJcbiAgICAgICAgICAgICAgICAvKjAqLyAwLCAwLCAxLCAvKjEqLyAwLCAwLCAwLCAvKjIqLyAwLCAwLCAwLCAvKjMqLyAxLCAwLCAwLFxyXG4gICAgICAgICAgICAgICAgLy8gYmFja1xyXG4gICAgICAgICAgICAgICAgLyo0Ki8gMCwgMCwgMCwgLyo1Ki8gMCwgMCwgMCwgLyo2Ki8gMCwgMCwgMCwgLyo3Ki8gMCwgMCwgLTEsXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU2Vjb25kIHdyYXBcclxuICAgICAgICAgICAgICAgIC8vIGZyb250XHJcbiAgICAgICAgICAgICAgICAvKjAqLyAwLCAwLCAwLCAvKjEqLyAwLCAtMSwgMCwgLyoyKi8gMCwgMCwgMCwgLyozKi8gMCwgMSwgMCxcclxuICAgICAgICAgICAgICAgIC8vIGJhY2tcclxuICAgICAgICAgICAgICAgIC8qNCovIC0xLCAwLCAwLCAvKjUqLyAwLCAwLCAwLCAvKjYqLyAwLCAwLCAwLCAvKjcqLyAwLCAwLCAwXHJcbiAgICAgIF0pO1xyXG5cclxuICAgICAgLy9ub3JtYWxzID0gdGhpcy5jcmVhdGVWZXJ0aWNlcygpO1xyXG5cclxuICAgICAgcmV0dXJuIG5vcm1hbHM7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIC8qKiBUaGlzIGZ1bmN0aW9uIHR5cGUgdGFrZXMgeCBhbmQgeiBhcyBQYXJhbWV0ZXJzIGFuZCByZXR1cm5zIGEgbnVtYmVyIC0gdG8gYmUgdXNlZCBhcyBhIGhlaWdodG1hcC4gXHJcbiAgICogeCBhbmQgeiBhcmUgbWFwcGVkIGZyb20gMCB0byAxIHdoZW4gdXNlZCB0byBnZW5lcmF0ZSBhIEhlaWdodG1hcCBNZXNoXHJcbiAgICogQGF1dGhvcnMgU2ltb24gU3RvcmwtU2NodWxrZSwgSEZVLCAyMDIwKi9cclxuICBleHBvcnQgdHlwZSBoZWlnaHRNYXBGdW5jdGlvbiA9ICh4OiBudW1iZXIsIHo6IG51bWJlcikgPT4gbnVtYmVyO1xyXG5cclxuICAvKipcclxuICAgKiBHZW5lcmF0ZXMgYSBwbGFuYXIgR3JpZCBhbmQgYXBwbGllcyBhIEhlaWdodG1hcC1GdW5jdGlvbiB0byBpdC5cclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIFNpbW9uIFN0b3JsLVNjaHVsa2UsIEhGVSwgMjAyMFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBNZXNoSGVpZ2h0TWFwIGV4dGVuZHMgTWVzaCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gTWVzaC5yZWdpc3RlclN1YmNsYXNzKE1lc2hIZWlnaHRNYXApO1xyXG5cclxuICAgIHByaXZhdGUgcmVzb2x1dGlvblg6IG51bWJlcjtcclxuICAgIHByaXZhdGUgcmVzb2x1dGlvblo6IG51bWJlcjtcclxuICAgIHByaXZhdGUgaGVpZ2h0TWFwRnVuY3Rpb246IGhlaWdodE1hcEZ1bmN0aW9uO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfcmVzb2x1dGlvblg6IG51bWJlciA9IDE2LCBfcmVzb2x1dGlvblo6IG51bWJlciA9IDE2LCBfaGVpZ2h0TWFwRnVuY3Rpb24/OiBoZWlnaHRNYXBGdW5jdGlvbikge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLnJlc29sdXRpb25YID0gX3Jlc29sdXRpb25YO1xyXG4gICAgICB0aGlzLnJlc29sdXRpb25aID0gX3Jlc29sdXRpb25aO1xyXG5cclxuICAgICAgaWYgKF9yZXNvbHV0aW9uWiB8fCBfcmVzb2x1dGlvblggPD0gMCkge1xyXG4gICAgICAgIERlYnVnLndhcm4oXCJIZWlnaHRNYXAgTWVzaCBjYW5ub3QgaGF2ZSByZXNvbHV0aW9uIHZhbHVlcyA8IDEuIFwiKTtcclxuICAgICAgICB0aGlzLnJlc29sdXRpb25YID0gTWF0aC5tYXgoMSwgdGhpcy5yZXNvbHV0aW9uWCk7XHJcbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uWiA9IE1hdGgubWF4KDEsIHRoaXMucmVzb2x1dGlvblopO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoX2hlaWdodE1hcEZ1bmN0aW9uKSB0aGlzLmhlaWdodE1hcEZ1bmN0aW9uID0gX2hlaWdodE1hcEZ1bmN0aW9uO1xyXG4gICAgICBlbHNlIHRoaXMuaGVpZ2h0TWFwRnVuY3Rpb24gPSBmdW5jdGlvbiAoX3g6IG51bWJlciwgX3k6IG51bWJlcik6IG51bWJlciB7IHJldHVybiAwOyB9O1xyXG5cclxuICAgICAgdGhpcy5jcmVhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlVmVydGljZXMoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgbGV0IHZlcnRpY2VzOiBGbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCh0aGlzLnJlc29sdXRpb25YICsgMSkgKiAodGhpcy5yZXNvbHV0aW9uWiArIDEpICogMyk7XHJcblxyXG4gICAgICAvL0l0ZXJhdGUgb3ZlciBlYWNoIGNlbGwgdG8gZ2VuZXJhdGUgZ3JpZCBvZiB2ZXJ0aWNlc1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwLCB6OiBudW1iZXIgPSAwOyB6IDw9IHRoaXMucmVzb2x1dGlvblo7IHorKykge1xyXG4gICAgICAgIGZvciAobGV0IHg6IG51bWJlciA9IDA7IHggPD0gdGhpcy5yZXNvbHV0aW9uWDsgeCsrKSB7XHJcbiAgICAgICAgICAvLyBYXHJcbiAgICAgICAgICB2ZXJ0aWNlc1tpXSA9IHggLyB0aGlzLnJlc29sdXRpb25YIC0gMC41O1xyXG4gICAgICAgICAgLy8gQXBwbHkgaGVpZ2h0bWFwIHRvIHkgY29vcmRpbmF0ZVxyXG4gICAgICAgICAgdmVydGljZXNbaSArIDFdID0gdGhpcy5oZWlnaHRNYXBGdW5jdGlvbih4IC8gdGhpcy5yZXNvbHV0aW9uWCwgeiAvIHRoaXMucmVzb2x1dGlvblopO1xyXG4gICAgICAgICAgLy8gWlxyXG4gICAgICAgICAgdmVydGljZXNbaSArIDJdID0geiAvIHRoaXMucmVzb2x1dGlvblogLSAwLjU7XHJcbiAgICAgICAgICBpICs9IDM7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB2ZXJ0aWNlcztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlSW5kaWNlcygpOiBVaW50MTZBcnJheSB7XHJcbiAgICAgIGxldCB2ZXJ0OiBudW1iZXIgPSAwO1xyXG4gICAgICBsZXQgdHJpczogbnVtYmVyID0gMDtcclxuXHJcbiAgICAgIGxldCBpbmRpY2VzOiBVaW50MTZBcnJheSA9IG5ldyBVaW50MTZBcnJheSh0aGlzLnJlc29sdXRpb25YICogdGhpcy5yZXNvbHV0aW9uWiAqIDYpO1xyXG4gICAgICBmb3IgKGxldCB6OiBudW1iZXIgPSAwOyB6IDwgdGhpcy5yZXNvbHV0aW9uWjsgeisrKSB7XHJcbiAgICAgICAgZm9yIChsZXQgeDogbnVtYmVyID0gMDsgeCA8IHRoaXMucmVzb2x1dGlvblg7IHgrKykge1xyXG5cclxuICAgICAgICAgIC8vIEZpcnN0IHRyaWFuZ2xlIG9mIGVhY2ggZ3JpZC1jZWxsXHJcbiAgICAgICAgICBpbmRpY2VzW3RyaXMgKyAwXSA9IHZlcnQgKyAwO1xyXG4gICAgICAgICAgaW5kaWNlc1t0cmlzICsgMV0gPSB2ZXJ0ICsgdGhpcy5yZXNvbHV0aW9uWCArIDE7XHJcbiAgICAgICAgICBpbmRpY2VzW3RyaXMgKyAyXSA9IHZlcnQgKyAxO1xyXG5cclxuICAgICAgICAgIC8vIFNlY29uZCB0cmlhbmdsZSBvZiBlYWNoIGdyaWQtY2VsbFxyXG4gICAgICAgICAgaW5kaWNlc1t0cmlzICsgM10gPSB2ZXJ0ICsgMTtcclxuICAgICAgICAgIGluZGljZXNbdHJpcyArIDRdID0gdmVydCArIHRoaXMucmVzb2x1dGlvblggKyAxO1xyXG4gICAgICAgICAgaW5kaWNlc1t0cmlzICsgNV0gPSB2ZXJ0ICsgdGhpcy5yZXNvbHV0aW9uWCArIDI7XHJcbiAgICAgICAgICB2ZXJ0Kys7XHJcbiAgICAgICAgICB0cmlzICs9IDY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZlcnQrKztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gaW5kaWNlcztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlVGV4dHVyZVVWcygpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICBsZXQgdGV4dHVyZVVWczogRmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmluZGljZXMubGVuZ3RoICogMik7XHJcblxyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwLCB6OiBudW1iZXIgPSAwOyB6IDw9IHRoaXMucmVzb2x1dGlvblo7IHorKykge1xyXG4gICAgICAgIGZvciAobGV0IHg6IG51bWJlciA9IDA7IHggPD0gdGhpcy5yZXNvbHV0aW9uWDsgeCsrKSB7XHJcbiAgICAgICAgICB0ZXh0dXJlVVZzW2ldID0geCAvIHRoaXMucmVzb2x1dGlvblg7XHJcbiAgICAgICAgICB0ZXh0dXJlVVZzW2kgKyAxXSA9IHogLyB0aGlzLnJlc29sdXRpb25aO1xyXG4gICAgICAgICAgaSArPSAyO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGV4dHVyZVVWcztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlRmFjZU5vcm1hbHMoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgcmV0dXJuIHRoaXMuY2FsY3VsYXRlRmFjZU5vcm1hbHMoKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBHZW5lcmF0ZSBhIHNpbXBsZSBweXJhbWlkIHdpdGggZWRnZXMgYXQgdGhlIGJhc2Ugb2YgbGVuZ3RoIDEgYW5kIGEgaGVpZ2h0IG9mIDEuIFRoZSBzaWRlcyBjb25zaXN0aW5nIG9mIG9uZSwgdGhlIGJhc2Ugb2YgdHdvIHRyaWdvbnNcclxuICAgKiBgYGBwbGFpbnRleHRcclxuICAgKiAgICAgICAgICAgICAgIDRcclxuICAgKiAgICAgICAgICAgICAgL1xcYC5cclxuICAgKiAgICAgICAgICAgIDMvX19cXF9cXCAyXHJcbiAgICogICAgICAgICAgIDAvX19fX1xcLzFcclxuICAgKiBgYGBcclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBNZXNoUHlyYW1pZCBleHRlbmRzIE1lc2gge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IE1lc2gucmVnaXN0ZXJTdWJjbGFzcyhNZXNoUHlyYW1pZCk7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLmNyZWF0ZSgpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlVmVydGljZXMoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgbGV0IHZlcnRpY2VzOiBGbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KFtcclxuICAgICAgICAgICAgICAgIC8vIGZsb29yXHJcbiAgICAgICAgICAgICAgICAvKjAqLyAtMSwgMCwgMSwgLyoxKi8gMSwgMCwgMSwgIC8qMiovIDEsIDAsIC0xLCAvKjMqLyAtMSwgMCwgLTEsXHJcbiAgICAgICAgICAgICAgICAvLyB0aXBcclxuICAgICAgICAgICAgICAgIC8qNCovIDAsIDIsIDAsICAvLyBkb3VibGUgaGVpZ2h0IHdpbGwgYmUgc2NhbGVkIGRvd25cclxuICAgICAgICAgICAgICAgIC8vIGZsb29yIGFnYWluIGZvciB0ZXh0dXJpbmcgYW5kIG5vcm1hbHNcclxuICAgICAgICAgICAgICAgIC8qNSovIC0xLCAwLCAxLCAvKjYqLyAxLCAwLCAxLCAgLyo3Ki8gMSwgMCwgLTEsIC8qOCovIC0xLCAwLCAtMVxyXG4gICAgICBdKTtcclxuXHJcbiAgICAgIC8vIHNjYWxlIGRvd24gdG8gYSBsZW5ndGggb2YgMSBmb3IgYm90dG9tIGVkZ2VzIGFuZCBoZWlnaHRcclxuICAgICAgdmVydGljZXMgPSB2ZXJ0aWNlcy5tYXAoX3ZhbHVlID0+IF92YWx1ZSAvIDIpO1xyXG4gICAgICByZXR1cm4gdmVydGljZXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZUluZGljZXMoKTogVWludDE2QXJyYXkge1xyXG4gICAgICBsZXQgaW5kaWNlczogVWludDE2QXJyYXkgPSBuZXcgVWludDE2QXJyYXkoW1xyXG4gICAgICAgIC8vIGZyb250XHJcbiAgICAgICAgNCwgMCwgMSxcclxuICAgICAgICAvLyByaWdodFxyXG4gICAgICAgIDQsIDEsIDIsXHJcbiAgICAgICAgLy8gYmFja1xyXG4gICAgICAgIDQsIDIsIDMsXHJcbiAgICAgICAgLy8gbGVmdFxyXG4gICAgICAgIDQsIDMsIDAsXHJcbiAgICAgICAgLy8gYm90dG9tXHJcbiAgICAgICAgNSArIDAsIDUgKyAyLCA1ICsgMSwgNSArIDAsIDUgKyAzLCA1ICsgMlxyXG4gICAgICBdKTtcclxuICAgICAgcmV0dXJuIGluZGljZXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZVRleHR1cmVVVnMoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgbGV0IHRleHR1cmVVVnM6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoW1xyXG4gICAgICAgICAgICAgICAgLy8gZnJvbnRcclxuICAgICAgICAgICAgICAgIC8qMCovIDAsIDEsIC8qMSovIDAuNSwgMSwgIC8qMiovIDEsIDEsIC8qMyovIDAuNSwgMSxcclxuICAgICAgICAgICAgICAgIC8vIGJhY2tcclxuICAgICAgICAgICAgICAgIC8qNCovIDAuNSwgMCxcclxuICAgICAgICAgICAgICAgIC8qNSovIDAsIDAsIC8qNiovIDEsIDAsICAvKjcqLyAxLCAxLCAvKjgqLyAwLCAxXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gdGV4dHVyZVVWcztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlRmFjZU5vcm1hbHMoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkodGhpcy5jYWxjdWxhdGVGYWNlTm9ybWFscygpKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBHZW5lcmF0ZSBhIHNpbXBsZSBxdWFkIHdpdGggZWRnZXMgb2YgbGVuZ3RoIDEsIHRoZSBmYWNlIGNvbnNpc3Rpbmcgb2YgdHdvIHRyaWdvbnNcclxuICAgKiBgYGBwbGFpbnRleHRcclxuICAgKiAgICAgICAgMCBfXyAzXHJcbiAgICogICAgICAgICB8X198XHJcbiAgICogICAgICAgIDEgICAgMiAgICAgICAgICAgICBcclxuICAgKiBgYGAgXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgTWVzaFF1YWQgZXh0ZW5kcyBNZXNoIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBNZXNoLnJlZ2lzdGVyU3ViY2xhc3MoTWVzaFF1YWQpO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5jcmVhdGUoKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZVZlcnRpY2VzKCk6IEZsb2F0MzJBcnJheSB7XHJcbiAgICAgIGxldCB2ZXJ0aWNlczogRmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAgICAgICAgICAgICAvKjAqLyAtMSwgMSwgMCwgLyoxKi8gLTEsIC0xLCAwLCAgLyoyKi8gMSwgLTEsIDAsIC8qMyovIDEsIDEsIDBcclxuICAgICAgXSk7XHJcblxyXG4gICAgICB2ZXJ0aWNlcyA9IHZlcnRpY2VzLm1hcChfdmFsdWUgPT4gX3ZhbHVlIC8gMik7XHJcbiAgICAgIHJldHVybiB2ZXJ0aWNlcztcclxuICAgIH1cclxuICAgIFxyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZUluZGljZXMoKTogVWludDE2QXJyYXkge1xyXG4gICAgICBsZXQgaW5kaWNlczogVWludDE2QXJyYXkgPSBuZXcgVWludDE2QXJyYXkoW1xyXG4gICAgICAgIDEsIDIsIDAsIDIsIDMsIDBcclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiBpbmRpY2VzO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBjcmVhdGVUZXh0dXJlVVZzKCk6IEZsb2F0MzJBcnJheSB7XHJcbiAgICAgIGxldCB0ZXh0dXJlVVZzOiBGbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KFtcclxuICAgICAgICAgICAgICAgIC8vIGZyb250XHJcbiAgICAgICAgICAgICAgICAvKjAqLyAwLCAwLCAvKjEqLyAwLCAxLCAgLyoyKi8gMSwgMSwgLyozKi8gMSwgMFxyXG4gICAgICBdKTtcclxuICAgICAgcmV0dXJuIHRleHR1cmVVVnM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZUZhY2VOb3JtYWxzKCk6IEZsb2F0MzJBcnJheSB7XHJcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KFtcclxuICAgICAgICAgICAgICAgIC8qMCovIDAsIDAsIDEsIC8qMSovIDAsIDAsIDAsIC8qMiovIDAsIDAsIDAsIC8qMyovIDAsIDAsIDBcclxuICAgICAgXSk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogR2VuZXJhdGUgYSBVViBTcGhlcmUgd2l0aCBhIGdpdmVuIG51bWJlciBvZiBzZWN0b3JzIGFuZCBzdGFja3MgKGNsYW1wZWQgYXQgMTI4KjEyOClcclxuICAgKiBJbXBsZW1lbnRhdGlvbiBiYXNlZCBvbiBodHRwOi8vd3d3LnNvbmdoby5jYS9vcGVuZ2wvZ2xfc3BoZXJlLmh0bWxcclxuICAgKiBAYXV0aG9ycyBTaW1vbiBTdG9ybC1TY2h1bGtlLCBIRlUsIDIwMjAgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBNZXNoU3BoZXJlIGV4dGVuZHMgTWVzaCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gTWVzaC5yZWdpc3RlclN1YmNsYXNzKE1lc2hTcGhlcmUpO1xyXG5cclxuICAgIHB1YmxpYyBub3JtYWxzOiBGbG9hdDMyQXJyYXk7XHJcblxyXG4gICAgcHJpdmF0ZSBzZWN0b3JzOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIHN0YWNrczogbnVtYmVyO1xyXG5cclxuICAgIC8vIERpcnR5IFdvcmthcm91bmQgdG8gaGF2ZSBhY2Nlc3MgdG8gdGhlIG5vcm1hbHMgZnJvbSBjcmVhdGVWZXJ0aWNlcygpXHJcbiAgICAvLyBwcml2YXRlIG5vcm1hbHM6IEFycmF5PG51bWJlcj4gPSBbXTtcclxuICAgIC8vIHByaXZhdGUgdGV4dHVyZVVWczogQXJyYXk8bnVtYmVyPiA9IFtdO1xyXG4gICAgLy8gcHVibGljIHRleHR1cmVVVnM6IEZsb2F0MzJBcnJheTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3NlY3RvcnM6IG51bWJlciA9IDEyLCBfc3RhY2tzOiBudW1iZXIgPSA4KSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcblxyXG4gICAgICAvL0NsYW1wIHJlc29sdXRpb24gdG8gcHJldmVudCBwZXJmb3JtYW5jZSBpc3N1ZXNcclxuICAgICAgdGhpcy5zZWN0b3JzID0gTWF0aC5taW4oX3NlY3RvcnMsIDEyOCk7XHJcbiAgICAgIHRoaXMuc3RhY2tzID0gTWF0aC5taW4oX3N0YWNrcywgMTI4KTtcclxuXHJcbiAgICAgIGlmIChfc2VjdG9ycyA8IDMgfHwgX3N0YWNrcyA8IDIpIHtcclxuICAgICAgICBEZWJ1Zy53YXJuKFwiVVYgU3BoZXJlIG11c3QgaGF2ZSBhdCBsZWFzdCAzIHNlY3RvcnMgYW5kIDIgc3RhY2tzIHRvIGZvcm0gYSAzLWRpbWVuc2lvbmFsIHNoYXBlLlwiKTtcclxuICAgICAgICB0aGlzLnNlY3RvcnMgPSBNYXRoLm1heCgzLCBfc2VjdG9ycyk7XHJcbiAgICAgICAgdGhpcy5zdGFja3MgPSBNYXRoLm1heCgyLCBfc3RhY2tzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5jcmVhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgY3JlYXRlKCk6IHZvaWQge1xyXG4gICAgICBsZXQgdmVydGljZXM6IEFycmF5PG51bWJlcj4gPSBbXTtcclxuICAgICAgbGV0IG5vcm1hbHM6IG51bWJlcltdID0gW107XHJcbiAgICAgIGxldCB0ZXh0dXJlVVZzOiBudW1iZXJbXSA9IFtdO1xyXG5cclxuICAgICAgbGV0IHg6IG51bWJlcjtcclxuICAgICAgbGV0IHo6IG51bWJlcjtcclxuICAgICAgbGV0IHh6OiBudW1iZXI7XHJcbiAgICAgIGxldCB5OiBudW1iZXI7XHJcblxyXG5cclxuICAgICAgbGV0IHNlY3RvclN0ZXA6IG51bWJlciA9IDIgKiBNYXRoLlBJIC8gdGhpcy5zZWN0b3JzO1xyXG4gICAgICBsZXQgc3RhY2tTdGVwOiBudW1iZXIgPSBNYXRoLlBJIC8gdGhpcy5zdGFja3M7XHJcbiAgICAgIGxldCBzdGFja0FuZ2xlOiBudW1iZXI7XHJcbiAgICAgIGxldCBzZWN0b3JBbmdsZTogbnVtYmVyO1xyXG5cclxuICAgICAgLyogYWRkIChzZWN0b3JDb3VudCsxKSB2ZXJ0aWNlcyBwZXIgc3RhY2suXHJcbiAgICAgIHRoZSBmaXJzdCBhbmQgbGFzdCB2ZXJ0aWNlcyBoYXZlIHNhbWUgcG9zaXRpb24gYW5kIG5vcm1hbCwgXHJcbiAgICAgIGJ1dCBkaWZmZXJlbnQgdGV4IGNvb3JkcyAqL1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDw9IHRoaXMuc3RhY2tzOyArK2kpIHtcclxuICAgICAgICBzdGFja0FuZ2xlID0gTWF0aC5QSSAvIDIgLSBpICogc3RhY2tTdGVwO1xyXG4gICAgICAgIHh6ID0gTWF0aC5jb3Moc3RhY2tBbmdsZSk7XHJcbiAgICAgICAgeSA9IE1hdGguc2luKHN0YWNrQW5nbGUpO1xyXG5cclxuICAgICAgICAvLyBhZGQgKHNlY3RvckNvdW50KzEpIHZlcnRpY2VzIHBlciBzdGFja1xyXG4gICAgICAgIC8vIHRoZSBmaXJzdCBhbmQgbGFzdCB2ZXJ0aWNlcyBoYXZlIHNhbWUgcG9zaXRpb24gYW5kIG5vcm1hbCwgYnV0IGRpZmZlcmVudCB0ZXggY29vcmRzXHJcbiAgICAgICAgZm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8PSB0aGlzLnNlY3RvcnM7ICsraikge1xyXG4gICAgICAgICAgc2VjdG9yQW5nbGUgPSBqICogc2VjdG9yU3RlcDtcclxuXHJcbiAgICAgICAgICAvL3ZlcnRleCBwb3NpdGlvblxyXG4gICAgICAgICAgeCA9IHh6ICogTWF0aC5jb3Moc2VjdG9yQW5nbGUpO1xyXG4gICAgICAgICAgeiA9IHh6ICogTWF0aC5zaW4oc2VjdG9yQW5nbGUpO1xyXG4gICAgICAgICAgdmVydGljZXMucHVzaCh4LCB5LCB6KTtcclxuXHJcbiAgICAgICAgICAvL25vcm1hbHNcclxuICAgICAgICAgIG5vcm1hbHMucHVzaCh4LCB5LCB6KTtcclxuXHJcbiAgICAgICAgICAvL1VWIENvb3Jkc1xyXG4gICAgICAgICAgdGV4dHVyZVVWcy5wdXNoKGogLyB0aGlzLnNlY3RvcnMgKiAtMSk7XHJcbiAgICAgICAgICB0ZXh0dXJlVVZzLnB1c2goaSAvIHRoaXMuc3RhY2tzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHNjYWxlIGRvd25cclxuICAgICAgdmVydGljZXMgPSB2ZXJ0aWNlcy5tYXAoX3ZhbHVlID0+IF92YWx1ZSAvIDIpO1xyXG5cclxuICAgICAgdGhpcy50ZXh0dXJlVVZzID0gbmV3IEZsb2F0MzJBcnJheSh0ZXh0dXJlVVZzKTtcclxuICAgICAgdGhpcy5ub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheShub3JtYWxzKTtcclxuICAgICAgdGhpcy52ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkodmVydGljZXMpO1xyXG4gICAgICB0aGlzLm5vcm1hbHNGYWNlID0gdGhpcy5jcmVhdGVGYWNlTm9ybWFscygpO1xyXG4gICAgICB0aGlzLmluZGljZXMgPSB0aGlzLmNyZWF0ZUluZGljZXMoKTtcclxuICAgICAgdGhpcy5jcmVhdGVSZW5kZXJCdWZmZXJzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZUluZGljZXMoKTogVWludDE2QXJyYXkge1xyXG4gICAgICBsZXQgaW5kczogQXJyYXk8bnVtYmVyPiA9IFtdO1xyXG5cclxuICAgICAgbGV0IGsxOiBudW1iZXI7XHJcbiAgICAgIGxldCBrMjogbnVtYmVyO1xyXG5cclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMuc3RhY2tzOyArK2kpIHtcclxuICAgICAgICBrMSA9IGkgKiAodGhpcy5zZWN0b3JzICsgMSk7ICAgLy8gYmVnaW5uaW5nIG9mIGN1cnJlbnQgc3RhY2tcclxuICAgICAgICBrMiA9IGsxICsgdGhpcy5zZWN0b3JzICsgMTsgICAgLy8gYmVnaW5uaW5nIG9mIG5leHQgc3RhY2tcclxuXHJcbiAgICAgICAgZm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IHRoaXMuc2VjdG9yczsgKytqLCArK2sxLCArK2syKSB7XHJcblxyXG4gICAgICAgICAgLy8gMiB0cmlhbmdsZXMgcGVyIHNlY3RvciBleGNsdWRpbmcgZmlyc3QgYW5kIGxhc3Qgc3RhY2tzXHJcbiAgICAgICAgICAvLyBrMSA9PiBrMiA9PiBrMSsxXHJcbiAgICAgICAgICBpZiAoaSAhPSAwKSB7XHJcbiAgICAgICAgICAgIGluZHMucHVzaChrMSk7XHJcbiAgICAgICAgICAgIGluZHMucHVzaChrMSArIDEpO1xyXG4gICAgICAgICAgICBpbmRzLnB1c2goazIpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmIChpICE9ICh0aGlzLnN0YWNrcyAtIDEpKSB7XHJcbiAgICAgICAgICAgIGluZHMucHVzaChrMSArIDEpO1xyXG4gICAgICAgICAgICBpbmRzLnB1c2goazIgKyAxKTtcclxuICAgICAgICAgICAgaW5kcy5wdXNoKGsyKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgbGV0IGluZGljZXM6IFVpbnQxNkFycmF5ID0gbmV3IFVpbnQxNkFycmF5KGluZHMpO1xyXG4gICAgICByZXR1cm4gaW5kaWNlcztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlVmVydGljZXMoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgcmV0dXJuIHRoaXMudmVydGljZXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZVRleHR1cmVVVnMoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZVVWcztcclxuICAgIH1cclxuXHJcbiAgICAvL1RPRE86IHdlIGFsc28gbmVlZCBSRUFMIGZhY2Ugbm9ybWFsc1xyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZUZhY2VOb3JtYWxzKCk6IEZsb2F0MzJBcnJheSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm5vcm1hbHM7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogR2VuZXJhdGUgdHdvIHF1YWRzIHBsYWNlZCBiYWNrIHRvIGJhY2ssIHRoZSBvbmUgZmFjaW5nIGluIG5lZ2F0aXZlIFotZGlyZWN0aW9uIGlzIHRleHR1cmVkIHJldmVyc2VkXHJcbiAgICogYGBgcGxhaW50ZXh0XHJcbiAgICogICAgICAgIDAgX18gM1xyXG4gICAqICAgICAgICAgfF9ffFxyXG4gICAqICAgICAgICAxICAgIDIgICAgICAgICAgICAgXHJcbiAgICogYGBgIFxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIwXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE1lc2hTcHJpdGUgZXh0ZW5kcyBNZXNoIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBNZXNoLnJlZ2lzdGVyU3ViY2xhc3MoTWVzaFNwcml0ZSk7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLmNyZWF0ZSgpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlVmVydGljZXMoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgbGV0IHZlcnRpY2VzOiBGbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KFtcclxuICAgICAgICAvKjAqLyAtMSwgMSwgMCwgLyoxKi8gLTEsIC0xLCAwLCAgLyoyKi8gMSwgLTEsIDAsIC8qMyovIDEsIDEsIDBcclxuICAgICAgXSk7XHJcblxyXG4gICAgICB2ZXJ0aWNlcyA9IHZlcnRpY2VzLm1hcChfdmFsdWUgPT4gX3ZhbHVlIC8gMik7XHJcblxyXG4gICAgICByZXR1cm4gdmVydGljZXM7XHJcbiAgICB9XHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlSW5kaWNlcygpOiBVaW50MTZBcnJheSB7XHJcbiAgICAgIGxldCBpbmRpY2VzOiBVaW50MTZBcnJheSA9IG5ldyBVaW50MTZBcnJheShbXHJcbiAgICAgICAgMSwgMiwgMCwgMiwgMywgMCwgLy9mcm9udFxyXG4gICAgICAgIDAsIDMsIDEsIDMsIDIsIDEgIC8vYmFja1xyXG4gICAgICBdKTtcclxuICAgICAgcmV0dXJuIGluZGljZXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZVRleHR1cmVVVnMoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgbGV0IHRleHR1cmVVVnM6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoW1xyXG4gICAgICAgIC8vIGZyb250XHJcbiAgICAgICAgLyowKi8gMCwgMCwgLyoxKi8gMCwgMSwgIC8qMiovIDEsIDEsIC8qMyovIDEsIDBcclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiB0ZXh0dXJlVVZzO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBjcmVhdGVGYWNlTm9ybWFscygpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAgICAgLyowOiBub3JtYWwgb2YgZnJvbnQgZmFjZSovXHJcbiAgICAgICAgMCwgMCwgMSxcclxuICAgICAgICAvKjE6IG5vcm1hbCBvZiBiYWNrIGZhY2UqL1xyXG4gICAgICAgIDAsIDAsIC0xLFxyXG4gICAgICAgIC8qMiovXHJcbiAgICAgICAgMCwgMCwgMCxcclxuICAgICAgICAvKjMqL1xyXG4gICAgICAgIDAsIDAsIDBcclxuICAgICAgXSk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGludGVyZmFjZSBNYXBDbGFzc1RvQ29tcG9uZW50cyB7XHJcbiAgICBbY2xhc3NOYW1lOiBzdHJpbmddOiBDb21wb25lbnRbXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlcHJlc2VudHMgYSBub2RlIGluIHRoZSBzY2VuZXRyZWUuXHJcbiAgICogQGF1dGhvcnMgSmFzY2hhIEthcmFnw7ZsLCBIRlUsIDIwMTkgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9KaXJrYURlbGxPcm8vRlVER0Uvd2lraS9HcmFwaFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBOb2RlIGV4dGVuZHMgRXZlbnRUYXJnZXTGkiBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZSB7XHJcbiAgICBwdWJsaWMgbmFtZTogc3RyaW5nOyAvLyBUaGUgbmFtZSB0byBjYWxsIHRoaXMgbm9kZSBieS5cclxuICAgIHB1YmxpYyBtdHhXb3JsZDogTWF0cml4NHg0ID0gTWF0cml4NHg0LklERU5USVRZKCk7XHJcbiAgICBwdWJsaWMgdGltZXN0YW1wVXBkYXRlOiBudW1iZXIgPSAwO1xyXG5cclxuICAgIHByaXZhdGUgcGFyZW50OiBOb2RlIHwgbnVsbCA9IG51bGw7IC8vIFRoZSBwYXJlbnQgb2YgdGhpcyBub2RlLlxyXG4gICAgcHJpdmF0ZSBjaGlsZHJlbjogTm9kZVtdID0gW107IC8vIGFycmF5IG9mIGNoaWxkIG5vZGVzIGFwcGVuZGVkIHRvIHRoaXMgbm9kZS5cclxuICAgIHByaXZhdGUgY29tcG9uZW50czogTWFwQ2xhc3NUb0NvbXBvbmVudHMgPSB7fTtcclxuICAgIC8vIHByaXZhdGUgdGFnczogc3RyaW5nW10gPSBbXTsgLy8gTmFtZXMgb2YgdGFncyB0aGF0IGFyZSBhdHRhY2hlZCB0byB0aGlzIG5vZGUuIChUT0RPOiBBcyBvZiB5ZXQgbm8gZnVuY3Rpb25hbGl0eSlcclxuICAgIC8vIHByaXZhdGUgbGF5ZXJzOiBzdHJpbmdbXSA9IFtdOyAvLyBOYW1lcyBvZiB0aGUgbGF5ZXJzIHRoaXMgbm9kZSBpcyBvbi4gKFRPRE86IEFzIG9mIHlldCBubyBmdW5jdGlvbmFsaXR5KVxyXG4gICAgcHJpdmF0ZSBsaXN0ZW5lcnM6IE1hcEV2ZW50VHlwZVRvTGlzdGVuZXIgPSB7fTtcclxuICAgIHByaXZhdGUgY2FwdHVyZXM6IE1hcEV2ZW50VHlwZVRvTGlzdGVuZXIgPSB7fTtcclxuICAgIHByaXZhdGUgYWN0aXZlOiBib29sZWFuID0gdHJ1ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgbm9kZSB3aXRoIGEgbmFtZSBhbmQgaW5pdGlhbGl6ZXMgYWxsIGF0dHJpYnV0ZXNcclxuICAgICAqIEBwYXJhbSBfbmFtZSBUaGUgbmFtZSBieSB3aGljaCB0aGUgbm9kZSBjYW4gYmUgY2FsbGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX25hbWU6IHN0cmluZykge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLm5hbWUgPSBfbmFtZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYWN0aXZhdGUoX29uOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuYWN0aXZlID0gX29uO1xyXG4gICAgICAvLyBUT0RPOiBjaGVjayBpZiBDT01QT05FTlRfQUNUSVZBVEUvREVBQ1RJVkFURSBpcyB0aGUgY29ycmVjdCBldmVudCB0byBkaXNwYXRjaC4gU2hvdWxkbid0IGl0IGJlIHNvbWV0aGluZyBsaWtlIE5PREVfQUNUSVZBVEUvREVBQ1RJVkFURT9cclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChfb24gPyBFVkVOVC5DT01QT05FTlRfQUNUSVZBVEUgOiBFVkVOVC5DT01QT05FTlRfREVBQ1RJVkFURSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgaXNBY3RpdmUoKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLmFjdGl2ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNob3J0Y3V0IHRvIHJldHJpZXZlIHRoaXMgbm9kZXMgW1tDb21wb25lbnRUcmFuc2Zvcm1dXVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGNtcFRyYW5zZm9ybSgpOiBDb21wb25lbnRUcmFuc2Zvcm0ge1xyXG4gICAgICByZXR1cm4gPENvbXBvbmVudFRyYW5zZm9ybT50aGlzLmdldENvbXBvbmVudHMoQ29tcG9uZW50VHJhbnNmb3JtKVswXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNob3J0Y3V0IHRvIHJldHJpZXZlIHRoZSBsb2NhbCBbW01hdHJpeDR4NF1dIGF0dGFjaGVkIHRvIHRoaXMgbm9kZXMgW1tDb21wb25lbnRUcmFuc2Zvcm1dXSAgXHJcbiAgICAgKiBGYWlscyBpZiBubyBbW0NvbXBvbmVudFRyYW5zZm9ybV1dIGlzIGF0dGFjaGVkXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgbXR4TG9jYWwoKTogTWF0cml4NHg0IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY21wVHJhbnNmb3JtLmxvY2FsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICNyZWdpb24gU2NlbmV0cmVlXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhpcyBub2RlcyBwYXJlbnQgbm9kZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0UGFyZW50KCk6IE5vZGUgfCBudWxsIHtcclxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhY2VzIGJhY2sgdGhlIGFuY2VzdG9ycyBvZiB0aGlzIG5vZGUgYW5kIHJldHVybnMgdGhlIGZpcnN0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRBbmNlc3RvcigpOiBOb2RlIHwgbnVsbCB7XHJcbiAgICAgIGxldCBhbmNlc3RvcjogTm9kZSA9IHRoaXM7XHJcbiAgICAgIHdoaWxlIChhbmNlc3Rvci5nZXRQYXJlbnQoKSlcclxuICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLmdldFBhcmVudCgpO1xyXG4gICAgICByZXR1cm4gYW5jZXN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gYXR0YWNoZWQgdG8gdGhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG5DaGlsZHJlbigpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGNoaWxkIGF0IHRoZSBnaXZlbiBpbmRleCBpbiB0aGUgbGlzdCBvZiBjaGlsZHJlblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Q2hpbGQoX2luZGV4OiBudW1iZXIpOiBOb2RlIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5bX2luZGV4XTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgbGlzdCBvZiBjaGlsZHJlblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Q2hpbGRyZW4oKTogTm9kZVtdIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4uc2xpY2UoMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHJlZmVyZW5jZXMgdG8gY2hpbGRub2RlcyB3aXRoIHRoZSBzdXBwbGllZCBuYW1lLiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldENoaWxkcmVuQnlOYW1lKF9uYW1lOiBzdHJpbmcpOiBOb2RlW10ge1xyXG4gICAgICBsZXQgZm91bmQ6IE5vZGVbXSA9IFtdO1xyXG4gICAgICBmb3VuZCA9IHRoaXMuY2hpbGRyZW4uZmlsdGVyKChfbm9kZTogTm9kZSkgPT4gX25vZGUubmFtZSA9PSBfbmFtZSk7XHJcbiAgICAgIHJldHVybiBmb3VuZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNpbXBseSBjYWxscyBbW2FkZENoaWxkXV0uIFRoaXMgcmVmZXJlbmNlIGlzIGhlcmUgc29sZWx5IGJlY2F1c2UgYXBwZW5kQ2hpbGQgaXMgdGhlIGVxdWl2YWxlbnQgbWV0aG9kIGluIERPTS5cclxuICAgICAqIFNlZSBhbmQgcHJlZmVyYWJseSB1c2UgW1thZGRDaGlsZF1dXHJcbiAgICAgKi9cclxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbWVtYmVyLW9yZGVyaW5nXHJcbiAgICBwdWJsaWMgcmVhZG9ubHkgYXBwZW5kQ2hpbGQ6IChfY2hpbGQ6IE5vZGUpID0+IHZvaWQgPSB0aGlzLmFkZENoaWxkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgZ2l2ZW4gcmVmZXJlbmNlIHRvIGEgbm9kZSB0byB0aGUgbGlzdCBvZiBjaGlsZHJlbiwgaWYgbm90IGFscmVhZHkgaW5cclxuICAgICAqIEB0aHJvd3MgRXJyb3Igd2hlbiB0cnlpbmcgdG8gYWRkIGFuIGFuY2VzdG9yIG9mIHRoaXMgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhZGRDaGlsZChfY2hpbGQ6IE5vZGUpOiB2b2lkIHtcclxuICAgICAgaWYgKHRoaXMuY2hpbGRyZW4uaW5jbHVkZXMoX2NoaWxkKSlcclxuICAgICAgICAvLyBfbm9kZSBpcyBhbHJlYWR5IGEgY2hpbGQgb2YgdGhpc1xyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGxldCBpbkF1ZGlvR3JhcGg6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgICAgbGV0IGdyYXBoTGlzdGVuZWQ6IE5vZGUgPSBBdWRpb01hbmFnZXIuZGVmYXVsdC5nZXRHcmFwaExpc3RlbmluZ1RvKCk7XHJcbiAgICAgIGxldCBhbmNlc3RvcjogTm9kZSA9IHRoaXM7XHJcbiAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xyXG4gICAgICAgIGFuY2VzdG9yLnRpbWVzdGFtcFVwZGF0ZSA9IDA7XHJcbiAgICAgICAgaW5BdWRpb0dyYXBoID0gaW5BdWRpb0dyYXBoIHx8IChhbmNlc3RvciA9PSBncmFwaExpc3RlbmVkKTtcclxuICAgICAgICBpZiAoYW5jZXN0b3IgPT0gX2NoaWxkKVxyXG4gICAgICAgICAgdGhyb3cgKG5ldyBFcnJvcihcIkN5Y2xpYyByZWZlcmVuY2UgcHJvaGliaXRlZCBpbiBub2RlIGhpZXJhcmNoeSwgYW5jZXN0b3JzIG11c3Qgbm90IGJlIGFkZGVkIGFzIGNoaWxkcmVuXCIpKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IHByZXZpb3VzUGFyZW50OiBOb2RlID0gX2NoaWxkLnBhcmVudDtcclxuICAgICAgaWYgKHByZXZpb3VzUGFyZW50KVxyXG4gICAgICAgIHByZXZpb3VzUGFyZW50LnJlbW92ZUNoaWxkKF9jaGlsZCk7XHJcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChfY2hpbGQpO1xyXG4gICAgICBfY2hpbGQucGFyZW50ID0gdGhpcztcclxuICAgICAgX2NoaWxkLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULkNISUxEX0FQUEVORCwgeyBidWJibGVzOiB0cnVlIH0pKTtcclxuICAgICAgaWYgKGluQXVkaW9HcmFwaClcclxuICAgICAgICBfY2hpbGQuYnJvYWRjYXN0RXZlbnQobmV3IEV2ZW50KEVWRU5UX0FVRElPLkNISUxEX0FQUEVORCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgcmVmZXJlbmNlIHRvIHRoZSBnaXZlIG5vZGUgZnJvbSB0aGUgbGlzdCBvZiBjaGlsZHJlblxyXG4gICAgICogQHBhcmFtIF9jaGlsZCBUaGUgbm9kZSB0byBiZSByZW1vdmVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVtb3ZlQ2hpbGQoX2NoaWxkOiBOb2RlKTogdm9pZCB7XHJcbiAgICAgIGxldCBmb3VuZDogbnVtYmVyID0gdGhpcy5maW5kQ2hpbGQoX2NoaWxkKTtcclxuICAgICAgaWYgKGZvdW5kIDwgMClcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBfY2hpbGQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuQ0hJTERfUkVNT1ZFLCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xyXG4gICAgICBpZiAodGhpcy5pc0Rlc2NlbmRhbnRPZihBdWRpb01hbmFnZXIuZGVmYXVsdC5nZXRHcmFwaExpc3RlbmluZ1RvKCkpKVxyXG4gICAgICAgIF9jaGlsZC5icm9hZGNhc3RFdmVudChuZXcgRXZlbnQoRVZFTlRfQVVESU8uQ0hJTERfUkVNT1ZFKSk7XHJcbiAgICAgIHRoaXMuY2hpbGRyZW4uc3BsaWNlKGZvdW5kLCAxKTtcclxuICAgICAgX2NoaWxkLnBhcmVudCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgbm9kZSBpbiB0aGUgbGlzdCBvZiBjaGlsZHJlbiBvciAtMSBpZiBub3QgZm91bmRcclxuICAgICAqIEBwYXJhbSBfc2VhcmNoIFRoZSBub2RlIHRvIGJlIGZvdW5kLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZmluZENoaWxkKF9zZWFyY2g6IE5vZGUpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5pbmRleE9mKF9zZWFyY2gpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVwbGFjZXMgYSBjaGlsZCBub2RlIHdpdGggYW5vdGhlciwgcHJlc2VydmluZyB0aGUgcG9zaXRpb24gaW4gdGhlIGxpc3Qgb2YgY2hpbGRyZW5cclxuICAgICAqIEBwYXJhbSBfcmVwbGFjZSBUaGUgbm9kZSB0byBiZSByZXBsYWNlZFxyXG4gICAgICogQHBhcmFtIF93aXRoIFRoZSBub2RlIHRvIHJlcGxhY2Ugd2l0aFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVwbGFjZUNoaWxkKF9yZXBsYWNlOiBOb2RlLCBfd2l0aDogTm9kZSk6IGJvb2xlYW4ge1xyXG4gICAgICBsZXQgZm91bmQ6IG51bWJlciA9IHRoaXMuZmluZENoaWxkKF9yZXBsYWNlKTtcclxuICAgICAgaWYgKGZvdW5kIDwgMClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICBsZXQgcHJldmlvdXNQYXJlbnQ6IE5vZGUgPSBfd2l0aC5nZXRQYXJlbnQoKTtcclxuICAgICAgaWYgKHByZXZpb3VzUGFyZW50KVxyXG4gICAgICAgIHByZXZpb3VzUGFyZW50LnJlbW92ZUNoaWxkKF93aXRoKTtcclxuXHJcbiAgICAgIF9yZXBsYWNlLnBhcmVudCA9IG51bGw7XHJcbiAgICAgIHRoaXMuY2hpbGRyZW5bZm91bmRdID0gX3dpdGg7XHJcbiAgICAgIF93aXRoLnBhcmVudCA9IHRoaXM7XHJcblxyXG4gICAgICBfd2l0aC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVC5DSElMRF9BUFBFTkQsIHsgYnViYmxlczogdHJ1ZSB9KSk7XHJcbiAgICAgIGlmICh0aGlzLmlzRGVzY2VuZGFudE9mKEF1ZGlvTWFuYWdlci5kZWZhdWx0LmdldEdyYXBoTGlzdGVuaW5nVG8oKSkpXHJcbiAgICAgICAgX3dpdGguYnJvYWRjYXN0RXZlbnQobmV3IEV2ZW50KEVWRU5UX0FVRElPLkNISUxEX0FQUEVORCkpO1xyXG5cclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0b3IgeWllbGRpbmcgdGhlIG5vZGUgYW5kIGFsbCBkZWNlbmRhbnRzIGluIHRoZSBncmFwaCBiZWxvdyBmb3IgaXRlcmF0aW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgZ3JhcGgoKTogSXRlcmFibGVJdGVyYXRvcjxOb2RlPiB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldEdyYXBoR2VuZXJhdG9yKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGlzVXBkYXRlZChfdGltZXN0YW1wVXBkYXRlOiBudW1iZXIpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuICh0aGlzLnRpbWVzdGFtcFVwZGF0ZSA9PSBfdGltZXN0YW1wVXBkYXRlKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgaXNEZXNjZW5kYW50T2YoX2FuY2VzdG9yOiBOb2RlKTogYm9vbGVhbiB7XHJcbiAgICAgIGxldCBub2RlOiBOb2RlID0gdGhpcztcclxuICAgICAgd2hpbGUgKG5vZGUgJiYgbm9kZSAhPSBfYW5jZXN0b3IpXHJcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xyXG4gICAgICByZXR1cm4gKG5vZGUgIT0gbnVsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIGEgTXV0YXRvciBmcm9tIFtbQW5pbWF0aW9uXV0gdG8gYWxsIGl0cyBjb21wb25lbnRzIGFuZCB0cmFuc2ZlcnMgaXQgdG8gaXRzIGNoaWxkcmVuLlxyXG4gICAgICogQHBhcmFtIF9tdXRhdG9yIFRoZSBtdXRhdG9yIGdlbmVyYXRlZCBmcm9tIGFuIFtbQW5pbWF0aW9uXV1cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFwcGx5QW5pbWF0aW9uKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIGlmIChfbXV0YXRvci5jb21wb25lbnRzKSB7XHJcbiAgICAgICAgZm9yIChsZXQgY29tcG9uZW50TmFtZSBpbiBfbXV0YXRvci5jb21wb25lbnRzKSB7XHJcbiAgICAgICAgICBpZiAodGhpcy5jb21wb25lbnRzW2NvbXBvbmVudE5hbWVdKSB7XHJcbiAgICAgICAgICAgIGxldCBtdXRhdG9yT2ZDb21wb25lbnQ6IE11dGF0b3IgPSA8TXV0YXRvcj5fbXV0YXRvci5jb21wb25lbnRzO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpIGluIG11dGF0b3JPZkNvbXBvbmVudFtjb21wb25lbnROYW1lXSkge1xyXG4gICAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudHNbY29tcG9uZW50TmFtZV1bK2ldKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY29tcG9uZW50VG9NdXRhdGU6IENvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50c1tjb21wb25lbnROYW1lXVsraV07XHJcbiAgICAgICAgICAgICAgICBsZXQgbXV0YXRvckFycmF5OiBNdXRhdG9yW10gPSAoPEFycmF5PE11dGF0b3I+Pm11dGF0b3JPZkNvbXBvbmVudFtjb21wb25lbnROYW1lXSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgbXV0YXRvcldpdGhDb21wb25lbnROYW1lOiBNdXRhdG9yID0gPE11dGF0b3I+bXV0YXRvckFycmF5WytpXTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGNuYW1lIGluIG11dGF0b3JXaXRoQ29tcG9uZW50TmFtZSkgeyAgIC8vIHRyaWNrIHVzZWQgdG8gZ2V0IHRoZSBvbmx5IGVudHJ5IGluIHRoZSBsaXN0XHJcbiAgICAgICAgICAgICAgICAgIGxldCBtdXRhdG9yVG9HaXZlOiBNdXRhdG9yID0gPE11dGF0b3I+bXV0YXRvcldpdGhDb21wb25lbnROYW1lW2NuYW1lXTtcclxuICAgICAgICAgICAgICAgICAgY29tcG9uZW50VG9NdXRhdGUubXV0YXRlKG11dGF0b3JUb0dpdmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoX211dGF0b3IuY2hpbGRyZW4pIHtcclxuICAgICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgKDxBcnJheTxPYmplY3Q+Pl9tdXRhdG9yLmNoaWxkcmVuKS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgbGV0IG5hbWU6IHN0cmluZyA9ICg8Tm9kZT4oPEFycmF5PE11dGF0b3I+Pl9tdXRhdG9yLmNoaWxkcmVuKVtpXVtcIsaSLk5vZGVcIl0pLm5hbWU7XHJcbiAgICAgICAgICBsZXQgY2hpbGROb2RlczogTm9kZVtdID0gdGhpcy5nZXRDaGlsZHJlbkJ5TmFtZShuYW1lKTtcclxuICAgICAgICAgIGZvciAobGV0IGNoaWxkTm9kZSBvZiBjaGlsZE5vZGVzKSB7XHJcbiAgICAgICAgICAgIGNoaWxkTm9kZS5hcHBseUFuaW1hdGlvbig8TXV0YXRvcj4oPEFycmF5PE11dGF0b3I+Pl9tdXRhdG9yLmNoaWxkcmVuKVtpXVtcIsaSLk5vZGVcIl0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vICNyZWdpb24gQ29tcG9uZW50c1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgY29tcG9uZW50cyBhdHRhY2hlZCB0byB0aGlzIG5vZGUsIGluZGVwZW5kZW50IG9mIHR5cGUuIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0QWxsQ29tcG9uZW50cygpOiBDb21wb25lbnRbXSB7XHJcbiAgICAgIGxldCBhbGw6IENvbXBvbmVudFtdID0gW107XHJcbiAgICAgIGZvciAobGV0IHR5cGUgaW4gdGhpcy5jb21wb25lbnRzKSB7XHJcbiAgICAgICAgYWxsID0gYWxsLmNvbmNhdCh0aGlzLmNvbXBvbmVudHNbdHlwZV0pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBhbGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIGxpc3Qgb2YgY29tcG9uZW50cyBvZiB0aGUgZ2l2ZW4gY2xhc3MgYXR0YWNoZWQgdG8gdGhpcyBub2RlLiBcclxuICAgICAqIEBwYXJhbSBfY2xhc3MgVGhlIGNsYXNzIG9mIHRoZSBjb21wb25lbnRzIHRvIGJlIGZvdW5kLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Q29tcG9uZW50czxUIGV4dGVuZHMgQ29tcG9uZW50PihfY2xhc3M6IG5ldyAoKSA9PiBUKTogVFtdIHtcclxuICAgICAgcmV0dXJuIDxUW10+KHRoaXMuY29tcG9uZW50c1tfY2xhc3MubmFtZV0gfHwgW10pLnNsaWNlKDApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBjb21wb250ZW50IGZvdW5kIG9mIHRoZSBnaXZlbiBjbGFzcyBhdHRhY2hlZCB0aGlzIG5vZGUgb3IgbnVsbCwgaWYgbGlzdCBpcyBlbXB0eSBvciBkb2Vzbid0IGV4aXN0XHJcbiAgICAgKiBAcGFyYW0gX2NsYXNzIFRoZSBjbGFzcyBvZiB0aGUgY29tcG9uZW50cyB0byBiZSBmb3VuZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldENvbXBvbmVudDxUIGV4dGVuZHMgQ29tcG9uZW50PihfY2xhc3M6IG5ldyAoKSA9PiBUKTogVCB7XHJcbiAgICAgIGxldCBsaXN0OiBUW10gPSA8VFtdPnRoaXMuY29tcG9uZW50c1tfY2xhc3MubmFtZV07XHJcbiAgICAgIGlmIChsaXN0KVxyXG4gICAgICAgIHJldHVybiBsaXN0WzBdO1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdGhlIHN1cHBsaWVkIGNvbXBvbmVudCBpbnRvIHRoZSBub2RlcyBjb21wb25lbnQgbWFwLlxyXG4gICAgICogQHBhcmFtIF9jb21wb25lbnQgVGhlIGNvbXBvbmVudCB0byBiZSBwdXNoZWQgaW50byB0aGUgYXJyYXkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhZGRDb21wb25lbnQoX2NvbXBvbmVudDogQ29tcG9uZW50KTogdm9pZCB7XHJcbiAgICAgIGlmIChfY29tcG9uZW50LmdldENvbnRhaW5lcigpID09IHRoaXMpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBsZXQgY21wTGlzdDogQ29tcG9uZW50W10gPSB0aGlzLmNvbXBvbmVudHNbX2NvbXBvbmVudC50eXBlXTtcclxuICAgICAgaWYgKGNtcExpc3QgPT09IHVuZGVmaW5lZClcclxuICAgICAgICB0aGlzLmNvbXBvbmVudHNbX2NvbXBvbmVudC50eXBlXSA9IFtfY29tcG9uZW50XTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIGlmIChjbXBMaXN0Lmxlbmd0aCAmJiBfY29tcG9uZW50LmlzU2luZ2xldG9uKVxyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29tcG9uZW50IGlzIG1hcmtlZCBzaW5nbGV0b24gYW5kIGNhbid0IGJlIGF0dGFjaGVkLCBubyBtb3JlIHRoYW4gb25lIGFsbG93ZWRcIik7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgY21wTGlzdC5wdXNoKF9jb21wb25lbnQpO1xyXG5cclxuICAgICAgX2NvbXBvbmVudC5zZXRDb250YWluZXIodGhpcyk7XHJcbiAgICAgIF9jb21wb25lbnQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuQ09NUE9ORU5UX0FERCkpO1xyXG4gICAgfVxyXG4gICAgLyoqIFxyXG4gICAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gY29tcG9uZW50IGZyb20gdGhlIG5vZGUsIGlmIGl0IHdhcyBhdHRhY2hlZCwgYW5kIHNldHMgaXRzIHBhcmVudCB0byBudWxsLiBcclxuICAgICAqIEBwYXJhbSBfY29tcG9uZW50IFRoZSBjb21wb25lbnQgdG8gYmUgcmVtb3ZlZFxyXG4gICAgICogQHRocm93cyBFeGNlcHRpb24gd2hlbiBjb21wb25lbnQgaXMgbm90IGZvdW5kXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZW1vdmVDb21wb25lbnQoX2NvbXBvbmVudDogQ29tcG9uZW50KTogdm9pZCB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgbGV0IGNvbXBvbmVudHNPZlR5cGU6IENvbXBvbmVudFtdID0gdGhpcy5jb21wb25lbnRzW19jb21wb25lbnQudHlwZV07XHJcbiAgICAgICAgbGV0IGZvdW5kQXQ6IG51bWJlciA9IGNvbXBvbmVudHNPZlR5cGUuaW5kZXhPZihfY29tcG9uZW50KTtcclxuICAgICAgICBpZiAoZm91bmRBdCA8IDApXHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgX2NvbXBvbmVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVC5DT01QT05FTlRfUkVNT1ZFKSk7XHJcbiAgICAgICAgY29tcG9uZW50c09mVHlwZS5zcGxpY2UoZm91bmRBdCwgMSk7XHJcbiAgICAgICAgX2NvbXBvbmVudC5zZXRDb250YWluZXIobnVsbCk7XHJcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHJlbW92ZSBjb21wb25lbnQgJyR7X2NvbXBvbmVudH0naW4gbm9kZSBuYW1lZCAnJHt0aGlzLm5hbWV9J2ApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyAjZW5kcmVnaW9uXHJcblxyXG4gICAgLy8gI3JlZ2lvbiBTZXJpYWxpemF0aW9uXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHtcclxuICAgICAgICBuYW1lOiB0aGlzLm5hbWVcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGxldCBjb21wb25lbnRzOiBTZXJpYWxpemF0aW9uID0ge307XHJcbiAgICAgIGZvciAobGV0IHR5cGUgaW4gdGhpcy5jb21wb25lbnRzKSB7XHJcbiAgICAgICAgY29tcG9uZW50c1t0eXBlXSA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGNvbXBvbmVudCBvZiB0aGlzLmNvbXBvbmVudHNbdHlwZV0pIHtcclxuICAgICAgICAgIC8vIGNvbXBvbmVudHNbdHlwZV0ucHVzaChjb21wb25lbnQuc2VyaWFsaXplKCkpO1xyXG4gICAgICAgICAgY29tcG9uZW50c1t0eXBlXS5wdXNoKFNlcmlhbGl6ZXIuc2VyaWFsaXplKGNvbXBvbmVudCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBzZXJpYWxpemF0aW9uW1wiY29tcG9uZW50c1wiXSA9IGNvbXBvbmVudHM7XHJcblxyXG4gICAgICBsZXQgY2hpbGRyZW46IFNlcmlhbGl6YXRpb25bXSA9IFtdO1xyXG4gICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgY2hpbGRyZW4ucHVzaChTZXJpYWxpemVyLnNlcmlhbGl6ZShjaGlsZCkpO1xyXG4gICAgICB9XHJcbiAgICAgIHNlcmlhbGl6YXRpb25bXCJjaGlsZHJlblwiXSA9IGNoaWxkcmVuO1xyXG5cclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVC5OT0RFX1NFUklBTElaRUQpKTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogU2VyaWFsaXphYmxlIHtcclxuICAgICAgdGhpcy5uYW1lID0gX3NlcmlhbGl6YXRpb24ubmFtZTtcclxuICAgICAgLy8gdGhpcy5wYXJlbnQgPSBpcyBzZXQgd2hlbiB0aGUgbm9kZXMgYXJlIGFkZGVkXHJcblxyXG4gICAgICAvLyBkZXNlcmlhbGl6ZSBjb21wb25lbnRzIGZpcnN0IHNvIHNjcmlwdHMgY2FuIHJlYWN0IHRvIGNoaWxkcmVuIGJlaW5nIGFwcGVuZGVkXHJcbiAgICAgIGZvciAobGV0IHR5cGUgaW4gX3NlcmlhbGl6YXRpb24uY29tcG9uZW50cykge1xyXG4gICAgICAgIGZvciAobGV0IHNlcmlhbGl6ZWRDb21wb25lbnQgb2YgX3NlcmlhbGl6YXRpb24uY29tcG9uZW50c1t0eXBlXSkge1xyXG4gICAgICAgICAgbGV0IGRlc2VyaWFsaXplZENvbXBvbmVudDogQ29tcG9uZW50ID0gPENvbXBvbmVudD5TZXJpYWxpemVyLmRlc2VyaWFsaXplKHNlcmlhbGl6ZWRDb21wb25lbnQpO1xyXG4gICAgICAgICAgdGhpcy5hZGRDb21wb25lbnQoZGVzZXJpYWxpemVkQ29tcG9uZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAobGV0IHNlcmlhbGl6ZWRDaGlsZCBvZiBfc2VyaWFsaXphdGlvbi5jaGlsZHJlbikge1xyXG4gICAgICAgIGxldCBkZXNlcmlhbGl6ZWRDaGlsZDogTm9kZSA9IDxOb2RlPlNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoc2VyaWFsaXplZENoaWxkKTtcclxuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGRlc2VyaWFsaXplZENoaWxkKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVC5OT0RFX0RFU0VSSUFMSVpFRCkpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8vICNlbmRyZWdpb25cclxuXHJcbiAgICAvLyAjcmVnaW9uIEV2ZW50c1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBub2RlLiBUaGUgZ2l2ZW4gaGFuZGxlciB3aWxsIGJlIGNhbGxlZCB3aGVuIGEgbWF0Y2hpbmcgZXZlbnQgaXMgcGFzc2VkIHRvIHRoZSBub2RlLlxyXG4gICAgICogRGV2aWF0aW5nIGZyb20gdGhlIHN0YW5kYXJkIEV2ZW50VGFyZ2V0LCBoZXJlIHRoZSBfaGFuZGxlciBtdXN0IGJlIGEgZnVuY3Rpb24gYW5kIF9jYXB0dXJlIGlzIHRoZSBvbmx5IG9wdGlvbi5cclxuICAgICAqIEBwYXJhbSBfdHlwZSBUaGUgdHlwZSBvZiB0aGUgZXZlbnQsIHNob3VsZCBiZSBhbiBlbnVtZXJhdGVkIHZhbHVlIG9mIE5PREVfRVZFTlQsIGNhbiBiZSBhbnkgc3RyaW5nXHJcbiAgICAgKiBAcGFyYW0gX2hhbmRsZXIgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgZXZlbnQgcmVhY2hlcyB0aGlzIG5vZGVcclxuICAgICAqIEBwYXJhbSBfY2FwdHVyZSBXaGVuIHRydWUsIHRoZSBsaXN0ZW5lciBsaXN0ZW5zIGluIHRoZSBjYXB0dXJlIHBoYXNlLCB3aGVuIHRoZSBldmVudCB0cmF2ZWxzIGRlZXBlciBpbnRvIHRoZSBoaWVyYXJjaHkgb2Ygbm9kZXMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhZGRFdmVudExpc3RlbmVyKF90eXBlOiBFVkVOVCB8IHN0cmluZywgX2hhbmRsZXI6IEV2ZW50TGlzdGVuZXIsIF9jYXB0dXJlOiBib29sZWFuIC8qfCBBZGRFdmVudExpc3RlbmVyT3B0aW9ucyovID0gZmFsc2UpOiB2b2lkIHtcclxuICAgICAgbGV0IGxpc3RMaXN0ZW5lcnM6IE1hcEV2ZW50VHlwZVRvTGlzdGVuZXIgPSBfY2FwdHVyZSA/IHRoaXMuY2FwdHVyZXMgOiB0aGlzLmxpc3RlbmVycztcclxuICAgICAgaWYgKCFsaXN0TGlzdGVuZXJzW190eXBlXSlcclxuICAgICAgICBsaXN0TGlzdGVuZXJzW190eXBlXSA9IFtdO1xyXG4gICAgICBsaXN0TGlzdGVuZXJzW190eXBlXS5wdXNoKF9oYW5kbGVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbiBldmVudCBsaXN0ZW5lciBmcm9tIHRoZSBub2RlLiBUaGUgc2lnbmF0dXIgbXVzdCBtYXRjaCB0aGUgb25lIHVzZWQgd2l0aCBhZGRFdmVudExpc3RlbmVyXHJcbiAgICAgKiBAcGFyYW0gX3R5cGUgVGhlIHR5cGUgb2YgdGhlIGV2ZW50LCBzaG91bGQgYmUgYW4gZW51bWVyYXRlZCB2YWx1ZSBvZiBOT0RFX0VWRU5ULCBjYW4gYmUgYW55IHN0cmluZ1xyXG4gICAgICogQHBhcmFtIF9oYW5kbGVyIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGV2ZW50IHJlYWNoZXMgdGhpcyBub2RlXHJcbiAgICAgKiBAcGFyYW0gX2NhcHR1cmUgV2hlbiB0cnVlLCB0aGUgbGlzdGVuZXIgbGlzdGVucyBpbiB0aGUgY2FwdHVyZSBwaGFzZSwgd2hlbiB0aGUgZXZlbnQgdHJhdmVscyBkZWVwZXIgaW50byB0aGUgaGllcmFyY2h5IG9mIG5vZGVzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVtb3ZlRXZlbnRMaXN0ZW5lcihfdHlwZTogRVZFTlQgfCBzdHJpbmcsIF9oYW5kbGVyOiBFdmVudExpc3RlbmVyLCBfY2FwdHVyZTogYm9vbGVhbiAvKnwgQWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMqLyA9IGZhbHNlKTogdm9pZCB7XHJcbiAgICAgIGxldCBsaXN0ZW5lcnNGb3JUeXBlOiBFdmVudExpc3RlbmVyW10gPSBfY2FwdHVyZSA/IHRoaXMuY2FwdHVyZXNbX3R5cGVdIDogdGhpcy5saXN0ZW5lcnNbX3R5cGVdO1xyXG4gICAgICBpZiAobGlzdGVuZXJzRm9yVHlwZSlcclxuICAgICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSBsaXN0ZW5lcnNGb3JUeXBlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxyXG4gICAgICAgICAgaWYgKGxpc3RlbmVyc0ZvclR5cGVbaV0gPT0gX2hhbmRsZXIpXHJcbiAgICAgICAgICAgIGxpc3RlbmVyc0ZvclR5cGUuc3BsaWNlKGksIDEpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwYXRjaGVzIGEgc3ludGhldGljIGV2ZW50IHRvIHRhcmdldC4gVGhpcyBpbXBsZW1lbnRhdGlvbiBhbHdheXMgcmV0dXJucyB0cnVlIChzdGFuZGFyZDogcmV0dXJuIHRydWUgb25seSBpZiBlaXRoZXIgZXZlbnQncyBjYW5jZWxhYmxlIGF0dHJpYnV0ZSB2YWx1ZSBpcyBmYWxzZSBvciBpdHMgcHJldmVudERlZmF1bHQoKSBtZXRob2Qgd2FzIG5vdCBpbnZva2VkKVxyXG4gICAgICogVGhlIGV2ZW50IHRyYXZlbHMgaW50byB0aGUgaGllcmFyY2h5IHRvIHRoaXMgbm9kZSBkaXNwYXRjaGluZyB0aGUgZXZlbnQsIGludm9raW5nIG1hdGNoaW5nIGhhbmRsZXJzIG9mIHRoZSBub2RlcyBhbmNlc3RvcnMgbGlzdGVuaW5nIHRvIHRoZSBjYXB0dXJlIHBoYXNlLCBcclxuICAgICAqIHRoYW4gdGhlIG1hdGNoaW5nIGhhbmRsZXIgb2YgdGhlIHRhcmdldCBub2RlIGluIHRoZSB0YXJnZXQgcGhhc2UsIGFuZCBiYWNrIG91dCBvZiB0aGUgaGllcmFyY2h5IGluIHRoZSBidWJibGluZyBwaGFzZSwgaW52b2tpbmcgYXBwcm9wcmlhdGUgaGFuZGxlcnMgb2YgdGhlIGFudmVzdG9yc1xyXG4gICAgICogQHBhcmFtIF9ldmVudCBUaGUgZXZlbnQgdG8gZGlzcGF0Y2hcclxuICAgICAqL1xyXG4gICAgcHVibGljIGRpc3BhdGNoRXZlbnQoX2V2ZW50OiBFdmVudCk6IGJvb2xlYW4ge1xyXG4gICAgICBsZXQgYW5jZXN0b3JzOiBOb2RlW10gPSBbXTtcclxuICAgICAgbGV0IHVwY29taW5nOiBOb2RlID0gdGhpcztcclxuICAgICAgLy8gb3ZlcndyaXRlIGV2ZW50IHRhcmdldFxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V2ZW50LCBcInRhcmdldFwiLCB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogdGhpcyB9KTtcclxuICAgICAgLy8gVE9ETzogY29uc2lkZXIgdXNpbmcgUmVmbGVjdCBpbnN0ZWFkIG9mIE9iamVjdCB0aHJvdWdob3V0LiBTZWUgYWxzbyBSZW5kZXIgYW5kIE11dGFibGUuLi5cclxuICAgICAgd2hpbGUgKHVwY29taW5nLnBhcmVudClcclxuICAgICAgICBhbmNlc3RvcnMucHVzaCh1cGNvbWluZyA9IHVwY29taW5nLnBhcmVudCk7XHJcblxyXG4gICAgICAvLyBjYXB0dXJlIHBoYXNlXHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXZlbnQsIFwiZXZlbnRQaGFzZVwiLCB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogRXZlbnQuQ0FQVFVSSU5HX1BIQVNFIH0pO1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSBhbmNlc3RvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICBsZXQgYW5jZXN0b3I6IE5vZGUgPSBhbmNlc3RvcnNbaV07XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9ldmVudCwgXCJjdXJyZW50VGFyZ2V0XCIsIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBhbmNlc3RvciB9KTtcclxuICAgICAgICBsZXQgY2FwdHVyZXM6IEV2ZW50TGlzdGVuZXJbXSA9IGFuY2VzdG9yLmNhcHR1cmVzW19ldmVudC50eXBlXSB8fCBbXTtcclxuICAgICAgICBmb3IgKGxldCBoYW5kbGVyIG9mIGNhcHR1cmVzKVxyXG4gICAgICAgICAgaGFuZGxlcihfZXZlbnQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIV9ldmVudC5idWJibGVzKVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgLy8gdGFyZ2V0IHBoYXNlXHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXZlbnQsIFwiZXZlbnRQaGFzZVwiLCB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogRXZlbnQuQVRfVEFSR0VUIH0pO1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V2ZW50LCBcImN1cnJlbnRUYXJnZXRcIiwgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHRoaXMgfSk7XHJcbiAgICAgIGxldCBsaXN0ZW5lcnM6IEV2ZW50TGlzdGVuZXJbXSA9IHRoaXMubGlzdGVuZXJzW19ldmVudC50eXBlXSB8fCBbXTtcclxuICAgICAgZm9yIChsZXQgaGFuZGxlciBvZiBsaXN0ZW5lcnMpXHJcbiAgICAgICAgaGFuZGxlcihfZXZlbnQpO1xyXG5cclxuICAgICAgLy8gYnViYmxlIHBoYXNlXHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXZlbnQsIFwiZXZlbnRQaGFzZVwiLCB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogRXZlbnQuQlVCQkxJTkdfUEhBU0UgfSk7XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBhbmNlc3RvcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgYW5jZXN0b3I6IE5vZGUgPSBhbmNlc3RvcnNbaV07XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9ldmVudCwgXCJjdXJyZW50VGFyZ2V0XCIsIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBhbmNlc3RvciB9KTtcclxuICAgICAgICBsZXQgbGlzdGVuZXJzOiBGdW5jdGlvbltdID0gYW5jZXN0b3IubGlzdGVuZXJzW19ldmVudC50eXBlXSB8fCBbXTtcclxuICAgICAgICBmb3IgKGxldCBoYW5kbGVyIG9mIGxpc3RlbmVycylcclxuICAgICAgICAgIGhhbmRsZXIoX2V2ZW50KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdHJ1ZTsgLy9UT0RPOiByZXR1cm4gYSBtZWFuaW5nZnVsIHZhbHVlLCBzZWUgZG9jdW1lbnRhdGlvbiBvZiBkaXNwYXRjaCBldmVudFxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBCcm9hZGNhc3RzIGEgc3ludGhldGljIGV2ZW50IHRvIHRoaXMgbm9kZSBhbmQgZnJvbSB0aGVyZSB0byBhbGwgbm9kZXMgZGVlcGVyIGluIHRoZSBoaWVyYXJjaHksXHJcbiAgICAgKiBpbnZva2luZyBtYXRjaGluZyBoYW5kbGVycyBvZiB0aGUgbm9kZXMgbGlzdGVuaW5nIHRvIHRoZSBjYXB0dXJlIHBoYXNlLiBXYXRjaCBwZXJmb3JtYW5jZSB3aGVuIHRoZXJlIGFyZSBtYW55IG5vZGVzIGludm9sdmVkXHJcbiAgICAgKiBAcGFyYW0gX2V2ZW50IFRoZSBldmVudCB0byBicm9hZGNhc3RcclxuICAgICAqL1xyXG4gICAgcHVibGljIGJyb2FkY2FzdEV2ZW50KF9ldmVudDogRXZlbnQpOiB2b2lkIHtcclxuICAgICAgLy8gb3ZlcndyaXRlIGV2ZW50IHRhcmdldCBhbmQgcGhhc2VcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9ldmVudCwgXCJldmVudFBoYXNlXCIsIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBFdmVudC5DQVBUVVJJTkdfUEhBU0UgfSk7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXZlbnQsIFwidGFyZ2V0XCIsIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB0aGlzIH0pO1xyXG4gICAgICB0aGlzLmJyb2FkY2FzdEV2ZW50UmVjdXJzaXZlKF9ldmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBicm9hZGNhc3RFdmVudFJlY3Vyc2l2ZShfZXZlbnQ6IEV2ZW50KTogdm9pZCB7XHJcbiAgICAgIC8vIGNhcHR1cmUgcGhhc2Ugb25seVxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V2ZW50LCBcImN1cnJlbnRUYXJnZXRcIiwgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHRoaXMgfSk7XHJcbiAgICAgIGxldCBjYXB0dXJlczogRnVuY3Rpb25bXSA9IHRoaXMuY2FwdHVyZXNbX2V2ZW50LnR5cGVdIHx8IFtdO1xyXG4gICAgICBmb3IgKGxldCBoYW5kbGVyIG9mIGNhcHR1cmVzKVxyXG4gICAgICAgIGhhbmRsZXIoX2V2ZW50KTtcclxuICAgICAgLy8gYXBwZWFycyB0byBiZSBzbG93ZXIsIGFzdG9uaXNoaW5nbHkuLi5cclxuICAgICAgLy8gY2FwdHVyZXMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcjogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgLy8gICAgIGhhbmRsZXIoX2V2ZW50KTtcclxuICAgICAgLy8gfSk7XHJcblxyXG4gICAgICAvLyBzYW1lIGZvciBjaGlsZHJlblxyXG4gICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgY2hpbGQuYnJvYWRjYXN0RXZlbnRSZWN1cnNpdmUoX2V2ZW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gI2VuZHJlZ2lvblxyXG5cclxuICAgIHByaXZhdGUgKiBnZXRHcmFwaEdlbmVyYXRvcigpOiBJdGVyYWJsZUl0ZXJhdG9yPE5vZGU+IHtcclxuICAgICAgeWllbGQgdGhpcztcclxuICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbilcclxuICAgICAgICB5aWVsZCogY2hpbGQuZ3JhcGg7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQSBub2RlIG1hbmFnZWQgYnkgW1tSZXNvdXJjZU1hbmFnZXJdXSB0aGF0IGZ1bmN0aW9ucyBhcyBhIHRlbXBsYXRlIGZvciBbW05vZGVSZXNvdXJjZUluc3RhbmNlXV1zIFxyXG4gICAqIEBhdXRob3IgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vSmlya2FEZWxsT3JvL0ZVREdFL3dpa2kvUmVzb3VyY2VcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgTm9kZVJlc291cmNlIGV4dGVuZHMgTm9kZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZVJlc291cmNlIHtcclxuICAgIHB1YmxpYyBpZFJlc291cmNlOiBzdHJpbmcgPSB1bmRlZmluZWQ7XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQW4gaW5zdGFuY2Ugb2YgYSBbW05vZGVSZXNvdXJjZV1dLiAgXHJcbiAgICogVGhpcyBub2RlIGtlZXBzIGEgcmVmZXJlbmNlIHRvIGl0cyByZXNvdXJjZSBhbiBjYW4gdGh1cyBvcHRpbWl6ZSBzZXJpYWxpemF0aW9uXHJcbiAgICogQGF1dGhvciBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9KaXJrYURlbGxPcm8vRlVER0Uvd2lraS9SZXNvdXJjZVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBOb2RlUmVzb3VyY2VJbnN0YW5jZSBleHRlbmRzIE5vZGUge1xyXG4gICAgLyoqIGlkIG9mIHRoZSByZXNvdXJjZSB0aGF0IGluc3RhbmNlIHdhcyBjcmVhdGVkIGZyb20gKi9cclxuICAgIC8vIFRPRE86IGV4YW1pbmUsIGlmIHRoaXMgc2hvdWxkIGJlIGEgZGlyZWN0IHJlZmVyZW5jZSB0byB0aGUgTm9kZVJlc291cmNlLCBpbnN0ZWFkIG9mIHRoZSBpZFxyXG4gICAgcHJpdmF0ZSBpZFNvdXJjZTogc3RyaW5nID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKF9ub2RlUmVzb3VyY2U6IE5vZGVSZXNvdXJjZSkge1xyXG4gICAgICBzdXBlcihcIk5vZGVSZXNvdXJjZUluc3RhbmNlXCIpO1xyXG4gICAgICBpZiAoX25vZGVSZXNvdXJjZSlcclxuICAgICAgICB0aGlzLnNldChfbm9kZVJlc291cmNlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlY3JlYXRlIHRoaXMgbm9kZSBmcm9tIHRoZSBbW05vZGVSZXNvdXJjZV1dIHJlZmVyZW5jZWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xyXG4gICAgICBsZXQgcmVzb3VyY2U6IE5vZGVSZXNvdXJjZSA9IDxOb2RlUmVzb3VyY2U+UmVzb3VyY2VNYW5hZ2VyLmdldCh0aGlzLmlkU291cmNlKTtcclxuICAgICAgdGhpcy5zZXQocmVzb3VyY2UpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vVE9ETzogb3B0aW1pemUgdXNpbmcgdGhlIHJlZmVyZW5jZWQgTm9kZVJlc291cmNlLCBzZXJpYWxpemUvZGVzZXJpYWxpemUgb25seSB0aGUgZGlmZmVyZW5jZXNcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24uaWRTb3VyY2UgPSB0aGlzLmlkU291cmNlO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBTZXJpYWxpemFibGUge1xyXG4gICAgICBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIHRoaXMuaWRTb3VyY2UgPSBfc2VyaWFsaXphdGlvbi5pZFNvdXJjZTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhpcyBub2RlIHRvIGJlIGEgcmVjcmVhdGlvbiBvZiB0aGUgW1tOb2RlUmVzb3VyY2VdXSBnaXZlblxyXG4gICAgICogQHBhcmFtIF9ub2RlUmVzb3VyY2VcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzZXQoX25vZGVSZXNvdXJjZTogTm9kZVJlc291cmNlKTogdm9pZCB7XHJcbiAgICAgIC8vIFRPRE86IGV4YW1pbmUsIGlmIHRoZSBzZXJpYWxpemF0aW9uIHNob3VsZCBiZSBzdG9yZWQgaW4gdGhlIE5vZGVSZXNvdXJjZSBmb3Igb3B0aW1pemF0aW9uXHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gU2VyaWFsaXplci5zZXJpYWxpemUoX25vZGVSZXNvdXJjZSk7XHJcbiAgICAgIC8vU2VyaWFsaXplci5kZXNlcmlhbGl6ZShzZXJpYWxpemF0aW9uKTtcclxuICAgICAgZm9yIChsZXQgcGF0aCBpbiBzZXJpYWxpemF0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZShzZXJpYWxpemF0aW9uW3BhdGhdKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmlkU291cmNlID0gX25vZGVSZXNvdXJjZS5pZFJlc291cmNlO1xyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULk5PREVSRVNPVVJDRV9JTlNUQU5USUFURUQpKTtcclxuICAgIH1cclxuXHJcblxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG5cclxuICAvKipcclxuICAgKiBAY2xhc3MgRmFjdG9yeSBjbGFzcyB0byBjcmVhdGUgY2xvc3VyZXMuXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIENsb3N1cmVGYWN0b3J5IHtcclxuICAgIHByaXZhdGUgc3RhdGljIGNsb3N1cmVzOiB7IFtrZXk6IHN0cmluZ106IEZ1bmN0aW9uIH0gPSB7XHJcbiAgICAgIFwiYWRkaXRpb25cIjogQ2xvc3VyZUZhY3RvcnkuY3JlYXRlQ2xvc3VyZUFkZGl0aW9uLFxyXG4gICAgICBcIm11bHRpcGxpY2F0aW9uXCI6IENsb3N1cmVGYWN0b3J5LmNyZWF0ZUNsb3N1cmVNdWx0aXBsaWNhdGlvbixcclxuICAgICAgXCJkaXZpc2lvblwiOiBDbG9zdXJlRmFjdG9yeS5jcmVhdGVDbG9zdXJlRGl2aXNpb24sXHJcbiAgICAgIFwibW9kdWxvXCI6IENsb3N1cmVGYWN0b3J5LmNyZWF0ZUNsb3N1cmVNb2R1bG8sXHJcbiAgICAgIFwibGluZWFyXCI6IENsb3N1cmVGYWN0b3J5LmNyZWF0ZUNsb3N1cmVMaW5lYXIsXHJcbiAgICAgIFwicG9seW5vbWlhbFwiOiBDbG9zdXJlRmFjdG9yeS5jcmVhdGVDbG9zdXJlUG9seW5vbWlhbDMsXHJcbiAgICAgIFwic3F1YXJlUm9vdFwiOiBDbG9zdXJlRmFjdG9yeS5jcmVhdGVDbG9zdXJlU3F1YXJlUm9vdCxcclxuICAgICAgXCJyYW5kb21cIjogQ2xvc3VyZUZhY3RvcnkuY3JlYXRlQ2xvc3VyZVJhbmRvbSxcclxuICAgICAgXCJpZGVudGl0eVwiOiBDbG9zdXJlRmFjdG9yeS5jcmVhdGVDbG9zdXJlSWRlbnRpdHksXHJcbiAgICAgIFwic3VidHJhY3Rpb25cIjogQ2xvc3VyZUZhY3RvcnkuY3JlYXRlQ2xvc3VyZVN1YnRyYWN0aW9uXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGNsb3N1cmUgZm9yIHRoZSBnaXZlbiBmdW5jdGlvbiB0eXBlIGFuZCB0aGUgcGFyYW1ldGVycy5cclxuICAgICAqIEBwYXJhbSBfZnVuY3Rpb24gdGhlIGZ1bmN0aW9uIHR5cGUgb2YgdGhlIGNsb3N1cmUgeW91IHdhbnQgdG8gY3JlYXRlLlxyXG4gICAgICogQHBhcmFtIF9wYXJhbWV0ZXJzIHRoZSBwYXJhbWV0ZXJzLCB3aGljaCBzaG91bGQgYmUgZnVuY3Rpb25zIHRoZW1zZWx2ZXMsIGdpdmVuIHRvIHRoZSBjcmVhdGVkIGNsb3N1cmUuXHJcbiAgICAgKiBAcmV0dXJucyBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXRDbG9zdXJlKF9mdW5jdGlvbjogc3RyaW5nLCBfcGFyYW1ldGVyczogRnVuY3Rpb25bXS8qLCBfaW5wdXRGYWN0b3JzPzogeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfSwgX3JhbmRvbU51bWJlcnM/OiBudW1iZXJbXSovKTogRnVuY3Rpb24ge1xyXG4gICAgICBsZXQgY2xvc3VyZTogRnVuY3Rpb24gPSB0aGlzLmNsb3N1cmVzW19mdW5jdGlvbl07XHJcbiAgICAgIGlmIChfZnVuY3Rpb24gaW4gdGhpcy5jbG9zdXJlcylcclxuICAgICAgICByZXR1cm4gY2xvc3VyZShfcGFyYW1ldGVycyk7XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIERlYnVnLmVycm9yKGBcIiR7X2Z1bmN0aW9ufVwiIGlzIG5vdCBhbiBvcGVyYXRpb25gKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHByaXZhdGUgc3RhdGljIGNyZWF0ZUNsb3N1cmVzKCk6IE1hcDxDTE9TVVJFX1RZUEUsIEZ1bmN0aW9uPiB7XHJcbiAgICAvLyAgIHJldHVybiBuZXcgTWFwPENMT1NVUkVfVFlQRSwgRnVuY3Rpb24+KFtcclxuICAgIC8vICAgICBbQ0xPU1VSRV9UWVBFLkFERElUSU9OLCB0aGlzLmNyZWF0ZUNsb3N1cmVBZGRpdGlvbl0sXHJcbiAgICAvLyAgICAgW0NMT1NVUkVfVFlQRS5NVUxUSVBMSUNBVElPTiwgdGhpcy5jcmVhdGVDbG9zdXJlTXVsdGlwbGljYXRpb25dLFxyXG4gICAgLy8gICAgIFtDTE9TVVJFX1RZUEUuRElWSVNJT04sIHRoaXMuY3JlYXRlQ2xvc3VyZURpdmlzaW9uXSxcclxuICAgIC8vICAgICBbQ0xPU1VSRV9UWVBFLk1PRFVMTywgdGhpcy5jcmVhdGVDbG9zdXJlTW9kdWxvXSxcclxuICAgIC8vICAgICBbQ0xPU1VSRV9UWVBFLkxJTkVBUiwgdGhpcy5jcmVhdGVDbG9zdXJlTGluZWFyXSxcclxuICAgIC8vICAgICBbQ0xPU1VSRV9UWVBFLlBPTFlOT01JQUwzLCB0aGlzLmNyZWF0ZUNsb3N1cmVQb2x5bm9taWFsM10sXHJcbiAgICAvLyAgICAgW0NMT1NVUkVfVFlQRS5SQU5ET00sIHRoaXMuY3JlYXRlQ2xvc3VyZVJhbmRvbV0sXHJcbiAgICAvLyAgIF0pO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgc3VtIG9mIHRoZSBnaXZlbiBwYXJhbWV0ZXJzLlxyXG4gICAgICogIGkuZS4gcGFyYW1ldGVyWzBdICsgLi4uICsgcGFyYW1ldGVyW25dXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIGNyZWF0ZUNsb3N1cmVBZGRpdGlvbihfcGFyYW1ldGVyczogRnVuY3Rpb25bXSk6IEZ1bmN0aW9uIHtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpOiBudW1iZXIge1xyXG4gICAgICAgIERlYnVnLmdyb3VwKFwiQ2xvc3VyZUFkZGl0aW9uXCIpO1xyXG4gICAgICAgIGxldCByZXN1bHQ6IG51bWJlciA9IDA7XHJcbiAgICAgICAgZm9yIChjb25zdCBwYXJhbSBvZiBfcGFyYW1ldGVycykge1xyXG4gICAgICAgICAgcmVzdWx0ICs9IHBhcmFtKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIERlYnVnLmdyb3VwRW5kKCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBzdW0gb2YgdGhlIGdpdmVuIHBhcmFtZXRlcnMuXHJcbiAgICAgKiAgaS5lLiBwYXJhbWV0ZXJbMF0gKyAuLi4gKyBwYXJhbWV0ZXJbbl1cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgY3JlYXRlQ2xvc3VyZVN1YnRyYWN0aW9uKF9wYXJhbWV0ZXJzOiBGdW5jdGlvbltdKTogRnVuY3Rpb24ge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCk6IG51bWJlciB7XHJcbiAgICAgICAgRGVidWcuZ3JvdXAoXCJDbG9zdXJlU3VidHJhY3Rpb25cIik7XHJcbiAgICAgICAgbGV0IHJlc3VsdDogbnVtYmVyID0gX3BhcmFtZXRlcnNbMF0oKSAtIF9wYXJhbWV0ZXJzWzFdKCk7XHJcbiAgICAgICAgRGVidWcuZ3JvdXBFbmQoKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIENhbGN1bGF0ZXMgdGhlIHByb2R1Y3Qgb2YgdGhlIGdpdmVuIHBhcmFtZXRlcnMuIFxyXG4gICAgICAqICAgaS5lLiBwYXJhbWV0ZXJbMF0gKiAuLi4gKiBwYXJhbWV0ZXJbbl1cclxuICAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIGNyZWF0ZUNsb3N1cmVNdWx0aXBsaWNhdGlvbihfcGFyYW1ldGVyczogRnVuY3Rpb25bXSk6IEZ1bmN0aW9uIHtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpOiBudW1iZXIge1xyXG4gICAgICAgIERlYnVnLmxvZyhcIkNsb3N1cmVNdWx0aXBsaWNhdGlvblwiKTtcclxuICAgICAgICBsZXQgcmVzdWx0OiBudW1iZXIgPSAxO1xyXG4gICAgICAgIGZvciAoY29uc3QgcGFyYW0gb2YgX3BhcmFtZXRlcnMpIHtcclxuICAgICAgICAgIHJlc3VsdCAqPSBwYXJhbSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBEZWJ1Zy5ncm91cEVuZCgpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBkaXZpc2lvbiBvZiB0aGUgZ2l2ZW4gcGFyYW1ldGVycy4gXHJcbiAgICAgKiAgaS5lLiBwYXJhbWV0ZXJbMF0gLyBwYXJhbWV0ZXJbMV1cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgY3JlYXRlQ2xvc3VyZURpdmlzaW9uKF9wYXJhbWV0ZXJzOiBGdW5jdGlvbltdKTogRnVuY3Rpb24ge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCk6IG51bWJlciB7XHJcbiAgICAgICAgRGVidWcuZ3JvdXAoXCJDbG9zdXJlRGl2aXNpb25cIik7XHJcbiAgICAgICAgbGV0IHJlc3VsdDogbnVtYmVyID0gX3BhcmFtZXRlcnNbMF0oKSAvIF9wYXJhbWV0ZXJzWzFdKCk7XHJcbiAgICAgICAgRGVidWcuZ3JvdXBFbmQoKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgbW9kdWxvIG9mIHRoZSBnaXZlbiBwYXJhbWV0ZXJzLlxyXG4gICAgICogIGkuZS4gcGFyYW1ldGVyWzBdICUgcGFyYW1ldGVyWzFdXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIGNyZWF0ZUNsb3N1cmVNb2R1bG8oX3BhcmFtZXRlcnM6IEZ1bmN0aW9uW10pOiBGdW5jdGlvbiB7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKTogbnVtYmVyIHtcclxuICAgICAgICBEZWJ1Zy5ncm91cChcIkNsb3N1cmVNb2R1bG9cIik7XHJcbiAgICAgICAgbGV0IHJlc3VsdDogbnVtYmVyID0gX3BhcmFtZXRlcnNbMF0oKSAlIF9wYXJhbWV0ZXJzWzFdKCk7XHJcbiAgICAgICAgRGVidWcuZ3JvdXBFbmQoKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJwb2xhdGVzIGEgbGluZWFyIGZ1bmN0aW9uIGJldHdlZW4gdHdvIGdpdmVuIHBvaW50cy5cclxuICAgICAqICBwYXJhbWV0ZXJbMF0gd2lsbCBiZSB0aGUgaW5wdXQgdmFsdWUgZm9yIHRoZSBmdW5jdGlvbi5cclxuICAgICAqICBwYXJhbWV0ZXJbMV0gLSBwYXJhbWV0ZXJbNF0gZGVzY3JpYmUgdGhlIHBvaW50cyBiZXR3ZWVuIHdoaWNoIHdpbGwgYmUgaW50ZXJwb2xldGVkXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIGNyZWF0ZUNsb3N1cmVMaW5lYXIoX3BhcmFtZXRlcnM6IEZ1bmN0aW9uW10pOiBGdW5jdGlvbiB7XHJcbiAgICAgIGxldCB4U3RhcnQ6IG51bWJlciA9IF9wYXJhbWV0ZXJzWzFdKCk7XHJcbiAgICAgIGxldCB4RW5kOiBudW1iZXIgPSBfcGFyYW1ldGVyc1syXSgpO1xyXG4gICAgICBsZXQgeVN0YXJ0OiBudW1iZXIgPSBfcGFyYW1ldGVyc1szXSgpO1xyXG4gICAgICBsZXQgeUVuZDogbnVtYmVyID0gX3BhcmFtZXRlcnNbNF0oKTtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpOiBudW1iZXIge1xyXG4gICAgICAgIERlYnVnLmdyb3VwKFwiQ2xvc3VyZUxpbmVhclwiKTtcclxuICAgICAgICBsZXQgeDogbnVtYmVyID0gX3BhcmFtZXRlcnNbMF0oKTtcclxuICAgICAgICBsZXQgeTogbnVtYmVyID0geVN0YXJ0ICsgKHggLSB4U3RhcnQpICogKHlFbmQgLSB5U3RhcnQpIC8gKHhFbmQgLSB4U3RhcnQpO1xyXG4gICAgICAgIERlYnVnLmxvZyh4RW5kKTtcclxuICAgICAgICBEZWJ1Zy5ncm91cEVuZCgpO1xyXG4gICAgICAgIHJldHVybiB5O1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHBvbHlub21pYWwgb2YgdGhpcmQgZGVncmVlLlxyXG4gICAgICogIHBhcmFtZXRlclswXSB3aWxsIGJlIHRoZSBpbnB1dCB2YWx1ZSBmb3IgdGhlIGZ1bmN0aW9uLlxyXG4gICAgICogIHBhcmFtZXRlclsxXSAtIHBhcmFtZXRlcls0XSByZXByZXNlbnRpbmcgYSxiLGMsZFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBjcmVhdGVDbG9zdXJlUG9seW5vbWlhbDMoX3BhcmFtZXRlcnM6IEZ1bmN0aW9uW10pOiBGdW5jdGlvbiB7XHJcbiAgICAgIGxldCBhOiBudW1iZXIgPSBfcGFyYW1ldGVyc1sxXSgpO1xyXG4gICAgICBsZXQgYjogbnVtYmVyID0gX3BhcmFtZXRlcnNbMl0oKTtcclxuICAgICAgbGV0IGM6IG51bWJlciA9IF9wYXJhbWV0ZXJzWzNdKCk7XHJcbiAgICAgIGxldCBkOiBudW1iZXIgPSBfcGFyYW1ldGVyc1s0XSgpO1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCk6IG51bWJlciB7XHJcbiAgICAgICAgRGVidWcuZ3JvdXAoXCJDbG9zdXJlUG9seW5vbWlhbDNcIik7XHJcbiAgICAgICAgbGV0IHg6IG51bWJlciA9IF9wYXJhbWV0ZXJzWzBdKCk7XHJcbiAgICAgICAgbGV0IHk6IG51bWJlciA9IGEgKiBNYXRoLnBvdyh4LCAzKSArIGIgKiBNYXRoLnBvdyh4LCAyKSArIGMgKiB4ICsgZDtcclxuICAgICAgICBEZWJ1Zy5ncm91cEVuZCgpO1xyXG4gICAgICAgIHJldHVybiB5O1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGNsb3N1cmUgd2hpY2ggd2lsbCByZXR1cm4gdGhlIHNxdWFyZSByb290IG9mIHRoZSBnaXZlbiBwYXJhbWV0ZXJcclxuICAgICAqICBwYXJhbWV0ZXJbMF0gd2lsbCBiZSB0aGUgaW5wdXQgdmFsdWUgZm9yIHRoZSBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgY3JlYXRlQ2xvc3VyZVNxdWFyZVJvb3QoX3BhcmFtZXRlcnM6IEZ1bmN0aW9uW10pOiBGdW5jdGlvbiB7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKTogbnVtYmVyIHtcclxuICAgICAgICBEZWJ1Zy5ncm91cChcIkNsb3N1cmVTcXVhcmVSb290XCIpO1xyXG4gICAgICAgIGxldCB4OiBudW1iZXIgPSBfcGFyYW1ldGVyc1swXSgpO1xyXG4gICAgICAgIGxldCB5OiBudW1iZXIgPSBNYXRoLnNxcnQoeCk7XHJcbiAgICAgICAgRGVidWcuZ3JvdXBFbmQoKTtcclxuICAgICAgICByZXR1cm4geTtcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBjbG9zdXJlIHdoaWNoIHdpbGwgcmV0dXJuIGEgbnVtYmVyIGNob3NlbiBmcm9tIHRoZSBnaXZlbiBhcnJheSBvZiBudW1iZXJzLlxyXG4gICAgICogIHBhcmFtZXRlclswXSByZXByZXNlbnRpbmcgdGhlIGluZGV4IG9mIHRoZSBudW1iZXIgd2hpY2ggd2lsbCBiZSBjaG9zZW4uXHJcbiAgICAgKiAgcGFyYW1ldGVyWzFdIHJlcHJlc2VudGluZyB0aGUgYXJyYXkgb2YgcmFuZG9tIG51bWJlcnMgdG8gY2hvb3NlIGZyb20uXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIGNyZWF0ZUNsb3N1cmVSYW5kb20oX3BhcmFtZXRlcnM6IEZ1bmN0aW9uW10pOiBGdW5jdGlvbiB7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKTogbnVtYmVyIHtcclxuICAgICAgICBEZWJ1Zy5ncm91cChcIkNsb3N1cmVSYW5kb21cIik7XHJcbiAgICAgICAgbGV0IHJlc3VsdDogbnVtYmVyID0gX3BhcmFtZXRlcnNbMV0oKVtfcGFyYW1ldGVyc1swXSgpXTtcclxuICAgICAgICBEZWJ1Zy5ncm91cEVuZCgpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgY2xvc3VyZSB3aGljaCB3aWxsIHJldHVybiB0aGUgaW5wdXQgdmFsdWVcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgY3JlYXRlQ2xvc3VyZUlkZW50aXR5KF9wYXJhbWV0ZXJzOiBGdW5jdGlvbltdKTogRnVuY3Rpb24ge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCk6IG51bWJlciB7XHJcbiAgICAgICAgRGVidWcuZ3JvdXAoXCJDbG9zdXJlSWRlbnRpdHlcIik7XHJcbiAgICAgICAgbGV0IHJlc3VsdDogbnVtYmVyID0gX3BhcmFtZXRlcnNbMF0oKTtcclxuICAgICAgICBEZWJ1Zy5ncm91cEVuZCgpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGludGVyZmFjZSBQYXJ0aWNsZUVmZmVjdERhdGEge1xyXG4gICAgW2lkZW50aWZpZXI6IHN0cmluZ106IEdlbmVyYWw7XHJcbiAgfVxyXG5cclxuICBpbnRlcmZhY2UgQ2xvc3VyZURhdGFGdW5jdGlvbiB7XHJcbiAgICBmdW5jdGlvbjogc3RyaW5nO1xyXG4gICAgcGFyYW1ldGVyczogQ2xvc3VyZURhdGFbXTtcclxuICB9XHJcbiAgdHlwZSBDbG9zdXJlRGF0YSA9IENsb3N1cmVEYXRhRnVuY3Rpb24gfCBzdHJpbmcgfCBudW1iZXI7XHJcblxyXG4gIGV4cG9ydCBjbGFzcyBQYXJ0aWNsZUVmZmVjdEltcG9ydGVyIHtcclxuICAgIHByaXZhdGUgc3RvcmVkVmFsdWVzOiBTdG9yZWRWYWx1ZXM7XHJcbiAgICBwcml2YXRlIHJhbmRvbU51bWJlcnM6IG51bWJlcltdO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKF9zdG9yZWRWYWx1ZXM6IFN0b3JlZFZhbHVlcywgX3JhbmRvbU51bWJlcnM6IG51bWJlcltdKSB7XHJcbiAgICAgIHRoaXMuc3RvcmVkVmFsdWVzID0gX3N0b3JlZFZhbHVlcztcclxuICAgICAgdGhpcy5yYW5kb21OdW1iZXJzID0gX3JhbmRvbU51bWJlcnM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGltcG9ydEZpbGUoX2ZpbGVuYW1lOiBzdHJpbmcpOiBQYXJ0aWNsZUVmZmVjdERhdGEge1xyXG4gICAgICAvL1RPRE86IGltcG9ydCBmaWxlXHJcbiAgICAgIGxldCBmaWxlOiBYTUxIdHRwUmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICBmaWxlLm9wZW4oXCJHRVRcIiwgX2ZpbGVuYW1lLCBmYWxzZSk7XHJcbiAgICAgIGZpbGUuc2VuZCgpO1xyXG4gICAgICBsZXQgZGF0YTogUGFydGljbGVFZmZlY3REYXRhID0gSlNPTi5wYXJzZShmaWxlLnJlc3BvbnNlVGV4dCk7XHJcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRmlsZShkYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlIHRoZSBkYXRhIGZyb20ganNvbiBmaWxlIGFuZCByZXR1cm4gYSBwYXJ0aWNsZSBlZmZlY3QgZGVmaW5pdGlvblxyXG4gICAgICogQHBhcmFtIF9kYXRhIHRoZSBkYXRhIHRvIHBhcnNlXHJcbiAgICAgKiBAcmV0dXJucyBhIGRlZmluaXRpb24gb2YgdGhlIHBhcnRpY2xlIGVmZmVjdCBjb250YWluaW5nIHRoZSBjbG9zdXJlIGZvciB0cmFuc2xhdGlvbiwgcm90YXRpb24gZXRjLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHBhcnNlRmlsZShfZGF0YTogUGFydGljbGVFZmZlY3REYXRhKTogUGFydGljbGVFZmZlY3REYXRhIHtcclxuICAgICAgLy8gY29uc29sZS5sb2coX2RhdGEpO1xyXG5cclxuICAgICAgLy8gcHJlIHBhcnNlIHN0b3JhZ2UgYW5kIGluaXRpYWxpemUgc3RvcmVkIHZhbHVlc1xyXG4gICAgICB0aGlzLnByZVBhcnNlU3RvcmFnZSg8UGFydGljbGVFZmZlY3REYXRhPl9kYXRhW1wic3RvcmFnZVwiXSk7XHJcblxyXG4gICAgICB0aGlzLnBhcnNlRGF0YVJlY3Vyc2l2ZWx5KF9kYXRhKTtcclxuXHJcbiAgICAgIHJldHVybiBfZGF0YTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgZW50cmllcyBpbiBzdG9yZWQgdmFsdWVzIGZvciBlYWNoIGRlZmluZWQgc3RvcmFnZSBjbG9zdXJlLiBQcmVkZWZpbmVkIHZhbHVlcyAodGltZSwgaW5kZXguLi4pIGFuZCBwcmV2aW91c2x5IGRlZmluZWQgb25lcyAoaW4ganNvbikgY2FuIG5vdCBiZSBvdmVyd3JpdHRlbi5cclxuICAgICAqIEBwYXJhbSBfZGF0YSBUaGUgcGF0aWNsZSBkYXRhIHRvIHBhcnNlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcHJlUGFyc2VTdG9yYWdlKF9kYXRhOiBQYXJ0aWNsZUVmZmVjdERhdGEpOiB2b2lkIHtcclxuICAgICAgZm9yIChjb25zdCBzdG9yYWdlUGFydGl0aW9uIGluIF9kYXRhKSB7XHJcbiAgICAgICAgbGV0IHN0b3JhZ2U6IFBhcnRpY2xlRWZmZWN0RGF0YSA9IDxQYXJ0aWNsZUVmZmVjdERhdGE+X2RhdGFbc3RvcmFnZVBhcnRpdGlvbl07XHJcbiAgICAgICAgZm9yIChjb25zdCBzdG9yYWdlVmFsdWUgaW4gPFBhcnRpY2xlRWZmZWN0RGF0YT5zdG9yYWdlKSB7XHJcbiAgICAgICAgICBpZiAoc3RvcmFnZVZhbHVlIGluIHRoaXMuc3RvcmVkVmFsdWVzKSB7XHJcbiAgICAgICAgICAgIHRocm93IGBcIiR7c3RvcmFnZVZhbHVlfVwiIGlzIGFscmVhZHkgZGVmaW5lZGA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHRoaXMuc3RvcmVkVmFsdWVzW3N0b3JhZ2VWYWx1ZV0gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2UgdGhlIGdpdmVuIGVmZmVjdCBkYXRhIHJlY3Vyc2l2bGV5LiBUaGUgaGllcmFjaHkgb2YgdGhlIGpzb24gZmlsZSB3aWxsIGJlIGtlcHQuIENvbnN0YW50cywgdmFyaWFibGVzKFwidGltZVwiKSBhbmQgZnVuY3Rpb25zIGRlZmluaXRpb25zIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBmdW5jdGlvbnMuXHJcbiAgICAgKiBAcGFyYW0gX2RhdGEgVGhlIGVmZmVjdCBkYXRhIHRvIHBhcnNlIHJlY3Vyc2l2bGV5XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcGFyc2VEYXRhUmVjdXJzaXZlbHkoX2RhdGE6IFBhcnRpY2xlRWZmZWN0RGF0YSk6IHZvaWQge1xyXG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBfZGF0YSkge1xyXG4gICAgICAgIGxldCB2YWx1ZTogT2JqZWN0ID0gX2RhdGFba2V5XTtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCBcImZ1bmN0aW9uXCIgaW4gPFBhcnRpY2xlRWZmZWN0RGF0YT52YWx1ZSlcclxuICAgICAgICAgIF9kYXRhW2tleV0gPSB0aGlzLnBhcnNlQ2xvc3VyZSg8Q2xvc3VyZURhdGE+dmFsdWUpO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5wYXJzZURhdGFSZWN1cnNpdmVseSg8UGFydGljbGVFZmZlY3REYXRhPnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlIHRoZSBnaXZlbiBjbG9zdXJlIGRhdGEgcmVjdXJzaXZsZXkuIFJldHVybnMgYSBmdW5jdGlvbiBkZXBlbmRpbmcgb24gdGhlIGNsb3N1cmUgZGF0YS5cclxuICAgICAqIEBwYXJhbSBfZGF0YSBUaGUgY2xvc3VyZSBkYXRhIHRvIHBhcnNlIHJlY3Vyc2l2ZWx5XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcGFyc2VDbG9zdXJlKF9kYXRhOiBDbG9zdXJlRGF0YSk6IEZ1bmN0aW9uIHtcclxuICAgICAgc3dpdGNoICh0eXBlb2YgX2RhdGEpIHtcclxuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XHJcbiAgICAgICAgICBsZXQgcGFyYW1ldGVyczogRnVuY3Rpb25bXSA9IFtdO1xyXG4gICAgICAgICAgZm9yIChsZXQgcGFyYW0gb2YgX2RhdGEucGFyYW1ldGVycykge1xyXG4gICAgICAgICAgICBwYXJhbWV0ZXJzLnB1c2godGhpcy5wYXJzZUNsb3N1cmUocGFyYW0pKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyByYW5kb20gY2xvc3VyZSBuZWVkcyB0byBoYXZlIHRoZSByYW5kb20gbnVtYmVycyBhcnJheSBhcyBhIHBhcmFtZXRlclxyXG4gICAgICAgICAgaWYgKF9kYXRhLmZ1bmN0aW9uID09IFwicmFuZG9tXCIpIHtcclxuICAgICAgICAgICAgcGFyYW1ldGVycy5wdXNoKCgpID0+IHtcclxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yYW5kb21OdW1iZXJzO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBsZXQgY2xvc3VyZTogRnVuY3Rpb24gPSBDbG9zdXJlRmFjdG9yeS5nZXRDbG9zdXJlKF9kYXRhLmZ1bmN0aW9uLCBwYXJhbWV0ZXJzKTtcclxuXHJcbiAgICAgICAgICByZXR1cm4gY2xvc3VyZTtcclxuXHJcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxyXG4gICAgICAgICAgaWYgKF9kYXRhIGluIHRoaXMuc3RvcmVkVmFsdWVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgRGVidWcubG9nKFwiVmFyaWFibGVcIiwgYFwiJHtfZGF0YX1cImAsIHRoaXMuc3RvcmVkVmFsdWVzWzxzdHJpbmc+X2RhdGFdKTtcclxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdG9yZWRWYWx1ZXNbPHN0cmluZz5fZGF0YV07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgYFwiJHtfZGF0YX1cIiBpcyBub3QgZGVmaW5lZGA7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcclxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKTogbnVtYmVyIHtcclxuICAgICAgICAgICAgRGVidWcubG9nKFwiQ29uc3RhbnRcIiwgX2RhdGEpO1xyXG4gICAgICAgICAgICByZXR1cm4gPG51bWJlcj5fZGF0YTtcclxuICAgICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAgIGV4cG9ydCBjbGFzcyBSYXkge1xyXG4gICAgICAgIHB1YmxpYyBvcmlnaW46IFZlY3RvcjM7XHJcbiAgICAgICAgcHVibGljIGRpcmVjdGlvbjogVmVjdG9yMztcclxuICAgICAgICBwdWJsaWMgbGVuZ3RoOiBudW1iZXI7XHJcblxyXG4gICAgICAgIGNvbnN0cnVjdG9yKF9kaXJlY3Rpb246IFZlY3RvcjMgPSBWZWN0b3IzLlooLTEpLCBfb3JpZ2luOiBWZWN0b3IzID0gVmVjdG9yMy5aRVJPKCksIF9sZW5ndGg6IG51bWJlciA9IDEpIHtcclxuICAgICAgICAgICAgdGhpcy5vcmlnaW4gPSBfb3JpZ2luO1xyXG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IF9kaXJlY3Rpb247XHJcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gX2xlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAgIGV4cG9ydCBjbGFzcyBSYXlIaXQge1xyXG4gICAgICAgIHB1YmxpYyBub2RlOiBOb2RlO1xyXG4gICAgICAgIHB1YmxpYyBmYWNlOiBudW1iZXI7XHJcbiAgICAgICAgcHVibGljIHpCdWZmZXI6IG51bWJlcjtcclxuXHJcbiAgICAgICAgY29uc3RydWN0b3IoX25vZGU6IE5vZGUgPSBudWxsLCBfZmFjZTogbnVtYmVyID0gMCwgX3pCdWZmZXI6IG51bWJlciA9IDApIHtcclxuICAgICAgICAgICAgdGhpcy5ub2RlID0gX25vZGU7XHJcbiAgICAgICAgICAgIHRoaXMuZmFjZSA9IF9mYWNlO1xyXG4gICAgICAgICAgICB0aGlzLnpCdWZmZXIgPSBfekJ1ZmZlcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgdHlwZSBNYXBMaWdodFR5cGVUb0xpZ2h0TGlzdCA9IE1hcDxUeXBlT2ZMaWdodCwgQ29tcG9uZW50TGlnaHRbXT47XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbmRlcmVkIHRleHR1cmUgZm9yIGVhY2ggbm9kZSBmb3IgcGlja2luZ1xyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgUGlja0J1ZmZlciB7XHJcbiAgICBub2RlOiBOb2RlO1xyXG4gICAgdGV4dHVyZTogV2ViR0xUZXh0dXJlO1xyXG4gICAgZnJhbWVCdWZmZXI6IFdlYkdMRnJhbWVidWZmZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgbWFpbiBpbnRlcmZhY2UgdG8gdGhlIHJlbmRlciBlbmdpbmUsIGhlcmUgV2ViR0wsIHdoaWNoIGlzIHVzZWQgbWFpbmx5IGluIHRoZSBzdXBlcmNsYXNzIFtbUmVuZGVyT3BlcmF0b3JdXVxyXG4gICAqL1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBSZW5kZXJNYW5hZ2VyIGV4dGVuZHMgUmVuZGVyT3BlcmF0b3Ige1xyXG4gICAgcHVibGljIHN0YXRpYyByZWN0Q2xpcDogUmVjdGFuZ2xlID0gbmV3IFJlY3RhbmdsZSgtMSwgMSwgMiwgLTIpO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgdGltZXN0YW1wVXBkYXRlOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBwaWNrQnVmZmVyczogUGlja0J1ZmZlcltdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXIgdGhlIG9mZnNjcmVlbiByZW5kZXJidWZmZXIgd2l0aCB0aGUgZ2l2ZW4gW1tDb2xvcl1dXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgY2xlYXIoX2NvbG9yOiBDb2xvciA9IG51bGwpOiB2b2lkIHtcclxuICAgICAgUmVuZGVyTWFuYWdlci5jcmMzLmNsZWFyQ29sb3IoX2NvbG9yLnIsIF9jb2xvci5nLCBfY29sb3IuYiwgX2NvbG9yLmEpO1xyXG4gICAgICBSZW5kZXJNYW5hZ2VyLmNyYzMuY2xlYXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5DT0xPUl9CVUZGRVJfQklUIHwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ERVBUSF9CVUZGRVJfQklUKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0IHRoZSBvZmZzY3JlZW4gZnJhbWVidWZmZXIgdG8gdGhlIG9yaWdpbmFsIFJlbmRlcmluZ0NvbnRleHRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZXNldEZyYW1lQnVmZmVyKF9jb2xvcjogQ29sb3IgPSBudWxsKTogdm9pZCB7XHJcbiAgICAgIFJlbmRlck1hbmFnZXIuY3JjMy5iaW5kRnJhbWVidWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GUkFNRUJVRkZFUiwgbnVsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFJheUNhc3QgJiBQaWNraW5nXHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIHRoZSBncmFwaCBmb3IgUmF5Q2FzdGluZyBzdGFydGluZyB3aXRoIHRoZSBnaXZlbiBbW05vZGVdXSB1c2luZyB0aGUgY2FtZXJhIGdpdmVuIFtbQ29tcG9uZW50Q2FtZXJhXV0uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZHJhd0dyYXBoRm9yUmF5Q2FzdChfbm9kZTogTm9kZSwgX2NtcENhbWVyYTogQ29tcG9uZW50Q2FtZXJhKTogUGlja0J1ZmZlcltdIHsgLy8gVE9ETzogc2VlIGlmIHRoaXJkIHBhcmFtZXRlciBfd29ybGQ/OiBNYXRyaXg0eDQgd291bGQgYmUgdXNlZnVsbFxyXG4gICAgICBSZW5kZXJNYW5hZ2VyLnBpY2tCdWZmZXJzID0gW107XHJcbiAgICAgIC8vVE9ETzogZXhhbWluZSwgd2h5IHN3aXRjaGluZyBibGVuZEZ1bmN0aW9uIGlzIG5lY2Vzc2FyeSBcclxuICAgICAgUmVuZGVyT3BlcmF0b3IuY3JjMy5ibGVuZEZ1bmMoMSwgMCk7XHJcbiAgICAgIFJlbmRlck1hbmFnZXIuZHJhd0dyYXBoKF9ub2RlLCBfY21wQ2FtZXJhLCBSZW5kZXJNYW5hZ2VyLmRyYXdOb2RlRm9yUmF5Q2FzdCk7XHJcbiAgICAgIFJlbmRlck9wZXJhdG9yLmNyYzMuYmxlbmRGdW5jKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRFNUX0FMUEhBLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk9ORV9NSU5VU19EU1RfQUxQSEEpO1xyXG5cclxuICAgICAgUmVuZGVyTWFuYWdlci5yZXNldEZyYW1lQnVmZmVyKCk7XHJcbiAgICAgIHJldHVybiBSZW5kZXJNYW5hZ2VyLnBpY2tCdWZmZXJzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQnJvd3NlcyB0aHJvdWdoIHRoZSBidWZmZXJzIChwcmV2aW91c2x5IGNyZWF0ZWQgd2l0aCBbW2RyYXdHcmFwaEZvclJheUNhc3RdXSkgb2YgdGhlIHNpemUgZ2l2ZW5cclxuICAgICAqIGFuZCByZXR1cm5zIGFuIHVuc29ydGVkIGxpc3Qgb2YgdGhlIHZhbHVlcyBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24sIHJlcHJlc2VudGluZyBub2RlLWlkcyBhbmQgZGVwdGggaW5mb3JtYXRpb24gYXMgW1tSYXlIaXRdXXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBwaWNrTm9kZUF0KF9wb3M6IFZlY3RvcjIsIF9waWNrQnVmZmVyczogUGlja0J1ZmZlcltdLCBfcmVjdDogUmVjdGFuZ2xlKTogUmF5SGl0W10ge1xyXG4gICAgICBsZXQgaGl0czogUmF5SGl0W10gPSBbXTtcclxuXHJcbiAgICAgIGZvciAobGV0IHBpY2tCdWZmZXIgb2YgX3BpY2tCdWZmZXJzKSB7XHJcbiAgICAgICAgUmVuZGVyTWFuYWdlci5jcmMzLmJpbmRGcmFtZWJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZSQU1FQlVGRkVSLCBwaWNrQnVmZmVyLmZyYW1lQnVmZmVyKTtcclxuICAgICAgICAvLyBUT0RPOiBpbnN0ZWFkIG9mIHJlYWRpbmcgYWxsIGRhdGEgYW5kIGFmdGVyd2FyZHMgcGljayB0aGUgcGl4ZWwsIHJlYWQgb25seSB0aGUgcGl4ZWwhXHJcbiAgICAgICAgbGV0IGRhdGE6IFVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShfcmVjdC53aWR0aCAqIF9yZWN0LmhlaWdodCAqIDQpO1xyXG4gICAgICAgIFJlbmRlck1hbmFnZXIuY3JjMy5yZWFkUGl4ZWxzKDAsIDAsIF9yZWN0LndpZHRoLCBfcmVjdC5oZWlnaHQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuUkdCQSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTlNJR05FRF9CWVRFLCBkYXRhKTtcclxuICAgICAgICBsZXQgcGl4ZWw6IG51bWJlciA9IF9wb3MueCArIF9yZWN0LndpZHRoICogX3Bvcy55O1xyXG5cclxuICAgICAgICAvLyBsZXQgekJ1ZmZlcjogbnVtYmVyID0gZGF0YVs0ICogcGl4ZWwgKyAxXSArIGRhdGFbNCAqIHBpeGVsICsgMl0gLyAyNTY7XHJcbiAgICAgICAgbGV0IHpCdWZmZXI6IG51bWJlciA9IGRhdGFbNCAqIHBpeGVsICsgMF07XHJcbiAgICAgICAgbGV0IGhpdDogUmF5SGl0ID0gbmV3IFJheUhpdChwaWNrQnVmZmVyLm5vZGUsIDAsIHpCdWZmZXIpO1xyXG5cclxuICAgICAgICBoaXRzLnB1c2goaGl0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGhpdHM7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gRHJhd2luZ1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbWFpbiByZW5kZXJpbmcgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGZyb20gW1tWaWV3cG9ydF1dLlxyXG4gICAgICogRHJhd3MgdGhlIGdyYXBoIHN0YXJ0aW5nIHdpdGggdGhlIGdpdmVuIFtbTm9kZV1dIHVzaW5nIHRoZSBjYW1lcmEgZ2l2ZW4gW1tDb21wb25lbnRDYW1lcmFdXS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBkcmF3R3JhcGgoX25vZGU6IE5vZGUsIF9jbXBDYW1lcmE6IENvbXBvbmVudENhbWVyYSwgX2RyYXdOb2RlOiBGdW5jdGlvbiA9IFJlbmRlck1hbmFnZXIuZHJhd05vZGUpOiB2b2lkIHtcclxuICAgICAgbGV0IG1hdHJpeDogTWF0cml4NHg0ID0gTWF0cml4NHg0LklERU5USVRZKCk7XHJcbiAgICAgIGlmIChfbm9kZS5nZXRQYXJlbnQoKSlcclxuICAgICAgICBtYXRyaXggPSBfbm9kZS5nZXRQYXJlbnQoKS5tdHhXb3JsZDtcclxuXHJcbiAgICAgIFJlbmRlck1hbmFnZXIuc2V0dXBUcmFuc2Zvcm1BbmRMaWdodHMoX25vZGUsIG1hdHJpeCk7XHJcblxyXG4gICAgICBSZW5kZXJNYW5hZ2VyLmRyYXdHcmFwaFJlY3Vyc2l2ZShfbm9kZSwgX2NtcENhbWVyYSwgX2RyYXdOb2RlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlY3Vyc2l2bHkgaXRlcmF0ZXMgb3ZlciB0aGUgZ3JhcGggYW5kIHJlbmRlcnMgZWFjaCBub2RlIGFuZCBhbGwgc3VjY2Vzc29ycyB3aXRoIHRoZSBnaXZlbiByZW5kZXIgZnVuY3Rpb25cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZHJhd0dyYXBoUmVjdXJzaXZlKF9ub2RlOiBOb2RlLCBfY21wQ2FtZXJhOiBDb21wb25lbnRDYW1lcmEsIF9kcmF3Tm9kZTogRnVuY3Rpb24gPSBSZW5kZXJNYW5hZ2VyLmRyYXdOb2RlKTogdm9pZCB7XHJcbiAgICAgIC8vIFRPRE86IHNlZSBpZiB0aGlyZCBwYXJhbWV0ZXIgX3dvcmxkPzogTWF0cml4NHg0IHdvdWxkIGJlIHVzZWZ1bGxcclxuICAgICAgaWYgKCFfbm9kZS5pc0FjdGl2ZSlcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBsZXQgZmluYWxUcmFuc2Zvcm06IE1hdHJpeDR4NDtcclxuXHJcbiAgICAgIGxldCBjbXBNZXNoOiBDb21wb25lbnRNZXNoID0gX25vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudE1lc2gpO1xyXG4gICAgICBpZiAoY21wTWVzaCkgLy8gVE9ETzogY2FyZWZ1bCB3aGVuIHVzaW5nIHBhcnRpY2xlc3lzdGVtLCBwaXZvdCBtdXN0IG5vdCBjaGFuZ2Ugbm9kZSBwb3NpdGlvblxyXG4gICAgICAgIGZpbmFsVHJhbnNmb3JtID0gTWF0cml4NHg0Lk1VTFRJUExJQ0FUSU9OKF9ub2RlLm10eFdvcmxkLCBjbXBNZXNoLnBpdm90KTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIGZpbmFsVHJhbnNmb3JtID0gX25vZGUubXR4V29ybGQ7IC8vIGNhdXRpb24sIFJlbmRlck1hbmFnZXIgaXMgYSByZWZlcmVuY2UuLi5cclxuXHJcbiAgICAgIC8vIG11bHRpcGx5IGNhbWVyYSBtYXRyaXhcclxuICAgICAgLy8gVE9ETzogdGhpcyBuZWVkcyB0byBiZSBkb25lIGV4dHJhIGZvciBldmVyeSBzaW5nbGUgcGFydGljbGVcclxuICAgICAgbGV0IHByb2plY3Rpb246IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5NVUxUSVBMSUNBVElPTihfY21wQ2FtZXJhLlZpZXdQcm9qZWN0aW9uTWF0cml4LCBmaW5hbFRyYW5zZm9ybSk7XHJcblxyXG4gICAgICAvLyBUT0RPOiBjcmVhdGUgZHJhd05vZGUgbWV0aG9kIGZvciBwYXJ0aWNsZSBzeXN0ZW0gdXNpbmcgX25vZGUubXR4V29ybGQgaW5zdGVhZCBvZiBmaW5hbFRyYW5zZm9ybVxyXG4gICAgICBsZXQgY21wUGFydGljbGVTeXN0ZW06IENvbXBvbmVudFBhcnRpY2xlU3lzdGVtID0gX25vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudFBhcnRpY2xlU3lzdGVtKTtcclxuICAgICAgaWYgKGNtcFBhcnRpY2xlU3lzdGVtKVxyXG4gICAgICAgIFJlbmRlclBhcnRpY2xlcy5kcmF3UGFydGljbGVzKF9ub2RlLCBfbm9kZS5tdHhXb3JsZCwgX2NtcENhbWVyYSk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBfZHJhd05vZGUoX25vZGUsIGZpbmFsVHJhbnNmb3JtLCBwcm9qZWN0aW9uKTtcclxuXHJcblxyXG4gICAgICBmb3IgKGxldCBuYW1lIGluIF9ub2RlLmdldENoaWxkcmVuKCkpIHtcclxuICAgICAgICBsZXQgY2hpbGROb2RlOiBOb2RlID0gX25vZGUuZ2V0Q2hpbGRyZW4oKVtuYW1lXTtcclxuICAgICAgICBSZW5kZXJNYW5hZ2VyLmRyYXdHcmFwaFJlY3Vyc2l2ZShjaGlsZE5vZGUsIF9jbXBDYW1lcmEsIF9kcmF3Tm9kZSk7IC8vLCB3b3JsZCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFRPRE86IHRoaXMgc2hvdWxkIGFsc28gYmUgZG9uZSBwZXIgcGFydGljbGVcclxuICAgICAgUmVjeWNsZXIuc3RvcmUocHJvamVjdGlvbik7XHJcbiAgICAgIGlmIChmaW5hbFRyYW5zZm9ybSAhPSBfbm9kZS5tdHhXb3JsZClcclxuICAgICAgICBSZWN5Y2xlci5zdG9yZShmaW5hbFRyYW5zZm9ybSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc3RhbmRhcmQgcmVuZGVyIGZ1bmN0aW9uIGZvciBkcmF3aW5nIGEgc2luZ2xlIG5vZGVcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZHJhd05vZGUoX25vZGU6IE5vZGUsIF9maW5hbFRyYW5zZm9ybTogTWF0cml4NHg0LCBfcHJvamVjdGlvbjogTWF0cml4NHg0LCBfbGlnaHRzOiBNYXBMaWdodFR5cGVUb0xpZ2h0TGlzdCk6IHZvaWQge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGxldCBjbXBNYXRlcmlhbDogQ29tcG9uZW50TWF0ZXJpYWwgPSBfbm9kZS5nZXRDb21wb25lbnQoQ29tcG9uZW50TWF0ZXJpYWwpO1xyXG4gICAgICAgIGxldCBtZXNoOiBNZXNoID0gX25vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudE1lc2gpLm1lc2g7XHJcbiAgICAgICAgLy8gUmVuZGVyTWFuYWdlci5zZXRMaWdodHNJblNoYWRlcihzaGFkZXIsIF9saWdodHMpO1xyXG4gICAgICAgIFJlbmRlck1hbmFnZXIuZHJhdyhtZXNoLCBjbXBNYXRlcmlhbCwgX2ZpbmFsVHJhbnNmb3JtLCBfcHJvamVjdGlvbik7IC8vLCBfbGlnaHRzKTtcclxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XHJcbiAgICAgICAgLy8gRGVidWcuZXJyb3IoX2Vycm9yKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIFBpY2tpbmdcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHJlbmRlciBmdW5jdGlvbiBmb3IgZHJhd2luZyBidWZmZXJzIGZvciBwaWNraW5nLiBSZW5kZXJzIGVhY2ggbm9kZSBvbiBhIGRlZGljYXRlZCBidWZmZXIgd2l0aCBpZCBhbmQgZGVwdGggdmFsdWVzIGluc3RlYWQgb2YgY29sb3JzXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIGRyYXdOb2RlRm9yUmF5Q2FzdChfbm9kZTogTm9kZSwgX2ZpbmFsVHJhbnNmb3JtOiBNYXRyaXg0eDQsIF9wcm9qZWN0aW9uOiBNYXRyaXg0eDQsIF9saWdodHM6IE1hcExpZ2h0VHlwZVRvTGlnaHRMaXN0KTogdm9pZCB7IC8vIGNyZWF0ZSBUZXh0dXJlIHRvIHJlbmRlciB0bywgaW50LXJnYmFcclxuICAgICAgLy8gVE9ETzogbG9vayBpbnRvIFNTQk9zIVxyXG4gICAgICBsZXQgdGFyZ2V0OiBXZWJHTFRleHR1cmUgPSBSZW5kZXJNYW5hZ2VyLmdldFJheUNhc3RUZXh0dXJlKCk7XHJcblxyXG4gICAgICBjb25zdCBmcmFtZWJ1ZmZlcjogV2ViR0xGcmFtZWJ1ZmZlciA9IFJlbmRlck1hbmFnZXIuY3JjMy5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xyXG4gICAgICAvLyByZW5kZXIgdG8gb3VyIHRhcmdldFRleHR1cmUgYnkgYmluZGluZyB0aGUgZnJhbWVidWZmZXJcclxuICAgICAgUmVuZGVyTWFuYWdlci5jcmMzLmJpbmRGcmFtZWJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlcik7XHJcbiAgICAgIC8vIGF0dGFjaCB0aGUgdGV4dHVyZSBhcyB0aGUgZmlyc3QgY29sb3IgYXR0YWNobWVudFxyXG4gICAgICBjb25zdCBhdHRhY2htZW50UG9pbnQ6IG51bWJlciA9IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ09MT1JfQVRUQUNITUVOVDA7XHJcbiAgICAgIFJlbmRlck1hbmFnZXIuY3JjMy5mcmFtZWJ1ZmZlclRleHR1cmUyRChXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZSQU1FQlVGRkVSLCBhdHRhY2htZW50UG9pbnQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgdGFyZ2V0LCAwKTtcclxuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgbGV0IG1lc2g6IE1lc2ggPSBfbm9kZS5nZXRDb21wb25lbnQoQ29tcG9uZW50TWVzaCkubWVzaDtcclxuICAgICAgICBTaGFkZXJSYXlDYXN0LnVzZVByb2dyYW0oKTtcclxuICAgICAgICBsZXQgcGlja0J1ZmZlcjogUGlja0J1ZmZlciA9IHsgbm9kZTogX25vZGUsIHRleHR1cmU6IHRhcmdldCwgZnJhbWVCdWZmZXI6IGZyYW1lYnVmZmVyIH07XHJcbiAgICAgICAgUmVuZGVyTWFuYWdlci5waWNrQnVmZmVycy5wdXNoKHBpY2tCdWZmZXIpO1xyXG4gICAgICAgIG1lc2gudXNlUmVuZGVyQnVmZmVycyhTaGFkZXJSYXlDYXN0LCBfZmluYWxUcmFuc2Zvcm0sIF9wcm9qZWN0aW9uLCBSZW5kZXJNYW5hZ2VyLnBpY2tCdWZmZXJzLmxlbmd0aCk7XHJcblxyXG4gICAgICAgIFJlbmRlck9wZXJhdG9yLmNyYzMuZHJhd0VsZW1lbnRzKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVFJJQU5HTEVTLCBtZXNoLnJlbmRlckJ1ZmZlcnMubkluZGljZXMsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5TSUdORURfU0hPUlQsIDApO1xyXG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcclxuICAgICAgICAvL1xyXG4gICAgICB9XHJcbiAgICAgIC8vIG1ha2UgdGV4dHVyZSBhdmFpbGFibGUgdG8gb25zY3JlZW4tZGlzcGxheVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHRleHR1cmUgYnVmZmVyIHRvIGJlIHVzZXMgYXMgcGljay1idWZmZXJcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0UmF5Q2FzdFRleHR1cmUoKTogV2ViR0xUZXh0dXJlIHtcclxuICAgICAgLy8gY3JlYXRlIHRvIHJlbmRlciB0b1xyXG4gICAgICBjb25zdCB0YXJnZXRUZXh0dXJlV2lkdGg6IG51bWJlciA9IFJlbmRlck1hbmFnZXIuZ2V0Vmlld3BvcnRSZWN0YW5nbGUoKS53aWR0aDtcclxuICAgICAgY29uc3QgdGFyZ2V0VGV4dHVyZUhlaWdodDogbnVtYmVyID0gUmVuZGVyTWFuYWdlci5nZXRWaWV3cG9ydFJlY3RhbmdsZSgpLmhlaWdodDtcclxuICAgICAgY29uc3QgdGFyZ2V0VGV4dHVyZTogV2ViR0xUZXh0dXJlID0gUmVuZGVyTWFuYWdlci5jcmMzLmNyZWF0ZVRleHR1cmUoKTtcclxuICAgICAgUmVuZGVyTWFuYWdlci5jcmMzLmJpbmRUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgdGFyZ2V0VGV4dHVyZSk7XHJcblxyXG4gICAgICB7XHJcbiAgICAgICAgY29uc3QgaW50ZXJuYWxGb3JtYXQ6IG51bWJlciA9IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuUkdCQTg7XHJcbiAgICAgICAgY29uc3QgZm9ybWF0OiBudW1iZXIgPSBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlJHQkE7XHJcbiAgICAgICAgY29uc3QgdHlwZTogbnVtYmVyID0gV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTlNJR05FRF9CWVRFO1xyXG4gICAgICAgIFJlbmRlck1hbmFnZXIuY3JjMy50ZXhJbWFnZTJEKFxyXG4gICAgICAgICAgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCAwLCBpbnRlcm5hbEZvcm1hdCwgdGFyZ2V0VGV4dHVyZVdpZHRoLCB0YXJnZXRUZXh0dXJlSGVpZ2h0LCAwLCBmb3JtYXQsIHR5cGUsIG51bGxcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBzZXQgdGhlIGZpbHRlcmluZyBzbyB3ZSBkb24ndCBuZWVkIG1pcHNcclxuICAgICAgICBSZW5kZXJNYW5hZ2VyLmNyYzMudGV4UGFyYW1ldGVyaShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV9NSU5fRklMVEVSLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkxJTkVBUik7XHJcbiAgICAgICAgUmVuZGVyTWFuYWdlci5jcmMzLnRleFBhcmFtZXRlcmkoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfV1JBUF9TLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkNMQU1QX1RPX0VER0UpO1xyXG4gICAgICAgIFJlbmRlck1hbmFnZXIuY3JjMy50ZXhQYXJhbWV0ZXJpKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFX1dSQVBfVCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRhcmdldFRleHR1cmU7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmb3JtYXRpb24gJiBMaWdodHNcclxuICAgIC8qKlxyXG4gICAgICogUmVjdXJzaXZlbHkgaXRlcmF0ZXMgb3ZlciB0aGUgZ3JhcGggc3RhcnRpbmcgd2l0aCB0aGUgbm9kZSBnaXZlbiwgcmVjYWxjdWxhdGVzIGFsbCB3b3JsZCB0cmFuc2Zvcm1zLCBcclxuICAgICAqIGNvbGxlY3RzIGFsbCBsaWdodHMgYW5kIGZlZWRzIGFsbCBzaGFkZXJzIHVzZWQgaW4gdGhlIGdyYXBoIHdpdGggdGhlc2UgbGlnaHRzXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIHNldHVwVHJhbnNmb3JtQW5kTGlnaHRzKF9ub2RlOiBOb2RlLCBfd29ybGQ6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpLCBfbGlnaHRzOiBNYXBMaWdodFR5cGVUb0xpZ2h0TGlzdCA9IG5ldyBNYXAoKSwgX3NoYWRlcnNVc2VkOiAodHlwZW9mIFNoYWRlcilbXSA9IG51bGwpOiB2b2lkIHtcclxuICAgICAgbGV0IGZpcnN0TGV2ZWw6IGJvb2xlYW4gPSAoX3NoYWRlcnNVc2VkID09IG51bGwpO1xyXG4gICAgICBpZiAoZmlyc3RMZXZlbClcclxuICAgICAgICBfc2hhZGVyc1VzZWQgPSBbXTtcclxuXHJcbiAgICAgIGxldCB3b3JsZDogTWF0cml4NHg0ID0gX3dvcmxkO1xyXG5cclxuICAgICAgbGV0IGNtcFRyYW5zZm9ybTogQ29tcG9uZW50VHJhbnNmb3JtID0gX25vZGUuY21wVHJhbnNmb3JtO1xyXG4gICAgICBpZiAoY21wVHJhbnNmb3JtKVxyXG4gICAgICAgIHdvcmxkID0gTWF0cml4NHg0Lk1VTFRJUExJQ0FUSU9OKF93b3JsZCwgY21wVHJhbnNmb3JtLmxvY2FsKTtcclxuXHJcbiAgICAgIF9ub2RlLm10eFdvcmxkID0gd29ybGQ7XHJcbiAgICAgIF9ub2RlLnRpbWVzdGFtcFVwZGF0ZSA9IFJlbmRlck1hbmFnZXIudGltZXN0YW1wVXBkYXRlO1xyXG5cclxuICAgICAgbGV0IGNtcExpZ2h0czogQ29tcG9uZW50TGlnaHRbXSA9IF9ub2RlLmdldENvbXBvbmVudHMoQ29tcG9uZW50TGlnaHQpO1xyXG4gICAgICBmb3IgKGxldCBjbXBMaWdodCBvZiBjbXBMaWdodHMpIHtcclxuICAgICAgICBsZXQgdHlwZTogVHlwZU9mTGlnaHQgPSBjbXBMaWdodC5saWdodC5nZXRUeXBlKCk7XHJcbiAgICAgICAgbGV0IGxpZ2h0c09mVHlwZTogQ29tcG9uZW50TGlnaHRbXSA9IF9saWdodHMuZ2V0KHR5cGUpO1xyXG4gICAgICAgIGlmICghbGlnaHRzT2ZUeXBlKSB7XHJcbiAgICAgICAgICBsaWdodHNPZlR5cGUgPSBbXTtcclxuICAgICAgICAgIF9saWdodHMuc2V0KHR5cGUsIGxpZ2h0c09mVHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxpZ2h0c09mVHlwZS5wdXNoKGNtcExpZ2h0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IGNtcE1hdGVyaWFsOiBDb21wb25lbnRNYXRlcmlhbCA9IF9ub2RlLmdldENvbXBvbmVudChDb21wb25lbnRNYXRlcmlhbCk7XHJcbiAgICAgIGlmIChjbXBNYXRlcmlhbCkge1xyXG4gICAgICAgIGxldCBzaGFkZXI6IHR5cGVvZiBTaGFkZXIgPSBjbXBNYXRlcmlhbC5tYXRlcmlhbC5nZXRTaGFkZXIoKTtcclxuICAgICAgICBpZiAoX3NoYWRlcnNVc2VkLmluZGV4T2Yoc2hhZGVyKSA8IDApXHJcbiAgICAgICAgICBfc2hhZGVyc1VzZWQucHVzaChzaGFkZXIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKGxldCBjaGlsZCBvZiBfbm9kZS5nZXRDaGlsZHJlbigpKSB7XHJcbiAgICAgICAgUmVuZGVyTWFuYWdlci5zZXR1cFRyYW5zZm9ybUFuZExpZ2h0cyhjaGlsZCwgd29ybGQsIF9saWdodHMsIF9zaGFkZXJzVXNlZCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChmaXJzdExldmVsKVxyXG4gICAgICAgIGZvciAobGV0IHNoYWRlciBvZiBfc2hhZGVyc1VzZWQpXHJcbiAgICAgICAgICBSZW5kZXJNYW5hZ2VyLnNldExpZ2h0c0luU2hhZGVyKHNoYWRlciwgX2xpZ2h0cyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgbGlnaHQgZGF0YSBpbiBzaGFkZXJzXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIHNldExpZ2h0c0luU2hhZGVyKF9zaGFkZXI6IHR5cGVvZiBTaGFkZXIsIF9saWdodHM6IE1hcExpZ2h0VHlwZVRvTGlnaHRMaXN0KTogdm9pZCB7XHJcbiAgICAgIF9zaGFkZXIudXNlUHJvZ3JhbSgpO1xyXG4gICAgICBsZXQgdW5pOiB7IFtuYW1lOiBzdHJpbmddOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiB9ID0gX3NoYWRlci51bmlmb3JtcztcclxuXHJcbiAgICAgIC8vIEFtYmllbnRcclxuICAgICAgbGV0IGFtYmllbnQ6IFdlYkdMVW5pZm9ybUxvY2F0aW9uID0gdW5pW1widV9hbWJpZW50LmNvbG9yXCJdO1xyXG4gICAgICBpZiAoYW1iaWVudCkge1xyXG4gICAgICAgIGxldCBjbXBMaWdodHM6IENvbXBvbmVudExpZ2h0W10gPSBfbGlnaHRzLmdldChMaWdodEFtYmllbnQpO1xyXG4gICAgICAgIGlmIChjbXBMaWdodHMpIHtcclxuICAgICAgICAgIC8vIFRPRE86IGFkZCB1cCBhbWJpZW50IGxpZ2h0cyB0byBhIHNpbmdsZSBjb2xvclxyXG4gICAgICAgICAgbGV0IHJlc3VsdDogQ29sb3IgPSBuZXcgQ29sb3IoMCwgMCwgMCwgMSk7XHJcbiAgICAgICAgICBmb3IgKGxldCBjbXBMaWdodCBvZiBjbXBMaWdodHMpXHJcbiAgICAgICAgICAgIHJlc3VsdC5hZGQoY21wTGlnaHQubGlnaHQuY29sb3IpO1xyXG4gICAgICAgICAgUmVuZGVyT3BlcmF0b3IuY3JjMy51bmlmb3JtNGZ2KGFtYmllbnQsIHJlc3VsdC5nZXRBcnJheSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIERpcmVjdGlvbmFsXHJcbiAgICAgIGxldCBuRGlyZWN0aW9uYWw6IFdlYkdMVW5pZm9ybUxvY2F0aW9uID0gdW5pW1widV9uTGlnaHRzRGlyZWN0aW9uYWxcIl07XHJcbiAgICAgIGlmIChuRGlyZWN0aW9uYWwpIHtcclxuICAgICAgICBsZXQgY21wTGlnaHRzOiBDb21wb25lbnRMaWdodFtdID0gX2xpZ2h0cy5nZXQoTGlnaHREaXJlY3Rpb25hbCk7XHJcbiAgICAgICAgaWYgKGNtcExpZ2h0cykge1xyXG4gICAgICAgICAgbGV0IG46IG51bWJlciA9IGNtcExpZ2h0cy5sZW5ndGg7XHJcbiAgICAgICAgICBSZW5kZXJPcGVyYXRvci5jcmMzLnVuaWZvcm0xdWkobkRpcmVjdGlvbmFsLCBuKTtcclxuICAgICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGNtcExpZ2h0OiBDb21wb25lbnRMaWdodCA9IGNtcExpZ2h0c1tpXTtcclxuICAgICAgICAgICAgUmVuZGVyT3BlcmF0b3IuY3JjMy51bmlmb3JtNGZ2KHVuaVtgdV9kaXJlY3Rpb25hbFske2l9XS5jb2xvcmBdLCBjbXBMaWdodC5saWdodC5jb2xvci5nZXRBcnJheSgpKTtcclxuICAgICAgICAgICAgbGV0IGRpcmVjdGlvbjogVmVjdG9yMyA9IFZlY3RvcjMuWigpO1xyXG4gICAgICAgICAgICBkaXJlY3Rpb24udHJhbnNmb3JtKGNtcExpZ2h0LnBpdm90LCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGRpcmVjdGlvbi50cmFuc2Zvcm0oY21wTGlnaHQuZ2V0Q29udGFpbmVyKCkubXR4V29ybGQpO1xyXG4gICAgICAgICAgICBSZW5kZXJPcGVyYXRvci5jcmMzLnVuaWZvcm0zZnYodW5pW2B1X2RpcmVjdGlvbmFsWyR7aX1dLmRpcmVjdGlvbmBdLCBkaXJlY3Rpb24uZ2V0KCkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFJlbmRlclBhcnRpY2xlcyBleHRlbmRzIFJlbmRlck1hbmFnZXIge1xyXG4gICAgcHVibGljIHN0YXRpYyBkcmF3UGFydGljbGVzKF9ub2RlOiBOb2RlLCBfc3lzdGVtVHJhbnNmb3JtOiBNYXRyaXg0eDQsIF9jbXBDYW1lcmE6IENvbXBvbmVudENhbWVyYSk6IHZvaWQge1xyXG4gICAgICBsZXQgY21wUGFydGljbGVTeXN0ZW06IENvbXBvbmVudFBhcnRpY2xlU3lzdGVtID0gX25vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudFBhcnRpY2xlU3lzdGVtKTtcclxuICAgICAgbGV0IGNtcE1hdGVyaWFsOiBDb21wb25lbnRNYXRlcmlhbCA9IF9ub2RlLmdldENvbXBvbmVudChDb21wb25lbnRNYXRlcmlhbCk7XHJcbiAgICAgIGxldCBjbXBNZXNoOiBDb21wb25lbnRNZXNoID0gX25vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudE1lc2gpO1xyXG4gICAgICBsZXQgbWVzaDogTWVzaCA9IGNtcE1lc2gubWVzaDtcclxuXHJcbiAgICAgIGxldCBzaGFkZXI6IHR5cGVvZiBTaGFkZXIgPSBjbXBNYXRlcmlhbC5tYXRlcmlhbC5nZXRTaGFkZXIoKTtcclxuICAgICAgbGV0IGNvYXQ6IENvYXQgPSBjbXBNYXRlcmlhbC5tYXRlcmlhbC5nZXRDb2F0KCk7XHJcbiAgICAgIHNoYWRlci51c2VQcm9ncmFtKCk7XHJcblxyXG4gICAgICBsZXQgc3RvcmVkVmFsdWVzOiBTdG9yZWRWYWx1ZXMgPSBjbXBQYXJ0aWNsZVN5c3RlbS5zdG9yZWRWYWx1ZXM7XHJcbiAgICAgIGxldCBlZmZlY3REYXRhOiBQYXJ0aWNsZUVmZmVjdERhdGEgPSBjbXBQYXJ0aWNsZVN5c3RlbS5lZmZlY3REYXRhO1xyXG5cclxuICAgICAgbGV0IHN0b3JhZ2VEYXRhOiBQYXJ0aWNsZUVmZmVjdERhdGEgPSBlZmZlY3REYXRhW1wic3RvcmFnZVwiXTtcclxuICAgICAgbGV0IHRyYW5zZm9ybURhdGE6IFBhcnRpY2xlRWZmZWN0RGF0YSA9IGVmZmVjdERhdGFbXCJ0cmFuc2Zvcm1hdGlvbnNcIl07XHJcbiAgICAgIGxldCB0cmFuc2Zvcm1EYXRhTG9jYWw6IFBhcnRpY2xlRWZmZWN0RGF0YSA9IHRyYW5zZm9ybURhdGFbXCJsb2NhbFwiXTtcclxuICAgICAgbGV0IHRyYW5zZm9ybURhdGFXb3JsZDogUGFydGljbGVFZmZlY3REYXRhID0gdHJhbnNmb3JtRGF0YVtcIndvcmxkXCJdO1xyXG4gICAgICBsZXQgY29tcG9uZW50c0RhdGE6IFBhcnRpY2xlRWZmZWN0RGF0YSA9IGVmZmVjdERhdGFbXCJjb21wb25lbnRzXCJdO1xyXG5cclxuICAgICAgLy8gZ2V0IHJlbGV2YW50IGNvbXBvbmVudHNcclxuICAgICAgbGV0IGNvbXBvbmVudHM6IENvbXBvbmVudFtdID0gW107XHJcbiAgICAgIGZvciAoY29uc3QgY29tcG9uZW50Q2xhc3MgaW4gY29tcG9uZW50c0RhdGEpIHtcclxuICAgICAgICBjb21wb25lbnRzLnB1c2goX25vZGUuZ2V0Q29tcG9uZW50KCg8R2VuZXJhbD5nbG9iYWxUaGlzW1wiRnVkZ2VDb3JlXCJdKVtjb21wb25lbnRDbGFzc10pKTtcclxuICAgICAgfVxyXG4gICAgICBsZXQgY29tcG9uZW50c0xlbmd0aDogbnVtYmVyID0gY29tcG9uZW50cy5sZW5ndGg7XHJcbiAgICAgIC8vIHNhdmUgdGhlaXIgc3RhdGVcclxuICAgICAgbGV0IGNvbXBvbmVudE11dGF0b3JzOiBNdXRhdG9yW10gPSBbXTtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IGNvbXBvbmVudHNMZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbXBvbmVudE11dGF0b3JzLnB1c2goY29tcG9uZW50c1tpXS5nZXRNdXRhdG9yKCkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgcGFydGljbGVTdG9yYWdlOiBQYXJ0aWNsZUVmZmVjdERhdGE7XHJcbiAgICAgIC8vIGV2YWx1YXRlIHVwZGF0ZSBzdG9yYWdlXHJcbiAgICAgIGlmIChzdG9yYWdlRGF0YSkge1xyXG4gICAgICAgIGNtcFBhcnRpY2xlU3lzdGVtLmV2YWx1YXRlQ2xvc3VyZVN0b3JhZ2Uoc3RvcmFnZURhdGFbXCJ1cGRhdGVcIl0pO1xyXG4gICAgICAgIHBhcnRpY2xlU3RvcmFnZSA9IHN0b3JhZ2VEYXRhW1wicGFydGljbGVcIl07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBjYW1lcmFWaWV3UHJvamVjdGlvbk1hdHJpeDogTWF0cml4NHg0ID0gX2NtcENhbWVyYS5WaWV3UHJvamVjdGlvbk1hdHJpeDtcclxuICAgICAgLy8gbGV0IG1lc2hQaXZvdFNjYWxpbmc6IFZlY3RvcjMgPSBjbXBNZXNoLnBpdm90LnNjYWxpbmc7XHJcblxyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwLCBsZW5ndGg6IG51bWJlciA9IHN0b3JlZFZhbHVlc1tcInNpemVcIl07IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHN0b3JlZFZhbHVlc1tcImluZGV4XCJdID0gaTtcclxuXHJcbiAgICAgICAgLy8gZXZhbHVhdGUgcGFydGljbGUgc3RvcmFnZVxyXG4gICAgICAgIGNtcFBhcnRpY2xlU3lzdGVtLmV2YWx1YXRlQ2xvc3VyZVN0b3JhZ2UocGFydGljbGVTdG9yYWdlKTtcclxuXHJcbiAgICAgICAgLy8gYXBwbHkgdHJhbnNmb3JtYXRpb25zXHJcbiAgICAgICAgbGV0IGZpbmFsVHJhbnNmb3JtOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKTtcclxuXHJcbiAgICAgICAgLy8gZm9yIChjb25zdCBrZXkgaW4gdHJhbnNmb3JtRGF0YUxvY2FsKSB7XHJcbiAgICAgICAgLy8gICAvLyBUT0RPOiBjaGFuZ2UgdGhpcyBzb21laG93Li4uIGdldCBtdXRhdG9ycyBvdXQgb2YgdmVjdG9ycyBhbmQgY2hhbmdlIHRoZW0gKyBnZXQgY29ycmVjdCB2ZWN0b3JcclxuICAgICAgICAvLyAgIGxldCB0cmFuc2Zvcm1NYXRyaXg6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpO1xyXG4gICAgICAgIC8vICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSB7fTtcclxuICAgICAgICAvLyAgIG11dGF0b3Jba2V5XSA9IHRoaXMuZ2V0TXV0YXRvckZvcih0cmFuc2Zvcm1EYXRhTG9jYWxba2V5XSk7XHJcbiAgICAgICAgLy8gICB0cmFuc2Zvcm1NYXRyaXgubXV0YXRlKG11dGF0b3IpO1xyXG4gICAgICAgIC8vICAgZmluYWxUcmFuc2Zvcm0ubXVsdGlwbHkodHJhbnNmb3JtTWF0cml4KTtcclxuICAgICAgICAvLyAgIFJlY3ljbGVyLnN0b3JlKHRyYW5zZm9ybU1hdHJpeCk7XHJcbiAgICAgICAgLy8gfVxyXG5cclxuICAgICAgICBmaW5hbFRyYW5zZm9ybS5tdXRhdGUodGhpcy5nZXRNdXRhdG9yRm9yKHRyYW5zZm9ybURhdGFMb2NhbCkpO1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRyYW5zZm9ybURhdGFMb2NhbCkge1xyXG4gICAgICAgICAgLy8gVE9ETzogY2hhbmdlIHRoaXMgc29tZWhvdy4uLiBnZXQgbXV0YXRvcnMgb3V0IG9mIHZlY3RvcnMgYW5kIGNoYW5nZSB0aGVtICsgZ2V0IGNvcnJlY3QgdmVjdG9yXHJcbiAgICAgICAgICBsZXQgdHJhbnNmb3JtVmVjdG9yOiBWZWN0b3IzID0ga2V5ID09IFwic2NhbGVcIiA/IF9zeXN0ZW1UcmFuc2Zvcm0uc2NhbGluZyA6IFZlY3RvcjMuWkVSTygpO1xyXG4gICAgICAgICAgdHJhbnNmb3JtVmVjdG9yLm11dGF0ZSh0aGlzLmdldE11dGF0b3JGb3IodHJhbnNmb3JtRGF0YUxvY2FsW2tleV0pKTtcclxuICAgICAgICAgICg8R2VuZXJhbD5maW5hbFRyYW5zZm9ybSlba2V5XSh0cmFuc2Zvcm1WZWN0b3IpO1xyXG4gICAgICAgICAgUmVjeWNsZXIuc3RvcmUodHJhbnNmb3JtVmVjdG9yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCB3b3JsZFRyYW5zZm9ybTogTWF0cml4NHg0ID0gTWF0cml4NHg0LklERU5USVRZKCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdHJhbnNmb3JtRGF0YVdvcmxkKSB7XHJcbiAgICAgICAgICBsZXQgdHJhbnNmb3JtVmVjdG9yOiBWZWN0b3IzID0gVmVjdG9yMy5aRVJPKCk7XHJcbiAgICAgICAgICB0cmFuc2Zvcm1WZWN0b3IubXV0YXRlKHRoaXMuZ2V0TXV0YXRvckZvcih0cmFuc2Zvcm1EYXRhV29ybGRba2V5XSkpO1xyXG4gICAgICAgICAgKDxHZW5lcmFsPndvcmxkVHJhbnNmb3JtKVtrZXldKHRyYW5zZm9ybVZlY3Rvcik7XHJcbiAgICAgICAgICBSZWN5Y2xlci5zdG9yZSh0cmFuc2Zvcm1WZWN0b3IpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gYXBwbHkgc3lzdGVtIHRyYW5zZm9ybWF0aW9uXHJcbiAgICAgICAgLy8gZmluYWxUcmFuc2Zvcm0uc2NhbGUobWVzaFBpdm90U2NhbGluZyk7IC8vIHRoaXMgaXMgc2xvd2VyIHRoYW4gbWF0cml4IG11bHRpcGxpY2F0aW9uXHJcbiAgICAgICAgZmluYWxUcmFuc2Zvcm0ubXVsdGlwbHkoY21wTWVzaC5waXZvdCk7XHJcbiAgICAgICAgZmluYWxUcmFuc2Zvcm0ubXVsdGlwbHkoX3N5c3RlbVRyYW5zZm9ybSwgdHJ1ZSk7XHJcbiAgICAgICAgZmluYWxUcmFuc2Zvcm0ubXVsdGlwbHkod29ybGRUcmFuc2Zvcm0sIHRydWUpO1xyXG5cclxuICAgICAgICAvLyBUT0RPOiBvcHRpbWl6ZVxyXG4gICAgICAgIC8vIHRyYW5zZm9ybWF0aW9uLnNob3dUbyhNYXRyaXg0eDQuTVVMVElQTElDQVRJT04oX2NtcENhbWVyYS5nZXRDb250YWluZXIoKS5tdHhXb3JsZCwgX2NtcENhbWVyYS5waXZvdCkudHJhbnNsYXRpb24pO1xyXG5cclxuICAgICAgICAvLyBldmFsdWF0ZSBjb21wb25lbnQgZGF0YVxyXG4gICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBjb21wb25lbnRzTGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGNvbXBvbmVudHNbaV0ubXV0YXRlKHRoaXMuZ2V0TXV0YXRvckZvcihjb21wb25lbnRzRGF0YVtjb21wb25lbnRzW2ldLnR5cGVdKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyByZW5kZXJcclxuICAgICAgICBsZXQgcHJvamVjdGlvbjogTWF0cml4NHg0ID0gTWF0cml4NHg0Lk1VTFRJUExJQ0FUSU9OKGNhbWVyYVZpZXdQcm9qZWN0aW9uTWF0cml4LCBmaW5hbFRyYW5zZm9ybSk7XHJcblxyXG4gICAgICAgIG1lc2gudXNlUmVuZGVyQnVmZmVycyhzaGFkZXIsIGZpbmFsVHJhbnNmb3JtLCBwcm9qZWN0aW9uKTtcclxuICAgICAgICBjb2F0LnVzZVJlbmRlckRhdGEoc2hhZGVyLCBjbXBNYXRlcmlhbCk7XHJcbiAgICAgICAgUmVuZGVyT3BlcmF0b3IuY3JjMy5kcmF3RWxlbWVudHMoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5UUklBTkdMRVMsIG1lc2gucmVuZGVyQnVmZmVycy5uSW5kaWNlcywgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTlNJR05FRF9TSE9SVCwgMCk7XHJcblxyXG4gICAgICAgIFJlY3ljbGVyLnN0b3JlKHByb2plY3Rpb24pO1xyXG4gICAgICAgIFJlY3ljbGVyLnN0b3JlKHdvcmxkVHJhbnNmb3JtKTtcclxuICAgICAgICBSZWN5Y2xlci5zdG9yZShmaW5hbFRyYW5zZm9ybSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHJlc3RvcmUgY29tcG9uZW50IHN0YXRlXHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBjb21wb25lbnRzTGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb21wb25lbnRzW2ldLm11dGF0ZShjb21wb25lbnRNdXRhdG9yc1tpXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPOiBkb24ndCBjcmVhdGUgbmV3IE11dGF0b3JzIGFsbCB0aGUgdGltZVxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0TXV0YXRvckZvcihfZWZmZWN0RGF0YTogUGFydGljbGVFZmZlY3REYXRhKTogTXV0YXRvciB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0ge307XHJcbiAgICAgIGZvciAoY29uc3QgYXR0cmlidXRlIGluIF9lZmZlY3REYXRhKSB7XHJcbiAgICAgICAgbGV0IHZhbHVlOiBPYmplY3QgPSBfZWZmZWN0RGF0YVthdHRyaWJ1dGVdO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgbXV0YXRvclthdHRyaWJ1dGVdID0gKDxGdW5jdGlvbj52YWx1ZSkoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbXV0YXRvclthdHRyaWJ1dGVdID0gdGhpcy5nZXRNdXRhdG9yRm9yKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZXZhbHVhdGVNdXRhdG9yKF9lZmZlY3REYXRhOiBQYXJ0aWNsZUVmZmVjdERhdGEsIF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIGZvciAoY29uc3QgYXR0cmlidXRlIGluIF9lZmZlY3REYXRhKSB7XHJcbiAgICAgICAgbGV0IHZhbHVlOiBPYmplY3QgPSBfZWZmZWN0RGF0YVthdHRyaWJ1dGVdO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgX211dGF0b3JbYXR0cmlidXRlXSA9ICg8RnVuY3Rpb24+dmFsdWUpKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuZXZhbHVhdGVNdXRhdG9yKHZhbHVlLCA8TXV0YXRvcj5fbXV0YXRvclthdHRyaWJ1dGVdKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn0iLCIvLyAvIDxyZWZlcmVuY2UgcGF0aD1cIi4uL0NvYXQvQ29hdC50c1wiLz5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogU3RhdGljIHN1cGVyY2xhc3MgZm9yIHRoZSByZXByZXNlbnRhdGlvbiBvZiBXZWJHbCBzaGFkZXJwcm9ncmFtcy4gXHJcbiAgICogQGF1dGhvcnMgSmFzY2hhIEthcmFnw7ZsLCBIRlUsIDIwMTkgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG5cclxuICAvLyBUT0RPOiBkZWZpbmUgYXR0cmlidXRlL3VuaWZvcm1zIGFzIGxheW91dCBhbmQgdXNlIHRob3NlIGNvbnNpc3RlbnRseSBpbiBzaGFkZXJzXHJcbiAgQFJlbmRlckluamVjdG9yU2hhZGVyLmRlY29yYXRlXHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYWRlciB7XHJcbiAgICAvKiogcmVmZXJzIGJhY2sgdG8gdGhpcyBjbGFzcyBmcm9tIGFueSBzdWJjbGFzcyBlLmcuIGluIG9yZGVyIHRvIGZpbmQgY29tcGF0aWJsZSBvdGhlciByZXNvdXJjZXMqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBiYXNlQ2xhc3M6IHR5cGVvZiBTaGFkZXIgPSBTaGFkZXI7XHJcbiAgICAvKiogbGlzdCBvZiBhbGwgdGhlIHN1YmNsYXNzZXMgZGVyaXZlZCBmcm9tIHRoaXMgY2xhc3MsIGlmIHRoZXkgcmVnaXN0ZXJlZCBwcm9wZXJseSovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IHN1YmNsYXNzZXM6IHR5cGVvZiBTaGFkZXJbXSA9IFtdO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgcHJvZ3JhbTogV2ViR0xQcm9ncmFtO1xyXG4gICAgcHVibGljIHN0YXRpYyBhdHRyaWJ1dGVzOiB7IFtuYW1lOiBzdHJpbmddOiBudW1iZXIgfTtcclxuICAgIHB1YmxpYyBzdGF0aWMgdW5pZm9ybXM6IHsgW25hbWU6IHN0cmluZ106IFdlYkdMVW5pZm9ybUxvY2F0aW9uIH07XHJcblxyXG4gICAgLyoqIFRoZSB0eXBlIG9mIGNvYXQgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIHRoaXMgc2hhZGVyIHRvIGNyZWF0ZSBhIG1hdGVyaWFsICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQgeyByZXR1cm4gbnVsbDsgfVxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRWZXJ0ZXhTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHsgcmV0dXJuIG51bGw7IH1cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHsgcmV0dXJuIG51bGw7IH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGRlbGV0ZVByb2dyYW0odGhpczogdHlwZW9mIFNoYWRlcik6IHZvaWQgey8qIGluamVjdGVkIGJ5IGRlY29yYXRvciAqLyB9XHJcbiAgICBwdWJsaWMgc3RhdGljIHVzZVByb2dyYW0odGhpczogdHlwZW9mIFNoYWRlcik6IHZvaWQgey8qIGluamVjdGVkIGJ5IGRlY29yYXRvciAqLyB9XHJcbiAgICBwdWJsaWMgc3RhdGljIGNyZWF0ZVByb2dyYW0odGhpczogdHlwZW9mIFNoYWRlcik6IHZvaWQgey8qIGluamVjdGVkIGJ5IGRlY29yYXRvciAqLyB9IFxyXG4gICAgXHJcbiAgICBcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVnaXN0ZXJTdWJjbGFzcyhfc3ViY2xhc3M6IHR5cGVvZiBTaGFkZXIpOiBudW1iZXIgeyByZXR1cm4gU2hhZGVyLnN1YmNsYXNzZXMucHVzaChfc3ViY2xhc3MpIC0gMTsgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFNpbmdsZSBjb2xvciBzaGFkaW5nXHJcbiAgICogQGF1dGhvcnMgSmFzY2hhIEthcmFnw7ZsLCBIRlUsIDIwMTkgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIEBSZW5kZXJJbmplY3RvclNoYWRlci5kZWNvcmF0ZVxyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJGbGF0IGV4dGVuZHMgU2hhZGVyIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBTaGFkZXIucmVnaXN0ZXJTdWJjbGFzcyhTaGFkZXJGbGF0KTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQge1xyXG4gICAgICByZXR1cm4gQ29hdENvbG9yZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRWZXJ0ZXhTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIGAjdmVyc2lvbiAzMDAgZXNcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc3RydWN0IExpZ2h0QW1iaWVudCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgY29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBzdHJ1Y3QgTGlnaHREaXJlY3Rpb25hbCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgY29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzMgZGlyZWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVpbnQgTUFYX0xJR0hUU19ESVJFQ1RJT05BTCA9IDEwdTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaW4gdmVjMyBhX3Bvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGluIHZlYzMgYV9ub3JtYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybSBtYXQ0IHVfd29ybGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybSBtYXQ0IHVfcHJvamVjdGlvbjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybSBMaWdodEFtYmllbnQgdV9hbWJpZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHVuaWZvcm0gdWludCB1X25MaWdodHNEaXJlY3Rpb25hbDtcclxuICAgICAgICAgICAgICAgICAgICB1bmlmb3JtIExpZ2h0RGlyZWN0aW9uYWwgdV9kaXJlY3Rpb25hbFtNQVhfTElHSFRTX0RJUkVDVElPTkFMXTtcclxuICAgICAgICAgICAgICAgICAgICBmbGF0IG91dCB2ZWM0IHZfY29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgdm9pZCBtYWluKCkgeyAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHVfcHJvamVjdGlvbiAqIHZlYzQoYV9wb3NpdGlvbiwgMS4wKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMyBub3JtYWwgPSBub3JtYWxpemUobWF0Myh1X3dvcmxkKSAqIGFfbm9ybWFsKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZfY29sb3IgPSB1X2FtYmllbnQuY29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodWludCBpID0gMHU7IGkgPCB1X25MaWdodHNEaXJlY3Rpb25hbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBpbGx1bWluYXRpb24gPSAtZG90KG5vcm1hbCwgdV9kaXJlY3Rpb25hbFtpXS5kaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlsbHVtaW5hdGlvbiA+IDAuMGYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdl9jb2xvciArPSBpbGx1bWluYXRpb24gKiB1X2RpcmVjdGlvbmFsW2ldLmNvbG9yOyAvLyB2ZWM0KDEsMSwxLDEpOyAvLyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2X2NvbG9yLmEgPSAxLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgfWA7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc3RhdGljIGdldEZyYWdtZW50U2hhZGVyU291cmNlKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiBgI3ZlcnNpb24gMzAwIGVzXHJcbiAgICAgICAgICAgICAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHVuaWZvcm0gdmVjNCB1X2NvbG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsYXQgaW4gdmVjNCB2X2NvbG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIG91dCB2ZWM0IGZyYWc7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgdm9pZCBtYWluKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnID0gdV9jb2xvciAqIHZfY29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgfWA7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwiXHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIE1hdGNhcCAoTWF0ZXJpYWwgQ2FwdHVyZSkgc2hhZGluZy4gVGhlIHRleHR1cmUgcHJvdmlkZWQgYnkgdGhlIGNvYXQgaXMgdXNlZCBhcyBhIG1hdGNhcCBtYXRlcmlhbC4gXHJcbiAgICogSW1wbGVtZW50YXRpb24gYmFzZWQgb24gaHR0cHM6Ly93d3cuY2xpY2t0b3JlbGVhc2UuY29tL2Jsb2cvY3JlYXRpbmctc3BoZXJpY2FsLWVudmlyb25tZW50LW1hcHBpbmctc2hhZGVyL1xyXG4gICAqIEBhdXRob3JzIFNpbW9uIFN0b3JsLVNjaHVsa2UsIEhGVSwgMjAxOSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYWRlck1hdENhcCBleHRlbmRzIFNoYWRlciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gU2hhZGVyLnJlZ2lzdGVyU3ViY2xhc3MoU2hhZGVyTWF0Q2FwKTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQge1xyXG4gICAgICByZXR1cm4gQ29hdE1hdENhcDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldFZlcnRleFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gYCN2ZXJzaW9uIDMwMCBlc1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpbiB2ZWMzIGFfcG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgaW4gdmVjMyBhX25vcm1hbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybSBtYXQ0IHVfcHJvamVjdGlvbjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0IHZlYzIgdGV4Y29vcmRzX3Ntb290aDtcclxuICAgICAgICAgICAgICAgICAgICBmbGF0IG91dCB2ZWMyIHRleGNvb3Jkc19mbGF0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2b2lkIG1haW4oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleGNvb3Jkc19zbW9vdGggPSBub3JtYWxpemUobWF0Myh1X3Byb2plY3Rpb24pICogYV9ub3JtYWwpLnh5ICogMC41IC0gMC41O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXhjb29yZHNfZmxhdCA9IHRleGNvb3Jkc19zbW9vdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdV9wcm9qZWN0aW9uICogdmVjNChhX3Bvc2l0aW9uLCAxLjApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1gO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gYCN2ZXJzaW9uIDMwMCBlc1xyXG4gICAgICAgICAgICAgICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIHVuaWZvcm0gdmVjNCB1X3RpbnRfY29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybSBpbnQgc2hhZGVfc21vb3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBpbiB2ZWMyIHRleGNvb3Jkc19zbW9vdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxhdCBpbiB2ZWMyIHRleGNvb3Jkc19mbGF0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBvdXQgdmVjNCBmcmFnO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2b2lkIG1haW4oKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hhZGVfc21vb3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcgPSB1X3RpbnRfY29sb3IgKiB0ZXh0dXJlKHVfdGV4dHVyZSwgdGV4Y29vcmRzX3Ntb290aCkgKiAyLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZyA9IHVfdGludF9jb2xvciAqIHRleHR1cmUodV90ZXh0dXJlLCB0ZXhjb29yZHNfZmxhdCkgKiAyLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9YDtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBSZW5kZXJzIGZvciBSYXljYXN0aW5nXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyUmF5Q2FzdCBleHRlbmRzIFNoYWRlciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIGdldFZlcnRleFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gYCN2ZXJzaW9uIDMwMCBlc1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpbiB2ZWMzIGFfcG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybSBtYXQ0IHVfcHJvamVjdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICB2b2lkIG1haW4oKSB7ICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdV9wcm9qZWN0aW9uICogdmVjNChhX3Bvc2l0aW9uLCAxLjApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1gO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gYCN2ZXJzaW9uIDMwMCBlc1xyXG4gICAgICAgICAgICAgICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG4gICAgICAgICAgICAgICAgICAgIHByZWNpc2lvbiBoaWdocCBpbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybSBpbnQgdV9pZDtcclxuICAgICAgICAgICAgICAgICAgICBvdXQgdmVjNCBmcmFnO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBpZCA9IGZsb2F0KHVfaWQpLyAyNTYuMDtcclxuICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCB1cHBlcmJ5dGUgPSB0cnVuYyhnbF9GcmFnQ29vcmQueiAqIDI1Ni4wKSAvIDI1Ni4wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IGxvd2VyYnl0ZSA9IGZyYWN0KGdsX0ZyYWdDb29yZC56ICogMjU2LjApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGZyYWcgPSB2ZWM0KGdsX0ZyYWdDb29yZC56LCB1cHBlcmJ5dGUsIGxvd2VyYnl0ZSwgMS4wKTtcclxuICAgICAgICAgICAgICAgICAgICB9YDtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBUZXh0dXJlZCBzaGFkaW5nXHJcbiAgICogQGF1dGhvcnMgSmFzY2hhIEthcmFnw7ZsLCBIRlUsIDIwMTkgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJUZXh0dXJlIGV4dGVuZHMgU2hhZGVyIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBTaGFkZXIucmVnaXN0ZXJTdWJjbGFzcyhTaGFkZXJUZXh0dXJlKTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQge1xyXG4gICAgICByZXR1cm4gQ29hdFRleHR1cmVkO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0VmVydGV4U2hhZGVyU291cmNlKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiBgI3ZlcnNpb24gMzAwIGVzXHJcblxyXG4gICAgICAgICAgICAgICAgaW4gdmVjMyBhX3Bvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgaW4gdmVjMiBhX3RleHR1cmVVVnM7XHJcbiAgICAgICAgICAgICAgICB1bmlmb3JtIG1hdDQgdV9wcm9qZWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgdW5pZm9ybSBtYXQzIHVfcGl2b3Q7XHJcbiAgICAgICAgICAgICAgICBvdXQgdmVjMiB2X3RleHR1cmVVVnM7XHJcblxyXG4gICAgICAgICAgICAgICAgdm9pZCBtYWluKCkgeyAgXHJcbiAgICAgICAgICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB1X3Byb2plY3Rpb24gKiB2ZWM0KGFfcG9zaXRpb24sIDEuMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdl90ZXh0dXJlVVZzID0gYV90ZXh0dXJlVVZzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZfdGV4dHVyZVVWcyA9IHZlYzIodV9waXZvdCAqIHZlYzMoYV90ZXh0dXJlVVZzLCAxLjApKS54eTtcclxuICAgICAgICAgICAgICAgIH1gO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gYCN2ZXJzaW9uIDMwMCBlc1xyXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGluIHZlYzIgdl90ZXh0dXJlVVZzO1xyXG4gICAgICAgICAgICAgICAgdW5pZm9ybSB2ZWM0IHVfY29sb3I7XHJcbiAgICAgICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XHJcbiAgICAgICAgICAgICAgICAvLyB1bmlmb3JtIHZlYzQgdV9jb2xvckJhY2tncm91bmQ7IC8vIG1heWJlIGEgbWF0ZXJpYWwgYmFja2dyb3VuZCBjb2xvciBjYW4gc2hpbmUgdGhyb3VnaC4uLiBidXQgd2hlcmUgYW5kIHdpdGggd2hpY2ggaW50ZW5zaXR5P1xyXG4gICAgICAgICAgICAgICAgb3V0IHZlYzQgZnJhZztcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdm9pZCBtYWluKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZlYzQgY29sb3JUZXh0dXJlID0gdGV4dHVyZSh1X3RleHR1cmUsIHZfdGV4dHVyZVVWcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZnJhZyA9IHVfY29sb3IgKiBjb2xvclRleHR1cmU7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9mcmFnID0gdmVjNChjb2xvclRleHR1cmUuciAqIDEuMCwgY29sb3JUZXh0dXJlLmcgKiAwLjQsIGNvbG9yVGV4dHVyZS5iICogMC4xLCBjb2xvclRleHR1cmUuYSAqIDEuNSk7Ly91X2NvbG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZnJhZyA9IGNvbG9yVGV4dHVyZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZy5hIDwgMC4wMSlcclxuICAgICAgICAgICAgICAgICAgICAgIGRpc2NhcmQ7XHJcbiAgICAgICAgICAgIH1gO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFNpbmdsZSBjb2xvciBzaGFkaW5nXHJcbiAgICogQGF1dGhvcnMgSmFzY2hhIEthcmFnw7ZsLCBIRlUsIDIwMTkgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJVbmlDb2xvciBleHRlbmRzIFNoYWRlciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gU2hhZGVyLnJlZ2lzdGVyU3ViY2xhc3MoU2hhZGVyVW5pQ29sb3IpO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0Q29hdCgpOiB0eXBlb2YgQ29hdCB7XHJcbiAgICAgIHJldHVybiBDb2F0Q29sb3JlZDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldFZlcnRleFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gYCN2ZXJzaW9uIDMwMCBlc1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpbiB2ZWMzIGFfcG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybSBtYXQ0IHVfcHJvamVjdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICB2b2lkIG1haW4oKSB7ICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdV9wcm9qZWN0aW9uICogdmVjNChhX3Bvc2l0aW9uLCAxLjApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1gO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gYCN2ZXJzaW9uIDMwMCBlc1xyXG4gICAgICAgICAgICAgICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIHVuaWZvcm0gdmVjNCB1X2NvbG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIG91dCB2ZWM0IGZyYWc7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgdm9pZCBtYWluKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGZyYWcgPSB1X2NvbG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIH1gO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBCYXNlY2xhc3MgZm9yIGRpZmZlcmVudCBraW5kcyBvZiB0ZXh0dXJlcy4gXHJcbiAgICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAgICovXHJcbiAgICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgVGV4dHVyZSBleHRlbmRzIE11dGFibGUge1xyXG4gICAgICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKCk6IHZvaWQgey8qKi8gfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGV4dHVyZSBjcmVhdGVkIGZyb20gYW4gZXhpc3RpbmcgaW1hZ2VcclxuICAgICAqL1xyXG4gICAgZXhwb3J0IGNsYXNzIFRleHR1cmVJbWFnZSBleHRlbmRzIFRleHR1cmUge1xyXG4gICAgICAgIHB1YmxpYyBpbWFnZTogSFRNTEltYWdlRWxlbWVudCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRleHR1cmUgY3JlYXRlZCBmcm9tIGEgY2FudmFzXHJcbiAgICAgKi9cclxuICAgIGV4cG9ydCBjbGFzcyBUZXh0dXJlQ2FudmFzIGV4dGVuZHMgVGV4dHVyZSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRleHR1cmUgY3JlYXRlZCBmcm9tIGEgRlVER0UtU2tldGNoXHJcbiAgICAgKi9cclxuICAgIGV4cG9ydCBjbGFzcyBUZXh0dXJlU2tldGNoIGV4dGVuZHMgVGV4dHVyZUNhbnZhcyB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRleHR1cmUgY3JlYXRlZCBmcm9tIGFuIEhUTUwtcGFnZVxyXG4gICAgICovXHJcbiAgICBleHBvcnQgY2xhc3MgVGV4dHVyZUhUTUwgZXh0ZW5kcyBUZXh0dXJlQ2FudmFzIHtcclxuICAgIH1cclxufSIsIi8vIC88cmVmZXJlbmNlIHBhdGg9XCIuLi9FdmVudC9FdmVudC50c1wiLz5cclxuLy8gLzxyZWZlcmVuY2UgcGF0aD1cIi4uL1RpbWUvVGltZS50c1wiLz5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lcyB0aGUgbW9kZSBhIGxvb3AgcnVucyBpblxyXG4gICAqL1xyXG4gIGV4cG9ydCBlbnVtIExPT1BfTU9ERSB7XHJcbiAgICAvKiogTG9vcCBjeWNsZXMgY29udHJvbGxlZCBieSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICovXHJcbiAgICBGUkFNRV9SRVFVRVNUID0gXCJmcmFtZVJlcXVlc3RcIixcclxuICAgIC8qKiBMb29wIGN5Y2xlcyB3aXRoIHRoZSBnaXZlbiBmcmFtZXJhdGUgaW4gW1tUaW1lXV0uZ2FtZSAqL1xyXG4gICAgVElNRV9HQU1FID0gXCJ0aW1lR2FtZVwiLFxyXG4gICAgLyoqIExvb3AgY3ljbGVzIHdpdGggdGhlIGdpdmVuIGZyYW1lcmF0ZSBpbiByZWFsdGltZSwgaW5kZXBlbmRlbnQgb2YgW1tUaW1lXV0uZ2FtZSAqL1xyXG4gICAgVElNRV9SRUFMID0gXCJ0aW1lUmVhbFwiXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb3JlIGxvb3Agb2YgYSBGdWRnZSBhcHBsaWNhdGlvbi4gSW5pdGlhbGl6ZXMgYXV0b21hdGljYWxseSBhbmQgbXVzdCBiZSBzdGFydGVkIGV4cGxpY2l0bHkuXHJcbiAgICogSXQgdGhlbiBmaXJlcyBbW0VWRU5UXV0uTE9PUFxcX0ZSQU1FIHRvIGFsbCBhZGRlZCBsaXN0ZW5lcnMgYXQgZWFjaCBmcmFtZVxyXG4gICAqIFxyXG4gICAqIEBhdXRob3IgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgTG9vcCBleHRlbmRzIEV2ZW50VGFyZ2V0U3RhdGljIHtcclxuICAgIC8qKiBUaGUgZ2FtZXRpbWUgdGhlIGxvb3Agd2FzIHN0YXJ0ZWQsIG92ZXJ3cml0dGVuIGF0IGVhY2ggc3RhcnQgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgdGltZVN0YXJ0R2FtZTogbnVtYmVyID0gMDtcclxuICAgIC8qKiBUaGUgcmVhbHRpbWUgdGhlIGxvb3Agd2FzIHN0YXJ0ZWQsIG92ZXJ3cml0dGVuIGF0IGVhY2ggc3RhcnQgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgdGltZVN0YXJ0UmVhbDogbnVtYmVyID0gMDtcclxuICAgIC8qKiBUaGUgZ2FtZXRpbWUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCBsb29wIGN5Y2xlICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHRpbWVGcmFtZUdhbWU6IG51bWJlciA9IDA7XHJcbiAgICAvKiogVGhlIHJlYWx0aW1lIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgbG9vcCBjeWNsZSAqL1xyXG4gICAgcHVibGljIHN0YXRpYyB0aW1lRnJhbWVSZWFsOiBudW1iZXIgPSAwO1xyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIHRpbWVMYXN0RnJhbWVHYW1lOiBudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgdGltZUxhc3RGcmFtZVJlYWw6IG51bWJlciA9IDA7XHJcbiAgICBwcml2YXRlIHN0YXRpYyB0aW1lTGFzdEZyYW1lR2FtZUF2ZzogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgc3RhdGljIHRpbWVMYXN0RnJhbWVSZWFsQXZnOiBudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcnVubmluZzogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgbW9kZTogTE9PUF9NT0RFID0gTE9PUF9NT0RFLkZSQU1FX1JFUVVFU1Q7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBpZEludGVydmFsbDogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgc3RhdGljIGlkUmVxdWVzdDogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgc3RhdGljIGZwc0Rlc2lyZWQ6IG51bWJlciA9IDMwO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZnJhbWVzVG9BdmVyYWdlOiBudW1iZXIgPSAzMDtcclxuICAgIHByaXZhdGUgc3RhdGljIHN5bmNXaXRoQW5pbWF0aW9uRnJhbWU6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0cyB0aGUgbG9vcCB3aXRoIHRoZSBnaXZlbiBtb2RlIGFuZCBmcHNcclxuICAgICAqIEBwYXJhbSBfbW9kZSBcclxuICAgICAqIEBwYXJhbSBfZnBzIElzIG9ubHkgYXBwbGljYWJsZSBpbiBUSU1FLW1vZGVzXHJcbiAgICAgKiBAcGFyYW0gX3N5bmNXaXRoQW5pbWF0aW9uRnJhbWUgRXhwZXJpbWVudGFsIGFuZCBvbmx5IGFwcGxpY2FibGUgaW4gVElNRS1tb2Rlcy4gU2hvdWxkIGRlZmVyIHRoZSBsb29wLWN5Y2xlIHVudGlsIHRoZSBuZXh0IHBvc3NpYmxlIGFuaW1hdGlvbiBmcmFtZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzdGFydChfbW9kZTogTE9PUF9NT0RFID0gTE9PUF9NT0RFLkZSQU1FX1JFUVVFU1QsIF9mcHM6IG51bWJlciA9IDYwLCBfc3luY1dpdGhBbmltYXRpb25GcmFtZTogYm9vbGVhbiA9IGZhbHNlKTogdm9pZCB7XHJcbiAgICAgIExvb3Auc3RvcCgpO1xyXG5cclxuICAgICAgTG9vcC50aW1lU3RhcnRHYW1lID0gVGltZS5nYW1lLmdldCgpO1xyXG4gICAgICBMb29wLnRpbWVTdGFydFJlYWwgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgTG9vcC50aW1lTGFzdEZyYW1lR2FtZSA9IExvb3AudGltZVN0YXJ0R2FtZTtcclxuICAgICAgTG9vcC50aW1lTGFzdEZyYW1lUmVhbCA9IExvb3AudGltZVN0YXJ0UmVhbDtcclxuICAgICAgTG9vcC5mcHNEZXNpcmVkID0gKF9tb2RlID09IExPT1BfTU9ERS5GUkFNRV9SRVFVRVNUKSA/IDYwIDogX2ZwcztcclxuICAgICAgTG9vcC5mcmFtZXNUb0F2ZXJhZ2UgPSBMb29wLmZwc0Rlc2lyZWQ7XHJcbiAgICAgIExvb3AudGltZUxhc3RGcmFtZUdhbWVBdmcgPSBMb29wLnRpbWVMYXN0RnJhbWVSZWFsQXZnID0gMTAwMCAvIExvb3AuZnBzRGVzaXJlZDtcclxuICAgICAgTG9vcC5tb2RlID0gX21vZGU7XHJcbiAgICAgIExvb3Auc3luY1dpdGhBbmltYXRpb25GcmFtZSA9IF9zeW5jV2l0aEFuaW1hdGlvbkZyYW1lO1xyXG5cclxuICAgICAgbGV0IGxvZzogc3RyaW5nID0gYExvb3Agc3RhcnRpbmcgaW4gbW9kZSAke0xvb3AubW9kZX1gO1xyXG4gICAgICBpZiAoTG9vcC5tb2RlICE9IExPT1BfTU9ERS5GUkFNRV9SRVFVRVNUKVxyXG4gICAgICAgIGxvZyArPSBgIHdpdGggYXR0ZW1wdGVkICR7X2Zwc30gZnBzYDtcclxuICAgICAgRGVidWcuZnVkZ2UobG9nKTtcclxuXHJcbiAgICAgIHN3aXRjaCAoX21vZGUpIHtcclxuICAgICAgICBjYXNlIExPT1BfTU9ERS5GUkFNRV9SRVFVRVNUOlxyXG4gICAgICAgICAgTG9vcC5sb29wRnJhbWUoKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgTE9PUF9NT0RFLlRJTUVfUkVBTDpcclxuICAgICAgICAgIExvb3AuaWRJbnRlcnZhbGwgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoTG9vcC5sb29wVGltZSwgMTAwMCAvIExvb3AuZnBzRGVzaXJlZCk7XHJcbiAgICAgICAgICBMb29wLmxvb3BUaW1lKCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIExPT1BfTU9ERS5USU1FX0dBTUU6XHJcbiAgICAgICAgICBMb29wLmlkSW50ZXJ2YWxsID0gVGltZS5nYW1lLnNldFRpbWVyKDEwMDAgLyBMb29wLmZwc0Rlc2lyZWQsIDAsIExvb3AubG9vcFRpbWUpO1xyXG4gICAgICAgICAgTG9vcC5sb29wVGltZSgpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBMb29wLnJ1bm5pbmcgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgdGhlIGxvb3BcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzdG9wKCk6IHZvaWQge1xyXG4gICAgICBpZiAoIUxvb3AucnVubmluZylcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBzd2l0Y2ggKExvb3AubW9kZSkge1xyXG4gICAgICAgIGNhc2UgTE9PUF9NT0RFLkZSQU1FX1JFUVVFU1Q6XHJcbiAgICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoTG9vcC5pZFJlcXVlc3QpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBMT09QX01PREUuVElNRV9SRUFMOlxyXG4gICAgICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwoTG9vcC5pZEludGVydmFsbCk7XHJcbiAgICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoTG9vcC5pZFJlcXVlc3QpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBMT09QX01PREUuVElNRV9HQU1FOlxyXG4gICAgICAgICAgVGltZS5nYW1lLmRlbGV0ZVRpbWVyKExvb3AuaWRJbnRlcnZhbGwpO1xyXG4gICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKExvb3AuaWRSZXF1ZXN0KTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgICAgTG9vcC5ydW5uaW5nID0gZmFsc2U7XHJcbiAgICAgIERlYnVnLmZ1ZGdlKFwiTG9vcCBzdG9wcGVkIVwiKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldEZwc0dhbWVBdmVyYWdlKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiAxMDAwIC8gTG9vcC50aW1lTGFzdEZyYW1lR2FtZUF2ZztcclxuICAgIH1cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0RnBzUmVhbEF2ZXJhZ2UoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIDEwMDAgLyBMb29wLnRpbWVMYXN0RnJhbWVSZWFsQXZnO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGxvb3AoKTogdm9pZCB7XHJcbiAgICAgIGxldCB0aW1lOiBudW1iZXI7XHJcbiAgICAgIHRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgTG9vcC50aW1lRnJhbWVSZWFsID0gdGltZSAtIExvb3AudGltZUxhc3RGcmFtZVJlYWw7XHJcbiAgICAgIExvb3AudGltZUxhc3RGcmFtZVJlYWwgPSB0aW1lO1xyXG5cclxuICAgICAgdGltZSA9IFRpbWUuZ2FtZS5nZXQoKTtcclxuICAgICAgTG9vcC50aW1lRnJhbWVHYW1lID0gdGltZSAtIExvb3AudGltZUxhc3RGcmFtZUdhbWU7XHJcbiAgICAgIExvb3AudGltZUxhc3RGcmFtZUdhbWUgPSB0aW1lO1xyXG5cclxuICAgICAgTG9vcC50aW1lTGFzdEZyYW1lR2FtZUF2ZyA9ICgoTG9vcC5mcmFtZXNUb0F2ZXJhZ2UgLSAxKSAqIExvb3AudGltZUxhc3RGcmFtZUdhbWVBdmcgKyBMb29wLnRpbWVGcmFtZUdhbWUpIC8gTG9vcC5mcmFtZXNUb0F2ZXJhZ2U7XHJcbiAgICAgIExvb3AudGltZUxhc3RGcmFtZVJlYWxBdmcgPSAoKExvb3AuZnJhbWVzVG9BdmVyYWdlIC0gMSkgKiBMb29wLnRpbWVMYXN0RnJhbWVSZWFsQXZnICsgTG9vcC50aW1lRnJhbWVSZWFsKSAvIExvb3AuZnJhbWVzVG9BdmVyYWdlO1xyXG5cclxuICAgICAgLy8gVE9ETzogY29uc2lkZXIgTG9vcEV2ZW50IHdoaWNoIGNvbnZleXMgaW5mb3JtYXRpb24gc3VjaCBhcyB0aW1lRWxhcHNlZCBldGMuLi5cclxuICAgICAgbGV0IGV2ZW50OiBFdmVudCA9IG5ldyBFdmVudChFVkVOVC5MT09QX0ZSQU1FKTtcclxuICAgICAgTG9vcC50YXJnZXRTdGF0aWMuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgbG9vcEZyYW1lKCk6IHZvaWQge1xyXG4gICAgICBMb29wLmxvb3AoKTtcclxuICAgICAgTG9vcC5pZFJlcXVlc3QgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKExvb3AubG9vcEZyYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBsb29wVGltZSgpOiB2b2lkIHtcclxuICAgICAgaWYgKExvb3Auc3luY1dpdGhBbmltYXRpb25GcmFtZSlcclxuICAgICAgICBMb29wLmlkUmVxdWVzdCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoTG9vcC5sb29wKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIExvb3AubG9vcCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgaW50ZXJmYWNlIFRpbWVVbml0cyB7XHJcbiAgICBob3Vycz86IG51bWJlcjtcclxuICAgIG1pbnV0ZXM/OiBudW1iZXI7XHJcbiAgICBzZWNvbmRzPzogbnVtYmVyO1xyXG4gICAgdGVudGhzPzogbnVtYmVyO1xyXG4gICAgaHVuZHJlZHM/OiBudW1iZXI7XHJcbiAgICB0aG91c2FuZHM/OiBudW1iZXI7XHJcbiAgICBmcmFjdGlvbj86IG51bWJlcjtcclxuICAgIGFzSG91cnM/OiBudW1iZXI7XHJcbiAgICBhc01pbnV0ZXM/OiBudW1iZXI7XHJcbiAgICBhc1NlY29uZHM/OiBudW1iZXI7XHJcbiAgfVxyXG5cclxuICBleHBvcnQgaW50ZXJmYWNlIFRpbWVycyBleHRlbmRzIE9iamVjdCB7XHJcbiAgICBbaWQ6IG51bWJlcl06IFRpbWVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MgZ2VuZXJhdGUgYSB0aW1lc3RhbXAgdGhhdCBjb3JyZWxhdGVzIHdpdGggdGhlIHRpbWUgZWxhcHNlZCBzaW5jZSB0aGUgc3RhcnQgb2YgdGhlIHByb2dyYW0gYnV0IGFsbG93cyBmb3IgcmVzZXR0aW5nIGFuZCBzY2FsaW5nLiAgXHJcbiAgICogU3VwcG9ydHMgW1tUaW1lcl1dcyBzaW1pbGFyIHRvIHdpbmRvdy5zZXRJbnRlcnZhbCBidXQgd2l0aCByZXNwZWN0IHRvIHRoZSBzY2FsZWQgdGltZS5cclxuICAgKiBBbGwgdGltZSB2YWx1ZXMgYXJlIGdpdmVuIGluIG1pbGxpc2Vjb25kc1xyXG4gICAqIFxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFRpbWUgZXh0ZW5kcyBFdmVudFRhcmdldMaSIHtcclxuICAgIC8qKiBTdGFuZGFyZCBnYW1lIHRpbWUgc3RhcnRpbmcgYXV0b21hdGljYWxseSB3aXRoIHRoZSBhcHBsaWNhdGlvbiAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBnYW1lOiBUaW1lID0gbmV3IFRpbWUoKTtcclxuICAgIHByaXZhdGUgc3RhcnQ6IG51bWJlcjtcclxuICAgIHByaXZhdGUgc2NhbGU6IG51bWJlcjtcclxuICAgIHByaXZhdGUgb2Zmc2V0OiBudW1iZXI7XHJcbiAgICBwcml2YXRlIGxhc3RDYWxsVG9FbGFwc2VkOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIHRpbWVyczogVGltZXJzID0ge307XHJcbiAgICBwcml2YXRlIGlkVGltZXJOZXh0OiBudW1iZXIgPSAwO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLnN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgIHRoaXMuc2NhbGUgPSAxLjA7XHJcbiAgICAgIHRoaXMub2Zmc2V0ID0gMC4wO1xyXG4gICAgICB0aGlzLmxhc3RDYWxsVG9FbGFwc2VkID0gMC4wO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZ2FtZS10aW1lLW9iamVjdCB3aGljaCBzdGFydHMgYXV0b21hdGljYWxseSBhbmQgc2VydmVzIGFzIGJhc2UgZm9yIHZhcmlvdXMgaW50ZXJuYWwgb3BlcmF0aW9ucy4gXHJcbiAgICAgKi9cclxuICAgIC8vIHB1YmxpYyBzdGF0aWMgZ2V0IGdhbWUoKTogVGltZSB7XHJcbiAgICAvLyAgIHJldHVybiBUaW1lLmdhbWVUaW1lO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0VW5pdHMoX21pbGxpc2Vjb25kczogbnVtYmVyKTogVGltZVVuaXRzIHtcclxuICAgICAgbGV0IHVuaXRzOiBUaW1lVW5pdHMgPSB7fTtcclxuXHJcbiAgICAgIHVuaXRzLmFzU2Vjb25kcyA9IF9taWxsaXNlY29uZHMgLyAxMDAwO1xyXG4gICAgICB1bml0cy5hc01pbnV0ZXMgPSB1bml0cy5hc1NlY29uZHMgLyA2MDtcclxuICAgICAgdW5pdHMuYXNIb3VycyA9IHVuaXRzLmFzTWludXRlcyAvIDYwO1xyXG5cclxuICAgICAgdW5pdHMuaG91cnMgPSBNYXRoLmZsb29yKHVuaXRzLmFzSG91cnMpO1xyXG4gICAgICB1bml0cy5taW51dGVzID0gTWF0aC5mbG9vcih1bml0cy5hc01pbnV0ZXMpICUgNjA7XHJcbiAgICAgIHVuaXRzLnNlY29uZHMgPSBNYXRoLmZsb29yKHVuaXRzLmFzU2Vjb25kcykgJSA2MDtcclxuXHJcbiAgICAgIHVuaXRzLmZyYWN0aW9uID0gX21pbGxpc2Vjb25kcyAlIDEwMDA7XHJcbiAgICAgIHVuaXRzLnRob3VzYW5kcyA9IF9taWxsaXNlY29uZHMgJSAxMDtcclxuICAgICAgdW5pdHMuaHVuZHJlZHMgPSBfbWlsbGlzZWNvbmRzICUgMTAwIC0gdW5pdHMudGhvdXNhbmRzO1xyXG4gICAgICB1bml0cy50ZW50aHMgPSB1bml0cy5mcmFjdGlvbiAtIHVuaXRzLmh1bmRyZWRzIC0gdW5pdHMudGhvdXNhbmRzO1xyXG5cclxuICAgICAgcmV0dXJuIHVuaXRzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBHZXQvU2V0IHRpbWUgYW5kIHNjYWxpbmdcclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIHRoZSBjdXJyZW50IHNjYWxlZCB0aW1lc3RhbXAgb2YgdGhpcyBpbnN0YW5jZSBpbiBtaWxsaXNlY29uZHNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5vZmZzZXQgKyB0aGlzLnNjYWxlICogKHBlcmZvcm1hbmNlLm5vdygpIC0gdGhpcy5zdGFydCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSByZW1haW5pbmcgdGltZSB0byB0aGUgZ2l2ZW4gcG9pbnQgb2YgdGltZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0UmVtYWluZGVyKF90bzogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIF90byAtIHRoaXMuZ2V0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAoUmUtKSBTZXRzIHRoZSB0aW1lc3RhbXAgb2YgdGhpcyBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIF90aW1lIFRoZSB0aW1lc3RhbXAgdG8gcmVwcmVzZW50IHRoZSBjdXJyZW50IHRpbWUgKGRlZmF1bHQgMC4wKVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0KF90aW1lOiBudW1iZXIgPSAwKTogdm9pZCB7XHJcbiAgICAgIHRoaXMub2Zmc2V0ID0gX3RpbWU7XHJcbiAgICAgIHRoaXMuc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgdGhpcy5nZXRFbGFwc2VkU2luY2VQcmV2aW91c0NhbGwoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHNjYWxpbmcgb2YgdGhpcyB0aW1lLCBhbGxvd2luZyBmb3Igc2xvd21vdGlvbiAoPDEpIG9yIGZhc3Rmb3J3YXJkICg+MSkgXHJcbiAgICAgKiBAcGFyYW0gX3NjYWxlIFRoZSBkZXNpcmVkIHNjYWxpbmcgKGRlZmF1bHQgMS4wKVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0U2NhbGUoX3NjYWxlOiBudW1iZXIgPSAxLjApOiB2b2lkIHtcclxuICAgICAgdGhpcy5zZXQodGhpcy5nZXQoKSk7XHJcbiAgICAgIHRoaXMuc2NhbGUgPSBfc2NhbGU7XHJcbiAgICAgIC8vVE9ETzogY2F0Y2ggc2NhbGU9MFxyXG4gICAgICB0aGlzLnJlc2NhbGVBbGxUaW1lcnMoKTtcclxuICAgICAgdGhpcy5nZXRFbGFwc2VkU2luY2VQcmV2aW91c0NhbGwoKTtcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVC5USU1FX1NDQUxFRCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIHRoZSBjdXJyZW50IHNjYWxpbmcgb2YgdGhpcyB0aW1lXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRTY2FsZSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5zY2FsZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyB0aGUgb2Zmc2V0IG9mIHRoaXMgdGltZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0T2Zmc2V0KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLm9mZnNldDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyB0aGUgc2NhbGVkIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHBhc3NlZCBzaW5jZSB0aGUgbGFzdCBjYWxsIHRvIHRoaXMgbWV0aG9kXHJcbiAgICAgKiBBdXRvbWF0aWNhbGx5IHJlc2V0IGF0IGV2ZXJ5IGNhbGwgdG8gc2V0KC4uLikgYW5kIHNldFNjYWxlKC4uLilcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEVsYXBzZWRTaW5jZVByZXZpb3VzQ2FsbCgpOiBudW1iZXIge1xyXG4gICAgICBsZXQgY3VycmVudDogbnVtYmVyID0gdGhpcy5nZXQoKTtcclxuICAgICAgbGV0IGVsYXBzZWQ6IG51bWJlciA9IGN1cnJlbnQgLSB0aGlzLmxhc3RDYWxsVG9FbGFwc2VkO1xyXG4gICAgICB0aGlzLmxhc3RDYWxsVG9FbGFwc2VkID0gY3VycmVudDtcclxuICAgICAgcmV0dXJuIGVsYXBzZWQ7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcblxyXG4gICAgLy8jcmVnaW9uIFRpbWVyc1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgUHJvbWlzZTx2b2lkPiB0byBiZSByZXNvbHZlZCBhZnRlciB0aGUgdGltZSBnaXZlbi4gVG8gYmUgdXNlZCB3aXRoIGFzeW5jL2F3YWl0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBkZWxheShfbGFwc2U6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoX3Jlc29sdmUgPT4gdGhpcy5zZXRUaW1lcihfbGFwc2UsIDEsICgpID0+IF9yZXNvbHZlKCkpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPOiBleGFtaW5lIGlmIHdlYi13b3JrZXJzIHdvdWxkIGVuaGFuY2UgcGVyZm9ybWFuY2UgaGVyZSFcclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgYW5kIGRlbGV0ZXMgYWxsIFtbVGltZXJdXXMgYXR0YWNoZWQuIFNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIHRoaXMgVGltZS1vYmplY3QgbGVhdmVzIHNjb3BlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjbGVhckFsbFRpbWVycygpOiB2b2lkIHtcclxuICAgICAgZm9yIChsZXQgaWQgaW4gdGhpcy50aW1lcnMpIHtcclxuICAgICAgICB0aGlzLmRlbGV0ZVRpbWVyKE51bWJlcihpZCkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGVzIFtbVGltZXJdXSBmb3VuZCB1c2luZyB0aGUgaW50ZXJuYWwgaWQgb2YgdGhlIGNvbm5lY3RlZCBpbnRlcnZhbC1vYmplY3RcclxuICAgICAqIEBwYXJhbSBfaWQgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBkZWxldGVUaW1lckJ5SXRzSW50ZXJuYWxJZChfaWQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICBmb3IgKGxldCBpZCBpbiB0aGlzLnRpbWVycykge1xyXG4gICAgICAgIGxldCB0aW1lcjogVGltZXIgPSB0aGlzLnRpbWVyc1tpZF07XHJcbiAgICAgICAgaWYgKHRpbWVyLmlkID09IF9pZCkge1xyXG4gICAgICAgICAgdGltZXIuY2xlYXIoKTtcclxuICAgICAgICAgIGRlbGV0ZSB0aGlzLnRpbWVyc1tpZF07XHJcbiAgICAgICAgICAvLyBUT0RPOiBjaGVjayBpZiBhbiBlYXJseSBvdXQgaXMgT0sgaGVyZS4uLiBzaG91bGQgYmUhXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnN0YWxscyBhIHRpbWVyIGF0IHRoaXMgdGltZSBvYmplY3RcclxuICAgICAqIEBwYXJhbSBfbGFwc2UgVGhlIG9iamVjdC10aW1lIHRvIGVsYXBzZSBiZXR3ZWVuIHRoZSBjYWxscyB0byBfY2FsbGJhY2tcclxuICAgICAqIEBwYXJhbSBfY291bnQgVGhlIG51bWJlciBvZiBjYWxscyBkZXNpcmVkLCAwID0gSW5maW5pdGVcclxuICAgICAqIEBwYXJhbSBfaGFuZGxlciBUaGUgZnVuY3Rpb24gdG8gY2FsbCBlYWNoIHRoZSBnaXZlbiBsYXBzZSBoYXMgZWxhcHNlZFxyXG4gICAgICogQHBhcmFtIF9hcmd1bWVudHMgQWRkaXRpb25hbCBwYXJhbWV0ZXJzIHRvIHBhc3MgdG8gY2FsbGJhY2sgZnVuY3Rpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFRpbWVyKF9sYXBzZTogbnVtYmVyLCBfY291bnQ6IG51bWJlciwgX2hhbmRsZXI6IFRpbWVySGFuZGxlciwgLi4uX2FyZ3VtZW50czogT2JqZWN0W10pOiBudW1iZXIge1xyXG4gICAgICBsZXQgdGltZXI6IFRpbWVyID0gbmV3IFRpbWVyKHRoaXMsIF9sYXBzZSwgX2NvdW50LCBfaGFuZGxlciwgX2FyZ3VtZW50cyk7XHJcbiAgICAgIHRoaXMudGltZXJzWysrdGhpcy5pZFRpbWVyTmV4dF0gPSB0aW1lcjtcclxuICAgICAgcmV0dXJuIHRoaXMuaWRUaW1lck5leHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGVzIHRoZSB0aW1lciB3aXRoIHRoZSBpZCBnaXZlbiBieSB0aGlzIHRpbWUgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBkZWxldGVUaW1lcihfaWQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICBsZXQgdGltZXI6IFRpbWVyID0gdGhpcy50aW1lcnNbX2lkXTtcclxuICAgICAgaWYgKCF0aW1lcilcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIHRpbWVyLmNsZWFyKCk7XHJcbiAgICAgIGRlbGV0ZSB0aGlzLnRpbWVyc1tfaWRdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgdGltZXIgd2l0aCB0aGUgZ2l2ZW4gaWQgb3IgbnVsbCBpZiBub3QgZm91bmQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRUaW1lcihfaWQ6IG51bWJlcik6IFRpbWVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMudGltZXJzW19pZF07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgbGlzdCBvZiB0aW1lcnMgY3VycmVudGx5IGluc3RhbGxlZCBvbiB0aGlzIHRpbWUgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRUaW1lcnMoKTogVGltZXJzIHtcclxuICAgICAgbGV0IHJlc3VsdDogVGltZXJzID0ge307XHJcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHJlc3VsdCwgdGhpcy50aW1lcnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZXJlIGFyZSBbW1RpbWVyc11dIGluc3RhbGxlZCB0byB0aGlzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBoYXNUaW1lcnMoKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiAoT2JqZWN0LmtleXModGhpcy50aW1lcnMpLmxlbmd0aCA+IDApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVjcmVhdGVzIFtbVGltZXJdXXMgd2hlbiBzY2FsaW5nIGNoYW5nZXNcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSByZXNjYWxlQWxsVGltZXJzKCk6IHZvaWQge1xyXG4gICAgICBmb3IgKGxldCBpZCBpbiB0aGlzLnRpbWVycykge1xyXG4gICAgICAgIGxldCB0aW1lcjogVGltZXIgPSB0aGlzLnRpbWVyc1tpZF07XHJcbiAgICAgICAgdGltZXIuY2xlYXIoKTtcclxuICAgICAgICBpZiAoIXRoaXMuc2NhbGUpXHJcbiAgICAgICAgICAvLyBUaW1lIGhhcyBzdG9wcGVkLCBubyBuZWVkIHRvIHJlcGxhY2UgY2xlYXJlZCB0aW1lcnNcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICB0aGlzLnRpbWVyc1tpZF0gPSB0aW1lci5pbnN0YWxsQ29weSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vI2VuZHJlZ2lvblxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogRGVmaW5lcyB0aGUgc2lnbmF0dXJlIG9mIGhhbmRsZXIgZnVuY3Rpb25zIGZvciBbW1RpbWVyRXZlbnTGkl1dcywgdmVyeSBzaW1pbGFyIHRvIHVzdWFsIGV2ZW50IGhhbmRsZXJcclxuICAgKi9cclxuICBleHBvcnQgdHlwZSBUaW1lckhhbmRsZXIgPSAoX2V2ZW50OiBFdmVudFRpbWVyKSA9PiB2b2lkO1xyXG5cclxuICAvKipcclxuICAgKiBBIFtbVGltZXJdXS1pbnN0YW5jZSBpbnRlcm5hbGx5IHVzZXMgd2luZG93LnNldEludGVydmFsIHRvIGNhbGwgYSBnaXZlbiBoYW5kbGVyIHdpdGggYSBnaXZlbiBmcmVxdWVuY3kgYSBnaXZlbiBudW1iZXIgb2YgdGltZXMsXHJcbiAgICogcGFzc2luZyBhbiBbW1RpbWVyRXZlbnTGkl1dLWluc3RhbmNlIHdpdGggYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhbmQgZ2l2ZW4gYXJndW1lbnRzLiBcclxuICAgKiBUaGUgZnJlcXVlbmN5IHNjYWxlcyB3aXRoIHRoZSBbW1RpbWVdXS1pbnN0YW5jZSB0aGUgW1tUaW1lcl1dLWluc3RhbmNlIGlzIGF0dGFjaGVkIHRvLlxyXG4gICAqIFxyXG4gICAqIEBhdXRob3IgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgVGltZXIge1xyXG4gICAgcHVibGljIGFjdGl2ZTogYm9vbGVhbjtcclxuICAgIHB1YmxpYyBjb3VudDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBoYW5kbGVyOiBUaW1lckhhbmRsZXI7XHJcbiAgICBwcml2YXRlIHRpbWU6IFRpbWU7XHJcbiAgICBwcml2YXRlIGVsYXBzZTogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBldmVudDogRXZlbnRUaW1lcjtcclxuICAgIHByaXZhdGUgdGltZW91dFJlYWw6IG51bWJlcjtcclxuICAgIHByaXZhdGUgaWRXaW5kb3c6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBbW1RpbWVyXV0gaW5zdGFuY2UuXHJcbiAgICAgKiBAcGFyYW0gX3RpbWUgVGhlIFtbVGltZV1dIGluc3RhbmNlLCB0aGUgdGltZXIgYXR0YWNoZXMgdG9cclxuICAgICAqIEBwYXJhbSBfZWxhcHNlIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyB0byBlbGFwc2UsIHRvIHRoZSBuZXh0IGNhbGwgb2YgX2hhbmRsZXIsIG1lYXN1cmVkIGluIF90aW1lXHJcbiAgICAgKiBAcGFyYW0gX2NvdW50IFRoZSBkZXNpcmVkIG51bWJlciBvZiBjYWxscyB0byBfaGFuZGxlciwgVGltZXIgZGVpbnN0YWxscyBhdXRvbWF0aWNhbGx5IGFmdGVyIGxhc3QgY2FsbC4gUGFzc2luZyAwIGludm9rZXMgaW5maW5pdGUgY2FsbHNcclxuICAgICAqIEBwYXJhbSBfaGFuZGxlciBUaGUgW1tUaW1lckhhbmRsZXJdXSBpbnN0YW5jZSB0byBjYWxsXHJcbiAgICAgKiBAcGFyYW0gX2FyZ3VtZW50cyBBZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBwYXNzIHRvIF9oYW5kbGVyXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKF90aW1lOiBUaW1lLCBfZWxhcHNlOiBudW1iZXIsIF9jb3VudDogbnVtYmVyLCBfaGFuZGxlcjogVGltZXJIYW5kbGVyLCAuLi5fYXJndW1lbnRzOiBPYmplY3RbXSkge1xyXG4gICAgICB0aGlzLnRpbWUgPSBfdGltZTtcclxuICAgICAgdGhpcy5lbGFwc2UgPSBfZWxhcHNlO1xyXG4gICAgICB0aGlzLmV2ZW50ID0gbmV3IEV2ZW50VGltZXIodGhpcywgX2FyZ3VtZW50cyk7XHJcbiAgICAgIHRoaXMuaGFuZGxlciA9IF9oYW5kbGVyO1xyXG4gICAgICB0aGlzLmNvdW50ID0gX2NvdW50O1xyXG5cclxuICAgICAgbGV0IHNjYWxlOiBudW1iZXIgPSBNYXRoLmFicyhfdGltZS5nZXRTY2FsZSgpKTtcclxuXHJcbiAgICAgIGlmICghc2NhbGUpIHtcclxuICAgICAgICAvLyBUaW1lIGlzIHN0b3BwZWQsIHRpbWVyIHdvbid0IGJlIGFjdGl2ZVxyXG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnRpbWVvdXRSZWFsID0gdGhpcy5lbGFwc2UgLyBzY2FsZTtcclxuXHJcbiAgICAgIGxldCBjYWxsYmFjazogRnVuY3Rpb24gPSAoKTogdm9pZCA9PiB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSlcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIFxyXG4gICAgICAgIHRoaXMuZXZlbnQubGFzdENhbGwgPSAodGhpcy5jb3VudCA9PSAxKTtcclxuICAgICAgICBfaGFuZGxlcih0aGlzLmV2ZW50KTtcclxuICAgICAgICB0aGlzLmV2ZW50LmZpcnN0Q2FsbCA9IGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5jb3VudCA+IDApXHJcbiAgICAgICAgICBpZiAoLS10aGlzLmNvdW50ID09IDApXHJcbiAgICAgICAgICAgIF90aW1lLmRlbGV0ZVRpbWVyQnlJdHNJbnRlcm5hbElkKHRoaXMuaWRXaW5kb3cpO1xyXG5cclxuICAgICAgfTtcclxuXHJcbiAgICAgIHRoaXMuaWRXaW5kb3cgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoY2FsbGJhY2ssIHRoaXMudGltZW91dFJlYWwsIF9hcmd1bWVudHMpO1xyXG4gICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB3aW5kb3ctaWQgb2YgdGhlIHRpbWVyLCB3aGljaCB3YXMgcmV0dXJuZWQgYnkgc2V0SW50ZXJ2YWxcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBpZCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5pZFdpbmRvdztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHRpbWUtaW50ZXJ2YWxsIGZvciBjYWxscyB0byB0aGUgaGFuZGxlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGxhcHNlKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmVsYXBzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEF0dGFjaGVzIGEgY29weSBvZiB0aGlzIGF0IGl0cyBjdXJyZW50IHN0YXRlIHRvIHRoZSBzYW1lIFtbVGltZV1dLWluc3RhbmNlLiBVc2VkIGludGVybmFsbHkgd2hlbiByZXNjYWxpbmcgW1tUaW1lXV1cclxuICAgICAqL1xyXG4gICAgcHVibGljIGluc3RhbGxDb3B5KCk6IFRpbWVyIHtcclxuICAgICAgcmV0dXJuIG5ldyBUaW1lcih0aGlzLnRpbWUsIHRoaXMuZWxhcHNlLCB0aGlzLmNvdW50LCB0aGlzLmhhbmRsZXIsIHRoaXMuZXZlbnQuYXJndW1lbnRzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyB0aGUgdGltZXIsIHJlbW92aW5nIGl0IGZyb20gdGhlIGludGVydmFsLXRpbWVycyBoYW5kbGVkIGJ5IHdpbmRvd1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY2xlYXIoKTogdm9pZCB7XHJcbiAgICAgIC8vIGlmICh0aGlzLnR5cGUgPT0gVElNRVJfVFlQRS5USU1FT1VUKSB7XHJcbiAgICAgIC8vICAgICBpZiAodGhpcy5hY3RpdmUpXHJcbiAgICAgIC8vICAgICAgICAgLy8gc2F2ZSByZW1haW5pbmcgdGltZSB0byB0aW1lb3V0IGFzIG5ldyB0aW1lb3V0IGZvciByZXN0YXJ0XHJcbiAgICAgIC8vICAgICAgICAgdGhpcy50aW1lb3V0ID0gdGhpcy50aW1lb3V0ICogKDEgLSAocGVyZm9ybWFuY2Uubm93KCkgLSB0aGlzLnN0YXJ0VGltZVJlYWwpIC8gdGhpcy50aW1lb3V0UmVhbCk7XHJcbiAgICAgIC8vICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuaWQpO1xyXG4gICAgICAvLyB9XHJcbiAgICAgIC8vIGVsc2VcclxuICAgICAgLy8gVE9ETzogcmV1c2luZyB0aW1lciBzdGFydHMgaW50ZXJ2YWwgYW5ldy4gU2hvdWxkIGJlIHJlbWFpbmluZyBpbnRlcnZhbCBhcyB0aW1lb3V0LCB0aGVuIHN0YXJ0aW5nIGludGVydmFsIGFuZXcgXHJcbiAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuaWRXaW5kb3cpO1xyXG4gICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gICAgZXhwb3J0IGludGVyZmFjZSBNYXBGaWxlbmFtZVRvQ29udGVudCB7XHJcbiAgICAgICAgW2ZpbGVuYW1lOiBzdHJpbmddOiBzdHJpbmc7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXMgZmlsZSB0cmFuc2ZlciBmcm9tIGEgRnVkZ2UtQnJvd3NlcmFwcCB0byB0aGUgbG9jYWwgZmlsZXN5c3RlbSB3aXRob3V0IGEgbG9jYWwgc2VydmVyLiAgXHJcbiAgICAgKiBTYXZlcyB0byB0aGUgZG93bmxvYWQtcGF0aCBnaXZlbiBieSB0aGUgYnJvd3NlciwgbG9hZHMgZnJvbSB0aGUgcGxheWVyJ3MgY2hvaWNlLlxyXG4gICAgICovXHJcbiAgICBleHBvcnQgY2xhc3MgRmlsZUlvQnJvd3NlckxvY2FsIGV4dGVuZHMgRXZlbnRUYXJnZXRTdGF0aWMge1xyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIHNlbGVjdG9yOiBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgIC8vIFRPRE86IHJlZmFjdG9yIHRvIGFzeW5jIGZ1bmN0aW9uIHRvIGJlIGhhbmRsZWQgdXNpbmcgcHJvbWlzZSwgaW5zdGVhZCBvZiB1c2luZyBldmVudCB0YXJnZXRcclxuICAgICAgICBwdWJsaWMgc3RhdGljIGxvYWQoKTogdm9pZCB7XHJcbiAgICAgICAgICAgIEZpbGVJb0Jyb3dzZXJMb2NhbC5zZWxlY3RvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcclxuICAgICAgICAgICAgRmlsZUlvQnJvd3NlckxvY2FsLnNlbGVjdG9yLnR5cGUgPSBcImZpbGVcIjtcclxuICAgICAgICAgICAgRmlsZUlvQnJvd3NlckxvY2FsLnNlbGVjdG9yLm11bHRpcGxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgRmlsZUlvQnJvd3NlckxvY2FsLnNlbGVjdG9yLmhpZGRlbiA9IHRydWU7XHJcbiAgICAgICAgICAgIEZpbGVJb0Jyb3dzZXJMb2NhbC5zZWxlY3Rvci5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIEZpbGVJb0Jyb3dzZXJMb2NhbC5oYW5kbGVGaWxlU2VsZWN0KTtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChGaWxlSW9Ccm93c2VyTG9jYWwuc2VsZWN0b3IpO1xyXG4gICAgICAgICAgICBGaWxlSW9Ccm93c2VyTG9jYWwuc2VsZWN0b3IuY2xpY2soKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRPRE86IHJlZmFjdG9yIHRvIGFzeW5jIGZ1bmN0aW9uIHRvIGJlIGhhbmRsZWQgdXNpbmcgcHJvbWlzZSwgaW5zdGVhZCBvZiB1c2luZyBldmVudCB0YXJnZXRcclxuICAgICAgICBwdWJsaWMgc3RhdGljIHNhdmUoX3RvU2F2ZTogTWFwRmlsZW5hbWVUb0NvbnRlbnQpOiB2b2lkIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgZmlsZW5hbWUgaW4gX3RvU2F2ZSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvbnRlbnQ6IHN0cmluZyA9IF90b1NhdmVbZmlsZW5hbWVdO1xyXG4gICAgICAgICAgICAgICAgbGV0IGJsb2I6IEJsb2IgPSBuZXcgQmxvYihbY29udGVudF0sIHsgdHlwZTogXCJ0ZXh0L3BsYWluXCIgfSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgdXJsOiBzdHJpbmcgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcclxuICAgICAgICAgICAgICAgIC8vKi8gdXNpbmcgYW5jaG9yIGVsZW1lbnQgZm9yIGRvd25sb2FkXHJcbiAgICAgICAgICAgICAgICBsZXQgZG93bmxvYWRlcjogSFRNTEFuY2hvckVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICBkb3dubG9hZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XHJcbiAgICAgICAgICAgICAgICBkb3dubG9hZGVyLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgdXJsKTtcclxuICAgICAgICAgICAgICAgIGRvd25sb2FkZXIuc2V0QXR0cmlidXRlKFwiZG93bmxvYWRcIiwgZmlsZW5hbWUpO1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkb3dubG9hZGVyKTtcclxuICAgICAgICAgICAgICAgIGRvd25sb2FkZXIuY2xpY2soKTtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZG93bmxvYWRlcik7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cuVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgZXZlbnQ6IEN1c3RvbUV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KEVWRU5ULkZJTEVfU0FWRUQsIHsgZGV0YWlsOiB7IG1hcEZpbGVuYW1lVG9Db250ZW50OiBfdG9TYXZlIH0gfSk7XHJcbiAgICAgICAgICAgIEZpbGVJb0Jyb3dzZXJMb2NhbC50YXJnZXRTdGF0aWMuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGFzeW5jIGhhbmRsZUZpbGVTZWxlY3QoX2V2ZW50OiBFdmVudCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgICAgICBEZWJ1Zy5mdWRnZShcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGhhbmRsZUZpbGVTZWxlY3RcIik7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoRmlsZUlvQnJvd3NlckxvY2FsLnNlbGVjdG9yKTtcclxuICAgICAgICAgICAgbGV0IGZpbGVMaXN0OiBGaWxlTGlzdCA9ICg8SFRNTElucHV0RWxlbWVudD5fZXZlbnQudGFyZ2V0KS5maWxlcztcclxuICAgICAgICAgICAgRGVidWcuZnVkZ2UoZmlsZUxpc3QsIGZpbGVMaXN0Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGlmIChmaWxlTGlzdC5sZW5ndGggPT0gMClcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGxldCBsb2FkZWQ6IE1hcEZpbGVuYW1lVG9Db250ZW50ID0ge307XHJcbiAgICAgICAgICAgIGF3YWl0IEZpbGVJb0Jyb3dzZXJMb2NhbC5sb2FkRmlsZXMoZmlsZUxpc3QsIGxvYWRlZCk7XHJcblxyXG4gICAgICAgICAgICBsZXQgZXZlbnQ6IEN1c3RvbUV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KEVWRU5ULkZJTEVfTE9BREVELCB7IGRldGFpbDogeyBtYXBGaWxlbmFtZVRvQ29udGVudDogbG9hZGVkIH0gfSk7XHJcbiAgICAgICAgICAgIEZpbGVJb0Jyb3dzZXJMb2NhbC50YXJnZXRTdGF0aWMuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGFzeW5jIGxvYWRGaWxlcyhfZmlsZUxpc3Q6IEZpbGVMaXN0LCBfbG9hZGVkOiBNYXBGaWxlbmFtZVRvQ29udGVudCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBmaWxlIG9mIF9maWxlTGlzdCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudDogc3RyaW5nID0gYXdhaXQgbmV3IFJlc3BvbnNlKGZpbGUpLnRleHQoKTtcclxuICAgICAgICAgICAgICAgIF9sb2FkZWRbZmlsZS5uYW1lXSA9IGNvbnRlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0gIl19